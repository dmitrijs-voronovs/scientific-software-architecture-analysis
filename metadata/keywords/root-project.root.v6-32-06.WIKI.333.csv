id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://root.cern/root/html532/RooTFnPdfBinding.html:21758,Performance,optimiz,optimizeCacheMode,21758,"ialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html532/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTFnPdfBinding.html
https://root.cern/root/html532/RooTFnPdfBinding.html:26045,Performance,cache,cache,26045,"eam(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsPdf::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidRooAbsPdf::resetErrorCounters(Int_t resetValue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg:",MatchSource.WIKI,root/html532/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTFnPdfBinding.html
https://root.cern/root/html532/RooTFnPdfBinding.html:27331,Performance,cache,cache,27331,"irtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); voidRooAbsPdf::setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsPdf::setTraceCounter(Int_t value, Bool_t allNodes = kFALS",MatchSource.WIKI,root/html532/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTFnPdfBinding.html
https://root.cern/root/html532/RooTFnPdfBinding.html:29835,Performance,cache,cache,29835,"iqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig(Bool_t createOnTheFly); RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_tRooAbsPdf::traceEvalHook(Double_t value) const; Bool_tRooAbsPdf::traceEvalPdf(Double_t value) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); static intRooAbsPdf::verboseEval(); static voidRooAbsPdf::verboseEval(Int_t stat); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root/html532/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTFnPdfBinding.html
https://root.cern/root/html532/RooTFnPdfBinding.html:33376,Performance,optimiz,optimizeDirtyHook,33376,"atVars, const RooDataSet* prototype, Int_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html532/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTFnPdfBinding.html
https://root.cern/root/html532/RooTFnPdfBinding.html:36639,Performance,cache,cache,36639,,MatchSource.WIKI,root/html532/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTFnPdfBinding.html
https://root.cern/root/html532/RooTFnPdfBinding.html:36838,Performance,cache,caches,36838,,MatchSource.WIKI,root/html532/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTFnPdfBinding.html
https://root.cern/root/html532/RooTFnPdfBinding.html:37373,Performance,cache,cache,37373,,MatchSource.WIKI,root/html532/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTFnPdfBinding.html
https://root.cern/root/html532/RooTFnPdfBinding.html:37690,Performance,cache,cache,37690,"_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalizat",MatchSource.WIKI,root/html532/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTFnPdfBinding.html
https://root.cern/root/html532/RooTFnPdfBinding.html:38048,Performance,cache,cache,38048,luesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Pr,MatchSource.WIKI,root/html532/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTFnPdfBinding.html
https://root.cern/root/html532/RooTFnPdfBinding.html:38543,Performance,cache,cache,38543, Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalcul,MatchSource.WIKI,root/html532/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTFnPdfBinding.html
https://root.cern/root/html532/RooTFnPdfBinding.html:39212,Performance,cache,cache,39212,"CacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInter",MatchSource.WIKI,root/html532/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTFnPdfBinding.html
https://root.cern/root/html532/RooTFnPdfBinding.html:40011,Performance,cache,cache,40011,"nge; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; TF1*func; RooListProxylist.",MatchSource.WIKI,root/html532/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTFnPdfBinding.html
https://root.cern/root/html532/RooTFnPdfBinding.html:40257,Performance,cache,cache,40257,"nge; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; TF1*func; RooListProxylist.",MatchSource.WIKI,root/html532/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTFnPdfBinding.html
https://root.cern/root/html532/RooTFnPdfBinding.html:17788,Security,Hash,Hash,17788," RooArgSet* depList, Bool_t stripDisconnected = kTRUE) const; const char*RooAbsReal::getPlotLabel() const; Double_tRooAbsReal::getPropagatedError(const RooFitResult& fr); const Text_t*RooAbsArg::getStringAttribute(const Text_t* key) const; virtual const char*TNamed::GetTitle() const; TStringRooAbsReal::getTitle(Bool_t appendUnit = kFALSE) const; Bool_tRooAbsArg::getTransientAttribute(const Text_t* name) const; virtual UInt_tTObject::GetUniqueID() const; const Text_t*RooAbsReal::getUnit() const; virtual Double_tRooAbsPdf::getVal(const RooArgSet* set = 0) const; RooArgSet*RooAbsArg::getVariables(Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); voidRooAbsArg::graphVizTree(ostream& os, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tRooAbsArg::hasClients() const; virtual ULong_tTNamed::Hash() const; virtual Bool_tRooAbsArg::hasRange(const char*) const; RooGenFunction*RooAbsReal::iGenFunction(RooRealVar& x, const RooArgSet& nset = RooArgSet()); RooMultiGenFunction*RooAbsReal::iGenFunction(const RooArgSet& observables, const RooArgSet& nset = RooArgSet()); virtual Bool_tRooAbsArg::importWorkspaceHook(RooWorkspace&); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidRooAbsPdf::initGenerator(Int_t code); virtual Bool_tRooAbsArg::inRange(const char*) const; virtual voidTObject::Inspect() constMENU ; Int_tRooAbsPdf::intOrderNormValueCaching() const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tRooAbsPdf::isDirectGenSafe(const RooAbsArg& arg) const; v",MatchSource.WIKI,root/html532/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTFnPdfBinding.html
https://root.cern/root/html532/RooTFnPdfBinding.html:36734,Security,validat,validate,36734,,MatchSource.WIKI,root/html532/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTFnPdfBinding.html
https://root.cern/root/html532/RooTFnPdfBinding.html:8308,Testability,test,testArg,8308,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html532/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTFnPdfBinding.html
https://root.cern/root/html532/RooTFnPdfBinding.html:8402,Testability,test,testArg,8402,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html532/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTFnPdfBinding.html
https://root.cern/root/html532/RooTFnPdfBinding.html:19644,Testability,log,logEvalError,19644,"sArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tRooAbsPdf::isDirectGenSafe(const RooAbsArg& arg) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); ",MatchSource.WIKI,root/html532/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTFnPdfBinding.html
https://root.cern/root/html532/RooTFnPdfBinding.html:19743,Testability,log,logEvalError,19743,"rectGenSafe(const RooAbsArg& arg) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsR",MatchSource.WIKI,root/html532/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTFnPdfBinding.html
https://root.cern/root/html532/RooTFnPdfBinding.html:20849,Testability,test,testArg,20849,"tring = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNo",MatchSource.WIKI,root/html532/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTFnPdfBinding.html
https://root.cern/root/html532/RooTFnPdfBinding.html:20944,Testability,test,testArg,20944,"xVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; con",MatchSource.WIKI,root/html532/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTFnPdfBinding.html
https://root.cern/root/html532/RooTFnPdfBinding.html:21902,Testability,test,testArg,21902,"ialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html532/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTFnPdfBinding.html
https://root.cern/root/html532/RooTFnPdfBinding.html:29347,Testability,Test,TestBit,29347,"::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig(Bool_t createOnTheFly); RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_tRooAbsPdf::traceEvalHook(Double_t value) const; Bool_tRooAbsPdf::traceEvalPdf(Double_t value) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); static intRooAbsPdf::verboseEval(); static voidRooAbsPdf::verboseEval(Int_t stat); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t",MatchSource.WIKI,root/html532/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTFnPdfBinding.html
https://root.cern/root/html532/RooTFnPdfBinding.html:29386,Testability,Test,TestBits,29386,"ame, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig(Bool_t createOnTheFly); RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_tRooAbsPdf::traceEvalHook(Double_t value) const; Bool_tRooAbsPdf::traceEvalPdf(Double_t value) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); static intRooAbsPdf::verboseEval(); static voidRooAbsPdf::verboseEval(Int_t stat); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsR",MatchSource.WIKI,root/html532/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTFnPdfBinding.html
https://root.cern/root/html532/RooTFnPdfBinding.html:2412,Usability,Clear,Clear,2412,"const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg",MatchSource.WIKI,root/html532/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTFnPdfBinding.html
https://root.cern/root/html532/RooTFnPdfBinding.html:2464,Usability,clear,clearEvalError,2464,"g::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), cons",MatchSource.WIKI,root/html532/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTFnPdfBinding.html
https://root.cern/root/html532/RooTFnPdfBinding.html:2505,Usability,clear,clearEvalErrorLog,2505,"idRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), con",MatchSource.WIKI,root/html532/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTFnPdfBinding.html
https://root.cern/root/html532/RooTFnPdfBinding.html:2541,Usability,clear,clearShapeDirty,2541,"RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::non",MatchSource.WIKI,root/html532/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTFnPdfBinding.html
https://root.cern/root/html532/RooTFnPdfBinding.html:2581,Usability,clear,clearValueAndShapeDirty,2581,">&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none",MatchSource.WIKI,root/html532/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTFnPdfBinding.html
https://root.cern/root/html532/RooTFnPdfBinding.html:2629,Usability,clear,clearValueDirty,2629,"RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooAbsReal*RooAbsPdf::createChi",MatchSource.WIKI,root/html532/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTFnPdfBinding.html
https://root.cern/root/html532/RooTFoamBinding.html:1418,Availability,Error,Error,1418," RooTFoamBinding(const RooTFoamBinding&); RooTFoamBinding(const RooAbsReal& pdf, const RooArgSet& observables); virtual~RooTFoamBinding(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); RooRealBinding&binding(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDensity(Int_t ndim, Double_t*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtua",MatchSource.WIKI,root/html532/RooTFoamBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTFoamBinding.html
https://root.cern/root/html532/RooTFoamBinding.html:1547,Availability,error,error,1547,"Binding(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); RooRealBinding&binding(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDensity(Int_t ndim, Double_t*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html532/RooTFoamBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTFoamBinding.html
https://root.cern/root/html532/RooTFoamBinding.html:1631,Availability,error,error,1631,"t::AppendPad(Option_t* option = """"); RooRealBinding&binding(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDensity(Int_t ndim, Double_t*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html532/RooTFoamBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTFoamBinding.html
https://root.cern/root/html532/RooTFoamBinding.html:343,Energy Efficiency,adapt,adaptor,343,". RooTFoamBinding. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  ROOFIT;  ROOFITCORE;  RooTFoamBinding. class RooTFoamBinding: public TFoamIntegrand. Lightweight interface adaptor that binds a RooAbsPdf to TFOAM; . Function Members (Methods); public:. RooTFoamBinding(const RooTFoamBinding&); RooTFoamBinding(const RooAbsReal& pdf, const RooArgSet& observables); virtual~RooTFoamBinding(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); RooRealBinding&binding(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDensity(Int_t ndim, Double_t*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtua",MatchSource.WIKI,root/html532/RooTFoamBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTFoamBinding.html
https://root.cern/root/html532/RooTFoamBinding.html:333,Integrability,interface,interface,333,". RooTFoamBinding. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  ROOFIT;  ROOFITCORE;  RooTFoamBinding. class RooTFoamBinding: public TFoamIntegrand. Lightweight interface adaptor that binds a RooAbsPdf to TFOAM; . Function Members (Methods); public:. RooTFoamBinding(const RooTFoamBinding&); RooTFoamBinding(const RooAbsReal& pdf, const RooArgSet& observables); virtual~RooTFoamBinding(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); RooRealBinding&binding(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDensity(Int_t ndim, Double_t*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtua",MatchSource.WIKI,root/html532/RooTFoamBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTFoamBinding.html
https://root.cern/root/html532/RooTFoamBinding.html:343,Modifiability,adapt,adaptor,343,". RooTFoamBinding. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  ROOFIT;  ROOFITCORE;  RooTFoamBinding. class RooTFoamBinding: public TFoamIntegrand. Lightweight interface adaptor that binds a RooAbsPdf to TFOAM; . Function Members (Methods); public:. RooTFoamBinding(const RooTFoamBinding&); RooTFoamBinding(const RooAbsReal& pdf, const RooArgSet& observables); virtual~RooTFoamBinding(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); RooRealBinding&binding(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDensity(Int_t ndim, Double_t*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtua",MatchSource.WIKI,root/html532/RooTFoamBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTFoamBinding.html
https://root.cern/root/html532/RooTFoamBinding.html:2511,Modifiability,Inherit,InheritsFrom,2511,"d, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TOb",MatchSource.WIKI,root/html532/RooTFoamBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTFoamBinding.html
https://root.cern/root/html532/RooTFoamBinding.html:2577,Modifiability,Inherit,InheritsFrom,2577,"cute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooTFoamBinding&operato",MatchSource.WIKI,root/html532/RooTFoamBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTFoamBinding.html
https://root.cern/root/html532/RooTFoamBinding.html:5370,Modifiability,Inherit,Inheritance,5370," option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. RooRealBinding*_binding; RooArgSet_nset. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooTFoamBinding(const RooAbsReal& pdf, const RooArgSet& observables). ~RooTFoamBinding(); Destructor. Double_t Density(Int_t ndim, Double_t* ). RooTFoamBinding(const RooAbsReal& pdf, const RooArgSet& observables). RooRealBinding& binding(); { return *_binding ; }.  Last changed: Thu Nov 3 20:09:57 2011  Last generated: 2011-11-03 20:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/RooTFoamBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTFoamBinding.html
https://root.cern/root/html532/RooTFoamBinding.html:5383,Modifiability,Inherit,Inherited,5383," option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. RooRealBinding*_binding; RooArgSet_nset. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooTFoamBinding(const RooAbsReal& pdf, const RooArgSet& observables). ~RooTFoamBinding(); Destructor. Double_t Density(Int_t ndim, Double_t* ). RooTFoamBinding(const RooAbsReal& pdf, const RooArgSet& observables). RooRealBinding& binding(); { return *_binding ; }.  Last changed: Thu Nov 3 20:09:57 2011  Last generated: 2011-11-03 20:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/RooTFoamBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTFoamBinding.html
https://root.cern/root/html532/RooTFoamBinding.html:2401,Security,Hash,Hash,2401,"l voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator ",MatchSource.WIKI,root/html532/RooTFoamBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTFoamBinding.html
https://root.cern/root/html532/RooTFoamBinding.html:4527,Testability,Test,TestBit,4527,"const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooTFoamBinding&operator=(const RooTFoamBinding&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/RooTFoamBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTFoamBinding.html
https://root.cern/root/html532/RooTFoamBinding.html:4566,Testability,Test,TestBits,4566,"const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooTFoamBinding&operator=(const RooTFoamBinding&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/RooTFoamBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTFoamBinding.html
https://root.cern/root/html532/RooTFoamBinding.html:830,Usability,Clear,Clear,830," RooTFoamBinding(const RooTFoamBinding&); RooTFoamBinding(const RooAbsReal& pdf, const RooArgSet& observables); virtual~RooTFoamBinding(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); RooRealBinding&binding(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDensity(Int_t ndim, Double_t*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtua",MatchSource.WIKI,root/html532/RooTFoamBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTFoamBinding.html
https://root.cern/root/html532/RooThreshEntry.html:1339,Availability,Error,Error,1339," RooThreshEntry(); RooThreshEntry(const RooThreshEntry& other); RooThreshEntry(Double_t thresh, const RooCatType& cat); virtual~RooThreshEntry(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); const RooCatType&cat() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*Clone(const char*) const; virtual Int_tCompare(const TObject*) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName(",MatchSource.WIKI,root/html532/RooThreshEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooThreshEntry.html
https://root.cern/root/html532/RooThreshEntry.html:1468,Availability,error,error,1468,"other); RooThreshEntry(Double_t thresh, const RooCatType& cat); virtual~RooThreshEntry(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); const RooCatType&cat() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*Clone(const char*) const; virtual Int_tCompare(const TObject*) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html532/RooThreshEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooThreshEntry.html
https://root.cern/root/html532/RooThreshEntry.html:1552,Availability,error,error,1552,"ry(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); const RooCatType&cat() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*Clone(const char*) const; virtual Int_tCompare(const TObject*) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html532/RooThreshEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooThreshEntry.html
https://root.cern/root/html532/RooThreshEntry.html:2432,Modifiability,Inherit,InheritsFrom,2432,"d, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::ope",MatchSource.WIKI,root/html532/RooThreshEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooThreshEntry.html
https://root.cern/root/html532/RooThreshEntry.html:2498,Modifiability,Inherit,InheritsFrom,2498,"cute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooThreshEntry&operator=(const R",MatchSource.WIKI,root/html532/RooThreshEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooThreshEntry.html
https://root.cern/root/html532/RooThreshEntry.html:5296,Modifiability,Inherit,Inheritance,5296,"sp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Double_tthresh() const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. RooCatType_cat; Double_t_thresh. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooThreshEntry(Double_t thresh, const RooCatType& cat); Constructor with threshold value and associated category value. RooThreshEntry(const RooThreshEntry& other); Copy constructor. Int_t Compare(const TObject* ) const; Implement TObject Compare() operator to facilitate sorting of; RooThreshEntry object in ROOT collection. Only comparison; to other RooThreshEntry objects is supported. inline RooThreshEntry(); {}. virtual ~RooThreshEntry(); {}. TObject* Clone(const char* ) const; { return new RooThreshEntry(*this); }. Bool_t IsSortable() const; { return kTRUE ; }. Double_t thresh() const; { return _thresh ; }. const RooCatType& cat() const; { return _cat ; }.  Last changed: Thu Nov 3 20:09:58 2011  Last generated: 2011-11-03 20:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/RooThreshEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooThreshEntry.html
https://root.cern/root/html532/RooThreshEntry.html:5309,Modifiability,Inherit,Inherited,5309,"sp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Double_tthresh() const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. RooCatType_cat; Double_t_thresh. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooThreshEntry(Double_t thresh, const RooCatType& cat); Constructor with threshold value and associated category value. RooThreshEntry(const RooThreshEntry& other); Copy constructor. Int_t Compare(const TObject* ) const; Implement TObject Compare() operator to facilitate sorting of; RooThreshEntry object in ROOT collection. Only comparison; to other RooThreshEntry objects is supported. inline RooThreshEntry(); {}. virtual ~RooThreshEntry(); {}. TObject* Clone(const char* ) const; { return new RooThreshEntry(*this); }. Bool_t IsSortable() const; { return kTRUE ; }. Double_t thresh() const; { return _thresh ; }. const RooCatType& cat() const; { return _cat ; }.  Last changed: Thu Nov 3 20:09:58 2011  Last generated: 2011-11-03 20:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/RooThreshEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooThreshEntry.html
https://root.cern/root/html532/RooThreshEntry.html:2322,Security,Hash,Hash,2322,"l voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_",MatchSource.WIKI,root/html532/RooThreshEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooThreshEntry.html
https://root.cern/root/html532/RooThreshEntry.html:4437,Testability,Test,TestBit,4437,"IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooThreshEntry&operator=(const RooThreshEntry&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Double_tthresh() const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/RooThreshEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooThreshEntry.html
https://root.cern/root/html532/RooThreshEntry.html:4476,Testability,Test,TestBits,4476,"IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooThreshEntry&operator=(const RooThreshEntry&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Double_tthresh() const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/RooThreshEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooThreshEntry.html
https://root.cern/root/html532/RooThreshEntry.html:834,Usability,Clear,Clear,834," RooThreshEntry(); RooThreshEntry(const RooThreshEntry& other); RooThreshEntry(Double_t thresh, const RooCatType& cat); virtual~RooThreshEntry(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); const RooCatType&cat() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*Clone(const char*) const; virtual Int_tCompare(const TObject*) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName(",MatchSource.WIKI,root/html532/RooThreshEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooThreshEntry.html
https://root.cern/root/html532/RooThresholdCategory.html:4072,Availability,Error,Error,4072,"t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAb",MatchSource.WIKI,root/html532/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooThresholdCategory.html
https://root.cern/root/html532/RooThresholdCategory.html:4201,Availability,error,error,4201,", const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; Ro",MatchSource.WIKI,root/html532/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooThresholdCategory.html
https://root.cern/root/html532/RooThresholdCategory.html:4285,Availability,error,error,4285,"t* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloning",MatchSource.WIKI,root/html532/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooThresholdCategory.html
https://root.cern/root/html532/RooThresholdCategory.html:3164,Integrability,depend,dependentOverlaps,3164,"rg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method,",MatchSource.WIKI,root/html532/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooThresholdCategory.html
https://root.cern/root/html532/RooThresholdCategory.html:3256,Integrability,depend,dependentOverlaps,3256,"sArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjAr",MatchSource.WIKI,root/html532/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooThresholdCategory.html
https://root.cern/root/html532/RooThresholdCategory.html:3350,Integrability,depend,dependsOn,3350,"bject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, I",MatchSource.WIKI,root/html532/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooThresholdCategory.html
https://root.cern/root/html532/RooThresholdCategory.html:3479,Integrability,depend,dependsOn,3479,"tual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const c",MatchSource.WIKI,root/html532/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooThresholdCategory.html
https://root.cern/root/html532/RooThresholdCategory.html:3597,Integrability,depend,dependsOnValue,3597,"onstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& ob",MatchSource.WIKI,root/html532/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooThresholdCategory.html
https://root.cern/root/html532/RooThresholdCategory.html:3704,Integrability,depend,dependsOnValue,3704,"r* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSe",MatchSource.WIKI,root/html532/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooThresholdCategory.html
https://root.cern/root/html532/RooThresholdCategory.html:7582,Modifiability,Inherit,InheritsFrom,7582,"st; virtual RooArgSet*RooAbsArg::getParameters(const RooArgSet* depList, Bool_t stripDisconnected = kTRUE) const; const Text_t*RooAbsArg::getStringAttribute(const Text_t* key) const; virtual const char*TNamed::GetTitle() const; Bool_tRooAbsArg::getTransientAttribute(const Text_t* name) const; virtual UInt_tTObject::GetUniqueID() const; RooArgSet*RooAbsArg::getVariables(Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); voidRooAbsArg::graphVizTree(ostream& os, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tRooAbsArg::hasClients() const; virtual ULong_tTNamed::Hash() const; virtual Bool_tRooAbsArg::hasRange(const char*) const; virtual Bool_tRooAbsArg::importWorkspaceHook(RooWorkspace&); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual Bool_tRooAbsArg::inRange(const char*) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsCategory::isIntegrationSafeLValue(const RooArgSet*) const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; Bool_tRooAbsCategory::isSignType(Bool_t mustHaveZero = kFALSE) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsCategory::isValidIndex",MatchSource.WIKI,root/html532/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooThresholdCategory.html
https://root.cern/root/html532/RooThresholdCategory.html:7648,Modifiability,Inherit,InheritsFrom,7648,"pList, Bool_t stripDisconnected = kTRUE) const; const Text_t*RooAbsArg::getStringAttribute(const Text_t* key) const; virtual const char*TNamed::GetTitle() const; Bool_tRooAbsArg::getTransientAttribute(const Text_t* name) const; virtual UInt_tTObject::GetUniqueID() const; RooArgSet*RooAbsArg::getVariables(Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); voidRooAbsArg::graphVizTree(ostream& os, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tRooAbsArg::hasClients() const; virtual ULong_tTNamed::Hash() const; virtual Bool_tRooAbsArg::hasRange(const char*) const; virtual Bool_tRooAbsArg::importWorkspaceHook(RooWorkspace&); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual Bool_tRooAbsArg::inRange(const char*) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsCategory::isIntegrationSafeLValue(const RooArgSet*) const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; Bool_tRooAbsCategory::isSignType(Bool_t mustHaveZero = kFALSE) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsCategory::isValidIndex(Int_t index) const; Bool_tRooAbsCategory::isValidLabel(const char",MatchSource.WIKI,root/html532/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooThresholdCategory.html
https://root.cern/root/html532/RooThresholdCategory.html:18721,Modifiability,Config,ConfigChange,18721,"oAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::syncCache(const RooArgSet* set = 0); RooCatTypeRooAbsCategory::traceEval() const; virtual Bool_tRooAbsCategory::traceEvalHook(RooCatType) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy). Data Members; public:. enum RooAbsArg::ConstOpCode { Activate; DeActivate; ConfigChange; ValueChange; };; enum RooAbsArg::OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsCategory::_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! It",MatchSource.WIKI,root/html532/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooThresholdCategory.html
https://root.cern/root/html532/RooThresholdCategory.html:21512,Modifiability,Inherit,Inheritance,21512," mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; TIterator*_threshIter! do not persist ; TSortedList_threshList; Bool_tRooAbsCategory::_treeVar! do not persist; TIterator*RooAbsCategory::_typeIter!; TObjArrayRooAbsCategory::_typesArray of allowed values; RooCatTypeRooAbsCategory::_valueCurrent value; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooThresholdCategory(const char* name, const char* title, RooAbsReal& inputVar, const char* defCatName = ""Default"", Int_t defCatIdx = 0); Constructor with input function to be mapped and name and index of default; output state of unmapped values. RooThresholdCategory(const RooThresholdCategory& other, const char* name = 0); Copy constructor. ~RooThresholdCategory(); Destructor. Bool_t addThreshold(Double_t upperLimit, const char* catName, Int_t catIdx = -99999); Insert threshold at value upperLimit. All values below upper limit (and above any lower; thresholds, if any) will be mapped to a state name 'catName' with index 'catIdx'. RooCatType evaluate() const; Calculate and return the value of the mapping function. void writeToStream(ostream& os, Bool_t compact) const; Write object contents to given stream. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this threshold",MatchSource.WIKI,root/html532/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooThresholdCategory.html
https://root.cern/root/html532/RooThresholdCategory.html:21525,Modifiability,Inherit,Inherited,21525," mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; TIterator*_threshIter! do not persist ; TSortedList_threshList; Bool_tRooAbsCategory::_treeVar! do not persist; TIterator*RooAbsCategory::_typeIter!; TObjArrayRooAbsCategory::_typesArray of allowed values; RooCatTypeRooAbsCategory::_valueCurrent value; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooThresholdCategory(const char* name, const char* title, RooAbsReal& inputVar, const char* defCatName = ""Default"", Int_t defCatIdx = 0); Constructor with input function to be mapped and name and index of default; output state of unmapped values. RooThresholdCategory(const RooThresholdCategory& other, const char* name = 0); Copy constructor. ~RooThresholdCategory(); Destructor. Bool_t addThreshold(Double_t upperLimit, const char* catName, Int_t catIdx = -99999); Insert threshold at value upperLimit. All values below upper limit (and above any lower; thresholds, if any) will be mapped to a state name 'catName' with index 'catIdx'. RooCatType evaluate() const; Calculate and return the value of the mapping function. void writeToStream(ostream& os, Bool_t compact) const; Write object contents to given stream. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this threshold",MatchSource.WIKI,root/html532/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooThresholdCategory.html
https://root.cern/root/html532/RooThresholdCategory.html:1756,Performance,cache,cacheUniqueSuffix,1756,"ractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); Bool_taddThreshold(Double_t upperLimit, const char* catName, Int_t catIdx = -99999); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFund",MatchSource.WIKI,root/html532/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooThresholdCategory.html
https://root.cern/root/html532/RooThresholdCategory.html:4627,Performance,cache,cacheList,4627,"on& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(const RooAbsData* set) const; RooArgSet*RooAbsArg::getDependents(const RooArgSet* depList) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly()",MatchSource.WIKI,root/html532/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooThresholdCategory.html
https://root.cern/root/html532/RooThresholdCategory.html:4715,Performance,cache,cacheList,4715,"onst RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(const RooAbsData* set) const; RooArgSet*RooAbsArg::getDependents(const RooArgSet* depList) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tRooAbsCategory::getIndex",MatchSource.WIKI,root/html532/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooThresholdCategory.html
https://root.cern/root/html532/RooThresholdCategory.html:10796,Performance,optimiz,optimizeCacheMode,10796," depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", con",MatchSource.WIKI,root/html532/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooThresholdCategory.html
https://root.cern/root/html532/RooThresholdCategory.html:10868,Performance,optimiz,optimizeCacheMode,10868,"har* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); voidRooAbsArg::printDirty(Boo",MatchSource.WIKI,root/html532/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooThresholdCategory.html
https://root.cern/root/html532/RooThresholdCategory.html:13311,Performance,cache,cache,13311,"idRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsCategory::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsCategory::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); virtual voidTNamed:",MatchSource.WIKI,root/html532/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooThresholdCategory.html
https://root.cern/root/html532/RooThresholdCategory.html:14287,Performance,cache,cache,14287,"erCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::Sys",MatchSource.WIKI,root/html532/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooThresholdCategory.html
https://root.cern/root/html532/RooThresholdCategory.html:15779,Performance,cache,cache,15779,"; virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; TIterator*RooAbsCategory::typeIterator() const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root/html532/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooThresholdCategory.html
https://root.cern/root/html532/RooThresholdCategory.html:17826,Performance,optimiz,optimizeDirtyHook,17826,"ce, Bool_t valueOnly = kFALSE, Bool_t setValueDirty = kTRUE); const RooCatType*RooAbsCategory::defineType(const char* label); const RooCatType*RooAbsCategory::defineType(const char* label, Int_t index); const RooCatType*RooAbsCategory::defineTypeUnchecked(const char* label, Int_t index); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual RooCatTypeevaluate() const; virtual voidRooAbsCategory::fillTreeBranch(TTree& t); static Bool_tRooAbsArg::flipAClean(); virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; const RooCatType*RooAbsCategory::getOrdinal(UInt_t n, const char* rangeName = 0) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); virtual Bool_tRooAbsCategory::isValid() const; virtual Bool_tRooAbsCategory::isValid(const RooCatType& value) const; voidTObject::MakeZombie(); Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::syncCache(const RooArgSet* set = 0); RooCatTypeRooAbsCategory::traceEval() const; virtual Bool_tRooAbsCategory::traceEvalHook(RooCatType) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy).",MatchSource.WIKI,root/html532/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooThresholdCategory.html
https://root.cern/root/html532/RooThresholdCategory.html:19489,Performance,cache,cache,19489,,MatchSource.WIKI,root/html532/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooThresholdCategory.html
https://root.cern/root/html532/RooThresholdCategory.html:19579,Performance,cache,caches,19579,,MatchSource.WIKI,root/html532/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooThresholdCategory.html
https://root.cern/root/html532/RooThresholdCategory.html:20134,Performance,cache,cache,20134,,MatchSource.WIKI,root/html532/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooThresholdCategory.html
https://root.cern/root/html532/RooThresholdCategory.html:7357,Security,Hash,Hash,7357," stripDisconnected = kTRUE) const; RooArgSet*RooAbsArg::getParameters(const RooAbsData& data, Bool_t stripDisconnected = kTRUE) const; RooArgSet*RooAbsArg::getParameters(const RooArgSet& set, Bool_t stripDisconnected = kTRUE) const; virtual RooArgSet*RooAbsArg::getParameters(const RooArgSet* depList, Bool_t stripDisconnected = kTRUE) const; const Text_t*RooAbsArg::getStringAttribute(const Text_t* key) const; virtual const char*TNamed::GetTitle() const; Bool_tRooAbsArg::getTransientAttribute(const Text_t* name) const; virtual UInt_tTObject::GetUniqueID() const; RooArgSet*RooAbsArg::getVariables(Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); voidRooAbsArg::graphVizTree(ostream& os, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tRooAbsArg::hasClients() const; virtual ULong_tTNamed::Hash() const; virtual Bool_tRooAbsArg::hasRange(const char*) const; virtual Bool_tRooAbsArg::importWorkspaceHook(RooWorkspace&); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual Bool_tRooAbsArg::inRange(const char*) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsCategory::isIntegrationSafeLValue(const RooArgSet*) const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const",MatchSource.WIKI,root/html532/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooThresholdCategory.html
https://root.cern/root/html532/RooThresholdCategory.html:3223,Testability,test,testArg,3223,"earValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTO",MatchSource.WIKI,root/html532/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooThresholdCategory.html
https://root.cern/root/html532/RooThresholdCategory.html:3317,Testability,test,testArg,3317,"t char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::Exe",MatchSource.WIKI,root/html532/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooThresholdCategory.html
https://root.cern/root/html532/RooThresholdCategory.html:9737,Testability,test,testArg,9737,"dClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(Int_t index, Bool_t printError = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(const char* label, Bool_t printError = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(const RooCatType& type, Bool_t printError = kFALSE) const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; Int_tRooAbsCategory::numTypes(const char* = 0) const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperM",MatchSource.WIKI,root/html532/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooThresholdCategory.html
https://root.cern/root/html532/RooThresholdCategory.html:9832,Testability,test,testArg,9832,"erver(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(Int_t index, Bool_t printError = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(const char* label, Bool_t printError = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(const RooCatType& type, Bool_t printError = kFALSE) const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; Int_tRooAbsCategory::numTypes(const char* = 0) const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& obser",MatchSource.WIKI,root/html532/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooThresholdCategory.html
https://root.cern/root/html532/RooThresholdCategory.html:11012,Testability,test,testArg,11012,"operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); voidRooAbsArg::printDirty(Bool_t depth = kTRUE) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidRooAbsArg::printMetaArgs(ostream&) const; v",MatchSource.WIKI,root/html532/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooThresholdCategory.html
https://root.cern/root/html532/RooThresholdCategory.html:15358,Testability,Test,TestBit,15358,"; virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; TIterator*RooAbsCategory::typeIterator() const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root/html532/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooThresholdCategory.html
https://root.cern/root/html532/RooThresholdCategory.html:15397,Testability,Test,TestBits,15397,"; virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; TIterator*RooAbsCategory::typeIterator() const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root/html532/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooThresholdCategory.html
https://root.cern/root/html532/RooThresholdCategory.html:2092,Usability,Clear,Clear,2092,"dServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); Bool_taddThreshold(Double_t upperLimit, const char* catName, Int_t catIdx = -99999); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtu",MatchSource.WIKI,root/html532/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooThresholdCategory.html
https://root.cern/root/html532/RooThresholdCategory.html:2137,Usability,clear,clearShapeDirty,2137,"alueProp = kTRUE, Bool_t shapeProp = kFALSE); Bool_taddThreshold(Double_t upperLimit, const char* catName, Int_t catIdx = -99999); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ",MatchSource.WIKI,root/html532/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooThresholdCategory.html
https://root.cern/root/html532/RooThresholdCategory.html:2177,Usability,clear,clearValueAndShapeDirty,2177,"; Bool_taddThreshold(Double_t upperLimit, const char* catName, Int_t catIdx = -99999); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const R",MatchSource.WIKI,root/html532/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooThresholdCategory.html
https://root.cern/root/html532/RooThresholdCategory.html:2225,Usability,clear,clearValueDirty,2225,"nst char* catName, Int_t catIdx = -99999); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) c",MatchSource.WIKI,root/html532/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooThresholdCategory.html
https://root.cern/root/html532/RooThresholdCategory.html:16571,Usability,clear,clearTypes,16571,,MatchSource.WIKI,root/html532/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooThresholdCategory.html
https://root.cern/root/html532/RooTObjWrap.html:1345,Availability,Error,Error,1345," RooTObjWrap(Bool_t isArray = kFALSE); RooTObjWrap(const RooTObjWrap& other); RooTObjWrap(TObject* inObj, Bool_t isArray = kFALSE); virtual~RooTObjWrap(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetI",MatchSource.WIKI,root/html532/RooTObjWrap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTObjWrap.html
https://root.cern/root/html532/RooTObjWrap.html:1474,Availability,error,error,1474,"her); RooTObjWrap(TObject* inObj, Bool_t isArray = kFALSE); virtual~RooTObjWrap(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObj",MatchSource.WIKI,root/html532/RooTObjWrap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTObjWrap.html
https://root.cern/root/html532/RooTObjWrap.html:1558,Availability,error,error,1558,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(",MatchSource.WIKI,root/html532/RooTObjWrap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTObjWrap.html
https://root.cern/root/html532/RooTObjWrap.html:2482,Modifiability,Inherit,InheritsFrom,2482,"rtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); TObject*obj() const; const RooLinkedList&objList() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void",MatchSource.WIKI,root/html532/RooTObjWrap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTObjWrap.html
https://root.cern/root/html532/RooTObjWrap.html:2548,Modifiability,Inherit,InheritsFrom,2548,"_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); TObject*obj() const; const RooLinkedList&objList() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::oper",MatchSource.WIKI,root/html532/RooTObjWrap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTObjWrap.html
https://root.cern/root/html532/RooTObjWrap.html:5747,Modifiability,Inherit,Inheritance,5747,"lag); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_t_isArray; RooLinkedList_list; Bool_t_owning; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooTObjWrap(Bool_t isArray = kFALSE); {}. RooTObjWrap(TObject* inObj, Bool_t isArray = kFALSE); { _list.Add(inObj) ; }. RooTObjWrap(const RooTObjWrap& other); {}. virtual ~RooTObjWrap(); { if (_owning) _list.Delete() ; }. void setOwning(Bool_t flag); { _owning = flag ; }. TObject* obj() const; { return _list.At(0) ; }. const RooLinkedList& objList() const; { return _list ; }. void setObj(TObject* inObj).  Last changed: Thu Nov 3 20:09:57 2011  Last generated: 2011-11-03 20:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/RooTObjWrap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTObjWrap.html
https://root.cern/root/html532/RooTObjWrap.html:5760,Modifiability,Inherit,Inherited,5760,"lag); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_t_isArray; RooLinkedList_list; Bool_t_owning; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooTObjWrap(Bool_t isArray = kFALSE); {}. RooTObjWrap(TObject* inObj, Bool_t isArray = kFALSE); { _list.Add(inObj) ; }. RooTObjWrap(const RooTObjWrap& other); {}. virtual ~RooTObjWrap(); { if (_owning) _list.Delete() ; }. void setOwning(Bool_t flag); { _owning = flag ; }. TObject* obj() const; { return _list.At(0) ; }. const RooLinkedList& objList() const; { return _list ; }. void setObj(TObject* inObj).  Last changed: Thu Nov 3 20:09:57 2011  Last generated: 2011-11-03 20:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/RooTObjWrap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTObjWrap.html
https://root.cern/root/html532/RooTObjWrap.html:2372,Security,Hash,Hash,2372,"st char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); TObject*obj() const; const RooLinkedList&objList() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operato",MatchSource.WIKI,root/html532/RooTObjWrap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTObjWrap.html
https://root.cern/root/html532/RooTObjWrap.html:4820,Testability,Test,TestBit,4820,"rs) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooTObjWrap&operator=(const RooTObjWrap&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidsetObj(TObject* inObj); static voidTObject::SetObjectStat(Bool_t stat); voidsetOwning(Bool_t flag); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/RooTObjWrap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTObjWrap.html
https://root.cern/root/html532/RooTObjWrap.html:4859,Testability,Test,TestBits,4859,"rs) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooTObjWrap&operator=(const RooTObjWrap&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidsetObj(TObject* inObj); static voidTObject::SetObjectStat(Bool_t stat); voidsetOwning(Bool_t flag); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/RooTObjWrap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTObjWrap.html
https://root.cern/root/html532/RooTObjWrap.html:802,Usability,Clear,Clear,802," RooTObjWrap(Bool_t isArray = kFALSE); RooTObjWrap(const RooTObjWrap& other); RooTObjWrap(TObject* inObj, Bool_t isArray = kFALSE); virtual~RooTObjWrap(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetI",MatchSource.WIKI,root/html532/RooTObjWrap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTObjWrap.html
https://root.cern/root/html532/RooTrace.html:464,Integrability,message,messages,464,". RooTrace. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  ROOFIT;  ROOFITCORE;  RooTrace. class RooTrace. Class RooTrace controls the memory tracing hooks in all RooFit; objects. When tracing is active, a table of live RooFit objects; is kept that can be queried at any time. In verbose mode, messages; are printed in addition at the construction and destruction of; each object.; . Function Members (Methods); public:. RooTrace(); RooTrace(const RooTrace&); virtual~RooTrace(); static voidactive(Bool_t flag); static voidcallgrind_dump(); static voidcallgrind_zero(); static TClass*Class(); static voidcreate(const TObject* obj); static voiddestroy(const TObject* obj); static voiddump(); static voiddump(ostream& os, Bool_t sinceMarked = kFALSE); virtual TClass*IsA() const; static voidmark(); RooTrace&operator=(const RooTrace&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); static voidverbose(Bool_t flag). protected:. voidaddPad(const TObject* ref, Bool_t doPad); static voidcreate2(const TObject* obj); static voiddestroy2(const TObject* obj); Bool_tremovePad(const TObject* ref). Data Members; protected:. static Bool_t_active; static RooLinkedList_list; static RooLinkedList_markList; static Bool_t_verbose. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void create(const TObject* obj); Register creation of object 'obj'. void destroy(const TObject* obj); Register deletion of object 'obj'. void active(Bool_t flag); If flag is true, memory tracing is activated. void verbose(Bool_t flag); If flag is true, a message will be printed at each; object creation or deletion. void create2(const TObject* obj); Back end function of create(), register creation of object 'obj'. void destroy2(const TObject* obj);",MatchSource.WIKI,root/html532/RooTrace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTrace.html
https://root.cern/root/html532/RooTrace.html:1805,Integrability,message,message,1805,"ddestroy(const TObject* obj); static voiddump(); static voiddump(ostream& os, Bool_t sinceMarked = kFALSE); virtual TClass*IsA() const; static voidmark(); RooTrace&operator=(const RooTrace&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); static voidverbose(Bool_t flag). protected:. voidaddPad(const TObject* ref, Bool_t doPad); static voidcreate2(const TObject* obj); static voiddestroy2(const TObject* obj); Bool_tremovePad(const TObject* ref). Data Members; protected:. static Bool_t_active; static RooLinkedList_list; static RooLinkedList_markList; static Bool_t_verbose. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void create(const TObject* obj); Register creation of object 'obj'. void destroy(const TObject* obj); Register deletion of object 'obj'. void active(Bool_t flag); If flag is true, memory tracing is activated. void verbose(Bool_t flag); If flag is true, a message will be printed at each; object creation or deletion. void create2(const TObject* obj); Back end function of create(), register creation of object 'obj'. void destroy2(const TObject* obj); Back end function of destroy(), register deletion of object 'obj'. void mark(); Put marker in object list, that allows to dump contents of list; relative to this marker. void dump(); Dump contents of object registry to stdout. void dump(ostream& os, Bool_t sinceMarked = kFALSE); Dump contents of object register to stream 'os'. If sinceMarked is; true, only object created after the last call to mark() are shown. void callgrind_zero(); Utility function to trigger zeroing of callgrind counters. Note that this function does _not_ do anything, other than optionally printing this message; To trigger callgrind zero counter action, run callgrind with; argument '--zero-before=RooTrace::callgrind_zero()' (include single quotes in cmdline). void callgrind_dump(); Utility function to trigger dumping of callgrin",MatchSource.WIKI,root/html532/RooTrace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTrace.html
https://root.cern/root/html532/RooTrace.html:2583,Integrability,message,message,2583,"; static RooLinkedList_markList; static Bool_t_verbose. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void create(const TObject* obj); Register creation of object 'obj'. void destroy(const TObject* obj); Register deletion of object 'obj'. void active(Bool_t flag); If flag is true, memory tracing is activated. void verbose(Bool_t flag); If flag is true, a message will be printed at each; object creation or deletion. void create2(const TObject* obj); Back end function of create(), register creation of object 'obj'. void destroy2(const TObject* obj); Back end function of destroy(), register deletion of object 'obj'. void mark(); Put marker in object list, that allows to dump contents of list; relative to this marker. void dump(); Dump contents of object registry to stdout. void dump(ostream& os, Bool_t sinceMarked = kFALSE); Dump contents of object register to stream 'os'. If sinceMarked is; true, only object created after the last call to mark() are shown. void callgrind_zero(); Utility function to trigger zeroing of callgrind counters. Note that this function does _not_ do anything, other than optionally printing this message; To trigger callgrind zero counter action, run callgrind with; argument '--zero-before=RooTrace::callgrind_zero()' (include single quotes in cmdline). void callgrind_dump(); Utility function to trigger dumping of callgrind counters. Note that this function does _not_ do anything, other than optionally printing this message; To trigger callgrind dumping action, run callgrind with; argument '--dump-before=RooTrace::callgrind_dump()' (include single quotes in cmdline). virtual ~RooTrace(); {}. void addPad(const TObject* ref, Bool_t doPad). Bool_t removePad(const TObject* ref).  Last changed: Thu Nov 3 20:09:59 2011  Last generated: 2011-11-03 20:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/RooTrace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTrace.html
https://root.cern/root/html532/RooTrace.html:2908,Integrability,message,message,2908,"; static RooLinkedList_markList; static Bool_t_verbose. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void create(const TObject* obj); Register creation of object 'obj'. void destroy(const TObject* obj); Register deletion of object 'obj'. void active(Bool_t flag); If flag is true, memory tracing is activated. void verbose(Bool_t flag); If flag is true, a message will be printed at each; object creation or deletion. void create2(const TObject* obj); Back end function of create(), register creation of object 'obj'. void destroy2(const TObject* obj); Back end function of destroy(), register deletion of object 'obj'. void mark(); Put marker in object list, that allows to dump contents of list; relative to this marker. void dump(); Dump contents of object registry to stdout. void dump(ostream& os, Bool_t sinceMarked = kFALSE); Dump contents of object register to stream 'os'. If sinceMarked is; true, only object created after the last call to mark() are shown. void callgrind_zero(); Utility function to trigger zeroing of callgrind counters. Note that this function does _not_ do anything, other than optionally printing this message; To trigger callgrind zero counter action, run callgrind with; argument '--zero-before=RooTrace::callgrind_zero()' (include single quotes in cmdline). void callgrind_dump(); Utility function to trigger dumping of callgrind counters. Note that this function does _not_ do anything, other than optionally printing this message; To trigger callgrind dumping action, run callgrind with; argument '--dump-before=RooTrace::callgrind_dump()' (include single quotes in cmdline). virtual ~RooTrace(); {}. void addPad(const TObject* ref, Bool_t doPad). Bool_t removePad(const TObject* ref).  Last changed: Thu Nov 3 20:09:59 2011  Last generated: 2011-11-03 20:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/RooTrace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTrace.html
https://root.cern/root/html532/RooTrace.html:1473,Modifiability,Inherit,Inheritance,1473,"at the construction and destruction of; each object.; . Function Members (Methods); public:. RooTrace(); RooTrace(const RooTrace&); virtual~RooTrace(); static voidactive(Bool_t flag); static voidcallgrind_dump(); static voidcallgrind_zero(); static TClass*Class(); static voidcreate(const TObject* obj); static voiddestroy(const TObject* obj); static voiddump(); static voiddump(ostream& os, Bool_t sinceMarked = kFALSE); virtual TClass*IsA() const; static voidmark(); RooTrace&operator=(const RooTrace&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); static voidverbose(Bool_t flag). protected:. voidaddPad(const TObject* ref, Bool_t doPad); static voidcreate2(const TObject* obj); static voiddestroy2(const TObject* obj); Bool_tremovePad(const TObject* ref). Data Members; protected:. static Bool_t_active; static RooLinkedList_list; static RooLinkedList_markList; static Bool_t_verbose. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void create(const TObject* obj); Register creation of object 'obj'. void destroy(const TObject* obj); Register deletion of object 'obj'. void active(Bool_t flag); If flag is true, memory tracing is activated. void verbose(Bool_t flag); If flag is true, a message will be printed at each; object creation or deletion. void create2(const TObject* obj); Back end function of create(), register creation of object 'obj'. void destroy2(const TObject* obj); Back end function of destroy(), register deletion of object 'obj'. void mark(); Put marker in object list, that allows to dump contents of list; relative to this marker. void dump(); Dump contents of object registry to stdout. void dump(ostream& os, Bool_t sinceMarked = kFALSE); Dump contents of object register to stream 'os'. If sinceMarked is; true, only object created after the last call to mark() are shown. void callgrind_zero(); Utility function to trigger zeroing of callgrind counters. ",MatchSource.WIKI,root/html532/RooTrace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTrace.html
https://root.cern/root/html532/RooTrace.html:1486,Modifiability,Inherit,Inherited,1486,"at the construction and destruction of; each object.; . Function Members (Methods); public:. RooTrace(); RooTrace(const RooTrace&); virtual~RooTrace(); static voidactive(Bool_t flag); static voidcallgrind_dump(); static voidcallgrind_zero(); static TClass*Class(); static voidcreate(const TObject* obj); static voiddestroy(const TObject* obj); static voiddump(); static voiddump(ostream& os, Bool_t sinceMarked = kFALSE); virtual TClass*IsA() const; static voidmark(); RooTrace&operator=(const RooTrace&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); static voidverbose(Bool_t flag). protected:. voidaddPad(const TObject* ref, Bool_t doPad); static voidcreate2(const TObject* obj); static voiddestroy2(const TObject* obj); Bool_tremovePad(const TObject* ref). Data Members; protected:. static Bool_t_active; static RooLinkedList_list; static RooLinkedList_markList; static Bool_t_verbose. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void create(const TObject* obj); Register creation of object 'obj'. void destroy(const TObject* obj); Register deletion of object 'obj'. void active(Bool_t flag); If flag is true, memory tracing is activated. void verbose(Bool_t flag); If flag is true, a message will be printed at each; object creation or deletion. void create2(const TObject* obj); Back end function of create(), register creation of object 'obj'. void destroy2(const TObject* obj); Back end function of destroy(), register deletion of object 'obj'. void mark(); Put marker in object list, that allows to dump contents of list; relative to this marker. void dump(); Dump contents of object registry to stdout. void dump(ostream& os, Bool_t sinceMarked = kFALSE); Dump contents of object register to stream 'os'. If sinceMarked is; true, only object created after the last call to mark() are shown. void callgrind_zero(); Utility function to trigger zeroing of callgrind counters. ",MatchSource.WIKI,root/html532/RooTrace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTrace.html
https://root.cern/root/html532/RooTreeData.html:549,Availability,avail,available,549,". RooTreeData. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  ROOFIT;  ROOFITCORE;  RooTreeData. class RooTreeData: public RooAbsData. RooTreeData is the abstract base class for data collection that; use a TTree as internal storage mechanism; . Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. ~RooTreeData(); voidTObject::AbstractMethod(const char* method) const; virtual voidRooAbsData::add(const RooArgSet& row, Double_t weight = 1, Double_t weightError = 0); voidRooAbsData::addOwnedComponent(const char* idxlabel, RooAbsData& data); virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsData::attachBuffers(const RooArgSet& extObs); virtual voidTObject::Browse(TBrowser* b); Bool_tRooAbsData::canSplitFast() const; virtual Bool_tRooAbsData::changeObservableName(const char* from, const char* to); voidRooAbsData::checkInit() const; static voidRooAbsData::claimVars(RooAbsData*); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; voidRooAbsData::convertToVectorStore(); virtual voidTNamed::Copy(TObject& named) const; Double_tRooAbsData::correlation(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRange = 0) const; TMatrixDSym*RooAbsData::correlationMatrix(const char* cutSpec = 0, const char* cutRange = 0) const; TMatrixDSym*RooAbsData::correlationMatrix(const RooArgList& vars, const char* cutSpec = 0, const char* cutRange = 0) const; Double_tRooAbsData::covariance(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRange = 0) const; TMatrixDSym*RooAbsData::cov",MatchSource.WIKI,root/html532/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeData.html
https://root.cern/root/html532/RooTreeData.html:3556,Availability,Error,Error,3556,"oCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; virtual Int_tRooAbsData::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidRooAbsData::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual RooAbsData*RooAbsData::emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidRooAbsData::fill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TH1*RooAbsData::fillHistogram(TH1* hist, const RooArgList& plotVars, const char* cuts = """", const char* cutRange = 0) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const RooArgSet*RooAbsData::get() const; virtual const RooArgSet*RooAbsData::get(Int_t index) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char",MatchSource.WIKI,root/html532/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeData.html
https://root.cern/root/html532/RooTreeData.html:3685,Availability,error,error,3685,"oCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; virtual Int_tRooAbsData::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidRooAbsData::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual RooAbsData*RooAbsData::emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidRooAbsData::fill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TH1*RooAbsData::fillHistogram(TH1* hist, const RooArgList& plotVars, const char* cuts = """", const char* cutRange = 0) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const RooArgSet*RooAbsData::get() const; virtual const RooArgSet*RooAbsData::get(Int_t index) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() c",MatchSource.WIKI,root/html532/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeData.html
https://root.cern/root/html532/RooTreeData.html:3769,Availability,error,error,3769,"RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; virtual Int_tRooAbsData::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidRooAbsData::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual RooAbsData*RooAbsData::emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidRooAbsData::fill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TH1*RooAbsData::fillHistogram(TH1* hist, const RooArgList& plotVars, const char* cuts = """", const char* cutRange = 0) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const RooArgSet*RooAbsData::get() const; virtual const RooArgSet*RooAbsData::get(Int_t index) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Bool_tRooAbsData::getRange(RooRealVar& var, Double_t& lowest, Double_t& highes",MatchSource.WIKI,root/html532/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeData.html
https://root.cern/root/html532/RooTreeData.html:12204,Availability,Error,ErrorType,12204,"mdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooPlot*RooAbsData::statOn(RooPlot* frame, const char* what, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.15, Double_t xmax = 0.65, Double_t ymax = 0.85, const char* cutSpec = 0, const char* cutRange = 0, const RooCmdArg* formatCmd = 0); RooAbsDataStore*RooAbsData::store(); const RooAbsDataStore*RooAbsData::store() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual Double_tRooAbsData::sumEntries() const; virtual Double_tRooAbsData::sumEntries(const char* cutSpec, const char* cutRange = 0) const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual Roo1DTable*RooAbsData::table(const RooArgSet& catSet, const char* cuts = """", const char* opts = """") const; virtual Roo1DTable*RooAbsData::table(const RooAbsCategory& cat, const char* cuts = """", const char* opts = """") const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const TTree*RooAbsData::tree() const; virtual voidTObject::UseCurrentStyle(); virtual Bool_tRooAbsData::valid() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Double_tRooAbsData::weight() const; virtual Double_tRooAbsData::weightError(RooAbsData::ErrorType etype = Poisson) const; virtual voidRooAbsData::weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = Poisson) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. Bool_tRooAbsData::allClientsCached(RooAbsArg*, const RooArgSet&); virtual voidRooAbsData::attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidRooAbsData::cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); virtual RooAbsData*RooAbsData",MatchSource.WIKI,root/html532/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeData.html
https://root.cern/root/html532/RooTreeData.html:12314,Availability,Error,ErrorType,12314,"mdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooPlot*RooAbsData::statOn(RooPlot* frame, const char* what, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.15, Double_t xmax = 0.65, Double_t ymax = 0.85, const char* cutSpec = 0, const char* cutRange = 0, const RooCmdArg* formatCmd = 0); RooAbsDataStore*RooAbsData::store(); const RooAbsDataStore*RooAbsData::store() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual Double_tRooAbsData::sumEntries() const; virtual Double_tRooAbsData::sumEntries(const char* cutSpec, const char* cutRange = 0) const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual Roo1DTable*RooAbsData::table(const RooArgSet& catSet, const char* cuts = """", const char* opts = """") const; virtual Roo1DTable*RooAbsData::table(const RooAbsCategory& cat, const char* cuts = """", const char* opts = """") const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const TTree*RooAbsData::tree() const; virtual voidTObject::UseCurrentStyle(); virtual Bool_tRooAbsData::valid() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Double_tRooAbsData::weight() const; virtual Double_tRooAbsData::weightError(RooAbsData::ErrorType etype = Poisson) const; virtual voidRooAbsData::weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = Poisson) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. Bool_tRooAbsData::allClientsCached(RooAbsArg*, const RooArgSet&); virtual voidRooAbsData::attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidRooAbsData::cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); virtual RooAbsData*RooAbsData",MatchSource.WIKI,root/html532/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeData.html
https://root.cern/root/html532/RooTreeData.html:14191,Availability,Error,ErrorType,14191,"onst RooArgSet& cacheList, const RooArgSet& keepObsList); virtual RooPlot*RooAbsData::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; virtual RooAbsData*RooAbsData::reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidRooAbsData::resetCache(); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum RooAbsData::ErrorType { Poisson; SumW2; None; Auto; };; enum RooAbsData::StorageType { Tree; Vector; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static RooAbsData::StorageTypeRooAbsData::defaultStorageType. protected:. TIterator*RooAbsData::_cacheIter! Iterator over cached variables; RooArgSetRooAbsData::_cachedVars! External variables cached with this data set; RooAbsDataStore*RooAbsData::_dstoreData storage implementation; TIterator*RooAbsData::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<std::string,RooAbsData*>RooAbsData::_ownedComponentsOwned external components; RooArgSetRooAbsData::_varsDimensions of this data set; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TString_blindStringBlinding string (optionally read from ASCII files) ; TTree*_treeTTree",MatchSource.WIKI,root/html532/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeData.html
https://root.cern/root/html532/RooTreeData.html:9126,Deployability,release,releaseVars,9126,"am(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_tRooAbsData::releaseVars(RooAbsData*); virtual voidRooAbsData::reset(); voidTObject::ResetBit(UInt_t f); voidRooAbsData::resetBuffers(); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidRooAbsData::setDirtyProp(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); Double_tRooAbsData::sigma(RooRealVar& var, const char* cutSpec =",MatchSource.WIKI,root/html532/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeData.html
https://root.cern/root/html532/RooTreeData.html:8535,Energy Efficiency,reduce,reduce,8535,"dArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; virtual voidTObject::Pop(); virtual voidRooAbsData::Print(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidRooAbsData::printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_tRooAbsData::releaseVars(RooAbsData*); virtual voidRooAbsData::reset(); voidTObject::ResetBit(UInt_t f); voidRooAbsData::resetBuffers(); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(U",MatchSource.WIKI,root/html532/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeData.html
https://root.cern/root/html532/RooTreeData.html:8583,Energy Efficiency,reduce,reduce,8583,":none()) const; virtual voidTObject::Pop(); virtual voidRooAbsData::Print(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidRooAbsData::printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_tRooAbsData::releaseVars(RooAbsData*); virtual voidRooAbsData::reset(); voidTObject::ResetBit(UInt_t f); voidRooAbsData::resetBuffers(); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t s",MatchSource.WIKI,root/html532/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeData.html
https://root.cern/root/html532/RooTreeData.html:8643,Energy Efficiency,reduce,reduce,8643,"bsData::Print(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidRooAbsData::printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_tRooAbsData::releaseVars(RooAbsData*); virtual voidRooAbsData::reset(); voidTObject::ResetBit(UInt_t f); voidRooAbsData::resetBuffers(); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidRooAbsData::setDirtyProp(Bool_t flag); virtual void",MatchSource.WIKI,root/html532/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeData.html
https://root.cern/root/html532/RooTreeData.html:8723,Energy Efficiency,reduce,reduce,8723,"ss(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidRooAbsData::printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_tRooAbsData::releaseVars(RooAbsData*); virtual voidRooAbsData::reset(); voidTObject::ResetBit(UInt_t f); voidRooAbsData::resetBuffers(); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidRooAbsData::setDirtyProp(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorO",MatchSource.WIKI,root/html532/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeData.html
https://root.cern/root/html532/RooTreeData.html:8811,Energy Efficiency,reduce,reduce,8811,"oidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidRooAbsData::printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_tRooAbsData::releaseVars(RooAbsData*); virtual voidRooAbsData::reset(); voidTObject::ResetBit(UInt_t f); voidRooAbsData::resetBuffers(); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidRooAbsData::setDirtyProp(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::",MatchSource.WIKI,root/html532/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeData.html
https://root.cern/root/html532/RooTreeData.html:13874,Energy Efficiency,reduce,reduceEng,13874,"t; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. Bool_tRooAbsData::allClientsCached(RooAbsArg*, const RooArgSet&); virtual voidRooAbsData::attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidRooAbsData::cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); virtual RooAbsData*RooAbsData::cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0); Double_tRooAbsData::corrcov(RooRealVar& x, RooRealVar& y, const char* cutSpec, const char* cutRange, Bool_t corr) const; TMatrixDSym*RooAbsData::corrcovMatrix(const RooArgList& vars, const char* cutSpec, const char* cutRange, Bool_t corr) const; RooRealVar*RooAbsData::dataRealVar(const char* methodname, RooRealVar& extVar) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); virtual voidRooAbsData::optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); virtual RooPlot*RooAbsData::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; virtual RooAbsData*RooAbsData::reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidRooAbsData::resetCache(); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum RooAbsData::ErrorType { Poisson; SumW2; None; Auto; };; enum RooAbsData::StorageType { Tree; Vector; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCa",MatchSource.WIKI,root/html532/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeData.html
https://root.cern/root/html532/RooTreeData.html:5204,Modifiability,Inherit,InheritsFrom,5204,"t*TObject::FindObject(const TObject* obj) const; virtual const RooArgSet*RooAbsData::get() const; virtual const RooArgSet*RooAbsData::get(Int_t index) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Bool_tRooAbsData::getRange(RooRealVar& var, Double_t& lowest, Double_t& highest, Double_t marginFrac = 0, Bool_t symMode = kFALSE) const; RooAbsData*RooAbsData::getSimData(const char* idxstate); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tRooAbsData::hasFilledCache() const; virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsData::isNonPoissonWeighted() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tRooAbsData::isWeighted() const; Bool_tTObject::IsZombie() const; Double_tRooAbsData::kurtosis(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; Double_tRooAbsData::mean(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; RooRealVar*RooAbsData::meanVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; Double_tRooAbsData::moment(RooRealVar& var, Double_t order, const char* cutS",MatchSource.WIKI,root/html532/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeData.html
https://root.cern/root/html532/RooTreeData.html:5270,Modifiability,Inherit,InheritsFrom,5270,"ArgSet*RooAbsData::get() const; virtual const RooArgSet*RooAbsData::get(Int_t index) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Bool_tRooAbsData::getRange(RooRealVar& var, Double_t& lowest, Double_t& highest, Double_t marginFrac = 0, Bool_t symMode = kFALSE) const; RooAbsData*RooAbsData::getSimData(const char* idxstate); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tRooAbsData::hasFilledCache() const; virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsData::isNonPoissonWeighted() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tRooAbsData::isWeighted() const; Bool_tTObject::IsZombie() const; Double_tRooAbsData::kurtosis(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; Double_tRooAbsData::mean(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; RooRealVar*RooAbsData::meanVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; Double_tRooAbsData::moment(RooRealVar& var, Double_t order, const char* cutSpec = 0, const char* cutRange = 0) const; Double_tRooAbsData::mome",MatchSource.WIKI,root/html532/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeData.html
https://root.cern/root/html532/RooTreeData.html:14891,Modifiability,variab,variables,14891,"irtual RooAbsData*RooAbsData::reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidRooAbsData::resetCache(); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum RooAbsData::ErrorType { Poisson; SumW2; None; Auto; };; enum RooAbsData::StorageType { Tree; Vector; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static RooAbsData::StorageTypeRooAbsData::defaultStorageType. protected:. TIterator*RooAbsData::_cacheIter! Iterator over cached variables; RooArgSetRooAbsData::_cachedVars! External variables cached with this data set; RooAbsDataStore*RooAbsData::_dstoreData storage implementation; TIterator*RooAbsData::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<std::string,RooAbsData*>RooAbsData::_ownedComponentsOwned external components; RooArgSetRooAbsData::_varsDimensions of this data set; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TString_blindStringBlinding string (optionally read from ASCII files) ; TTree*_treeTTree holding the data points; RooArgSet_truthTruth variables . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation.  Last changed: Thu Nov 3 20:10:00 2011  Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeData.html
https://root.cern/root/html532/RooTreeData.html:14945,Modifiability,variab,variables,14945,"irtual RooAbsData*RooAbsData::reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidRooAbsData::resetCache(); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum RooAbsData::ErrorType { Poisson; SumW2; None; Auto; };; enum RooAbsData::StorageType { Tree; Vector; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static RooAbsData::StorageTypeRooAbsData::defaultStorageType. protected:. TIterator*RooAbsData::_cacheIter! Iterator over cached variables; RooArgSetRooAbsData::_cachedVars! External variables cached with this data set; RooAbsDataStore*RooAbsData::_dstoreData storage implementation; TIterator*RooAbsData::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<std::string,RooAbsData*>RooAbsData::_ownedComponentsOwned external components; RooArgSetRooAbsData::_varsDimensions of this data set; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TString_blindStringBlinding string (optionally read from ASCII files) ; TTree*_treeTTree holding the data points; RooArgSet_truthTruth variables . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation.  Last changed: Thu Nov 3 20:10:00 2011  Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeData.html
https://root.cern/root/html532/RooTreeData.html:15103,Modifiability,variab,variables,15103,"irtual RooAbsData*RooAbsData::reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidRooAbsData::resetCache(); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum RooAbsData::ErrorType { Poisson; SumW2; None; Auto; };; enum RooAbsData::StorageType { Tree; Vector; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static RooAbsData::StorageTypeRooAbsData::defaultStorageType. protected:. TIterator*RooAbsData::_cacheIter! Iterator over cached variables; RooArgSetRooAbsData::_cachedVars! External variables cached with this data set; RooAbsDataStore*RooAbsData::_dstoreData storage implementation; TIterator*RooAbsData::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<std::string,RooAbsData*>RooAbsData::_ownedComponentsOwned external components; RooArgSetRooAbsData::_varsDimensions of this data set; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TString_blindStringBlinding string (optionally read from ASCII files) ; TTree*_treeTTree holding the data points; RooArgSet_truthTruth variables . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation.  Last changed: Thu Nov 3 20:10:00 2011  Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeData.html
https://root.cern/root/html532/RooTreeData.html:15510,Modifiability,variab,variables,15510,"irtual RooAbsData*RooAbsData::reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidRooAbsData::resetCache(); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum RooAbsData::ErrorType { Poisson; SumW2; None; Auto; };; enum RooAbsData::StorageType { Tree; Vector; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static RooAbsData::StorageTypeRooAbsData::defaultStorageType. protected:. TIterator*RooAbsData::_cacheIter! Iterator over cached variables; RooArgSetRooAbsData::_cachedVars! External variables cached with this data set; RooAbsDataStore*RooAbsData::_dstoreData storage implementation; TIterator*RooAbsData::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<std::string,RooAbsData*>RooAbsData::_ownedComponentsOwned external components; RooArgSetRooAbsData::_varsDimensions of this data set; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TString_blindStringBlinding string (optionally read from ASCII files) ; TTree*_treeTTree holding the data points; RooArgSet_truthTruth variables . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation.  Last changed: Thu Nov 3 20:10:00 2011  Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeData.html
https://root.cern/root/html532/RooTreeData.html:15536,Modifiability,Inherit,Inheritance,15536,"irtual RooAbsData*RooAbsData::reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidRooAbsData::resetCache(); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum RooAbsData::ErrorType { Poisson; SumW2; None; Auto; };; enum RooAbsData::StorageType { Tree; Vector; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static RooAbsData::StorageTypeRooAbsData::defaultStorageType. protected:. TIterator*RooAbsData::_cacheIter! Iterator over cached variables; RooArgSetRooAbsData::_cachedVars! External variables cached with this data set; RooAbsDataStore*RooAbsData::_dstoreData storage implementation; TIterator*RooAbsData::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<std::string,RooAbsData*>RooAbsData::_ownedComponentsOwned external components; RooArgSetRooAbsData::_varsDimensions of this data set; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TString_blindStringBlinding string (optionally read from ASCII files) ; TTree*_treeTTree holding the data points; RooArgSet_truthTruth variables . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation.  Last changed: Thu Nov 3 20:10:00 2011  Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeData.html
https://root.cern/root/html532/RooTreeData.html:15549,Modifiability,Inherit,Inherited,15549,"irtual RooAbsData*RooAbsData::reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidRooAbsData::resetCache(); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum RooAbsData::ErrorType { Poisson; SumW2; None; Auto; };; enum RooAbsData::StorageType { Tree; Vector; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static RooAbsData::StorageTypeRooAbsData::defaultStorageType. protected:. TIterator*RooAbsData::_cacheIter! Iterator over cached variables; RooArgSetRooAbsData::_cachedVars! External variables cached with this data set; RooAbsDataStore*RooAbsData::_dstoreData storage implementation; TIterator*RooAbsData::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<std::string,RooAbsData*>RooAbsData::_ownedComponentsOwned external components; RooArgSetRooAbsData::_varsDimensions of this data set; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TString_blindStringBlinding string (optionally read from ASCII files) ; TTree*_treeTTree holding the data points; RooArgSet_truthTruth variables . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation.  Last changed: Thu Nov 3 20:10:00 2011  Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeData.html
https://root.cern/root/html532/RooTreeData.html:12688,Performance,cache,cachedVars,12688,"t; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. Bool_tRooAbsData::allClientsCached(RooAbsArg*, const RooArgSet&); virtual voidRooAbsData::attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidRooAbsData::cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); virtual RooAbsData*RooAbsData::cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0); Double_tRooAbsData::corrcov(RooRealVar& x, RooRealVar& y, const char* cutSpec, const char* cutRange, Bool_t corr) const; TMatrixDSym*RooAbsData::corrcovMatrix(const RooArgList& vars, const char* cutSpec, const char* cutRange, Bool_t corr) const; RooRealVar*RooAbsData::dataRealVar(const char* methodname, RooRealVar& extVar) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); virtual voidRooAbsData::optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); virtual RooPlot*RooAbsData::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; virtual RooAbsData*RooAbsData::reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidRooAbsData::resetCache(); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum RooAbsData::ErrorType { Poisson; SumW2; None; Auto; };; enum RooAbsData::StorageType { Tree; Vector; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCa",MatchSource.WIKI,root/html532/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeData.html
https://root.cern/root/html532/RooTreeData.html:12725,Performance,cache,cacheArgs,12725,"t; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. Bool_tRooAbsData::allClientsCached(RooAbsArg*, const RooArgSet&); virtual voidRooAbsData::attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidRooAbsData::cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); virtual RooAbsData*RooAbsData::cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0); Double_tRooAbsData::corrcov(RooRealVar& x, RooRealVar& y, const char* cutSpec, const char* cutRange, Bool_t corr) const; TMatrixDSym*RooAbsData::corrcovMatrix(const RooArgList& vars, const char* cutSpec, const char* cutRange, Bool_t corr) const; RooRealVar*RooAbsData::dataRealVar(const char* methodname, RooRealVar& extVar) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); virtual voidRooAbsData::optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); virtual RooPlot*RooAbsData::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; virtual RooAbsData*RooAbsData::reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidRooAbsData::resetCache(); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum RooAbsData::ErrorType { Poisson; SumW2; None; Auto; };; enum RooAbsData::StorageType { Tree; Vector; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCa",MatchSource.WIKI,root/html532/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeData.html
https://root.cern/root/html532/RooTreeData.html:12837,Performance,cache,cacheClone,12837,"t; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. Bool_tRooAbsData::allClientsCached(RooAbsArg*, const RooArgSet&); virtual voidRooAbsData::attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidRooAbsData::cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); virtual RooAbsData*RooAbsData::cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0); Double_tRooAbsData::corrcov(RooRealVar& x, RooRealVar& y, const char* cutSpec, const char* cutRange, Bool_t corr) const; TMatrixDSym*RooAbsData::corrcovMatrix(const RooArgList& vars, const char* cutSpec, const char* cutRange, Bool_t corr) const; RooRealVar*RooAbsData::dataRealVar(const char* methodname, RooRealVar& extVar) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); virtual voidRooAbsData::optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); virtual RooPlot*RooAbsData::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; virtual RooAbsData*RooAbsData::reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidRooAbsData::resetCache(); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum RooAbsData::ErrorType { Poisson; SumW2; None; Auto; };; enum RooAbsData::StorageType { Tree; Vector; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCa",MatchSource.WIKI,root/html532/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeData.html
https://root.cern/root/html532/RooTreeData.html:13418,Performance,optimiz,optimizeReadingWithCaching,13418,"t; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. Bool_tRooAbsData::allClientsCached(RooAbsArg*, const RooArgSet&); virtual voidRooAbsData::attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidRooAbsData::cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); virtual RooAbsData*RooAbsData::cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0); Double_tRooAbsData::corrcov(RooRealVar& x, RooRealVar& y, const char* cutSpec, const char* cutRange, Bool_t corr) const; TMatrixDSym*RooAbsData::corrcovMatrix(const RooArgList& vars, const char* cutSpec, const char* cutRange, Bool_t corr) const; RooRealVar*RooAbsData::dataRealVar(const char* methodname, RooRealVar& extVar) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); virtual voidRooAbsData::optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); virtual RooPlot*RooAbsData::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; virtual RooAbsData*RooAbsData::reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidRooAbsData::resetCache(); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum RooAbsData::ErrorType { Poisson; SumW2; None; Auto; };; enum RooAbsData::StorageType { Tree; Vector; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCa",MatchSource.WIKI,root/html532/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeData.html
https://root.cern/root/html532/RooTreeData.html:13478,Performance,cache,cacheList,13478,"t; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. Bool_tRooAbsData::allClientsCached(RooAbsArg*, const RooArgSet&); virtual voidRooAbsData::attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidRooAbsData::cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); virtual RooAbsData*RooAbsData::cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0); Double_tRooAbsData::corrcov(RooRealVar& x, RooRealVar& y, const char* cutSpec, const char* cutRange, Bool_t corr) const; TMatrixDSym*RooAbsData::corrcovMatrix(const RooArgList& vars, const char* cutSpec, const char* cutRange, Bool_t corr) const; RooRealVar*RooAbsData::dataRealVar(const char* methodname, RooRealVar& extVar) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); virtual voidRooAbsData::optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); virtual RooPlot*RooAbsData::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; virtual RooAbsData*RooAbsData::reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidRooAbsData::resetCache(); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum RooAbsData::ErrorType { Poisson; SumW2; None; Auto; };; enum RooAbsData::StorageType { Tree; Vector; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCa",MatchSource.WIKI,root/html532/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeData.html
https://root.cern/root/html532/RooTreeData.html:14884,Performance,cache,cached,14884,"irtual RooAbsData*RooAbsData::reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidRooAbsData::resetCache(); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum RooAbsData::ErrorType { Poisson; SumW2; None; Auto; };; enum RooAbsData::StorageType { Tree; Vector; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static RooAbsData::StorageTypeRooAbsData::defaultStorageType. protected:. TIterator*RooAbsData::_cacheIter! Iterator over cached variables; RooArgSetRooAbsData::_cachedVars! External variables cached with this data set; RooAbsDataStore*RooAbsData::_dstoreData storage implementation; TIterator*RooAbsData::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<std::string,RooAbsData*>RooAbsData::_ownedComponentsOwned external components; RooArgSetRooAbsData::_varsDimensions of this data set; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TString_blindStringBlinding string (optionally read from ASCII files) ; TTree*_treeTTree holding the data points; RooArgSet_truthTruth variables . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation.  Last changed: Thu Nov 3 20:10:00 2011  Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeData.html
https://root.cern/root/html532/RooTreeData.html:14955,Performance,cache,cached,14955,"irtual RooAbsData*RooAbsData::reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidRooAbsData::resetCache(); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum RooAbsData::ErrorType { Poisson; SumW2; None; Auto; };; enum RooAbsData::StorageType { Tree; Vector; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static RooAbsData::StorageTypeRooAbsData::defaultStorageType. protected:. TIterator*RooAbsData::_cacheIter! Iterator over cached variables; RooArgSetRooAbsData::_cachedVars! External variables cached with this data set; RooAbsDataStore*RooAbsData::_dstoreData storage implementation; TIterator*RooAbsData::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<std::string,RooAbsData*>RooAbsData::_ownedComponentsOwned external components; RooArgSetRooAbsData::_varsDimensions of this data set; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TString_blindStringBlinding string (optionally read from ASCII files) ; TTree*_treeTTree holding the data points; RooArgSet_truthTruth variables . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation.  Last changed: Thu Nov 3 20:10:00 2011  Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeData.html
https://root.cern/root/html532/RooTreeData.html:5094,Security,Hash,Hash,5094,"= """", const char* cutRange = 0) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const RooArgSet*RooAbsData::get() const; virtual const RooArgSet*RooAbsData::get(Int_t index) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Bool_tRooAbsData::getRange(RooRealVar& var, Double_t& lowest, Double_t& highest, Double_t marginFrac = 0, Bool_t symMode = kFALSE) const; RooAbsData*RooAbsData::getSimData(const char* idxstate); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tRooAbsData::hasFilledCache() const; virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsData::isNonPoissonWeighted() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tRooAbsData::isWeighted() const; Bool_tTObject::IsZombie() const; Double_tRooAbsData::kurtosis(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; Double_tRooAbsData::mean(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; RooRealVar*RooAbsData::meanVar(RooRealVar& var, const char* cutSpec ",MatchSource.WIKI,root/html532/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeData.html
https://root.cern/root/html532/RooTreeData.html:11848,Testability,Test,TestBit,11848,"mdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooPlot*RooAbsData::statOn(RooPlot* frame, const char* what, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.15, Double_t xmax = 0.65, Double_t ymax = 0.85, const char* cutSpec = 0, const char* cutRange = 0, const RooCmdArg* formatCmd = 0); RooAbsDataStore*RooAbsData::store(); const RooAbsDataStore*RooAbsData::store() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual Double_tRooAbsData::sumEntries() const; virtual Double_tRooAbsData::sumEntries(const char* cutSpec, const char* cutRange = 0) const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual Roo1DTable*RooAbsData::table(const RooArgSet& catSet, const char* cuts = """", const char* opts = """") const; virtual Roo1DTable*RooAbsData::table(const RooAbsCategory& cat, const char* cuts = """", const char* opts = """") const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const TTree*RooAbsData::tree() const; virtual voidTObject::UseCurrentStyle(); virtual Bool_tRooAbsData::valid() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Double_tRooAbsData::weight() const; virtual Double_tRooAbsData::weightError(RooAbsData::ErrorType etype = Poisson) const; virtual voidRooAbsData::weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = Poisson) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. Bool_tRooAbsData::allClientsCached(RooAbsArg*, const RooArgSet&); virtual voidRooAbsData::attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidRooAbsData::cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); virtual RooAbsData*RooAbsData",MatchSource.WIKI,root/html532/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeData.html
https://root.cern/root/html532/RooTreeData.html:11887,Testability,Test,TestBits,11887,"mdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooPlot*RooAbsData::statOn(RooPlot* frame, const char* what, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.15, Double_t xmax = 0.65, Double_t ymax = 0.85, const char* cutSpec = 0, const char* cutRange = 0, const RooCmdArg* formatCmd = 0); RooAbsDataStore*RooAbsData::store(); const RooAbsDataStore*RooAbsData::store() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual Double_tRooAbsData::sumEntries() const; virtual Double_tRooAbsData::sumEntries(const char* cutSpec, const char* cutRange = 0) const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual Roo1DTable*RooAbsData::table(const RooArgSet& catSet, const char* cuts = """", const char* opts = """") const; virtual Roo1DTable*RooAbsData::table(const RooAbsCategory& cat, const char* cuts = """", const char* opts = """") const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const TTree*RooAbsData::tree() const; virtual voidTObject::UseCurrentStyle(); virtual Bool_tRooAbsData::valid() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Double_tRooAbsData::weight() const; virtual Double_tRooAbsData::weightError(RooAbsData::ErrorType etype = Poisson) const; virtual voidRooAbsData::weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = Poisson) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. Bool_tRooAbsData::allClientsCached(RooAbsArg*, const RooArgSet&); virtual voidRooAbsData::attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidRooAbsData::cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); virtual RooAbsData*RooAbsData",MatchSource.WIKI,root/html532/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeData.html
https://root.cern/root/html532/RooTreeData.html:1274,Usability,Clear,Clear,1274," ~RooTreeData(); voidTObject::AbstractMethod(const char* method) const; virtual voidRooAbsData::add(const RooArgSet& row, Double_t weight = 1, Double_t weightError = 0); voidRooAbsData::addOwnedComponent(const char* idxlabel, RooAbsData& data); virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsData::attachBuffers(const RooArgSet& extObs); virtual voidTObject::Browse(TBrowser* b); Bool_tRooAbsData::canSplitFast() const; virtual Bool_tRooAbsData::changeObservableName(const char* from, const char* to); voidRooAbsData::checkInit() const; static voidRooAbsData::claimVars(RooAbsData*); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; voidRooAbsData::convertToVectorStore(); virtual voidTNamed::Copy(TObject& named) const; Double_tRooAbsData::correlation(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRange = 0) const; TMatrixDSym*RooAbsData::correlationMatrix(const char* cutSpec = 0, const char* cutRange = 0) const; TMatrixDSym*RooAbsData::correlationMatrix(const RooArgList& vars, const char* cutSpec = 0, const char* cutRange = 0) const; Double_tRooAbsData::covariance(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRange = 0) const; TMatrixDSym*RooAbsData::cov",MatchSource.WIKI,root/html532/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeData.html
https://root.cern/root/html532/RooTreeDataStore.html:3442,Availability,Error,Error,3442,"oidTNamed::Clear(Option_t* option = """"); virtual RooAbsDataStore*clone(const char* newname = 0) const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooAbsDataStore::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsDataStore::dirtyProp() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidRooAbsDataStore::dump(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tfill(); Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const RooArgSet*get(Int_t index) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Stat_tGetEntries() const; Int_tGetEntry(Int_t entry = 0, Int_t getall = 0); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:3571,Availability,error,error,3571,"one(const char* newname = """") const; virtual RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooAbsDataStore::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsDataStore::dirtyProp() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidRooAbsDataStore::dump(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tfill(); Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const RooArgSet*get(Int_t index) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Stat_tGetEntries() const; Int_tGetEntry(Int_t entry = 0, Int_t getall = 0); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:3655,Availability,error,error,3655,"vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooAbsDataStore::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsDataStore::dirtyProp() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidRooAbsDataStore::dump(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tfill(); Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const RooArgSet*get(Int_t index) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Stat_tGetEntries() const; Int_tGetEntry(Int_t entry = 0, Int_t getall = 0); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tRooAbsDataStore::hasFilledCache() const; virtual",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:9151,Availability,Error,ErrorType,9151,"voidTObject::ResetBit(UInt_t f); virtual voidresetBuffers(); virtual voidresetCache(); voidrestoreAlternateBuffers(); const RooArgSet&row(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidsetArgStatus(const RooArgSet& set, Bool_t active); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsDataStore::setDirtyProp(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidsetExternalWeightArray(Double_t* arrayWgt, Double_t* arrayWgtErrLo, Double_t* arrayWgtErrHi, Double_t* arraySumW2); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual Double_tsumEntries() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TTree&tree(); virtual const TTree*tree() const; virtual voidTObject::UseCurrentStyle(); virtual Bool_tvalid() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Double_tweight() const; virtual Double_tweight(Int_t index) const; virtual Double_tweightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const; virtual voidweightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:9261,Availability,Error,ErrorType,9261,"voidTObject::ResetBit(UInt_t f); virtual voidresetBuffers(); virtual voidresetCache(); voidrestoreAlternateBuffers(); const RooArgSet&row(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidsetArgStatus(const RooArgSet& set, Bool_t active); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsDataStore::setDirtyProp(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidsetExternalWeightArray(Double_t* arrayWgt, Double_t* arrayWgtErrLo, Double_t* arrayWgtErrHi, Double_t* arraySumW2); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual Double_tsumEntries() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TTree&tree(); virtual const TTree*tree() const; virtual voidTObject::UseCurrentStyle(); virtual Bool_tvalid() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Double_tweight() const; virtual Double_tweight(Int_t index) const; virtual Double_tweightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const; virtual voidweightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:11341,Availability,error,error,11341,"ck; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooArgSet_attachedBuffers! Currently attached buffers (if different from _varsww); TIterator*RooAbsDataStore::_cacheIter! Iterator over cached variables; const RooAbsArg*_cacheOwner! Object owning cache contents; TTree*_cacheTree! TTree holding the cached function values; RooArgSetRooAbsDataStore::_cachedVars; Double_t_curWgtWeight of current event; Double_t_curWgtErrWeight of current event; Double_t_curWgtErrHiWeight of current event; Double_t_curWgtErrLoWeight of current event; Bool_t_defCtor! Was object constructed with default ctor?; static Int_t_defTreeBufSize; Bool_tRooAbsDataStore::_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; Double_t*_extSumW2Array! External sum of weights array; Double_t*_extWgtArray! External weight array; Double_t*_extWgtErrHiArray! External weight array - high error; Double_t*_extWgtErrLoArray! External weight array - low error; TIterator*RooAbsDataStore::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; TTree*_treeTTree holding the data points; RooArgSetRooAbsDataStore::_vars; RooArgSet_varsww; RooRealVar*_wgtVarPointer to weight variable (if set); TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooTreeDataStore(). RooTreeDataStore(TTree* t, const RooArgSet& vars, const char* wgtVarName = 0); Constructor to facilitate reading of legacy RooDataSets. RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const char* wgtVarName = 0). RooTreeDataStore(const c",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:11404,Availability,error,error,11404,"ck; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooArgSet_attachedBuffers! Currently attached buffers (if different from _varsww); TIterator*RooAbsDataStore::_cacheIter! Iterator over cached variables; const RooAbsArg*_cacheOwner! Object owning cache contents; TTree*_cacheTree! TTree holding the cached function values; RooArgSetRooAbsDataStore::_cachedVars; Double_t_curWgtWeight of current event; Double_t_curWgtErrWeight of current event; Double_t_curWgtErrHiWeight of current event; Double_t_curWgtErrLoWeight of current event; Bool_t_defCtor! Was object constructed with default ctor?; static Int_t_defTreeBufSize; Bool_tRooAbsDataStore::_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; Double_t*_extSumW2Array! External sum of weights array; Double_t*_extWgtArray! External weight array; Double_t*_extWgtErrHiArray! External weight array - high error; Double_t*_extWgtErrLoArray! External weight array - low error; TIterator*RooAbsDataStore::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; TTree*_treeTTree holding the data points; RooArgSetRooAbsDataStore::_vars; RooArgSet_varsww; RooRealVar*_wgtVarPointer to weight variable (if set); TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooTreeDataStore(). RooTreeDataStore(TTree* t, const RooArgSet& vars, const char* wgtVarName = 0); Constructor to facilitate reading of legacy RooDataSets. RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const char* wgtVarName = 0). RooTreeDataStore(const c",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:15149,Availability,Error,ErrorType,15149,"electing events using 'select' RooFormulaVar. The source tree 't' is first clone as not disturb its branch; structure when retrieving information from it. void loadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); Load values from dataset 't' into this data collection, optionally; selecting events using 'select' RooFormulaVar. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. Int_t fill(); Interface function to TTree::Fill. const RooArgSet* get(Int_t index) const; Load the n-th data point (n='index') in memory; and return a pointer to the internal RooArgSet; holding its coordinates. Double_t weight(Int_t index) const; Return the weight of the n-th data point (n='index') in memory. Double_t weight() const; Return the weight of the n-th data point (n='index') in memory. Double_t weightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Bool_t changeObservableName(const char* from, const char* to); Change name of internal observable named 'from' into 'to'. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); Add a new column to the data set which holds the pre-calculated values; of 'newVar'. This operation is only meaningful if 'newVar' is a derived; value. The return value points to the added element holding 'newVar's value; in the data collection. The element is always the corresponding fundamental; type of 'newVar' (e.g. a RooRealVar if 'newVar' is a RooFormulaVar). Note: This function is explicitly NOT intended as a speed optimization; opportunity for the user. Components of complex PDFs that can be; precalculated with the dataset are automatically identified as such; and will be precalculated when fitting to a dataset. By forcibly precalculating functions with",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:15252,Availability,Error,ErrorType,15252,"turb its branch; structure when retrieving information from it. void loadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); Load values from dataset 't' into this data collection, optionally; selecting events using 'select' RooFormulaVar. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. Int_t fill(); Interface function to TTree::Fill. const RooArgSet* get(Int_t index) const; Load the n-th data point (n='index') in memory; and return a pointer to the internal RooArgSet; holding its coordinates. Double_t weight(Int_t index) const; Return the weight of the n-th data point (n='index') in memory. Double_t weight() const; Return the weight of the n-th data point (n='index') in memory. Double_t weightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Bool_t changeObservableName(const char* from, const char* to); Change name of internal observable named 'from' into 'to'. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); Add a new column to the data set which holds the pre-calculated values; of 'newVar'. This operation is only meaningful if 'newVar' is a derived; value. The return value points to the added element holding 'newVar's value; in the data collection. The element is always the corresponding fundamental; type of 'newVar' (e.g. a RooRealVar if 'newVar' is a RooFormulaVar). Note: This function is explicitly NOT intended as a speed optimization; opportunity for the user. Components of complex PDFs that can be; precalculated with the dataset are automatically identified as such; and will be precalculated when fitting to a dataset. By forcibly precalculating functions with non-trivial Jacobians,; or functions of multiple variables occurring in the data set,; usi",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:14730,Integrability,Interface,Interface,14730,"; variables of internal ArgSet to the corresponding TTree branches. void createTree(const char* name, const char* title); Create TTree object that lives in memory, independent of current; location of gDirectory. void loadValues(const TTree* t, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); Load values from tree 't' into this data collection, optionally; selecting events using 'select' RooFormulaVar. The source tree 't' is first clone as not disturb its branch; structure when retrieving information from it. void loadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); Load values from dataset 't' into this data collection, optionally; selecting events using 'select' RooFormulaVar. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. Int_t fill(); Interface function to TTree::Fill. const RooArgSet* get(Int_t index) const; Load the n-th data point (n='index') in memory; and return a pointer to the internal RooArgSet; holding its coordinates. Double_t weight(Int_t index) const; Return the weight of the n-th data point (n='index') in memory. Double_t weight() const; Return the weight of the n-th data point (n='index') in memory. Double_t weightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Bool_t changeObservableName(const char* from, const char* to); Change name of internal observable named 'from' into 'to'. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); Add a new column to the data set which holds the pre-calculated values; of 'newVar'. This operation is only meaningful if 'newVar' is a derived; value. The return value points to the added element holding 'newVar's value; in the data collection. The elem",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:17750,Integrability,Interface,Interface,17750,"mns the column of the last dataset in the list; prevails. void append(RooAbsDataStore& other). Double_t sumEntries() const. Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void setArgStatus(const RooArgSet& set, Bool_t active); Activate or deactivate the branch status of the TTree branch associated; with the given set of dataset observables. void resetCache(); Remove tree with values of cached observables; and clear list of cached observables. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void restoreAlternateBuffers(). void checkInit() const. Stat_t GetEntries() const; Interface function to TTree::GetEntries. void Reset(Option_t* option = 0); Interface function to TTree::Reset. Int_t Fill(); Interface function to TTree::Fill. Int_t GetEntry(Int_t entry = 0, Int_t getall = 0); Interface function to TTree::GetEntry. void Draw(Option_t* option = """"). void Streamer(TBuffer& b); Stream an object of class RooTreeDataStore. RooAbsDataStore* clone(const char* newname = 0) const; { return new RooTreeDataStore(*this,newname) ; }. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const; { return new RooTreeDataStore(*this,vars,newname) ; }. Bool_t isWeighted() const; { return (_wgtVar!=0||_extWgtArray!=0) ; }. TTree& tree(); Tree access. { return *_tree ; }. const TTree* tree() const; { return _tree ; }. const RooAbsArg* cacheOwner(); { return _cacheOwner ; }. void setExternalWeightArray(Double_t* arrayWgt, Double_t* arrayWgtErrLo, Double_t* arrayWgtErrHi, Double_t* arraySumW2). const RooArgSet& row(); { return _varsww ; }. void setBranchBufferSi",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:17825,Integrability,Interface,Interface,17825,"(RooAbsDataStore& other). Double_t sumEntries() const. Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void setArgStatus(const RooArgSet& set, Bool_t active); Activate or deactivate the branch status of the TTree branch associated; with the given set of dataset observables. void resetCache(); Remove tree with values of cached observables; and clear list of cached observables. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void restoreAlternateBuffers(). void checkInit() const. Stat_t GetEntries() const; Interface function to TTree::GetEntries. void Reset(Option_t* option = 0); Interface function to TTree::Reset. Int_t Fill(); Interface function to TTree::Fill. Int_t GetEntry(Int_t entry = 0, Int_t getall = 0); Interface function to TTree::GetEntry. void Draw(Option_t* option = """"). void Streamer(TBuffer& b); Stream an object of class RooTreeDataStore. RooAbsDataStore* clone(const char* newname = 0) const; { return new RooTreeDataStore(*this,newname) ; }. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const; { return new RooTreeDataStore(*this,vars,newname) ; }. Bool_t isWeighted() const; { return (_wgtVar!=0||_extWgtArray!=0) ; }. TTree& tree(); Tree access. { return *_tree ; }. const TTree* tree() const; { return _tree ; }. const RooAbsArg* cacheOwner(); { return _cacheOwner ; }. void setExternalWeightArray(Double_t* arrayWgt, Double_t* arrayWgtErrLo, Double_t* arrayWgtErrHi, Double_t* arraySumW2). const RooArgSet& row(); { return _varsww ; }. void setBranchBufferSize(Int_t size); TTree Branch buffer size control. { _defTreeBufSize =",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:17875,Integrability,Interface,Interface,17875,"t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void setArgStatus(const RooArgSet& set, Bool_t active); Activate or deactivate the branch status of the TTree branch associated; with the given set of dataset observables. void resetCache(); Remove tree with values of cached observables; and clear list of cached observables. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void restoreAlternateBuffers(). void checkInit() const. Stat_t GetEntries() const; Interface function to TTree::GetEntries. void Reset(Option_t* option = 0); Interface function to TTree::Reset. Int_t Fill(); Interface function to TTree::Fill. Int_t GetEntry(Int_t entry = 0, Int_t getall = 0); Interface function to TTree::GetEntry. void Draw(Option_t* option = """"). void Streamer(TBuffer& b); Stream an object of class RooTreeDataStore. RooAbsDataStore* clone(const char* newname = 0) const; { return new RooTreeDataStore(*this,newname) ; }. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const; { return new RooTreeDataStore(*this,vars,newname) ; }. Bool_t isWeighted() const; { return (_wgtVar!=0||_extWgtArray!=0) ; }. TTree& tree(); Tree access. { return *_tree ; }. const TTree* tree() const; { return _tree ; }. const RooAbsArg* cacheOwner(); { return _cacheOwner ; }. void setExternalWeightArray(Double_t* arrayWgt, Double_t* arrayWgtErrLo, Double_t* arrayWgtErrHi, Double_t* arraySumW2). const RooArgSet& row(); { return _varsww ; }. void setBranchBufferSize(Int_t size); TTree Branch buffer size control. { _defTreeBufSize = size ; }. Int_t getBranchBufferSize() const; { return _defT",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:17961,Integrability,Interface,Interface,17961,"ner, RooArgSet& varSet, const RooArgSet* nset = 0); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void setArgStatus(const RooArgSet& set, Bool_t active); Activate or deactivate the branch status of the TTree branch associated; with the given set of dataset observables. void resetCache(); Remove tree with values of cached observables; and clear list of cached observables. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void restoreAlternateBuffers(). void checkInit() const. Stat_t GetEntries() const; Interface function to TTree::GetEntries. void Reset(Option_t* option = 0); Interface function to TTree::Reset. Int_t Fill(); Interface function to TTree::Fill. Int_t GetEntry(Int_t entry = 0, Int_t getall = 0); Interface function to TTree::GetEntry. void Draw(Option_t* option = """"). void Streamer(TBuffer& b); Stream an object of class RooTreeDataStore. RooAbsDataStore* clone(const char* newname = 0) const; { return new RooTreeDataStore(*this,newname) ; }. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const; { return new RooTreeDataStore(*this,vars,newname) ; }. Bool_t isWeighted() const; { return (_wgtVar!=0||_extWgtArray!=0) ; }. TTree& tree(); Tree access. { return *_tree ; }. const TTree* tree() const; { return _tree ; }. const RooAbsArg* cacheOwner(); { return _cacheOwner ; }. void setExternalWeightArray(Double_t* arrayWgt, Double_t* arrayWgtErrLo, Double_t* arrayWgtErrHi, Double_t* arraySumW2). const RooArgSet& row(); { return _varsww ; }. void setBranchBufferSize(Int_t size); TTree Branch buffer size control. { _defTreeBufSize = size ; }. Int_t getBranchBufferSize() const; { return _defTreeBufSize ; }.  Last changed: Fri Dec 2 14:27:15 2011  Last genera",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:4784,Modifiability,Inherit,InheritsFrom,4784,"ar* msgfmt) const; virtual Int_tfill(); Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const RooArgSet*get(Int_t index) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Stat_tGetEntries() const; Int_tGetEntry(Int_t entry = 0, Int_t getall = 0); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tRooAbsDataStore::hasFilledCache() const; virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tisWeighted() const; Bool_tTObject::IsZombie() const; voidloadValues(const TTree* t, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); virtual voidloadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual RooAbsDataStore*merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_t",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:4850,Modifiability,Inherit,InheritsFrom,4850,"Named::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const RooArgSet*get(Int_t index) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Stat_tGetEntries() const; Int_tGetEntry(Int_t entry = 0, Int_t getall = 0); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tRooAbsDataStore::hasFilledCache() const; virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tisWeighted() const; Bool_tTObject::IsZombie() const; voidloadValues(const TTree* t, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); virtual voidloadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual RooAbsDataStore*merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); virtual Int_tnumEntries() const; voidTObject::O",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:10643,Modifiability,variab,variables,10643,"ck; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooArgSet_attachedBuffers! Currently attached buffers (if different from _varsww); TIterator*RooAbsDataStore::_cacheIter! Iterator over cached variables; const RooAbsArg*_cacheOwner! Object owning cache contents; TTree*_cacheTree! TTree holding the cached function values; RooArgSetRooAbsDataStore::_cachedVars; Double_t_curWgtWeight of current event; Double_t_curWgtErrWeight of current event; Double_t_curWgtErrHiWeight of current event; Double_t_curWgtErrLoWeight of current event; Bool_t_defCtor! Was object constructed with default ctor?; static Int_t_defTreeBufSize; Bool_tRooAbsDataStore::_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; Double_t*_extSumW2Array! External sum of weights array; Double_t*_extWgtArray! External weight array; Double_t*_extWgtErrHiArray! External weight array - high error; Double_t*_extWgtErrLoArray! External weight array - low error; TIterator*RooAbsDataStore::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; TTree*_treeTTree holding the data points; RooArgSetRooAbsDataStore::_vars; RooArgSet_varsww; RooRealVar*_wgtVarPointer to weight variable (if set); TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooTreeDataStore(). RooTreeDataStore(TTree* t, const RooArgSet& vars, const char* wgtVarName = 0); Constructor to facilitate reading of legacy RooDataSets. RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const char* wgtVarName = 0). RooTreeDataStore(const c",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:11473,Modifiability,variab,variables,11473,"ck; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooArgSet_attachedBuffers! Currently attached buffers (if different from _varsww); TIterator*RooAbsDataStore::_cacheIter! Iterator over cached variables; const RooAbsArg*_cacheOwner! Object owning cache contents; TTree*_cacheTree! TTree holding the cached function values; RooArgSetRooAbsDataStore::_cachedVars; Double_t_curWgtWeight of current event; Double_t_curWgtErrWeight of current event; Double_t_curWgtErrHiWeight of current event; Double_t_curWgtErrLoWeight of current event; Bool_t_defCtor! Was object constructed with default ctor?; static Int_t_defTreeBufSize; Bool_tRooAbsDataStore::_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; Double_t*_extSumW2Array! External sum of weights array; Double_t*_extWgtArray! External weight array; Double_t*_extWgtErrHiArray! External weight array - high error; Double_t*_extWgtErrLoArray! External weight array - low error; TIterator*RooAbsDataStore::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; TTree*_treeTTree holding the data points; RooArgSetRooAbsDataStore::_vars; RooArgSet_varsww; RooRealVar*_wgtVarPointer to weight variable (if set); TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooTreeDataStore(). RooTreeDataStore(TTree* t, const RooArgSet& vars, const char* wgtVarName = 0); Constructor to facilitate reading of legacy RooDataSets. RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const char* wgtVarName = 0). RooTreeDataStore(const c",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:11652,Modifiability,variab,variable,11652,"ck; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooArgSet_attachedBuffers! Currently attached buffers (if different from _varsww); TIterator*RooAbsDataStore::_cacheIter! Iterator over cached variables; const RooAbsArg*_cacheOwner! Object owning cache contents; TTree*_cacheTree! TTree holding the cached function values; RooArgSetRooAbsDataStore::_cachedVars; Double_t_curWgtWeight of current event; Double_t_curWgtErrWeight of current event; Double_t_curWgtErrHiWeight of current event; Double_t_curWgtErrLoWeight of current event; Bool_t_defCtor! Was object constructed with default ctor?; static Int_t_defTreeBufSize; Bool_tRooAbsDataStore::_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; Double_t*_extSumW2Array! External sum of weights array; Double_t*_extWgtArray! External weight array; Double_t*_extWgtErrHiArray! External weight array - high error; Double_t*_extWgtErrLoArray! External weight array - low error; TIterator*RooAbsDataStore::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; TTree*_treeTTree holding the data points; RooArgSetRooAbsDataStore::_vars; RooArgSet_varsww; RooRealVar*_wgtVarPointer to weight variable (if set); TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooTreeDataStore(). RooTreeDataStore(TTree* t, const RooArgSet& vars, const char* wgtVarName = 0); Constructor to facilitate reading of legacy RooDataSets. RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const char* wgtVarName = 0). RooTreeDataStore(const c",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:11759,Modifiability,Inherit,Inheritance,11759,"oAbsDataStore::_cachedVars; Double_t_curWgtWeight of current event; Double_t_curWgtErrWeight of current event; Double_t_curWgtErrHiWeight of current event; Double_t_curWgtErrLoWeight of current event; Bool_t_defCtor! Was object constructed with default ctor?; static Int_t_defTreeBufSize; Bool_tRooAbsDataStore::_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; Double_t*_extSumW2Array! External sum of weights array; Double_t*_extWgtArray! External weight array; Double_t*_extWgtErrHiArray! External weight array - high error; Double_t*_extWgtErrLoArray! External weight array - low error; TIterator*RooAbsDataStore::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; TTree*_treeTTree holding the data points; RooArgSetRooAbsDataStore::_vars; RooArgSet_varsww; RooRealVar*_wgtVarPointer to weight variable (if set); TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooTreeDataStore(). RooTreeDataStore(TTree* t, const RooArgSet& vars, const char* wgtVarName = 0); Constructor to facilitate reading of legacy RooDataSets. RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const char* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, TTree& t, const RooFormulaVar& select, const char* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, TTree& t, const char* selExpr = 0, const char* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const RooAbsDataStore& tds, const RooFormulaVar& select, const char* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const RooAbsDataStore& tds, const char* selExpr = 0, const char* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, RooAbsDataStore& tds, con",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:11772,Modifiability,Inherit,Inherited,11772,"oAbsDataStore::_cachedVars; Double_t_curWgtWeight of current event; Double_t_curWgtErrWeight of current event; Double_t_curWgtErrHiWeight of current event; Double_t_curWgtErrLoWeight of current event; Bool_t_defCtor! Was object constructed with default ctor?; static Int_t_defTreeBufSize; Bool_tRooAbsDataStore::_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; Double_t*_extSumW2Array! External sum of weights array; Double_t*_extWgtArray! External weight array; Double_t*_extWgtErrHiArray! External weight array - high error; Double_t*_extWgtErrLoArray! External weight array - low error; TIterator*RooAbsDataStore::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; TTree*_treeTTree holding the data points; RooArgSetRooAbsDataStore::_vars; RooArgSet_varsww; RooRealVar*_wgtVarPointer to weight variable (if set); TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooTreeDataStore(). RooTreeDataStore(TTree* t, const RooArgSet& vars, const char* wgtVarName = 0); Constructor to facilitate reading of legacy RooDataSets. RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const char* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, TTree& t, const RooFormulaVar& select, const char* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, TTree& t, const char* selExpr = 0, const char* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const RooAbsDataStore& tds, const RooFormulaVar& select, const char* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const RooAbsDataStore& tds, const char* selExpr = 0, const char* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, RooAbsDataStore& tds, con",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:13078,Modifiability,variab,variable,13078,"r* name, const char* title, const RooArgSet& vars, const char* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, TTree& t, const RooFormulaVar& select, const char* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, TTree& t, const char* selExpr = 0, const char* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const RooAbsDataStore& tds, const RooFormulaVar& select, const char* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const RooAbsDataStore& tds, const char* selExpr = 0, const char* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, RooAbsDataStore& tds, const RooArgSet& vars, const RooFormulaVar* cutVar, const char* cutRange, Int_t nStart, Int_t nStop, Bool_t , const char* wgtVarName = 0). RooArgSet varsNoWeight(const RooArgSet& allVars, const char* wgtName = 0); Utility function for constructors; Return RooArgSet that is copy of allVars minus variable matching wgtName if specified. RooRealVar* weightVar(const RooArgSet& allVars, const char* wgtName = 0); Utility function for constructors; Return pointer to weight variable if it is defined. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Initialize cache of dataset: attach variables of cache ArgSet; to the corresponding TTree branches. RooTreeDataStore(const RooTreeDataStore& other, const char* newname = 0). RooTreeDataStore(const RooTreeDataStore& other, const RooArgSet& vars, const char* newname = 0). ~RooTreeDataStore(); Destructor. void initialize(); One-time initialization common to all constructor forms. Attach; variables of internal ArgSet to the corresponding TTree branches. void createTree(const char* name, const char* title); Create TTree object that lives in memory, independent of current; location of gDirectory. void loadValues(const TTree* t, const RooFormulaVar* select = 0, con",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:13252,Modifiability,variab,variable,13252,"mulaVar& select, const char* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, TTree& t, const char* selExpr = 0, const char* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const RooAbsDataStore& tds, const RooFormulaVar& select, const char* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const RooAbsDataStore& tds, const char* selExpr = 0, const char* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, RooAbsDataStore& tds, const RooArgSet& vars, const RooFormulaVar* cutVar, const char* cutRange, Int_t nStart, Int_t nStop, Bool_t , const char* wgtVarName = 0). RooArgSet varsNoWeight(const RooArgSet& allVars, const char* wgtName = 0); Utility function for constructors; Return RooArgSet that is copy of allVars minus variable matching wgtName if specified. RooRealVar* weightVar(const RooArgSet& allVars, const char* wgtName = 0); Utility function for constructors; Return pointer to weight variable if it is defined. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Initialize cache of dataset: attach variables of cache ArgSet; to the corresponding TTree branches. RooTreeDataStore(const RooTreeDataStore& other, const char* newname = 0). RooTreeDataStore(const RooTreeDataStore& other, const RooArgSet& vars, const char* newname = 0). ~RooTreeDataStore(); Destructor. void initialize(); One-time initialization common to all constructor forms. Attach; variables of internal ArgSet to the corresponding TTree branches. void createTree(const char* name, const char* title); Create TTree object that lives in memory, independent of current; location of gDirectory. void loadValues(const TTree* t, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); Load values from tree 't' into this data collection, optionally; selecting events using 'select' RooFormulaVar",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:13389,Modifiability,variab,variables,13389,"* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const RooAbsDataStore& tds, const RooFormulaVar& select, const char* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const RooAbsDataStore& tds, const char* selExpr = 0, const char* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, RooAbsDataStore& tds, const RooArgSet& vars, const RooFormulaVar* cutVar, const char* cutRange, Int_t nStart, Int_t nStop, Bool_t , const char* wgtVarName = 0). RooArgSet varsNoWeight(const RooArgSet& allVars, const char* wgtName = 0); Utility function for constructors; Return RooArgSet that is copy of allVars minus variable matching wgtName if specified. RooRealVar* weightVar(const RooArgSet& allVars, const char* wgtName = 0); Utility function for constructors; Return pointer to weight variable if it is defined. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Initialize cache of dataset: attach variables of cache ArgSet; to the corresponding TTree branches. RooTreeDataStore(const RooTreeDataStore& other, const char* newname = 0). RooTreeDataStore(const RooTreeDataStore& other, const RooArgSet& vars, const char* newname = 0). ~RooTreeDataStore(); Destructor. void initialize(); One-time initialization common to all constructor forms. Attach; variables of internal ArgSet to the corresponding TTree branches. void createTree(const char* name, const char* title); Create TTree object that lives in memory, independent of current; location of gDirectory. void loadValues(const TTree* t, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); Load values from tree 't' into this data collection, optionally; selecting events using 'select' RooFormulaVar. The source tree 't' is first clone as not disturb its branch; structure when retrieving information from it. void loadValues(const RooAbsDataStore* tds, const RooFor",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:13741,Modifiability,variab,variables,13741,"aStore& tds, const RooArgSet& vars, const RooFormulaVar* cutVar, const char* cutRange, Int_t nStart, Int_t nStop, Bool_t , const char* wgtVarName = 0). RooArgSet varsNoWeight(const RooArgSet& allVars, const char* wgtName = 0); Utility function for constructors; Return RooArgSet that is copy of allVars minus variable matching wgtName if specified. RooRealVar* weightVar(const RooArgSet& allVars, const char* wgtName = 0); Utility function for constructors; Return pointer to weight variable if it is defined. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Initialize cache of dataset: attach variables of cache ArgSet; to the corresponding TTree branches. RooTreeDataStore(const RooTreeDataStore& other, const char* newname = 0). RooTreeDataStore(const RooTreeDataStore& other, const RooArgSet& vars, const char* newname = 0). ~RooTreeDataStore(); Destructor. void initialize(); One-time initialization common to all constructor forms. Attach; variables of internal ArgSet to the corresponding TTree branches. void createTree(const char* name, const char* title); Create TTree object that lives in memory, independent of current; location of gDirectory. void loadValues(const TTree* t, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); Load values from tree 't' into this data collection, optionally; selecting events using 'select' RooFormulaVar. The source tree 't' is first clone as not disturb its branch; structure when retrieving information from it. void loadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); Load values from dataset 't' into this data collection, optionally; selecting events using 'select' RooFormulaVar. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. Int_t fill(); Interface function to TTree::Fill. cons",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:16205,Modifiability,variab,variables,16205,"Error(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Bool_t changeObservableName(const char* from, const char* to); Change name of internal observable named 'from' into 'to'. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); Add a new column to the data set which holds the pre-calculated values; of 'newVar'. This operation is only meaningful if 'newVar' is a derived; value. The return value points to the added element holding 'newVar's value; in the data collection. The element is always the corresponding fundamental; type of 'newVar' (e.g. a RooRealVar if 'newVar' is a RooFormulaVar). Note: This function is explicitly NOT intended as a speed optimization; opportunity for the user. Components of complex PDFs that can be; precalculated with the dataset are automatically identified as such; and will be precalculated when fitting to a dataset. By forcibly precalculating functions with non-trivial Jacobians,; or functions of multiple variables occurring in the data set,; using addColumn(), you may alter the outcome of the fit. Only in cases where such a modification of fit behaviour is intentional,; this function should be used. RooArgSet* addColumns(const RooArgList& varList); Utility function to add multiple columns in one call; See addColumn() for details. RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge columns of supplied data set(s) with this data set. All; data sets must have equal number of entries. In case of; duplicate columns the column of the last dataset in the list; prevails. void append(RooAbsDataStore& other). Double_t sumEntries() const. Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() c",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:2207,Performance,cache,cachedVars,2207,"rs, const RooAbsDataStore& tds, const RooFormulaVar& select, const char* wgtVarName = 0); RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const RooAbsDataStore& tds, const char* selExpr = 0, const char* wgtVarName = 0); RooTreeDataStore(const char* name, const char* title, RooAbsDataStore& tds, const RooArgSet& vars, const RooFormulaVar* cutVar, const char* cutRange, Int_t nStart, Int_t nStop, Bool_t, const char* wgtVarName = 0); virtual~RooTreeDataStore(); voidTObject::AbstractMethod(const char* method) const; virtual RooAbsArg*addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); virtual RooArgSet*addColumns(const RooArgList& varList); virtual voidappend(RooAbsDataStore& other); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidattachBuffers(const RooArgSet& extObs); virtual voidTObject::Browse(TBrowser* b); virtual voidcacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); const RooArgSet&RooAbsDataStore::cachedVars() const; virtual const RooAbsArg*cacheOwner(); virtual Bool_tchangeObservableName(const char* from, const char* to); virtual voidcheckInit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual RooAbsDataStore*clone(const char* newname = 0) const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooAbsDataStore::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsDataStore::dirtyProp() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:2251,Performance,cache,cacheOwner,2251,"mulaVar& select, const char* wgtVarName = 0); RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const RooAbsDataStore& tds, const char* selExpr = 0, const char* wgtVarName = 0); RooTreeDataStore(const char* name, const char* title, RooAbsDataStore& tds, const RooArgSet& vars, const RooFormulaVar* cutVar, const char* cutRange, Int_t nStart, Int_t nStop, Bool_t, const char* wgtVarName = 0); virtual~RooTreeDataStore(); voidTObject::AbstractMethod(const char* method) const; virtual RooAbsArg*addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); virtual RooArgSet*addColumns(const RooArgList& varList); virtual voidappend(RooAbsDataStore& other); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidattachBuffers(const RooArgSet& extObs); virtual voidTObject::Browse(TBrowser* b); virtual voidcacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); const RooArgSet&RooAbsDataStore::cachedVars() const; virtual const RooAbsArg*cacheOwner(); virtual Bool_tchangeObservableName(const char* from, const char* to); virtual voidcheckInit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual RooAbsDataStore*clone(const char* newname = 0) const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooAbsDataStore::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsDataStore::dirtyProp() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawCla",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:9569,Performance,cache,cachedVars,9569," msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TTree&tree(); virtual const TTree*tree() const; virtual voidTObject::UseCurrentStyle(); virtual Bool_tvalid() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Double_tweight() const; virtual Double_tweight(Int_t index) const; virtual Double_tweightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const; virtual voidweightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidattachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); voidcreateTree(const char* name, const char* title); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Int_tgetBranchBufferSize() const; voidinitialize(); voidTObject::MakeZombie(); voidsetBranchBufferSize(Int_t size); RooArgSetvarsNoWeight(const RooArgSet& allVars, const char* wgtName = 0); RooRealVar*weightVar(const RooArgSet& allVars, const char* wgtName = 0). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooArgSet_attachedBuffers! Currently attached buffers (if different from _varsww); TIterator*RooAbsDataStore::_cacheIter! Iterator over cached variables; const RooAbsArg*_cacheOwner! Object owning cache contents; TTree*_cacheTree! TTree holding the",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:10636,Performance,cache,cached,10636,"ck; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooArgSet_attachedBuffers! Currently attached buffers (if different from _varsww); TIterator*RooAbsDataStore::_cacheIter! Iterator over cached variables; const RooAbsArg*_cacheOwner! Object owning cache contents; TTree*_cacheTree! TTree holding the cached function values; RooArgSetRooAbsDataStore::_cachedVars; Double_t_curWgtWeight of current event; Double_t_curWgtErrWeight of current event; Double_t_curWgtErrHiWeight of current event; Double_t_curWgtErrLoWeight of current event; Bool_t_defCtor! Was object constructed with default ctor?; static Int_t_defTreeBufSize; Bool_tRooAbsDataStore::_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; Double_t*_extSumW2Array! External sum of weights array; Double_t*_extWgtArray! External weight array; Double_t*_extWgtErrHiArray! External weight array - high error; Double_t*_extWgtErrLoArray! External weight array - low error; TIterator*RooAbsDataStore::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; TTree*_treeTTree holding the data points; RooArgSetRooAbsDataStore::_vars; RooArgSet_varsww; RooRealVar*_wgtVarPointer to weight variable (if set); TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooTreeDataStore(). RooTreeDataStore(TTree* t, const RooArgSet& vars, const char* wgtVarName = 0); Constructor to facilitate reading of legacy RooDataSets. RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const char* wgtVarName = 0). RooTreeDataStore(const c",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:10697,Performance,cache,cache,10697,"ck; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooArgSet_attachedBuffers! Currently attached buffers (if different from _varsww); TIterator*RooAbsDataStore::_cacheIter! Iterator over cached variables; const RooAbsArg*_cacheOwner! Object owning cache contents; TTree*_cacheTree! TTree holding the cached function values; RooArgSetRooAbsDataStore::_cachedVars; Double_t_curWgtWeight of current event; Double_t_curWgtErrWeight of current event; Double_t_curWgtErrHiWeight of current event; Double_t_curWgtErrLoWeight of current event; Bool_t_defCtor! Was object constructed with default ctor?; static Int_t_defTreeBufSize; Bool_tRooAbsDataStore::_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; Double_t*_extSumW2Array! External sum of weights array; Double_t*_extWgtArray! External weight array; Double_t*_extWgtErrHiArray! External weight array - high error; Double_t*_extWgtErrLoArray! External weight array - low error; TIterator*RooAbsDataStore::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; TTree*_treeTTree holding the data points; RooArgSetRooAbsDataStore::_vars; RooArgSet_varsww; RooRealVar*_wgtVarPointer to weight variable (if set); TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooTreeDataStore(). RooTreeDataStore(TTree* t, const RooArgSet& vars, const char* wgtVarName = 0); Constructor to facilitate reading of legacy RooDataSets. RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const char* wgtVarName = 0). RooTreeDataStore(const c",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:10749,Performance,cache,cached,10749,"ck; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooArgSet_attachedBuffers! Currently attached buffers (if different from _varsww); TIterator*RooAbsDataStore::_cacheIter! Iterator over cached variables; const RooAbsArg*_cacheOwner! Object owning cache contents; TTree*_cacheTree! TTree holding the cached function values; RooArgSetRooAbsDataStore::_cachedVars; Double_t_curWgtWeight of current event; Double_t_curWgtErrWeight of current event; Double_t_curWgtErrHiWeight of current event; Double_t_curWgtErrLoWeight of current event; Bool_t_defCtor! Was object constructed with default ctor?; static Int_t_defTreeBufSize; Bool_tRooAbsDataStore::_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; Double_t*_extSumW2Array! External sum of weights array; Double_t*_extWgtArray! External weight array; Double_t*_extWgtErrHiArray! External weight array - high error; Double_t*_extWgtErrLoArray! External weight array - low error; TIterator*RooAbsDataStore::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; TTree*_treeTTree holding the data points; RooArgSetRooAbsDataStore::_vars; RooArgSet_varsww; RooRealVar*_wgtVarPointer to weight variable (if set); TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooTreeDataStore(). RooTreeDataStore(TTree* t, const RooArgSet& vars, const char* wgtVarName = 0); Constructor to facilitate reading of legacy RooDataSets. RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const char* wgtVarName = 0). RooTreeDataStore(const c",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:11160,Performance,load,loading,11160,"ck; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooArgSet_attachedBuffers! Currently attached buffers (if different from _varsww); TIterator*RooAbsDataStore::_cacheIter! Iterator over cached variables; const RooAbsArg*_cacheOwner! Object owning cache contents; TTree*_cacheTree! TTree holding the cached function values; RooArgSetRooAbsDataStore::_cachedVars; Double_t_curWgtWeight of current event; Double_t_curWgtErrWeight of current event; Double_t_curWgtErrHiWeight of current event; Double_t_curWgtErrLoWeight of current event; Bool_t_defCtor! Was object constructed with default ctor?; static Int_t_defTreeBufSize; Bool_tRooAbsDataStore::_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; Double_t*_extSumW2Array! External sum of weights array; Double_t*_extWgtArray! External weight array; Double_t*_extWgtErrHiArray! External weight array - high error; Double_t*_extWgtErrLoArray! External weight array - low error; TIterator*RooAbsDataStore::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; TTree*_treeTTree holding the data points; RooArgSetRooAbsDataStore::_vars; RooArgSet_varsww; RooRealVar*_wgtVarPointer to weight variable (if set); TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooTreeDataStore(). RooTreeDataStore(TTree* t, const RooArgSet& vars, const char* wgtVarName = 0); Constructor to facilitate reading of legacy RooDataSets. RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const char* wgtVarName = 0). RooTreeDataStore(const c",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:13340,Performance,cache,cachedVars,13340,"* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const RooAbsDataStore& tds, const RooFormulaVar& select, const char* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const RooAbsDataStore& tds, const char* selExpr = 0, const char* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, RooAbsDataStore& tds, const RooArgSet& vars, const RooFormulaVar* cutVar, const char* cutRange, Int_t nStart, Int_t nStop, Bool_t , const char* wgtVarName = 0). RooArgSet varsNoWeight(const RooArgSet& allVars, const char* wgtName = 0); Utility function for constructors; Return RooArgSet that is copy of allVars minus variable matching wgtName if specified. RooRealVar* weightVar(const RooArgSet& allVars, const char* wgtName = 0); Utility function for constructors; Return pointer to weight variable if it is defined. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Initialize cache of dataset: attach variables of cache ArgSet; to the corresponding TTree branches. RooTreeDataStore(const RooTreeDataStore& other, const char* newname = 0). RooTreeDataStore(const RooTreeDataStore& other, const RooArgSet& vars, const char* newname = 0). ~RooTreeDataStore(); Destructor. void initialize(); One-time initialization common to all constructor forms. Attach; variables of internal ArgSet to the corresponding TTree branches. void createTree(const char* name, const char* title); Create TTree object that lives in memory, independent of current; location of gDirectory. void loadValues(const TTree* t, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); Load values from tree 't' into this data collection, optionally; selecting events using 'select' RooFormulaVar. The source tree 't' is first clone as not disturb its branch; structure when retrieving information from it. void loadValues(const RooAbsDataStore* tds, const RooFor",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:13364,Performance,cache,cache,13364,"* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const RooAbsDataStore& tds, const RooFormulaVar& select, const char* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const RooAbsDataStore& tds, const char* selExpr = 0, const char* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, RooAbsDataStore& tds, const RooArgSet& vars, const RooFormulaVar* cutVar, const char* cutRange, Int_t nStart, Int_t nStop, Bool_t , const char* wgtVarName = 0). RooArgSet varsNoWeight(const RooArgSet& allVars, const char* wgtName = 0); Utility function for constructors; Return RooArgSet that is copy of allVars minus variable matching wgtName if specified. RooRealVar* weightVar(const RooArgSet& allVars, const char* wgtName = 0); Utility function for constructors; Return pointer to weight variable if it is defined. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Initialize cache of dataset: attach variables of cache ArgSet; to the corresponding TTree branches. RooTreeDataStore(const RooTreeDataStore& other, const char* newname = 0). RooTreeDataStore(const RooTreeDataStore& other, const RooArgSet& vars, const char* newname = 0). ~RooTreeDataStore(); Destructor. void initialize(); One-time initialization common to all constructor forms. Attach; variables of internal ArgSet to the corresponding TTree branches. void createTree(const char* name, const char* title); Create TTree object that lives in memory, independent of current; location of gDirectory. void loadValues(const TTree* t, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); Load values from tree 't' into this data collection, optionally; selecting events using 'select' RooFormulaVar. The source tree 't' is first clone as not disturb its branch; structure when retrieving information from it. void loadValues(const RooAbsDataStore* tds, const RooFor",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:13402,Performance,cache,cache,13402,"* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const RooAbsDataStore& tds, const RooFormulaVar& select, const char* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const RooAbsDataStore& tds, const char* selExpr = 0, const char* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, RooAbsDataStore& tds, const RooArgSet& vars, const RooFormulaVar* cutVar, const char* cutRange, Int_t nStart, Int_t nStop, Bool_t , const char* wgtVarName = 0). RooArgSet varsNoWeight(const RooArgSet& allVars, const char* wgtName = 0); Utility function for constructors; Return RooArgSet that is copy of allVars minus variable matching wgtName if specified. RooRealVar* weightVar(const RooArgSet& allVars, const char* wgtName = 0); Utility function for constructors; Return pointer to weight variable if it is defined. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Initialize cache of dataset: attach variables of cache ArgSet; to the corresponding TTree branches. RooTreeDataStore(const RooTreeDataStore& other, const char* newname = 0). RooTreeDataStore(const RooTreeDataStore& other, const RooArgSet& vars, const char* newname = 0). ~RooTreeDataStore(); Destructor. void initialize(); One-time initialization common to all constructor forms. Attach; variables of internal ArgSet to the corresponding TTree branches. void createTree(const char* name, const char* title); Create TTree object that lives in memory, independent of current; location of gDirectory. void loadValues(const TTree* t, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); Load values from tree 't' into this data collection, optionally; selecting events using 'select' RooFormulaVar. The source tree 't' is first clone as not disturb its branch; structure when retrieving information from it. void loadValues(const RooAbsDataStore* tds, const RooFor",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:13956,Performance,load,loadValues,13956,"nus variable matching wgtName if specified. RooRealVar* weightVar(const RooArgSet& allVars, const char* wgtName = 0); Utility function for constructors; Return pointer to weight variable if it is defined. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Initialize cache of dataset: attach variables of cache ArgSet; to the corresponding TTree branches. RooTreeDataStore(const RooTreeDataStore& other, const char* newname = 0). RooTreeDataStore(const RooTreeDataStore& other, const RooArgSet& vars, const char* newname = 0). ~RooTreeDataStore(); Destructor. void initialize(); One-time initialization common to all constructor forms. Attach; variables of internal ArgSet to the corresponding TTree branches. void createTree(const char* name, const char* title); Create TTree object that lives in memory, independent of current; location of gDirectory. void loadValues(const TTree* t, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); Load values from tree 't' into this data collection, optionally; selecting events using 'select' RooFormulaVar. The source tree 't' is first clone as not disturb its branch; structure when retrieving information from it. void loadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); Load values from dataset 't' into this data collection, optionally; selecting events using 'select' RooFormulaVar. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. Int_t fill(); Interface function to TTree::Fill. const RooArgSet* get(Int_t index) const; Load the n-th data point (n='index') in memory; and return a pointer to the internal RooArgSet; holding its coordinates. Double_t weight(Int_t index) const; Return the weight of the n-th data point (n='index') in memory. Double_t weight() const; Return the weight of th",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:14088,Performance,Load,Load,14088,"nus variable matching wgtName if specified. RooRealVar* weightVar(const RooArgSet& allVars, const char* wgtName = 0); Utility function for constructors; Return pointer to weight variable if it is defined. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Initialize cache of dataset: attach variables of cache ArgSet; to the corresponding TTree branches. RooTreeDataStore(const RooTreeDataStore& other, const char* newname = 0). RooTreeDataStore(const RooTreeDataStore& other, const RooArgSet& vars, const char* newname = 0). ~RooTreeDataStore(); Destructor. void initialize(); One-time initialization common to all constructor forms. Attach; variables of internal ArgSet to the corresponding TTree branches. void createTree(const char* name, const char* title); Create TTree object that lives in memory, independent of current; location of gDirectory. void loadValues(const TTree* t, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); Load values from tree 't' into this data collection, optionally; selecting events using 'select' RooFormulaVar. The source tree 't' is first clone as not disturb its branch; structure when retrieving information from it. void loadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); Load values from dataset 't' into this data collection, optionally; selecting events using 'select' RooFormulaVar. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. Int_t fill(); Interface function to TTree::Fill. const RooArgSet* get(Int_t index) const; Load the n-th data point (n='index') in memory; and return a pointer to the internal RooArgSet; holding its coordinates. Double_t weight(Int_t index) const; Return the weight of the n-th data point (n='index') in memory. Double_t weight() const; Return the weight of th",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:14314,Performance,load,loadValues,14314,"ee branches. RooTreeDataStore(const RooTreeDataStore& other, const char* newname = 0). RooTreeDataStore(const RooTreeDataStore& other, const RooArgSet& vars, const char* newname = 0). ~RooTreeDataStore(); Destructor. void initialize(); One-time initialization common to all constructor forms. Attach; variables of internal ArgSet to the corresponding TTree branches. void createTree(const char* name, const char* title); Create TTree object that lives in memory, independent of current; location of gDirectory. void loadValues(const TTree* t, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); Load values from tree 't' into this data collection, optionally; selecting events using 'select' RooFormulaVar. The source tree 't' is first clone as not disturb its branch; structure when retrieving information from it. void loadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); Load values from dataset 't' into this data collection, optionally; selecting events using 'select' RooFormulaVar. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. Int_t fill(); Interface function to TTree::Fill. const RooArgSet* get(Int_t index) const; Load the n-th data point (n='index') in memory; and return a pointer to the internal RooArgSet; holding its coordinates. Double_t weight(Int_t index) const; Return the weight of the n-th data point (n='index') in memory. Double_t weight() const; Return the weight of the n-th data point (n='index') in memory. Double_t weightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Bool_t changeObservableName(const char* from, const char* to); Change name of internal observable named 'from' into 'to'. RooAbsArg* addColumn",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:14458,Performance,Load,Load,14458,"ee branches. RooTreeDataStore(const RooTreeDataStore& other, const char* newname = 0). RooTreeDataStore(const RooTreeDataStore& other, const RooArgSet& vars, const char* newname = 0). ~RooTreeDataStore(); Destructor. void initialize(); One-time initialization common to all constructor forms. Attach; variables of internal ArgSet to the corresponding TTree branches. void createTree(const char* name, const char* title); Create TTree object that lives in memory, independent of current; location of gDirectory. void loadValues(const TTree* t, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); Load values from tree 't' into this data collection, optionally; selecting events using 'select' RooFormulaVar. The source tree 't' is first clone as not disturb its branch; structure when retrieving information from it. void loadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); Load values from dataset 't' into this data collection, optionally; selecting events using 'select' RooFormulaVar. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. Int_t fill(); Interface function to TTree::Fill. const RooArgSet* get(Int_t index) const; Load the n-th data point (n='index') in memory; and return a pointer to the internal RooArgSet; holding its coordinates. Double_t weight(Int_t index) const; Return the weight of the n-th data point (n='index') in memory. Double_t weight() const; Return the weight of the n-th data point (n='index') in memory. Double_t weightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Bool_t changeObservableName(const char* from, const char* to); Change name of internal observable named 'from' into 'to'. RooAbsArg* addColumn",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:14620,Performance,load,loaded,14620,"; Destructor. void initialize(); One-time initialization common to all constructor forms. Attach; variables of internal ArgSet to the corresponding TTree branches. void createTree(const char* name, const char* title); Create TTree object that lives in memory, independent of current; location of gDirectory. void loadValues(const TTree* t, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); Load values from tree 't' into this data collection, optionally; selecting events using 'select' RooFormulaVar. The source tree 't' is first clone as not disturb its branch; structure when retrieving information from it. void loadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); Load values from dataset 't' into this data collection, optionally; selecting events using 'select' RooFormulaVar. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. Int_t fill(); Interface function to TTree::Fill. const RooArgSet* get(Int_t index) const; Load the n-th data point (n='index') in memory; and return a pointer to the internal RooArgSet; holding its coordinates. Double_t weight(Int_t index) const; Return the weight of the n-th data point (n='index') in memory. Double_t weight() const; Return the weight of the n-th data point (n='index') in memory. Double_t weightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Bool_t changeObservableName(const char* from, const char* to); Change name of internal observable named 'from' into 'to'. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); Add a new column to the data set which holds the pre-calculated values; of 'newVar'. This operation is only meaningful if 'newVar' is a derived; value. The re",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:14806,Performance,Load,Load,14806,"t char* title); Create TTree object that lives in memory, independent of current; location of gDirectory. void loadValues(const TTree* t, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); Load values from tree 't' into this data collection, optionally; selecting events using 'select' RooFormulaVar. The source tree 't' is first clone as not disturb its branch; structure when retrieving information from it. void loadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); Load values from dataset 't' into this data collection, optionally; selecting events using 'select' RooFormulaVar. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. Int_t fill(); Interface function to TTree::Fill. const RooArgSet* get(Int_t index) const; Load the n-th data point (n='index') in memory; and return a pointer to the internal RooArgSet; holding its coordinates. Double_t weight(Int_t index) const; Return the weight of the n-th data point (n='index') in memory. Double_t weight() const; Return the weight of the n-th data point (n='index') in memory. Double_t weightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Bool_t changeObservableName(const char* from, const char* to); Change name of internal observable named 'from' into 'to'. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); Add a new column to the data set which holds the pre-calculated values; of 'newVar'. This operation is only meaningful if 'newVar' is a derived; value. The return value points to the added element holding 'newVar's value; in the data collection. The element is always the corresponding fundamental; type of 'newVar' (e.g. a RooRealVar if 'newVar' is a RooForm",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:15912,Performance,optimiz,optimization,15912,"holding its coordinates. Double_t weight(Int_t index) const; Return the weight of the n-th data point (n='index') in memory. Double_t weight() const; Return the weight of the n-th data point (n='index') in memory. Double_t weightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Bool_t changeObservableName(const char* from, const char* to); Change name of internal observable named 'from' into 'to'. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); Add a new column to the data set which holds the pre-calculated values; of 'newVar'. This operation is only meaningful if 'newVar' is a derived; value. The return value points to the added element holding 'newVar's value; in the data collection. The element is always the corresponding fundamental; type of 'newVar' (e.g. a RooRealVar if 'newVar' is a RooFormulaVar). Note: This function is explicitly NOT intended as a speed optimization; opportunity for the user. Components of complex PDFs that can be; precalculated with the dataset are automatically identified as such; and will be precalculated when fitting to a dataset. By forcibly precalculating functions with non-trivial Jacobians,; or functions of multiple variables occurring in the data set,; using addColumn(), you may alter the outcome of the fit. Only in cases where such a modification of fit behaviour is intentional,; this function should be used. RooArgSet* addColumns(const RooArgList& varList); Utility function to add multiple columns in one call; See addColumn() for details. RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge columns of supplied data set(s) with this data set. All; data sets must have equal number of entries. In case of; duplicate columns the column of the last dataset in the list; prevails. void append(RooAbsDataStore& other). Double_t sumEntries() const. Int_t numEntries() con",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:16925,Performance,cache,cacheArgs,16925,"such; and will be precalculated when fitting to a dataset. By forcibly precalculating functions with non-trivial Jacobians,; or functions of multiple variables occurring in the data set,; using addColumn(), you may alter the outcome of the fit. Only in cases where such a modification of fit behaviour is intentional,; this function should be used. RooArgSet* addColumns(const RooArgList& varList); Utility function to add multiple columns in one call; See addColumn() for details. RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge columns of supplied data set(s) with this data set. All; data sets must have equal number of entries. In case of; duplicate columns the column of the last dataset in the list; prevails. void append(RooAbsDataStore& other). Double_t sumEntries() const. Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void setArgStatus(const RooArgSet& set, Bool_t active); Activate or deactivate the branch status of the TTree branch associated; with the given set of dataset observables. void resetCache(); Remove tree with values of cached observables; and clear list of cached observables. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void restoreAlternateBuffers(). void checkInit() const. Stat_t GetEntries() const; Interface function to TTree::GetEntries. void Reset(Option_t* option = 0); Interface function to TTree::Reset. Int_t Fill(); Interface function to TTree::Fill. Int_t GetEntry(Int_t entry = 0, Int_t getall = 0); Interface function to TTree::GetEntry. void Draw(Option_t* option = """"). void Streamer(TBuffer",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:17006,Performance,Cache,Cache,17006,"such; and will be precalculated when fitting to a dataset. By forcibly precalculating functions with non-trivial Jacobians,; or functions of multiple variables occurring in the data set,; using addColumn(), you may alter the outcome of the fit. Only in cases where such a modification of fit behaviour is intentional,; this function should be used. RooArgSet* addColumns(const RooArgList& varList); Utility function to add multiple columns in one call; See addColumn() for details. RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge columns of supplied data set(s) with this data set. All; data sets must have equal number of entries. In case of; duplicate columns the column of the last dataset in the list; prevails. void append(RooAbsDataStore& other). Double_t sumEntries() const. Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void setArgStatus(const RooArgSet& set, Bool_t active); Activate or deactivate the branch status of the TTree branch associated; with the given set of dataset observables. void resetCache(); Remove tree with values of cached observables; and clear list of cached observables. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void restoreAlternateBuffers(). void checkInit() const. Stat_t GetEntries() const; Interface function to TTree::GetEntries. void Reset(Option_t* option = 0); Interface function to TTree::Reset. Int_t Fill(); Interface function to TTree::Fill. Int_t GetEntry(Int_t entry = 0, Int_t getall = 0); Interface function to TTree::GetEntry. void Draw(Option_t* option = """"). void Streamer(TBuffer",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:17105,Performance,cache,cache,17105,"such; and will be precalculated when fitting to a dataset. By forcibly precalculating functions with non-trivial Jacobians,; or functions of multiple variables occurring in the data set,; using addColumn(), you may alter the outcome of the fit. Only in cases where such a modification of fit behaviour is intentional,; this function should be used. RooArgSet* addColumns(const RooArgList& varList); Utility function to add multiple columns in one call; See addColumn() for details. RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge columns of supplied data set(s) with this data set. All; data sets must have equal number of entries. In case of; duplicate columns the column of the last dataset in the list; prevails. void append(RooAbsDataStore& other). Double_t sumEntries() const. Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void setArgStatus(const RooArgSet& set, Bool_t active); Activate or deactivate the branch status of the TTree branch associated; with the given set of dataset observables. void resetCache(); Remove tree with values of cached observables; and clear list of cached observables. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void restoreAlternateBuffers(). void checkInit() const. Stat_t GetEntries() const; Interface function to TTree::GetEntries. void Reset(Option_t* option = 0); Interface function to TTree::Reset. Int_t Fill(); Interface function to TTree::Fill. Int_t GetEntry(Int_t entry = 0, Int_t getall = 0); Interface function to TTree::GetEntry. void Draw(Option_t* option = """"). void Streamer(TBuffer",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:17225,Performance,cache,cache,17225,"n(), you may alter the outcome of the fit. Only in cases where such a modification of fit behaviour is intentional,; this function should be used. RooArgSet* addColumns(const RooArgList& varList); Utility function to add multiple columns in one call; See addColumn() for details. RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge columns of supplied data set(s) with this data set. All; data sets must have equal number of entries. In case of; duplicate columns the column of the last dataset in the list; prevails. void append(RooAbsDataStore& other). Double_t sumEntries() const. Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void setArgStatus(const RooArgSet& set, Bool_t active); Activate or deactivate the branch status of the TTree branch associated; with the given set of dataset observables. void resetCache(); Remove tree with values of cached observables; and clear list of cached observables. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void restoreAlternateBuffers(). void checkInit() const. Stat_t GetEntries() const; Interface function to TTree::GetEntries. void Reset(Option_t* option = 0); Interface function to TTree::Reset. Int_t Fill(); Interface function to TTree::Fill. Int_t GetEntry(Int_t entry = 0, Int_t getall = 0); Interface function to TTree::GetEntry. void Draw(Option_t* option = """"). void Streamer(TBuffer& b); Stream an object of class RooTreeDataStore. RooAbsDataStore* clone(const char* newname = 0) const; { return new RooTreeDataStore(*this,newname) ; }. RooAbsDataStore* clone(const RooArgSet& vars, co",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:17251,Performance,load,loaded,17251,"n(), you may alter the outcome of the fit. Only in cases where such a modification of fit behaviour is intentional,; this function should be used. RooArgSet* addColumns(const RooArgList& varList); Utility function to add multiple columns in one call; See addColumn() for details. RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge columns of supplied data set(s) with this data set. All; data sets must have equal number of entries. In case of; duplicate columns the column of the last dataset in the list; prevails. void append(RooAbsDataStore& other). Double_t sumEntries() const. Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void setArgStatus(const RooArgSet& set, Bool_t active); Activate or deactivate the branch status of the TTree branch associated; with the given set of dataset observables. void resetCache(); Remove tree with values of cached observables; and clear list of cached observables. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void restoreAlternateBuffers(). void checkInit() const. Stat_t GetEntries() const; Interface function to TTree::GetEntries. void Reset(Option_t* option = 0); Interface function to TTree::Reset. Int_t Fill(); Interface function to TTree::Fill. Int_t GetEntry(Int_t entry = 0, Int_t getall = 0); Interface function to TTree::GetEntry. void Draw(Option_t* option = """"). void Streamer(TBuffer& b); Stream an object of class RooTreeDataStore. RooAbsDataStore* clone(const char* newname = 0) const; { return new RooTreeDataStore(*this,newname) ; }. RooAbsDataStore* clone(const RooArgSet& vars, co",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:17543,Performance,cache,cached,17543,"tore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge columns of supplied data set(s) with this data set. All; data sets must have equal number of entries. In case of; duplicate columns the column of the last dataset in the list; prevails. void append(RooAbsDataStore& other). Double_t sumEntries() const. Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void setArgStatus(const RooArgSet& set, Bool_t active); Activate or deactivate the branch status of the TTree branch associated; with the given set of dataset observables. void resetCache(); Remove tree with values of cached observables; and clear list of cached observables. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void restoreAlternateBuffers(). void checkInit() const. Stat_t GetEntries() const; Interface function to TTree::GetEntries. void Reset(Option_t* option = 0); Interface function to TTree::Reset. Int_t Fill(); Interface function to TTree::Fill. Int_t GetEntry(Int_t entry = 0, Int_t getall = 0); Interface function to TTree::GetEntry. void Draw(Option_t* option = """"). void Streamer(TBuffer& b); Stream an object of class RooTreeDataStore. RooAbsDataStore* clone(const char* newname = 0) const; { return new RooTreeDataStore(*this,newname) ; }. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const; { return new RooTreeDataStore(*this,vars,newname) ; }. Bool_t isWeighted() const; { return (_wgtVar!=0||_extWgtArray!=0) ; }. TTree& tree(); Tree access. { return *_tree ; }. const TTree* tree() const; { return _tree ; }. const RooAbsArg* cacheOwner(); { retur",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:17581,Performance,cache,cached,17581,"tore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge columns of supplied data set(s) with this data set. All; data sets must have equal number of entries. In case of; duplicate columns the column of the last dataset in the list; prevails. void append(RooAbsDataStore& other). Double_t sumEntries() const. Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void setArgStatus(const RooArgSet& set, Bool_t active); Activate or deactivate the branch status of the TTree branch associated; with the given set of dataset observables. void resetCache(); Remove tree with values of cached observables; and clear list of cached observables. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void restoreAlternateBuffers(). void checkInit() const. Stat_t GetEntries() const; Interface function to TTree::GetEntries. void Reset(Option_t* option = 0); Interface function to TTree::Reset. Int_t Fill(); Interface function to TTree::Fill. Int_t GetEntry(Int_t entry = 0, Int_t getall = 0); Interface function to TTree::GetEntry. void Draw(Option_t* option = """"). void Streamer(TBuffer& b); Stream an object of class RooTreeDataStore. RooAbsDataStore* clone(const char* newname = 0) const; { return new RooTreeDataStore(*this,newname) ; }. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const; { return new RooTreeDataStore(*this,vars,newname) ; }. Bool_t isWeighted() const; { return (_wgtVar!=0||_extWgtArray!=0) ; }. TTree& tree(); Tree access. { return *_tree ; }. const TTree* tree() const; { return _tree ; }. const RooAbsArg* cacheOwner(); { retur",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:18527,Performance,cache,cacheOwner,18527,"re-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void setArgStatus(const RooArgSet& set, Bool_t active); Activate or deactivate the branch status of the TTree branch associated; with the given set of dataset observables. void resetCache(); Remove tree with values of cached observables; and clear list of cached observables. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void restoreAlternateBuffers(). void checkInit() const. Stat_t GetEntries() const; Interface function to TTree::GetEntries. void Reset(Option_t* option = 0); Interface function to TTree::Reset. Int_t Fill(); Interface function to TTree::Fill. Int_t GetEntry(Int_t entry = 0, Int_t getall = 0); Interface function to TTree::GetEntry. void Draw(Option_t* option = """"). void Streamer(TBuffer& b); Stream an object of class RooTreeDataStore. RooAbsDataStore* clone(const char* newname = 0) const; { return new RooTreeDataStore(*this,newname) ; }. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const; { return new RooTreeDataStore(*this,vars,newname) ; }. Bool_t isWeighted() const; { return (_wgtVar!=0||_extWgtArray!=0) ; }. TTree& tree(); Tree access. { return *_tree ; }. const TTree* tree() const; { return _tree ; }. const RooAbsArg* cacheOwner(); { return _cacheOwner ; }. void setExternalWeightArray(Double_t* arrayWgt, Double_t* arrayWgtErrLo, Double_t* arrayWgtErrHi, Double_t* arraySumW2). const RooArgSet& row(); { return _varsww ; }. void setBranchBufferSize(Int_t size); TTree Branch buffer size control. { _defTreeBufSize = size ; }. Int_t getBranchBufferSize() const; { return _defTreeBufSize ; }.  Last changed: Fri Dec 2 14:27:15 2011  Last generated: 2011-12-02 14:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:4674,Security,Hash,Hash,4674,"oidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tfill(); Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const RooArgSet*get(Int_t index) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Stat_tGetEntries() const; Int_tGetEntry(Int_t entry = 0, Int_t getall = 0); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tRooAbsDataStore::hasFilledCache() const; virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tisWeighted() const; Bool_tTObject::IsZombie() const; voidloadValues(const TTree* t, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); virtual voidloadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual RooAbsDataStore*merge(const RooArgSet& a",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:17077,Security,access,access,17077,"such; and will be precalculated when fitting to a dataset. By forcibly precalculating functions with non-trivial Jacobians,; or functions of multiple variables occurring in the data set,; using addColumn(), you may alter the outcome of the fit. Only in cases where such a modification of fit behaviour is intentional,; this function should be used. RooArgSet* addColumns(const RooArgList& varList); Utility function to add multiple columns in one call; See addColumn() for details. RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge columns of supplied data set(s) with this data set. All; data sets must have equal number of entries. In case of; duplicate columns the column of the last dataset in the list; prevails. void append(RooAbsDataStore& other). Double_t sumEntries() const. Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void setArgStatus(const RooArgSet& set, Bool_t active); Activate or deactivate the branch status of the TTree branch associated; with the given set of dataset observables. void resetCache(); Remove tree with values of cached observables; and clear list of cached observables. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void restoreAlternateBuffers(). void checkInit() const. Stat_t GetEntries() const; Interface function to TTree::GetEntries. void Reset(Option_t* option = 0); Interface function to TTree::Reset. Int_t Fill(); Interface function to TTree::Fill. Int_t GetEntry(Int_t entry = 0, Int_t getall = 0); Interface function to TTree::GetEntry. void Draw(Option_t* option = """"). void Streamer(TBuffer",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:18434,Security,access,access,18434,"re-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void setArgStatus(const RooArgSet& set, Bool_t active); Activate or deactivate the branch status of the TTree branch associated; with the given set of dataset observables. void resetCache(); Remove tree with values of cached observables; and clear list of cached observables. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void restoreAlternateBuffers(). void checkInit() const. Stat_t GetEntries() const; Interface function to TTree::GetEntries. void Reset(Option_t* option = 0); Interface function to TTree::Reset. Int_t Fill(); Interface function to TTree::Fill. Int_t GetEntry(Int_t entry = 0, Int_t getall = 0); Interface function to TTree::GetEntry. void Draw(Option_t* option = """"). void Streamer(TBuffer& b); Stream an object of class RooTreeDataStore. RooAbsDataStore* clone(const char* newname = 0) const; { return new RooTreeDataStore(*this,newname) ; }. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const; { return new RooTreeDataStore(*this,vars,newname) ; }. Bool_t isWeighted() const; { return (_wgtVar!=0||_extWgtArray!=0) ; }. TTree& tree(); Tree access. { return *_tree ; }. const TTree* tree() const; { return _tree ; }. const RooAbsArg* cacheOwner(); { return _cacheOwner ; }. void setExternalWeightArray(Double_t* arrayWgt, Double_t* arrayWgtErrLo, Double_t* arrayWgtErrHi, Double_t* arraySumW2). const RooArgSet& row(); { return _varsww ; }. void setBranchBufferSize(Int_t size); TTree Branch buffer size control. { _defTreeBufSize = size ; }. Int_t getBranchBufferSize() const; { return _defTreeBufSize ; }.  Last changed: Fri Dec 2 14:27:15 2011  Last generated: 2011-12-02 14:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:8778,Testability,Test,TestBit,8778,"voidTObject::ResetBit(UInt_t f); virtual voidresetBuffers(); virtual voidresetCache(); voidrestoreAlternateBuffers(); const RooArgSet&row(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidsetArgStatus(const RooArgSet& set, Bool_t active); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsDataStore::setDirtyProp(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidsetExternalWeightArray(Double_t* arrayWgt, Double_t* arrayWgtErrLo, Double_t* arrayWgtErrHi, Double_t* arraySumW2); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual Double_tsumEntries() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TTree&tree(); virtual const TTree*tree() const; virtual voidTObject::UseCurrentStyle(); virtual Bool_tvalid() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Double_tweight() const; virtual Double_tweight(Int_t index) const; virtual Double_tweightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const; virtual voidweightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:8817,Testability,Test,TestBits,8817,"voidTObject::ResetBit(UInt_t f); virtual voidresetBuffers(); virtual voidresetCache(); voidrestoreAlternateBuffers(); const RooArgSet&row(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidsetArgStatus(const RooArgSet& set, Bool_t active); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsDataStore::setDirtyProp(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidsetExternalWeightArray(Double_t* arrayWgt, Double_t* arrayWgtErrLo, Double_t* arrayWgtErrHi, Double_t* arraySumW2); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual Double_tsumEntries() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TTree&tree(); virtual const TTree*tree() const; virtual voidTObject::UseCurrentStyle(); virtual Bool_tvalid() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Double_tweight() const; virtual Double_tweight(Int_t index) const; virtual Double_tweightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const; virtual voidweightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:2456,Usability,Clear,Clear,2456,"; RooTreeDataStore(const char* name, const char* title, RooAbsDataStore& tds, const RooArgSet& vars, const RooFormulaVar* cutVar, const char* cutRange, Int_t nStart, Int_t nStop, Bool_t, const char* wgtVarName = 0); virtual~RooTreeDataStore(); voidTObject::AbstractMethod(const char* method) const; virtual RooAbsArg*addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); virtual RooArgSet*addColumns(const RooArgList& varList); virtual voidappend(RooAbsDataStore& other); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidattachBuffers(const RooArgSet& extObs); virtual voidTObject::Browse(TBrowser* b); virtual voidcacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); const RooArgSet&RooAbsDataStore::cachedVars() const; virtual const RooAbsArg*cacheOwner(); virtual Bool_tchangeObservableName(const char* from, const char* to); virtual voidcheckInit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual RooAbsDataStore*clone(const char* newname = 0) const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooAbsDataStore::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsDataStore::dirtyProp() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidRooAbsDataStore::dump(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char*",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:17316,Usability,clear,cleared,17316,"n(), you may alter the outcome of the fit. Only in cases where such a modification of fit behaviour is intentional,; this function should be used. RooArgSet* addColumns(const RooArgList& varList); Utility function to add multiple columns in one call; See addColumn() for details. RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge columns of supplied data set(s) with this data set. All; data sets must have equal number of entries. In case of; duplicate columns the column of the last dataset in the list; prevails. void append(RooAbsDataStore& other). Double_t sumEntries() const. Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void setArgStatus(const RooArgSet& set, Bool_t active); Activate or deactivate the branch status of the TTree branch associated; with the given set of dataset observables. void resetCache(); Remove tree with values of cached observables; and clear list of cached observables. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void restoreAlternateBuffers(). void checkInit() const. Stat_t GetEntries() const; Interface function to TTree::GetEntries. void Reset(Option_t* option = 0); Interface function to TTree::Reset. Int_t Fill(); Interface function to TTree::Fill. Int_t GetEntry(Int_t entry = 0, Int_t getall = 0); Interface function to TTree::GetEntry. void Draw(Option_t* option = """"). void Streamer(TBuffer& b); Stream an object of class RooTreeDataStore. RooAbsDataStore* clone(const char* newname = 0) const; { return new RooTreeDataStore(*this,newname) ; }. RooAbsDataStore* clone(const RooArgSet& vars, co",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTreeDataStore.html:17567,Usability,clear,clear,17567,"tore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge columns of supplied data set(s) with this data set. All; data sets must have equal number of entries. In case of; duplicate columns the column of the last dataset in the list; prevails. void append(RooAbsDataStore& other). Double_t sumEntries() const. Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void setArgStatus(const RooArgSet& set, Bool_t active); Activate or deactivate the branch status of the TTree branch associated; with the given set of dataset observables. void resetCache(); Remove tree with values of cached observables; and clear list of cached observables. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void restoreAlternateBuffers(). void checkInit() const. Stat_t GetEntries() const; Interface function to TTree::GetEntries. void Reset(Option_t* option = 0); Interface function to TTree::Reset. Int_t Fill(); Interface function to TTree::Fill. Int_t GetEntry(Int_t entry = 0, Int_t getall = 0); Interface function to TTree::GetEntry. void Draw(Option_t* option = """"). void Streamer(TBuffer& b); Stream an object of class RooTreeDataStore. RooAbsDataStore* clone(const char* newname = 0) const; { return new RooTreeDataStore(*this,newname) ; }. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const; { return new RooTreeDataStore(*this,vars,newname) ; }. Bool_t isWeighted() const; { return (_wgtVar!=0||_extWgtArray!=0) ; }. TTree& tree(); Tree access. { return *_tree ; }. const TTree* tree() const; { return _tree ; }. const RooAbsArg* cacheOwner(); { retur",MatchSource.WIKI,root/html532/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html
https://root.cern/root/html532/RooTruthModel.html:10047,Availability,Error,Error,10047,,MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:10217,Availability,Error,ErrorLoggingModeRooAbsReal,10217,,MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:10345,Availability,error,error,10345,,MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:10429,Availability,error,error,10429,,MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:28111,Availability,Error,ErrorLoggingMode,28111,"t(UInt_t f); virtual voidRooAbsPdf::resetErrorCounters(Int_t resetValue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); voidRooAbsPdf::setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title ",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:37174,Availability,Error,ErrorLoggingMode,37174,"ooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Double_tRooAbsReal::traceEval(const RooArgSet* set) const; virtual Bool_tRooResolutionModel::traceEvalHook(Double_t value) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy). Data Members; public:. enum RooTruthBasis { noBasis; expBasisMinus; expBasisSum; expBasisPlus; sinBasisMinus; sinBasisSum; sinBasisPlus; cosBasisMinus; cosBasisSum; cosBasisPlus; linBasisPlus; quadBasisPlus; coshBasisMinus; coshBasisSum; coshBasisPlus; sinhBasisMinus; sinhBasisSum; sinhBasisPlus; genericBasis; };; enum BasisType { none; expBasis; sinBasis; cosBasis; linBasis; quadBasis; coshBasis; sinhBasis; };; enum BasisSign { Both; Plus; Minus; };; enum RooAbsPdf::ExtendMode { CanNotBeExtended; CanBeExtended; MustBeExtended; };; enum RooAbsReal::ScaleType { Raw; Relative; NumEvent; RelativeExpected; };; enum RooAbsReal::ErrorLoggingMode { PrintErrors; CollectErrors; CountErrors; };; enum RooAbsArg::ConstOpCode { Activate; DeActivate; ConfigChange; ValueChange; };; enum RooAbsArg::OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooFormulaVar*RooResolutionModel::_basisBasis function convolved with this resolution model; Int_tRooResolutionModel::_basisCodeIdentifier code for selected basis function; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal:",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:39065,Availability,error,errors,39065,"olean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static RooFormulaVar*RooResolutionModel::_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative pro",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:39377,Deployability,integrat,integration,39377,<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static RooFormulaVar*RooResolutionModel::_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for abo,MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:39920,Deployability,integrat,integrated,39920,ooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static RooFormulaVar*RooResolutionModel::_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbs,MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:41388,Deployability,configurat,configuration,41388,"ove integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyRooResolutionModel::xDependent/convolution variable.",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:41485,Deployability,integrat,integrator,41485,"ove integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyRooResolutionModel::xDependent/convolution variable.",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:41496,Deployability,configurat,configuration,41496,"ove integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyRooResolutionModel::xDependent/convolution variable.",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:7439,Integrability,depend,dependentVars,7439,"), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; RooAbsReal*RooAbsReal::createIntRI(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); virtual RooAbsReal*RooAbsPdf::createNLL(RooAbsData& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsPdf::createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:8929,Integrability,depend,dependentOverlaps,8929,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:9021,Integrability,depend,dependentOverlaps,9021,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:9115,Integrability,depend,dependsOn,9115,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:9244,Integrability,depend,dependsOn,9244,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:9362,Integrability,depend,dependsOnValue,9362,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:9469,Integrability,depend,dependsOnValue,9469,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:20440,Integrability,message,message,20440,"); virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tRooAbsPdf::isDirectGenSafe(const RooAbsArg& arg) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual voidRooResolutionModel::normLeafServerList(RooArgSet& list) const; const char*RooAbsPdf:",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:20591,Integrability,message,message,20591,"st TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual voidRooResolutionModel::normLeafServerList(RooArgSet& list) const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbs",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:39377,Integrability,integrat,integration,39377,<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static RooFormulaVar*RooResolutionModel::_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for abo,MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:39920,Integrability,integrat,integrated,39920,ooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static RooFormulaVar*RooResolutionModel::_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbs,MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:41485,Integrability,integrat,integrator,41485,"ove integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyRooResolutionModel::xDependent/convolution variable.",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:10745,Modifiability,extend,extendedTerm,10745,,MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:10836,Modifiability,Extend,ExtendModeRooAbsPdf,10836,"(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; static Bool_tRooAbsPdf::evalError(); static RooAbsReal::EvalErrorIterRooAbsReal::evalErrorIter(); static RooAbsReal::ErrorLoggingModeRooAbsReal::evalErrorLoggingMode(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet* nset) const; virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_tRooAbsPdf::extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeRooAbsPdf::extendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(Roo",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:10857,Modifiability,extend,extendMode,10857,"n = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; static Bool_tRooAbsPdf::evalError(); static RooAbsReal::EvalErrorIterRooAbsReal::evalErrorIter(); static RooAbsReal::ErrorLoggingModeRooAbsReal::evalErrorLoggingMode(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet* nset) const; virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_tRooAbsPdf::extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeRooAbsPdf::extendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Doubl",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:14106,Modifiability,extend,extended,14106,"::generate(const RooArgSet& whatVars, Int_t nEvents = 0, Bool_t verbose = kFALSE) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); RooDataHist*RooAbsPdf::generateBinned(const RooArgSet& whatVars, Double_t nEvents, Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; RooDataHist*RooAbsPdf::generateBinned(const RooArgSet& whatVars, Double_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataHist*RooAbsPdf::generateBinned(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); virtual voidgenerateEvent(Int_t code); virtual RooDataSet*RooAbsPdf::generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); virtual RooArgSet*RooAbsPdf::getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; virtual Int_tgetAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName ",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:18881,Modifiability,Inherit,InheritsFrom,18881,"; virtual Double_tRooResolutionModel::getVal(const RooArgSet* nset = 0) const; RooArgSet*RooAbsArg::getVariables(Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); voidRooAbsArg::graphVizTree(ostream& os, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tRooAbsArg::hasClients() const; virtual ULong_tTNamed::Hash() const; virtual Bool_tRooAbsArg::hasRange(const char*) const; static RooFormulaVar*RooResolutionModel::identity(); RooGenFunction*RooAbsReal::iGenFunction(RooRealVar& x, const RooArgSet& nset = RooArgSet()); RooMultiGenFunction*RooAbsReal::iGenFunction(const RooArgSet& observables, const RooArgSet& nset = RooArgSet()); virtual Bool_tRooAbsArg::importWorkspaceHook(RooWorkspace&); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidRooAbsPdf::initGenerator(Int_t code); virtual Bool_tRooAbsArg::inRange(const char*) const; virtual voidTObject::Inspect() constMENU ; Int_tRooAbsPdf::intOrderNormValueCaching() const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tRooResolutionModel::isBasisSupported(const char* name) const; Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; Bool_tRooResolutionModel::isConvolved(); virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tRooAbsPdf::isDirectGenSafe(const RooAbsArg& arg) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:18947,Modifiability,Inherit,InheritsFrom,18947," = 0) const; RooArgSet*RooAbsArg::getVariables(Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); voidRooAbsArg::graphVizTree(ostream& os, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tRooAbsArg::hasClients() const; virtual ULong_tTNamed::Hash() const; virtual Bool_tRooAbsArg::hasRange(const char*) const; static RooFormulaVar*RooResolutionModel::identity(); RooGenFunction*RooAbsReal::iGenFunction(RooRealVar& x, const RooArgSet& nset = RooArgSet()); RooMultiGenFunction*RooAbsReal::iGenFunction(const RooArgSet& observables, const RooArgSet& nset = RooArgSet()); virtual Bool_tRooAbsArg::importWorkspaceHook(RooWorkspace&); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidRooAbsPdf::initGenerator(Int_t code); virtual Bool_tRooAbsArg::inRange(const char*) const; virtual voidTObject::Inspect() constMENU ; Int_tRooAbsPdf::intOrderNormValueCaching() const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tRooResolutionModel::isBasisSupported(const char* name) const; Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; Bool_tRooResolutionModel::isConvolved(); virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tRooAbsPdf::isDirectGenSafe(const RooAbsArg& arg) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tR",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:28298,Modifiability,config,config,28298,"Object::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); voidRooAbsPdf::setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsPdf::setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:28405,Modifiability,config,config,28405,"; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); voidRooAbsPdf::setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsPdf::setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const;",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:37015,Modifiability,Extend,ExtendMode,37015,"ooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Double_tRooAbsReal::traceEval(const RooArgSet* set) const; virtual Bool_tRooResolutionModel::traceEvalHook(Double_t value) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy). Data Members; public:. enum RooTruthBasis { noBasis; expBasisMinus; expBasisSum; expBasisPlus; sinBasisMinus; sinBasisSum; sinBasisPlus; cosBasisMinus; cosBasisSum; cosBasisPlus; linBasisPlus; quadBasisPlus; coshBasisMinus; coshBasisSum; coshBasisPlus; sinhBasisMinus; sinhBasisSum; sinhBasisPlus; genericBasis; };; enum BasisType { none; expBasis; sinBasis; cosBasis; linBasis; quadBasis; coshBasis; sinhBasis; };; enum BasisSign { Both; Plus; Minus; };; enum RooAbsPdf::ExtendMode { CanNotBeExtended; CanBeExtended; MustBeExtended; };; enum RooAbsReal::ScaleType { Raw; Relative; NumEvent; RelativeExpected; };; enum RooAbsReal::ErrorLoggingMode { PrintErrors; CollectErrors; CountErrors; };; enum RooAbsArg::ConstOpCode { Activate; DeActivate; ConfigChange; ValueChange; };; enum RooAbsArg::OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooFormulaVar*RooResolutionModel::_basisBasis function convolved with this resolution model; Int_tRooResolutionModel::_basisCodeIdentifier code for selected basis function; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal:",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:37290,Modifiability,Config,ConfigChange,37290,"ooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Double_tRooAbsReal::traceEval(const RooArgSet* set) const; virtual Bool_tRooResolutionModel::traceEvalHook(Double_t value) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy). Data Members; public:. enum RooTruthBasis { noBasis; expBasisMinus; expBasisSum; expBasisPlus; sinBasisMinus; sinBasisSum; sinBasisPlus; cosBasisMinus; cosBasisSum; cosBasisPlus; linBasisPlus; quadBasisPlus; coshBasisMinus; coshBasisSum; coshBasisPlus; sinhBasisMinus; sinhBasisSum; sinhBasisPlus; genericBasis; };; enum BasisType { none; expBasis; sinBasis; cosBasis; linBasis; quadBasis; coshBasis; sinhBasis; };; enum BasisSign { Both; Plus; Minus; };; enum RooAbsPdf::ExtendMode { CanNotBeExtended; CanBeExtended; MustBeExtended; };; enum RooAbsReal::ScaleType { Raw; Relative; NumEvent; RelativeExpected; };; enum RooAbsReal::ErrorLoggingMode { PrintErrors; CollectErrors; CountErrors; };; enum RooAbsArg::ConstOpCode { Activate; DeActivate; ConfigChange; ValueChange; };; enum RooAbsArg::OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooFormulaVar*RooResolutionModel::_basisBasis function convolved with this resolution model; Int_tRooResolutionModel::_basisCodeIdentifier code for selected basis function; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal:",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:41388,Modifiability,config,configuration,41388,"ove integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyRooResolutionModel::xDependent/convolution variable.",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:41496,Modifiability,config,configuration,41496,"ove integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyRooResolutionModel::xDependent/convolution variable.",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:42374,Modifiability,variab,variable,42374,"ove integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyRooResolutionModel::xDependent/convolution variable.",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:42398,Modifiability,Inherit,Inheritance,42398,"ect; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyRooResolutionModel::xDependent/convolution variable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooTruthModel(const char* name, const char* title, RooRealVar& x); Constructor of a truth resolution model, i.e. a delta function in observable 'xIn'. RooTruthModel(const RooTruthModel& other, const char* name = 0); Copy constructor. ~RooTruthModel(); Destructor. Int_t basisCode(const char* name) const; Return basis code for given basis definition string. Return special; codes for 'known' bases for which compiled definition exists. Return; generic bases code if implementation relies on TFormula interpretation; of basis name. void changeBasis(RooFormulaVar* basis); Changes associated bases function to 'inBasis'. Double_t evaluate() const; Evaluate the truth model: a delta function when used as PDF,; the basis function itself, when convoluted with a basis function. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Advertise analytical integrals for compiled basis functions and when use",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:42411,Modifiability,Inherit,Inherited,42411,"ect; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyRooResolutionModel::xDependent/convolution variable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooTruthModel(const char* name, const char* title, RooRealVar& x); Constructor of a truth resolution model, i.e. a delta function in observable 'xIn'. RooTruthModel(const RooTruthModel& other, const char* name = 0); Copy constructor. ~RooTruthModel(); Destructor. Int_t basisCode(const char* name) const; Return basis code for given basis definition string. Return special; codes for 'known' bases for which compiled definition exists. Return; generic bases code if implementation relies on TFormula interpretation; of basis name. void changeBasis(RooFormulaVar* basis); Changes associated bases function to 'inBasis'. Double_t evaluate() const; Evaluate the truth model: a delta function when used as PDF,; the basis function itself, when convoluted with a basis function. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Advertise analytical integrals for compiled basis functions and when use",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:2428,Performance,cache,cacheUniqueSuffix,2428,"t code, const char* rangeName = 0) const; virtual Double_tRooAbsPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; const RooFormulaVar&RooResolutionModel::basis() const; virtual Int_tbasisCode(const char* name) const; const RooRealVar&RooResolutionModel::basisConvVar() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Co",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:11466,Performance,cache,cacheList,11466,"ent(Int_t event, Int_t px, Int_t py); virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet* nset) const; virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_tRooAbsPdf::extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeRooAbsPdf::extendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:11554,Performance,cache,cacheList,11554,"oArgSet* nset) const; virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_tRooAbsPdf::extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeRooAbsPdf::extendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:22532,Performance,optimiz,optimizeCacheMode,22532,"& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual voidRooResolutionModel::normLeafServerList(RooArgSet& list) const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:22604,Performance,optimiz,optimizeCacheMode,22604,"& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual voidRooResolutionModel::normLeafServerList(RooArgSet& list) const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:26910,Performance,cache,cache,26910,"eam(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsPdf::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidRooAbsPdf::resetErrorCounters(Int_t resetValue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg:",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:28196,Performance,cache,cache,28196,"irtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); voidRooAbsPdf::setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsPdf::setTraceCounter(Int_t value, Bool_t allNodes = kFALS",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:30638,Performance,cache,cache,30638,"ext_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig(Bool_t createOnTheFly); RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tRooAbsPdf::traceEvalPdf(Double_t value) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); static intRooAbsPdf::verboseEval(); static voidRooAbsPdf::verboseEval(Int_t stat); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:34226,Performance,optimiz,optimizeDirtyHook,34226,"atVars, const RooDataSet* prototype, Int_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:38227,Performance,cache,cache,38227,,MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:38426,Performance,cache,caches,38426,,MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:38961,Performance,cache,cache,38961,"onModel::_basisCodeIdentifier code for selected basis function; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static RooFormulaVar*RooResolutionModel::_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalizat",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:39278,Performance,cache,cache,39278,"_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static RooFormulaVar*RooResolutionModel::_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; stat",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:39718,Performance,cache,cache,39718,Arg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static RooFormulaVar*RooResolutionModel::_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_p,MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:40213,Performance,cache,cache,40213, nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static RooFormulaVar*RooResolutionModel::_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of ser,MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:40955,Performance,cache,cache,40955,"alization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInter",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:41754,Performance,cache,cache,41754,"ove integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyRooResolutionModel::xDependent/convolution variable.",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:42000,Performance,cache,cache,42000,"ove integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyRooResolutionModel::xDependent/convolution variable.",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:18397,Security,Hash,Hash,18397,"* depList, Bool_t stripDisconnected = kTRUE) const; const char*RooAbsReal::getPlotLabel() const; Double_tRooAbsReal::getPropagatedError(const RooFitResult& fr); const Text_t*RooAbsArg::getStringAttribute(const Text_t* key) const; virtual const char*TNamed::GetTitle() const; TStringRooAbsReal::getTitle(Bool_t appendUnit = kFALSE) const; Bool_tRooAbsArg::getTransientAttribute(const Text_t* name) const; virtual UInt_tTObject::GetUniqueID() const; const Text_t*RooAbsReal::getUnit() const; virtual Double_tRooResolutionModel::getVal(const RooArgSet* nset = 0) const; RooArgSet*RooAbsArg::getVariables(Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); voidRooAbsArg::graphVizTree(ostream& os, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tRooAbsArg::hasClients() const; virtual ULong_tTNamed::Hash() const; virtual Bool_tRooAbsArg::hasRange(const char*) const; static RooFormulaVar*RooResolutionModel::identity(); RooGenFunction*RooAbsReal::iGenFunction(RooRealVar& x, const RooArgSet& nset = RooArgSet()); RooMultiGenFunction*RooAbsReal::iGenFunction(const RooArgSet& observables, const RooArgSet& nset = RooArgSet()); virtual Bool_tRooAbsArg::importWorkspaceHook(RooWorkspace&); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidRooAbsPdf::initGenerator(Int_t code); virtual Bool_tRooAbsArg::inRange(const char*) const; virtual voidTObject::Inspect() constMENU ; Int_tRooAbsPdf::intOrderNormValueCaching() const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tRooResolutionModel::isBasisSupported(const char* name) const; Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() c",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:38322,Security,validat,validate,38322,,MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:8988,Testability,test,testArg,8988,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:9082,Testability,test,testArg,9082,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:20415,Testability,log,logEvalError,20415,"tionModel::isConvolved(); virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tRooAbsPdf::isDirectGenSafe(const RooAbsArg& arg) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual voidRooResolutionModel::normLeafServerList(RooArgSet& list) const;",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:20514,Testability,log,logEvalError,20514,"rectGenSafe(const RooAbsArg& arg) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual voidRooResolutionModel::normLeafServerList(RooArgSet& list) const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCache",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:21695,Testability,test,testArg,21695,"uble_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual voidRooResolutionModel::normLeafServerList(RooArgSet& list) const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNo",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:21790,Testability,test,testArg,21790,"ooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual voidRooResolutionModel::normLeafServerList(RooArgSet& list) const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; con",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:22748,Testability,test,testArg,22748,"& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual voidRooResolutionModel::normLeafServerList(RooArgSet& list) const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:30212,Testability,Test,TestBit,30212,"::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig(Bool_t createOnTheFly); RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tRooAbsPdf::traceEvalPdf(Double_t value) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); static intRooAbsPdf::verboseEval(); static voidRooAbsPdf::verboseEval(Int_t stat); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ost",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:30251,Testability,Test,TestBits,30251,"ext_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig(Bool_t createOnTheFly); RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tRooAbsPdf::traceEvalPdf(Double_t value) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); static intRooAbsPdf::verboseEval(); static voidRooAbsPdf::verboseEval(Int_t stat); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:2938,Usability,Clear,Clear,2938,"const; const RooFormulaVar&RooResolutionModel::basis() const; virtual Int_tbasisCode(const char* name) const; const RooRealVar&RooResolutionModel::basisConvVar() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual RooResolutionModel*RooResolutionModel::convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&RooResolutionModel::convVar() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooAr",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:2990,Usability,clear,clearEvalError,2990,"onst; virtual Int_tbasisCode(const char* name) const; const RooRealVar&RooResolutionModel::basisConvVar() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual RooResolutionModel*RooResolutionModel::convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&RooResolutionModel::convVar() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 ",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:3031,Usability,clear,clearEvalErrorLog,3031,"me) const; const RooRealVar&RooResolutionModel::basisConvVar() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual RooResolutionModel*RooResolutionModel::convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&RooResolutionModel::convVar() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:3067,Usability,clear,clearShapeDirty,3067,"lutionModel::basisConvVar() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual RooResolutionModel*RooResolutionModel::convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&RooResolutionModel::convVar() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdA",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:3107,Usability,clear,clearValueAndShapeDirty,3107,"c*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual RooResolutionModel*RooResolutionModel::convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&RooResolutionModel::convVar() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdAr",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/RooTruthModel.html:3155,Usability,clear,clearValueDirty,3155,", const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual RooResolutionModel*RooResolutionModel::convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&RooResolutionModel::convVar() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg",MatchSource.WIKI,root/html532/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/RooTruthModel.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:397,Availability,error,error,397,". ROOT::Fit::BinData. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::BinData. class ROOT::Fit::BinData: public ROOT::Fit::FitData. Class describing the binned data sets :; vectors of x coordinates, y values and optionally error on y values and error on coordinates; The dimension of the coordinate is free; There are 4 different options:; - only coordinates and values (for binned likelihood fits) : kNoError; - coordinate, values and error on values (for normal least square fits) : kValueError; - coordinate, values, error on values and coordinates (for effective least square fits) : kCoordError; - corrdinate, values, error on coordinates and asymmettric error on valyes : kAsymError. In addition there is the option to construct Bindata copying the data in (using the DataVector class); or using pointer to external data (DataWrapper) class.; In general is found to be more efficient to copy the data.; In case of really large data sets for limiting memory consumption then the other option can be used; Specialized constructor exists for data up to 3 dimensions. When the data are copying in the number of points can be set later (or re-set) using Initialize and; the data are inserted one by one using the Add method.; It is mandatory to set the size before using the Add method. @ingroup FitData. Function Members (Methods); public:. virtual~BinData(); voidAdd(double x, double y); voidAdd(const double* x, double val); voidAdd(double x, double y, double ey); voidAdd(const double* x, double val, double eval); voidAdd(double x, double y, double ex, double ey); voidAdd(const double* x, double val, const double* ex, double eval); voidAdd(double x, double y, double ex, double eyl, double eyh); voidAdd(const double* x, double val, const double* ex, double elval, double ehval); voidAddBinUpEdge(const double* xup); RO",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:419,Availability,error,error,419,". ROOT::Fit::BinData. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::BinData. class ROOT::Fit::BinData: public ROOT::Fit::FitData. Class describing the binned data sets :; vectors of x coordinates, y values and optionally error on y values and error on coordinates; The dimension of the coordinate is free; There are 4 different options:; - only coordinates and values (for binned likelihood fits) : kNoError; - coordinate, values and error on values (for normal least square fits) : kValueError; - coordinate, values, error on values and coordinates (for effective least square fits) : kCoordError; - corrdinate, values, error on coordinates and asymmettric error on valyes : kAsymError. In addition there is the option to construct Bindata copying the data in (using the DataVector class); or using pointer to external data (DataWrapper) class.; In general is found to be more efficient to copy the data.; In case of really large data sets for limiting memory consumption then the other option can be used; Specialized constructor exists for data up to 3 dimensions. When the data are copying in the number of points can be set later (or re-set) using Initialize and; the data are inserted one by one using the Add method.; It is mandatory to set the size before using the Add method. @ingroup FitData. Function Members (Methods); public:. virtual~BinData(); voidAdd(double x, double y); voidAdd(const double* x, double val); voidAdd(double x, double y, double ey); voidAdd(const double* x, double val, double eval); voidAdd(double x, double y, double ex, double ey); voidAdd(const double* x, double val, const double* ex, double eval); voidAdd(double x, double y, double ex, double eyl, double eyh); voidAdd(const double* x, double val, const double* ex, double elval, double ehval); voidAddBinUpEdge(const double* xup); RO",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:610,Availability,error,error,610,". ROOT::Fit::BinData. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::BinData. class ROOT::Fit::BinData: public ROOT::Fit::FitData. Class describing the binned data sets :; vectors of x coordinates, y values and optionally error on y values and error on coordinates; The dimension of the coordinate is free; There are 4 different options:; - only coordinates and values (for binned likelihood fits) : kNoError; - coordinate, values and error on values (for normal least square fits) : kValueError; - coordinate, values, error on values and coordinates (for effective least square fits) : kCoordError; - corrdinate, values, error on coordinates and asymmettric error on valyes : kAsymError. In addition there is the option to construct Bindata copying the data in (using the DataVector class); or using pointer to external data (DataWrapper) class.; In general is found to be more efficient to copy the data.; In case of really large data sets for limiting memory consumption then the other option can be used; Specialized constructor exists for data up to 3 dimensions. When the data are copying in the number of points can be set later (or re-set) using Initialize and; the data are inserted one by one using the Add method.; It is mandatory to set the size before using the Add method. @ingroup FitData. Function Members (Methods); public:. virtual~BinData(); voidAdd(double x, double y); voidAdd(const double* x, double val); voidAdd(double x, double y, double ey); voidAdd(const double* x, double val, double eval); voidAdd(double x, double y, double ex, double ey); voidAdd(const double* x, double val, const double* ex, double eval); voidAdd(double x, double y, double ex, double eyl, double eyh); voidAdd(const double* x, double val, const double* ex, double elval, double ehval); voidAddBinUpEdge(const double* xup); RO",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:694,Availability,error,error,694,". ROOT::Fit::BinData. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::BinData. class ROOT::Fit::BinData: public ROOT::Fit::FitData. Class describing the binned data sets :; vectors of x coordinates, y values and optionally error on y values and error on coordinates; The dimension of the coordinate is free; There are 4 different options:; - only coordinates and values (for binned likelihood fits) : kNoError; - coordinate, values and error on values (for normal least square fits) : kValueError; - coordinate, values, error on values and coordinates (for effective least square fits) : kCoordError; - corrdinate, values, error on coordinates and asymmettric error on valyes : kAsymError. In addition there is the option to construct Bindata copying the data in (using the DataVector class); or using pointer to external data (DataWrapper) class.; In general is found to be more efficient to copy the data.; In case of really large data sets for limiting memory consumption then the other option can be used; Specialized constructor exists for data up to 3 dimensions. When the data are copying in the number of points can be set later (or re-set) using Initialize and; the data are inserted one by one using the Add method.; It is mandatory to set the size before using the Add method. @ingroup FitData. Function Members (Methods); public:. virtual~BinData(); voidAdd(double x, double y); voidAdd(const double* x, double val); voidAdd(double x, double y, double ey); voidAdd(const double* x, double val, double eval); voidAdd(double x, double y, double ex, double ey); voidAdd(const double* x, double val, const double* ex, double eval); voidAdd(double x, double y, double ex, double eyl, double eyh); voidAdd(const double* x, double val, const double* ex, double elval, double ehval); voidAddBinUpEdge(const double* xup); RO",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:797,Availability,error,error,797,". ROOT::Fit::BinData. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::BinData. class ROOT::Fit::BinData: public ROOT::Fit::FitData. Class describing the binned data sets :; vectors of x coordinates, y values and optionally error on y values and error on coordinates; The dimension of the coordinate is free; There are 4 different options:; - only coordinates and values (for binned likelihood fits) : kNoError; - coordinate, values and error on values (for normal least square fits) : kValueError; - coordinate, values, error on values and coordinates (for effective least square fits) : kCoordError; - corrdinate, values, error on coordinates and asymmettric error on valyes : kAsymError. In addition there is the option to construct Bindata copying the data in (using the DataVector class); or using pointer to external data (DataWrapper) class.; In general is found to be more efficient to copy the data.; In case of really large data sets for limiting memory consumption then the other option can be used; Specialized constructor exists for data up to 3 dimensions. When the data are copying in the number of points can be set later (or re-set) using Initialize and; the data are inserted one by one using the Add method.; It is mandatory to set the size before using the Add method. @ingroup FitData. Function Members (Methods); public:. virtual~BinData(); voidAdd(double x, double y); voidAdd(const double* x, double val); voidAdd(double x, double y, double ey); voidAdd(const double* x, double val, double eval); voidAdd(double x, double y, double ex, double ey); voidAdd(const double* x, double val, const double* ex, double eval); voidAdd(double x, double y, double ex, double eyl, double eyh); voidAdd(const double* x, double val, const double* ex, double elval, double ehval); voidAddBinUpEdge(const double* xup); RO",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:834,Availability,error,error,834,". ROOT::Fit::BinData. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::BinData. class ROOT::Fit::BinData: public ROOT::Fit::FitData. Class describing the binned data sets :; vectors of x coordinates, y values and optionally error on y values and error on coordinates; The dimension of the coordinate is free; There are 4 different options:; - only coordinates and values (for binned likelihood fits) : kNoError; - coordinate, values and error on values (for normal least square fits) : kValueError; - coordinate, values, error on values and coordinates (for effective least square fits) : kCoordError; - corrdinate, values, error on coordinates and asymmettric error on valyes : kAsymError. In addition there is the option to construct Bindata copying the data in (using the DataVector class); or using pointer to external data (DataWrapper) class.; In general is found to be more efficient to copy the data.; In case of really large data sets for limiting memory consumption then the other option can be used; Specialized constructor exists for data up to 3 dimensions. When the data are copying in the number of points can be set later (or re-set) using Initialize and; the data are inserted one by one using the Add method.; It is mandatory to set the size before using the Add method. @ingroup FitData. Function Members (Methods); public:. virtual~BinData(); voidAdd(double x, double y); voidAdd(const double* x, double val); voidAdd(double x, double y, double ey); voidAdd(const double* x, double val, double eval); voidAdd(double x, double y, double ex, double ey); voidAdd(const double* x, double val, const double* ex, double eval); voidAdd(double x, double y, double ex, double eyl, double eyh); voidAdd(const double* x, double val, const double* ex, double elval, double ehval); voidAddBinUpEdge(const double* xup); RO",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:2149,Availability,Error,ErrorType,2149," virtual~BinData(); voidAdd(double x, double y); voidAdd(const double* x, double val); voidAdd(double x, double y, double ey); voidAdd(const double* x, double val, double eval); voidAdd(double x, double y, double ex, double ey); voidAdd(const double* x, double val, const double* ex, double eval); voidAdd(double x, double y, double ex, double eyl, double eyh); voidAdd(const double* x, double val, const double* ex, double elval, double ehval); voidAddBinUpEdge(const double* xup); RO",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:2310,Availability,Error,ErrorType,2310," virtual~BinData(); voidAdd(double x, double y); voidAdd(const double* x, double val); voidAdd(double x, double y, double ey); voidAdd(const double* x, double val, double eval); voidAdd(double x, double y, double ex, double ey); voidAdd(const double* x, double val, const double* ex, double eval); voidAdd(double x, double y, double ex, double eyl, double eyh); voidAdd(const double* x, double val, const double* ex, double elval, double ehval); voidAddBinUpEdge(const double* xup); RO",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:2506,Availability,Error,ErrorType,2506," virtual~BinData(); voidAdd(double x, double y); voidAdd(const double* x, double val); voidAdd(double x, double y, double ey); voidAdd(const double* x, double val, double eval); voidAdd(double x, double y, double ex, double ey); voidAdd(const double* x, double val, const double* ex, double eval); voidAdd(double x, double y, double ex, double eyl, double eyh); voidAdd(const double* x, double val, const double* ex, double elval, double ehval); voidAddBinUpEdge(const double* xup); RO",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:3662,Availability,Error,ErrorTypeGetErrorType,3662,"taBinData(unsigned int n, const double* dataX, const double* dataY, const double* val, const double* ex, const double* ey, const double* eval); ROOT::Fit::BinDataBinData(unsigned int n, const double* dataX, const double* dataY, const double* dataZ, const double* val, const double* ex, const double* ey, const double* ez, const double* eval); const double*BinUpEdge(unsigned int icoord) const; const double*CoordErrors(unsigned int ipoint) const; const double*Coords(unsigned int ipoint) const; unsigned intDataSize() const; doubleError(unsigned int ipoint) const; ROOT::Fit::FitDataROOT::Fit::FitData::FitData(); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::DataOptions& opt); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::DataRange& range); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::FitData&); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range); ROOT::Fit::BinData::ErrorTypeGetErrorType() const; const double*GetPoint(unsigned int ipoint, double& value) const; const double*GetPoint(unsigned int ipoint, double& value, double& invError) const; const double*GetPointError(unsigned int ipoint, double& errvalue) const; const double*GetPointError(unsigned int ipoint, double& errlow, double& errhigh) const; static unsigned intGetPointSize(ROOT::Fit::BinData::ErrorType err, unsigned int dim); boolHasBinEdges() const; boolHaveAsymErrors() const; boolHaveCoordErrors() const; voidInitialize(unsigned int maxpoints, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError); doubleInvError(unsigned int ipoint) const; ROOT::Fit::BinData&LogTransform(); static unsigned intROOT::Fit::FitData::MaxSize(); unsigned intNDim() const; unsigned intNPoints() const; ROOT::Fit::BinData&operator=(const ROOT::Fit::BinData&); const ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt() const; ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt(); unsigned intPointSize() const; const ROO",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:4054,Availability,Error,ErrorType,4054,"onst double* dataY, const double* dataZ, const double* val, const double* ex, const double* ey, const double* ez, const double* eval); const double*BinUpEdge(unsigned int icoord) const; const double*CoordErrors(unsigned int ipoint) const; const double*Coords(unsigned int ipoint) const; unsigned intDataSize() const; doubleError(unsigned int ipoint) const; ROOT::Fit::FitDataROOT::Fit::FitData::FitData(); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::DataOptions& opt); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::DataRange& range); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::FitData&); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range); ROOT::Fit::BinData::ErrorTypeGetErrorType() const; const double*GetPoint(unsigned int ipoint, double& value) const; const double*GetPoint(unsigned int ipoint, double& value, double& invError) const; const double*GetPointError(unsigned int ipoint, double& errvalue) const; const double*GetPointError(unsigned int ipoint, double& errlow, double& errhigh) const; static unsigned intGetPointSize(ROOT::Fit::BinData::ErrorType err, unsigned int dim); boolHasBinEdges() const; boolHaveAsymErrors() const; boolHaveCoordErrors() const; voidInitialize(unsigned int maxpoints, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError); doubleInvError(unsigned int ipoint) const; ROOT::Fit::BinData&LogTransform(); static unsigned intROOT::Fit::FitData::MaxSize(); unsigned intNDim() const; unsigned intNPoints() const; ROOT::Fit::BinData&operator=(const ROOT::Fit::BinData&); const ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt() const; ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt(); unsigned intPointSize() const; const ROOT::Fit::DataRange&ROOT::Fit::FitData::Range() const; doubleRefVolume() const; voidResize(unsigned int npoints); voidSetRefVolume(double value); unsigned intSize() const; doubleValue(unsigned int ipoint) const.",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:4251,Availability,Error,ErrorType,4251,"onst double* dataY, const double* dataZ, const double* val, const double* ex, const double* ey, const double* ez, const double* eval); const double*BinUpEdge(unsigned int icoord) const; const double*CoordErrors(unsigned int ipoint) const; const double*Coords(unsigned int ipoint) const; unsigned intDataSize() const; doubleError(unsigned int ipoint) const; ROOT::Fit::FitDataROOT::Fit::FitData::FitData(); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::DataOptions& opt); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::DataRange& range); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::FitData&); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range); ROOT::Fit::BinData::ErrorTypeGetErrorType() const; const double*GetPoint(unsigned int ipoint, double& value) const; const double*GetPoint(unsigned int ipoint, double& value, double& invError) const; const double*GetPointError(unsigned int ipoint, double& errvalue) const; const double*GetPointError(unsigned int ipoint, double& errlow, double& errhigh) const; static unsigned intGetPointSize(ROOT::Fit::BinData::ErrorType err, unsigned int dim); boolHasBinEdges() const; boolHaveAsymErrors() const; boolHaveCoordErrors() const; voidInitialize(unsigned int maxpoints, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError); doubleInvError(unsigned int ipoint) const; ROOT::Fit::BinData&LogTransform(); static unsigned intROOT::Fit::FitData::MaxSize(); unsigned intNDim() const; unsigned intNPoints() const; ROOT::Fit::BinData&operator=(const ROOT::Fit::BinData&); const ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt() const; ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt(); unsigned intPointSize() const; const ROOT::Fit::DataRange&ROOT::Fit::FitData::Range() const; doubleRefVolume() const; voidResize(unsigned int npoints); voidSetRefVolume(double value); unsigned intSize() const; doubleValue(unsigned int ipoint) const.",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:4955,Availability,Error,ErrorType,4955,"e& errhigh) const; static unsigned intGetPointSize(ROOT::Fit::BinData::ErrorType err, unsigned int dim); boolHasBinEdges() const; boolHaveAsymErrors() const; boolHaveCoordErrors() const; voidInitialize(unsigned int maxpoints, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError); doubleInvError(unsigned int ipoint) const; ROOT::Fit::BinData&LogTransform(); static unsigned intROOT::Fit::FitData::MaxSize(); unsigned intNDim() const; unsigned intNPoints() const; ROOT::Fit::BinData&operator=(const ROOT::Fit::BinData&); const ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt() const; ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt(); unsigned intPointSize() const; const ROOT::Fit::DataRange&ROOT::Fit::FitData::Range() const; doubleRefVolume() const; voidResize(unsigned int npoints); voidSetRefVolume(double value); unsigned intSize() const; doubleValue(unsigned int ipoint) const. protected:. voidSetNPoints(unsigned int n). Data Members; public:. enum ErrorType { kNoError; kValueError; kCoordError; kAsymError; };. private:. vector<double>fBinEdgevector containing the bin upper edge (coordinate will contain low edge) ; ROOT::Fit::DataVector*fDataVectorpointer to the copied in data vector; ROOT::Fit::DataWrapper*fDataWrapperpointer to the external data wrapper structure; unsigned intfDimcoordinate dimension; unsigned intfNPointsnumber of contained points in the data set (can be different than size of vector); unsigned intfPointSizetotal point size including value and errors (= fDim + 2 for error in only Y ) ; doublefRefVolumereference bin volume - used to normalize the bins in case of variable bins data. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; unsigned int GetPointSize(ROOT::Fit::BinData::ErrorType err, unsigned int dim). ErrorType GetErrorType() const. explicit BinData(unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from dimension of point and max n",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:5479,Availability,error,errors,5479," ROOT::Fit::BinData&LogTransform(); static unsigned intROOT::Fit::FitData::MaxSize(); unsigned intNDim() const; unsigned intNPoints() const; ROOT::Fit::BinData&operator=(const ROOT::Fit::BinData&); const ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt() const; ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt(); unsigned intPointSize() const; const ROOT::Fit::DataRange&ROOT::Fit::FitData::Range() const; doubleRefVolume() const; voidResize(unsigned int npoints); voidSetRefVolume(double value); unsigned intSize() const; doubleValue(unsigned int ipoint) const. protected:. voidSetNPoints(unsigned int n). Data Members; public:. enum ErrorType { kNoError; kValueError; kCoordError; kAsymError; };. private:. vector<double>fBinEdgevector containing the bin upper edge (coordinate will contain low edge) ; ROOT::Fit::DataVector*fDataVectorpointer to the copied in data vector; ROOT::Fit::DataWrapper*fDataWrapperpointer to the external data wrapper structure; unsigned intfDimcoordinate dimension; unsigned intfNPointsnumber of contained points in the data set (can be different than size of vector); unsigned intfPointSizetotal point size including value and errors (= fDim + 2 for error in only Y ) ; doublefRefVolumereference bin volume - used to normalize the bins in case of variable bins data. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; unsigned int GetPointSize(ROOT::Fit::BinData::ErrorType err, unsigned int dim). ErrorType GetErrorType() const. explicit BinData(unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from dimension of point and max number of points (to pre-allocate vector); Give a zero value and then use Initialize later one if the size is not known. explicit BinData(const ROOT::Fit::DataOptions& opt, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from option and default range. BinData(const ROOT::Fit:",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:5502,Availability,error,error,5502," ROOT::Fit::BinData&LogTransform(); static unsigned intROOT::Fit::FitData::MaxSize(); unsigned intNDim() const; unsigned intNPoints() const; ROOT::Fit::BinData&operator=(const ROOT::Fit::BinData&); const ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt() const; ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt(); unsigned intPointSize() const; const ROOT::Fit::DataRange&ROOT::Fit::FitData::Range() const; doubleRefVolume() const; voidResize(unsigned int npoints); voidSetRefVolume(double value); unsigned intSize() const; doubleValue(unsigned int ipoint) const. protected:. voidSetNPoints(unsigned int n). Data Members; public:. enum ErrorType { kNoError; kValueError; kCoordError; kAsymError; };. private:. vector<double>fBinEdgevector containing the bin upper edge (coordinate will contain low edge) ; ROOT::Fit::DataVector*fDataVectorpointer to the copied in data vector; ROOT::Fit::DataWrapper*fDataWrapperpointer to the external data wrapper structure; unsigned intfDimcoordinate dimension; unsigned intfNPointsnumber of contained points in the data set (can be different than size of vector); unsigned intfPointSizetotal point size including value and errors (= fDim + 2 for error in only Y ) ; doublefRefVolumereference bin volume - used to normalize the bins in case of variable bins data. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; unsigned int GetPointSize(ROOT::Fit::BinData::ErrorType err, unsigned int dim). ErrorType GetErrorType() const. explicit BinData(unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from dimension of point and max number of points (to pre-allocate vector); Give a zero value and then use Initialize later one if the size is not known. explicit BinData(const ROOT::Fit::DataOptions& opt, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from option and default range. BinData(const ROOT::Fit:",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:5756,Availability,Error,ErrorType,5756,"lume() const; voidResize(unsigned int npoints); voidSetRefVolume(double value); unsigned intSize() const; doubleValue(unsigned int ipoint) const. protected:. voidSetNPoints(unsigned int n). Data Members; public:. enum ErrorType { kNoError; kValueError; kCoordError; kAsymError; };. private:. vector<double>fBinEdgevector containing the bin upper edge (coordinate will contain low edge) ; ROOT::Fit::DataVector*fDataVectorpointer to the copied in data vector; ROOT::Fit::DataWrapper*fDataWrapperpointer to the external data wrapper structure; unsigned intfDimcoordinate dimension; unsigned intfNPointsnumber of contained points in the data set (can be different than size of vector); unsigned intfPointSizetotal point size including value and errors (= fDim + 2 for error in only Y ) ; doublefRefVolumereference bin volume - used to normalize the bins in case of variable bins data. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; unsigned int GetPointSize(ROOT::Fit::BinData::ErrorType err, unsigned int dim). ErrorType GetErrorType() const. explicit BinData(unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from dimension of point and max number of points (to pre-allocate vector); Give a zero value and then use Initialize later one if the size is not known. explicit BinData(const ROOT::Fit::DataOptions& opt, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from option and default range. BinData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from options and range; efault is 1D and value errors. BinData(unsigned int n, const double* dataX, const double* val, const double* ex, const double* eval); constructurs using external data . constructor from external data for 1D with errors on co",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:5790,Availability,Error,ErrorType,5790,"ble value); unsigned intSize() const; doubleValue(unsigned int ipoint) const. protected:. voidSetNPoints(unsigned int n). Data Members; public:. enum ErrorType { kNoError; kValueError; kCoordError; kAsymError; };. private:. vector<double>fBinEdgevector containing the bin upper edge (coordinate will contain low edge) ; ROOT::Fit::DataVector*fDataVectorpointer to the copied in data vector; ROOT::Fit::DataWrapper*fDataWrapperpointer to the external data wrapper structure; unsigned intfDimcoordinate dimension; unsigned intfNPointsnumber of contained points in the data set (can be different than size of vector); unsigned intfPointSizetotal point size including value and errors (= fDim + 2 for error in only Y ) ; doublefRefVolumereference bin volume - used to normalize the bins in case of variable bins data. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; unsigned int GetPointSize(ROOT::Fit::BinData::ErrorType err, unsigned int dim). ErrorType GetErrorType() const. explicit BinData(unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from dimension of point and max number of points (to pre-allocate vector); Give a zero value and then use Initialize later one if the size is not known. explicit BinData(const ROOT::Fit::DataOptions& opt, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from option and default range. BinData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from options and range; efault is 1D and value errors. BinData(unsigned int n, const double* dataX, const double* val, const double* ex, const double* eval); constructurs using external data . constructor from external data for 1D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, con",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:5909,Availability,Error,ErrorType,5909,"st. protected:. voidSetNPoints(unsigned int n). Data Members; public:. enum ErrorType { kNoError; kValueError; kCoordError; kAsymError; };. private:. vector<double>fBinEdgevector containing the bin upper edge (coordinate will contain low edge) ; ROOT::Fit::DataVector*fDataVectorpointer to the copied in data vector; ROOT::Fit::DataWrapper*fDataWrapperpointer to the external data wrapper structure; unsigned intfDimcoordinate dimension; unsigned intfNPointsnumber of contained points in the data set (can be different than size of vector); unsigned intfPointSizetotal point size including value and errors (= fDim + 2 for error in only Y ) ; doublefRefVolumereference bin volume - used to normalize the bins in case of variable bins data. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; unsigned int GetPointSize(ROOT::Fit::BinData::ErrorType err, unsigned int dim). ErrorType GetErrorType() const. explicit BinData(unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from dimension of point and max number of points (to pre-allocate vector); Give a zero value and then use Initialize later one if the size is not known. explicit BinData(const ROOT::Fit::DataOptions& opt, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from option and default range. BinData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from options and range; efault is 1D and value errors. BinData(unsigned int n, const double* dataX, const double* val, const double* ex, const double* eval); constructurs using external data . constructor from external data for 1D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, const double* dataY, const double* val, const double* ex, const double* ey, co",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:6226,Availability,Error,ErrorType,6226," in data vector; ROOT::Fit::DataWrapper*fDataWrapperpointer to the external data wrapper structure; unsigned intfDimcoordinate dimension; unsigned intfNPointsnumber of contained points in the data set (can be different than size of vector); unsigned intfPointSizetotal point size including value and errors (= fDim + 2 for error in only Y ) ; doublefRefVolumereference bin volume - used to normalize the bins in case of variable bins data. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; unsigned int GetPointSize(ROOT::Fit::BinData::ErrorType err, unsigned int dim). ErrorType GetErrorType() const. explicit BinData(unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from dimension of point and max number of points (to pre-allocate vector); Give a zero value and then use Initialize later one if the size is not known. explicit BinData(const ROOT::Fit::DataOptions& opt, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from option and default range. BinData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from options and range; efault is 1D and value errors. BinData(unsigned int n, const double* dataX, const double* val, const double* ex, const double* eval); constructurs using external data . constructor from external data for 1D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, const double* dataY, const double* val, const double* ex, const double* ey, const double* eval). constructor from external data for 2D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, const double* dataY, const double* dataZ, const double* val, const double* ex, const double* ey, const double* ez, const double* eval). constructor from externa",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:6447,Availability,Error,ErrorType,6447," different than size of vector); unsigned intfPointSizetotal point size including value and errors (= fDim + 2 for error in only Y ) ; doublefRefVolumereference bin volume - used to normalize the bins in case of variable bins data. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; unsigned int GetPointSize(ROOT::Fit::BinData::ErrorType err, unsigned int dim). ErrorType GetErrorType() const. explicit BinData(unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from dimension of point and max number of points (to pre-allocate vector); Give a zero value and then use Initialize later one if the size is not known. explicit BinData(const ROOT::Fit::DataOptions& opt, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from option and default range. BinData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from options and range; efault is 1D and value errors. BinData(unsigned int n, const double* dataX, const double* val, const double* ex, const double* eval); constructurs using external data . constructor from external data for 1D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, const double* dataY, const double* val, const double* ex, const double* ey, const double* eval). constructor from external data for 2D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, const double* dataY, const double* dataZ, const double* val, const double* ex, const double* ey, const double* ez, const double* eval). constructor from external data for 3D with errors on coordinate and value. BinData(const ROOT::Fit::BinData& ). copy constructors. BinData & operator=(const ROOT::Fit::BinData& ). assignment operator. virtual ~BinData(). destructor.",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:6536,Availability,error,errors,6536,"n only Y ) ; doublefRefVolumereference bin volume - used to normalize the bins in case of variable bins data. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; unsigned int GetPointSize(ROOT::Fit::BinData::ErrorType err, unsigned int dim). ErrorType GetErrorType() const. explicit BinData(unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from dimension of point and max number of points (to pre-allocate vector); Give a zero value and then use Initialize later one if the size is not known. explicit BinData(const ROOT::Fit::DataOptions& opt, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from option and default range. BinData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from options and range; efault is 1D and value errors. BinData(unsigned int n, const double* dataX, const double* val, const double* ex, const double* eval); constructurs using external data . constructor from external data for 1D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, const double* dataY, const double* val, const double* ex, const double* ey, const double* eval). constructor from external data for 2D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, const double* dataY, const double* dataZ, const double* val, const double* ex, const double* ey, const double* ez, const double* eval). constructor from external data for 3D with errors on coordinate and value. BinData(const ROOT::Fit::BinData& ). copy constructors. BinData & operator=(const ROOT::Fit::BinData& ). assignment operator. virtual ~BinData(). destructor. void Initialize(unsigned int maxpoints, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). preallocat",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:6725,Availability,error,errors,6725," int GetPointSize(ROOT::Fit::BinData::ErrorType err, unsigned int dim). ErrorType GetErrorType() const. explicit BinData(unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from dimension of point and max number of points (to pre-allocate vector); Give a zero value and then use Initialize later one if the size is not known. explicit BinData(const ROOT::Fit::DataOptions& opt, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from option and default range. BinData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from options and range; efault is 1D and value errors. BinData(unsigned int n, const double* dataX, const double* val, const double* ex, const double* eval); constructurs using external data . constructor from external data for 1D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, const double* dataY, const double* val, const double* ex, const double* ey, const double* eval). constructor from external data for 2D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, const double* dataY, const double* dataZ, const double* val, const double* ex, const double* ey, const double* ez, const double* eval). constructor from external data for 3D with errors on coordinate and value. BinData(const ROOT::Fit::BinData& ). copy constructors. BinData & operator=(const ROOT::Fit::BinData& ). assignment operator. virtual ~BinData(). destructor. void Initialize(unsigned int maxpoints, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). preallocate a data set with given size , dimension and error type (to get the full point size); If the data set already exists and it is having the compatible point size space for the new points; is created in the data ",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:6942,Availability,error,errors,6942,"r). constructor from dimension of point and max number of points (to pre-allocate vector); Give a zero value and then use Initialize later one if the size is not known. explicit BinData(const ROOT::Fit::DataOptions& opt, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from option and default range. BinData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from options and range; efault is 1D and value errors. BinData(unsigned int n, const double* dataX, const double* val, const double* ex, const double* eval); constructurs using external data . constructor from external data for 1D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, const double* dataY, const double* val, const double* ex, const double* ey, const double* eval). constructor from external data for 2D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, const double* dataY, const double* dataZ, const double* val, const double* ex, const double* ey, const double* ez, const double* eval). constructor from external data for 3D with errors on coordinate and value. BinData(const ROOT::Fit::BinData& ). copy constructors. BinData & operator=(const ROOT::Fit::BinData& ). assignment operator. virtual ~BinData(). destructor. void Initialize(unsigned int maxpoints, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). preallocate a data set with given size , dimension and error type (to get the full point size); If the data set already exists and it is having the compatible point size space for the new points; is created in the data sets, while if not compatible the old data are erased and new space of; new size is allocated.; (i.e if exists initialize is equivalent to a resize( NPoints() + maxpoints). unsigned int PointSize() const. return the s",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:7198,Availability,error,errors,7198,"d int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from option and default range. BinData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from options and range; efault is 1D and value errors. BinData(unsigned int n, const double* dataX, const double* val, const double* ex, const double* eval); constructurs using external data . constructor from external data for 1D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, const double* dataY, const double* val, const double* ex, const double* ey, const double* eval). constructor from external data for 2D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, const double* dataY, const double* dataZ, const double* val, const double* ex, const double* ey, const double* ez, const double* eval). constructor from external data for 3D with errors on coordinate and value. BinData(const ROOT::Fit::BinData& ). copy constructors. BinData & operator=(const ROOT::Fit::BinData& ). assignment operator. virtual ~BinData(). destructor. void Initialize(unsigned int maxpoints, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). preallocate a data set with given size , dimension and error type (to get the full point size); If the data set already exists and it is having the compatible point size space for the new points; is created in the data sets, while if not compatible the old data are erased and new space of; new size is allocated.; (i.e if exists initialize is equivalent to a resize( NPoints() + maxpoints). unsigned int PointSize() const. return the size of a fit point (is the coordinate dimension + 1 for the value and eventually; the number of all errors. unsigned int DataSize() const. return the size of internal data (number of fit points); if data are not copied in but used externally the size is 0.",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:7470,Availability,Error,ErrorType,7470,"ta::ErrorType err = kValueError). constructor from options and range; efault is 1D and value errors. BinData(unsigned int n, const double* dataX, const double* val, const double* ex, const double* eval); constructurs using external data . constructor from external data for 1D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, const double* dataY, const double* val, const double* ex, const double* ey, const double* eval). constructor from external data for 2D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, const double* dataY, const double* dataZ, const double* val, const double* ex, const double* ey, const double* ez, const double* eval). constructor from external data for 3D with errors on coordinate and value. BinData(const ROOT::Fit::BinData& ). copy constructors. BinData & operator=(const ROOT::Fit::BinData& ). assignment operator. virtual ~BinData(). destructor. void Initialize(unsigned int maxpoints, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). preallocate a data set with given size , dimension and error type (to get the full point size); If the data set already exists and it is having the compatible point size space for the new points; is created in the data sets, while if not compatible the old data are erased and new space of; new size is allocated.; (i.e if exists initialize is equivalent to a resize( NPoints() + maxpoints). unsigned int PointSize() const. return the size of a fit point (is the coordinate dimension + 1 for the value and eventually; the number of all errors. unsigned int DataSize() const. return the size of internal data (number of fit points); if data are not copied in but used externally the size is 0. bool HaveCoordErrors() const. flag to control if data provides error on the coordinates. bool HaveAsymErrors() const. flag to control if data provides asymmetric errors on the value. void Add(double x, double y). add one dim data with only coordinate",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:7555,Availability,error,error,7555,"urs using external data . constructor from external data for 1D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, const double* dataY, const double* val, const double* ex, const double* ey, const double* eval). constructor from external data for 2D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, const double* dataY, const double* dataZ, const double* val, const double* ex, const double* ey, const double* ez, const double* eval). constructor from external data for 3D with errors on coordinate and value. BinData(const ROOT::Fit::BinData& ). copy constructors. BinData & operator=(const ROOT::Fit::BinData& ). assignment operator. virtual ~BinData(). destructor. void Initialize(unsigned int maxpoints, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). preallocate a data set with given size , dimension and error type (to get the full point size); If the data set already exists and it is having the compatible point size space for the new points; is created in the data sets, while if not compatible the old data are erased and new space of; new size is allocated.; (i.e if exists initialize is equivalent to a resize( NPoints() + maxpoints). unsigned int PointSize() const. return the size of a fit point (is the coordinate dimension + 1 for the value and eventually; the number of all errors. unsigned int DataSize() const. return the size of internal data (number of fit points); if data are not copied in but used externally the size is 0. bool HaveCoordErrors() const. flag to control if data provides error on the coordinates. bool HaveAsymErrors() const. flag to control if data provides asymmetric errors on the value. void Add(double x, double y). add one dim data with only coordinate and values. void Add(double x, double y, double ey). add one dim data with no error in the coordinate (x); in this case store the inverse of the error in the value (y). void Add(double x, double y, double ex, dou",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:8036,Availability,error,errors,8036,"nsigned int n, const double* dataX, const double* dataY, const double* dataZ, const double* val, const double* ex, const double* ey, const double* ez, const double* eval). constructor from external data for 3D with errors on coordinate and value. BinData(const ROOT::Fit::BinData& ). copy constructors. BinData & operator=(const ROOT::Fit::BinData& ). assignment operator. virtual ~BinData(). destructor. void Initialize(unsigned int maxpoints, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). preallocate a data set with given size , dimension and error type (to get the full point size); If the data set already exists and it is having the compatible point size space for the new points; is created in the data sets, while if not compatible the old data are erased and new space of; new size is allocated.; (i.e if exists initialize is equivalent to a resize( NPoints() + maxpoints). unsigned int PointSize() const. return the size of a fit point (is the coordinate dimension + 1 for the value and eventually; the number of all errors. unsigned int DataSize() const. return the size of internal data (number of fit points); if data are not copied in but used externally the size is 0. bool HaveCoordErrors() const. flag to control if data provides error on the coordinates. bool HaveAsymErrors() const. flag to control if data provides asymmetric errors on the value. void Add(double x, double y). add one dim data with only coordinate and values. void Add(double x, double y, double ey). add one dim data with no error in the coordinate (x); in this case store the inverse of the error in the value (y). void Add(double x, double y, double ex, double ey). add one dim data with error in the coordinate (x); in this case store the value (y) error and not the inverse. void Add(double x, double y, double ex, double eyl, double eyh). add one dim data with error in the coordinate (x) and asymmetric errors in the value (y); in this case store the y errors and not the inverse.",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:8256,Availability,error,error,8256,"it::BinData& ). copy constructors. BinData & operator=(const ROOT::Fit::BinData& ). assignment operator. virtual ~BinData(). destructor. void Initialize(unsigned int maxpoints, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). preallocate a data set with given size , dimension and error type (to get the full point size); If the data set already exists and it is having the compatible point size space for the new points; is created in the data sets, while if not compatible the old data are erased and new space of; new size is allocated.; (i.e if exists initialize is equivalent to a resize( NPoints() + maxpoints). unsigned int PointSize() const. return the size of a fit point (is the coordinate dimension + 1 for the value and eventually; the number of all errors. unsigned int DataSize() const. return the size of internal data (number of fit points); if data are not copied in but used externally the size is 0. bool HaveCoordErrors() const. flag to control if data provides error on the coordinates. bool HaveAsymErrors() const. flag to control if data provides asymmetric errors on the value. void Add(double x, double y). add one dim data with only coordinate and values. void Add(double x, double y, double ey). add one dim data with no error in the coordinate (x); in this case store the inverse of the error in the value (y). void Add(double x, double y, double ex, double ey). add one dim data with error in the coordinate (x); in this case store the value (y) error and not the inverse. void Add(double x, double y, double ex, double eyl, double eyh). add one dim data with error in the coordinate (x) and asymmetric errors in the value (y); in this case store the y errors and not the inverse. void Add(const double* x, double val). add multi-dim coordinate data with only value (no errors). void Add(const double* x, double val, double eval). add multi-dim coordinate data with only error in value. void Add(const double* x, double val, const double* ex, double",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:8355,Availability,error,errors,8355,"ent operator. virtual ~BinData(). destructor. void Initialize(unsigned int maxpoints, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). preallocate a data set with given size , dimension and error type (to get the full point size); If the data set already exists and it is having the compatible point size space for the new points; is created in the data sets, while if not compatible the old data are erased and new space of; new size is allocated.; (i.e if exists initialize is equivalent to a resize( NPoints() + maxpoints). unsigned int PointSize() const. return the size of a fit point (is the coordinate dimension + 1 for the value and eventually; the number of all errors. unsigned int DataSize() const. return the size of internal data (number of fit points); if data are not copied in but used externally the size is 0. bool HaveCoordErrors() const. flag to control if data provides error on the coordinates. bool HaveAsymErrors() const. flag to control if data provides asymmetric errors on the value. void Add(double x, double y). add one dim data with only coordinate and values. void Add(double x, double y, double ey). add one dim data with no error in the coordinate (x); in this case store the inverse of the error in the value (y). void Add(double x, double y, double ex, double ey). add one dim data with error in the coordinate (x); in this case store the value (y) error and not the inverse. void Add(double x, double y, double ex, double eyl, double eyh). add one dim data with error in the coordinate (x) and asymmetric errors in the value (y); in this case store the y errors and not the inverse. void Add(const double* x, double val). add multi-dim coordinate data with only value (no errors). void Add(const double* x, double val, double eval). add multi-dim coordinate data with only error in value. void Add(const double* x, double val, const double* ex, double eval). add multi-dim coordinate data with both error in coordinates and value. void Add(co",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:8522,Availability,error,error,8522," error type (to get the full point size); If the data set already exists and it is having the compatible point size space for the new points; is created in the data sets, while if not compatible the old data are erased and new space of; new size is allocated.; (i.e if exists initialize is equivalent to a resize( NPoints() + maxpoints). unsigned int PointSize() const. return the size of a fit point (is the coordinate dimension + 1 for the value and eventually; the number of all errors. unsigned int DataSize() const. return the size of internal data (number of fit points); if data are not copied in but used externally the size is 0. bool HaveCoordErrors() const. flag to control if data provides error on the coordinates. bool HaveAsymErrors() const. flag to control if data provides asymmetric errors on the value. void Add(double x, double y). add one dim data with only coordinate and values. void Add(double x, double y, double ey). add one dim data with no error in the coordinate (x); in this case store the inverse of the error in the value (y). void Add(double x, double y, double ex, double ey). add one dim data with error in the coordinate (x); in this case store the value (y) error and not the inverse. void Add(double x, double y, double ex, double eyl, double eyh). add one dim data with error in the coordinate (x) and asymmetric errors in the value (y); in this case store the y errors and not the inverse. void Add(const double* x, double val). add multi-dim coordinate data with only value (no errors). void Add(const double* x, double val, double eval). add multi-dim coordinate data with only error in value. void Add(const double* x, double val, const double* ex, double eval). add multi-dim coordinate data with both error in coordinates and value. void Add(const double* x, double val, const double* ex, double elval, double ehval). add multi-dim coordinate data with both error in coordinates and value. const double * Coords(unsigned int ipoint) const. return a pointe",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:8589,Availability,error,error,8589," error type (to get the full point size); If the data set already exists and it is having the compatible point size space for the new points; is created in the data sets, while if not compatible the old data are erased and new space of; new size is allocated.; (i.e if exists initialize is equivalent to a resize( NPoints() + maxpoints). unsigned int PointSize() const. return the size of a fit point (is the coordinate dimension + 1 for the value and eventually; the number of all errors. unsigned int DataSize() const. return the size of internal data (number of fit points); if data are not copied in but used externally the size is 0. bool HaveCoordErrors() const. flag to control if data provides error on the coordinates. bool HaveAsymErrors() const. flag to control if data provides asymmetric errors on the value. void Add(double x, double y). add one dim data with only coordinate and values. void Add(double x, double y, double ey). add one dim data with no error in the coordinate (x); in this case store the inverse of the error in the value (y). void Add(double x, double y, double ex, double ey). add one dim data with error in the coordinate (x); in this case store the value (y) error and not the inverse. void Add(double x, double y, double ex, double eyl, double eyh). add one dim data with error in the coordinate (x) and asymmetric errors in the value (y); in this case store the y errors and not the inverse. void Add(const double* x, double val). add multi-dim coordinate data with only value (no errors). void Add(const double* x, double val, double eval). add multi-dim coordinate data with only error in value. void Add(const double* x, double val, const double* ex, double eval). add multi-dim coordinate data with both error in coordinates and value. void Add(const double* x, double val, const double* ex, double elval, double ehval). add multi-dim coordinate data with both error in coordinates and value. const double * Coords(unsigned int ipoint) const. return a pointe",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:8687,Availability,error,error,8687,"sets, while if not compatible the old data are erased and new space of; new size is allocated.; (i.e if exists initialize is equivalent to a resize( NPoints() + maxpoints). unsigned int PointSize() const. return the size of a fit point (is the coordinate dimension + 1 for the value and eventually; the number of all errors. unsigned int DataSize() const. return the size of internal data (number of fit points); if data are not copied in but used externally the size is 0. bool HaveCoordErrors() const. flag to control if data provides error on the coordinates. bool HaveAsymErrors() const. flag to control if data provides asymmetric errors on the value. void Add(double x, double y). add one dim data with only coordinate and values. void Add(double x, double y, double ey). add one dim data with no error in the coordinate (x); in this case store the inverse of the error in the value (y). void Add(double x, double y, double ex, double ey). add one dim data with error in the coordinate (x); in this case store the value (y) error and not the inverse. void Add(double x, double y, double ex, double eyl, double eyh). add one dim data with error in the coordinate (x) and asymmetric errors in the value (y); in this case store the y errors and not the inverse. void Add(const double* x, double val). add multi-dim coordinate data with only value (no errors). void Add(const double* x, double val, double eval). add multi-dim coordinate data with only error in value. void Add(const double* x, double val, const double* ex, double eval). add multi-dim coordinate data with both error in coordinates and value. void Add(const double* x, double val, const double* ex, double elval, double ehval). add multi-dim coordinate data with both error in coordinates and value. const double * Coords(unsigned int ipoint) const. return a pointer to the coordinates data for the given fit point. double Value(unsigned int ipoint) const. return the value for the given fit point. double Error(unsigned int ipoint",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:8749,Availability,error,error,8749,"sets, while if not compatible the old data are erased and new space of; new size is allocated.; (i.e if exists initialize is equivalent to a resize( NPoints() + maxpoints). unsigned int PointSize() const. return the size of a fit point (is the coordinate dimension + 1 for the value and eventually; the number of all errors. unsigned int DataSize() const. return the size of internal data (number of fit points); if data are not copied in but used externally the size is 0. bool HaveCoordErrors() const. flag to control if data provides error on the coordinates. bool HaveAsymErrors() const. flag to control if data provides asymmetric errors on the value. void Add(double x, double y). add one dim data with only coordinate and values. void Add(double x, double y, double ey). add one dim data with no error in the coordinate (x); in this case store the inverse of the error in the value (y). void Add(double x, double y, double ex, double ey). add one dim data with error in the coordinate (x); in this case store the value (y) error and not the inverse. void Add(double x, double y, double ex, double eyl, double eyh). add one dim data with error in the coordinate (x) and asymmetric errors in the value (y); in this case store the y errors and not the inverse. void Add(const double* x, double val). add multi-dim coordinate data with only value (no errors). void Add(const double* x, double val, double eval). add multi-dim coordinate data with only error in value. void Add(const double* x, double val, const double* ex, double eval). add multi-dim coordinate data with both error in coordinates and value. void Add(const double* x, double val, const double* ex, double elval, double ehval). add multi-dim coordinate data with both error in coordinates and value. const double * Coords(unsigned int ipoint) const. return a pointer to the coordinates data for the given fit point. double Value(unsigned int ipoint) const. return the value for the given fit point. double Error(unsigned int ipoint",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:8863,Availability,error,error,8863,"ize() const. return the size of a fit point (is the coordinate dimension + 1 for the value and eventually; the number of all errors. unsigned int DataSize() const. return the size of internal data (number of fit points); if data are not copied in but used externally the size is 0. bool HaveCoordErrors() const. flag to control if data provides error on the coordinates. bool HaveAsymErrors() const. flag to control if data provides asymmetric errors on the value. void Add(double x, double y). add one dim data with only coordinate and values. void Add(double x, double y, double ey). add one dim data with no error in the coordinate (x); in this case store the inverse of the error in the value (y). void Add(double x, double y, double ex, double ey). add one dim data with error in the coordinate (x); in this case store the value (y) error and not the inverse. void Add(double x, double y, double ex, double eyl, double eyh). add one dim data with error in the coordinate (x) and asymmetric errors in the value (y); in this case store the y errors and not the inverse. void Add(const double* x, double val). add multi-dim coordinate data with only value (no errors). void Add(const double* x, double val, double eval). add multi-dim coordinate data with only error in value. void Add(const double* x, double val, const double* ex, double eval). add multi-dim coordinate data with both error in coordinates and value. void Add(const double* x, double val, const double* ex, double elval, double ehval). add multi-dim coordinate data with both error in coordinates and value. const double * Coords(unsigned int ipoint) const. return a pointer to the coordinates data for the given fit point. double Value(unsigned int ipoint) const. return the value for the given fit point. double Error(unsigned int ipoint) const. return error on the value for the given fit point; Safe (but slower) method returning correctly the error on the value; in case of asymm errors return the average 0.5(eu + el). double",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:8906,Availability,error,errors,8906,"ize() const. return the size of a fit point (is the coordinate dimension + 1 for the value and eventually; the number of all errors. unsigned int DataSize() const. return the size of internal data (number of fit points); if data are not copied in but used externally the size is 0. bool HaveCoordErrors() const. flag to control if data provides error on the coordinates. bool HaveAsymErrors() const. flag to control if data provides asymmetric errors on the value. void Add(double x, double y). add one dim data with only coordinate and values. void Add(double x, double y, double ey). add one dim data with no error in the coordinate (x); in this case store the inverse of the error in the value (y). void Add(double x, double y, double ex, double ey). add one dim data with error in the coordinate (x); in this case store the value (y) error and not the inverse. void Add(double x, double y, double ex, double eyl, double eyh). add one dim data with error in the coordinate (x) and asymmetric errors in the value (y); in this case store the y errors and not the inverse. void Add(const double* x, double val). add multi-dim coordinate data with only value (no errors). void Add(const double* x, double val, double eval). add multi-dim coordinate data with only error in value. void Add(const double* x, double val, const double* ex, double eval). add multi-dim coordinate data with both error in coordinates and value. void Add(const double* x, double val, const double* ex, double elval, double ehval). add multi-dim coordinate data with both error in coordinates and value. const double * Coords(unsigned int ipoint) const. return a pointer to the coordinates data for the given fit point. double Value(unsigned int ipoint) const. return the value for the given fit point. double Error(unsigned int ipoint) const. return error on the value for the given fit point; Safe (but slower) method returning correctly the error on the value; in case of asymm errors return the average 0.5(eu + el). double",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:8956,Availability,error,errors,8956,"ize() const. return the size of a fit point (is the coordinate dimension + 1 for the value and eventually; the number of all errors. unsigned int DataSize() const. return the size of internal data (number of fit points); if data are not copied in but used externally the size is 0. bool HaveCoordErrors() const. flag to control if data provides error on the coordinates. bool HaveAsymErrors() const. flag to control if data provides asymmetric errors on the value. void Add(double x, double y). add one dim data with only coordinate and values. void Add(double x, double y, double ey). add one dim data with no error in the coordinate (x); in this case store the inverse of the error in the value (y). void Add(double x, double y, double ex, double ey). add one dim data with error in the coordinate (x); in this case store the value (y) error and not the inverse. void Add(double x, double y, double ex, double eyl, double eyh). add one dim data with error in the coordinate (x) and asymmetric errors in the value (y); in this case store the y errors and not the inverse. void Add(const double* x, double val). add multi-dim coordinate data with only value (no errors). void Add(const double* x, double val, double eval). add multi-dim coordinate data with only error in value. void Add(const double* x, double val, const double* ex, double eval). add multi-dim coordinate data with both error in coordinates and value. void Add(const double* x, double val, const double* ex, double elval, double ehval). add multi-dim coordinate data with both error in coordinates and value. const double * Coords(unsigned int ipoint) const. return a pointer to the coordinates data for the given fit point. double Value(unsigned int ipoint) const. return the value for the given fit point. double Error(unsigned int ipoint) const. return error on the value for the given fit point; Safe (but slower) method returning correctly the error on the value; in case of asymm errors return the average 0.5(eu + el). double",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:9073,Availability,error,errors,9073,"d int DataSize() const. return the size of internal data (number of fit points); if data are not copied in but used externally the size is 0. bool HaveCoordErrors() const. flag to control if data provides error on the coordinates. bool HaveAsymErrors() const. flag to control if data provides asymmetric errors on the value. void Add(double x, double y). add one dim data with only coordinate and values. void Add(double x, double y, double ey). add one dim data with no error in the coordinate (x); in this case store the inverse of the error in the value (y). void Add(double x, double y, double ex, double ey). add one dim data with error in the coordinate (x); in this case store the value (y) error and not the inverse. void Add(double x, double y, double ex, double eyl, double eyh). add one dim data with error in the coordinate (x) and asymmetric errors in the value (y); in this case store the y errors and not the inverse. void Add(const double* x, double val). add multi-dim coordinate data with only value (no errors). void Add(const double* x, double val, double eval). add multi-dim coordinate data with only error in value. void Add(const double* x, double val, const double* ex, double eval). add multi-dim coordinate data with both error in coordinates and value. void Add(const double* x, double val, const double* ex, double elval, double ehval). add multi-dim coordinate data with both error in coordinates and value. const double * Coords(unsigned int ipoint) const. return a pointer to the coordinates data for the given fit point. double Value(unsigned int ipoint) const. return the value for the given fit point. double Error(unsigned int ipoint) const. return error on the value for the given fit point; Safe (but slower) method returning correctly the error on the value; in case of asymm errors return the average 0.5(eu + el). double InvError(unsigned int ipoint) const. Return the inverse of error on the value for the given fit point; useful when error in the coordinates",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:9174,Availability,error,error,9174," used externally the size is 0. bool HaveCoordErrors() const. flag to control if data provides error on the coordinates. bool HaveAsymErrors() const. flag to control if data provides asymmetric errors on the value. void Add(double x, double y). add one dim data with only coordinate and values. void Add(double x, double y, double ey). add one dim data with no error in the coordinate (x); in this case store the inverse of the error in the value (y). void Add(double x, double y, double ex, double ey). add one dim data with error in the coordinate (x); in this case store the value (y) error and not the inverse. void Add(double x, double y, double ex, double eyl, double eyh). add one dim data with error in the coordinate (x) and asymmetric errors in the value (y); in this case store the y errors and not the inverse. void Add(const double* x, double val). add multi-dim coordinate data with only value (no errors). void Add(const double* x, double val, double eval). add multi-dim coordinate data with only error in value. void Add(const double* x, double val, const double* ex, double eval). add multi-dim coordinate data with both error in coordinates and value. void Add(const double* x, double val, const double* ex, double elval, double ehval). add multi-dim coordinate data with both error in coordinates and value. const double * Coords(unsigned int ipoint) const. return a pointer to the coordinates data for the given fit point. double Value(unsigned int ipoint) const. return the value for the given fit point. double Error(unsigned int ipoint) const. return error on the value for the given fit point; Safe (but slower) method returning correctly the error on the value; in case of asymm errors return the average 0.5(eu + el). double InvError(unsigned int ipoint) const. Return the inverse of error on the value for the given fit point; useful when error in the coordinates are not stored and then this is used directly this as the weight in; the least square function. const double",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:9300,Availability,error,error,9300,"Errors() const. flag to control if data provides asymmetric errors on the value. void Add(double x, double y). add one dim data with only coordinate and values. void Add(double x, double y, double ey). add one dim data with no error in the coordinate (x); in this case store the inverse of the error in the value (y). void Add(double x, double y, double ex, double ey). add one dim data with error in the coordinate (x); in this case store the value (y) error and not the inverse. void Add(double x, double y, double ex, double eyl, double eyh). add one dim data with error in the coordinate (x) and asymmetric errors in the value (y); in this case store the y errors and not the inverse. void Add(const double* x, double val). add multi-dim coordinate data with only value (no errors). void Add(const double* x, double val, double eval). add multi-dim coordinate data with only error in value. void Add(const double* x, double val, const double* ex, double eval). add multi-dim coordinate data with both error in coordinates and value. void Add(const double* x, double val, const double* ex, double elval, double ehval). add multi-dim coordinate data with both error in coordinates and value. const double * Coords(unsigned int ipoint) const. return a pointer to the coordinates data for the given fit point. double Value(unsigned int ipoint) const. return the value for the given fit point. double Error(unsigned int ipoint) const. return error on the value for the given fit point; Safe (but slower) method returning correctly the error on the value; in case of asymm errors return the average 0.5(eu + el). double InvError(unsigned int ipoint) const. Return the inverse of error on the value for the given fit point; useful when error in the coordinates are not stored and then this is used directly this as the weight in; the least square function. const double * CoordErrors(unsigned int ipoint) const. Return a pointer to the errors in the coordinates for the given fit point. const double * G",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:9457,Availability,error,error,9457,"es. void Add(double x, double y, double ey). add one dim data with no error in the coordinate (x); in this case store the inverse of the error in the value (y). void Add(double x, double y, double ex, double ey). add one dim data with error in the coordinate (x); in this case store the value (y) error and not the inverse. void Add(double x, double y, double ex, double eyl, double eyh). add one dim data with error in the coordinate (x) and asymmetric errors in the value (y); in this case store the y errors and not the inverse. void Add(const double* x, double val). add multi-dim coordinate data with only value (no errors). void Add(const double* x, double val, double eval). add multi-dim coordinate data with only error in value. void Add(const double* x, double val, const double* ex, double eval). add multi-dim coordinate data with both error in coordinates and value. void Add(const double* x, double val, const double* ex, double elval, double ehval). add multi-dim coordinate data with both error in coordinates and value. const double * Coords(unsigned int ipoint) const. return a pointer to the coordinates data for the given fit point. double Value(unsigned int ipoint) const. return the value for the given fit point. double Error(unsigned int ipoint) const. return error on the value for the given fit point; Safe (but slower) method returning correctly the error on the value; in case of asymm errors return the average 0.5(eu + el). double InvError(unsigned int ipoint) const. Return the inverse of error on the value for the given fit point; useful when error in the coordinates are not stored and then this is used directly this as the weight in; the least square function. const double * CoordErrors(unsigned int ipoint) const. Return a pointer to the errors in the coordinates for the given fit point. const double * GetPoint(unsigned int ipoint, double& value) const. retrieve at the same time a pointer to the coordinate data and the fit value; More efficient than calling ",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:9695,Availability,Error,Error,9695,"ate (x); in this case store the value (y) error and not the inverse. void Add(double x, double y, double ex, double eyl, double eyh). add one dim data with error in the coordinate (x) and asymmetric errors in the value (y); in this case store the y errors and not the inverse. void Add(const double* x, double val). add multi-dim coordinate data with only value (no errors). void Add(const double* x, double val, double eval). add multi-dim coordinate data with only error in value. void Add(const double* x, double val, const double* ex, double eval). add multi-dim coordinate data with both error in coordinates and value. void Add(const double* x, double val, const double* ex, double elval, double ehval). add multi-dim coordinate data with both error in coordinates and value. const double * Coords(unsigned int ipoint) const. return a pointer to the coordinates data for the given fit point. double Value(unsigned int ipoint) const. return the value for the given fit point. double Error(unsigned int ipoint) const. return error on the value for the given fit point; Safe (but slower) method returning correctly the error on the value; in case of asymm errors return the average 0.5(eu + el). double InvError(unsigned int ipoint) const. Return the inverse of error on the value for the given fit point; useful when error in the coordinates are not stored and then this is used directly this as the weight in; the least square function. const double * CoordErrors(unsigned int ipoint) const. Return a pointer to the errors in the coordinates for the given fit point. const double * GetPoint(unsigned int ipoint, double& value) const. retrieve at the same time a pointer to the coordinate data and the fit value; More efficient than calling Coords(i) and Value(i). const double * GetPoint(unsigned int ipoint, double& value, double& invError) const. retrieve in a single call a pointer to the coordinate data, value and inverse error for; the given fit point.; To be used only when type is kValueE",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:9736,Availability,error,error,9736," ex, double eyl, double eyh). add one dim data with error in the coordinate (x) and asymmetric errors in the value (y); in this case store the y errors and not the inverse. void Add(const double* x, double val). add multi-dim coordinate data with only value (no errors). void Add(const double* x, double val, double eval). add multi-dim coordinate data with only error in value. void Add(const double* x, double val, const double* ex, double eval). add multi-dim coordinate data with both error in coordinates and value. void Add(const double* x, double val, const double* ex, double elval, double ehval). add multi-dim coordinate data with both error in coordinates and value. const double * Coords(unsigned int ipoint) const. return a pointer to the coordinates data for the given fit point. double Value(unsigned int ipoint) const. return the value for the given fit point. double Error(unsigned int ipoint) const. return error on the value for the given fit point; Safe (but slower) method returning correctly the error on the value; in case of asymm errors return the average 0.5(eu + el). double InvError(unsigned int ipoint) const. Return the inverse of error on the value for the given fit point; useful when error in the coordinates are not stored and then this is used directly this as the weight in; the least square function. const double * CoordErrors(unsigned int ipoint) const. Return a pointer to the errors in the coordinates for the given fit point. const double * GetPoint(unsigned int ipoint, double& value) const. retrieve at the same time a pointer to the coordinate data and the fit value; More efficient than calling Coords(i) and Value(i). const double * GetPoint(unsigned int ipoint, double& value, double& invError) const. retrieve in a single call a pointer to the coordinate data, value and inverse error for; the given fit point.; To be used only when type is kValueError or kNoError. In the last case the value 1 is returned; for the error. const double * GetPointError",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:9829,Availability,error,error,9829," ex, double eyl, double eyh). add one dim data with error in the coordinate (x) and asymmetric errors in the value (y); in this case store the y errors and not the inverse. void Add(const double* x, double val). add multi-dim coordinate data with only value (no errors). void Add(const double* x, double val, double eval). add multi-dim coordinate data with only error in value. void Add(const double* x, double val, const double* ex, double eval). add multi-dim coordinate data with both error in coordinates and value. void Add(const double* x, double val, const double* ex, double elval, double ehval). add multi-dim coordinate data with both error in coordinates and value. const double * Coords(unsigned int ipoint) const. return a pointer to the coordinates data for the given fit point. double Value(unsigned int ipoint) const. return the value for the given fit point. double Error(unsigned int ipoint) const. return error on the value for the given fit point; Safe (but slower) method returning correctly the error on the value; in case of asymm errors return the average 0.5(eu + el). double InvError(unsigned int ipoint) const. Return the inverse of error on the value for the given fit point; useful when error in the coordinates are not stored and then this is used directly this as the weight in; the least square function. const double * CoordErrors(unsigned int ipoint) const. Return a pointer to the errors in the coordinates for the given fit point. const double * GetPoint(unsigned int ipoint, double& value) const. retrieve at the same time a pointer to the coordinate data and the fit value; More efficient than calling Coords(i) and Value(i). const double * GetPoint(unsigned int ipoint, double& value, double& invError) const. retrieve in a single call a pointer to the coordinate data, value and inverse error for; the given fit point.; To be used only when type is kValueError or kNoError. In the last case the value 1 is returned; for the error. const double * GetPointError",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:9866,Availability,error,errors,9866," ex, double eyl, double eyh). add one dim data with error in the coordinate (x) and asymmetric errors in the value (y); in this case store the y errors and not the inverse. void Add(const double* x, double val). add multi-dim coordinate data with only value (no errors). void Add(const double* x, double val, double eval). add multi-dim coordinate data with only error in value. void Add(const double* x, double val, const double* ex, double eval). add multi-dim coordinate data with both error in coordinates and value. void Add(const double* x, double val, const double* ex, double elval, double ehval). add multi-dim coordinate data with both error in coordinates and value. const double * Coords(unsigned int ipoint) const. return a pointer to the coordinates data for the given fit point. double Value(unsigned int ipoint) const. return the value for the given fit point. double Error(unsigned int ipoint) const. return error on the value for the given fit point; Safe (but slower) method returning correctly the error on the value; in case of asymm errors return the average 0.5(eu + el). double InvError(unsigned int ipoint) const. Return the inverse of error on the value for the given fit point; useful when error in the coordinates are not stored and then this is used directly this as the weight in; the least square function. const double * CoordErrors(unsigned int ipoint) const. Return a pointer to the errors in the coordinates for the given fit point. const double * GetPoint(unsigned int ipoint, double& value) const. retrieve at the same time a pointer to the coordinate data and the fit value; More efficient than calling Coords(i) and Value(i). const double * GetPoint(unsigned int ipoint, double& value, double& invError) const. retrieve in a single call a pointer to the coordinate data, value and inverse error for; the given fit point.; To be used only when type is kValueError or kNoError. In the last case the value 1 is returned; for the error. const double * GetPointError",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:9972,Availability,error,error,9972,"data with only value (no errors). void Add(const double* x, double val, double eval). add multi-dim coordinate data with only error in value. void Add(const double* x, double val, const double* ex, double eval). add multi-dim coordinate data with both error in coordinates and value. void Add(const double* x, double val, const double* ex, double elval, double ehval). add multi-dim coordinate data with both error in coordinates and value. const double * Coords(unsigned int ipoint) const. return a pointer to the coordinates data for the given fit point. double Value(unsigned int ipoint) const. return the value for the given fit point. double Error(unsigned int ipoint) const. return error on the value for the given fit point; Safe (but slower) method returning correctly the error on the value; in case of asymm errors return the average 0.5(eu + el). double InvError(unsigned int ipoint) const. Return the inverse of error on the value for the given fit point; useful when error in the coordinates are not stored and then this is used directly this as the weight in; the least square function. const double * CoordErrors(unsigned int ipoint) const. Return a pointer to the errors in the coordinates for the given fit point. const double * GetPoint(unsigned int ipoint, double& value) const. retrieve at the same time a pointer to the coordinate data and the fit value; More efficient than calling Coords(i) and Value(i). const double * GetPoint(unsigned int ipoint, double& value, double& invError) const. retrieve in a single call a pointer to the coordinate data, value and inverse error for; the given fit point.; To be used only when type is kValueError or kNoError. In the last case the value 1 is returned; for the error. const double * GetPointError(unsigned int ipoint, double& errvalue) const. Retrieve the errors on the point (coordinate and value) for the given fit point; It must be called only when the coordinate errors are stored otherwise it will produce an; assert. const doubl",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:10028,Availability,error,error,10028,"data with only value (no errors). void Add(const double* x, double val, double eval). add multi-dim coordinate data with only error in value. void Add(const double* x, double val, const double* ex, double eval). add multi-dim coordinate data with both error in coordinates and value. void Add(const double* x, double val, const double* ex, double elval, double ehval). add multi-dim coordinate data with both error in coordinates and value. const double * Coords(unsigned int ipoint) const. return a pointer to the coordinates data for the given fit point. double Value(unsigned int ipoint) const. return the value for the given fit point. double Error(unsigned int ipoint) const. return error on the value for the given fit point; Safe (but slower) method returning correctly the error on the value; in case of asymm errors return the average 0.5(eu + el). double InvError(unsigned int ipoint) const. Return the inverse of error on the value for the given fit point; useful when error in the coordinates are not stored and then this is used directly this as the weight in; the least square function. const double * CoordErrors(unsigned int ipoint) const. Return a pointer to the errors in the coordinates for the given fit point. const double * GetPoint(unsigned int ipoint, double& value) const. retrieve at the same time a pointer to the coordinate data and the fit value; More efficient than calling Coords(i) and Value(i). const double * GetPoint(unsigned int ipoint, double& value, double& invError) const. retrieve in a single call a pointer to the coordinate data, value and inverse error for; the given fit point.; To be used only when type is kValueError or kNoError. In the last case the value 1 is returned; for the error. const double * GetPointError(unsigned int ipoint, double& errvalue) const. Retrieve the errors on the point (coordinate and value) for the given fit point; It must be called only when the coordinate errors are stored otherwise it will produce an; assert. const doubl",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:10228,Availability,error,errors,10228,"* ex, double eval). add multi-dim coordinate data with both error in coordinates and value. void Add(const double* x, double val, const double* ex, double elval, double ehval). add multi-dim coordinate data with both error in coordinates and value. const double * Coords(unsigned int ipoint) const. return a pointer to the coordinates data for the given fit point. double Value(unsigned int ipoint) const. return the value for the given fit point. double Error(unsigned int ipoint) const. return error on the value for the given fit point; Safe (but slower) method returning correctly the error on the value; in case of asymm errors return the average 0.5(eu + el). double InvError(unsigned int ipoint) const. Return the inverse of error on the value for the given fit point; useful when error in the coordinates are not stored and then this is used directly this as the weight in; the least square function. const double * CoordErrors(unsigned int ipoint) const. Return a pointer to the errors in the coordinates for the given fit point. const double * GetPoint(unsigned int ipoint, double& value) const. retrieve at the same time a pointer to the coordinate data and the fit value; More efficient than calling Coords(i) and Value(i). const double * GetPoint(unsigned int ipoint, double& value, double& invError) const. retrieve in a single call a pointer to the coordinate data, value and inverse error for; the given fit point.; To be used only when type is kValueError or kNoError. In the last case the value 1 is returned; for the error. const double * GetPointError(unsigned int ipoint, double& errvalue) const. Retrieve the errors on the point (coordinate and value) for the given fit point; It must be called only when the coordinate errors are stored otherwise it will produce an; assert. const double * GetPointError(unsigned int ipoint, double& errlow, double& errhigh) const. Get errors on the point (coordinate errors and asymmetric value errors) for the; given fit point.; It must be cal",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:10639,Availability,error,error,10639,"ue(unsigned int ipoint) const. return the value for the given fit point. double Error(unsigned int ipoint) const. return error on the value for the given fit point; Safe (but slower) method returning correctly the error on the value; in case of asymm errors return the average 0.5(eu + el). double InvError(unsigned int ipoint) const. Return the inverse of error on the value for the given fit point; useful when error in the coordinates are not stored and then this is used directly this as the weight in; the least square function. const double * CoordErrors(unsigned int ipoint) const. Return a pointer to the errors in the coordinates for the given fit point. const double * GetPoint(unsigned int ipoint, double& value) const. retrieve at the same time a pointer to the coordinate data and the fit value; More efficient than calling Coords(i) and Value(i). const double * GetPoint(unsigned int ipoint, double& value, double& invError) const. retrieve in a single call a pointer to the coordinate data, value and inverse error for; the given fit point.; To be used only when type is kValueError or kNoError. In the last case the value 1 is returned; for the error. const double * GetPointError(unsigned int ipoint, double& errvalue) const. Retrieve the errors on the point (coordinate and value) for the given fit point; It must be called only when the coordinate errors are stored otherwise it will produce an; assert. const double * GetPointError(unsigned int ipoint, double& errlow, double& errhigh) const. Get errors on the point (coordinate errors and asymmetric value errors) for the; given fit point.; It must be called only when the coordinate errors and asymmetric errors are stored; otherwise it will produce an assert. void Resize(unsigned int npoints). resize the vector to the new given npoints; if vector does not exists is created using existing point size. unsigned int NPoints() const. return number of fit points. { return fNPoints; }. unsigned int Size() const. return number of",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:10776,Availability,error,error,10776,"e for the given fit point; Safe (but slower) method returning correctly the error on the value; in case of asymm errors return the average 0.5(eu + el). double InvError(unsigned int ipoint) const. Return the inverse of error on the value for the given fit point; useful when error in the coordinates are not stored and then this is used directly this as the weight in; the least square function. const double * CoordErrors(unsigned int ipoint) const. Return a pointer to the errors in the coordinates for the given fit point. const double * GetPoint(unsigned int ipoint, double& value) const. retrieve at the same time a pointer to the coordinate data and the fit value; More efficient than calling Coords(i) and Value(i). const double * GetPoint(unsigned int ipoint, double& value, double& invError) const. retrieve in a single call a pointer to the coordinate data, value and inverse error for; the given fit point.; To be used only when type is kValueError or kNoError. In the last case the value 1 is returned; for the error. const double * GetPointError(unsigned int ipoint, double& errvalue) const. Retrieve the errors on the point (coordinate and value) for the given fit point; It must be called only when the coordinate errors are stored otherwise it will produce an; assert. const double * GetPointError(unsigned int ipoint, double& errlow, double& errhigh) const. Get errors on the point (coordinate errors and asymmetric value errors) for the; given fit point.; It must be called only when the coordinate errors and asymmetric errors are stored; otherwise it will produce an assert. void Resize(unsigned int npoints). resize the vector to the new given npoints; if vector does not exists is created using existing point size. unsigned int NPoints() const. return number of fit points. { return fNPoints; }. unsigned int Size() const. return number of fit points. { return fNPoints; }. unsigned int NDim() const. return coordinate data dimension. { return fDim; }. BinData & LogTransform().",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:10871,Availability,error,errors,10871,"t. Return the inverse of error on the value for the given fit point; useful when error in the coordinates are not stored and then this is used directly this as the weight in; the least square function. const double * CoordErrors(unsigned int ipoint) const. Return a pointer to the errors in the coordinates for the given fit point. const double * GetPoint(unsigned int ipoint, double& value) const. retrieve at the same time a pointer to the coordinate data and the fit value; More efficient than calling Coords(i) and Value(i). const double * GetPoint(unsigned int ipoint, double& value, double& invError) const. retrieve in a single call a pointer to the coordinate data, value and inverse error for; the given fit point.; To be used only when type is kValueError or kNoError. In the last case the value 1 is returned; for the error. const double * GetPointError(unsigned int ipoint, double& errvalue) const. Retrieve the errors on the point (coordinate and value) for the given fit point; It must be called only when the coordinate errors are stored otherwise it will produce an; assert. const double * GetPointError(unsigned int ipoint, double& errlow, double& errhigh) const. Get errors on the point (coordinate errors and asymmetric value errors) for the; given fit point.; It must be called only when the coordinate errors and asymmetric errors are stored; otherwise it will produce an assert. void Resize(unsigned int npoints). resize the vector to the new given npoints; if vector does not exists is created using existing point size. unsigned int NPoints() const. return number of fit points. { return fNPoints; }. unsigned int Size() const. return number of fit points. { return fNPoints; }. unsigned int NDim() const. return coordinate data dimension. { return fDim; }. BinData & LogTransform(). apply a Log transformation of the data values; can be used for example when fitting an exponential or gaussian; Transform the data in place need to copy if want to preserve original data; The ",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:10982,Availability,error,errors,10982,"t. Return the inverse of error on the value for the given fit point; useful when error in the coordinates are not stored and then this is used directly this as the weight in; the least square function. const double * CoordErrors(unsigned int ipoint) const. Return a pointer to the errors in the coordinates for the given fit point. const double * GetPoint(unsigned int ipoint, double& value) const. retrieve at the same time a pointer to the coordinate data and the fit value; More efficient than calling Coords(i) and Value(i). const double * GetPoint(unsigned int ipoint, double& value, double& invError) const. retrieve in a single call a pointer to the coordinate data, value and inverse error for; the given fit point.; To be used only when type is kValueError or kNoError. In the last case the value 1 is returned; for the error. const double * GetPointError(unsigned int ipoint, double& errvalue) const. Retrieve the errors on the point (coordinate and value) for the given fit point; It must be called only when the coordinate errors are stored otherwise it will produce an; assert. const double * GetPointError(unsigned int ipoint, double& errlow, double& errhigh) const. Get errors on the point (coordinate errors and asymmetric value errors) for the; given fit point.; It must be called only when the coordinate errors and asymmetric errors are stored; otherwise it will produce an assert. void Resize(unsigned int npoints). resize the vector to the new given npoints; if vector does not exists is created using existing point size. unsigned int NPoints() const. return number of fit points. { return fNPoints; }. unsigned int Size() const. return number of fit points. { return fNPoints; }. unsigned int NDim() const. return coordinate data dimension. { return fDim; }. BinData & LogTransform(). apply a Log transformation of the data values; can be used for example when fitting an exponential or gaussian; Transform the data in place need to copy if want to preserve original data; The ",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:11132,Availability,error,errors,11132,"unsigned int ipoint) const. Return a pointer to the errors in the coordinates for the given fit point. const double * GetPoint(unsigned int ipoint, double& value) const. retrieve at the same time a pointer to the coordinate data and the fit value; More efficient than calling Coords(i) and Value(i). const double * GetPoint(unsigned int ipoint, double& value, double& invError) const. retrieve in a single call a pointer to the coordinate data, value and inverse error for; the given fit point.; To be used only when type is kValueError or kNoError. In the last case the value 1 is returned; for the error. const double * GetPointError(unsigned int ipoint, double& errvalue) const. Retrieve the errors on the point (coordinate and value) for the given fit point; It must be called only when the coordinate errors are stored otherwise it will produce an; assert. const double * GetPointError(unsigned int ipoint, double& errlow, double& errhigh) const. Get errors on the point (coordinate errors and asymmetric value errors) for the; given fit point.; It must be called only when the coordinate errors and asymmetric errors are stored; otherwise it will produce an assert. void Resize(unsigned int npoints). resize the vector to the new given npoints; if vector does not exists is created using existing point size. unsigned int NPoints() const. return number of fit points. { return fNPoints; }. unsigned int Size() const. return number of fit points. { return fNPoints; }. unsigned int NDim() const. return coordinate data dimension. { return fDim; }. BinData & LogTransform(). apply a Log transformation of the data values; can be used for example when fitting an exponential or gaussian; Transform the data in place need to copy if want to preserve original data; The data sets must not contain negative values. IN case it does,; an empty data set is returned. const double * BinUpEdge(unsigned int icoord) const. return an array containing the upper edge of the bin for coordinate i; In case of e",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:11164,Availability,error,errors,11164,"unsigned int ipoint) const. Return a pointer to the errors in the coordinates for the given fit point. const double * GetPoint(unsigned int ipoint, double& value) const. retrieve at the same time a pointer to the coordinate data and the fit value; More efficient than calling Coords(i) and Value(i). const double * GetPoint(unsigned int ipoint, double& value, double& invError) const. retrieve in a single call a pointer to the coordinate data, value and inverse error for; the given fit point.; To be used only when type is kValueError or kNoError. In the last case the value 1 is returned; for the error. const double * GetPointError(unsigned int ipoint, double& errvalue) const. Retrieve the errors on the point (coordinate and value) for the given fit point; It must be called only when the coordinate errors are stored otherwise it will produce an; assert. const double * GetPointError(unsigned int ipoint, double& errlow, double& errhigh) const. Get errors on the point (coordinate errors and asymmetric value errors) for the; given fit point.; It must be called only when the coordinate errors and asymmetric errors are stored; otherwise it will produce an assert. void Resize(unsigned int npoints). resize the vector to the new given npoints; if vector does not exists is created using existing point size. unsigned int NPoints() const. return number of fit points. { return fNPoints; }. unsigned int Size() const. return number of fit points. { return fNPoints; }. unsigned int NDim() const. return coordinate data dimension. { return fDim; }. BinData & LogTransform(). apply a Log transformation of the data values; can be used for example when fitting an exponential or gaussian; Transform the data in place need to copy if want to preserve original data; The data sets must not contain negative values. IN case it does,; an empty data set is returned. const double * BinUpEdge(unsigned int icoord) const. return an array containing the upper edge of the bin for coordinate i; In case of e",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:11192,Availability,error,errors,11192,"unsigned int ipoint) const. Return a pointer to the errors in the coordinates for the given fit point. const double * GetPoint(unsigned int ipoint, double& value) const. retrieve at the same time a pointer to the coordinate data and the fit value; More efficient than calling Coords(i) and Value(i). const double * GetPoint(unsigned int ipoint, double& value, double& invError) const. retrieve in a single call a pointer to the coordinate data, value and inverse error for; the given fit point.; To be used only when type is kValueError or kNoError. In the last case the value 1 is returned; for the error. const double * GetPointError(unsigned int ipoint, double& errvalue) const. Retrieve the errors on the point (coordinate and value) for the given fit point; It must be called only when the coordinate errors are stored otherwise it will produce an; assert. const double * GetPointError(unsigned int ipoint, double& errlow, double& errhigh) const. Get errors on the point (coordinate errors and asymmetric value errors) for the; given fit point.; It must be called only when the coordinate errors and asymmetric errors are stored; otherwise it will produce an assert. void Resize(unsigned int npoints). resize the vector to the new given npoints; if vector does not exists is created using existing point size. unsigned int NPoints() const. return number of fit points. { return fNPoints; }. unsigned int Size() const. return number of fit points. { return fNPoints; }. unsigned int NDim() const. return coordinate data dimension. { return fDim; }. BinData & LogTransform(). apply a Log transformation of the data values; can be used for example when fitting an exponential or gaussian; Transform the data in place need to copy if want to preserve original data; The data sets must not contain negative values. IN case it does,; an empty data set is returned. const double * BinUpEdge(unsigned int icoord) const. return an array containing the upper edge of the bin for coordinate i; In case of e",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:11270,Availability,error,errors,11270,"ouble * GetPoint(unsigned int ipoint, double& value) const. retrieve at the same time a pointer to the coordinate data and the fit value; More efficient than calling Coords(i) and Value(i). const double * GetPoint(unsigned int ipoint, double& value, double& invError) const. retrieve in a single call a pointer to the coordinate data, value and inverse error for; the given fit point.; To be used only when type is kValueError or kNoError. In the last case the value 1 is returned; for the error. const double * GetPointError(unsigned int ipoint, double& errvalue) const. Retrieve the errors on the point (coordinate and value) for the given fit point; It must be called only when the coordinate errors are stored otherwise it will produce an; assert. const double * GetPointError(unsigned int ipoint, double& errlow, double& errhigh) const. Get errors on the point (coordinate errors and asymmetric value errors) for the; given fit point.; It must be called only when the coordinate errors and asymmetric errors are stored; otherwise it will produce an assert. void Resize(unsigned int npoints). resize the vector to the new given npoints; if vector does not exists is created using existing point size. unsigned int NPoints() const. return number of fit points. { return fNPoints; }. unsigned int Size() const. return number of fit points. { return fNPoints; }. unsigned int NDim() const. return coordinate data dimension. { return fDim; }. BinData & LogTransform(). apply a Log transformation of the data values; can be used for example when fitting an exponential or gaussian; Transform the data in place need to copy if want to preserve original data; The data sets must not contain negative values. IN case it does,; an empty data set is returned. const double * BinUpEdge(unsigned int icoord) const. return an array containing the upper edge of the bin for coordinate i; In case of empty bin they could be merged in a single larger bin; Return a NULL pointer if the bin width is not stored. bo",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:11292,Availability,error,errors,11292,"ouble * GetPoint(unsigned int ipoint, double& value) const. retrieve at the same time a pointer to the coordinate data and the fit value; More efficient than calling Coords(i) and Value(i). const double * GetPoint(unsigned int ipoint, double& value, double& invError) const. retrieve in a single call a pointer to the coordinate data, value and inverse error for; the given fit point.; To be used only when type is kValueError or kNoError. In the last case the value 1 is returned; for the error. const double * GetPointError(unsigned int ipoint, double& errvalue) const. Retrieve the errors on the point (coordinate and value) for the given fit point; It must be called only when the coordinate errors are stored otherwise it will produce an; assert. const double * GetPointError(unsigned int ipoint, double& errlow, double& errhigh) const. Get errors on the point (coordinate errors and asymmetric value errors) for the; given fit point.; It must be called only when the coordinate errors and asymmetric errors are stored; otherwise it will produce an assert. void Resize(unsigned int npoints). resize the vector to the new given npoints; if vector does not exists is created using existing point size. unsigned int NPoints() const. return number of fit points. { return fNPoints; }. unsigned int Size() const. return number of fit points. { return fNPoints; }. unsigned int NDim() const. return coordinate data dimension. { return fDim; }. BinData & LogTransform(). apply a Log transformation of the data values; can be used for example when fitting an exponential or gaussian; Transform the data in place need to copy if want to preserve original data; The data sets must not contain negative values. IN case it does,; an empty data set is returned. const double * BinUpEdge(unsigned int icoord) const. return an array containing the upper edge of the bin for coordinate i; In case of empty bin they could be merged in a single larger bin; Return a NULL pointer if the bin width is not stored. bo",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:1054,Energy Efficiency,efficient,efficient,1054,"Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::BinData. class ROOT::Fit::BinData: public ROOT::Fit::FitData. Class describing the binned data sets :; vectors of x coordinates, y values and optionally error on y values and error on coordinates; The dimension of the coordinate is free; There are 4 different options:; - only coordinates and values (for binned likelihood fits) : kNoError; - coordinate, values and error on values (for normal least square fits) : kValueError; - coordinate, values, error on values and coordinates (for effective least square fits) : kCoordError; - corrdinate, values, error on coordinates and asymmettric error on valyes : kAsymError. In addition there is the option to construct Bindata copying the data in (using the DataVector class); or using pointer to external data (DataWrapper) class.; In general is found to be more efficient to copy the data.; In case of really large data sets for limiting memory consumption then the other option can be used; Specialized constructor exists for data up to 3 dimensions. When the data are copying in the number of points can be set later (or re-set) using Initialize and; the data are inserted one by one using the Add method.; It is mandatory to set the size before using the Add method. @ingroup FitData. Function Members (Methods); public:. virtual~BinData(); voidAdd(double x, double y); voidAdd(const double* x, double val); voidAdd(double x, double y, double ey); voidAdd(const double* x, double val, double eval); voidAdd(double x, double y, double ex, double ey); voidAdd(const double* x, double val, const double* ex, double eval); voidAdd(double x, double y, double ex, double eyl, double eyh); voidAdd(const double* x, double val, const double* ex, double elval, double ehval); voidAddBinUpEdge(const double* xup); ROOT::Fit::BinDataBinData(const ROOT::Fit::BinData&)",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:1137,Energy Efficiency,consumption,consumption,1137,"ction members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::BinData. class ROOT::Fit::BinData: public ROOT::Fit::FitData. Class describing the binned data sets :; vectors of x coordinates, y values and optionally error on y values and error on coordinates; The dimension of the coordinate is free; There are 4 different options:; - only coordinates and values (for binned likelihood fits) : kNoError; - coordinate, values and error on values (for normal least square fits) : kValueError; - coordinate, values, error on values and coordinates (for effective least square fits) : kCoordError; - corrdinate, values, error on coordinates and asymmettric error on valyes : kAsymError. In addition there is the option to construct Bindata copying the data in (using the DataVector class); or using pointer to external data (DataWrapper) class.; In general is found to be more efficient to copy the data.; In case of really large data sets for limiting memory consumption then the other option can be used; Specialized constructor exists for data up to 3 dimensions. When the data are copying in the number of points can be set later (or re-set) using Initialize and; the data are inserted one by one using the Add method.; It is mandatory to set the size before using the Add method. @ingroup FitData. Function Members (Methods); public:. virtual~BinData(); voidAdd(double x, double y); voidAdd(const double* x, double val); voidAdd(double x, double y, double ey); voidAdd(const double* x, double val, double eval); voidAdd(double x, double y, double ex, double ey); voidAdd(const double* x, double val, const double* ex, double eval); voidAdd(double x, double y, double ex, double eyl, double eyh); voidAdd(const double* x, double val, const double* ex, double elval, double ehval); voidAddBinUpEdge(const double* xup); ROOT::Fit::BinDataBinData(const ROOT::Fit::BinData&); ROOT::Fit::BinDataBinData(unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:6008,Energy Efficiency,allocate,allocate,6008,"rivate:. vector<double>fBinEdgevector containing the bin upper edge (coordinate will contain low edge) ; ROOT::Fit::DataVector*fDataVectorpointer to the copied in data vector; ROOT::Fit::DataWrapper*fDataWrapperpointer to the external data wrapper structure; unsigned intfDimcoordinate dimension; unsigned intfNPointsnumber of contained points in the data set (can be different than size of vector); unsigned intfPointSizetotal point size including value and errors (= fDim + 2 for error in only Y ) ; doublefRefVolumereference bin volume - used to normalize the bins in case of variable bins data. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; unsigned int GetPointSize(ROOT::Fit::BinData::ErrorType err, unsigned int dim). ErrorType GetErrorType() const. explicit BinData(unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from dimension of point and max number of points (to pre-allocate vector); Give a zero value and then use Initialize later one if the size is not known. explicit BinData(const ROOT::Fit::DataOptions& opt, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from option and default range. BinData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from options and range; efault is 1D and value errors. BinData(unsigned int n, const double* dataX, const double* val, const double* ex, const double* eval); constructurs using external data . constructor from external data for 1D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, const double* dataY, const double* val, const double* ex, const double* ey, const double* eval). constructor from external data for 2D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, co",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:7803,Energy Efficiency,allocate,allocated,7803,"urs using external data . constructor from external data for 1D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, const double* dataY, const double* val, const double* ex, const double* ey, const double* eval). constructor from external data for 2D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, const double* dataY, const double* dataZ, const double* val, const double* ex, const double* ey, const double* ez, const double* eval). constructor from external data for 3D with errors on coordinate and value. BinData(const ROOT::Fit::BinData& ). copy constructors. BinData & operator=(const ROOT::Fit::BinData& ). assignment operator. virtual ~BinData(). destructor. void Initialize(unsigned int maxpoints, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). preallocate a data set with given size , dimension and error type (to get the full point size); If the data set already exists and it is having the compatible point size space for the new points; is created in the data sets, while if not compatible the old data are erased and new space of; new size is allocated.; (i.e if exists initialize is equivalent to a resize( NPoints() + maxpoints). unsigned int PointSize() const. return the size of a fit point (is the coordinate dimension + 1 for the value and eventually; the number of all errors. unsigned int DataSize() const. return the size of internal data (number of fit points); if data are not copied in but used externally the size is 0. bool HaveCoordErrors() const. flag to control if data provides error on the coordinates. bool HaveAsymErrors() const. flag to control if data provides asymmetric errors on the value. void Add(double x, double y). add one dim data with only coordinate and values. void Add(double x, double y, double ey). add one dim data with no error in the coordinate (x); in this case store the inverse of the error in the value (y). void Add(double x, double y, double ex, dou",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:10429,Energy Efficiency,efficient,efficient,10429,"hval). add multi-dim coordinate data with both error in coordinates and value. const double * Coords(unsigned int ipoint) const. return a pointer to the coordinates data for the given fit point. double Value(unsigned int ipoint) const. return the value for the given fit point. double Error(unsigned int ipoint) const. return error on the value for the given fit point; Safe (but slower) method returning correctly the error on the value; in case of asymm errors return the average 0.5(eu + el). double InvError(unsigned int ipoint) const. Return the inverse of error on the value for the given fit point; useful when error in the coordinates are not stored and then this is used directly this as the weight in; the least square function. const double * CoordErrors(unsigned int ipoint) const. Return a pointer to the errors in the coordinates for the given fit point. const double * GetPoint(unsigned int ipoint, double& value) const. retrieve at the same time a pointer to the coordinate data and the fit value; More efficient than calling Coords(i) and Value(i). const double * GetPoint(unsigned int ipoint, double& value, double& invError) const. retrieve in a single call a pointer to the coordinate data, value and inverse error for; the given fit point.; To be used only when type is kValueError or kNoError. In the last case the value 1 is returned; for the error. const double * GetPointError(unsigned int ipoint, double& errvalue) const. Retrieve the errors on the point (coordinate and value) for the given fit point; It must be called only when the coordinate errors are stored otherwise it will produce an; assert. const double * GetPointError(unsigned int ipoint, double& errlow, double& errhigh) const. Get errors on the point (coordinate errors and asymmetric value errors) for the; given fit point.; It must be called only when the coordinate errors and asymmetric errors are stored; otherwise it will produce an assert. void Resize(unsigned int npoints). resize the vector to the ne",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:5260,Integrability,wrap,wrapper,5260," ROOT::Fit::BinData&LogTransform(); static unsigned intROOT::Fit::FitData::MaxSize(); unsigned intNDim() const; unsigned intNPoints() const; ROOT::Fit::BinData&operator=(const ROOT::Fit::BinData&); const ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt() const; ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt(); unsigned intPointSize() const; const ROOT::Fit::DataRange&ROOT::Fit::FitData::Range() const; doubleRefVolume() const; voidResize(unsigned int npoints); voidSetRefVolume(double value); unsigned intSize() const; doubleValue(unsigned int ipoint) const. protected:. voidSetNPoints(unsigned int n). Data Members; public:. enum ErrorType { kNoError; kValueError; kCoordError; kAsymError; };. private:. vector<double>fBinEdgevector containing the bin upper edge (coordinate will contain low edge) ; ROOT::Fit::DataVector*fDataVectorpointer to the copied in data vector; ROOT::Fit::DataWrapper*fDataWrapperpointer to the external data wrapper structure; unsigned intfDimcoordinate dimension; unsigned intfNPointsnumber of contained points in the data set (can be different than size of vector); unsigned intfPointSizetotal point size including value and errors (= fDim + 2 for error in only Y ) ; doublefRefVolumereference bin volume - used to normalize the bins in case of variable bins data. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; unsigned int GetPointSize(ROOT::Fit::BinData::ErrorType err, unsigned int dim). ErrorType GetErrorType() const. explicit BinData(unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from dimension of point and max number of points (to pre-allocate vector); Give a zero value and then use Initialize later one if the size is not known. explicit BinData(const ROOT::Fit::DataOptions& opt, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from option and default range. BinData(const ROOT::Fit:",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:5599,Modifiability,variab,variable,5599," ROOT::Fit::BinData&LogTransform(); static unsigned intROOT::Fit::FitData::MaxSize(); unsigned intNDim() const; unsigned intNPoints() const; ROOT::Fit::BinData&operator=(const ROOT::Fit::BinData&); const ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt() const; ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt(); unsigned intPointSize() const; const ROOT::Fit::DataRange&ROOT::Fit::FitData::Range() const; doubleRefVolume() const; voidResize(unsigned int npoints); voidSetRefVolume(double value); unsigned intSize() const; doubleValue(unsigned int ipoint) const. protected:. voidSetNPoints(unsigned int n). Data Members; public:. enum ErrorType { kNoError; kValueError; kCoordError; kAsymError; };. private:. vector<double>fBinEdgevector containing the bin upper edge (coordinate will contain low edge) ; ROOT::Fit::DataVector*fDataVectorpointer to the copied in data vector; ROOT::Fit::DataWrapper*fDataWrapperpointer to the external data wrapper structure; unsigned intfDimcoordinate dimension; unsigned intfNPointsnumber of contained points in the data set (can be different than size of vector); unsigned intfPointSizetotal point size including value and errors (= fDim + 2 for error in only Y ) ; doublefRefVolumereference bin volume - used to normalize the bins in case of variable bins data. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; unsigned int GetPointSize(ROOT::Fit::BinData::ErrorType err, unsigned int dim). ErrorType GetErrorType() const. explicit BinData(unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from dimension of point and max number of points (to pre-allocate vector); Give a zero value and then use Initialize later one if the size is not known. explicit BinData(const ROOT::Fit::DataOptions& opt, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from option and default range. BinData(const ROOT::Fit:",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:5633,Modifiability,Inherit,Inheritance,5633,"onst; const ROOT::Fit::DataRange&ROOT::Fit::FitData::Range() const; doubleRefVolume() const; voidResize(unsigned int npoints); voidSetRefVolume(double value); unsigned intSize() const; doubleValue(unsigned int ipoint) const. protected:. voidSetNPoints(unsigned int n). Data Members; public:. enum ErrorType { kNoError; kValueError; kCoordError; kAsymError; };. private:. vector<double>fBinEdgevector containing the bin upper edge (coordinate will contain low edge) ; ROOT::Fit::DataVector*fDataVectorpointer to the copied in data vector; ROOT::Fit::DataWrapper*fDataWrapperpointer to the external data wrapper structure; unsigned intfDimcoordinate dimension; unsigned intfNPointsnumber of contained points in the data set (can be different than size of vector); unsigned intfPointSizetotal point size including value and errors (= fDim + 2 for error in only Y ) ; doublefRefVolumereference bin volume - used to normalize the bins in case of variable bins data. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; unsigned int GetPointSize(ROOT::Fit::BinData::ErrorType err, unsigned int dim). ErrorType GetErrorType() const. explicit BinData(unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from dimension of point and max number of points (to pre-allocate vector); Give a zero value and then use Initialize later one if the size is not known. explicit BinData(const ROOT::Fit::DataOptions& opt, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from option and default range. BinData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from options and range; efault is 1D and value errors. BinData(unsigned int n, const double* dataX, const double* val, const double* ex, const double* eval); constructurs",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:5646,Modifiability,Inherit,Inherited,5646,"onst; const ROOT::Fit::DataRange&ROOT::Fit::FitData::Range() const; doubleRefVolume() const; voidResize(unsigned int npoints); voidSetRefVolume(double value); unsigned intSize() const; doubleValue(unsigned int ipoint) const. protected:. voidSetNPoints(unsigned int n). Data Members; public:. enum ErrorType { kNoError; kValueError; kCoordError; kAsymError; };. private:. vector<double>fBinEdgevector containing the bin upper edge (coordinate will contain low edge) ; ROOT::Fit::DataVector*fDataVectorpointer to the copied in data vector; ROOT::Fit::DataWrapper*fDataWrapperpointer to the external data wrapper structure; unsigned intfDimcoordinate dimension; unsigned intfNPointsnumber of contained points in the data set (can be different than size of vector); unsigned intfPointSizetotal point size including value and errors (= fDim + 2 for error in only Y ) ; doublefRefVolumereference bin volume - used to normalize the bins in case of variable bins data. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; unsigned int GetPointSize(ROOT::Fit::BinData::ErrorType err, unsigned int dim). ErrorType GetErrorType() const. explicit BinData(unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from dimension of point and max number of points (to pre-allocate vector); Give a zero value and then use Initialize later one if the size is not known. explicit BinData(const ROOT::Fit::DataOptions& opt, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from option and default range. BinData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from options and range; efault is 1D and value errors. BinData(unsigned int n, const double* dataX, const double* val, const double* ex, const double* eval); constructurs",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:9780,Safety,Safe,Safe,9780," ex, double eyl, double eyh). add one dim data with error in the coordinate (x) and asymmetric errors in the value (y); in this case store the y errors and not the inverse. void Add(const double* x, double val). add multi-dim coordinate data with only value (no errors). void Add(const double* x, double val, double eval). add multi-dim coordinate data with only error in value. void Add(const double* x, double val, const double* ex, double eval). add multi-dim coordinate data with both error in coordinates and value. void Add(const double* x, double val, const double* ex, double elval, double ehval). add multi-dim coordinate data with both error in coordinates and value. const double * Coords(unsigned int ipoint) const. return a pointer to the coordinates data for the given fit point. double Value(unsigned int ipoint) const. return the value for the given fit point. double Error(unsigned int ipoint) const. return error on the value for the given fit point; Safe (but slower) method returning correctly the error on the value; in case of asymm errors return the average 0.5(eu + el). double InvError(unsigned int ipoint) const. Return the inverse of error on the value for the given fit point; useful when error in the coordinates are not stored and then this is used directly this as the weight in; the least square function. const double * CoordErrors(unsigned int ipoint) const. Return a pointer to the errors in the coordinates for the given fit point. const double * GetPoint(unsigned int ipoint, double& value) const. retrieve at the same time a pointer to the coordinate data and the fit value; More efficient than calling Coords(i) and Value(i). const double * GetPoint(unsigned int ipoint, double& value, double& invError) const. retrieve in a single call a pointer to the coordinate data, value and inverse error for; the given fit point.; To be used only when type is kValueError or kNoError. In the last case the value 1 is returned; for the error. const double * GetPointError",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:4343,Testability,Log,LogTransform,4343,"onst double* dataY, const double* dataZ, const double* val, const double* ex, const double* ey, const double* ez, const double* eval); const double*BinUpEdge(unsigned int icoord) const; const double*CoordErrors(unsigned int ipoint) const; const double*Coords(unsigned int ipoint) const; unsigned intDataSize() const; doubleError(unsigned int ipoint) const; ROOT::Fit::FitDataROOT::Fit::FitData::FitData(); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::DataOptions& opt); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::DataRange& range); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::FitData&); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range); ROOT::Fit::BinData::ErrorTypeGetErrorType() const; const double*GetPoint(unsigned int ipoint, double& value) const; const double*GetPoint(unsigned int ipoint, double& value, double& invError) const; const double*GetPointError(unsigned int ipoint, double& errvalue) const; const double*GetPointError(unsigned int ipoint, double& errlow, double& errhigh) const; static unsigned intGetPointSize(ROOT::Fit::BinData::ErrorType err, unsigned int dim); boolHasBinEdges() const; boolHaveAsymErrors() const; boolHaveCoordErrors() const; voidInitialize(unsigned int maxpoints, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError); doubleInvError(unsigned int ipoint) const; ROOT::Fit::BinData&LogTransform(); static unsigned intROOT::Fit::FitData::MaxSize(); unsigned intNDim() const; unsigned intNPoints() const; ROOT::Fit::BinData&operator=(const ROOT::Fit::BinData&); const ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt() const; ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt(); unsigned intPointSize() const; const ROOT::Fit::DataRange&ROOT::Fit::FitData::Range() const; doubleRefVolume() const; voidResize(unsigned int npoints); voidSetRefVolume(double value); unsigned intSize() const; doubleValue(unsigned int ipoint) const.",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:11030,Testability,assert,assert,11030,"t. Return the inverse of error on the value for the given fit point; useful when error in the coordinates are not stored and then this is used directly this as the weight in; the least square function. const double * CoordErrors(unsigned int ipoint) const. Return a pointer to the errors in the coordinates for the given fit point. const double * GetPoint(unsigned int ipoint, double& value) const. retrieve at the same time a pointer to the coordinate data and the fit value; More efficient than calling Coords(i) and Value(i). const double * GetPoint(unsigned int ipoint, double& value, double& invError) const. retrieve in a single call a pointer to the coordinate data, value and inverse error for; the given fit point.; To be used only when type is kValueError or kNoError. In the last case the value 1 is returned; for the error. const double * GetPointError(unsigned int ipoint, double& errvalue) const. Retrieve the errors on the point (coordinate and value) for the given fit point; It must be called only when the coordinate errors are stored otherwise it will produce an; assert. const double * GetPointError(unsigned int ipoint, double& errlow, double& errhigh) const. Get errors on the point (coordinate errors and asymmetric value errors) for the; given fit point.; It must be called only when the coordinate errors and asymmetric errors are stored; otherwise it will produce an assert. void Resize(unsigned int npoints). resize the vector to the new given npoints; if vector does not exists is created using existing point size. unsigned int NPoints() const. return number of fit points. { return fNPoints; }. unsigned int Size() const. return number of fit points. { return fNPoints; }. unsigned int NDim() const. return coordinate data dimension. { return fDim; }. BinData & LogTransform(). apply a Log transformation of the data values; can be used for example when fitting an exponential or gaussian; Transform the data in place need to copy if want to preserve original data; The ",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:11340,Testability,assert,assert,11340,"ouble * GetPoint(unsigned int ipoint, double& value) const. retrieve at the same time a pointer to the coordinate data and the fit value; More efficient than calling Coords(i) and Value(i). const double * GetPoint(unsigned int ipoint, double& value, double& invError) const. retrieve in a single call a pointer to the coordinate data, value and inverse error for; the given fit point.; To be used only when type is kValueError or kNoError. In the last case the value 1 is returned; for the error. const double * GetPointError(unsigned int ipoint, double& errvalue) const. Retrieve the errors on the point (coordinate and value) for the given fit point; It must be called only when the coordinate errors are stored otherwise it will produce an; assert. const double * GetPointError(unsigned int ipoint, double& errlow, double& errhigh) const. Get errors on the point (coordinate errors and asymmetric value errors) for the; given fit point.; It must be called only when the coordinate errors and asymmetric errors are stored; otherwise it will produce an assert. void Resize(unsigned int npoints). resize the vector to the new given npoints; if vector does not exists is created using existing point size. unsigned int NPoints() const. return number of fit points. { return fNPoints; }. unsigned int Size() const. return number of fit points. { return fNPoints; }. unsigned int NDim() const. return coordinate data dimension. { return fDim; }. BinData & LogTransform(). apply a Log transformation of the data values; can be used for example when fitting an exponential or gaussian; Transform the data in place need to copy if want to preserve original data; The data sets must not contain negative values. IN case it does,; an empty data set is returned. const double * BinUpEdge(unsigned int icoord) const. return an array containing the upper edge of the bin for coordinate i; In case of empty bin they could be merged in a single larger bin; Return a NULL pointer if the bin width is not stored. bo",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:11739,Testability,Log,LogTransform,11739,"e the value 1 is returned; for the error. const double * GetPointError(unsigned int ipoint, double& errvalue) const. Retrieve the errors on the point (coordinate and value) for the given fit point; It must be called only when the coordinate errors are stored otherwise it will produce an; assert. const double * GetPointError(unsigned int ipoint, double& errlow, double& errhigh) const. Get errors on the point (coordinate errors and asymmetric value errors) for the; given fit point.; It must be called only when the coordinate errors and asymmetric errors are stored; otherwise it will produce an assert. void Resize(unsigned int npoints). resize the vector to the new given npoints; if vector does not exists is created using existing point size. unsigned int NPoints() const. return number of fit points. { return fNPoints; }. unsigned int Size() const. return number of fit points. { return fNPoints; }. unsigned int NDim() const. return coordinate data dimension. { return fDim; }. BinData & LogTransform(). apply a Log transformation of the data values; can be used for example when fitting an exponential or gaussian; Transform the data in place need to copy if want to preserve original data; The data sets must not contain negative values. IN case it does,; an empty data set is returned. const double * BinUpEdge(unsigned int icoord) const. return an array containing the upper edge of the bin for coordinate i; In case of empty bin they could be merged in a single larger bin; Return a NULL pointer if the bin width is not stored. bool HasBinEdges() const. query if the data store the bin edges instead of the center. void AddBinUpEdge(const double* xup). add the bin width data, a pointer to an array with the bin upper edge information.; This is needed when fitting with integral options; The information is added for the previously inserted point.; BinData::Add must be called before. double RefVolume() const. retrieve the reference volume used to normalize the data when the option b",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__BinData.html:11763,Testability,Log,Log,11763,"rrors on the point (coordinate and value) for the given fit point; It must be called only when the coordinate errors are stored otherwise it will produce an; assert. const double * GetPointError(unsigned int ipoint, double& errlow, double& errhigh) const. Get errors on the point (coordinate errors and asymmetric value errors) for the; given fit point.; It must be called only when the coordinate errors and asymmetric errors are stored; otherwise it will produce an assert. void Resize(unsigned int npoints). resize the vector to the new given npoints; if vector does not exists is created using existing point size. unsigned int NPoints() const. return number of fit points. { return fNPoints; }. unsigned int Size() const. return number of fit points. { return fNPoints; }. unsigned int NDim() const. return coordinate data dimension. { return fDim; }. BinData & LogTransform(). apply a Log transformation of the data values; can be used for example when fitting an exponential or gaussian; Transform the data in place need to copy if want to preserve original data; The data sets must not contain negative values. IN case it does,; an empty data set is returned. const double * BinUpEdge(unsigned int icoord) const. return an array containing the upper edge of the bin for coordinate i; In case of empty bin they could be merged in a single larger bin; Return a NULL pointer if the bin width is not stored. bool HasBinEdges() const. query if the data store the bin edges instead of the center. void AddBinUpEdge(const double* xup). add the bin width data, a pointer to an array with the bin upper edge information.; This is needed when fitting with integral options; The information is added for the previously inserted point.; BinData::Add must be called before. double RefVolume() const. retrieve the reference volume used to normalize the data when the option bin volume is set. { return fRefVolume; }. void SetRefVolume(double value). set the reference volume used to normalize the data when",MatchSource.WIKI,root/html532/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html
https://root.cern/root/html532/ROOT__Fit__Chi2FCN_-p0Math__IBaseFunctionMultiDim_.html:2463,Deployability,Update,UpdateNCalls,2463,"ss)ROOT::Fit::Chi2Function, ROOT::Fit::Chi2FCN<ROOT::Math::IMultiGenFunction>. Function Members (Methods); public:. virtual~Chi2FCN<ROOT::Math::IBaseFunctionMultiDim>(); ROOT::Fit::Chi2FCN<ROOT::Math::IBaseFunctionMultiDim>Chi2FCN<ROOT::Math::IBaseFunctionMultiDim>(const ROOT::Fit::Chi2FCN<ROOT::Math::IBaseFunctionMultiDim>&); ROOT::Fit::Chi2FCN<ROOT::Math::IBaseFunctionMultiDim>Chi2FCN<ROOT::Math::IBaseFunctionMultiDim>(const ROOT::Fit::BinData& data, const ROOT::Fit::Chi2FCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction& func); virtual ROOT::Fit::Chi2FCN<ROOT::Math::IBaseFunctionMultiDim>::BaseFunction*Clone() const; virtual const ROOT::Fit::BinData&Data() const; virtual doubleDataElement(const double* x, unsigned int i, double* g) const; virtual voidGradient(const double* x, double* g) const; virtual const ROOT::Fit::Chi2FCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction&ModelFunction() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NDim() const; virtual unsigned intNFitPoints() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>&ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::operator=(const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>&); virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::ResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::Type_tType() const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::UpdateNCalls() const. protected:. virtual voidSetNFitPoints(unsigned int n) const. private:. virtual doubleDoDerivative(const double* x,",MatchSource.WIKI,root/html532/ROOT__Fit__Chi2FCN_-p0Math__IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Chi2FCN_-p0Math__IBaseFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__Chi2FCN_-p0Math__IBaseFunctionMultiDim_.html:3685,Integrability,interface,interface,3685,"Math::IBaseFunctionMultiDim>&); virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::ResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::Type_tType() const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::UpdateNCalls() const. protected:. virtual voidSetNFitPoints(unsigned int n) const. private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const. Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::BinData&fData; const ROOT::Fit::Chi2FCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; unsigned intfNEffPointsnumber of effective points used in the fit . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function. unsigned int NFitPoints() const; effective points used in the fit (exclude the rejected one). { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th chi-square residual. void Gradient(const double* x, double* g) const; need to be virtual to be instantiated. void SetNFitPoints(unsigned int n) const; set number of fit points (need to be called in const methods, make it const). { fNEffPoints = n; }. double DoEval(const double* x) const. Evaluation of the function (required by interface). double DoDerivative(const double* x, unsigned int icoord) const; for derivatives.  Author: L. Moneta Tue Sep 5 09:13:32 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: Chi2FCN.h 40577 2011-08-12 10:43:12Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Fit__Chi2FCN_-p0Math__IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Chi2FCN_-p0Math__IBaseFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__Chi2FCN_-p0Math__IBaseFunctionMultiDim_.html:3035,Modifiability,Inherit,Inheritance,3035,"OT::Math::IBaseFunctionMultiDim>::operator=(const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>&); virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::ResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::Type_tType() const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::UpdateNCalls() const. protected:. virtual voidSetNFitPoints(unsigned int n) const. private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const. Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::BinData&fData; const ROOT::Fit::Chi2FCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; unsigned intfNEffPointsnumber of effective points used in the fit . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function. unsigned int NFitPoints() const; effective points used in the fit (exclude the rejected one). { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th chi-square residual. void Gradient(const double* x, double* g) const; need to be virtual to be instantiated. void SetNFitPoints(unsigned int n) const; set number of fit points (need to be called in const methods, make it const). { fNEffPoints = n; }. double DoEval(const double* x) const. Evaluation of the function (required by interface). double DoDerivative(const double* x, unsigned int icoord) const; for derivatives.  Author: L. Moneta Tue Sep 5 09:13:32 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: Chi2FCN.h 40577 2011-08-12 10:43:12Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or sugge",MatchSource.WIKI,root/html532/ROOT__Fit__Chi2FCN_-p0Math__IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Chi2FCN_-p0Math__IBaseFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__Chi2FCN_-p0Math__IBaseFunctionMultiDim_.html:3048,Modifiability,Inherit,Inherited,3048,"OT::Math::IBaseFunctionMultiDim>::operator=(const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>&); virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::ResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::Type_tType() const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::UpdateNCalls() const. protected:. virtual voidSetNFitPoints(unsigned int n) const. private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const. Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::BinData&fData; const ROOT::Fit::Chi2FCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; unsigned intfNEffPointsnumber of effective points used in the fit . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function. unsigned int NFitPoints() const; effective points used in the fit (exclude the rejected one). { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th chi-square residual. void Gradient(const double* x, double* g) const; need to be virtual to be instantiated. void SetNFitPoints(unsigned int n) const; set number of fit points (need to be called in const methods, make it const). { fNEffPoints = n; }. double DoEval(const double* x) const. Evaluation of the function (required by interface). double DoDerivative(const double* x, unsigned int icoord) const; for derivatives.  Author: L. Moneta Tue Sep 5 09:13:32 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: Chi2FCN.h 40577 2011-08-12 10:43:12Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or sugge",MatchSource.WIKI,root/html532/ROOT__Fit__Chi2FCN_-p0Math__IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Chi2FCN_-p0Math__IBaseFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__Chi2FCN_-p0Math__IGradientFunctionMultiDim_.html:2755,Deployability,Update,UpdateNCalls,2755,"ctionMultiDim>(); ROOT::Fit::Chi2FCN<ROOT::Math::IGradientFunctionMultiDim>Chi2FCN<ROOT::Math::IGradientFunctionMultiDim>(const ROOT::Fit::Chi2FCN<ROOT::Math::IGradientFunctionMultiDim>&); ROOT::Fit::Chi2FCN<ROOT::Math::IGradientFunctionMultiDim>Chi2FCN<ROOT::Math::IGradientFunctionMultiDim>(const ROOT::Fit::BinData& data, const ROOT::Fit::Chi2FCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction& func); virtual ROOT::Fit::Chi2FCN<ROOT::Math::IGradientFunctionMultiDim>::BaseFunction*Clone() const; virtual const ROOT::Fit::BinData&Data() const; virtual doubleDataElement(const double* x, unsigned int i, double* g) const; doubleROOT::Math::IGradientMultiDim::Derivative(const double* x, unsigned int icoord = 0) const; virtual voidROOT::Math::IGradientFunctionMultiDim::FdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* g) const; virtual const ROOT::Fit::Chi2FCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&ModelFunction() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NDim() const; virtual unsigned intNFitPoints() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>&ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::operator=(const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>&); virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::ResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::Type_tType() const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::UpdateNCalls() const.",MatchSource.WIKI,root/html532/ROOT__Fit__Chi2FCN_-p0Math__IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Chi2FCN_-p0Math__IGradientFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__Chi2FCN_-p0Math__IGradientFunctionMultiDim_.html:3981,Integrability,interface,interface,3981,"ionMultiDim>&); virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::ResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::Type_tType() const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::UpdateNCalls() const. protected:. virtual voidSetNFitPoints(unsigned int n) const. private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const. Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::BinData&fData; const ROOT::Fit::Chi2FCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; unsigned intfNEffPointsnumber of effective points used in the fit . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function. unsigned int NFitPoints() const; effective points used in the fit (exclude the rejected one). { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th chi-square residual. void Gradient(const double* x, double* g) const; need to be virtual to be instantiated. void SetNFitPoints(unsigned int n) const; set number of fit points (need to be called in const methods, make it const). { fNEffPoints = n; }. double DoEval(const double* x) const. Evaluation of the function (required by interface). double DoDerivative(const double* x, unsigned int icoord) const; for derivatives.  Author: L. Moneta Tue Sep 5 09:13:32 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: Chi2FCN.h 40577 2011-08-12 10:43:12Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Fit__Chi2FCN_-p0Math__IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Chi2FCN_-p0Math__IGradientFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__Chi2FCN_-p0Math__IGradientFunctionMultiDim_.html:3331,Modifiability,Inherit,Inheritance,3331,"ionMultiDim>::operator=(const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>&); virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::ResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::Type_tType() const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::UpdateNCalls() const. protected:. virtual voidSetNFitPoints(unsigned int n) const. private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const. Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::BinData&fData; const ROOT::Fit::Chi2FCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; unsigned intfNEffPointsnumber of effective points used in the fit . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function. unsigned int NFitPoints() const; effective points used in the fit (exclude the rejected one). { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th chi-square residual. void Gradient(const double* x, double* g) const; need to be virtual to be instantiated. void SetNFitPoints(unsigned int n) const; set number of fit points (need to be called in const methods, make it const). { fNEffPoints = n; }. double DoEval(const double* x) const. Evaluation of the function (required by interface). double DoDerivative(const double* x, unsigned int icoord) const; for derivatives.  Author: L. Moneta Tue Sep 5 09:13:32 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: Chi2FCN.h 40577 2011-08-12 10:43:12Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or sugge",MatchSource.WIKI,root/html532/ROOT__Fit__Chi2FCN_-p0Math__IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Chi2FCN_-p0Math__IGradientFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__Chi2FCN_-p0Math__IGradientFunctionMultiDim_.html:3344,Modifiability,Inherit,Inherited,3344,"ionMultiDim>::operator=(const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>&); virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::ResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::Type_tType() const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::UpdateNCalls() const. protected:. virtual voidSetNFitPoints(unsigned int n) const. private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const. Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::BinData&fData; const ROOT::Fit::Chi2FCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; unsigned intfNEffPointsnumber of effective points used in the fit . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function. unsigned int NFitPoints() const; effective points used in the fit (exclude the rejected one). { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th chi-square residual. void Gradient(const double* x, double* g) const; need to be virtual to be instantiated. void SetNFitPoints(unsigned int n) const; set number of fit points (need to be called in const methods, make it const). { fNEffPoints = n; }. double DoEval(const double* x) const. Evaluation of the function (required by interface). double DoDerivative(const double* x, unsigned int icoord) const; for derivatives.  Author: L. Moneta Tue Sep 5 09:13:32 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: Chi2FCN.h 40577 2011-08-12 10:43:12Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or sugge",MatchSource.WIKI,root/html532/ROOT__Fit__Chi2FCN_-p0Math__IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Chi2FCN_-p0Math__IGradientFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__DataOptions.html:662,Availability,error,errors,662,". ROOT::Fit::DataOptions. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::DataOptions. class ROOT::Fit::DataOptions. DataOptions : simple structure holding the options on how the data are filled. @ingroup FitData. Function Members (Methods); public:. ~DataOptions(); ROOT::Fit::DataOptionsDataOptions(); ROOT::Fit::DataOptionsDataOptions(const ROOT::Fit::DataOptions&); ROOT::Fit::DataOptions&operator=(const ROOT::Fit::DataOptions&). Data Members; public:. boolfAsymErrorsuse asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true); boolfBinVolumenormalize data by the bin volume (it is used in the Poisson likelihood fits); boolfCoordErrorsuse errors on the x coordinates when available (default is true); boolfErrors1use all errors equal to 1, i.e. fit without errors (default is false) ; boolfIntegraluse integral of bin content instead of bin center (default is false); boolfUseEmptyuse empty bins (default is false) with a fixed error of 1; boolfUseRangeuse the function range when creating the fit data (default is false). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; DataOptions(). Default constructor: use the default options. {}.  Author: L. Moneta Wed Aug 30 11:04:59 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: DataOptions.h 31180 2009-11-16 10:54:05Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Fit__DataOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__DataOptions.html
https://root.cern/root/html532/ROOT__Fit__DataOptions.html:687,Availability,avail,available,687,". ROOT::Fit::DataOptions. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::DataOptions. class ROOT::Fit::DataOptions. DataOptions : simple structure holding the options on how the data are filled. @ingroup FitData. Function Members (Methods); public:. ~DataOptions(); ROOT::Fit::DataOptionsDataOptions(); ROOT::Fit::DataOptionsDataOptions(const ROOT::Fit::DataOptions&); ROOT::Fit::DataOptions&operator=(const ROOT::Fit::DataOptions&). Data Members; public:. boolfAsymErrorsuse asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true); boolfBinVolumenormalize data by the bin volume (it is used in the Poisson likelihood fits); boolfCoordErrorsuse errors on the x coordinates when available (default is true); boolfErrors1use all errors equal to 1, i.e. fit without errors (default is false) ; boolfIntegraluse integral of bin content instead of bin center (default is false); boolfUseEmptyuse empty bins (default is false) with a fixed error of 1; boolfUseRangeuse the function range when creating the fit data (default is false). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; DataOptions(). Default constructor: use the default options. {}.  Author: L. Moneta Wed Aug 30 11:04:59 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: DataOptions.h 31180 2009-11-16 10:54:05Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Fit__DataOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__DataOptions.html
https://root.cern/root/html532/ROOT__Fit__DataOptions.html:881,Availability,error,errors,881,". ROOT::Fit::DataOptions. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::DataOptions. class ROOT::Fit::DataOptions. DataOptions : simple structure holding the options on how the data are filled. @ingroup FitData. Function Members (Methods); public:. ~DataOptions(); ROOT::Fit::DataOptionsDataOptions(); ROOT::Fit::DataOptionsDataOptions(const ROOT::Fit::DataOptions&); ROOT::Fit::DataOptions&operator=(const ROOT::Fit::DataOptions&). Data Members; public:. boolfAsymErrorsuse asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true); boolfBinVolumenormalize data by the bin volume (it is used in the Poisson likelihood fits); boolfCoordErrorsuse errors on the x coordinates when available (default is true); boolfErrors1use all errors equal to 1, i.e. fit without errors (default is false) ; boolfIntegraluse integral of bin content instead of bin center (default is false); boolfUseEmptyuse empty bins (default is false) with a fixed error of 1; boolfUseRangeuse the function range when creating the fit data (default is false). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; DataOptions(). Default constructor: use the default options. {}.  Author: L. Moneta Wed Aug 30 11:04:59 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: DataOptions.h 31180 2009-11-16 10:54:05Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Fit__DataOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__DataOptions.html
https://root.cern/root/html532/ROOT__Fit__DataOptions.html:914,Availability,avail,available,914,". ROOT::Fit::DataOptions. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::DataOptions. class ROOT::Fit::DataOptions. DataOptions : simple structure holding the options on how the data are filled. @ingroup FitData. Function Members (Methods); public:. ~DataOptions(); ROOT::Fit::DataOptionsDataOptions(); ROOT::Fit::DataOptionsDataOptions(const ROOT::Fit::DataOptions&); ROOT::Fit::DataOptions&operator=(const ROOT::Fit::DataOptions&). Data Members; public:. boolfAsymErrorsuse asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true); boolfBinVolumenormalize data by the bin volume (it is used in the Poisson likelihood fits); boolfCoordErrorsuse errors on the x coordinates when available (default is true); boolfErrors1use all errors equal to 1, i.e. fit without errors (default is false) ; boolfIntegraluse integral of bin content instead of bin center (default is false); boolfUseEmptyuse empty bins (default is false) with a fixed error of 1; boolfUseRangeuse the function range when creating the fit data (default is false). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; DataOptions(). Default constructor: use the default options. {}.  Author: L. Moneta Wed Aug 30 11:04:59 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: DataOptions.h 31180 2009-11-16 10:54:05Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Fit__DataOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__DataOptions.html
https://root.cern/root/html532/ROOT__Fit__DataOptions.html:963,Availability,error,errors,963,". ROOT::Fit::DataOptions. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::DataOptions. class ROOT::Fit::DataOptions. DataOptions : simple structure holding the options on how the data are filled. @ingroup FitData. Function Members (Methods); public:. ~DataOptions(); ROOT::Fit::DataOptionsDataOptions(); ROOT::Fit::DataOptionsDataOptions(const ROOT::Fit::DataOptions&); ROOT::Fit::DataOptions&operator=(const ROOT::Fit::DataOptions&). Data Members; public:. boolfAsymErrorsuse asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true); boolfBinVolumenormalize data by the bin volume (it is used in the Poisson likelihood fits); boolfCoordErrorsuse errors on the x coordinates when available (default is true); boolfErrors1use all errors equal to 1, i.e. fit without errors (default is false) ; boolfIntegraluse integral of bin content instead of bin center (default is false); boolfUseEmptyuse empty bins (default is false) with a fixed error of 1; boolfUseRangeuse the function range when creating the fit data (default is false). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; DataOptions(). Default constructor: use the default options. {}.  Author: L. Moneta Wed Aug 30 11:04:59 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: DataOptions.h 31180 2009-11-16 10:54:05Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Fit__DataOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__DataOptions.html
https://root.cern/root/html532/ROOT__Fit__DataOptions.html:999,Availability,error,errors,999,". ROOT::Fit::DataOptions. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::DataOptions. class ROOT::Fit::DataOptions. DataOptions : simple structure holding the options on how the data are filled. @ingroup FitData. Function Members (Methods); public:. ~DataOptions(); ROOT::Fit::DataOptionsDataOptions(); ROOT::Fit::DataOptionsDataOptions(const ROOT::Fit::DataOptions&); ROOT::Fit::DataOptions&operator=(const ROOT::Fit::DataOptions&). Data Members; public:. boolfAsymErrorsuse asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true); boolfBinVolumenormalize data by the bin volume (it is used in the Poisson likelihood fits); boolfCoordErrorsuse errors on the x coordinates when available (default is true); boolfErrors1use all errors equal to 1, i.e. fit without errors (default is false) ; boolfIntegraluse integral of bin content instead of bin center (default is false); boolfUseEmptyuse empty bins (default is false) with a fixed error of 1; boolfUseRangeuse the function range when creating the fit data (default is false). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; DataOptions(). Default constructor: use the default options. {}.  Author: L. Moneta Wed Aug 30 11:04:59 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: DataOptions.h 31180 2009-11-16 10:54:05Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Fit__DataOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__DataOptions.html
https://root.cern/root/html532/ROOT__Fit__DataOptions.html:1170,Availability,error,error,1170,". ROOT::Fit::DataOptions. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::DataOptions. class ROOT::Fit::DataOptions. DataOptions : simple structure holding the options on how the data are filled. @ingroup FitData. Function Members (Methods); public:. ~DataOptions(); ROOT::Fit::DataOptionsDataOptions(); ROOT::Fit::DataOptionsDataOptions(const ROOT::Fit::DataOptions&); ROOT::Fit::DataOptions&operator=(const ROOT::Fit::DataOptions&). Data Members; public:. boolfAsymErrorsuse asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true); boolfBinVolumenormalize data by the bin volume (it is used in the Poisson likelihood fits); boolfCoordErrorsuse errors on the x coordinates when available (default is true); boolfErrors1use all errors equal to 1, i.e. fit without errors (default is false) ; boolfIntegraluse integral of bin content instead of bin center (default is false); boolfUseEmptyuse empty bins (default is false) with a fixed error of 1; boolfUseRangeuse the function range when creating the fit data (default is false). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; DataOptions(). Default constructor: use the default options. {}.  Author: L. Moneta Wed Aug 30 11:04:59 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: DataOptions.h 31180 2009-11-16 10:54:05Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Fit__DataOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__DataOptions.html
https://root.cern/root/html532/ROOT__Fit__DataOptions.html:1279,Modifiability,Inherit,Inheritance,1279,". ROOT::Fit::DataOptions. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::DataOptions. class ROOT::Fit::DataOptions. DataOptions : simple structure holding the options on how the data are filled. @ingroup FitData. Function Members (Methods); public:. ~DataOptions(); ROOT::Fit::DataOptionsDataOptions(); ROOT::Fit::DataOptionsDataOptions(const ROOT::Fit::DataOptions&); ROOT::Fit::DataOptions&operator=(const ROOT::Fit::DataOptions&). Data Members; public:. boolfAsymErrorsuse asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true); boolfBinVolumenormalize data by the bin volume (it is used in the Poisson likelihood fits); boolfCoordErrorsuse errors on the x coordinates when available (default is true); boolfErrors1use all errors equal to 1, i.e. fit without errors (default is false) ; boolfIntegraluse integral of bin content instead of bin center (default is false); boolfUseEmptyuse empty bins (default is false) with a fixed error of 1; boolfUseRangeuse the function range when creating the fit data (default is false). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; DataOptions(). Default constructor: use the default options. {}.  Author: L. Moneta Wed Aug 30 11:04:59 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: DataOptions.h 31180 2009-11-16 10:54:05Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Fit__DataOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__DataOptions.html
https://root.cern/root/html532/ROOT__Fit__DataOptions.html:1292,Modifiability,Inherit,Inherited,1292,". ROOT::Fit::DataOptions. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::DataOptions. class ROOT::Fit::DataOptions. DataOptions : simple structure holding the options on how the data are filled. @ingroup FitData. Function Members (Methods); public:. ~DataOptions(); ROOT::Fit::DataOptionsDataOptions(); ROOT::Fit::DataOptionsDataOptions(const ROOT::Fit::DataOptions&); ROOT::Fit::DataOptions&operator=(const ROOT::Fit::DataOptions&). Data Members; public:. boolfAsymErrorsuse asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true); boolfBinVolumenormalize data by the bin volume (it is used in the Poisson likelihood fits); boolfCoordErrorsuse errors on the x coordinates when available (default is true); boolfErrors1use all errors equal to 1, i.e. fit without errors (default is false) ; boolfIntegraluse integral of bin content instead of bin center (default is false); boolfUseEmptyuse empty bins (default is false) with a fixed error of 1; boolfUseRangeuse the function range when creating the fit data (default is false). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; DataOptions(). Default constructor: use the default options. {}.  Author: L. Moneta Wed Aug 30 11:04:59 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: DataOptions.h 31180 2009-11-16 10:54:05Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Fit__DataOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__DataOptions.html
https://root.cern/root/html532/ROOT__Fit__DataOptions.html:305,Usability,simpl,simple,305,". ROOT::Fit::DataOptions. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::DataOptions. class ROOT::Fit::DataOptions. DataOptions : simple structure holding the options on how the data are filled. @ingroup FitData. Function Members (Methods); public:. ~DataOptions(); ROOT::Fit::DataOptionsDataOptions(); ROOT::Fit::DataOptionsDataOptions(const ROOT::Fit::DataOptions&); ROOT::Fit::DataOptions&operator=(const ROOT::Fit::DataOptions&). Data Members; public:. boolfAsymErrorsuse asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true); boolfBinVolumenormalize data by the bin volume (it is used in the Poisson likelihood fits); boolfCoordErrorsuse errors on the x coordinates when available (default is true); boolfErrors1use all errors equal to 1, i.e. fit without errors (default is false) ; boolfIntegraluse integral of bin content instead of bin center (default is false); boolfUseEmptyuse empty bins (default is false) with a fixed error of 1; boolfUseRangeuse the function range when creating the fit data (default is false). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; DataOptions(). Default constructor: use the default options. {}.  Author: L. Moneta Wed Aug 30 11:04:59 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: DataOptions.h 31180 2009-11-16 10:54:05Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Fit__DataOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__DataOptions.html
https://root.cern/root/html532/ROOT__Fit__DataRange.html:2498,Modifiability,Inherit,Inheritance,2498,"max) const; voidGetRange(double& xmin, double& xmax, double& ymin, double& ymax, double& zmin, double& zmax) const; boolIsInside(double x, unsigned int icoord = 0) const; boolIsSet() const; unsigned intNDim() const; pair<double,double>operator()(unsigned int icoord = 0, unsigned int irange = 0) const; ROOT::Fit::DataRange&operator=(const ROOT::Fit::DataRange&); const ROOT::Fit::DataRange::RangeSet&Ranges(unsigned int icoord = 0) const; voidSetRange(double xmin, double xmax); voidSetRange(unsigned int icoord, double xmin, double xmax); voidSetRange(double xmin, double xmax, double ymin, double ymax); voidSetRange(double xmin, double xmax, double ymin, double ymax, double zmin, double zmax); unsigned intSize(unsigned int icoord = 0) const. protected:. voidCleanRangeSet(unsigned int icoord, double xmin, double xmax); static voidGetInfRange(double& x1, double& x2). Data Members; private:. ROOT::Fit::DataRange::RangeIntervalsfRangeslist of all ranges. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; explicit DataRange(unsigned int dim = 1). Default constructor (infinite range). {}. DataRange(double xmin, double xmax). construct a range for [xmin, xmax]. DataRange(double xmin, double xmax, double ymin, double ymax). construct a range for [xmin, xmax] , [ymin, ymax]. DataRange(double xmin, double xmax, double ymin, double ymax, double zmin, double zmax). construct a range for [xmin, xmax] , [ymin, ymax] , [zmin, zmax]. unsigned int NDim() const. get range dimension. { return fRanges.size(); }. unsigned int Size(unsigned int icoord = 0) const. return range size for coordinate icoord (starts from zero); Size == 0 indicates no range is present [-inf, + inf]. bool IsSet() const. return true if a range has been set in any of the coordinates; i.e. when it is not [-inf,+inf] for all coordinates; Avoid in case of multi-dim to loop on all the coordinated and ask the size. const RangeSet & Ranges(unsigned int icoord = 0) const. return the vec",MatchSource.WIKI,root/html532/ROOT__Fit__DataRange.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__DataRange.html
https://root.cern/root/html532/ROOT__Fit__DataRange.html:2511,Modifiability,Inherit,Inherited,2511,"max) const; voidGetRange(double& xmin, double& xmax, double& ymin, double& ymax, double& zmin, double& zmax) const; boolIsInside(double x, unsigned int icoord = 0) const; boolIsSet() const; unsigned intNDim() const; pair<double,double>operator()(unsigned int icoord = 0, unsigned int irange = 0) const; ROOT::Fit::DataRange&operator=(const ROOT::Fit::DataRange&); const ROOT::Fit::DataRange::RangeSet&Ranges(unsigned int icoord = 0) const; voidSetRange(double xmin, double xmax); voidSetRange(unsigned int icoord, double xmin, double xmax); voidSetRange(double xmin, double xmax, double ymin, double ymax); voidSetRange(double xmin, double xmax, double ymin, double ymax, double zmin, double zmax); unsigned intSize(unsigned int icoord = 0) const. protected:. voidCleanRangeSet(unsigned int icoord, double xmin, double xmax); static voidGetInfRange(double& x1, double& x2). Data Members; private:. ROOT::Fit::DataRange::RangeIntervalsfRangeslist of all ranges. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; explicit DataRange(unsigned int dim = 1). Default constructor (infinite range). {}. DataRange(double xmin, double xmax). construct a range for [xmin, xmax]. DataRange(double xmin, double xmax, double ymin, double ymax). construct a range for [xmin, xmax] , [ymin, ymax]. DataRange(double xmin, double xmax, double ymin, double ymax, double zmin, double zmax). construct a range for [xmin, xmax] , [ymin, ymax] , [zmin, zmax]. unsigned int NDim() const. get range dimension. { return fRanges.size(); }. unsigned int Size(unsigned int icoord = 0) const. return range size for coordinate icoord (starts from zero); Size == 0 indicates no range is present [-inf, + inf]. bool IsSet() const. return true if a range has been set in any of the coordinates; i.e. when it is not [-inf,+inf] for all coordinates; Avoid in case of multi-dim to loop on all the coordinated and ask the size. const RangeSet & Ranges(unsigned int icoord = 0) const. return the vec",MatchSource.WIKI,root/html532/ROOT__Fit__DataRange.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__DataRange.html
https://root.cern/root/html532/ROOT__Fit__DataRange.html:3378,Safety,Avoid,Avoid,3378," x2). Data Members; private:. ROOT::Fit::DataRange::RangeIntervalsfRangeslist of all ranges. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; explicit DataRange(unsigned int dim = 1). Default constructor (infinite range). {}. DataRange(double xmin, double xmax). construct a range for [xmin, xmax]. DataRange(double xmin, double xmax, double ymin, double ymax). construct a range for [xmin, xmax] , [ymin, ymax]. DataRange(double xmin, double xmax, double ymin, double ymax, double zmin, double zmax). construct a range for [xmin, xmax] , [ymin, ymax] , [zmin, zmax]. unsigned int NDim() const. get range dimension. { return fRanges.size(); }. unsigned int Size(unsigned int icoord = 0) const. return range size for coordinate icoord (starts from zero); Size == 0 indicates no range is present [-inf, + inf]. bool IsSet() const. return true if a range has been set in any of the coordinates; i.e. when it is not [-inf,+inf] for all coordinates; Avoid in case of multi-dim to loop on all the coordinated and ask the size. const RangeSet & Ranges(unsigned int icoord = 0) const. return the vector of ranges for the coordinate icoord. std::pair<double, double> operator()(unsigned int icoord = 0, unsigned int irange = 0) const. return the i-th range for the coordinate icoord.; Useful method when only one range is present for the given coordinate. void GetRange(unsigned int icoord, double& xmin, double& xmax) const. get the first range for given coordinate. If range does not exist; return -inf, +inf. void GetRange(double& xmin, double& xmax) const. get first range for the x - coordinate. { GetRange(0,xmin,xmax); }. void GetRange(double& xmin, double& xmax, double& ymin, double& ymax) const. get first range for the x and y coordinates. GetRange(0,xmin,xmax). void GetRange(double& xmin, double& xmax, double& ymin, double& ymax, double& zmin, double& zmax) const. get first range for the x and y and z coordinates. ~DataRange(). Destructor (no operatio",MatchSource.WIKI,root/html532/ROOT__Fit__DataRange.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__DataRange.html
https://root.cern/root/html532/ROOT__Fit__DataRange.html:6048,Usability,Clear,Clear,6048," a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate. { AddRange(0,xmin,xmax); AddRange(1,ymin,ymax); }. void AddRange(double xmin, double xmax, double ymin, double ymax, double zmin, double zmax). add a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate and; [zmin,zmax] for the third coordinate. void SetRange(unsigned int icoord, double xmin, double xmax). set a range [xmin,xmax] for the new coordinate icoord; If more range exists for other coordinates, delete the existing one and use it the new one; Use Add range if want to keep the union of the existing ranges. void SetRange(double xmin, double xmax). set a range [xmin,xmax] for the first coordinate icoord. { SetRange(0,xmin,xmax); }. void SetRange(double xmin, double xmax, double ymin, double ymax). set a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate. { SetRange(0,xmin,xmax); SetRange(1,ymin,ymax); }. void SetRange(double xmin, double xmax, double ymin, double ymax, double zmin, double zmax). set a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate and; [zmin,zmax] for the third coordinate. void Clear(unsigned int icoord = 0). clear all ranges in one coordinate (is now -inf, +inf). bool IsInside(double x, unsigned int icoord = 0) const. check if a point is inside the range for the given coordinate. void CleanRangeSet(unsigned int icoord, double xmin, double xmax). internal function to remove all the existing ranges between xmin and xmax; called when a new range is inserted. void GetInfRange(double& x1, double& x2); get the full range (-inf, +inf).  Author: L. Moneta Wed Aug 30 11:05:02 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: DataRange.h 36558 2010-11-09 15:13:13Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Fit__DataRange.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__DataRange.html
https://root.cern/root/html532/ROOT__Fit__DataRange.html:6080,Usability,clear,clear,6080," a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate. { AddRange(0,xmin,xmax); AddRange(1,ymin,ymax); }. void AddRange(double xmin, double xmax, double ymin, double ymax, double zmin, double zmax). add a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate and; [zmin,zmax] for the third coordinate. void SetRange(unsigned int icoord, double xmin, double xmax). set a range [xmin,xmax] for the new coordinate icoord; If more range exists for other coordinates, delete the existing one and use it the new one; Use Add range if want to keep the union of the existing ranges. void SetRange(double xmin, double xmax). set a range [xmin,xmax] for the first coordinate icoord. { SetRange(0,xmin,xmax); }. void SetRange(double xmin, double xmax, double ymin, double ymax). set a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate. { SetRange(0,xmin,xmax); SetRange(1,ymin,ymax); }. void SetRange(double xmin, double xmax, double ymin, double ymax, double zmin, double zmax). set a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate and; [zmin,zmax] for the third coordinate. void Clear(unsigned int icoord = 0). clear all ranges in one coordinate (is now -inf, +inf). bool IsInside(double x, unsigned int icoord = 0) const. check if a point is inside the range for the given coordinate. void CleanRangeSet(unsigned int icoord, double xmin, double xmax). internal function to remove all the existing ranges between xmin and xmax; called when a new range is inserted. void GetInfRange(double& x1, double& x2); get the full range (-inf, +inf).  Author: L. Moneta Wed Aug 30 11:05:02 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: DataRange.h 36558 2010-11-09 15:13:13Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Fit__DataRange.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__DataRange.html
https://root.cern/root/html532/ROOT__Fit__FitConfig.html:2104,Availability,error,error,2104,"gs&ParSettings(unsigned int i); static voidSetDefaultMinimizer(const char* type, const char* algo = 0); voidSetFromFitResult(const ROOT::Fit::FitResult& rhs); voidSetMinimizer(const char* type, const char* algo = 0); voidSetMinosErrors(bool on = true); voidSetMinosErrors(const vector<unsigned int>& paramInd); voidSetNormErrors(bool on = true); voidSetParabErrors(bool on = true); voidSetParamsSettings(const vector<ROOT::Fit::ParameterSettings>& pars); voidSetParamsSettings(unsigned int npar, const double* params, const double* vstep = 0); voidSetUpdateAfterFit(bool on = true); voidSetWeightCorrection(bool on = true); boolUpdateAfterFit() const; boolUseWeightCorrection() const. Data Members; private:. ROOT::Math::MinimizerOptionsfMinimizerOptsminimizer control parameters including name and algo type; boolfMinosErrorsdo full error analysis using Minos; vector<unsigned int>fMinosParamsvector with the parameter indeces for running Minos; boolfNormErrorsflag for error normalization; boolfParabErrorsget correct parabolic errors estimate (call Hesse after minimizing) ; vector<ROOT::Fit::ParameterSettings>fSettingsvector with the parameter settings; boolfUpdateAfterFitupdate the configuration after a fit using the result; boolfWeightCorrapply correction to errors for weights fits . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitConfig(unsigned int npar = 0). Default constructor. FitConfig(const ROOT::Fit::FitConfig& rhs). Copy constructor. ~FitConfig(). Destructor. FitConfig & operator=(const ROOT::Fit::FitConfig& rhs). Assignment operator. const ParameterSettings & ParSettings(unsigned int i) const. get the parameter settings for the i-th parameter (const method). { return fSettings.at(i); }. ParameterSettings & ParSettings(unsigned int i). get the parameter settings for the i-th parameter (non-const method). { return fSettings.at(i); }. const std::vector<ROOT::Fit::ParameterSettings> & ParamsSettings() const. get the vector of ",MatchSource.WIKI,root/html532/ROOT__Fit__FitConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitConfig.html
https://root.cern/root/html532/ROOT__Fit__FitConfig.html:2241,Availability,error,error,2241,"gs&ParSettings(unsigned int i); static voidSetDefaultMinimizer(const char* type, const char* algo = 0); voidSetFromFitResult(const ROOT::Fit::FitResult& rhs); voidSetMinimizer(const char* type, const char* algo = 0); voidSetMinosErrors(bool on = true); voidSetMinosErrors(const vector<unsigned int>& paramInd); voidSetNormErrors(bool on = true); voidSetParabErrors(bool on = true); voidSetParamsSettings(const vector<ROOT::Fit::ParameterSettings>& pars); voidSetParamsSettings(unsigned int npar, const double* params, const double* vstep = 0); voidSetUpdateAfterFit(bool on = true); voidSetWeightCorrection(bool on = true); boolUpdateAfterFit() const; boolUseWeightCorrection() const. Data Members; private:. ROOT::Math::MinimizerOptionsfMinimizerOptsminimizer control parameters including name and algo type; boolfMinosErrorsdo full error analysis using Minos; vector<unsigned int>fMinosParamsvector with the parameter indeces for running Minos; boolfNormErrorsflag for error normalization; boolfParabErrorsget correct parabolic errors estimate (call Hesse after minimizing) ; vector<ROOT::Fit::ParameterSettings>fSettingsvector with the parameter settings; boolfUpdateAfterFitupdate the configuration after a fit using the result; boolfWeightCorrapply correction to errors for weights fits . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitConfig(unsigned int npar = 0). Default constructor. FitConfig(const ROOT::Fit::FitConfig& rhs). Copy constructor. ~FitConfig(). Destructor. FitConfig & operator=(const ROOT::Fit::FitConfig& rhs). Assignment operator. const ParameterSettings & ParSettings(unsigned int i) const. get the parameter settings for the i-th parameter (const method). { return fSettings.at(i); }. ParameterSettings & ParSettings(unsigned int i). get the parameter settings for the i-th parameter (non-const method). { return fSettings.at(i); }. const std::vector<ROOT::Fit::ParameterSettings> & ParamsSettings() const. get the vector of ",MatchSource.WIKI,root/html532/ROOT__Fit__FitConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitConfig.html
https://root.cern/root/html532/ROOT__Fit__FitConfig.html:2300,Availability,error,errors,2300,"gs&ParSettings(unsigned int i); static voidSetDefaultMinimizer(const char* type, const char* algo = 0); voidSetFromFitResult(const ROOT::Fit::FitResult& rhs); voidSetMinimizer(const char* type, const char* algo = 0); voidSetMinosErrors(bool on = true); voidSetMinosErrors(const vector<unsigned int>& paramInd); voidSetNormErrors(bool on = true); voidSetParabErrors(bool on = true); voidSetParamsSettings(const vector<ROOT::Fit::ParameterSettings>& pars); voidSetParamsSettings(unsigned int npar, const double* params, const double* vstep = 0); voidSetUpdateAfterFit(bool on = true); voidSetWeightCorrection(bool on = true); boolUpdateAfterFit() const; boolUseWeightCorrection() const. Data Members; private:. ROOT::Math::MinimizerOptionsfMinimizerOptsminimizer control parameters including name and algo type; boolfMinosErrorsdo full error analysis using Minos; vector<unsigned int>fMinosParamsvector with the parameter indeces for running Minos; boolfNormErrorsflag for error normalization; boolfParabErrorsget correct parabolic errors estimate (call Hesse after minimizing) ; vector<ROOT::Fit::ParameterSettings>fSettingsvector with the parameter settings; boolfUpdateAfterFitupdate the configuration after a fit using the result; boolfWeightCorrapply correction to errors for weights fits . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitConfig(unsigned int npar = 0). Default constructor. FitConfig(const ROOT::Fit::FitConfig& rhs). Copy constructor. ~FitConfig(). Destructor. FitConfig & operator=(const ROOT::Fit::FitConfig& rhs). Assignment operator. const ParameterSettings & ParSettings(unsigned int i) const. get the parameter settings for the i-th parameter (const method). { return fSettings.at(i); }. ParameterSettings & ParSettings(unsigned int i). get the parameter settings for the i-th parameter (non-const method). { return fSettings.at(i); }. const std::vector<ROOT::Fit::ParameterSettings> & ParamsSettings() const. get the vector of ",MatchSource.WIKI,root/html532/ROOT__Fit__FitConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitConfig.html
https://root.cern/root/html532/ROOT__Fit__FitConfig.html:2538,Availability,error,errors,2538,"gs&ParSettings(unsigned int i); static voidSetDefaultMinimizer(const char* type, const char* algo = 0); voidSetFromFitResult(const ROOT::Fit::FitResult& rhs); voidSetMinimizer(const char* type, const char* algo = 0); voidSetMinosErrors(bool on = true); voidSetMinosErrors(const vector<unsigned int>& paramInd); voidSetNormErrors(bool on = true); voidSetParabErrors(bool on = true); voidSetParamsSettings(const vector<ROOT::Fit::ParameterSettings>& pars); voidSetParamsSettings(unsigned int npar, const double* params, const double* vstep = 0); voidSetUpdateAfterFit(bool on = true); voidSetWeightCorrection(bool on = true); boolUpdateAfterFit() const; boolUseWeightCorrection() const. Data Members; private:. ROOT::Math::MinimizerOptionsfMinimizerOptsminimizer control parameters including name and algo type; boolfMinosErrorsdo full error analysis using Minos; vector<unsigned int>fMinosParamsvector with the parameter indeces for running Minos; boolfNormErrorsflag for error normalization; boolfParabErrorsget correct parabolic errors estimate (call Hesse after minimizing) ; vector<ROOT::Fit::ParameterSettings>fSettingsvector with the parameter settings; boolfUpdateAfterFitupdate the configuration after a fit using the result; boolfWeightCorrapply correction to errors for weights fits . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitConfig(unsigned int npar = 0). Default constructor. FitConfig(const ROOT::Fit::FitConfig& rhs). Copy constructor. ~FitConfig(). Destructor. FitConfig & operator=(const ROOT::Fit::FitConfig& rhs). Assignment operator. const ParameterSettings & ParSettings(unsigned int i) const. get the parameter settings for the i-th parameter (const method). { return fSettings.at(i); }. ParameterSettings & ParSettings(unsigned int i). get the parameter settings for the i-th parameter (non-const method). { return fSettings.at(i); }. const std::vector<ROOT::Fit::ParameterSettings> & ParamsSettings() const. get the vector of ",MatchSource.WIKI,root/html532/ROOT__Fit__FitConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitConfig.html
https://root.cern/root/html532/ROOT__Fit__FitConfig.html:4793,Availability,error,errors,4793,"uble* params, const double* vstep = 0). set the parameter settings from number of parameters and a vector of values and optionally step values. If there are not existing or number of parameters does not match existing one, create a new parameter setting list. void SetParamsSettings(const vector<ROOT::Fit::ParameterSettings>& pars). Set the parameter settings from a vector of parameter settings. void SetFromFitResult(const ROOT::Fit::FitResult& rhs). Set the parameter settings from a fit Result. ROOT::Math::Minimizer * CreateMinimizer(). create a new minimizer according to chosen configuration. void SetMinimizer(const char* type, const char* algo = 0). set minimizer type. const std::string & MinimizerType() const. return type of minimizer package. { return fMinimizerOpts.MinimizerType(); }. const std::string & MinimizerAlgoType() const. return type of minimizer algorithms. { return fMinimizerOpts.MinimizerAlgorithm(); }. bool NormalizeErrors() const. flag to check if resulting errors are be normalized according to chi2/ndf. { return fNormErrors; }. bool ParabErrors() const; do analysis for parabolic errors. { return fParabErrors; }. bool MinosErrors() const; do minos errros analysis on the parameters. { return fMinosErrors; }. bool UpdateAfterFit() const; Update configuration after a fit using the FitResult. { return fUpdateAfterFit; }. bool UseWeightCorrection() const; Apply Weight correction for error matrix computation. { return fWeightCorr; }. const std::vector<unsigned int> & MinosParams() const; return vector of parameter indeces for which the Minos Error will be computed. { return fMinosParams; }. void SetNormErrors(bool on = true). set the option to normalize the error on the result according to chi2/ndf. { fNormErrors= on; }. void SetParabErrors(bool on = true); set parabolic erros. { fParabErrors = on; }. void SetMinosErrors(bool on = true); set Minos erros. { fMinosErrors = on; }. void SetWeightCorrection(bool on = true); apply the weight correction for err",MatchSource.WIKI,root/html532/ROOT__Fit__FitConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitConfig.html
https://root.cern/root/html532/ROOT__Fit__FitConfig.html:4918,Availability,error,errors,4918,"and a vector of values and optionally step values. If there are not existing or number of parameters does not match existing one, create a new parameter setting list. void SetParamsSettings(const vector<ROOT::Fit::ParameterSettings>& pars). Set the parameter settings from a vector of parameter settings. void SetFromFitResult(const ROOT::Fit::FitResult& rhs). Set the parameter settings from a fit Result. ROOT::Math::Minimizer * CreateMinimizer(). create a new minimizer according to chosen configuration. void SetMinimizer(const char* type, const char* algo = 0). set minimizer type. const std::string & MinimizerType() const. return type of minimizer package. { return fMinimizerOpts.MinimizerType(); }. const std::string & MinimizerAlgoType() const. return type of minimizer algorithms. { return fMinimizerOpts.MinimizerAlgorithm(); }. bool NormalizeErrors() const. flag to check if resulting errors are be normalized according to chi2/ndf. { return fNormErrors; }. bool ParabErrors() const; do analysis for parabolic errors. { return fParabErrors; }. bool MinosErrors() const; do minos errros analysis on the parameters. { return fMinosErrors; }. bool UpdateAfterFit() const; Update configuration after a fit using the FitResult. { return fUpdateAfterFit; }. bool UseWeightCorrection() const; Apply Weight correction for error matrix computation. { return fWeightCorr; }. const std::vector<unsigned int> & MinosParams() const; return vector of parameter indeces for which the Minos Error will be computed. { return fMinosParams; }. void SetNormErrors(bool on = true). set the option to normalize the error on the result according to chi2/ndf. { fNormErrors= on; }. void SetParabErrors(bool on = true); set parabolic erros. { fParabErrors = on; }. void SetMinosErrors(bool on = true); set Minos erros. { fMinosErrors = on; }. void SetWeightCorrection(bool on = true); apply the weight correction for error matric computation. { fWeightCorr = on; }. void SetMinosErrors(const vector<unsigned int>",MatchSource.WIKI,root/html532/ROOT__Fit__FitConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitConfig.html
https://root.cern/root/html532/ROOT__Fit__FitConfig.html:5222,Availability,error,error,5222,"d SetFromFitResult(const ROOT::Fit::FitResult& rhs). Set the parameter settings from a fit Result. ROOT::Math::Minimizer * CreateMinimizer(). create a new minimizer according to chosen configuration. void SetMinimizer(const char* type, const char* algo = 0). set minimizer type. const std::string & MinimizerType() const. return type of minimizer package. { return fMinimizerOpts.MinimizerType(); }. const std::string & MinimizerAlgoType() const. return type of minimizer algorithms. { return fMinimizerOpts.MinimizerAlgorithm(); }. bool NormalizeErrors() const. flag to check if resulting errors are be normalized according to chi2/ndf. { return fNormErrors; }. bool ParabErrors() const; do analysis for parabolic errors. { return fParabErrors; }. bool MinosErrors() const; do minos errros analysis on the parameters. { return fMinosErrors; }. bool UpdateAfterFit() const; Update configuration after a fit using the FitResult. { return fUpdateAfterFit; }. bool UseWeightCorrection() const; Apply Weight correction for error matrix computation. { return fWeightCorr; }. const std::vector<unsigned int> & MinosParams() const; return vector of parameter indeces for which the Minos Error will be computed. { return fMinosParams; }. void SetNormErrors(bool on = true). set the option to normalize the error on the result according to chi2/ndf. { fNormErrors= on; }. void SetParabErrors(bool on = true); set parabolic erros. { fParabErrors = on; }. void SetMinosErrors(bool on = true); set Minos erros. { fMinosErrors = on; }. void SetWeightCorrection(bool on = true); apply the weight correction for error matric computation. { fWeightCorr = on; }. void SetMinosErrors(const vector<unsigned int>& paramInd); set parameter indeces for running Minos; this can be used for running Minos on a subset of parameters - otherwise is run on all of them; if MinosErrors() is set. void SetUpdateAfterFit(bool on = true); Update configuration after a fit using the FitResult. { fUpdateAfterFit = on; }. void SetDefa",MatchSource.WIKI,root/html532/ROOT__Fit__FitConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitConfig.html
https://root.cern/root/html532/ROOT__Fit__FitConfig.html:5383,Availability,Error,Error,5383,"er(). create a new minimizer according to chosen configuration. void SetMinimizer(const char* type, const char* algo = 0). set minimizer type. const std::string & MinimizerType() const. return type of minimizer package. { return fMinimizerOpts.MinimizerType(); }. const std::string & MinimizerAlgoType() const. return type of minimizer algorithms. { return fMinimizerOpts.MinimizerAlgorithm(); }. bool NormalizeErrors() const. flag to check if resulting errors are be normalized according to chi2/ndf. { return fNormErrors; }. bool ParabErrors() const; do analysis for parabolic errors. { return fParabErrors; }. bool MinosErrors() const; do minos errros analysis on the parameters. { return fMinosErrors; }. bool UpdateAfterFit() const; Update configuration after a fit using the FitResult. { return fUpdateAfterFit; }. bool UseWeightCorrection() const; Apply Weight correction for error matrix computation. { return fWeightCorr; }. const std::vector<unsigned int> & MinosParams() const; return vector of parameter indeces for which the Minos Error will be computed. { return fMinosParams; }. void SetNormErrors(bool on = true). set the option to normalize the error on the result according to chi2/ndf. { fNormErrors= on; }. void SetParabErrors(bool on = true); set parabolic erros. { fParabErrors = on; }. void SetMinosErrors(bool on = true); set Minos erros. { fMinosErrors = on; }. void SetWeightCorrection(bool on = true); apply the weight correction for error matric computation. { fWeightCorr = on; }. void SetMinosErrors(const vector<unsigned int>& paramInd); set parameter indeces for running Minos; this can be used for running Minos on a subset of parameters - otherwise is run on all of them; if MinosErrors() is set. void SetUpdateAfterFit(bool on = true); Update configuration after a fit using the FitResult. { fUpdateAfterFit = on; }. void SetDefaultMinimizer(const char* type, const char* algo = 0). static function to control default minimizer type and algorithm.  Author: L. Mone",MatchSource.WIKI,root/html532/ROOT__Fit__FitConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitConfig.html
https://root.cern/root/html532/ROOT__Fit__FitConfig.html:5501,Availability,error,error,5501,"imizerType() const. return type of minimizer package. { return fMinimizerOpts.MinimizerType(); }. const std::string & MinimizerAlgoType() const. return type of minimizer algorithms. { return fMinimizerOpts.MinimizerAlgorithm(); }. bool NormalizeErrors() const. flag to check if resulting errors are be normalized according to chi2/ndf. { return fNormErrors; }. bool ParabErrors() const; do analysis for parabolic errors. { return fParabErrors; }. bool MinosErrors() const; do minos errros analysis on the parameters. { return fMinosErrors; }. bool UpdateAfterFit() const; Update configuration after a fit using the FitResult. { return fUpdateAfterFit; }. bool UseWeightCorrection() const; Apply Weight correction for error matrix computation. { return fWeightCorr; }. const std::vector<unsigned int> & MinosParams() const; return vector of parameter indeces for which the Minos Error will be computed. { return fMinosParams; }. void SetNormErrors(bool on = true). set the option to normalize the error on the result according to chi2/ndf. { fNormErrors= on; }. void SetParabErrors(bool on = true); set parabolic erros. { fParabErrors = on; }. void SetMinosErrors(bool on = true); set Minos erros. { fMinosErrors = on; }. void SetWeightCorrection(bool on = true); apply the weight correction for error matric computation. { fWeightCorr = on; }. void SetMinosErrors(const vector<unsigned int>& paramInd); set parameter indeces for running Minos; this can be used for running Minos on a subset of parameters - otherwise is run on all of them; if MinosErrors() is set. void SetUpdateAfterFit(bool on = true); Update configuration after a fit using the FitResult. { fUpdateAfterFit = on; }. void SetDefaultMinimizer(const char* type, const char* algo = 0). static function to control default minimizer type and algorithm.  Author: L. Moneta Thu Sep 21 16:21:29 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: FitConfig.h 42007 2011-11-15 13:23:17Z moneta $ ",MatchSource.WIKI,root/html532/ROOT__Fit__FitConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitConfig.html
https://root.cern/root/html532/ROOT__Fit__FitConfig.html:5800,Availability,error,error,5800,"MinimizerOpts.MinimizerAlgorithm(); }. bool NormalizeErrors() const. flag to check if resulting errors are be normalized according to chi2/ndf. { return fNormErrors; }. bool ParabErrors() const; do analysis for parabolic errors. { return fParabErrors; }. bool MinosErrors() const; do minos errros analysis on the parameters. { return fMinosErrors; }. bool UpdateAfterFit() const; Update configuration after a fit using the FitResult. { return fUpdateAfterFit; }. bool UseWeightCorrection() const; Apply Weight correction for error matrix computation. { return fWeightCorr; }. const std::vector<unsigned int> & MinosParams() const; return vector of parameter indeces for which the Minos Error will be computed. { return fMinosParams; }. void SetNormErrors(bool on = true). set the option to normalize the error on the result according to chi2/ndf. { fNormErrors= on; }. void SetParabErrors(bool on = true); set parabolic erros. { fParabErrors = on; }. void SetMinosErrors(bool on = true); set Minos erros. { fMinosErrors = on; }. void SetWeightCorrection(bool on = true); apply the weight correction for error matric computation. { fWeightCorr = on; }. void SetMinosErrors(const vector<unsigned int>& paramInd); set parameter indeces for running Minos; this can be used for running Minos on a subset of parameters - otherwise is run on all of them; if MinosErrors() is set. void SetUpdateAfterFit(bool on = true); Update configuration after a fit using the FitResult. { fUpdateAfterFit = on; }. void SetDefaultMinimizer(const char* type, const char* algo = 0). static function to control default minimizer type and algorithm.  Author: L. Moneta Thu Sep 21 16:21:29 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: FitConfig.h 42007 2011-11-15 13:23:17Z moneta $  Last generated: 2011-12-02 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Fit__FitConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitConfig.html
https://root.cern/root/html532/ROOT__Fit__FitConfig.html:306,Deployability,configurat,configuration,306,". ROOT::Fit::FitConfig. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::FitConfig. class ROOT::Fit::FitConfig. Class describing the configuration of the fit, options and parameter settings; using the ROOT::Fit::ParameterSettings class. @ingroup FitMain. Function Members (Methods); public:. ~FitConfig(); ROOT::Math::Minimizer*CreateMinimizer(); voidCreateParamsSettings(const ROOT::Math::IParamMultiFunction& func); ROOT::Fit::FitConfigFitConfig(unsigned int npar = 0); ROOT::Fit::FitConfigFitConfig(const ROOT::Fit::FitConfig& rhs); const string&MinimizerAlgoType() const; ROOT::Math::MinimizerOptions&MinimizerOptions(); const string&MinimizerType() const; boolMinosErrors() const; const vector<unsigned int>&MinosParams() const; boolNormalizeErrors() const; unsigned intNPar() const; ROOT::Fit::FitConfig&operator=(const ROOT::Fit::FitConfig& rhs); boolParabErrors() const; const vector<ROOT::Fit::ParameterSettings>&ParamsSettings() const; vector<ROOT::Fit::ParameterSettings>&ParamsSettings(); const ROOT::Fit::ParameterSettings&ParSettings(unsigned int i) const; ROOT::Fit::ParameterSettings&ParSettings(unsigned int i); static voidSetDefaultMinimizer(const char* type, const char* algo = 0); voidSetFromFitResult(const ROOT::Fit::FitResult& rhs); voidSetMinimizer(const char* type, const char* algo = 0); voidSetMinosErrors(bool on = true); voidSetMinosErrors(const vector<unsigned int>& paramInd); voidSetNormErrors(bool on = true); voidSetParabErrors(bool on = true); voidSetParamsSettings(const vector<ROOT::Fit::ParameterSettings>& pars); voidSetParamsSettings(unsigned int npar, const double* params, const double* vstep = 0); voidSetUpdateAfterFit(bool on = true); voidSetWeightCorrection(bool on = true); boolUpdateAfterFit() const; boolUseWeightCorrection() const. Data Members; private:. ROOT::Math::MinimizerO",MatchSource.WIKI,root/html532/ROOT__Fit__FitConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitConfig.html
https://root.cern/root/html532/ROOT__Fit__FitConfig.html:2459,Deployability,configurat,configuration,2459,"gs&ParSettings(unsigned int i); static voidSetDefaultMinimizer(const char* type, const char* algo = 0); voidSetFromFitResult(const ROOT::Fit::FitResult& rhs); voidSetMinimizer(const char* type, const char* algo = 0); voidSetMinosErrors(bool on = true); voidSetMinosErrors(const vector<unsigned int>& paramInd); voidSetNormErrors(bool on = true); voidSetParabErrors(bool on = true); voidSetParamsSettings(const vector<ROOT::Fit::ParameterSettings>& pars); voidSetParamsSettings(unsigned int npar, const double* params, const double* vstep = 0); voidSetUpdateAfterFit(bool on = true); voidSetWeightCorrection(bool on = true); boolUpdateAfterFit() const; boolUseWeightCorrection() const. Data Members; private:. ROOT::Math::MinimizerOptionsfMinimizerOptsminimizer control parameters including name and algo type; boolfMinosErrorsdo full error analysis using Minos; vector<unsigned int>fMinosParamsvector with the parameter indeces for running Minos; boolfNormErrorsflag for error normalization; boolfParabErrorsget correct parabolic errors estimate (call Hesse after minimizing) ; vector<ROOT::Fit::ParameterSettings>fSettingsvector with the parameter settings; boolfUpdateAfterFitupdate the configuration after a fit using the result; boolfWeightCorrapply correction to errors for weights fits . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitConfig(unsigned int npar = 0). Default constructor. FitConfig(const ROOT::Fit::FitConfig& rhs). Copy constructor. ~FitConfig(). Destructor. FitConfig & operator=(const ROOT::Fit::FitConfig& rhs). Assignment operator. const ParameterSettings & ParSettings(unsigned int i) const. get the parameter settings for the i-th parameter (const method). { return fSettings.at(i); }. ParameterSettings & ParSettings(unsigned int i). get the parameter settings for the i-th parameter (non-const method). { return fSettings.at(i); }. const std::vector<ROOT::Fit::ParameterSettings> & ParamsSettings() const. get the vector of ",MatchSource.WIKI,root/html532/ROOT__Fit__FitConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitConfig.html
https://root.cern/root/html532/ROOT__Fit__FitConfig.html:4388,Deployability,configurat,configuration,4388,"ParamsSettings(). get the vector of parameter settings (non-const method). { return fSettings; }. unsigned int NPar() const. number of parameters settings. { return fSettings.size(); }. void CreateParamsSettings(const ROOT::Math::IParamMultiFunction& func). set the parameter settings from a model function.; Create always new parameter setting list from a given model function. void SetParamsSettings(unsigned int npar, const double* params, const double* vstep = 0). set the parameter settings from number of parameters and a vector of values and optionally step values. If there are not existing or number of parameters does not match existing one, create a new parameter setting list. void SetParamsSettings(const vector<ROOT::Fit::ParameterSettings>& pars). Set the parameter settings from a vector of parameter settings. void SetFromFitResult(const ROOT::Fit::FitResult& rhs). Set the parameter settings from a fit Result. ROOT::Math::Minimizer * CreateMinimizer(). create a new minimizer according to chosen configuration. void SetMinimizer(const char* type, const char* algo = 0). set minimizer type. const std::string & MinimizerType() const. return type of minimizer package. { return fMinimizerOpts.MinimizerType(); }. const std::string & MinimizerAlgoType() const. return type of minimizer algorithms. { return fMinimizerOpts.MinimizerAlgorithm(); }. bool NormalizeErrors() const. flag to check if resulting errors are be normalized according to chi2/ndf. { return fNormErrors; }. bool ParabErrors() const; do analysis for parabolic errors. { return fParabErrors; }. bool MinosErrors() const; do minos errros analysis on the parameters. { return fMinosErrors; }. bool UpdateAfterFit() const; Update configuration after a fit using the FitResult. { return fUpdateAfterFit; }. bool UseWeightCorrection() const; Apply Weight correction for error matrix computation. { return fWeightCorr; }. const std::vector<unsigned int> & MinosParams() const; return vector of parameter indeces for which ",MatchSource.WIKI,root/html532/ROOT__Fit__FitConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitConfig.html
https://root.cern/root/html532/ROOT__Fit__FitConfig.html:5053,Deployability,Update,UpdateAfterFit,5053,"st vector<ROOT::Fit::ParameterSettings>& pars). Set the parameter settings from a vector of parameter settings. void SetFromFitResult(const ROOT::Fit::FitResult& rhs). Set the parameter settings from a fit Result. ROOT::Math::Minimizer * CreateMinimizer(). create a new minimizer according to chosen configuration. void SetMinimizer(const char* type, const char* algo = 0). set minimizer type. const std::string & MinimizerType() const. return type of minimizer package. { return fMinimizerOpts.MinimizerType(); }. const std::string & MinimizerAlgoType() const. return type of minimizer algorithms. { return fMinimizerOpts.MinimizerAlgorithm(); }. bool NormalizeErrors() const. flag to check if resulting errors are be normalized according to chi2/ndf. { return fNormErrors; }. bool ParabErrors() const; do analysis for parabolic errors. { return fParabErrors; }. bool MinosErrors() const; do minos errros analysis on the parameters. { return fMinosErrors; }. bool UpdateAfterFit() const; Update configuration after a fit using the FitResult. { return fUpdateAfterFit; }. bool UseWeightCorrection() const; Apply Weight correction for error matrix computation. { return fWeightCorr; }. const std::vector<unsigned int> & MinosParams() const; return vector of parameter indeces for which the Minos Error will be computed. { return fMinosParams; }. void SetNormErrors(bool on = true). set the option to normalize the error on the result according to chi2/ndf. { fNormErrors= on; }. void SetParabErrors(bool on = true); set parabolic erros. { fParabErrors = on; }. void SetMinosErrors(bool on = true); set Minos erros. { fMinosErrors = on; }. void SetWeightCorrection(bool on = true); apply the weight correction for error matric computation. { fWeightCorr = on; }. void SetMinosErrors(const vector<unsigned int>& paramInd); set parameter indeces for running Minos; this can be used for running Minos on a subset of parameters - otherwise is run on all of them; if MinosErrors() is set. void SetUpdateAfter",MatchSource.WIKI,root/html532/ROOT__Fit__FitConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitConfig.html
https://root.cern/root/html532/ROOT__Fit__FitConfig.html:5077,Deployability,Update,Update,5077,"st vector<ROOT::Fit::ParameterSettings>& pars). Set the parameter settings from a vector of parameter settings. void SetFromFitResult(const ROOT::Fit::FitResult& rhs). Set the parameter settings from a fit Result. ROOT::Math::Minimizer * CreateMinimizer(). create a new minimizer according to chosen configuration. void SetMinimizer(const char* type, const char* algo = 0). set minimizer type. const std::string & MinimizerType() const. return type of minimizer package. { return fMinimizerOpts.MinimizerType(); }. const std::string & MinimizerAlgoType() const. return type of minimizer algorithms. { return fMinimizerOpts.MinimizerAlgorithm(); }. bool NormalizeErrors() const. flag to check if resulting errors are be normalized according to chi2/ndf. { return fNormErrors; }. bool ParabErrors() const; do analysis for parabolic errors. { return fParabErrors; }. bool MinosErrors() const; do minos errros analysis on the parameters. { return fMinosErrors; }. bool UpdateAfterFit() const; Update configuration after a fit using the FitResult. { return fUpdateAfterFit; }. bool UseWeightCorrection() const; Apply Weight correction for error matrix computation. { return fWeightCorr; }. const std::vector<unsigned int> & MinosParams() const; return vector of parameter indeces for which the Minos Error will be computed. { return fMinosParams; }. void SetNormErrors(bool on = true). set the option to normalize the error on the result according to chi2/ndf. { fNormErrors= on; }. void SetParabErrors(bool on = true); set parabolic erros. { fParabErrors = on; }. void SetMinosErrors(bool on = true); set Minos erros. { fMinosErrors = on; }. void SetWeightCorrection(bool on = true); apply the weight correction for error matric computation. { fWeightCorr = on; }. void SetMinosErrors(const vector<unsigned int>& paramInd); set parameter indeces for running Minos; this can be used for running Minos on a subset of parameters - otherwise is run on all of them; if MinosErrors() is set. void SetUpdateAfter",MatchSource.WIKI,root/html532/ROOT__Fit__FitConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitConfig.html
https://root.cern/root/html532/ROOT__Fit__FitConfig.html:5084,Deployability,configurat,configuration,5084,"st vector<ROOT::Fit::ParameterSettings>& pars). Set the parameter settings from a vector of parameter settings. void SetFromFitResult(const ROOT::Fit::FitResult& rhs). Set the parameter settings from a fit Result. ROOT::Math::Minimizer * CreateMinimizer(). create a new minimizer according to chosen configuration. void SetMinimizer(const char* type, const char* algo = 0). set minimizer type. const std::string & MinimizerType() const. return type of minimizer package. { return fMinimizerOpts.MinimizerType(); }. const std::string & MinimizerAlgoType() const. return type of minimizer algorithms. { return fMinimizerOpts.MinimizerAlgorithm(); }. bool NormalizeErrors() const. flag to check if resulting errors are be normalized according to chi2/ndf. { return fNormErrors; }. bool ParabErrors() const; do analysis for parabolic errors. { return fParabErrors; }. bool MinosErrors() const; do minos errros analysis on the parameters. { return fMinosErrors; }. bool UpdateAfterFit() const; Update configuration after a fit using the FitResult. { return fUpdateAfterFit; }. bool UseWeightCorrection() const; Apply Weight correction for error matrix computation. { return fWeightCorr; }. const std::vector<unsigned int> & MinosParams() const; return vector of parameter indeces for which the Minos Error will be computed. { return fMinosParams; }. void SetNormErrors(bool on = true). set the option to normalize the error on the result according to chi2/ndf. { fNormErrors= on; }. void SetParabErrors(bool on = true); set parabolic erros. { fParabErrors = on; }. void SetMinosErrors(bool on = true); set Minos erros. { fMinosErrors = on; }. void SetWeightCorrection(bool on = true); apply the weight correction for error matric computation. { fWeightCorr = on; }. void SetMinosErrors(const vector<unsigned int>& paramInd); set parameter indeces for running Minos; this can be used for running Minos on a subset of parameters - otherwise is run on all of them; if MinosErrors() is set. void SetUpdateAfter",MatchSource.WIKI,root/html532/ROOT__Fit__FitConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitConfig.html
https://root.cern/root/html532/ROOT__Fit__FitConfig.html:6110,Deployability,Update,Update,6110,"MinimizerOpts.MinimizerAlgorithm(); }. bool NormalizeErrors() const. flag to check if resulting errors are be normalized according to chi2/ndf. { return fNormErrors; }. bool ParabErrors() const; do analysis for parabolic errors. { return fParabErrors; }. bool MinosErrors() const; do minos errros analysis on the parameters. { return fMinosErrors; }. bool UpdateAfterFit() const; Update configuration after a fit using the FitResult. { return fUpdateAfterFit; }. bool UseWeightCorrection() const; Apply Weight correction for error matrix computation. { return fWeightCorr; }. const std::vector<unsigned int> & MinosParams() const; return vector of parameter indeces for which the Minos Error will be computed. { return fMinosParams; }. void SetNormErrors(bool on = true). set the option to normalize the error on the result according to chi2/ndf. { fNormErrors= on; }. void SetParabErrors(bool on = true); set parabolic erros. { fParabErrors = on; }. void SetMinosErrors(bool on = true); set Minos erros. { fMinosErrors = on; }. void SetWeightCorrection(bool on = true); apply the weight correction for error matric computation. { fWeightCorr = on; }. void SetMinosErrors(const vector<unsigned int>& paramInd); set parameter indeces for running Minos; this can be used for running Minos on a subset of parameters - otherwise is run on all of them; if MinosErrors() is set. void SetUpdateAfterFit(bool on = true); Update configuration after a fit using the FitResult. { fUpdateAfterFit = on; }. void SetDefaultMinimizer(const char* type, const char* algo = 0). static function to control default minimizer type and algorithm.  Author: L. Moneta Thu Sep 21 16:21:29 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: FitConfig.h 42007 2011-11-15 13:23:17Z moneta $  Last generated: 2011-12-02 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Fit__FitConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitConfig.html
https://root.cern/root/html532/ROOT__Fit__FitConfig.html:6117,Deployability,configurat,configuration,6117,"MinimizerOpts.MinimizerAlgorithm(); }. bool NormalizeErrors() const. flag to check if resulting errors are be normalized according to chi2/ndf. { return fNormErrors; }. bool ParabErrors() const; do analysis for parabolic errors. { return fParabErrors; }. bool MinosErrors() const; do minos errros analysis on the parameters. { return fMinosErrors; }. bool UpdateAfterFit() const; Update configuration after a fit using the FitResult. { return fUpdateAfterFit; }. bool UseWeightCorrection() const; Apply Weight correction for error matrix computation. { return fWeightCorr; }. const std::vector<unsigned int> & MinosParams() const; return vector of parameter indeces for which the Minos Error will be computed. { return fMinosParams; }. void SetNormErrors(bool on = true). set the option to normalize the error on the result according to chi2/ndf. { fNormErrors= on; }. void SetParabErrors(bool on = true); set parabolic erros. { fParabErrors = on; }. void SetMinosErrors(bool on = true); set Minos erros. { fMinosErrors = on; }. void SetWeightCorrection(bool on = true); apply the weight correction for error matric computation. { fWeightCorr = on; }. void SetMinosErrors(const vector<unsigned int>& paramInd); set parameter indeces for running Minos; this can be used for running Minos on a subset of parameters - otherwise is run on all of them; if MinosErrors() is set. void SetUpdateAfterFit(bool on = true); Update configuration after a fit using the FitResult. { fUpdateAfterFit = on; }. void SetDefaultMinimizer(const char* type, const char* algo = 0). static function to control default minimizer type and algorithm.  Author: L. Moneta Thu Sep 21 16:21:29 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: FitConfig.h 42007 2011-11-15 13:23:17Z moneta $  Last generated: 2011-12-02 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Fit__FitConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitConfig.html
https://root.cern/root/html532/ROOT__Fit__FitConfig.html:306,Modifiability,config,configuration,306,". ROOT::Fit::FitConfig. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::FitConfig. class ROOT::Fit::FitConfig. Class describing the configuration of the fit, options and parameter settings; using the ROOT::Fit::ParameterSettings class. @ingroup FitMain. Function Members (Methods); public:. ~FitConfig(); ROOT::Math::Minimizer*CreateMinimizer(); voidCreateParamsSettings(const ROOT::Math::IParamMultiFunction& func); ROOT::Fit::FitConfigFitConfig(unsigned int npar = 0); ROOT::Fit::FitConfigFitConfig(const ROOT::Fit::FitConfig& rhs); const string&MinimizerAlgoType() const; ROOT::Math::MinimizerOptions&MinimizerOptions(); const string&MinimizerType() const; boolMinosErrors() const; const vector<unsigned int>&MinosParams() const; boolNormalizeErrors() const; unsigned intNPar() const; ROOT::Fit::FitConfig&operator=(const ROOT::Fit::FitConfig& rhs); boolParabErrors() const; const vector<ROOT::Fit::ParameterSettings>&ParamsSettings() const; vector<ROOT::Fit::ParameterSettings>&ParamsSettings(); const ROOT::Fit::ParameterSettings&ParSettings(unsigned int i) const; ROOT::Fit::ParameterSettings&ParSettings(unsigned int i); static voidSetDefaultMinimizer(const char* type, const char* algo = 0); voidSetFromFitResult(const ROOT::Fit::FitResult& rhs); voidSetMinimizer(const char* type, const char* algo = 0); voidSetMinosErrors(bool on = true); voidSetMinosErrors(const vector<unsigned int>& paramInd); voidSetNormErrors(bool on = true); voidSetParabErrors(bool on = true); voidSetParamsSettings(const vector<ROOT::Fit::ParameterSettings>& pars); voidSetParamsSettings(unsigned int npar, const double* params, const double* vstep = 0); voidSetUpdateAfterFit(bool on = true); voidSetWeightCorrection(bool on = true); boolUpdateAfterFit() const; boolUseWeightCorrection() const. Data Members; private:. ROOT::Math::MinimizerO",MatchSource.WIKI,root/html532/ROOT__Fit__FitConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitConfig.html
https://root.cern/root/html532/ROOT__Fit__FitConfig.html:2459,Modifiability,config,configuration,2459,"gs&ParSettings(unsigned int i); static voidSetDefaultMinimizer(const char* type, const char* algo = 0); voidSetFromFitResult(const ROOT::Fit::FitResult& rhs); voidSetMinimizer(const char* type, const char* algo = 0); voidSetMinosErrors(bool on = true); voidSetMinosErrors(const vector<unsigned int>& paramInd); voidSetNormErrors(bool on = true); voidSetParabErrors(bool on = true); voidSetParamsSettings(const vector<ROOT::Fit::ParameterSettings>& pars); voidSetParamsSettings(unsigned int npar, const double* params, const double* vstep = 0); voidSetUpdateAfterFit(bool on = true); voidSetWeightCorrection(bool on = true); boolUpdateAfterFit() const; boolUseWeightCorrection() const. Data Members; private:. ROOT::Math::MinimizerOptionsfMinimizerOptsminimizer control parameters including name and algo type; boolfMinosErrorsdo full error analysis using Minos; vector<unsigned int>fMinosParamsvector with the parameter indeces for running Minos; boolfNormErrorsflag for error normalization; boolfParabErrorsget correct parabolic errors estimate (call Hesse after minimizing) ; vector<ROOT::Fit::ParameterSettings>fSettingsvector with the parameter settings; boolfUpdateAfterFitupdate the configuration after a fit using the result; boolfWeightCorrapply correction to errors for weights fits . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitConfig(unsigned int npar = 0). Default constructor. FitConfig(const ROOT::Fit::FitConfig& rhs). Copy constructor. ~FitConfig(). Destructor. FitConfig & operator=(const ROOT::Fit::FitConfig& rhs). Assignment operator. const ParameterSettings & ParSettings(unsigned int i) const. get the parameter settings for the i-th parameter (const method). { return fSettings.at(i); }. ParameterSettings & ParSettings(unsigned int i). get the parameter settings for the i-th parameter (non-const method). { return fSettings.at(i); }. const std::vector<ROOT::Fit::ParameterSettings> & ParamsSettings() const. get the vector of ",MatchSource.WIKI,root/html532/ROOT__Fit__FitConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitConfig.html
https://root.cern/root/html532/ROOT__Fit__FitConfig.html:2578,Modifiability,Inherit,Inheritance,2578," on = true); voidSetParabErrors(bool on = true); voidSetParamsSettings(const vector<ROOT::Fit::ParameterSettings>& pars); voidSetParamsSettings(unsigned int npar, const double* params, const double* vstep = 0); voidSetUpdateAfterFit(bool on = true); voidSetWeightCorrection(bool on = true); boolUpdateAfterFit() const; boolUseWeightCorrection() const. Data Members; private:. ROOT::Math::MinimizerOptionsfMinimizerOptsminimizer control parameters including name and algo type; boolfMinosErrorsdo full error analysis using Minos; vector<unsigned int>fMinosParamsvector with the parameter indeces for running Minos; boolfNormErrorsflag for error normalization; boolfParabErrorsget correct parabolic errors estimate (call Hesse after minimizing) ; vector<ROOT::Fit::ParameterSettings>fSettingsvector with the parameter settings; boolfUpdateAfterFitupdate the configuration after a fit using the result; boolfWeightCorrapply correction to errors for weights fits . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitConfig(unsigned int npar = 0). Default constructor. FitConfig(const ROOT::Fit::FitConfig& rhs). Copy constructor. ~FitConfig(). Destructor. FitConfig & operator=(const ROOT::Fit::FitConfig& rhs). Assignment operator. const ParameterSettings & ParSettings(unsigned int i) const. get the parameter settings for the i-th parameter (const method). { return fSettings.at(i); }. ParameterSettings & ParSettings(unsigned int i). get the parameter settings for the i-th parameter (non-const method). { return fSettings.at(i); }. const std::vector<ROOT::Fit::ParameterSettings> & ParamsSettings() const. get the vector of parameter settings (const method). { return fSettings; }. std::vector<ROOT::Fit::ParameterSettings> & ParamsSettings(). get the vector of parameter settings (non-const method). { return fSettings; }. unsigned int NPar() const. number of parameters settings. { return fSettings.size(); }. void CreateParamsSettings(const ROOT::Math::I",MatchSource.WIKI,root/html532/ROOT__Fit__FitConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitConfig.html
https://root.cern/root/html532/ROOT__Fit__FitConfig.html:2591,Modifiability,Inherit,Inherited,2591," on = true); voidSetParabErrors(bool on = true); voidSetParamsSettings(const vector<ROOT::Fit::ParameterSettings>& pars); voidSetParamsSettings(unsigned int npar, const double* params, const double* vstep = 0); voidSetUpdateAfterFit(bool on = true); voidSetWeightCorrection(bool on = true); boolUpdateAfterFit() const; boolUseWeightCorrection() const. Data Members; private:. ROOT::Math::MinimizerOptionsfMinimizerOptsminimizer control parameters including name and algo type; boolfMinosErrorsdo full error analysis using Minos; vector<unsigned int>fMinosParamsvector with the parameter indeces for running Minos; boolfNormErrorsflag for error normalization; boolfParabErrorsget correct parabolic errors estimate (call Hesse after minimizing) ; vector<ROOT::Fit::ParameterSettings>fSettingsvector with the parameter settings; boolfUpdateAfterFitupdate the configuration after a fit using the result; boolfWeightCorrapply correction to errors for weights fits . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitConfig(unsigned int npar = 0). Default constructor. FitConfig(const ROOT::Fit::FitConfig& rhs). Copy constructor. ~FitConfig(). Destructor. FitConfig & operator=(const ROOT::Fit::FitConfig& rhs). Assignment operator. const ParameterSettings & ParSettings(unsigned int i) const. get the parameter settings for the i-th parameter (const method). { return fSettings.at(i); }. ParameterSettings & ParSettings(unsigned int i). get the parameter settings for the i-th parameter (non-const method). { return fSettings.at(i); }. const std::vector<ROOT::Fit::ParameterSettings> & ParamsSettings() const. get the vector of parameter settings (const method). { return fSettings; }. std::vector<ROOT::Fit::ParameterSettings> & ParamsSettings(). get the vector of parameter settings (non-const method). { return fSettings; }. unsigned int NPar() const. number of parameters settings. { return fSettings.size(); }. void CreateParamsSettings(const ROOT::Math::I",MatchSource.WIKI,root/html532/ROOT__Fit__FitConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitConfig.html
https://root.cern/root/html532/ROOT__Fit__FitConfig.html:4388,Modifiability,config,configuration,4388,"ParamsSettings(). get the vector of parameter settings (non-const method). { return fSettings; }. unsigned int NPar() const. number of parameters settings. { return fSettings.size(); }. void CreateParamsSettings(const ROOT::Math::IParamMultiFunction& func). set the parameter settings from a model function.; Create always new parameter setting list from a given model function. void SetParamsSettings(unsigned int npar, const double* params, const double* vstep = 0). set the parameter settings from number of parameters and a vector of values and optionally step values. If there are not existing or number of parameters does not match existing one, create a new parameter setting list. void SetParamsSettings(const vector<ROOT::Fit::ParameterSettings>& pars). Set the parameter settings from a vector of parameter settings. void SetFromFitResult(const ROOT::Fit::FitResult& rhs). Set the parameter settings from a fit Result. ROOT::Math::Minimizer * CreateMinimizer(). create a new minimizer according to chosen configuration. void SetMinimizer(const char* type, const char* algo = 0). set minimizer type. const std::string & MinimizerType() const. return type of minimizer package. { return fMinimizerOpts.MinimizerType(); }. const std::string & MinimizerAlgoType() const. return type of minimizer algorithms. { return fMinimizerOpts.MinimizerAlgorithm(); }. bool NormalizeErrors() const. flag to check if resulting errors are be normalized according to chi2/ndf. { return fNormErrors; }. bool ParabErrors() const; do analysis for parabolic errors. { return fParabErrors; }. bool MinosErrors() const; do minos errros analysis on the parameters. { return fMinosErrors; }. bool UpdateAfterFit() const; Update configuration after a fit using the FitResult. { return fUpdateAfterFit; }. bool UseWeightCorrection() const; Apply Weight correction for error matrix computation. { return fWeightCorr; }. const std::vector<unsigned int> & MinosParams() const; return vector of parameter indeces for which ",MatchSource.WIKI,root/html532/ROOT__Fit__FitConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitConfig.html
https://root.cern/root/html532/ROOT__Fit__FitConfig.html:5084,Modifiability,config,configuration,5084,"st vector<ROOT::Fit::ParameterSettings>& pars). Set the parameter settings from a vector of parameter settings. void SetFromFitResult(const ROOT::Fit::FitResult& rhs). Set the parameter settings from a fit Result. ROOT::Math::Minimizer * CreateMinimizer(). create a new minimizer according to chosen configuration. void SetMinimizer(const char* type, const char* algo = 0). set minimizer type. const std::string & MinimizerType() const. return type of minimizer package. { return fMinimizerOpts.MinimizerType(); }. const std::string & MinimizerAlgoType() const. return type of minimizer algorithms. { return fMinimizerOpts.MinimizerAlgorithm(); }. bool NormalizeErrors() const. flag to check if resulting errors are be normalized according to chi2/ndf. { return fNormErrors; }. bool ParabErrors() const; do analysis for parabolic errors. { return fParabErrors; }. bool MinosErrors() const; do minos errros analysis on the parameters. { return fMinosErrors; }. bool UpdateAfterFit() const; Update configuration after a fit using the FitResult. { return fUpdateAfterFit; }. bool UseWeightCorrection() const; Apply Weight correction for error matrix computation. { return fWeightCorr; }. const std::vector<unsigned int> & MinosParams() const; return vector of parameter indeces for which the Minos Error will be computed. { return fMinosParams; }. void SetNormErrors(bool on = true). set the option to normalize the error on the result according to chi2/ndf. { fNormErrors= on; }. void SetParabErrors(bool on = true); set parabolic erros. { fParabErrors = on; }. void SetMinosErrors(bool on = true); set Minos erros. { fMinosErrors = on; }. void SetWeightCorrection(bool on = true); apply the weight correction for error matric computation. { fWeightCorr = on; }. void SetMinosErrors(const vector<unsigned int>& paramInd); set parameter indeces for running Minos; this can be used for running Minos on a subset of parameters - otherwise is run on all of them; if MinosErrors() is set. void SetUpdateAfter",MatchSource.WIKI,root/html532/ROOT__Fit__FitConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitConfig.html
https://root.cern/root/html532/ROOT__Fit__FitConfig.html:6117,Modifiability,config,configuration,6117,"MinimizerOpts.MinimizerAlgorithm(); }. bool NormalizeErrors() const. flag to check if resulting errors are be normalized according to chi2/ndf. { return fNormErrors; }. bool ParabErrors() const; do analysis for parabolic errors. { return fParabErrors; }. bool MinosErrors() const; do minos errros analysis on the parameters. { return fMinosErrors; }. bool UpdateAfterFit() const; Update configuration after a fit using the FitResult. { return fUpdateAfterFit; }. bool UseWeightCorrection() const; Apply Weight correction for error matrix computation. { return fWeightCorr; }. const std::vector<unsigned int> & MinosParams() const; return vector of parameter indeces for which the Minos Error will be computed. { return fMinosParams; }. void SetNormErrors(bool on = true). set the option to normalize the error on the result according to chi2/ndf. { fNormErrors= on; }. void SetParabErrors(bool on = true); set parabolic erros. { fParabErrors = on; }. void SetMinosErrors(bool on = true); set Minos erros. { fMinosErrors = on; }. void SetWeightCorrection(bool on = true); apply the weight correction for error matric computation. { fWeightCorr = on; }. void SetMinosErrors(const vector<unsigned int>& paramInd); set parameter indeces for running Minos; this can be used for running Minos on a subset of parameters - otherwise is run on all of them; if MinosErrors() is set. void SetUpdateAfterFit(bool on = true); Update configuration after a fit using the FitResult. { fUpdateAfterFit = on; }. void SetDefaultMinimizer(const char* type, const char* algo = 0). static function to control default minimizer type and algorithm.  Author: L. Moneta Thu Sep 21 16:21:29 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: FitConfig.h 42007 2011-11-15 13:23:17Z moneta $  Last generated: 2011-12-02 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Fit__FitConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitConfig.html
https://root.cern/root/html532/ROOT__Fit__FitData.html:938,Modifiability,Inherit,Inheritance,938,". ROOT::Fit::FitData. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::FitData. class ROOT::Fit::FitData. Function Members (Methods); public:. virtual~FitData(); ROOT::Fit::FitDataFitData(); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataOptions& opt); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataRange& range); ROOT::Fit::FitDataFitData(const ROOT::Fit::FitData&); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range); static unsigned intMaxSize(); ROOT::Fit::FitData&operator=(const ROOT::Fit::FitData&); const ROOT::Fit::DataOptions&Opt() const; ROOT::Fit::DataOptions&Opt(); const ROOT::Fit::DataRange&Range() const. Data Members; private:. ROOT::Fit::DataOptionsfOptions; ROOT::Fit::DataRangefRange. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitData(); construct with default option and data range. {}. virtual ~FitData(); dummy virtual destructor. {}. FitData(const DataOptions & opt); construct passing options and default data range. {}. FitData(const DataRange & range); construct passing range and default options. {}. FitData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range); construct passing options and data range. {}. unsigned int MaxSize(); range cannot be modified afterwards; since fit method functions use all data. define a max size to avoid allocating too large arrays.  Author: L. Moneta Wed Aug 30 11:15:23 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: DataVector.h 28946 2009-06-11 15:39:14Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Fit__FitData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitData.html
https://root.cern/root/html532/ROOT__Fit__FitData.html:951,Modifiability,Inherit,Inherited,951,". ROOT::Fit::FitData. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::FitData. class ROOT::Fit::FitData. Function Members (Methods); public:. virtual~FitData(); ROOT::Fit::FitDataFitData(); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataOptions& opt); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataRange& range); ROOT::Fit::FitDataFitData(const ROOT::Fit::FitData&); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range); static unsigned intMaxSize(); ROOT::Fit::FitData&operator=(const ROOT::Fit::FitData&); const ROOT::Fit::DataOptions&Opt() const; ROOT::Fit::DataOptions&Opt(); const ROOT::Fit::DataRange&Range() const. Data Members; private:. ROOT::Fit::DataOptionsfOptions; ROOT::Fit::DataRangefRange. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitData(); construct with default option and data range. {}. virtual ~FitData(); dummy virtual destructor. {}. FitData(const DataOptions & opt); construct passing options and default data range. {}. FitData(const DataRange & range); construct passing range and default options. {}. FitData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range); construct passing options and data range. {}. unsigned int MaxSize(); range cannot be modified afterwards; since fit method functions use all data. define a max size to avoid allocating too large arrays.  Author: L. Moneta Wed Aug 30 11:15:23 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: DataVector.h 28946 2009-06-11 15:39:14Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Fit__FitData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitData.html
https://root.cern/root/html532/ROOT__Fit__FitData.html:1545,Safety,avoid,avoid,1545,". ROOT::Fit::FitData. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::FitData. class ROOT::Fit::FitData. Function Members (Methods); public:. virtual~FitData(); ROOT::Fit::FitDataFitData(); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataOptions& opt); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataRange& range); ROOT::Fit::FitDataFitData(const ROOT::Fit::FitData&); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range); static unsigned intMaxSize(); ROOT::Fit::FitData&operator=(const ROOT::Fit::FitData&); const ROOT::Fit::DataOptions&Opt() const; ROOT::Fit::DataOptions&Opt(); const ROOT::Fit::DataRange&Range() const. Data Members; private:. ROOT::Fit::DataOptionsfOptions; ROOT::Fit::DataRangefRange. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitData(); construct with default option and data range. {}. virtual ~FitData(); dummy virtual destructor. {}. FitData(const DataOptions & opt); construct passing options and default data range. {}. FitData(const DataRange & range); construct passing range and default options. {}. FitData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range); construct passing options and data range. {}. unsigned int MaxSize(); range cannot be modified afterwards; since fit method functions use all data. define a max size to avoid allocating too large arrays.  Author: L. Moneta Wed Aug 30 11:15:23 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: DataVector.h 28946 2009-06-11 15:39:14Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Fit__FitData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitData.html
https://root.cern/root/html532/ROOT__Fit__FitResult.html:381,Availability,error,error,381,". ROOT::Fit::FitResult. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::FitResult. class ROOT::Fit::FitResult. class containg the result of the fit and all the related information; (fitted parameter values, error, covariance matrix and minimizer result information); Contains a pointer also to the fitted (model) function, modified with the fit parameter values.; When the fit is valid, it is constructed from a Minimizer and a model function pointer. @ingroup FitMain. Function Members (Methods); public:. ~FitResult(); doubleChi2() const; doubleCorrelation(unsigned int i, unsigned int j) const; doubleCovMatrix(unsigned int i, unsigned int j) const; intCovMatrixStatus() const; doubleEdm() const; doubleError(unsigned int i) const; const vector<double>&Errors() const; ROOT::Fit::FitResultFitResult(); ROOT::Fit::FitResultFitResult(const ROOT::Fit::FitConfig& fconfig); ROOT::Fit::FitResultFitResult(const ROOT::Fit::FitResult&); ROOT::Fit::FitResultFitResult(ROOT::Math::Minimizer& min, const ROOT::Fit::FitConfig& fconfig, const ROOT::Fit::FitResult::IModelFunction* f, bool isValid, unsigned int sizeOfData = 0, bool binFit = true, const ROOT::Math::IMultiGenFunction* chi2func = 0, unsigned int ncalls = 0); const ROOT::Fit::FitResult::IModelFunction*FittedFunction() const; voidGetConfidenceIntervals(const ROOT::Fit::BinData& data, double* ci, double cl = 0.95, bool norm = true) const; voidGetConfidenceIntervals(unsigned int n, unsigned int stride1, unsigned int stride2, const double* x, double* ci, double cl = 0.95, bool norm = true) const; voidGetCorrelationMatrix(TMatrixTSym<double>& mat) const; voidGetCorrelationMatrix<TMatrixDSym>(TMatrixTSym<double>& mat) const; voidGetCovarianceMatrix(TMatrixTSym<double>& mat) const; voidGetCovarianceMatrix<TMatrixDSym>(TMatrixTSym<double>& mat) const; const double*Get",MatchSource.WIKI,root/html532/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitResult.html
https://root.cern/root/html532/ROOT__Fit__FitResult.html:930,Availability,Error,Errors,930,"e; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::FitResult. class ROOT::Fit::FitResult. class containg the result of the fit and all the related information; (fitted parameter values, error, covariance matrix and minimizer result information); Contains a pointer also to the fitted (model) function, modified with the fit parameter values.; When the fit is valid, it is constructed from a Minimizer and a model function pointer. @ingroup FitMain. Function Members (Methods); public:. ~FitResult(); doubleChi2() const; doubleCorrelation(unsigned int i, unsigned int j) const; doubleCovMatrix(unsigned int i, unsigned int j) const; intCovMatrixStatus() const; doubleEdm() const; doubleError(unsigned int i) const; const vector<double>&Errors() const; ROOT::Fit::FitResultFitResult(); ROOT::Fit::FitResultFitResult(const ROOT::Fit::FitConfig& fconfig); ROOT::Fit::FitResultFitResult(const ROOT::Fit::FitResult&); ROOT::Fit::FitResultFitResult(ROOT::Math::Minimizer& min, const ROOT::Fit::FitConfig& fconfig, const ROOT::Fit::FitResult::IModelFunction* f, bool isValid, unsigned int sizeOfData = 0, bool binFit = true, const ROOT::Math::IMultiGenFunction* chi2func = 0, unsigned int ncalls = 0); const ROOT::Fit::FitResult::IModelFunction*FittedFunction() const; voidGetConfidenceIntervals(const ROOT::Fit::BinData& data, double* ci, double cl = 0.95, bool norm = true) const; voidGetConfidenceIntervals(unsigned int n, unsigned int stride1, unsigned int stride2, const double* x, double* ci, double cl = 0.95, bool norm = true) const; voidGetCorrelationMatrix(TMatrixTSym<double>& mat) const; voidGetCorrelationMatrix<TMatrixDSym>(TMatrixTSym<double>& mat) const; voidGetCovarianceMatrix(TMatrixTSym<double>& mat) const; voidGetCovarianceMatrix<TMatrixDSym>(TMatrixTSym<double>& mat) const; const double*GetErrors() const; stringGetParameterName(unsigned int ipar) const; const double*GetParams() const; doubleGlobalC",MatchSource.WIKI,root/html532/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitResult.html
https://root.cern/root/html532/ROOT__Fit__FitResult.html:4120,Availability,error,errors,4120,"perError(unsigned int i) const; doubleValue(unsigned int i) const. protected:. ROOT::Fit::FitResult::IModelFunction*ModelFunction(); voidSetModelFunction(ROOT::Fit::FitResult::IModelFunction* func). Data Members; protected:. vector<unsigned int>fBoundParamslist of limited parameters; doublefChi2fit chi2 value (different than fval in case of chi2 fits); vector<double>fCovMatrixcovariance matrix (size is npar*(npar+1)/2) where npar is total parameters; intfCovStatuscovariance matrix status code; doublefEdmexpected distance from mimimum; vector<double>fErrorserrors ; ROOT::Fit::FitResult::IModelFunction*fFitFunc! model function resulting from the fit. It is given by Fitter but it is managed by FitResult; vector<unsigned int>fFixedParamslist of fixed parameters; vector<double>fGlobalCCglobal Correlation coefficient; stringfMinimTypestring indicating type of minimizer; map<unsigned int,std::pair<double,double> >fMinosErrorsmap contains the two Minos errors; unsigned intfNCallsnumber of function calls; unsigned intfNFreenumber of fit free parameters (total parameters are in size of parameter vector) ; unsigned intfNdfnumber of degree of freedom; boolfNormalizedflag for indicating is errors are normalized; vector<std::string>fParNamesparameter names (only with FCN only fits, when fFitFunc=0); vector<double>fParamsparameter values. Size is total number of parameters; intfStatusminimizer status code; doublefValminimum function value; boolfValidflag for indicating valid fit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitResult(). Default constructor for an empty (non valid) fit result. FitResult(const FitConfig & fconfig). Constructor from a fit-config for a dummy fit; (e.g. when only one fcn evaluation is done). FitResult(ROOT::Math::Minimizer& min, const ROOT::Fit::FitConfig& fconfig, const ROOT::Fit::FitResult::IModelFunction* f, bool isValid, unsigned int sizeOfData = 0, bool binFit = true, const ROOT::Math::IMultiGenFunction",MatchSource.WIKI,root/html532/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitResult.html
https://root.cern/root/html532/ROOT__Fit__FitResult.html:4357,Availability,error,errors,4357,"perError(unsigned int i) const; doubleValue(unsigned int i) const. protected:. ROOT::Fit::FitResult::IModelFunction*ModelFunction(); voidSetModelFunction(ROOT::Fit::FitResult::IModelFunction* func). Data Members; protected:. vector<unsigned int>fBoundParamslist of limited parameters; doublefChi2fit chi2 value (different than fval in case of chi2 fits); vector<double>fCovMatrixcovariance matrix (size is npar*(npar+1)/2) where npar is total parameters; intfCovStatuscovariance matrix status code; doublefEdmexpected distance from mimimum; vector<double>fErrorserrors ; ROOT::Fit::FitResult::IModelFunction*fFitFunc! model function resulting from the fit. It is given by Fitter but it is managed by FitResult; vector<unsigned int>fFixedParamslist of fixed parameters; vector<double>fGlobalCCglobal Correlation coefficient; stringfMinimTypestring indicating type of minimizer; map<unsigned int,std::pair<double,double> >fMinosErrorsmap contains the two Minos errors; unsigned intfNCallsnumber of function calls; unsigned intfNFreenumber of fit free parameters (total parameters are in size of parameter vector) ; unsigned intfNdfnumber of degree of freedom; boolfNormalizedflag for indicating is errors are normalized; vector<std::string>fParNamesparameter names (only with FCN only fits, when fFitFunc=0); vector<double>fParamsparameter values. Size is total number of parameters; intfStatusminimizer status code; doublefValminimum function value; boolfValidflag for indicating valid fit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitResult(). Default constructor for an empty (non valid) fit result. FitResult(const FitConfig & fconfig). Constructor from a fit-config for a dummy fit; (e.g. when only one fcn evaluation is done). FitResult(ROOT::Math::Minimizer& min, const ROOT::Fit::FitConfig& fconfig, const ROOT::Fit::FitResult::IModelFunction* f, bool isValid, unsigned int sizeOfData = 0, bool binFit = true, const ROOT::Math::IMultiGenFunction",MatchSource.WIKI,root/html532/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitResult.html
https://root.cern/root/html532/ROOT__Fit__FitResult.html:7255,Availability,Error,Errors,7255," from minimum. { return fEdm; }. unsigned int NTotalParameters() const; get total number of parameters. { return fParams.size(); }. unsigned int NPar() const; total number of parameters (abbreviation). { return NTotalParameters(); }. unsigned int NFreeParameters() const; get total number of free parameters. { return fNFree; }. int Status() const; minimizer status code. { return fStatus; }. int CovMatrixStatus() const; covariance matrix status code; using Minuit convention : =0 not calculated, =1 approximated, =2 made pos def , =3 accurate. { return fCovStatus; }. const IModelFunction * FittedFunction() const; fitting quantities ; Return pointer to model (fit) function with fitted parameter values. { return fFitFunc; }. double Chi2() const; Chi2 fit value; in case of likelihood must be computed ?. { return fChi2; }. unsigned int Ndf() const; Number of degree of freedom. { return fNdf; }. double Prob() const; p value of the fit (chi2 probability). const std::vector<double> & Errors() const; parameter errors (return st::vector). { return fErrors; }. const double * GetErrors() const; parameter errors (return const pointer). { return (fErrors.empty()) ? 0 : &fErrors.front(); }. const std::vector<double> & Parameters() const; parameter values (return std::vector). { return fParams; }. const double * GetParams() const; parameter values (return const pointer). { return &fParams.front(); }. double Value(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Parameter(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Error(unsigned int i) const; parameter error by index; (NOTE: this due to conflict with TObject::Error cannot used in derived class which; inherits from TObject. Use instead ParError (or Errors()[i] ). double ParError(unsigned int i) const; parameter error by index. std::string ParName(unsigned int i) const; name of the parameter. void SetMinosError(unsigned int i, double elow, double eup); set the Minos erro",MatchSource.WIKI,root/html532/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitResult.html
https://root.cern/root/html532/ROOT__Fit__FitResult.html:7281,Availability,error,errors,7281," from minimum. { return fEdm; }. unsigned int NTotalParameters() const; get total number of parameters. { return fParams.size(); }. unsigned int NPar() const; total number of parameters (abbreviation). { return NTotalParameters(); }. unsigned int NFreeParameters() const; get total number of free parameters. { return fNFree; }. int Status() const; minimizer status code. { return fStatus; }. int CovMatrixStatus() const; covariance matrix status code; using Minuit convention : =0 not calculated, =1 approximated, =2 made pos def , =3 accurate. { return fCovStatus; }. const IModelFunction * FittedFunction() const; fitting quantities ; Return pointer to model (fit) function with fitted parameter values. { return fFitFunc; }. double Chi2() const; Chi2 fit value; in case of likelihood must be computed ?. { return fChi2; }. unsigned int Ndf() const; Number of degree of freedom. { return fNdf; }. double Prob() const; p value of the fit (chi2 probability). const std::vector<double> & Errors() const; parameter errors (return st::vector). { return fErrors; }. const double * GetErrors() const; parameter errors (return const pointer). { return (fErrors.empty()) ? 0 : &fErrors.front(); }. const std::vector<double> & Parameters() const; parameter values (return std::vector). { return fParams; }. const double * GetParams() const; parameter values (return const pointer). { return &fParams.front(); }. double Value(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Parameter(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Error(unsigned int i) const; parameter error by index; (NOTE: this due to conflict with TObject::Error cannot used in derived class which; inherits from TObject. Use instead ParError (or Errors()[i] ). double ParError(unsigned int i) const; parameter error by index. std::string ParName(unsigned int i) const; name of the parameter. void SetMinosError(unsigned int i, double elow, double eup); set the Minos erro",MatchSource.WIKI,root/html532/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitResult.html
https://root.cern/root/html532/ROOT__Fit__FitResult.html:7374,Availability,error,errors,7374,"ers. { return fParams.size(); }. unsigned int NPar() const; total number of parameters (abbreviation). { return NTotalParameters(); }. unsigned int NFreeParameters() const; get total number of free parameters. { return fNFree; }. int Status() const; minimizer status code. { return fStatus; }. int CovMatrixStatus() const; covariance matrix status code; using Minuit convention : =0 not calculated, =1 approximated, =2 made pos def , =3 accurate. { return fCovStatus; }. const IModelFunction * FittedFunction() const; fitting quantities ; Return pointer to model (fit) function with fitted parameter values. { return fFitFunc; }. double Chi2() const; Chi2 fit value; in case of likelihood must be computed ?. { return fChi2; }. unsigned int Ndf() const; Number of degree of freedom. { return fNdf; }. double Prob() const; p value of the fit (chi2 probability). const std::vector<double> & Errors() const; parameter errors (return st::vector). { return fErrors; }. const double * GetErrors() const; parameter errors (return const pointer). { return (fErrors.empty()) ? 0 : &fErrors.front(); }. const std::vector<double> & Parameters() const; parameter values (return std::vector). { return fParams; }. const double * GetParams() const; parameter values (return const pointer). { return &fParams.front(); }. double Value(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Parameter(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Error(unsigned int i) const; parameter error by index; (NOTE: this due to conflict with TObject::Error cannot used in derived class which; inherits from TObject. Use instead ParError (or Errors()[i] ). double ParError(unsigned int i) const; parameter error by index. std::string ParName(unsigned int i) const; name of the parameter. void SetMinosError(unsigned int i, double elow, double eup); set the Minos errors for parameter i (called by the Fitter class when running Minos). bool HasMinosError(unsigned int ",MatchSource.WIKI,root/html532/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitResult.html
https://root.cern/root/html532/ROOT__Fit__FitResult.html:7855,Availability,Error,Error,7855,"it) function with fitted parameter values. { return fFitFunc; }. double Chi2() const; Chi2 fit value; in case of likelihood must be computed ?. { return fChi2; }. unsigned int Ndf() const; Number of degree of freedom. { return fNdf; }. double Prob() const; p value of the fit (chi2 probability). const std::vector<double> & Errors() const; parameter errors (return st::vector). { return fErrors; }. const double * GetErrors() const; parameter errors (return const pointer). { return (fErrors.empty()) ? 0 : &fErrors.front(); }. const std::vector<double> & Parameters() const; parameter values (return std::vector). { return fParams; }. const double * GetParams() const; parameter values (return const pointer). { return &fParams.front(); }. double Value(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Parameter(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Error(unsigned int i) const; parameter error by index; (NOTE: this due to conflict with TObject::Error cannot used in derived class which; inherits from TObject. Use instead ParError (or Errors()[i] ). double ParError(unsigned int i) const; parameter error by index. std::string ParName(unsigned int i) const; name of the parameter. void SetMinosError(unsigned int i, double elow, double eup); set the Minos errors for parameter i (called by the Fitter class when running Minos). bool HasMinosError(unsigned int i) const; query if parameter i has the Minos error. double LowerError(unsigned int i) const; lower Minos error. If Minos has not run for parameter i return the parabolic error. double UpperError(unsigned int i) const; upper Minos error. If Minos has not run for parameter i return the parabolic error. double GlobalCC(unsigned int i) const; parameter global correlation coefficient. double CovMatrix(unsigned int i, unsigned int j) const; retrieve covariance matrix element. double Correlation(unsigned int i, unsigned int j) const; retrieve correlation elements. v",MatchSource.WIKI,root/html532/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitResult.html
https://root.cern/root/html532/ROOT__Fit__FitResult.html:7894,Availability,error,error,7894,"it) function with fitted parameter values. { return fFitFunc; }. double Chi2() const; Chi2 fit value; in case of likelihood must be computed ?. { return fChi2; }. unsigned int Ndf() const; Number of degree of freedom. { return fNdf; }. double Prob() const; p value of the fit (chi2 probability). const std::vector<double> & Errors() const; parameter errors (return st::vector). { return fErrors; }. const double * GetErrors() const; parameter errors (return const pointer). { return (fErrors.empty()) ? 0 : &fErrors.front(); }. const std::vector<double> & Parameters() const; parameter values (return std::vector). { return fParams; }. const double * GetParams() const; parameter values (return const pointer). { return &fParams.front(); }. double Value(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Parameter(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Error(unsigned int i) const; parameter error by index; (NOTE: this due to conflict with TObject::Error cannot used in derived class which; inherits from TObject. Use instead ParError (or Errors()[i] ). double ParError(unsigned int i) const; parameter error by index. std::string ParName(unsigned int i) const; name of the parameter. void SetMinosError(unsigned int i, double elow, double eup); set the Minos errors for parameter i (called by the Fitter class when running Minos). bool HasMinosError(unsigned int i) const; query if parameter i has the Minos error. double LowerError(unsigned int i) const; lower Minos error. If Minos has not run for parameter i return the parabolic error. double UpperError(unsigned int i) const; upper Minos error. If Minos has not run for parameter i return the parabolic error. double GlobalCC(unsigned int i) const; parameter global correlation coefficient. double CovMatrix(unsigned int i, unsigned int j) const; retrieve covariance matrix element. double Correlation(unsigned int i, unsigned int j) const; retrieve correlation elements. v",MatchSource.WIKI,root/html532/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitResult.html
https://root.cern/root/html532/ROOT__Fit__FitResult.html:7952,Availability,Error,Error,7952,"it) function with fitted parameter values. { return fFitFunc; }. double Chi2() const; Chi2 fit value; in case of likelihood must be computed ?. { return fChi2; }. unsigned int Ndf() const; Number of degree of freedom. { return fNdf; }. double Prob() const; p value of the fit (chi2 probability). const std::vector<double> & Errors() const; parameter errors (return st::vector). { return fErrors; }. const double * GetErrors() const; parameter errors (return const pointer). { return (fErrors.empty()) ? 0 : &fErrors.front(); }. const std::vector<double> & Parameters() const; parameter values (return std::vector). { return fParams; }. const double * GetParams() const; parameter values (return const pointer). { return &fParams.front(); }. double Value(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Parameter(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Error(unsigned int i) const; parameter error by index; (NOTE: this due to conflict with TObject::Error cannot used in derived class which; inherits from TObject. Use instead ParError (or Errors()[i] ). double ParError(unsigned int i) const; parameter error by index. std::string ParName(unsigned int i) const; name of the parameter. void SetMinosError(unsigned int i, double elow, double eup); set the Minos errors for parameter i (called by the Fitter class when running Minos). bool HasMinosError(unsigned int i) const; query if parameter i has the Minos error. double LowerError(unsigned int i) const; lower Minos error. If Minos has not run for parameter i return the parabolic error. double UpperError(unsigned int i) const; upper Minos error. If Minos has not run for parameter i return the parabolic error. double GlobalCC(unsigned int i) const; parameter global correlation coefficient. double CovMatrix(unsigned int i, unsigned int j) const; retrieve covariance matrix element. double Correlation(unsigned int i, unsigned int j) const; retrieve correlation elements. v",MatchSource.WIKI,root/html532/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitResult.html
https://root.cern/root/html532/ROOT__Fit__FitResult.html:8042,Availability,Error,Errors,8042,"case of likelihood must be computed ?. { return fChi2; }. unsigned int Ndf() const; Number of degree of freedom. { return fNdf; }. double Prob() const; p value of the fit (chi2 probability). const std::vector<double> & Errors() const; parameter errors (return st::vector). { return fErrors; }. const double * GetErrors() const; parameter errors (return const pointer). { return (fErrors.empty()) ? 0 : &fErrors.front(); }. const std::vector<double> & Parameters() const; parameter values (return std::vector). { return fParams; }. const double * GetParams() const; parameter values (return const pointer). { return &fParams.front(); }. double Value(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Parameter(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Error(unsigned int i) const; parameter error by index; (NOTE: this due to conflict with TObject::Error cannot used in derived class which; inherits from TObject. Use instead ParError (or Errors()[i] ). double ParError(unsigned int i) const; parameter error by index. std::string ParName(unsigned int i) const; name of the parameter. void SetMinosError(unsigned int i, double elow, double eup); set the Minos errors for parameter i (called by the Fitter class when running Minos). bool HasMinosError(unsigned int i) const; query if parameter i has the Minos error. double LowerError(unsigned int i) const; lower Minos error. If Minos has not run for parameter i return the parabolic error. double UpperError(unsigned int i) const; upper Minos error. If Minos has not run for parameter i return the parabolic error. double GlobalCC(unsigned int i) const; parameter global correlation coefficient. double CovMatrix(unsigned int i, unsigned int j) const; retrieve covariance matrix element. double Correlation(unsigned int i, unsigned int j) const; retrieve correlation elements. void GetCovarianceMatrix(TMatrixTSym<double>& mat) const; fill covariance matrix elements using a generic",MatchSource.WIKI,root/html532/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitResult.html
https://root.cern/root/html532/ROOT__Fit__FitResult.html:8106,Availability,error,error,8106,"2; }. unsigned int Ndf() const; Number of degree of freedom. { return fNdf; }. double Prob() const; p value of the fit (chi2 probability). const std::vector<double> & Errors() const; parameter errors (return st::vector). { return fErrors; }. const double * GetErrors() const; parameter errors (return const pointer). { return (fErrors.empty()) ? 0 : &fErrors.front(); }. const std::vector<double> & Parameters() const; parameter values (return std::vector). { return fParams; }. const double * GetParams() const; parameter values (return const pointer). { return &fParams.front(); }. double Value(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Parameter(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Error(unsigned int i) const; parameter error by index; (NOTE: this due to conflict with TObject::Error cannot used in derived class which; inherits from TObject. Use instead ParError (or Errors()[i] ). double ParError(unsigned int i) const; parameter error by index. std::string ParName(unsigned int i) const; name of the parameter. void SetMinosError(unsigned int i, double elow, double eup); set the Minos errors for parameter i (called by the Fitter class when running Minos). bool HasMinosError(unsigned int i) const; query if parameter i has the Minos error. double LowerError(unsigned int i) const; lower Minos error. If Minos has not run for parameter i return the parabolic error. double UpperError(unsigned int i) const; upper Minos error. If Minos has not run for parameter i return the parabolic error. double GlobalCC(unsigned int i) const; parameter global correlation coefficient. double CovMatrix(unsigned int i, unsigned int j) const; retrieve covariance matrix element. double Correlation(unsigned int i, unsigned int j) const; retrieve correlation elements. void GetCovarianceMatrix(TMatrixTSym<double>& mat) const; fill covariance matrix elements using a generic matrix class implementing operator(i,j); the matrix ",MatchSource.WIKI,root/html532/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitResult.html
https://root.cern/root/html532/ROOT__Fit__FitResult.html:8263,Availability,error,errors,8263,"s() const; parameter errors (return st::vector). { return fErrors; }. const double * GetErrors() const; parameter errors (return const pointer). { return (fErrors.empty()) ? 0 : &fErrors.front(); }. const std::vector<double> & Parameters() const; parameter values (return std::vector). { return fParams; }. const double * GetParams() const; parameter values (return const pointer). { return &fParams.front(); }. double Value(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Parameter(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Error(unsigned int i) const; parameter error by index; (NOTE: this due to conflict with TObject::Error cannot used in derived class which; inherits from TObject. Use instead ParError (or Errors()[i] ). double ParError(unsigned int i) const; parameter error by index. std::string ParName(unsigned int i) const; name of the parameter. void SetMinosError(unsigned int i, double elow, double eup); set the Minos errors for parameter i (called by the Fitter class when running Minos). bool HasMinosError(unsigned int i) const; query if parameter i has the Minos error. double LowerError(unsigned int i) const; lower Minos error. If Minos has not run for parameter i return the parabolic error. double UpperError(unsigned int i) const; upper Minos error. If Minos has not run for parameter i return the parabolic error. double GlobalCC(unsigned int i) const; parameter global correlation coefficient. double CovMatrix(unsigned int i, unsigned int j) const; retrieve covariance matrix element. double Correlation(unsigned int i, unsigned int j) const; retrieve correlation elements. void GetCovarianceMatrix(TMatrixTSym<double>& mat) const; fill covariance matrix elements using a generic matrix class implementing operator(i,j); the matrix must be previously allocates with right size (npar * npar). void GetCorrelationMatrix(TMatrixTSym<double>& mat) const; fill a correlation matrix elements using a generic sy",MatchSource.WIKI,root/html532/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitResult.html
https://root.cern/root/html532/ROOT__Fit__FitResult.html:8412,Availability,error,error,8412,"rors (return const pointer). { return (fErrors.empty()) ? 0 : &fErrors.front(); }. const std::vector<double> & Parameters() const; parameter values (return std::vector). { return fParams; }. const double * GetParams() const; parameter values (return const pointer). { return &fParams.front(); }. double Value(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Parameter(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Error(unsigned int i) const; parameter error by index; (NOTE: this due to conflict with TObject::Error cannot used in derived class which; inherits from TObject. Use instead ParError (or Errors()[i] ). double ParError(unsigned int i) const; parameter error by index. std::string ParName(unsigned int i) const; name of the parameter. void SetMinosError(unsigned int i, double elow, double eup); set the Minos errors for parameter i (called by the Fitter class when running Minos). bool HasMinosError(unsigned int i) const; query if parameter i has the Minos error. double LowerError(unsigned int i) const; lower Minos error. If Minos has not run for parameter i return the parabolic error. double UpperError(unsigned int i) const; upper Minos error. If Minos has not run for parameter i return the parabolic error. double GlobalCC(unsigned int i) const; parameter global correlation coefficient. double CovMatrix(unsigned int i, unsigned int j) const; retrieve covariance matrix element. double Correlation(unsigned int i, unsigned int j) const; retrieve correlation elements. void GetCovarianceMatrix(TMatrixTSym<double>& mat) const; fill covariance matrix elements using a generic matrix class implementing operator(i,j); the matrix must be previously allocates with right size (npar * npar). void GetCorrelationMatrix(TMatrixTSym<double>& mat) const; fill a correlation matrix elements using a generic symmetric matrix class implementing operator(i,j); the matrix must be previously allocates with right size (npar * np",MatchSource.WIKI,root/html532/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitResult.html
https://root.cern/root/html532/ROOT__Fit__FitResult.html:8472,Availability,error,error,8472,"ront(); }. const std::vector<double> & Parameters() const; parameter values (return std::vector). { return fParams; }. const double * GetParams() const; parameter values (return const pointer). { return &fParams.front(); }. double Value(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Parameter(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Error(unsigned int i) const; parameter error by index; (NOTE: this due to conflict with TObject::Error cannot used in derived class which; inherits from TObject. Use instead ParError (or Errors()[i] ). double ParError(unsigned int i) const; parameter error by index. std::string ParName(unsigned int i) const; name of the parameter. void SetMinosError(unsigned int i, double elow, double eup); set the Minos errors for parameter i (called by the Fitter class when running Minos). bool HasMinosError(unsigned int i) const; query if parameter i has the Minos error. double LowerError(unsigned int i) const; lower Minos error. If Minos has not run for parameter i return the parabolic error. double UpperError(unsigned int i) const; upper Minos error. If Minos has not run for parameter i return the parabolic error. double GlobalCC(unsigned int i) const; parameter global correlation coefficient. double CovMatrix(unsigned int i, unsigned int j) const; retrieve covariance matrix element. double Correlation(unsigned int i, unsigned int j) const; retrieve correlation elements. void GetCovarianceMatrix(TMatrixTSym<double>& mat) const; fill covariance matrix elements using a generic matrix class implementing operator(i,j); the matrix must be previously allocates with right size (npar * npar). void GetCorrelationMatrix(TMatrixTSym<double>& mat) const; fill a correlation matrix elements using a generic symmetric matrix class implementing operator(i,j); the matrix must be previously allocates with right size (npar * npar). void GetConfidenceIntervals(unsigned int n, unsigned int stride1, u",MatchSource.WIKI,root/html532/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitResult.html
https://root.cern/root/html532/ROOT__Fit__FitResult.html:8537,Availability,error,error,8537,"ameter values (return std::vector). { return fParams; }. const double * GetParams() const; parameter values (return const pointer). { return &fParams.front(); }. double Value(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Parameter(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Error(unsigned int i) const; parameter error by index; (NOTE: this due to conflict with TObject::Error cannot used in derived class which; inherits from TObject. Use instead ParError (or Errors()[i] ). double ParError(unsigned int i) const; parameter error by index. std::string ParName(unsigned int i) const; name of the parameter. void SetMinosError(unsigned int i, double elow, double eup); set the Minos errors for parameter i (called by the Fitter class when running Minos). bool HasMinosError(unsigned int i) const; query if parameter i has the Minos error. double LowerError(unsigned int i) const; lower Minos error. If Minos has not run for parameter i return the parabolic error. double UpperError(unsigned int i) const; upper Minos error. If Minos has not run for parameter i return the parabolic error. double GlobalCC(unsigned int i) const; parameter global correlation coefficient. double CovMatrix(unsigned int i, unsigned int j) const; retrieve covariance matrix element. double Correlation(unsigned int i, unsigned int j) const; retrieve correlation elements. void GetCovarianceMatrix(TMatrixTSym<double>& mat) const; fill covariance matrix elements using a generic matrix class implementing operator(i,j); the matrix must be previously allocates with right size (npar * npar). void GetCorrelationMatrix(TMatrixTSym<double>& mat) const; fill a correlation matrix elements using a generic symmetric matrix class implementing operator(i,j); the matrix must be previously allocates with right size (npar * npar). void GetConfidenceIntervals(unsigned int n, unsigned int stride1, unsigned int stride2, const double* x, double* ci, double cl = 0",MatchSource.WIKI,root/html532/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitResult.html
https://root.cern/root/html532/ROOT__Fit__FitResult.html:8597,Availability,error,error,8597,"double * GetParams() const; parameter values (return const pointer). { return &fParams.front(); }. double Value(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Parameter(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Error(unsigned int i) const; parameter error by index; (NOTE: this due to conflict with TObject::Error cannot used in derived class which; inherits from TObject. Use instead ParError (or Errors()[i] ). double ParError(unsigned int i) const; parameter error by index. std::string ParName(unsigned int i) const; name of the parameter. void SetMinosError(unsigned int i, double elow, double eup); set the Minos errors for parameter i (called by the Fitter class when running Minos). bool HasMinosError(unsigned int i) const; query if parameter i has the Minos error. double LowerError(unsigned int i) const; lower Minos error. If Minos has not run for parameter i return the parabolic error. double UpperError(unsigned int i) const; upper Minos error. If Minos has not run for parameter i return the parabolic error. double GlobalCC(unsigned int i) const; parameter global correlation coefficient. double CovMatrix(unsigned int i, unsigned int j) const; retrieve covariance matrix element. double Correlation(unsigned int i, unsigned int j) const; retrieve correlation elements. void GetCovarianceMatrix(TMatrixTSym<double>& mat) const; fill covariance matrix elements using a generic matrix class implementing operator(i,j); the matrix must be previously allocates with right size (npar * npar). void GetCorrelationMatrix(TMatrixTSym<double>& mat) const; fill a correlation matrix elements using a generic symmetric matrix class implementing operator(i,j); the matrix must be previously allocates with right size (npar * npar). void GetConfidenceIntervals(unsigned int n, unsigned int stride1, unsigned int stride2, const double* x, double* ci, double cl = 0.95, bool norm = true) const. get confidence intervals for an ",MatchSource.WIKI,root/html532/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitResult.html
https://root.cern/root/html532/ROOT__Fit__FitResult.html:8662,Availability,error,error,8662,"nter). { return &fParams.front(); }. double Value(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Parameter(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Error(unsigned int i) const; parameter error by index; (NOTE: this due to conflict with TObject::Error cannot used in derived class which; inherits from TObject. Use instead ParError (or Errors()[i] ). double ParError(unsigned int i) const; parameter error by index. std::string ParName(unsigned int i) const; name of the parameter. void SetMinosError(unsigned int i, double elow, double eup); set the Minos errors for parameter i (called by the Fitter class when running Minos). bool HasMinosError(unsigned int i) const; query if parameter i has the Minos error. double LowerError(unsigned int i) const; lower Minos error. If Minos has not run for parameter i return the parabolic error. double UpperError(unsigned int i) const; upper Minos error. If Minos has not run for parameter i return the parabolic error. double GlobalCC(unsigned int i) const; parameter global correlation coefficient. double CovMatrix(unsigned int i, unsigned int j) const; retrieve covariance matrix element. double Correlation(unsigned int i, unsigned int j) const; retrieve correlation elements. void GetCovarianceMatrix(TMatrixTSym<double>& mat) const; fill covariance matrix elements using a generic matrix class implementing operator(i,j); the matrix must be previously allocates with right size (npar * npar). void GetCorrelationMatrix(TMatrixTSym<double>& mat) const; fill a correlation matrix elements using a generic symmetric matrix class implementing operator(i,j); the matrix must be previously allocates with right size (npar * npar). void GetConfidenceIntervals(unsigned int n, unsigned int stride1, unsigned int stride2, const double* x, double* ci, double cl = 0.95, bool norm = true) const. get confidence intervals for an array of n points x.; stride1 indicates the stride in the coord",MatchSource.WIKI,root/html532/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitResult.html
https://root.cern/root/html532/ROOT__Fit__FitResult.html:10611,Availability,error,errors,10611,"s the stride in the coordinate space while stride2 the stride in dimension space.; For 1-dim points : stride1=1, stride2=1; for multi-dim points arranged as (x0,x1,...,xN,y0,....yN) stride1=1 stride2=n; for multi-dim points arraged as (x0,y0,..,x1,y1,...,xN,yN,..) stride1=ndim, stride2=1. the confidence interval are returned in the array ci; cl is the desired confidedence interval value; norm is a flag to control if the intervals need to be normalized to the chi2/ndf value; By default the intervals are corrected using the chi2/ndf value of the fit if a chi2 fit is performed. void GetConfidenceIntervals(const ROOT::Fit::BinData& data, double* ci, double cl = 0.95, bool norm = true) const. evaluate confidence interval for the point specified in the passed data sets; the confidence interval are returned in the array ci; cl is the desired confidence interval value. int Index(const string& name) const; get index for parameter name (return -1 if not found). void NormalizeErrors(); normalize errors using chi2/ndf for chi2 fits. bool NormalizedErrors() const; flag to chek if errors are normalized. { return fNormalized; }. void Print(ostream& os, bool covmat = false) const; print the result and optionaly covariance matrix and correlations. void PrintCovMatrix(ostream& os) const; print error matrix and correlations. bool IsParameterBound(unsigned int ipar) const; query if a parameter is bound. bool IsParameterFixed(unsigned int ipar) const; query if a parameter is fixed. std::string GetParameterName(unsigned int ipar) const; get name of parameter (deprecated). void SetModelFunction(ROOT::Fit::FitResult::IModelFunction* func); { fFitFunc = func; }.  Author: L. Moneta Wed Aug 30 11:05:34 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: FitResult.h 39474 2011-05-30 07:48:13Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in gene",MatchSource.WIKI,root/html532/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitResult.html
https://root.cern/root/html532/ROOT__Fit__FitResult.html:10695,Availability,error,errors,10695,"e stride2 the stride in dimension space.; For 1-dim points : stride1=1, stride2=1; for multi-dim points arranged as (x0,x1,...,xN,y0,....yN) stride1=1 stride2=n; for multi-dim points arraged as (x0,y0,..,x1,y1,...,xN,yN,..) stride1=ndim, stride2=1. the confidence interval are returned in the array ci; cl is the desired confidedence interval value; norm is a flag to control if the intervals need to be normalized to the chi2/ndf value; By default the intervals are corrected using the chi2/ndf value of the fit if a chi2 fit is performed. void GetConfidenceIntervals(const ROOT::Fit::BinData& data, double* ci, double cl = 0.95, bool norm = true) const. evaluate confidence interval for the point specified in the passed data sets; the confidence interval are returned in the array ci; cl is the desired confidence interval value. int Index(const string& name) const; get index for parameter name (return -1 if not found). void NormalizeErrors(); normalize errors using chi2/ndf for chi2 fits. bool NormalizedErrors() const; flag to chek if errors are normalized. { return fNormalized; }. void Print(ostream& os, bool covmat = false) const; print the result and optionaly covariance matrix and correlations. void PrintCovMatrix(ostream& os) const; print error matrix and correlations. bool IsParameterBound(unsigned int ipar) const; query if a parameter is bound. bool IsParameterFixed(unsigned int ipar) const; query if a parameter is fixed. std::string GetParameterName(unsigned int ipar) const; get name of parameter (deprecated). void SetModelFunction(ROOT::Fit::FitResult::IModelFunction* func); { fFitFunc = func; }.  Author: L. Moneta Wed Aug 30 11:05:34 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: FitResult.h 39474 2011-05-30 07:48:13Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitResult.html
https://root.cern/root/html532/ROOT__Fit__FitResult.html:10908,Availability,error,error,10908,"e stride2 the stride in dimension space.; For 1-dim points : stride1=1, stride2=1; for multi-dim points arranged as (x0,x1,...,xN,y0,....yN) stride1=1 stride2=n; for multi-dim points arraged as (x0,y0,..,x1,y1,...,xN,yN,..) stride1=ndim, stride2=1. the confidence interval are returned in the array ci; cl is the desired confidedence interval value; norm is a flag to control if the intervals need to be normalized to the chi2/ndf value; By default the intervals are corrected using the chi2/ndf value of the fit if a chi2 fit is performed. void GetConfidenceIntervals(const ROOT::Fit::BinData& data, double* ci, double cl = 0.95, bool norm = true) const. evaluate confidence interval for the point specified in the passed data sets; the confidence interval are returned in the array ci; cl is the desired confidence interval value. int Index(const string& name) const; get index for parameter name (return -1 if not found). void NormalizeErrors(); normalize errors using chi2/ndf for chi2 fits. bool NormalizedErrors() const; flag to chek if errors are normalized. { return fNormalized; }. void Print(ostream& os, bool covmat = false) const; print the result and optionaly covariance matrix and correlations. void PrintCovMatrix(ostream& os) const; print error matrix and correlations. bool IsParameterBound(unsigned int ipar) const; query if a parameter is bound. bool IsParameterFixed(unsigned int ipar) const; query if a parameter is fixed. std::string GetParameterName(unsigned int ipar) const; get name of parameter (deprecated). void SetModelFunction(ROOT::Fit::FitResult::IModelFunction* func); { fFitFunc = func; }.  Author: L. Moneta Wed Aug 30 11:05:34 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: FitResult.h 39474 2011-05-30 07:48:13Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitResult.html
https://root.cern/root/html532/ROOT__Fit__FitResult.html:5292,Deployability,configurat,configuration,5292,"parameter vector) ; unsigned intfNdfnumber of degree of freedom; boolfNormalizedflag for indicating is errors are normalized; vector<std::string>fParNamesparameter names (only with FCN only fits, when fFitFunc=0); vector<double>fParamsparameter values. Size is total number of parameters; intfStatusminimizer status code; doublefValminimum function value; boolfValidflag for indicating valid fit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitResult(). Default constructor for an empty (non valid) fit result. FitResult(const FitConfig & fconfig). Constructor from a fit-config for a dummy fit; (e.g. when only one fcn evaluation is done). FitResult(ROOT::Math::Minimizer& min, const ROOT::Fit::FitConfig& fconfig, const ROOT::Fit::FitResult::IModelFunction* f, bool isValid, unsigned int sizeOfData = 0, bool binFit = true, const ROOT::Math::IMultiGenFunction* chi2func = 0, unsigned int ncalls = 0). Construct from a Minimizer instance after fitting; Run also Minos if requested from the configuration. FitResult(const FitResult &). Copy constructor. ~FitResult(). Destructor. bool Update(const ROOT::Math::Minimizer& min, bool isValid, unsigned int ncalls = 0). Update the fit result with a new minimization status; To be run only if same fit is performed with same configuration; Note that in this case MINOS is not re-run. If one wants to run also MINOS; a new result must be created. const std::string & MinimizerType() const; minimization quantities ; minimizer type. { return fMinimType; }. bool IsValid() const; True if fit successful, otherwise false. { return fValid; }. bool IsEmpty() const; True if a fit result does not exist (even invalid) with parameter values. { return (fParams.size() == 0); }. double MinFcnValue() const; Return value of the objective function (chi2 or likelihood) used in the fit. { return fVal; }. unsigned int NCalls() const; Number of function calls to find minimum. { return fNCalls; }. double Edm() const; Expec",MatchSource.WIKI,root/html532/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitResult.html
https://root.cern/root/html532/ROOT__Fit__FitResult.html:5386,Deployability,Update,Update,5386," (only with FCN only fits, when fFitFunc=0); vector<double>fParamsparameter values. Size is total number of parameters; intfStatusminimizer status code; doublefValminimum function value; boolfValidflag for indicating valid fit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitResult(). Default constructor for an empty (non valid) fit result. FitResult(const FitConfig & fconfig). Constructor from a fit-config for a dummy fit; (e.g. when only one fcn evaluation is done). FitResult(ROOT::Math::Minimizer& min, const ROOT::Fit::FitConfig& fconfig, const ROOT::Fit::FitResult::IModelFunction* f, bool isValid, unsigned int sizeOfData = 0, bool binFit = true, const ROOT::Math::IMultiGenFunction* chi2func = 0, unsigned int ncalls = 0). Construct from a Minimizer instance after fitting; Run also Minos if requested from the configuration. FitResult(const FitResult &). Copy constructor. ~FitResult(). Destructor. bool Update(const ROOT::Math::Minimizer& min, bool isValid, unsigned int ncalls = 0). Update the fit result with a new minimization status; To be run only if same fit is performed with same configuration; Note that in this case MINOS is not re-run. If one wants to run also MINOS; a new result must be created. const std::string & MinimizerType() const; minimization quantities ; minimizer type. { return fMinimType; }. bool IsValid() const; True if fit successful, otherwise false. { return fValid; }. bool IsEmpty() const; True if a fit result does not exist (even invalid) with parameter values. { return (fParams.size() == 0); }. double MinFcnValue() const; Return value of the objective function (chi2 or likelihood) used in the fit. { return fVal; }. unsigned int NCalls() const; Number of function calls to find minimum. { return fNCalls; }. double Edm() const; Expected distance from minimum. { return fEdm; }. unsigned int NTotalParameters() const; get total number of parameters. { return fParams.size(); }. unsigned int NPar() cons",MatchSource.WIKI,root/html532/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitResult.html
https://root.cern/root/html532/ROOT__Fit__FitResult.html:5467,Deployability,Update,Update,5467,"Statusminimizer status code; doublefValminimum function value; boolfValidflag for indicating valid fit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitResult(). Default constructor for an empty (non valid) fit result. FitResult(const FitConfig & fconfig). Constructor from a fit-config for a dummy fit; (e.g. when only one fcn evaluation is done). FitResult(ROOT::Math::Minimizer& min, const ROOT::Fit::FitConfig& fconfig, const ROOT::Fit::FitResult::IModelFunction* f, bool isValid, unsigned int sizeOfData = 0, bool binFit = true, const ROOT::Math::IMultiGenFunction* chi2func = 0, unsigned int ncalls = 0). Construct from a Minimizer instance after fitting; Run also Minos if requested from the configuration. FitResult(const FitResult &). Copy constructor. ~FitResult(). Destructor. bool Update(const ROOT::Math::Minimizer& min, bool isValid, unsigned int ncalls = 0). Update the fit result with a new minimization status; To be run only if same fit is performed with same configuration; Note that in this case MINOS is not re-run. If one wants to run also MINOS; a new result must be created. const std::string & MinimizerType() const; minimization quantities ; minimizer type. { return fMinimType; }. bool IsValid() const; True if fit successful, otherwise false. { return fValid; }. bool IsEmpty() const; True if a fit result does not exist (even invalid) with parameter values. { return (fParams.size() == 0); }. double MinFcnValue() const; Return value of the objective function (chi2 or likelihood) used in the fit. { return fVal; }. unsigned int NCalls() const; Number of function calls to find minimum. { return fNCalls; }. double Edm() const; Expected distance from minimum. { return fEdm; }. unsigned int NTotalParameters() const; get total number of parameters. { return fParams.size(); }. unsigned int NPar() const; total number of parameters (abbreviation). { return NTotalParameters(); }. unsigned int NFreeParameters() const; get total",MatchSource.WIKI,root/html532/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitResult.html
https://root.cern/root/html532/ROOT__Fit__FitResult.html:5571,Deployability,configurat,configuration,5571,"Statusminimizer status code; doublefValminimum function value; boolfValidflag for indicating valid fit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitResult(). Default constructor for an empty (non valid) fit result. FitResult(const FitConfig & fconfig). Constructor from a fit-config for a dummy fit; (e.g. when only one fcn evaluation is done). FitResult(ROOT::Math::Minimizer& min, const ROOT::Fit::FitConfig& fconfig, const ROOT::Fit::FitResult::IModelFunction* f, bool isValid, unsigned int sizeOfData = 0, bool binFit = true, const ROOT::Math::IMultiGenFunction* chi2func = 0, unsigned int ncalls = 0). Construct from a Minimizer instance after fitting; Run also Minos if requested from the configuration. FitResult(const FitResult &). Copy constructor. ~FitResult(). Destructor. bool Update(const ROOT::Math::Minimizer& min, bool isValid, unsigned int ncalls = 0). Update the fit result with a new minimization status; To be run only if same fit is performed with same configuration; Note that in this case MINOS is not re-run. If one wants to run also MINOS; a new result must be created. const std::string & MinimizerType() const; minimization quantities ; minimizer type. { return fMinimType; }. bool IsValid() const; True if fit successful, otherwise false. { return fValid; }. bool IsEmpty() const; True if a fit result does not exist (even invalid) with parameter values. { return (fParams.size() == 0); }. double MinFcnValue() const; Return value of the objective function (chi2 or likelihood) used in the fit. { return fVal; }. unsigned int NCalls() const; Number of function calls to find minimum. { return fNCalls; }. double Edm() const; Expected distance from minimum. { return fEdm; }. unsigned int NTotalParameters() const; get total number of parameters. { return fParams.size(); }. unsigned int NPar() const; total number of parameters (abbreviation). { return NTotalParameters(); }. unsigned int NFreeParameters() const; get total",MatchSource.WIKI,root/html532/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitResult.html
https://root.cern/root/html532/ROOT__Fit__FitResult.html:9108,Energy Efficiency,allocate,allocates,9108,"or Errors()[i] ). double ParError(unsigned int i) const; parameter error by index. std::string ParName(unsigned int i) const; name of the parameter. void SetMinosError(unsigned int i, double elow, double eup); set the Minos errors for parameter i (called by the Fitter class when running Minos). bool HasMinosError(unsigned int i) const; query if parameter i has the Minos error. double LowerError(unsigned int i) const; lower Minos error. If Minos has not run for parameter i return the parabolic error. double UpperError(unsigned int i) const; upper Minos error. If Minos has not run for parameter i return the parabolic error. double GlobalCC(unsigned int i) const; parameter global correlation coefficient. double CovMatrix(unsigned int i, unsigned int j) const; retrieve covariance matrix element. double Correlation(unsigned int i, unsigned int j) const; retrieve correlation elements. void GetCovarianceMatrix(TMatrixTSym<double>& mat) const; fill covariance matrix elements using a generic matrix class implementing operator(i,j); the matrix must be previously allocates with right size (npar * npar). void GetCorrelationMatrix(TMatrixTSym<double>& mat) const; fill a correlation matrix elements using a generic symmetric matrix class implementing operator(i,j); the matrix must be previously allocates with right size (npar * npar). void GetConfidenceIntervals(unsigned int n, unsigned int stride1, unsigned int stride2, const double* x, double* ci, double cl = 0.95, bool norm = true) const. get confidence intervals for an array of n points x.; stride1 indicates the stride in the coordinate space while stride2 the stride in dimension space.; For 1-dim points : stride1=1, stride2=1; for multi-dim points arranged as (x0,x1,...,xN,y0,....yN) stride1=1 stride2=n; for multi-dim points arraged as (x0,y0,..,x1,y1,...,xN,yN,..) stride1=ndim, stride2=1. the confidence interval are returned in the array ci; cl is the desired confidedence interval value; norm is a flag to control if the inte",MatchSource.WIKI,root/html532/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitResult.html
https://root.cern/root/html532/ROOT__Fit__FitResult.html:9340,Energy Efficiency,allocate,allocates,9340,"rrors for parameter i (called by the Fitter class when running Minos). bool HasMinosError(unsigned int i) const; query if parameter i has the Minos error. double LowerError(unsigned int i) const; lower Minos error. If Minos has not run for parameter i return the parabolic error. double UpperError(unsigned int i) const; upper Minos error. If Minos has not run for parameter i return the parabolic error. double GlobalCC(unsigned int i) const; parameter global correlation coefficient. double CovMatrix(unsigned int i, unsigned int j) const; retrieve covariance matrix element. double Correlation(unsigned int i, unsigned int j) const; retrieve correlation elements. void GetCovarianceMatrix(TMatrixTSym<double>& mat) const; fill covariance matrix elements using a generic matrix class implementing operator(i,j); the matrix must be previously allocates with right size (npar * npar). void GetCorrelationMatrix(TMatrixTSym<double>& mat) const; fill a correlation matrix elements using a generic symmetric matrix class implementing operator(i,j); the matrix must be previously allocates with right size (npar * npar). void GetConfidenceIntervals(unsigned int n, unsigned int stride1, unsigned int stride2, const double* x, double* ci, double cl = 0.95, bool norm = true) const. get confidence intervals for an array of n points x.; stride1 indicates the stride in the coordinate space while stride2 the stride in dimension space.; For 1-dim points : stride1=1, stride2=1; for multi-dim points arranged as (x0,x1,...,xN,y0,....yN) stride1=1 stride2=n; for multi-dim points arraged as (x0,y0,..,x1,y1,...,xN,yN,..) stride1=ndim, stride2=1. the confidence interval are returned in the array ci; cl is the desired confidedence interval value; norm is a flag to control if the intervals need to be normalized to the chi2/ndf value; By default the intervals are corrected using the chi2/ndf value of the fit if a chi2 fit is performed. void GetConfidenceIntervals(const ROOT::Fit::BinData& data, double* ci,",MatchSource.WIKI,root/html532/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitResult.html
https://root.cern/root/html532/ROOT__Fit__FitResult.html:4665,Modifiability,Inherit,Inheritance,4665,"om mimimum; vector<double>fErrorserrors ; ROOT::Fit::FitResult::IModelFunction*fFitFunc! model function resulting from the fit. It is given by Fitter but it is managed by FitResult; vector<unsigned int>fFixedParamslist of fixed parameters; vector<double>fGlobalCCglobal Correlation coefficient; stringfMinimTypestring indicating type of minimizer; map<unsigned int,std::pair<double,double> >fMinosErrorsmap contains the two Minos errors; unsigned intfNCallsnumber of function calls; unsigned intfNFreenumber of fit free parameters (total parameters are in size of parameter vector) ; unsigned intfNdfnumber of degree of freedom; boolfNormalizedflag for indicating is errors are normalized; vector<std::string>fParNamesparameter names (only with FCN only fits, when fFitFunc=0); vector<double>fParamsparameter values. Size is total number of parameters; intfStatusminimizer status code; doublefValminimum function value; boolfValidflag for indicating valid fit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitResult(). Default constructor for an empty (non valid) fit result. FitResult(const FitConfig & fconfig). Constructor from a fit-config for a dummy fit; (e.g. when only one fcn evaluation is done). FitResult(ROOT::Math::Minimizer& min, const ROOT::Fit::FitConfig& fconfig, const ROOT::Fit::FitResult::IModelFunction* f, bool isValid, unsigned int sizeOfData = 0, bool binFit = true, const ROOT::Math::IMultiGenFunction* chi2func = 0, unsigned int ncalls = 0). Construct from a Minimizer instance after fitting; Run also Minos if requested from the configuration. FitResult(const FitResult &). Copy constructor. ~FitResult(). Destructor. bool Update(const ROOT::Math::Minimizer& min, bool isValid, unsigned int ncalls = 0). Update the fit result with a new minimization status; To be run only if same fit is performed with same configuration; Note that in this case MINOS is not re-run. If one wants to run also MINOS; a new result must be created.",MatchSource.WIKI,root/html532/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitResult.html
https://root.cern/root/html532/ROOT__Fit__FitResult.html:4678,Modifiability,Inherit,Inherited,4678,"om mimimum; vector<double>fErrorserrors ; ROOT::Fit::FitResult::IModelFunction*fFitFunc! model function resulting from the fit. It is given by Fitter but it is managed by FitResult; vector<unsigned int>fFixedParamslist of fixed parameters; vector<double>fGlobalCCglobal Correlation coefficient; stringfMinimTypestring indicating type of minimizer; map<unsigned int,std::pair<double,double> >fMinosErrorsmap contains the two Minos errors; unsigned intfNCallsnumber of function calls; unsigned intfNFreenumber of fit free parameters (total parameters are in size of parameter vector) ; unsigned intfNdfnumber of degree of freedom; boolfNormalizedflag for indicating is errors are normalized; vector<std::string>fParNamesparameter names (only with FCN only fits, when fFitFunc=0); vector<double>fParamsparameter values. Size is total number of parameters; intfStatusminimizer status code; doublefValminimum function value; boolfValidflag for indicating valid fit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitResult(). Default constructor for an empty (non valid) fit result. FitResult(const FitConfig & fconfig). Constructor from a fit-config for a dummy fit; (e.g. when only one fcn evaluation is done). FitResult(ROOT::Math::Minimizer& min, const ROOT::Fit::FitConfig& fconfig, const ROOT::Fit::FitResult::IModelFunction* f, bool isValid, unsigned int sizeOfData = 0, bool binFit = true, const ROOT::Math::IMultiGenFunction* chi2func = 0, unsigned int ncalls = 0). Construct from a Minimizer instance after fitting; Run also Minos if requested from the configuration. FitResult(const FitResult &). Copy constructor. ~FitResult(). Destructor. bool Update(const ROOT::Math::Minimizer& min, bool isValid, unsigned int ncalls = 0). Update the fit result with a new minimization status; To be run only if same fit is performed with same configuration; Note that in this case MINOS is not re-run. If one wants to run also MINOS; a new result must be created.",MatchSource.WIKI,root/html532/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitResult.html
https://root.cern/root/html532/ROOT__Fit__FitResult.html:4873,Modifiability,config,config,4873,"ctor<unsigned int>fFixedParamslist of fixed parameters; vector<double>fGlobalCCglobal Correlation coefficient; stringfMinimTypestring indicating type of minimizer; map<unsigned int,std::pair<double,double> >fMinosErrorsmap contains the two Minos errors; unsigned intfNCallsnumber of function calls; unsigned intfNFreenumber of fit free parameters (total parameters are in size of parameter vector) ; unsigned intfNdfnumber of degree of freedom; boolfNormalizedflag for indicating is errors are normalized; vector<std::string>fParNamesparameter names (only with FCN only fits, when fFitFunc=0); vector<double>fParamsparameter values. Size is total number of parameters; intfStatusminimizer status code; doublefValminimum function value; boolfValidflag for indicating valid fit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitResult(). Default constructor for an empty (non valid) fit result. FitResult(const FitConfig & fconfig). Constructor from a fit-config for a dummy fit; (e.g. when only one fcn evaluation is done). FitResult(ROOT::Math::Minimizer& min, const ROOT::Fit::FitConfig& fconfig, const ROOT::Fit::FitResult::IModelFunction* f, bool isValid, unsigned int sizeOfData = 0, bool binFit = true, const ROOT::Math::IMultiGenFunction* chi2func = 0, unsigned int ncalls = 0). Construct from a Minimizer instance after fitting; Run also Minos if requested from the configuration. FitResult(const FitResult &). Copy constructor. ~FitResult(). Destructor. bool Update(const ROOT::Math::Minimizer& min, bool isValid, unsigned int ncalls = 0). Update the fit result with a new minimization status; To be run only if same fit is performed with same configuration; Note that in this case MINOS is not re-run. If one wants to run also MINOS; a new result must be created. const std::string & MinimizerType() const; minimization quantities ; minimizer type. { return fMinimType; }. bool IsValid() const; True if fit successful, otherwise false. { return fV",MatchSource.WIKI,root/html532/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitResult.html
https://root.cern/root/html532/ROOT__Fit__FitResult.html:5292,Modifiability,config,configuration,5292,"parameter vector) ; unsigned intfNdfnumber of degree of freedom; boolfNormalizedflag for indicating is errors are normalized; vector<std::string>fParNamesparameter names (only with FCN only fits, when fFitFunc=0); vector<double>fParamsparameter values. Size is total number of parameters; intfStatusminimizer status code; doublefValminimum function value; boolfValidflag for indicating valid fit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitResult(). Default constructor for an empty (non valid) fit result. FitResult(const FitConfig & fconfig). Constructor from a fit-config for a dummy fit; (e.g. when only one fcn evaluation is done). FitResult(ROOT::Math::Minimizer& min, const ROOT::Fit::FitConfig& fconfig, const ROOT::Fit::FitResult::IModelFunction* f, bool isValid, unsigned int sizeOfData = 0, bool binFit = true, const ROOT::Math::IMultiGenFunction* chi2func = 0, unsigned int ncalls = 0). Construct from a Minimizer instance after fitting; Run also Minos if requested from the configuration. FitResult(const FitResult &). Copy constructor. ~FitResult(). Destructor. bool Update(const ROOT::Math::Minimizer& min, bool isValid, unsigned int ncalls = 0). Update the fit result with a new minimization status; To be run only if same fit is performed with same configuration; Note that in this case MINOS is not re-run. If one wants to run also MINOS; a new result must be created. const std::string & MinimizerType() const; minimization quantities ; minimizer type. { return fMinimType; }. bool IsValid() const; True if fit successful, otherwise false. { return fValid; }. bool IsEmpty() const; True if a fit result does not exist (even invalid) with parameter values. { return (fParams.size() == 0); }. double MinFcnValue() const; Return value of the objective function (chi2 or likelihood) used in the fit. { return fVal; }. unsigned int NCalls() const; Number of function calls to find minimum. { return fNCalls; }. double Edm() const; Expec",MatchSource.WIKI,root/html532/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitResult.html
https://root.cern/root/html532/ROOT__Fit__FitResult.html:5571,Modifiability,config,configuration,5571,"Statusminimizer status code; doublefValminimum function value; boolfValidflag for indicating valid fit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitResult(). Default constructor for an empty (non valid) fit result. FitResult(const FitConfig & fconfig). Constructor from a fit-config for a dummy fit; (e.g. when only one fcn evaluation is done). FitResult(ROOT::Math::Minimizer& min, const ROOT::Fit::FitConfig& fconfig, const ROOT::Fit::FitResult::IModelFunction* f, bool isValid, unsigned int sizeOfData = 0, bool binFit = true, const ROOT::Math::IMultiGenFunction* chi2func = 0, unsigned int ncalls = 0). Construct from a Minimizer instance after fitting; Run also Minos if requested from the configuration. FitResult(const FitResult &). Copy constructor. ~FitResult(). Destructor. bool Update(const ROOT::Math::Minimizer& min, bool isValid, unsigned int ncalls = 0). Update the fit result with a new minimization status; To be run only if same fit is performed with same configuration; Note that in this case MINOS is not re-run. If one wants to run also MINOS; a new result must be created. const std::string & MinimizerType() const; minimization quantities ; minimizer type. { return fMinimType; }. bool IsValid() const; True if fit successful, otherwise false. { return fValid; }. bool IsEmpty() const; True if a fit result does not exist (even invalid) with parameter values. { return (fParams.size() == 0); }. double MinFcnValue() const; Return value of the objective function (chi2 or likelihood) used in the fit. { return fVal; }. unsigned int NCalls() const; Number of function calls to find minimum. { return fNCalls; }. double Edm() const; Expected distance from minimum. { return fEdm; }. unsigned int NTotalParameters() const; get total number of parameters. { return fParams.size(); }. unsigned int NPar() const; total number of parameters (abbreviation). { return NTotalParameters(); }. unsigned int NFreeParameters() const; get total",MatchSource.WIKI,root/html532/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitResult.html
https://root.cern/root/html532/ROOT__Fit__FitResult.html:7994,Modifiability,inherit,inherits,7994,"it) function with fitted parameter values. { return fFitFunc; }. double Chi2() const; Chi2 fit value; in case of likelihood must be computed ?. { return fChi2; }. unsigned int Ndf() const; Number of degree of freedom. { return fNdf; }. double Prob() const; p value of the fit (chi2 probability). const std::vector<double> & Errors() const; parameter errors (return st::vector). { return fErrors; }. const double * GetErrors() const; parameter errors (return const pointer). { return (fErrors.empty()) ? 0 : &fErrors.front(); }. const std::vector<double> & Parameters() const; parameter values (return std::vector). { return fParams; }. const double * GetParams() const; parameter values (return const pointer). { return &fParams.front(); }. double Value(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Parameter(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Error(unsigned int i) const; parameter error by index; (NOTE: this due to conflict with TObject::Error cannot used in derived class which; inherits from TObject. Use instead ParError (or Errors()[i] ). double ParError(unsigned int i) const; parameter error by index. std::string ParName(unsigned int i) const; name of the parameter. void SetMinosError(unsigned int i, double elow, double eup); set the Minos errors for parameter i (called by the Fitter class when running Minos). bool HasMinosError(unsigned int i) const; query if parameter i has the Minos error. double LowerError(unsigned int i) const; lower Minos error. If Minos has not run for parameter i return the parabolic error. double UpperError(unsigned int i) const; upper Minos error. If Minos has not run for parameter i return the parabolic error. double GlobalCC(unsigned int i) const; parameter global correlation coefficient. double CovMatrix(unsigned int i, unsigned int j) const; retrieve covariance matrix element. double Correlation(unsigned int i, unsigned int j) const; retrieve correlation elements. v",MatchSource.WIKI,root/html532/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitResult.html
https://root.cern/root/html532/ROOT__Fit__FitResult.html:5551,Performance,perform,performed,5551,"Statusminimizer status code; doublefValminimum function value; boolfValidflag for indicating valid fit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitResult(). Default constructor for an empty (non valid) fit result. FitResult(const FitConfig & fconfig). Constructor from a fit-config for a dummy fit; (e.g. when only one fcn evaluation is done). FitResult(ROOT::Math::Minimizer& min, const ROOT::Fit::FitConfig& fconfig, const ROOT::Fit::FitResult::IModelFunction* f, bool isValid, unsigned int sizeOfData = 0, bool binFit = true, const ROOT::Math::IMultiGenFunction* chi2func = 0, unsigned int ncalls = 0). Construct from a Minimizer instance after fitting; Run also Minos if requested from the configuration. FitResult(const FitResult &). Copy constructor. ~FitResult(). Destructor. bool Update(const ROOT::Math::Minimizer& min, bool isValid, unsigned int ncalls = 0). Update the fit result with a new minimization status; To be run only if same fit is performed with same configuration; Note that in this case MINOS is not re-run. If one wants to run also MINOS; a new result must be created. const std::string & MinimizerType() const; minimization quantities ; minimizer type. { return fMinimType; }. bool IsValid() const; True if fit successful, otherwise false. { return fValid; }. bool IsEmpty() const; True if a fit result does not exist (even invalid) with parameter values. { return (fParams.size() == 0); }. double MinFcnValue() const; Return value of the objective function (chi2 or likelihood) used in the fit. { return fVal; }. unsigned int NCalls() const; Number of function calls to find minimum. { return fNCalls; }. double Edm() const; Expected distance from minimum. { return fEdm; }. unsigned int NTotalParameters() const; get total number of parameters. { return fParams.size(); }. unsigned int NPar() const; total number of parameters (abbreviation). { return NTotalParameters(); }. unsigned int NFreeParameters() const; get total",MatchSource.WIKI,root/html532/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitResult.html
https://root.cern/root/html532/ROOT__Fit__FitResult.html:10182,Performance,perform,performed,10182,"ass implementing operator(i,j); the matrix must be previously allocates with right size (npar * npar). void GetCorrelationMatrix(TMatrixTSym<double>& mat) const; fill a correlation matrix elements using a generic symmetric matrix class implementing operator(i,j); the matrix must be previously allocates with right size (npar * npar). void GetConfidenceIntervals(unsigned int n, unsigned int stride1, unsigned int stride2, const double* x, double* ci, double cl = 0.95, bool norm = true) const. get confidence intervals for an array of n points x.; stride1 indicates the stride in the coordinate space while stride2 the stride in dimension space.; For 1-dim points : stride1=1, stride2=1; for multi-dim points arranged as (x0,x1,...,xN,y0,....yN) stride1=1 stride2=n; for multi-dim points arraged as (x0,y0,..,x1,y1,...,xN,yN,..) stride1=ndim, stride2=1. the confidence interval are returned in the array ci; cl is the desired confidedence interval value; norm is a flag to control if the intervals need to be normalized to the chi2/ndf value; By default the intervals are corrected using the chi2/ndf value of the fit if a chi2 fit is performed. void GetConfidenceIntervals(const ROOT::Fit::BinData& data, double* ci, double cl = 0.95, bool norm = true) const. evaluate confidence interval for the point specified in the passed data sets; the confidence interval are returned in the array ci; cl is the desired confidence interval value. int Index(const string& name) const; get index for parameter name (return -1 if not found). void NormalizeErrors(); normalize errors using chi2/ndf for chi2 fits. bool NormalizedErrors() const; flag to chek if errors are normalized. { return fNormalized; }. void Print(ostream& os, bool covmat = false) const; print the result and optionaly covariance matrix and correlations. void PrintCovMatrix(ostream& os) const; print error matrix and correlations. bool IsParameterBound(unsigned int ipar) const; query if a parameter is bound. bool IsParameterFixed(unsign",MatchSource.WIKI,root/html532/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitResult.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:837,Availability,error,errors,837,". ROOT::Fit::Fitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::Fitter. class ROOT::Fit::Fitter. Fitter class, entry point for performing all type of fits.; Fits are performed using the generic ROOT::Fit::Fitter::Fit method.; The inputs are the data points and a model function (using a ROOT::Math::IParamFunction); The result of the fit is returned and kept internally in the ROOT::Fit::FitResult class.; The configuration of the fit (parameters, options, etc...) are specified in the; ROOT::Math::FitConfig class.; After fitting the config of the fit will be modified to have the new values the resulting; parameter of the fit with step sizes equal to the errors. FitConfig can be preserved with; initial parameters by calling FitConfig.SetUpdateAfterFit(false);. @ingroup FitMain. Function Members (Methods); public:. ~Fitter(); boolApplyWeightCorrection(const ROOT::Math::IMultiGenFunction& loglw2, bool minimizeW2L = false); boolCalculateHessErrors(); boolCalculateMinosErrors(); const ROOT::Fit::FitConfig&Config() const; ROOT::Fit::FitConfig&Config(); boolEvalFCN(); boolFit(const ROOT::Fit::BinData& data); boolFit(const ROOT::Fit::UnBinData& data, bool extended = false); boolFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricFunctionMultiDim& func); boolFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricFunctionMultiDim& func); boolFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func); boolFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func); boolFitFCN(); boolFitFCN(const ROOT::Math::FitMethodFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params =",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:11710,Availability,error,error,11710,"ented by a multi-dimensional gradient function interface; (ROOT::Math::IMultiGenFunction) and optionally the initial parameters; See also note above for the initial parameters for FitFCN. bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). bool EvalFCN(). Perform a simple FCN evaluation. FitResult will be modified and contain the value of the FCN. bool LinearFit(const ROOT::Fit::BinData& data). do a linear fit on a set of bin-data. { return DoLinearFit(data); }. void SetFunction(const IModelFunction & func, bool useGradient = false). Set the fitted function (model function) from a parametric function interface. void SetFunction(const IModel1DFunction & func, bool useGradient = false). Set the fitted function from a parametric 1D function interface. bool CalculateHessErrors(). perform an error analysis on the result using the Hessian; Errors are obtaied from the inverse of the Hessian matrix; To be called only after fitting and when a minimizer supporting the Hessian calculations is used; otherwise an error (false) is returned.; A new FitResult with the Hessian result will be produced. bool CalculateMinosErrors(). perform an error analysis on the result using MINOS; To be called only after fitting and when a minimizer supporting MINOS is used; otherwise an error (false) is returned.; The result will be appended in the fit result class; Optionally a vector of parameter indeces can be passed for selecting; the parameters to analyse using FitConfig::SetMinosErrors. bool IsBinFit() const. query if fit is binned. In cse of false teh fit can be unbinned; or is not defined (like in case of fitting through a ::FitFCN). { return fBinFit; }. ROOT::Math::Minimizer * GetMinimizer() const. return pointer to last used minimizer; (is NULL in case fit is not yet done); This pointer will be valid as far as the data, the objective function; and the fitter class have not been deleted.; To be used only",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:11758,Availability,Error,Errors,11758,"ented by a multi-dimensional gradient function interface; (ROOT::Math::IMultiGenFunction) and optionally the initial parameters; See also note above for the initial parameters for FitFCN. bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). bool EvalFCN(). Perform a simple FCN evaluation. FitResult will be modified and contain the value of the FCN. bool LinearFit(const ROOT::Fit::BinData& data). do a linear fit on a set of bin-data. { return DoLinearFit(data); }. void SetFunction(const IModelFunction & func, bool useGradient = false). Set the fitted function (model function) from a parametric function interface. void SetFunction(const IModel1DFunction & func, bool useGradient = false). Set the fitted function from a parametric 1D function interface. bool CalculateHessErrors(). perform an error analysis on the result using the Hessian; Errors are obtaied from the inverse of the Hessian matrix; To be called only after fitting and when a minimizer supporting the Hessian calculations is used; otherwise an error (false) is returned.; A new FitResult with the Hessian result will be produced. bool CalculateMinosErrors(). perform an error analysis on the result using MINOS; To be called only after fitting and when a minimizer supporting MINOS is used; otherwise an error (false) is returned.; The result will be appended in the fit result class; Optionally a vector of parameter indeces can be passed for selecting; the parameters to analyse using FitConfig::SetMinosErrors. bool IsBinFit() const. query if fit is binned. In cse of false teh fit can be unbinned; or is not defined (like in case of fitting through a ::FitFCN). { return fBinFit; }. ROOT::Math::Minimizer * GetMinimizer() const. return pointer to last used minimizer; (is NULL in case fit is not yet done); This pointer will be valid as far as the data, the objective function; and the fitter class have not been deleted.; To be used only",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:11928,Availability,error,error,11928,"ented by a multi-dimensional gradient function interface; (ROOT::Math::IMultiGenFunction) and optionally the initial parameters; See also note above for the initial parameters for FitFCN. bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). bool EvalFCN(). Perform a simple FCN evaluation. FitResult will be modified and contain the value of the FCN. bool LinearFit(const ROOT::Fit::BinData& data). do a linear fit on a set of bin-data. { return DoLinearFit(data); }. void SetFunction(const IModelFunction & func, bool useGradient = false). Set the fitted function (model function) from a parametric function interface. void SetFunction(const IModel1DFunction & func, bool useGradient = false). Set the fitted function from a parametric 1D function interface. bool CalculateHessErrors(). perform an error analysis on the result using the Hessian; Errors are obtaied from the inverse of the Hessian matrix; To be called only after fitting and when a minimizer supporting the Hessian calculations is used; otherwise an error (false) is returned.; A new FitResult with the Hessian result will be produced. bool CalculateMinosErrors(). perform an error analysis on the result using MINOS; To be called only after fitting and when a minimizer supporting MINOS is used; otherwise an error (false) is returned.; The result will be appended in the fit result class; Optionally a vector of parameter indeces can be passed for selecting; the parameters to analyse using FitConfig::SetMinosErrors. bool IsBinFit() const. query if fit is binned. In cse of false teh fit can be unbinned; or is not defined (like in case of fitting through a ::FitFCN). { return fBinFit; }. ROOT::Math::Minimizer * GetMinimizer() const. return pointer to last used minimizer; (is NULL in case fit is not yet done); This pointer will be valid as far as the data, the objective function; and the fitter class have not been deleted.; To be used only",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:12054,Availability,error,error,12054," bool chi2fit = false). bool EvalFCN(). Perform a simple FCN evaluation. FitResult will be modified and contain the value of the FCN. bool LinearFit(const ROOT::Fit::BinData& data). do a linear fit on a set of bin-data. { return DoLinearFit(data); }. void SetFunction(const IModelFunction & func, bool useGradient = false). Set the fitted function (model function) from a parametric function interface. void SetFunction(const IModel1DFunction & func, bool useGradient = false). Set the fitted function from a parametric 1D function interface. bool CalculateHessErrors(). perform an error analysis on the result using the Hessian; Errors are obtaied from the inverse of the Hessian matrix; To be called only after fitting and when a minimizer supporting the Hessian calculations is used; otherwise an error (false) is returned.; A new FitResult with the Hessian result will be produced. bool CalculateMinosErrors(). perform an error analysis on the result using MINOS; To be called only after fitting and when a minimizer supporting MINOS is used; otherwise an error (false) is returned.; The result will be appended in the fit result class; Optionally a vector of parameter indeces can be passed for selecting; the parameters to analyse using FitConfig::SetMinosErrors. bool IsBinFit() const. query if fit is binned. In cse of false teh fit can be unbinned; or is not defined (like in case of fitting through a ::FitFCN). { return fBinFit; }. ROOT::Math::Minimizer * GetMinimizer() const. return pointer to last used minimizer; (is NULL in case fit is not yet done); This pointer will be valid as far as the data, the objective function; and the fitter class have not been deleted.; To be used only after fitting.; The pointer should not be stored and will be invalided after performing a new fitting.; In this case a new instance of ROOT::Math::Minimizer will be re-created and can be; obtained calling again GetMinimizer(). { return fMinimizer.get(); }. ROOT::Math::IMultiGenFunction * GetFCN() con",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:12188,Availability,error,error,12188," bool chi2fit = false). bool EvalFCN(). Perform a simple FCN evaluation. FitResult will be modified and contain the value of the FCN. bool LinearFit(const ROOT::Fit::BinData& data). do a linear fit on a set of bin-data. { return DoLinearFit(data); }. void SetFunction(const IModelFunction & func, bool useGradient = false). Set the fitted function (model function) from a parametric function interface. void SetFunction(const IModel1DFunction & func, bool useGradient = false). Set the fitted function from a parametric 1D function interface. bool CalculateHessErrors(). perform an error analysis on the result using the Hessian; Errors are obtaied from the inverse of the Hessian matrix; To be called only after fitting and when a minimizer supporting the Hessian calculations is used; otherwise an error (false) is returned.; A new FitResult with the Hessian result will be produced. bool CalculateMinosErrors(). perform an error analysis on the result using MINOS; To be called only after fitting and when a minimizer supporting MINOS is used; otherwise an error (false) is returned.; The result will be appended in the fit result class; Optionally a vector of parameter indeces can be passed for selecting; the parameters to analyse using FitConfig::SetMinosErrors. bool IsBinFit() const. query if fit is binned. In cse of false teh fit can be unbinned; or is not defined (like in case of fitting through a ::FitFCN). { return fBinFit; }. ROOT::Math::Minimizer * GetMinimizer() const. return pointer to last used minimizer; (is NULL in case fit is not yet done); This pointer will be valid as far as the data, the objective function; and the fitter class have not been deleted.; To be used only after fitting.; The pointer should not be stored and will be invalided after performing a new fitting.; In this case a new instance of ROOT::Math::Minimizer will be re-created and can be; obtained calling again GetMinimizer(). { return fMinimizer.get(); }. ROOT::Math::IMultiGenFunction * GetFCN() con",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:13700,Availability,error,error,13700,"e data, the objective function; and the fitter class have not been deleted.; To be used only after fitting.; The pointer should not be stored and will be invalided after performing a new fitting.; In this case a new instance of ROOT::Math::Minimizer will be re-created and can be; obtained calling again GetMinimizer(). { return fMinimizer.get(); }. ROOT::Math::IMultiGenFunction * GetFCN() const. return pointer to last used objective function; (is NULL in case fit is not yet done); This pointer will be valid as far as the data and the fitter class; have not been deleted. To be used after the fitting.; The pointer should not be stored and will be invalided after performing a new fitting.; In this case a new instance of the function pointer will be re-created and can be; obtained calling again GetFCN(). { return fObjFunction.get(); }. bool ApplyWeightCorrection(const ROOT::Math::IMultiGenFunction& loglw2, bool minimizeW2L = false). apply correction in the error matrix for the weights for likelihood fits; This method can be called only after a fit. The; passed function (loglw2) is a log-likelihood function impelemented using the; sum of weight squared; When using FitConfig.SetWeightCorrection() this correction is applied; automatically when doing a likelihood fit (binned or unbinned). bool DoLinearFit(const ROOT::Fit::BinData& data); linear least square fit. bool DoInitMinimizer(); initialize the minimizer. bool DoMinimization(const ROOT::Fit::Fitter::BaseFunc& f, const ROOT::Math::IMultiGenFunction* chifunc = 0); do minimization. bool DoMinimization(const ROOT::Math::IMultiGenFunction* chifunc = 0); do minimization after having set obj function. void DoUpdateFitConfig(); update config after fit. int GetNCallsFromFCN(); get function calls from the FCN. void DoSetFunction(const IModel1DFunction & func, bool useGrad); set 1D function. void DoSetFunction(const IModelFunction & func, bool useGrad); set generic N-d function.  Author: L. Moneta Wed Aug 30 11:05:19 2006  Copy",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:589,Deployability,configurat,configuration,589,". ROOT::Fit::Fitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::Fitter. class ROOT::Fit::Fitter. Fitter class, entry point for performing all type of fits.; Fits are performed using the generic ROOT::Fit::Fitter::Fit method.; The inputs are the data points and a model function (using a ROOT::Math::IParamFunction); The result of the fit is returned and kept internally in the ROOT::Fit::FitResult class.; The configuration of the fit (parameters, options, etc...) are specified in the; ROOT::Math::FitConfig class.; After fitting the config of the fit will be modified to have the new values the resulting; parameter of the fit with step sizes equal to the errors. FitConfig can be preserved with; initial parameters by calling FitConfig.SetUpdateAfterFit(false);. @ingroup FitMain. Function Members (Methods); public:. ~Fitter(); boolApplyWeightCorrection(const ROOT::Math::IMultiGenFunction& loglw2, bool minimizeW2L = false); boolCalculateHessErrors(); boolCalculateMinosErrors(); const ROOT::Fit::FitConfig&Config() const; ROOT::Fit::FitConfig&Config(); boolEvalFCN(); boolFit(const ROOT::Fit::BinData& data); boolFit(const ROOT::Fit::UnBinData& data, bool extended = false); boolFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricFunctionMultiDim& func); boolFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricFunctionMultiDim& func); boolFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func); boolFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func); boolFitFCN(); boolFitFCN(const ROOT::Math::FitMethodFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params =",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:5163,Deployability,configurat,configuration,5163,"kelihoodFit(const ROOT::Fit::UnBinData& data, bool extended = false); boolDoLinearFit(const ROOT::Fit::BinData& data); boolDoMinimization(const ROOT::Math::IMultiGenFunction* chifunc = 0); boolDoMinimization(const ROOT::Fit::Fitter::BaseFunc& f, const ROOT::Math::IMultiGenFunction* chifunc = 0); voidDoSetFunction(const ROOT::Fit::Fitter::IModel1DFunction& func, bool useGrad); voidDoSetFunction(const ROOT::Fit::Fitter::IModelFunction& func, bool useGrad); voidDoUpdateFitConfig(); intGetNCallsFromFCN(). private:. ROOT::Fit::FitterFitter(const ROOT::Fit::Fitter&); ROOT::Fit::Fitter&operator=(const ROOT::Fit::Fitter& rhs). Data Members; private:. boolfBinFitflag to indicate if fit is binned ; ROOT::Fit::FitConfigfConfigfitter configuration (options and parameter settings); intfDataSizesize of data sets (need for Fumili or LM fitters); intfFitTypetype of fit (0 undefined, 1 least square, 2 likelihood); ROOT::Fit::Fitter::IModelFunction*fFunccopy of the fitted function containing on output the fit result (managed by FitResult); auto_ptr<ROOT::Math::Minimizer>fMinimizer! pointer to used minimizer; auto_ptr<ROOT::Math::IMultiGenFunction>fObjFunction! pointer to used objective function; auto_ptr<ROOT::Fit::FitResult>fResult! pointer to the object containing the result of the fit; boolfUseGradientflag to indicate if using gradient or not. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). bool SetFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fitter(). Default constructor. ~Fitter(). Destructor. Fitter(const ROOT::Fit::Fitter& ). Copy constructor (disabled, class is not copyable). bool Fit( const Data & data, const Function & func ). fit a data set using any generic model function; If data set is binned a least square f",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:14430,Deployability,update,update,14430," return fMinimizer.get(); }. ROOT::Math::IMultiGenFunction * GetFCN() const. return pointer to last used objective function; (is NULL in case fit is not yet done); This pointer will be valid as far as the data and the fitter class; have not been deleted. To be used after the fitting.; The pointer should not be stored and will be invalided after performing a new fitting.; In this case a new instance of the function pointer will be re-created and can be; obtained calling again GetFCN(). { return fObjFunction.get(); }. bool ApplyWeightCorrection(const ROOT::Math::IMultiGenFunction& loglw2, bool minimizeW2L = false). apply correction in the error matrix for the weights for likelihood fits; This method can be called only after a fit. The; passed function (loglw2) is a log-likelihood function impelemented using the; sum of weight squared; When using FitConfig.SetWeightCorrection() this correction is applied; automatically when doing a likelihood fit (binned or unbinned). bool DoLinearFit(const ROOT::Fit::BinData& data); linear least square fit. bool DoInitMinimizer(); initialize the minimizer. bool DoMinimization(const ROOT::Fit::Fitter::BaseFunc& f, const ROOT::Math::IMultiGenFunction* chifunc = 0); do minimization. bool DoMinimization(const ROOT::Math::IMultiGenFunction* chifunc = 0); do minimization after having set obj function. void DoUpdateFitConfig(); update config after fit. int GetNCallsFromFCN(); get function calls from the FCN. void DoSetFunction(const IModel1DFunction & func, bool useGrad); set 1D function. void DoSetFunction(const IModelFunction & func, bool useGrad); set generic N-d function.  Author: L. Moneta Wed Aug 30 11:05:19 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: Fitter.h 42202 2011-11-23 17:07:20Z moneta $  Last generated: 2011-12-02 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:6618,Integrability,interface,interface,6618,"ath::Minimizer>fMinimizer! pointer to used minimizer; auto_ptr<ROOT::Math::IMultiGenFunction>fObjFunction! pointer to used objective function; auto_ptr<ROOT::Fit::FitResult>fResult! pointer to the object containing the result of the fit; boolfUseGradientflag to indicate if using gradient or not. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). bool SetFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fitter(). Default constructor. ~Fitter(). Destructor. Fitter(const ROOT::Fit::Fitter& ). Copy constructor (disabled, class is not copyable). bool Fit( const Data & data, const Function & func ). fit a data set using any generic model function; If data set is binned a least square fit is performed; If data set is unbinned a maximum likelihood fit (not extended) is done; Pre-requisite on the function:; it must implement the 1D or multidimensional parametric function interface. SetFunction(func). return Fit(const ROOT::Fit::BinData& data). bool Fit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit (default method). return DoLeastSquareFit(const ROOT::Fit::BinData& data). bool LeastSquareFit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit. bool Fit(const ROOT::Fit::UnBinData& data, bool extended = false). fit an unbinned data set using loglikelihood method. return DoLikelihoodFit(data, extended). bool LikelihoodFit(const Data & data ). Likelihood fit (unbinned or unbinned) depending on the type of data; If Binned default is extended; If Unbinned defult is NOT extended (for backward compatibility). return DoLikelihoodFit(data). bool LikelihoodFit(const Data & data, bool extended ). Likelihood fit using extended or not extended method. bool LikelihoodFit( const",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:7195,Integrability,depend,depending,7195,"Copy constructor (disabled, class is not copyable). bool Fit( const Data & data, const Function & func ). fit a data set using any generic model function; If data set is binned a least square fit is performed; If data set is unbinned a maximum likelihood fit (not extended) is done; Pre-requisite on the function:; it must implement the 1D or multidimensional parametric function interface. SetFunction(func). return Fit(const ROOT::Fit::BinData& data). bool Fit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit (default method). return DoLeastSquareFit(const ROOT::Fit::BinData& data). bool LeastSquareFit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit. bool Fit(const ROOT::Fit::UnBinData& data, bool extended = false). fit an unbinned data set using loglikelihood method. return DoLikelihoodFit(data, extended). bool LikelihoodFit(const Data & data ). Likelihood fit (unbinned or unbinned) depending on the type of data; If Binned default is extended; If Unbinned defult is NOT extended (for backward compatibility). return DoLikelihoodFit(data). bool LikelihoodFit(const Data & data, bool extended ). Likelihood fit using extended or not extended method. bool LikelihoodFit( const Data & data, const Function & func, bool extended). fit a data set using any generic model function; Pre-requisite on the function:. SetFunction(func). bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fit using the a generic FCN function as a C++ callable object implementing; double () (const double *); Note that the function dimension (i.e. the number of parameter) is needed in this case; For the options see documentation for following methods FitFCN(IMultiGenFunction & fcn,..). bool SetFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Set a generic FCN function as a C++ call",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:8680,Integrability,interface,interface,8680,"Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fit using the a generic FCN function as a C++ callable object implementing; double () (const double *); Note that the function dimension (i.e. the number of parameter) is needed in this case; For the options see documentation for following methods FitFCN(IMultiGenFunction & fcn,..). bool SetFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Set a generic FCN function as a C++ callable object implementing; double () (const double *); Note that the function dimension (i.e. the number of parameter) is needed in this case; For the options see documentation for following methods FitFCN(IMultiGenFunction & fcn,..). bool FitFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fit using the given FCN function represented by a multi-dimensional function interface; (ROOT::Math::IMultiGenFunction).; Give optionally the initial arameter values, data size to have the fit Ndf correctly; set in the FitResult and flag specifying if it is a chi2 fit.; Note that if the parameters values are not given (params=0) the; current parameter settings are used. The parameter settings can be created before; by using the FitConfig::SetParamsSetting. If they have not been created they are created; automatically when the params pointer is not zero.; Note that passing a params != 0 will set the parameter settings to the new value AND also the; step sizes to some pre-defined value (stepsize = 0.3 * abs(parameter_value) ). bool SetFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fit using a FitMethodFunction interface. Same as method above, but now extra information; can be taken from the function class. Set the FCN function represented by a multi-dimensional function in",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:9498,Integrability,interface,interface,9498,"nst ROOT::Math::IMultiGenFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fit using the given FCN function represented by a multi-dimensional function interface; (ROOT::Math::IMultiGenFunction).; Give optionally the initial arameter values, data size to have the fit Ndf correctly; set in the FitResult and flag specifying if it is a chi2 fit.; Note that if the parameters values are not given (params=0) the; current parameter settings are used. The parameter settings can be created before; by using the FitConfig::SetParamsSetting. If they have not been created they are created; automatically when the params pointer is not zero.; Note that passing a params != 0 will set the parameter settings to the new value AND also the; step sizes to some pre-defined value (stepsize = 0.3 * abs(parameter_value) ). bool SetFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fit using a FitMethodFunction interface. Same as method above, but now extra information; can be taken from the function class. Set the FCN function represented by a multi-dimensional function interface; (ROOT::Math::IMultiGenFunction) and optionally the initial parameters; See also note above for the initial parameters for FitFCN. bool SetFCN(const ROOT::Math::FitMethodFunction& fcn, const double* params = 0). Set the objective function (FCN) using a FitMethodFunction interface.; Same as method above, but now extra information can be taken from the function class. bool FitFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fit using the given FCN function representing a multi-dimensional gradient function; interface (ROOT::Math::IMultiGradFunction). In this case the minimizer will use the; gradient information provided by the function.; For the options same consideration as in the previous method. bool FitFCN(const ROOT::Math::FitMeth",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:9661,Integrability,interface,interface,9661,"Math::IMultiGenFunction).; Give optionally the initial arameter values, data size to have the fit Ndf correctly; set in the FitResult and flag specifying if it is a chi2 fit.; Note that if the parameters values are not given (params=0) the; current parameter settings are used. The parameter settings can be created before; by using the FitConfig::SetParamsSetting. If they have not been created they are created; automatically when the params pointer is not zero.; Note that passing a params != 0 will set the parameter settings to the new value AND also the; step sizes to some pre-defined value (stepsize = 0.3 * abs(parameter_value) ). bool SetFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fit using a FitMethodFunction interface. Same as method above, but now extra information; can be taken from the function class. Set the FCN function represented by a multi-dimensional function interface; (ROOT::Math::IMultiGenFunction) and optionally the initial parameters; See also note above for the initial parameters for FitFCN. bool SetFCN(const ROOT::Math::FitMethodFunction& fcn, const double* params = 0). Set the objective function (FCN) using a FitMethodFunction interface.; Same as method above, but now extra information can be taken from the function class. bool FitFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fit using the given FCN function representing a multi-dimensional gradient function; interface (ROOT::Math::IMultiGradFunction). In this case the minimizer will use the; gradient information provided by the function.; For the options same consideration as in the previous method. bool FitFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0). Fit using a FitMethodGradFunction interface. Same as method above, but now extra information; can be taken from the function class. bool SetFCN(const ROOT::Math::",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:9942,Integrability,interface,interface,9942,"given (params=0) the; current parameter settings are used. The parameter settings can be created before; by using the FitConfig::SetParamsSetting. If they have not been created they are created; automatically when the params pointer is not zero.; Note that passing a params != 0 will set the parameter settings to the new value AND also the; step sizes to some pre-defined value (stepsize = 0.3 * abs(parameter_value) ). bool SetFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fit using a FitMethodFunction interface. Same as method above, but now extra information; can be taken from the function class. Set the FCN function represented by a multi-dimensional function interface; (ROOT::Math::IMultiGenFunction) and optionally the initial parameters; See also note above for the initial parameters for FitFCN. bool SetFCN(const ROOT::Math::FitMethodFunction& fcn, const double* params = 0). Set the objective function (FCN) using a FitMethodFunction interface.; Same as method above, but now extra information can be taken from the function class. bool FitFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fit using the given FCN function representing a multi-dimensional gradient function; interface (ROOT::Math::IMultiGradFunction). In this case the minimizer will use the; gradient information provided by the function.; For the options same consideration as in the previous method. bool FitFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0). Fit using a FitMethodGradFunction interface. Same as method above, but now extra information; can be taken from the function class. bool SetFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Set the FCN function represented by a multi-dimensional gradient function interface; (ROOT::Math::IMultiGenFunction) a",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:10256,Integrability,interface,interface,10256," new value AND also the; step sizes to some pre-defined value (stepsize = 0.3 * abs(parameter_value) ). bool SetFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fit using a FitMethodFunction interface. Same as method above, but now extra information; can be taken from the function class. Set the FCN function represented by a multi-dimensional function interface; (ROOT::Math::IMultiGenFunction) and optionally the initial parameters; See also note above for the initial parameters for FitFCN. bool SetFCN(const ROOT::Math::FitMethodFunction& fcn, const double* params = 0). Set the objective function (FCN) using a FitMethodFunction interface.; Same as method above, but now extra information can be taken from the function class. bool FitFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fit using the given FCN function representing a multi-dimensional gradient function; interface (ROOT::Math::IMultiGradFunction). In this case the minimizer will use the; gradient information provided by the function.; For the options same consideration as in the previous method. bool FitFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0). Fit using a FitMethodGradFunction interface. Same as method above, but now extra information; can be taken from the function class. bool SetFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Set the FCN function represented by a multi-dimensional gradient function interface; (ROOT::Math::IMultiGenFunction) and optionally the initial parameters; See also note above for the initial parameters for FitFCN. bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). bool EvalFCN(). Perform a simple FCN evaluation. FitResult will be modified and con",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:10570,Integrability,interface,interface,10570," can be taken from the function class. Set the FCN function represented by a multi-dimensional function interface; (ROOT::Math::IMultiGenFunction) and optionally the initial parameters; See also note above for the initial parameters for FitFCN. bool SetFCN(const ROOT::Math::FitMethodFunction& fcn, const double* params = 0). Set the objective function (FCN) using a FitMethodFunction interface.; Same as method above, but now extra information can be taken from the function class. bool FitFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fit using the given FCN function representing a multi-dimensional gradient function; interface (ROOT::Math::IMultiGradFunction). In this case the minimizer will use the; gradient information provided by the function.; For the options same consideration as in the previous method. bool FitFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0). Fit using a FitMethodGradFunction interface. Same as method above, but now extra information; can be taken from the function class. bool SetFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Set the FCN function represented by a multi-dimensional gradient function interface; (ROOT::Math::IMultiGenFunction) and optionally the initial parameters; See also note above for the initial parameters for FitFCN. bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). bool EvalFCN(). Perform a simple FCN evaluation. FitResult will be modified and contain the value of the FCN. bool LinearFit(const ROOT::Fit::BinData& data). do a linear fit on a set of bin-data. { return DoLinearFit(data); }. void SetFunction(const IModelFunction & func, bool useGradient = false). Set the fitted function (model function) from a parametric function interface. void SetFunction(const IMod",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:10873,Integrability,interface,interface,10873,"tion (FCN) using a FitMethodFunction interface.; Same as method above, but now extra information can be taken from the function class. bool FitFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fit using the given FCN function representing a multi-dimensional gradient function; interface (ROOT::Math::IMultiGradFunction). In this case the minimizer will use the; gradient information provided by the function.; For the options same consideration as in the previous method. bool FitFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0). Fit using a FitMethodGradFunction interface. Same as method above, but now extra information; can be taken from the function class. bool SetFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Set the FCN function represented by a multi-dimensional gradient function interface; (ROOT::Math::IMultiGenFunction) and optionally the initial parameters; See also note above for the initial parameters for FitFCN. bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). bool EvalFCN(). Perform a simple FCN evaluation. FitResult will be modified and contain the value of the FCN. bool LinearFit(const ROOT::Fit::BinData& data). do a linear fit on a set of bin-data. { return DoLinearFit(data); }. void SetFunction(const IModelFunction & func, bool useGradient = false). Set the fitted function (model function) from a parametric function interface. void SetFunction(const IModel1DFunction & func, bool useGradient = false). Set the fitted function from a parametric 1D function interface. bool CalculateHessErrors(). perform an error analysis on the result using the Hessian; Errors are obtaied from the inverse of the Hessian matrix; To be called only after fitting and when a minimizer supporting the Hessian calculations ",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:11520,Integrability,interface,interface,11520,"GradFunction& fcn, const double* params = 0). Fit using a FitMethodGradFunction interface. Same as method above, but now extra information; can be taken from the function class. bool SetFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Set the FCN function represented by a multi-dimensional gradient function interface; (ROOT::Math::IMultiGenFunction) and optionally the initial parameters; See also note above for the initial parameters for FitFCN. bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). bool EvalFCN(). Perform a simple FCN evaluation. FitResult will be modified and contain the value of the FCN. bool LinearFit(const ROOT::Fit::BinData& data). do a linear fit on a set of bin-data. { return DoLinearFit(data); }. void SetFunction(const IModelFunction & func, bool useGradient = false). Set the fitted function (model function) from a parametric function interface. void SetFunction(const IModel1DFunction & func, bool useGradient = false). Set the fitted function from a parametric 1D function interface. bool CalculateHessErrors(). perform an error analysis on the result using the Hessian; Errors are obtaied from the inverse of the Hessian matrix; To be called only after fitting and when a minimizer supporting the Hessian calculations is used; otherwise an error (false) is returned.; A new FitResult with the Hessian result will be produced. bool CalculateMinosErrors(). perform an error analysis on the result using MINOS; To be called only after fitting and when a minimizer supporting MINOS is used; otherwise an error (false) is returned.; The result will be appended in the fit result class; Optionally a vector of parameter indeces can be passed for selecting; the parameters to analyse using FitConfig::SetMinosErrors. bool IsBinFit() const. query if fit is binned. In cse of false teh fit can be unbinned; or is",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:11660,Integrability,interface,interface,11660,"taken from the function class. bool SetFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Set the FCN function represented by a multi-dimensional gradient function interface; (ROOT::Math::IMultiGenFunction) and optionally the initial parameters; See also note above for the initial parameters for FitFCN. bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). bool EvalFCN(). Perform a simple FCN evaluation. FitResult will be modified and contain the value of the FCN. bool LinearFit(const ROOT::Fit::BinData& data). do a linear fit on a set of bin-data. { return DoLinearFit(data); }. void SetFunction(const IModelFunction & func, bool useGradient = false). Set the fitted function (model function) from a parametric function interface. void SetFunction(const IModel1DFunction & func, bool useGradient = false). Set the fitted function from a parametric 1D function interface. bool CalculateHessErrors(). perform an error analysis on the result using the Hessian; Errors are obtaied from the inverse of the Hessian matrix; To be called only after fitting and when a minimizer supporting the Hessian calculations is used; otherwise an error (false) is returned.; A new FitResult with the Hessian result will be produced. bool CalculateMinosErrors(). perform an error analysis on the result using MINOS; To be called only after fitting and when a minimizer supporting MINOS is used; otherwise an error (false) is returned.; The result will be appended in the fit result class; Optionally a vector of parameter indeces can be passed for selecting; the parameters to analyse using FitConfig::SetMinosErrors. bool IsBinFit() const. query if fit is binned. In cse of false teh fit can be unbinned; or is not defined (like in case of fitting through a ::FitFCN). { return fBinFit; }. ROOT::Math::Minimizer * GetMinimizer() const. return pointer to las",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:589,Modifiability,config,configuration,589,". ROOT::Fit::Fitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::Fitter. class ROOT::Fit::Fitter. Fitter class, entry point for performing all type of fits.; Fits are performed using the generic ROOT::Fit::Fitter::Fit method.; The inputs are the data points and a model function (using a ROOT::Math::IParamFunction); The result of the fit is returned and kept internally in the ROOT::Fit::FitResult class.; The configuration of the fit (parameters, options, etc...) are specified in the; ROOT::Math::FitConfig class.; After fitting the config of the fit will be modified to have the new values the resulting; parameter of the fit with step sizes equal to the errors. FitConfig can be preserved with; initial parameters by calling FitConfig.SetUpdateAfterFit(false);. @ingroup FitMain. Function Members (Methods); public:. ~Fitter(); boolApplyWeightCorrection(const ROOT::Math::IMultiGenFunction& loglw2, bool minimizeW2L = false); boolCalculateHessErrors(); boolCalculateMinosErrors(); const ROOT::Fit::FitConfig&Config() const; ROOT::Fit::FitConfig&Config(); boolEvalFCN(); boolFit(const ROOT::Fit::BinData& data); boolFit(const ROOT::Fit::UnBinData& data, bool extended = false); boolFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricFunctionMultiDim& func); boolFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricFunctionMultiDim& func); boolFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func); boolFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func); boolFitFCN(); boolFitFCN(const ROOT::Math::FitMethodFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params =",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:714,Modifiability,config,config,714,". ROOT::Fit::Fitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::Fitter. class ROOT::Fit::Fitter. Fitter class, entry point for performing all type of fits.; Fits are performed using the generic ROOT::Fit::Fitter::Fit method.; The inputs are the data points and a model function (using a ROOT::Math::IParamFunction); The result of the fit is returned and kept internally in the ROOT::Fit::FitResult class.; The configuration of the fit (parameters, options, etc...) are specified in the; ROOT::Math::FitConfig class.; After fitting the config of the fit will be modified to have the new values the resulting; parameter of the fit with step sizes equal to the errors. FitConfig can be preserved with; initial parameters by calling FitConfig.SetUpdateAfterFit(false);. @ingroup FitMain. Function Members (Methods); public:. ~Fitter(); boolApplyWeightCorrection(const ROOT::Math::IMultiGenFunction& loglw2, bool minimizeW2L = false); boolCalculateHessErrors(); boolCalculateMinosErrors(); const ROOT::Fit::FitConfig&Config() const; ROOT::Fit::FitConfig&Config(); boolEvalFCN(); boolFit(const ROOT::Fit::BinData& data); boolFit(const ROOT::Fit::UnBinData& data, bool extended = false); boolFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricFunctionMultiDim& func); boolFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricFunctionMultiDim& func); boolFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func); boolFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func); boolFitFCN(); boolFitFCN(const ROOT::Math::FitMethodFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params =",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:1191,Modifiability,Config,Config,1191," ~Fitter(); boolApplyWeightCorrection(const ROOT::Math::IMultiGenFunction& loglw2, bool minimizeW2L = false); boolCalculateHessErrors(); boolCalculateMinosErrors(); const ROOT::Fit::FitConfig&Config() const; ROOT::Fit::FitConfig&Config(); boolEvalFCN(); boolFit(const ROOT::Fit::BinData& data); boolFit(const ROOT::Fit::UnBinData& data, bool extended = false); boolFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricFunctionMultiDim& func); boolFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricFunctionMultiDim& func); boolFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func); boolFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func); boolFitFCN(); boolFitFCN(const ROOT::Math::FitMethodFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params =",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:1228,Modifiability,Config,Config,1228," ~Fitter(); boolApplyWeightCorrection(const ROOT::Math::IMultiGenFunction& loglw2, bool minimizeW2L = false); boolCalculateHessErrors(); boolCalculateMinosErrors(); const ROOT::Fit::FitConfig&Config() const; ROOT::Fit::FitConfig&Config(); boolEvalFCN(); boolFit(const ROOT::Fit::BinData& data); boolFit(const ROOT::Fit::UnBinData& data, bool extended = false); boolFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricFunctionMultiDim& func); boolFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricFunctionMultiDim& func); boolFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func); boolFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func); boolFitFCN(); boolFitFCN(const ROOT::Math::FitMethodFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params =",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:1341,Modifiability,extend,extended,1341," ~Fitter(); boolApplyWeightCorrection(const ROOT::Math::IMultiGenFunction& loglw2, bool minimizeW2L = false); boolCalculateHessErrors(); boolCalculateMinosErrors(); const ROOT::Fit::FitConfig&Config() const; ROOT::Fit::FitConfig&Config(); boolEvalFCN(); boolFit(const ROOT::Fit::BinData& data); boolFit(const ROOT::Fit::UnBinData& data, bool extended = false); boolFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricFunctionMultiDim& func); boolFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricFunctionMultiDim& func); boolFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func); boolFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func); boolFitFCN(); boolFitFCN(const ROOT::Math::FitMethodFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params =",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:2672,Modifiability,extend,extended,2672,"inData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func); boolFitFCN(); boolFitFCN(const ROOT::Math::FitMethodFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolFitFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolFitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); ROOT::Fit::FitterFitter(); ROOT::Math::IMultiGenFunction*GetFCN() const; ROOT::Math::Minimizer*GetMinimizer() const; boolIsBinFit() const; boolLeastSquareFit(const ROOT::Fit::BinData& data); boolLikelihoodFit(const ROOT::Fit::BinData& data); boolLikelihoodFit(const ROOT::Fit::UnBinData& data); boolLikelihoodFit(const ROOT::Fit::BinData& data, bool extended); boolLikelihoodFit(const ROOT::Fit::UnBinData& data, bool extended); boolLikelihoodFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricFunctionMultiDim& func, bool extended); boolLikelihoodFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricFunctionMultiDim& func, bool extended); boolLikelihoodFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func, bool extended); boolLikelihoodFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func, bool extended); boolLinearFit(const ROOT::Fit::BinData& data); const ROOT::Fit::FitResult&Result() const; boolSetFCN(const ROOT::Math::FitMethodFunction& fcn, const double* params = 0); boolSetFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0); boolSetFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolSetFCN(const ROOT::Math::IMultiGradFunction& fcn, c",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:2740,Modifiability,extend,extended,2740,"c); boolFitFCN(); boolFitFCN(const ROOT::Math::FitMethodFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolFitFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolFitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); ROOT::Fit::FitterFitter(); ROOT::Math::IMultiGenFunction*GetFCN() const; ROOT::Math::Minimizer*GetMinimizer() const; boolIsBinFit() const; boolLeastSquareFit(const ROOT::Fit::BinData& data); boolLikelihoodFit(const ROOT::Fit::BinData& data); boolLikelihoodFit(const ROOT::Fit::UnBinData& data); boolLikelihoodFit(const ROOT::Fit::BinData& data, bool extended); boolLikelihoodFit(const ROOT::Fit::UnBinData& data, bool extended); boolLikelihoodFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricFunctionMultiDim& func, bool extended); boolLikelihoodFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricFunctionMultiDim& func, bool extended); boolLikelihoodFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func, bool extended); boolLikelihoodFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func, bool extended); boolLinearFit(const ROOT::Fit::BinData& data); const ROOT::Fit::FitResult&Result() const; boolSetFCN(const ROOT::Math::FitMethodFunction& fcn, const double* params = 0); boolSetFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0); boolSetFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolSetFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = f",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:2859,Modifiability,extend,extended,2859,"::Math::FitMethodGradFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolFitFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolFitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); ROOT::Fit::FitterFitter(); ROOT::Math::IMultiGenFunction*GetFCN() const; ROOT::Math::Minimizer*GetMinimizer() const; boolIsBinFit() const; boolLeastSquareFit(const ROOT::Fit::BinData& data); boolLikelihoodFit(const ROOT::Fit::BinData& data); boolLikelihoodFit(const ROOT::Fit::UnBinData& data); boolLikelihoodFit(const ROOT::Fit::BinData& data, bool extended); boolLikelihoodFit(const ROOT::Fit::UnBinData& data, bool extended); boolLikelihoodFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricFunctionMultiDim& func, bool extended); boolLikelihoodFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricFunctionMultiDim& func, bool extended); boolLikelihoodFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func, bool extended); boolLikelihoodFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func, bool extended); boolLinearFit(const ROOT::Fit::BinData& data); const ROOT::Fit::FitResult&Result() const; boolSetFCN(const ROOT::Math::FitMethodFunction& fcn, const double* params = 0); boolSetFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0); boolSetFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolSetFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolSetFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:2980,Modifiability,extend,extended,2980," double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolFitFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolFitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); ROOT::Fit::FitterFitter(); ROOT::Math::IMultiGenFunction*GetFCN() const; ROOT::Math::Minimizer*GetMinimizer() const; boolIsBinFit() const; boolLeastSquareFit(const ROOT::Fit::BinData& data); boolLikelihoodFit(const ROOT::Fit::BinData& data); boolLikelihoodFit(const ROOT::Fit::UnBinData& data); boolLikelihoodFit(const ROOT::Fit::BinData& data, bool extended); boolLikelihoodFit(const ROOT::Fit::UnBinData& data, bool extended); boolLikelihoodFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricFunctionMultiDim& func, bool extended); boolLikelihoodFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricFunctionMultiDim& func, bool extended); boolLikelihoodFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func, bool extended); boolLikelihoodFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func, bool extended); boolLinearFit(const ROOT::Fit::BinData& data); const ROOT::Fit::FitResult&Result() const; boolSetFCN(const ROOT::Math::FitMethodFunction& fcn, const double* params = 0); boolSetFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0); boolSetFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolSetFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolSetFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); voidSetFunction(const ROOT::Fit::Fitter::IModelFunction& func, bool useGradient = false); voidSe",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:3103,Modifiability,extend,extended,3103,", const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolFitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); ROOT::Fit::FitterFitter(); ROOT::Math::IMultiGenFunction*GetFCN() const; ROOT::Math::Minimizer*GetMinimizer() const; boolIsBinFit() const; boolLeastSquareFit(const ROOT::Fit::BinData& data); boolLikelihoodFit(const ROOT::Fit::BinData& data); boolLikelihoodFit(const ROOT::Fit::UnBinData& data); boolLikelihoodFit(const ROOT::Fit::BinData& data, bool extended); boolLikelihoodFit(const ROOT::Fit::UnBinData& data, bool extended); boolLikelihoodFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricFunctionMultiDim& func, bool extended); boolLikelihoodFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricFunctionMultiDim& func, bool extended); boolLikelihoodFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func, bool extended); boolLikelihoodFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func, bool extended); boolLinearFit(const ROOT::Fit::BinData& data); const ROOT::Fit::FitResult&Result() const; boolSetFCN(const ROOT::Math::FitMethodFunction& fcn, const double* params = 0); boolSetFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0); boolSetFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolSetFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolSetFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); voidSetFunction(const ROOT::Fit::Fitter::IModelFunction& func, bool useGradient = false); voidSetFunction(const ROOT::Fit::Fitter::IModel1DFunction& func, bool useGradient = false); voidSetFunction(const ROOT::Fit::Fitt",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:3228,Modifiability,extend,extended,3228,"int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); ROOT::Fit::FitterFitter(); ROOT::Math::IMultiGenFunction*GetFCN() const; ROOT::Math::Minimizer*GetMinimizer() const; boolIsBinFit() const; boolLeastSquareFit(const ROOT::Fit::BinData& data); boolLikelihoodFit(const ROOT::Fit::BinData& data); boolLikelihoodFit(const ROOT::Fit::UnBinData& data); boolLikelihoodFit(const ROOT::Fit::BinData& data, bool extended); boolLikelihoodFit(const ROOT::Fit::UnBinData& data, bool extended); boolLikelihoodFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricFunctionMultiDim& func, bool extended); boolLikelihoodFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricFunctionMultiDim& func, bool extended); boolLikelihoodFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func, bool extended); boolLikelihoodFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func, bool extended); boolLinearFit(const ROOT::Fit::BinData& data); const ROOT::Fit::FitResult&Result() const; boolSetFCN(const ROOT::Math::FitMethodFunction& fcn, const double* params = 0); boolSetFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0); boolSetFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolSetFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolSetFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); voidSetFunction(const ROOT::Fit::Fitter::IModelFunction& func, bool useGradient = false); voidSetFunction(const ROOT::Fit::Fitter::IModel1DFunction& func, bool useGradient = false); voidSetFunction(const ROOT::Fit::Fitter::IGradModelFunction& func, bool useGradient = true); voidSetFunction(const ROOT::Fit::Fitter::IGradModel1DFunction& func, ",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:4405,Modifiability,extend,extended,4405," chi2fit = false); boolSetFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolSetFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); voidSetFunction(const ROOT::Fit::Fitter::IModelFunction& func, bool useGradient = false); voidSetFunction(const ROOT::Fit::Fitter::IModel1DFunction& func, bool useGradient = false); voidSetFunction(const ROOT::Fit::Fitter::IGradModelFunction& func, bool useGradient = true); voidSetFunction(const ROOT::Fit::Fitter::IGradModel1DFunction& func, bool useGradient = true). protected:. boolDoInitMinimizer(); boolDoLeastSquareFit(const ROOT::Fit::BinData& data); boolDoLikelihoodFit(const ROOT::Fit::BinData& data, bool extended = true); boolDoLikelihoodFit(const ROOT::Fit::UnBinData& data, bool extended = false); boolDoLinearFit(const ROOT::Fit::BinData& data); boolDoMinimization(const ROOT::Math::IMultiGenFunction* chifunc = 0); boolDoMinimization(const ROOT::Fit::Fitter::BaseFunc& f, const ROOT::Math::IMultiGenFunction* chifunc = 0); voidDoSetFunction(const ROOT::Fit::Fitter::IModel1DFunction& func, bool useGrad); voidDoSetFunction(const ROOT::Fit::Fitter::IModelFunction& func, bool useGrad); voidDoUpdateFitConfig(); intGetNCallsFromFCN(). private:. ROOT::Fit::FitterFitter(const ROOT::Fit::Fitter&); ROOT::Fit::Fitter&operator=(const ROOT::Fit::Fitter& rhs). Data Members; private:. boolfBinFitflag to indicate if fit is binned ; ROOT::Fit::FitConfigfConfigfitter configuration (options and parameter settings); intfDataSizesize of data sets (need for Fumili or LM fitters); intfFitTypetype of fit (0 undefined, 1 least square, 2 likelihood); ROOT::Fit::Fitter::IModelFunction*fFunccopy of the fitted function containing on output the fit result (managed by FitResult); auto_ptr<ROOT::Math::Minimizer>fMinimizer! pointer to used minimizer; auto_ptr<ROOT::Math::IMultiGenFunction>fObjFunction! pointer to u",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:4482,Modifiability,extend,extended,4482," chi2fit = false); boolSetFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolSetFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); voidSetFunction(const ROOT::Fit::Fitter::IModelFunction& func, bool useGradient = false); voidSetFunction(const ROOT::Fit::Fitter::IModel1DFunction& func, bool useGradient = false); voidSetFunction(const ROOT::Fit::Fitter::IGradModelFunction& func, bool useGradient = true); voidSetFunction(const ROOT::Fit::Fitter::IGradModel1DFunction& func, bool useGradient = true). protected:. boolDoInitMinimizer(); boolDoLeastSquareFit(const ROOT::Fit::BinData& data); boolDoLikelihoodFit(const ROOT::Fit::BinData& data, bool extended = true); boolDoLikelihoodFit(const ROOT::Fit::UnBinData& data, bool extended = false); boolDoLinearFit(const ROOT::Fit::BinData& data); boolDoMinimization(const ROOT::Math::IMultiGenFunction* chifunc = 0); boolDoMinimization(const ROOT::Fit::Fitter::BaseFunc& f, const ROOT::Math::IMultiGenFunction* chifunc = 0); voidDoSetFunction(const ROOT::Fit::Fitter::IModel1DFunction& func, bool useGrad); voidDoSetFunction(const ROOT::Fit::Fitter::IModelFunction& func, bool useGrad); voidDoUpdateFitConfig(); intGetNCallsFromFCN(). private:. ROOT::Fit::FitterFitter(const ROOT::Fit::Fitter&); ROOT::Fit::Fitter&operator=(const ROOT::Fit::Fitter& rhs). Data Members; private:. boolfBinFitflag to indicate if fit is binned ; ROOT::Fit::FitConfigfConfigfitter configuration (options and parameter settings); intfDataSizesize of data sets (need for Fumili or LM fitters); intfFitTypetype of fit (0 undefined, 1 least square, 2 likelihood); ROOT::Fit::Fitter::IModelFunction*fFunccopy of the fitted function containing on output the fit result (managed by FitResult); auto_ptr<ROOT::Math::Minimizer>fMinimizer! pointer to used minimizer; auto_ptr<ROOT::Math::IMultiGenFunction>fObjFunction! pointer to u",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:5163,Modifiability,config,configuration,5163,"kelihoodFit(const ROOT::Fit::UnBinData& data, bool extended = false); boolDoLinearFit(const ROOT::Fit::BinData& data); boolDoMinimization(const ROOT::Math::IMultiGenFunction* chifunc = 0); boolDoMinimization(const ROOT::Fit::Fitter::BaseFunc& f, const ROOT::Math::IMultiGenFunction* chifunc = 0); voidDoSetFunction(const ROOT::Fit::Fitter::IModel1DFunction& func, bool useGrad); voidDoSetFunction(const ROOT::Fit::Fitter::IModelFunction& func, bool useGrad); voidDoUpdateFitConfig(); intGetNCallsFromFCN(). private:. ROOT::Fit::FitterFitter(const ROOT::Fit::Fitter&); ROOT::Fit::Fitter&operator=(const ROOT::Fit::Fitter& rhs). Data Members; private:. boolfBinFitflag to indicate if fit is binned ; ROOT::Fit::FitConfigfConfigfitter configuration (options and parameter settings); intfDataSizesize of data sets (need for Fumili or LM fitters); intfFitTypetype of fit (0 undefined, 1 least square, 2 likelihood); ROOT::Fit::Fitter::IModelFunction*fFunccopy of the fitted function containing on output the fit result (managed by FitResult); auto_ptr<ROOT::Math::Minimizer>fMinimizer! pointer to used minimizer; auto_ptr<ROOT::Math::IMultiGenFunction>fObjFunction! pointer to used objective function; auto_ptr<ROOT::Fit::FitResult>fResult! pointer to the object containing the result of the fit; boolfUseGradientflag to indicate if using gradient or not. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). bool SetFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fitter(). Default constructor. ~Fitter(). Destructor. Fitter(const ROOT::Fit::Fitter& ). Copy constructor (disabled, class is not copyable). bool Fit( const Data & data, const Function & func ). fit a data set using any generic model function; If data set is binned a least square f",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:5796,Modifiability,Inherit,Inheritance,5796,"nction(const ROOT::Fit::Fitter::IModelFunction& func, bool useGrad); voidDoUpdateFitConfig(); intGetNCallsFromFCN(). private:. ROOT::Fit::FitterFitter(const ROOT::Fit::Fitter&); ROOT::Fit::Fitter&operator=(const ROOT::Fit::Fitter& rhs). Data Members; private:. boolfBinFitflag to indicate if fit is binned ; ROOT::Fit::FitConfigfConfigfitter configuration (options and parameter settings); intfDataSizesize of data sets (need for Fumili or LM fitters); intfFitTypetype of fit (0 undefined, 1 least square, 2 likelihood); ROOT::Fit::Fitter::IModelFunction*fFunccopy of the fitted function containing on output the fit result (managed by FitResult); auto_ptr<ROOT::Math::Minimizer>fMinimizer! pointer to used minimizer; auto_ptr<ROOT::Math::IMultiGenFunction>fObjFunction! pointer to used objective function; auto_ptr<ROOT::Fit::FitResult>fResult! pointer to the object containing the result of the fit; boolfUseGradientflag to indicate if using gradient or not. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). bool SetFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fitter(). Default constructor. ~Fitter(). Destructor. Fitter(const ROOT::Fit::Fitter& ). Copy constructor (disabled, class is not copyable). bool Fit( const Data & data, const Function & func ). fit a data set using any generic model function; If data set is binned a least square fit is performed; If data set is unbinned a maximum likelihood fit (not extended) is done; Pre-requisite on the function:; it must implement the 1D or multidimensional parametric function interface. SetFunction(func). return Fit(const ROOT::Fit::BinData& data). bool Fit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit (default method). return DoLeastSquareFit",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:5809,Modifiability,Inherit,Inherited,5809,"nction(const ROOT::Fit::Fitter::IModelFunction& func, bool useGrad); voidDoUpdateFitConfig(); intGetNCallsFromFCN(). private:. ROOT::Fit::FitterFitter(const ROOT::Fit::Fitter&); ROOT::Fit::Fitter&operator=(const ROOT::Fit::Fitter& rhs). Data Members; private:. boolfBinFitflag to indicate if fit is binned ; ROOT::Fit::FitConfigfConfigfitter configuration (options and parameter settings); intfDataSizesize of data sets (need for Fumili or LM fitters); intfFitTypetype of fit (0 undefined, 1 least square, 2 likelihood); ROOT::Fit::Fitter::IModelFunction*fFunccopy of the fitted function containing on output the fit result (managed by FitResult); auto_ptr<ROOT::Math::Minimizer>fMinimizer! pointer to used minimizer; auto_ptr<ROOT::Math::IMultiGenFunction>fObjFunction! pointer to used objective function; auto_ptr<ROOT::Fit::FitResult>fResult! pointer to the object containing the result of the fit; boolfUseGradientflag to indicate if using gradient or not. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). bool SetFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fitter(). Default constructor. ~Fitter(). Destructor. Fitter(const ROOT::Fit::Fitter& ). Copy constructor (disabled, class is not copyable). bool Fit( const Data & data, const Function & func ). fit a data set using any generic model function; If data set is binned a least square fit is performed; If data set is unbinned a maximum likelihood fit (not extended) is done; Pre-requisite on the function:; it must implement the 1D or multidimensional parametric function interface. SetFunction(func). return Fit(const ROOT::Fit::BinData& data). bool Fit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit (default method). return DoLeastSquareFit",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:6502,Modifiability,extend,extended,6502,"ath::Minimizer>fMinimizer! pointer to used minimizer; auto_ptr<ROOT::Math::IMultiGenFunction>fObjFunction! pointer to used objective function; auto_ptr<ROOT::Fit::FitResult>fResult! pointer to the object containing the result of the fit; boolfUseGradientflag to indicate if using gradient or not. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). bool SetFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fitter(). Default constructor. ~Fitter(). Destructor. Fitter(const ROOT::Fit::Fitter& ). Copy constructor (disabled, class is not copyable). bool Fit( const Data & data, const Function & func ). fit a data set using any generic model function; If data set is binned a least square fit is performed; If data set is unbinned a maximum likelihood fit (not extended) is done; Pre-requisite on the function:; it must implement the 1D or multidimensional parametric function interface. SetFunction(func). return Fit(const ROOT::Fit::BinData& data). bool Fit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit (default method). return DoLeastSquareFit(const ROOT::Fit::BinData& data). bool LeastSquareFit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit. bool Fit(const ROOT::Fit::UnBinData& data, bool extended = false). fit an unbinned data set using loglikelihood method. return DoLikelihoodFit(data, extended). bool LikelihoodFit(const Data & data ). Likelihood fit (unbinned or unbinned) depending on the type of data; If Binned default is extended; If Unbinned defult is NOT extended (for backward compatibility). return DoLikelihoodFit(data). bool LikelihoodFit(const Data & data, bool extended ). Likelihood fit using extended or not extended method. bool LikelihoodFit( const",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:7005,Modifiability,extend,extended,7005,"ool chi2fit = false). bool SetFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fitter(). Default constructor. ~Fitter(). Destructor. Fitter(const ROOT::Fit::Fitter& ). Copy constructor (disabled, class is not copyable). bool Fit( const Data & data, const Function & func ). fit a data set using any generic model function; If data set is binned a least square fit is performed; If data set is unbinned a maximum likelihood fit (not extended) is done; Pre-requisite on the function:; it must implement the 1D or multidimensional parametric function interface. SetFunction(func). return Fit(const ROOT::Fit::BinData& data). bool Fit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit (default method). return DoLeastSquareFit(const ROOT::Fit::BinData& data). bool LeastSquareFit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit. bool Fit(const ROOT::Fit::UnBinData& data, bool extended = false). fit an unbinned data set using loglikelihood method. return DoLikelihoodFit(data, extended). bool LikelihoodFit(const Data & data ). Likelihood fit (unbinned or unbinned) depending on the type of data; If Binned default is extended; If Unbinned defult is NOT extended (for backward compatibility). return DoLikelihoodFit(data). bool LikelihoodFit(const Data & data, bool extended ). Likelihood fit using extended or not extended method. bool LikelihoodFit( const Data & data, const Function & func, bool extended). fit a data set using any generic model function; Pre-requisite on the function:. SetFunction(func). bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fit using the a generic FCN function as a C++ callable object implementing; double () (const double *); Note that the function dimension (i.e. the number of parameter) is needed in this case; For the options see d",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:7106,Modifiability,extend,extended,7106,"0, unsigned int dataSize = 0, bool chi2fit = false). Fitter(). Default constructor. ~Fitter(). Destructor. Fitter(const ROOT::Fit::Fitter& ). Copy constructor (disabled, class is not copyable). bool Fit( const Data & data, const Function & func ). fit a data set using any generic model function; If data set is binned a least square fit is performed; If data set is unbinned a maximum likelihood fit (not extended) is done; Pre-requisite on the function:; it must implement the 1D or multidimensional parametric function interface. SetFunction(func). return Fit(const ROOT::Fit::BinData& data). bool Fit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit (default method). return DoLeastSquareFit(const ROOT::Fit::BinData& data). bool LeastSquareFit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit. bool Fit(const ROOT::Fit::UnBinData& data, bool extended = false). fit an unbinned data set using loglikelihood method. return DoLikelihoodFit(data, extended). bool LikelihoodFit(const Data & data ). Likelihood fit (unbinned or unbinned) depending on the type of data; If Binned default is extended; If Unbinned defult is NOT extended (for backward compatibility). return DoLikelihoodFit(data). bool LikelihoodFit(const Data & data, bool extended ). Likelihood fit using extended or not extended method. bool LikelihoodFit( const Data & data, const Function & func, bool extended). fit a data set using any generic model function; Pre-requisite on the function:. SetFunction(func). bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fit using the a generic FCN function as a C++ callable object implementing; double () (const double *); Note that the function dimension (i.e. the number of parameter) is needed in this case; For the options see documentation for following methods FitFCN(IMultiGenFunction & fcn,..). bool SetFCN(ROOT::Fit::Fitter::Minu",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:7247,Modifiability,extend,extended,7247,"Copy constructor (disabled, class is not copyable). bool Fit( const Data & data, const Function & func ). fit a data set using any generic model function; If data set is binned a least square fit is performed; If data set is unbinned a maximum likelihood fit (not extended) is done; Pre-requisite on the function:; it must implement the 1D or multidimensional parametric function interface. SetFunction(func). return Fit(const ROOT::Fit::BinData& data). bool Fit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit (default method). return DoLeastSquareFit(const ROOT::Fit::BinData& data). bool LeastSquareFit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit. bool Fit(const ROOT::Fit::UnBinData& data, bool extended = false). fit an unbinned data set using loglikelihood method. return DoLikelihoodFit(data, extended). bool LikelihoodFit(const Data & data ). Likelihood fit (unbinned or unbinned) depending on the type of data; If Binned default is extended; If Unbinned defult is NOT extended (for backward compatibility). return DoLikelihoodFit(data). bool LikelihoodFit(const Data & data, bool extended ). Likelihood fit using extended or not extended method. bool LikelihoodFit( const Data & data, const Function & func, bool extended). fit a data set using any generic model function; Pre-requisite on the function:. SetFunction(func). bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fit using the a generic FCN function as a C++ callable object implementing; double () (const double *); Note that the function dimension (i.e. the number of parameter) is needed in this case; For the options see documentation for following methods FitFCN(IMultiGenFunction & fcn,..). bool SetFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Set a generic FCN function as a C++ call",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:7283,Modifiability,extend,extended,7283,"Copy constructor (disabled, class is not copyable). bool Fit( const Data & data, const Function & func ). fit a data set using any generic model function; If data set is binned a least square fit is performed; If data set is unbinned a maximum likelihood fit (not extended) is done; Pre-requisite on the function:; it must implement the 1D or multidimensional parametric function interface. SetFunction(func). return Fit(const ROOT::Fit::BinData& data). bool Fit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit (default method). return DoLeastSquareFit(const ROOT::Fit::BinData& data). bool LeastSquareFit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit. bool Fit(const ROOT::Fit::UnBinData& data, bool extended = false). fit an unbinned data set using loglikelihood method. return DoLikelihoodFit(data, extended). bool LikelihoodFit(const Data & data ). Likelihood fit (unbinned or unbinned) depending on the type of data; If Binned default is extended; If Unbinned defult is NOT extended (for backward compatibility). return DoLikelihoodFit(data). bool LikelihoodFit(const Data & data, bool extended ). Likelihood fit using extended or not extended method. bool LikelihoodFit( const Data & data, const Function & func, bool extended). fit a data set using any generic model function; Pre-requisite on the function:. SetFunction(func). bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fit using the a generic FCN function as a C++ callable object implementing; double () (const double *); Note that the function dimension (i.e. the number of parameter) is needed in this case; For the options see documentation for following methods FitFCN(IMultiGenFunction & fcn,..). bool SetFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Set a generic FCN function as a C++ call",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:7395,Modifiability,extend,extended,7395,"odel function; If data set is binned a least square fit is performed; If data set is unbinned a maximum likelihood fit (not extended) is done; Pre-requisite on the function:; it must implement the 1D or multidimensional parametric function interface. SetFunction(func). return Fit(const ROOT::Fit::BinData& data). bool Fit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit (default method). return DoLeastSquareFit(const ROOT::Fit::BinData& data). bool LeastSquareFit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit. bool Fit(const ROOT::Fit::UnBinData& data, bool extended = false). fit an unbinned data set using loglikelihood method. return DoLikelihoodFit(data, extended). bool LikelihoodFit(const Data & data ). Likelihood fit (unbinned or unbinned) depending on the type of data; If Binned default is extended; If Unbinned defult is NOT extended (for backward compatibility). return DoLikelihoodFit(data). bool LikelihoodFit(const Data & data, bool extended ). Likelihood fit using extended or not extended method. bool LikelihoodFit( const Data & data, const Function & func, bool extended). fit a data set using any generic model function; Pre-requisite on the function:. SetFunction(func). bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fit using the a generic FCN function as a C++ callable object implementing; double () (const double *); Note that the function dimension (i.e. the number of parameter) is needed in this case; For the options see documentation for following methods FitFCN(IMultiGenFunction & fcn,..). bool SetFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Set a generic FCN function as a C++ callable object implementing; double () (const double *); Note that the function dimension (i.e. the number of parameter) is needed in this case",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:7428,Modifiability,extend,extended,7428," is performed; If data set is unbinned a maximum likelihood fit (not extended) is done; Pre-requisite on the function:; it must implement the 1D or multidimensional parametric function interface. SetFunction(func). return Fit(const ROOT::Fit::BinData& data). bool Fit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit (default method). return DoLeastSquareFit(const ROOT::Fit::BinData& data). bool LeastSquareFit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit. bool Fit(const ROOT::Fit::UnBinData& data, bool extended = false). fit an unbinned data set using loglikelihood method. return DoLikelihoodFit(data, extended). bool LikelihoodFit(const Data & data ). Likelihood fit (unbinned or unbinned) depending on the type of data; If Binned default is extended; If Unbinned defult is NOT extended (for backward compatibility). return DoLikelihoodFit(data). bool LikelihoodFit(const Data & data, bool extended ). Likelihood fit using extended or not extended method. bool LikelihoodFit( const Data & data, const Function & func, bool extended). fit a data set using any generic model function; Pre-requisite on the function:. SetFunction(func). bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fit using the a generic FCN function as a C++ callable object implementing; double () (const double *); Note that the function dimension (i.e. the number of parameter) is needed in this case; For the options see documentation for following methods FitFCN(IMultiGenFunction & fcn,..). bool SetFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Set a generic FCN function as a C++ callable object implementing; double () (const double *); Note that the function dimension (i.e. the number of parameter) is needed in this case; For the options see documentation for following meth",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:7444,Modifiability,extend,extended,7444," is performed; If data set is unbinned a maximum likelihood fit (not extended) is done; Pre-requisite on the function:; it must implement the 1D or multidimensional parametric function interface. SetFunction(func). return Fit(const ROOT::Fit::BinData& data). bool Fit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit (default method). return DoLeastSquareFit(const ROOT::Fit::BinData& data). bool LeastSquareFit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit. bool Fit(const ROOT::Fit::UnBinData& data, bool extended = false). fit an unbinned data set using loglikelihood method. return DoLikelihoodFit(data, extended). bool LikelihoodFit(const Data & data ). Likelihood fit (unbinned or unbinned) depending on the type of data; If Binned default is extended; If Unbinned defult is NOT extended (for backward compatibility). return DoLikelihoodFit(data). bool LikelihoodFit(const Data & data, bool extended ). Likelihood fit using extended or not extended method. bool LikelihoodFit( const Data & data, const Function & func, bool extended). fit a data set using any generic model function; Pre-requisite on the function:. SetFunction(func). bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fit using the a generic FCN function as a C++ callable object implementing; double () (const double *); Note that the function dimension (i.e. the number of parameter) is needed in this case; For the options see documentation for following methods FitFCN(IMultiGenFunction & fcn,..). bool SetFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Set a generic FCN function as a C++ callable object implementing; double () (const double *); Note that the function dimension (i.e. the number of parameter) is needed in this case; For the options see documentation for following meth",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:7528,Modifiability,extend,extended,7528,"ot extended) is done; Pre-requisite on the function:; it must implement the 1D or multidimensional parametric function interface. SetFunction(func). return Fit(const ROOT::Fit::BinData& data). bool Fit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit (default method). return DoLeastSquareFit(const ROOT::Fit::BinData& data). bool LeastSquareFit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit. bool Fit(const ROOT::Fit::UnBinData& data, bool extended = false). fit an unbinned data set using loglikelihood method. return DoLikelihoodFit(data, extended). bool LikelihoodFit(const Data & data ). Likelihood fit (unbinned or unbinned) depending on the type of data; If Binned default is extended; If Unbinned defult is NOT extended (for backward compatibility). return DoLikelihoodFit(data). bool LikelihoodFit(const Data & data, bool extended ). Likelihood fit using extended or not extended method. bool LikelihoodFit( const Data & data, const Function & func, bool extended). fit a data set using any generic model function; Pre-requisite on the function:. SetFunction(func). bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fit using the a generic FCN function as a C++ callable object implementing; double () (const double *); Note that the function dimension (i.e. the number of parameter) is needed in this case; For the options see documentation for following methods FitFCN(IMultiGenFunction & fcn,..). bool SetFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Set a generic FCN function as a C++ callable object implementing; double () (const double *); Note that the function dimension (i.e. the number of parameter) is needed in this case; For the options see documentation for following methods FitFCN(IMultiGenFunction & fcn,..). bool FitFCN(const ROOT::Ma",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:14437,Modifiability,config,config,14437," return fMinimizer.get(); }. ROOT::Math::IMultiGenFunction * GetFCN() const. return pointer to last used objective function; (is NULL in case fit is not yet done); This pointer will be valid as far as the data and the fitter class; have not been deleted. To be used after the fitting.; The pointer should not be stored and will be invalided after performing a new fitting.; In this case a new instance of the function pointer will be re-created and can be; obtained calling again GetFCN(). { return fObjFunction.get(); }. bool ApplyWeightCorrection(const ROOT::Math::IMultiGenFunction& loglw2, bool minimizeW2L = false). apply correction in the error matrix for the weights for likelihood fits; This method can be called only after a fit. The; passed function (loglw2) is a log-likelihood function impelemented using the; sum of weight squared; When using FitConfig.SetWeightCorrection() this correction is applied; automatically when doing a likelihood fit (binned or unbinned). bool DoLinearFit(const ROOT::Fit::BinData& data); linear least square fit. bool DoInitMinimizer(); initialize the minimizer. bool DoMinimization(const ROOT::Fit::Fitter::BaseFunc& f, const ROOT::Math::IMultiGenFunction* chifunc = 0); do minimization. bool DoMinimization(const ROOT::Math::IMultiGenFunction* chifunc = 0); do minimization after having set obj function. void DoUpdateFitConfig(); update config after fit. int GetNCallsFromFCN(); get function calls from the FCN. void DoSetFunction(const IModel1DFunction & func, bool useGrad); set 1D function. void DoSetFunction(const IModelFunction & func, bool useGrad); set generic N-d function.  Author: L. Moneta Wed Aug 30 11:05:19 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: Fitter.h 42202 2011-11-23 17:07:20Z moneta $  Last generated: 2011-12-02 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:306,Performance,perform,performing,306,". ROOT::Fit::Fitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::Fitter. class ROOT::Fit::Fitter. Fitter class, entry point for performing all type of fits.; Fits are performed using the generic ROOT::Fit::Fitter::Fit method.; The inputs are the data points and a model function (using a ROOT::Math::IParamFunction); The result of the fit is returned and kept internally in the ROOT::Fit::FitResult class.; The configuration of the fit (parameters, options, etc...) are specified in the; ROOT::Math::FitConfig class.; After fitting the config of the fit will be modified to have the new values the resulting; parameter of the fit with step sizes equal to the errors. FitConfig can be preserved with; initial parameters by calling FitConfig.SetUpdateAfterFit(false);. @ingroup FitMain. Function Members (Methods); public:. ~Fitter(); boolApplyWeightCorrection(const ROOT::Math::IMultiGenFunction& loglw2, bool minimizeW2L = false); boolCalculateHessErrors(); boolCalculateMinosErrors(); const ROOT::Fit::FitConfig&Config() const; ROOT::Fit::FitConfig&Config(); boolEvalFCN(); boolFit(const ROOT::Fit::BinData& data); boolFit(const ROOT::Fit::UnBinData& data, bool extended = false); boolFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricFunctionMultiDim& func); boolFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricFunctionMultiDim& func); boolFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func); boolFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func); boolFitFCN(); boolFitFCN(const ROOT::Math::FitMethodFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params =",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:345,Performance,perform,performed,345,". ROOT::Fit::Fitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::Fitter. class ROOT::Fit::Fitter. Fitter class, entry point for performing all type of fits.; Fits are performed using the generic ROOT::Fit::Fitter::Fit method.; The inputs are the data points and a model function (using a ROOT::Math::IParamFunction); The result of the fit is returned and kept internally in the ROOT::Fit::FitResult class.; The configuration of the fit (parameters, options, etc...) are specified in the; ROOT::Math::FitConfig class.; After fitting the config of the fit will be modified to have the new values the resulting; parameter of the fit with step sizes equal to the errors. FitConfig can be preserved with; initial parameters by calling FitConfig.SetUpdateAfterFit(false);. @ingroup FitMain. Function Members (Methods); public:. ~Fitter(); boolApplyWeightCorrection(const ROOT::Math::IMultiGenFunction& loglw2, bool minimizeW2L = false); boolCalculateHessErrors(); boolCalculateMinosErrors(); const ROOT::Fit::FitConfig&Config() const; ROOT::Fit::FitConfig&Config(); boolEvalFCN(); boolFit(const ROOT::Fit::BinData& data); boolFit(const ROOT::Fit::UnBinData& data, bool extended = false); boolFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricFunctionMultiDim& func); boolFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricFunctionMultiDim& func); boolFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func); boolFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func); boolFitFCN(); boolFitFCN(const ROOT::Math::FitMethodFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params =",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:6437,Performance,perform,performed,6437,"ath::Minimizer>fMinimizer! pointer to used minimizer; auto_ptr<ROOT::Math::IMultiGenFunction>fObjFunction! pointer to used objective function; auto_ptr<ROOT::Fit::FitResult>fResult! pointer to the object containing the result of the fit; boolfUseGradientflag to indicate if using gradient or not. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). bool SetFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fitter(). Default constructor. ~Fitter(). Destructor. Fitter(const ROOT::Fit::Fitter& ). Copy constructor (disabled, class is not copyable). bool Fit( const Data & data, const Function & func ). fit a data set using any generic model function; If data set is binned a least square fit is performed; If data set is unbinned a maximum likelihood fit (not extended) is done; Pre-requisite on the function:; it must implement the 1D or multidimensional parametric function interface. SetFunction(func). return Fit(const ROOT::Fit::BinData& data). bool Fit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit (default method). return DoLeastSquareFit(const ROOT::Fit::BinData& data). bool LeastSquareFit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit. bool Fit(const ROOT::Fit::UnBinData& data, bool extended = false). fit an unbinned data set using loglikelihood method. return DoLikelihoodFit(data, extended). bool LikelihoodFit(const Data & data ). Likelihood fit (unbinned or unbinned) depending on the type of data; If Binned default is extended; If Unbinned defult is NOT extended (for backward compatibility). return DoLikelihoodFit(data). bool LikelihoodFit(const Data & data, bool extended ). Likelihood fit using extended or not extended method. bool LikelihoodFit( const",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:11168,Performance,Perform,Perform,11168,"e given FCN function representing a multi-dimensional gradient function; interface (ROOT::Math::IMultiGradFunction). In this case the minimizer will use the; gradient information provided by the function.; For the options same consideration as in the previous method. bool FitFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0). Fit using a FitMethodGradFunction interface. Same as method above, but now extra information; can be taken from the function class. bool SetFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Set the FCN function represented by a multi-dimensional gradient function interface; (ROOT::Math::IMultiGenFunction) and optionally the initial parameters; See also note above for the initial parameters for FitFCN. bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). bool EvalFCN(). Perform a simple FCN evaluation. FitResult will be modified and contain the value of the FCN. bool LinearFit(const ROOT::Fit::BinData& data). do a linear fit on a set of bin-data. { return DoLinearFit(data); }. void SetFunction(const IModelFunction & func, bool useGradient = false). Set the fitted function (model function) from a parametric function interface. void SetFunction(const IModel1DFunction & func, bool useGradient = false). Set the fitted function from a parametric 1D function interface. bool CalculateHessErrors(). perform an error analysis on the result using the Hessian; Errors are obtaied from the inverse of the Hessian matrix; To be called only after fitting and when a minimizer supporting the Hessian calculations is used; otherwise an error (false) is returned.; A new FitResult with the Hessian result will be produced. bool CalculateMinosErrors(). perform an error analysis on the result using MINOS; To be called only after fitting and when a minimizer supporting MINOS is used; otherwise",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:11699,Performance,perform,perform,11699,"ented by a multi-dimensional gradient function interface; (ROOT::Math::IMultiGenFunction) and optionally the initial parameters; See also note above for the initial parameters for FitFCN. bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). bool EvalFCN(). Perform a simple FCN evaluation. FitResult will be modified and contain the value of the FCN. bool LinearFit(const ROOT::Fit::BinData& data). do a linear fit on a set of bin-data. { return DoLinearFit(data); }. void SetFunction(const IModelFunction & func, bool useGradient = false). Set the fitted function (model function) from a parametric function interface. void SetFunction(const IModel1DFunction & func, bool useGradient = false). Set the fitted function from a parametric 1D function interface. bool CalculateHessErrors(). perform an error analysis on the result using the Hessian; Errors are obtaied from the inverse of the Hessian matrix; To be called only after fitting and when a minimizer supporting the Hessian calculations is used; otherwise an error (false) is returned.; A new FitResult with the Hessian result will be produced. bool CalculateMinosErrors(). perform an error analysis on the result using MINOS; To be called only after fitting and when a minimizer supporting MINOS is used; otherwise an error (false) is returned.; The result will be appended in the fit result class; Optionally a vector of parameter indeces can be passed for selecting; the parameters to analyse using FitConfig::SetMinosErrors. bool IsBinFit() const. query if fit is binned. In cse of false teh fit can be unbinned; or is not defined (like in case of fitting through a ::FitFCN). { return fBinFit; }. ROOT::Math::Minimizer * GetMinimizer() const. return pointer to last used minimizer; (is NULL in case fit is not yet done); This pointer will be valid as far as the data, the objective function; and the fitter class have not been deleted.; To be used only",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:12043,Performance,perform,perform,12043," bool chi2fit = false). bool EvalFCN(). Perform a simple FCN evaluation. FitResult will be modified and contain the value of the FCN. bool LinearFit(const ROOT::Fit::BinData& data). do a linear fit on a set of bin-data. { return DoLinearFit(data); }. void SetFunction(const IModelFunction & func, bool useGradient = false). Set the fitted function (model function) from a parametric function interface. void SetFunction(const IModel1DFunction & func, bool useGradient = false). Set the fitted function from a parametric 1D function interface. bool CalculateHessErrors(). perform an error analysis on the result using the Hessian; Errors are obtaied from the inverse of the Hessian matrix; To be called only after fitting and when a minimizer supporting the Hessian calculations is used; otherwise an error (false) is returned.; A new FitResult with the Hessian result will be produced. bool CalculateMinosErrors(). perform an error analysis on the result using MINOS; To be called only after fitting and when a minimizer supporting MINOS is used; otherwise an error (false) is returned.; The result will be appended in the fit result class; Optionally a vector of parameter indeces can be passed for selecting; the parameters to analyse using FitConfig::SetMinosErrors. bool IsBinFit() const. query if fit is binned. In cse of false teh fit can be unbinned; or is not defined (like in case of fitting through a ::FitFCN). { return fBinFit; }. ROOT::Math::Minimizer * GetMinimizer() const. return pointer to last used minimizer; (is NULL in case fit is not yet done); This pointer will be valid as far as the data, the objective function; and the fitter class have not been deleted.; To be used only after fitting.; The pointer should not be stored and will be invalided after performing a new fitting.; In this case a new instance of ROOT::Math::Minimizer will be re-created and can be; obtained calling again GetMinimizer(). { return fMinimizer.get(); }. ROOT::Math::IMultiGenFunction * GetFCN() con",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:12904,Performance,perform,performing,12904,"Hessian calculations is used; otherwise an error (false) is returned.; A new FitResult with the Hessian result will be produced. bool CalculateMinosErrors(). perform an error analysis on the result using MINOS; To be called only after fitting and when a minimizer supporting MINOS is used; otherwise an error (false) is returned.; The result will be appended in the fit result class; Optionally a vector of parameter indeces can be passed for selecting; the parameters to analyse using FitConfig::SetMinosErrors. bool IsBinFit() const. query if fit is binned. In cse of false teh fit can be unbinned; or is not defined (like in case of fitting through a ::FitFCN). { return fBinFit; }. ROOT::Math::Minimizer * GetMinimizer() const. return pointer to last used minimizer; (is NULL in case fit is not yet done); This pointer will be valid as far as the data, the objective function; and the fitter class have not been deleted.; To be used only after fitting.; The pointer should not be stored and will be invalided after performing a new fitting.; In this case a new instance of ROOT::Math::Minimizer will be re-created and can be; obtained calling again GetMinimizer(). { return fMinimizer.get(); }. ROOT::Math::IMultiGenFunction * GetFCN() const. return pointer to last used objective function; (is NULL in case fit is not yet done); This pointer will be valid as far as the data and the fitter class; have not been deleted. To be used after the fitting.; The pointer should not be stored and will be invalided after performing a new fitting.; In this case a new instance of the function pointer will be re-created and can be; obtained calling again GetFCN(). { return fObjFunction.get(); }. bool ApplyWeightCorrection(const ROOT::Math::IMultiGenFunction& loglw2, bool minimizeW2L = false). apply correction in the error matrix for the weights for likelihood fits; This method can be called only after a fit. The; passed function (loglw2) is a log-likelihood function impelemented using the; sum of w",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:13402,Performance,perform,performing,13402,"etMinosErrors. bool IsBinFit() const. query if fit is binned. In cse of false teh fit can be unbinned; or is not defined (like in case of fitting through a ::FitFCN). { return fBinFit; }. ROOT::Math::Minimizer * GetMinimizer() const. return pointer to last used minimizer; (is NULL in case fit is not yet done); This pointer will be valid as far as the data, the objective function; and the fitter class have not been deleted.; To be used only after fitting.; The pointer should not be stored and will be invalided after performing a new fitting.; In this case a new instance of ROOT::Math::Minimizer will be re-created and can be; obtained calling again GetMinimizer(). { return fMinimizer.get(); }. ROOT::Math::IMultiGenFunction * GetFCN() const. return pointer to last used objective function; (is NULL in case fit is not yet done); This pointer will be valid as far as the data and the fitter class; have not been deleted. To be used after the fitting.; The pointer should not be stored and will be invalided after performing a new fitting.; In this case a new instance of the function pointer will be re-created and can be; obtained calling again GetFCN(). { return fObjFunction.get(); }. bool ApplyWeightCorrection(const ROOT::Math::IMultiGenFunction& loglw2, bool minimizeW2L = false). apply correction in the error matrix for the weights for likelihood fits; This method can be called only after a fit. The; passed function (loglw2) is a log-likelihood function impelemented using the; sum of weight squared; When using FitConfig.SetWeightCorrection() this correction is applied; automatically when doing a likelihood fit (binned or unbinned). bool DoLinearFit(const ROOT::Fit::BinData& data); linear least square fit. bool DoInitMinimizer(); initialize the minimizer. bool DoMinimization(const ROOT::Fit::Fitter::BaseFunc& f, const ROOT::Math::IMultiGenFunction* chifunc = 0); do minimization. bool DoMinimization(const ROOT::Math::IMultiGenFunction* chifunc = 0); do minimization after havi",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:7055,Testability,log,loglikelihood,7055,"CN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fitter(). Default constructor. ~Fitter(). Destructor. Fitter(const ROOT::Fit::Fitter& ). Copy constructor (disabled, class is not copyable). bool Fit( const Data & data, const Function & func ). fit a data set using any generic model function; If data set is binned a least square fit is performed; If data set is unbinned a maximum likelihood fit (not extended) is done; Pre-requisite on the function:; it must implement the 1D or multidimensional parametric function interface. SetFunction(func). return Fit(const ROOT::Fit::BinData& data). bool Fit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit (default method). return DoLeastSquareFit(const ROOT::Fit::BinData& data). bool LeastSquareFit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit. bool Fit(const ROOT::Fit::UnBinData& data, bool extended = false). fit an unbinned data set using loglikelihood method. return DoLikelihoodFit(data, extended). bool LikelihoodFit(const Data & data ). Likelihood fit (unbinned or unbinned) depending on the type of data; If Binned default is extended; If Unbinned defult is NOT extended (for backward compatibility). return DoLikelihoodFit(data). bool LikelihoodFit(const Data & data, bool extended ). Likelihood fit using extended or not extended method. bool LikelihoodFit( const Data & data, const Function & func, bool extended). fit a data set using any generic model function; Pre-requisite on the function:. SetFunction(func). bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fit using the a generic FCN function as a C++ callable object implementing; double () (const double *); Note that the function dimension (i.e. the number of parameter) is needed in this case; For the options see documentation for following methods FitFCN(IMultiGenFunction ",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:13829,Testability,log,log-likelihood,13829,"ould not be stored and will be invalided after performing a new fitting.; In this case a new instance of ROOT::Math::Minimizer will be re-created and can be; obtained calling again GetMinimizer(). { return fMinimizer.get(); }. ROOT::Math::IMultiGenFunction * GetFCN() const. return pointer to last used objective function; (is NULL in case fit is not yet done); This pointer will be valid as far as the data and the fitter class; have not been deleted. To be used after the fitting.; The pointer should not be stored and will be invalided after performing a new fitting.; In this case a new instance of the function pointer will be re-created and can be; obtained calling again GetFCN(). { return fObjFunction.get(); }. bool ApplyWeightCorrection(const ROOT::Math::IMultiGenFunction& loglw2, bool minimizeW2L = false). apply correction in the error matrix for the weights for likelihood fits; This method can be called only after a fit. The; passed function (loglw2) is a log-likelihood function impelemented using the; sum of weight squared; When using FitConfig.SetWeightCorrection() this correction is applied; automatically when doing a likelihood fit (binned or unbinned). bool DoLinearFit(const ROOT::Fit::BinData& data); linear least square fit. bool DoInitMinimizer(); initialize the minimizer. bool DoMinimization(const ROOT::Fit::Fitter::BaseFunc& f, const ROOT::Math::IMultiGenFunction* chifunc = 0); do minimization. bool DoMinimization(const ROOT::Math::IMultiGenFunction* chifunc = 0); do minimization after having set obj function. void DoUpdateFitConfig(); update config after fit. int GetNCallsFromFCN(); get function calls from the FCN. void DoSetFunction(const IModel1DFunction & func, bool useGrad); set 1D function. void DoSetFunction(const IModelFunction & func, bool useGrad); set generic N-d function.  Author: L. Moneta Wed Aug 30 11:05:19 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: Fitter.h 42202 2011-11-23 17:07:20Z mo",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__Fitter.html:11178,Usability,simpl,simple,11178,"e given FCN function representing a multi-dimensional gradient function; interface (ROOT::Math::IMultiGradFunction). In this case the minimizer will use the; gradient information provided by the function.; For the options same consideration as in the previous method. bool FitFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0). Fit using a FitMethodGradFunction interface. Same as method above, but now extra information; can be taken from the function class. bool SetFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Set the FCN function represented by a multi-dimensional gradient function interface; (ROOT::Math::IMultiGenFunction) and optionally the initial parameters; See also note above for the initial parameters for FitFCN. bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). bool EvalFCN(). Perform a simple FCN evaluation. FitResult will be modified and contain the value of the FCN. bool LinearFit(const ROOT::Fit::BinData& data). do a linear fit on a set of bin-data. { return DoLinearFit(data); }. void SetFunction(const IModelFunction & func, bool useGradient = false). Set the fitted function (model function) from a parametric function interface. void SetFunction(const IModel1DFunction & func, bool useGradient = false). Set the fitted function from a parametric 1D function interface. bool CalculateHessErrors(). perform an error analysis on the result using the Hessian; Errors are obtaied from the inverse of the Hessian matrix; To be called only after fitting and when a minimizer supporting the Hessian calculations is used; otherwise an error (false) is returned.; A new FitResult with the Hessian result will be produced. bool CalculateMinosErrors(). perform an error analysis on the result using MINOS; To be called only after fitting and when a minimizer supporting MINOS is used; otherwise",MatchSource.WIKI,root/html532/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html
https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html:3989,Availability,error,errors,3989,"onst ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&); ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&operator=(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::UnBinData&fData; const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; boolfIsExtendedflag for indicating if likelihood is extended; unsigned intfNEffPointsnumber of effective points used in the fit ; intfWeightflag to indicate if needs to evaluate using weight or weight squared (default weight = 0). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new LogLikelihoodFCN(fData,fFunc,fWeight,fIsExtended); }. unsigned int NFitPoints() const; using BaseObjFunction::operator();; effective points used in the fit. { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th likelihood contribution and its gradient. void Gradient(const double* x, double* g) const; need to be virtual to be instantited. void UseSumOfWeightSquare(); Use sum of the weight squared in evaluating the likelihood; (this is needed for calculating the errors). double DoEval(const double* x) const. Evaluation of the function (required by interface). double DoDerivative(const double* x, unsigned int icoord) const; for derivatives.  Author: L. Moneta Fri Aug 17 14:29:24 2007  Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: LogLikelihoodFCN.h 42007 2011-11-15 13:23:17Z moneta $  Last generated: 2011-12-02 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html:2260,Deployability,Update,UpdateNCalls,2260,"tinguish gradient and non-gradient case. @ingroup FitMethodFunc. This class is also known as (typedefs to this class)ROOT::Fit::LogLikelihoodFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IMultiGenFunction>. Function Members (Methods); public:. virtual~LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(); virtual ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::BaseFunction*Clone() const; virtual const ROOT::Fit::UnBinData&Data() const; virtual doubleDataElement(const double* x, unsigned int i, double* g) const; virtual voidGradient(const double* x, double* g) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(const ROOT::Fit::UnBinData& data, const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction& func, int weight = 0, bool extended = false); virtual const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction&ModelFunction() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NDim() const; virtual unsigned intNFitPoints() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::ResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::Type_tType() const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::UpdateNCalls() const; voidUseSumOfWeightSquare(). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(const",MatchSource.WIKI,root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html:4076,Integrability,interface,interface,4076,"onst ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&); ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&operator=(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::UnBinData&fData; const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; boolfIsExtendedflag for indicating if likelihood is extended; unsigned intfNEffPointsnumber of effective points used in the fit ; intfWeightflag to indicate if needs to evaluate using weight or weight squared (default weight = 0). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new LogLikelihoodFCN(fData,fFunc,fWeight,fIsExtended); }. unsigned int NFitPoints() const; using BaseObjFunction::operator();; effective points used in the fit. { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th likelihood contribution and its gradient. void Gradient(const double* x, double* g) const; need to be virtual to be instantited. void UseSumOfWeightSquare(); Use sum of the weight squared in evaluating the likelihood; (this is needed for calculating the errors). double DoEval(const double* x) const. Evaluation of the function (required by interface). double DoDerivative(const double* x, unsigned int icoord) const; for derivatives.  Author: L. Moneta Fri Aug 17 14:29:24 2007  Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: LogLikelihoodFCN.h 42007 2011-11-15 13:23:17Z moneta $  Last generated: 2011-12-02 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html:1409,Modifiability,extend,extended,1409,"tinguish gradient and non-gradient case. @ingroup FitMethodFunc. This class is also known as (typedefs to this class)ROOT::Fit::LogLikelihoodFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IMultiGenFunction>. Function Members (Methods); public:. virtual~LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(); virtual ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::BaseFunction*Clone() const; virtual const ROOT::Fit::UnBinData&Data() const; virtual doubleDataElement(const double* x, unsigned int i, double* g) const; virtual voidGradient(const double* x, double* g) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(const ROOT::Fit::UnBinData& data, const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction& func, int weight = 0, bool extended = false); virtual const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction&ModelFunction() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NDim() const; virtual unsigned intNFitPoints() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::ResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::Type_tType() const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::UpdateNCalls() const; voidUseSumOfWeightSquare(). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(const",MatchSource.WIKI,root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html:3111,Modifiability,extend,extended,3111,"Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::Type_tType() const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::UpdateNCalls() const; voidUseSumOfWeightSquare(). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&); ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&operator=(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::UnBinData&fData; const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; boolfIsExtendedflag for indicating if likelihood is extended; unsigned intfNEffPointsnumber of effective points used in the fit ; intfWeightflag to indicate if needs to evaluate using weight or weight squared (default weight = 0). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new LogLikelihoodFCN(fData,fFunc,fWeight,fIsExtended); }. unsigned int NFitPoints() const; using BaseObjFunction::operator();; effective points used in the fit. { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th likelihood contribution and its gradient. void Gradient(const double* x, double* g) const; need to be virtual to be instantited. void UseSumOfWeightSquare(); Use sum of the weight squared in evaluating the likelihood; (this is needed for calculating the errors). double DoEval(const double* x) const. Evaluation of the function (required by interface). doubl",MatchSource.WIKI,root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html:3304,Modifiability,Inherit,Inheritance,3304,"oubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&); ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&operator=(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::UnBinData&fData; const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; boolfIsExtendedflag for indicating if likelihood is extended; unsigned intfNEffPointsnumber of effective points used in the fit ; intfWeightflag to indicate if needs to evaluate using weight or weight squared (default weight = 0). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new LogLikelihoodFCN(fData,fFunc,fWeight,fIsExtended); }. unsigned int NFitPoints() const; using BaseObjFunction::operator();; effective points used in the fit. { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th likelihood contribution and its gradient. void Gradient(const double* x, double* g) const; need to be virtual to be instantited. void UseSumOfWeightSquare(); Use sum of the weight squared in evaluating the likelihood; (this is needed for calculating the errors). double DoEval(const double* x) const. Evaluation of the function (required by interface). double DoDerivative(const double* x, unsigned int icoord) const; for derivatives.  Author: L. Moneta Fri Aug 17 14:29:24 2007  Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: LogLikelihoodFCN.h 42007",MatchSource.WIKI,root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html:3317,Modifiability,Inherit,Inherited,3317,"oubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&); ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&operator=(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::UnBinData&fData; const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; boolfIsExtendedflag for indicating if likelihood is extended; unsigned intfNEffPointsnumber of effective points used in the fit ; intfWeightflag to indicate if needs to evaluate using weight or weight squared (default weight = 0). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new LogLikelihoodFCN(fData,fFunc,fWeight,fIsExtended); }. unsigned int NFitPoints() const; using BaseObjFunction::operator();; effective points used in the fit. { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th likelihood contribution and its gradient. void Gradient(const double* x, double* g) const; need to be virtual to be instantited. void UseSumOfWeightSquare(); Use sum of the weight squared in evaluating the likelihood; (this is needed for calculating the errors). double DoEval(const double* x) const. Evaluation of the function (required by interface). double DoDerivative(const double* x, unsigned int icoord) const; for derivatives.  Author: L. Moneta Fri Aug 17 14:29:24 2007  Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: LogLikelihoodFCN.h 42007",MatchSource.WIKI,root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html:13,Testability,Log,LogLikelihoodFCN,13,". ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>. class ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>: public ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>. LogLikelihoodFCN class; for likelihood fits. it is template to distinguish gradient and non-gradient case. @ingroup FitMethodFunc. This class is also known as (typedefs to this class)ROOT::Fit::LogLikelihoodFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IMultiGenFunction>. Function Members (Methods); public:. virtual~LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(); virtual ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::BaseFunction*Clone() const; virtual const ROOT::Fit::UnBinData&Data() const; virtual doubleDataElement(const double* x, unsigned int i, double* g) const; virtual voidGradient(const double* x, double* g) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(const ROOT::Fit::UnBinData& data, const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction& func, int weight = 0, bool extended = false); virtual const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction&ModelFunction() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NDim() const; virtual unsigned intNFitPoints() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; virtual voidROOT::Mat",MatchSource.WIKI,root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html:288,Testability,Log,LogLikelihoodFCN,288,". ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>. class ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>: public ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>. LogLikelihoodFCN class; for likelihood fits. it is template to distinguish gradient and non-gradient case. @ingroup FitMethodFunc. This class is also known as (typedefs to this class)ROOT::Fit::LogLikelihoodFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IMultiGenFunction>. Function Members (Methods); public:. virtual~LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(); virtual ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::BaseFunction*Clone() const; virtual const ROOT::Fit::UnBinData&Data() const; virtual doubleDataElement(const double* x, unsigned int i, double* g) const; virtual voidGradient(const double* x, double* g) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(const ROOT::Fit::UnBinData& data, const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction& func, int weight = 0, bool extended = false); virtual const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction&ModelFunction() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NDim() const; virtual unsigned intNFitPoints() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; virtual voidROOT::Mat",MatchSource.WIKI,root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html:358,Testability,Log,LogLikelihoodFCN,358,". ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>. class ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>: public ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>. LogLikelihoodFCN class; for likelihood fits. it is template to distinguish gradient and non-gradient case. @ingroup FitMethodFunc. This class is also known as (typedefs to this class)ROOT::Fit::LogLikelihoodFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IMultiGenFunction>. Function Members (Methods); public:. virtual~LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(); virtual ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::BaseFunction*Clone() const; virtual const ROOT::Fit::UnBinData&Data() const; virtual doubleDataElement(const double* x, unsigned int i, double* g) const; virtual voidGradient(const double* x, double* g) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(const ROOT::Fit::UnBinData& data, const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction& func, int weight = 0, bool extended = false); virtual const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction&ModelFunction() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NDim() const; virtual unsigned intNFitPoints() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; virtual voidROOT::Mat",MatchSource.WIKI,root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html:489,Testability,Log,LogLikelihoodFCN,489,". ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>. class ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>: public ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>. LogLikelihoodFCN class; for likelihood fits. it is template to distinguish gradient and non-gradient case. @ingroup FitMethodFunc. This class is also known as (typedefs to this class)ROOT::Fit::LogLikelihoodFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IMultiGenFunction>. Function Members (Methods); public:. virtual~LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(); virtual ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::BaseFunction*Clone() const; virtual const ROOT::Fit::UnBinData&Data() const; virtual doubleDataElement(const double* x, unsigned int i, double* g) const; virtual voidGradient(const double* x, double* g) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(const ROOT::Fit::UnBinData& data, const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction& func, int weight = 0, bool extended = false); virtual const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction&ModelFunction() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NDim() const; virtual unsigned intNFitPoints() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; virtual voidROOT::Mat",MatchSource.WIKI,root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html:683,Testability,Log,LogLikelihoodFunction,683,". ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>. class ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>: public ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>. LogLikelihoodFCN class; for likelihood fits. it is template to distinguish gradient and non-gradient case. @ingroup FitMethodFunc. This class is also known as (typedefs to this class)ROOT::Fit::LogLikelihoodFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IMultiGenFunction>. Function Members (Methods); public:. virtual~LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(); virtual ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::BaseFunction*Clone() const; virtual const ROOT::Fit::UnBinData&Data() const; virtual doubleDataElement(const double* x, unsigned int i, double* g) const; virtual voidGradient(const double* x, double* g) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(const ROOT::Fit::UnBinData& data, const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction& func, int weight = 0, bool extended = false); virtual const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction&ModelFunction() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NDim() const; virtual unsigned intNFitPoints() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; virtual voidROOT::Mat",MatchSource.WIKI,root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html:717,Testability,Log,LogLikelihoodFCN,717,". ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>. class ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>: public ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>. LogLikelihoodFCN class; for likelihood fits. it is template to distinguish gradient and non-gradient case. @ingroup FitMethodFunc. This class is also known as (typedefs to this class)ROOT::Fit::LogLikelihoodFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IMultiGenFunction>. Function Members (Methods); public:. virtual~LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(); virtual ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::BaseFunction*Clone() const; virtual const ROOT::Fit::UnBinData&Data() const; virtual doubleDataElement(const double* x, unsigned int i, double* g) const; virtual voidGradient(const double* x, double* g) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(const ROOT::Fit::UnBinData& data, const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction& func, int weight = 0, bool extended = false); virtual const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction&ModelFunction() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NDim() const; virtual unsigned intNFitPoints() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; virtual voidROOT::Mat",MatchSource.WIKI,root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html:811,Testability,Log,LogLikelihoodFCN,811,"tinguish gradient and non-gradient case. @ingroup FitMethodFunc. This class is also known as (typedefs to this class)ROOT::Fit::LogLikelihoodFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IMultiGenFunction>. Function Members (Methods); public:. virtual~LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(); virtual ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::BaseFunction*Clone() const; virtual const ROOT::Fit::UnBinData&Data() const; virtual doubleDataElement(const double* x, unsigned int i, double* g) const; virtual voidGradient(const double* x, double* g) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(const ROOT::Fit::UnBinData& data, const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction& func, int weight = 0, bool extended = false); virtual const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction&ModelFunction() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NDim() const; virtual unsigned intNFitPoints() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::ResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::Type_tType() const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::UpdateNCalls() const; voidUseSumOfWeightSquare(). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(const",MatchSource.WIKI,root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html:885,Testability,Log,LogLikelihoodFCN,885,"tinguish gradient and non-gradient case. @ingroup FitMethodFunc. This class is also known as (typedefs to this class)ROOT::Fit::LogLikelihoodFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IMultiGenFunction>. Function Members (Methods); public:. virtual~LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(); virtual ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::BaseFunction*Clone() const; virtual const ROOT::Fit::UnBinData&Data() const; virtual doubleDataElement(const double* x, unsigned int i, double* g) const; virtual voidGradient(const double* x, double* g) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(const ROOT::Fit::UnBinData& data, const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction& func, int weight = 0, bool extended = false); virtual const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction&ModelFunction() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NDim() const; virtual unsigned intNFitPoints() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::ResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::Type_tType() const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::UpdateNCalls() const; voidUseSumOfWeightSquare(). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(const",MatchSource.WIKI,root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html:1159,Testability,Log,LogLikelihoodFCN,1159,"tinguish gradient and non-gradient case. @ingroup FitMethodFunc. This class is also known as (typedefs to this class)ROOT::Fit::LogLikelihoodFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IMultiGenFunction>. Function Members (Methods); public:. virtual~LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(); virtual ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::BaseFunction*Clone() const; virtual const ROOT::Fit::UnBinData&Data() const; virtual doubleDataElement(const double* x, unsigned int i, double* g) const; virtual voidGradient(const double* x, double* g) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(const ROOT::Fit::UnBinData& data, const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction& func, int weight = 0, bool extended = false); virtual const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction&ModelFunction() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NDim() const; virtual unsigned intNFitPoints() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::ResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::Type_tType() const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::UpdateNCalls() const; voidUseSumOfWeightSquare(). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(const",MatchSource.WIKI,root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html:1210,Testability,Log,LogLikelihoodFCN,1210,"tinguish gradient and non-gradient case. @ingroup FitMethodFunc. This class is also known as (typedefs to this class)ROOT::Fit::LogLikelihoodFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IMultiGenFunction>. Function Members (Methods); public:. virtual~LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(); virtual ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::BaseFunction*Clone() const; virtual const ROOT::Fit::UnBinData&Data() const; virtual doubleDataElement(const double* x, unsigned int i, double* g) const; virtual voidGradient(const double* x, double* g) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(const ROOT::Fit::UnBinData& data, const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction& func, int weight = 0, bool extended = false); virtual const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction&ModelFunction() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NDim() const; virtual unsigned intNFitPoints() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::ResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::Type_tType() const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::UpdateNCalls() const; voidUseSumOfWeightSquare(). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(const",MatchSource.WIKI,root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html:1313,Testability,Log,LogLikelihoodFCN,1313,"tinguish gradient and non-gradient case. @ingroup FitMethodFunc. This class is also known as (typedefs to this class)ROOT::Fit::LogLikelihoodFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IMultiGenFunction>. Function Members (Methods); public:. virtual~LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(); virtual ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::BaseFunction*Clone() const; virtual const ROOT::Fit::UnBinData&Data() const; virtual doubleDataElement(const double* x, unsigned int i, double* g) const; virtual voidGradient(const double* x, double* g) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(const ROOT::Fit::UnBinData& data, const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction& func, int weight = 0, bool extended = false); virtual const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction&ModelFunction() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NDim() const; virtual unsigned intNFitPoints() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::ResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::Type_tType() const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::UpdateNCalls() const; voidUseSumOfWeightSquare(). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(const",MatchSource.WIKI,root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html:1453,Testability,Log,LogLikelihoodFCN,1453,"tinguish gradient and non-gradient case. @ingroup FitMethodFunc. This class is also known as (typedefs to this class)ROOT::Fit::LogLikelihoodFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IMultiGenFunction>. Function Members (Methods); public:. virtual~LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(); virtual ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::BaseFunction*Clone() const; virtual const ROOT::Fit::UnBinData&Data() const; virtual doubleDataElement(const double* x, unsigned int i, double* g) const; virtual voidGradient(const double* x, double* g) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(const ROOT::Fit::UnBinData& data, const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction& func, int weight = 0, bool extended = false); virtual const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction&ModelFunction() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NDim() const; virtual unsigned intNFitPoints() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::ResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::Type_tType() const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::UpdateNCalls() const; voidUseSumOfWeightSquare(). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(const",MatchSource.WIKI,root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html:2448,Testability,Log,LogLikelihoodFCN,2448," virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NDim() const; virtual unsigned intNFitPoints() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::ResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::Type_tType() const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::UpdateNCalls() const; voidUseSumOfWeightSquare(). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&); ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&operator=(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::UnBinData&fData; const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; boolfIsExtendedflag for indicating if likelihood is extended; unsigned intfNEffPointsnumber of effective points used in the fit ; intfWeightflag to indicate if needs to evaluate using weight or weight squared (default weight = 0). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new LogLikelihoodFCN(fData,fFunc,fWeight,fIsExtended); }. unsigned in",MatchSource.WIKI,root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html:2499,Testability,Log,LogLikelihoodFCN,2499," virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NDim() const; virtual unsigned intNFitPoints() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::ResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::Type_tType() const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::UpdateNCalls() const; voidUseSumOfWeightSquare(). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&); ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&operator=(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::UnBinData&fData; const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; boolfIsExtendedflag for indicating if likelihood is extended; unsigned intfNEffPointsnumber of effective points used in the fit ; intfWeightflag to indicate if needs to evaluate using weight or weight squared (default weight = 0). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new LogLikelihoodFCN(fData,fFunc,fWeight,fIsExtended); }. unsigned in",MatchSource.WIKI,root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html:2568,Testability,Log,LogLikelihoodFCN,2568," virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NDim() const; virtual unsigned intNFitPoints() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::ResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::Type_tType() const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::UpdateNCalls() const; voidUseSumOfWeightSquare(). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&); ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&operator=(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::UnBinData&fData; const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; boolfIsExtendedflag for indicating if likelihood is extended; unsigned intfNEffPointsnumber of effective points used in the fit ; intfWeightflag to indicate if needs to evaluate using weight or weight squared (default weight = 0). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new LogLikelihoodFCN(fData,fFunc,fWeight,fIsExtended); }. unsigned in",MatchSource.WIKI,root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html:2634,Testability,Log,LogLikelihoodFCN,2634," virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NDim() const; virtual unsigned intNFitPoints() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::ResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::Type_tType() const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::UpdateNCalls() const; voidUseSumOfWeightSquare(). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&); ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&operator=(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::UnBinData&fData; const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; boolfIsExtendedflag for indicating if likelihood is extended; unsigned intfNEffPointsnumber of effective points used in the fit ; intfWeightflag to indicate if needs to evaluate using weight or weight squared (default weight = 0). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new LogLikelihoodFCN(fData,fFunc,fWeight,fIsExtended); }. unsigned in",MatchSource.WIKI,root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html:2713,Testability,Log,LogLikelihoodFCN,2713," virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NDim() const; virtual unsigned intNFitPoints() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::ResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::Type_tType() const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::UpdateNCalls() const; voidUseSumOfWeightSquare(). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&); ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&operator=(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::UnBinData&fData; const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; boolfIsExtendedflag for indicating if likelihood is extended; unsigned intfNEffPointsnumber of effective points used in the fit ; intfWeightflag to indicate if needs to evaluate using weight or weight squared (default weight = 0). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new LogLikelihoodFCN(fData,fFunc,fWeight,fIsExtended); }. unsigned in",MatchSource.WIKI,root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html:2948,Testability,Log,LogLikelihoodFCN,2948,"Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::Type_tType() const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::UpdateNCalls() const; voidUseSumOfWeightSquare(). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&); ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&operator=(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::UnBinData&fData; const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; boolfIsExtendedflag for indicating if likelihood is extended; unsigned intfNEffPointsnumber of effective points used in the fit ; intfWeightflag to indicate if needs to evaluate using weight or weight squared (default weight = 0). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new LogLikelihoodFCN(fData,fFunc,fWeight,fIsExtended); }. unsigned int NFitPoints() const; using BaseObjFunction::operator();; effective points used in the fit. { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th likelihood contribution and its gradient. void Gradient(const double* x, double* g) const; need to be virtual to be instantited. void UseSumOfWeightSquare(); Use sum of the weight squared in evaluating the likelihood; (this is needed for calculating the errors). double DoEval(const double* x) const. Evaluation of the function (required by interface). doubl",MatchSource.WIKI,root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html:3478,Testability,Log,LogLikelihoodFCN,3478,"m>LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&); ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&operator=(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::UnBinData&fData; const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; boolfIsExtendedflag for indicating if likelihood is extended; unsigned intfNEffPointsnumber of effective points used in the fit ; intfWeightflag to indicate if needs to evaluate using weight or weight squared (default weight = 0). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new LogLikelihoodFCN(fData,fFunc,fWeight,fIsExtended); }. unsigned int NFitPoints() const; using BaseObjFunction::operator();; effective points used in the fit. { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th likelihood contribution and its gradient. void Gradient(const double* x, double* g) const; need to be virtual to be instantited. void UseSumOfWeightSquare(); Use sum of the weight squared in evaluating the likelihood; (this is needed for calculating the errors). double DoEval(const double* x) const. Evaluation of the function (required by interface). double DoDerivative(const double* x, unsigned int icoord) const; for derivatives.  Author: L. Moneta Fri Aug 17 14:29:24 2007  Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: LogLikelihoodFCN.h 42007 2011-11-15 13:23:17Z moneta $  Last generated: 2011-12-02 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation o",MatchSource.WIKI,root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html:4306,Testability,Log,LogLikelihoodFCN,4306,"onst ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&); ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&operator=(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::UnBinData&fData; const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; boolfIsExtendedflag for indicating if likelihood is extended; unsigned intfNEffPointsnumber of effective points used in the fit ; intfWeightflag to indicate if needs to evaluate using weight or weight squared (default weight = 0). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new LogLikelihoodFCN(fData,fFunc,fWeight,fIsExtended); }. unsigned int NFitPoints() const; using BaseObjFunction::operator();; effective points used in the fit. { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th likelihood contribution and its gradient. void Gradient(const double* x, double* g) const; need to be virtual to be instantited. void UseSumOfWeightSquare(); Use sum of the weight squared in evaluating the likelihood; (this is needed for calculating the errors). double DoEval(const double* x) const. Evaluation of the function (required by interface). double DoDerivative(const double* x, unsigned int icoord) const; for derivatives.  Author: L. Moneta Fri Aug 17 14:29:24 2007  Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: LogLikelihoodFCN.h 42007 2011-11-15 13:23:17Z moneta $  Last generated: 2011-12-02 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html:4281,Availability,error,errors,4281,"LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&); ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&operator=(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::UnBinData&fData; const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; boolfIsExtendedflag for indicating if likelihood is extended; unsigned intfNEffPointsnumber of effective points used in the fit ; intfWeightflag to indicate if needs to evaluate using weight or weight squared (default weight = 0). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new LogLikelihoodFCN(fData,fFunc,fWeight,fIsExtended); }. unsigned int NFitPoints() const; using BaseObjFunction::operator();; effective points used in the fit. { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th likelihood contribution and its gradient. void Gradient(const double* x, double* g) const; need to be virtual to be instantited. void UseSumOfWeightSquare(); Use sum of the weight squared in evaluating the likelihood; (this is needed for calculating the errors). double DoEval(const double* x) const. Evaluation of the function (required by interface). double DoDerivative(const double* x, unsigned int icoord) const; for derivatives.  Author: L. Moneta Fri Aug 17 14:29:24 2007  Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: LogLikelihoodFCN.h 42007 2011-11-15 13:23:17Z moneta $  Last generated: 2011-12-02 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html:2528,Deployability,Update,UpdateNCalls,2528,"ogLikelihoodGradFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IMultiGradFunction>. Function Members (Methods); public:. virtual~LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(); virtual ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::BaseFunction*Clone() const; virtual const ROOT::Fit::UnBinData&Data() const; virtual doubleDataElement(const double* x, unsigned int i, double* g) const; doubleROOT::Math::IGradientMultiDim::Derivative(const double* x, unsigned int icoord = 0) const; virtual voidROOT::Math::IGradientFunctionMultiDim::FdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* g) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(const ROOT::Fit::UnBinData& data, const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction& func, int weight = 0, bool extended = false); virtual const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&ModelFunction() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NDim() const; virtual unsigned intNFitPoints() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::ResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::Type_tType() const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::UpdateNCalls() const; voidUseSumOfWeightSquare(). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) co",MatchSource.WIKI,root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html:4368,Integrability,interface,interface,4368,"LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&); ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&operator=(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::UnBinData&fData; const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; boolfIsExtendedflag for indicating if likelihood is extended; unsigned intfNEffPointsnumber of effective points used in the fit ; intfWeightflag to indicate if needs to evaluate using weight or weight squared (default weight = 0). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new LogLikelihoodFCN(fData,fFunc,fWeight,fIsExtended); }. unsigned int NFitPoints() const; using BaseObjFunction::operator();; effective points used in the fit. { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th likelihood contribution and its gradient. void Gradient(const double* x, double* g) const; need to be virtual to be instantited. void UseSumOfWeightSquare(); Use sum of the weight squared in evaluating the likelihood; (this is needed for calculating the errors). double DoEval(const double* x) const. Evaluation of the function (required by interface). double DoDerivative(const double* x, unsigned int icoord) const; for derivatives.  Author: L. Moneta Fri Aug 17 14:29:24 2007  Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: LogLikelihoodFCN.h 42007 2011-11-15 13:23:17Z moneta $  Last generated: 2011-12-02 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html:1649,Modifiability,extend,extended,1649,"ogLikelihoodGradFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IMultiGradFunction>. Function Members (Methods); public:. virtual~LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(); virtual ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::BaseFunction*Clone() const; virtual const ROOT::Fit::UnBinData&Data() const; virtual doubleDataElement(const double* x, unsigned int i, double* g) const; doubleROOT::Math::IGradientMultiDim::Derivative(const double* x, unsigned int icoord = 0) const; virtual voidROOT::Math::IGradientFunctionMultiDim::FdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* g) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(const ROOT::Fit::UnBinData& data, const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction& func, int weight = 0, bool extended = false); virtual const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&ModelFunction() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NDim() const; virtual unsigned intNFitPoints() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::ResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::Type_tType() const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::UpdateNCalls() const; voidUseSumOfWeightSquare(). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) co",MatchSource.WIKI,root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html:3403,Modifiability,extend,extended,3403,"OOT::Math::IGradientFunctionMultiDim>::Type_tType() const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::UpdateNCalls() const; voidUseSumOfWeightSquare(). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&); ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&operator=(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::UnBinData&fData; const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; boolfIsExtendedflag for indicating if likelihood is extended; unsigned intfNEffPointsnumber of effective points used in the fit ; intfWeightflag to indicate if needs to evaluate using weight or weight squared (default weight = 0). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new LogLikelihoodFCN(fData,fFunc,fWeight,fIsExtended); }. unsigned int NFitPoints() const; using BaseObjFunction::operator();; effective points used in the fit. { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th likelihood contribution and its gradient. void Gradient(const double* x, double* g) const; need to be virtual to be instantited. void UseSumOfWeightSquare(); Use sum of the weight squared in evaluating the likelihood; (this is needed for calculating the errors). double DoEval(const double* x) const. Evaluation of the function (required by interface). dou",MatchSource.WIKI,root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html:3596,Modifiability,Inherit,Inheritance,3596,"double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&); ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&operator=(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::UnBinData&fData; const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; boolfIsExtendedflag for indicating if likelihood is extended; unsigned intfNEffPointsnumber of effective points used in the fit ; intfWeightflag to indicate if needs to evaluate using weight or weight squared (default weight = 0). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new LogLikelihoodFCN(fData,fFunc,fWeight,fIsExtended); }. unsigned int NFitPoints() const; using BaseObjFunction::operator();; effective points used in the fit. { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th likelihood contribution and its gradient. void Gradient(const double* x, double* g) const; need to be virtual to be instantited. void UseSumOfWeightSquare(); Use sum of the weight squared in evaluating the likelihood; (this is needed for calculating the errors). double DoEval(const double* x) const. Evaluation of the function (required by interface). double DoDerivative(const double* x, unsigned int icoord) const; for derivatives.  Author: L. Moneta Fri Aug 17 14:29:24 2007  Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: LogLikelihoodFCN.h 42007",MatchSource.WIKI,root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html:3609,Modifiability,Inherit,Inherited,3609,"double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&); ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&operator=(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::UnBinData&fData; const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; boolfIsExtendedflag for indicating if likelihood is extended; unsigned intfNEffPointsnumber of effective points used in the fit ; intfWeightflag to indicate if needs to evaluate using weight or weight squared (default weight = 0). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new LogLikelihoodFCN(fData,fFunc,fWeight,fIsExtended); }. unsigned int NFitPoints() const; using BaseObjFunction::operator();; effective points used in the fit. { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th likelihood contribution and its gradient. void Gradient(const double* x, double* g) const; need to be virtual to be instantited. void UseSumOfWeightSquare(); Use sum of the weight squared in evaluating the likelihood; (this is needed for calculating the errors). double DoEval(const double* x) const. Evaluation of the function (required by interface). double DoDerivative(const double* x, unsigned int icoord) const; for derivatives.  Author: L. Moneta Fri Aug 17 14:29:24 2007  Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: LogLikelihoodFCN.h 42007",MatchSource.WIKI,root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html:13,Testability,Log,LogLikelihoodFCN,13,". ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>. class ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>: public ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>. LogLikelihoodFCN class; for likelihood fits. it is template to distinguish gradient and non-gradient case. @ingroup FitMethodFunc. This class is also known as (typedefs to this class)ROOT::Fit::LogLikelihoodGradFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IMultiGradFunction>. Function Members (Methods); public:. virtual~LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(); virtual ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::BaseFunction*Clone() const; virtual const ROOT::Fit::UnBinData&Data() const; virtual doubleDataElement(const double* x, unsigned int i, double* g) const; doubleROOT::Math::IGradientMultiDim::Derivative(const double* x, unsigned int icoord = 0) const; virtual voidROOT::Math::IGradientFunctionMultiDim::FdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* g) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(const ROOT::Fit::UnBinData& data, const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction& func, int weight = 0, bool extended = false); virtual const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&ModelFunction() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NDim() ",MatchSource.WIKI,root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html:292,Testability,Log,LogLikelihoodFCN,292,". ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>. class ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>: public ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>. LogLikelihoodFCN class; for likelihood fits. it is template to distinguish gradient and non-gradient case. @ingroup FitMethodFunc. This class is also known as (typedefs to this class)ROOT::Fit::LogLikelihoodGradFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IMultiGradFunction>. Function Members (Methods); public:. virtual~LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(); virtual ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::BaseFunction*Clone() const; virtual const ROOT::Fit::UnBinData&Data() const; virtual doubleDataElement(const double* x, unsigned int i, double* g) const; doubleROOT::Math::IGradientMultiDim::Derivative(const double* x, unsigned int icoord = 0) const; virtual voidROOT::Math::IGradientFunctionMultiDim::FdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* g) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(const ROOT::Fit::UnBinData& data, const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction& func, int weight = 0, bool extended = false); virtual const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&ModelFunction() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NDim() ",MatchSource.WIKI,root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html:366,Testability,Log,LogLikelihoodFCN,366,". ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>. class ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>: public ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>. LogLikelihoodFCN class; for likelihood fits. it is template to distinguish gradient and non-gradient case. @ingroup FitMethodFunc. This class is also known as (typedefs to this class)ROOT::Fit::LogLikelihoodGradFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IMultiGradFunction>. Function Members (Methods); public:. virtual~LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(); virtual ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::BaseFunction*Clone() const; virtual const ROOT::Fit::UnBinData&Data() const; virtual doubleDataElement(const double* x, unsigned int i, double* g) const; doubleROOT::Math::IGradientMultiDim::Derivative(const double* x, unsigned int icoord = 0) const; virtual voidROOT::Math::IGradientFunctionMultiDim::FdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* g) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(const ROOT::Fit::UnBinData& data, const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction& func, int weight = 0, bool extended = false); virtual const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&ModelFunction() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NDim() ",MatchSource.WIKI,root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html:505,Testability,Log,LogLikelihoodFCN,505,". ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>. class ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>: public ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>. LogLikelihoodFCN class; for likelihood fits. it is template to distinguish gradient and non-gradient case. @ingroup FitMethodFunc. This class is also known as (typedefs to this class)ROOT::Fit::LogLikelihoodGradFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IMultiGradFunction>. Function Members (Methods); public:. virtual~LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(); virtual ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::BaseFunction*Clone() const; virtual const ROOT::Fit::UnBinData&Data() const; virtual doubleDataElement(const double* x, unsigned int i, double* g) const; doubleROOT::Math::IGradientMultiDim::Derivative(const double* x, unsigned int icoord = 0) const; virtual voidROOT::Math::IGradientFunctionMultiDim::FdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* g) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(const ROOT::Fit::UnBinData& data, const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction& func, int weight = 0, bool extended = false); virtual const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&ModelFunction() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NDim() ",MatchSource.WIKI,root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html:699,Testability,Log,LogLikelihoodGradFunction,699,". ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>. class ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>: public ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>. LogLikelihoodFCN class; for likelihood fits. it is template to distinguish gradient and non-gradient case. @ingroup FitMethodFunc. This class is also known as (typedefs to this class)ROOT::Fit::LogLikelihoodGradFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IMultiGradFunction>. Function Members (Methods); public:. virtual~LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(); virtual ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::BaseFunction*Clone() const; virtual const ROOT::Fit::UnBinData&Data() const; virtual doubleDataElement(const double* x, unsigned int i, double* g) const; doubleROOT::Math::IGradientMultiDim::Derivative(const double* x, unsigned int icoord = 0) const; virtual voidROOT::Math::IGradientFunctionMultiDim::FdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* g) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(const ROOT::Fit::UnBinData& data, const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction& func, int weight = 0, bool extended = false); virtual const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&ModelFunction() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NDim() ",MatchSource.WIKI,root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html:737,Testability,Log,LogLikelihoodFCN,737,". ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>. class ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>: public ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>. LogLikelihoodFCN class; for likelihood fits. it is template to distinguish gradient and non-gradient case. @ingroup FitMethodFunc. This class is also known as (typedefs to this class)ROOT::Fit::LogLikelihoodGradFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IMultiGradFunction>. Function Members (Methods); public:. virtual~LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(); virtual ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::BaseFunction*Clone() const; virtual const ROOT::Fit::UnBinData&Data() const; virtual doubleDataElement(const double* x, unsigned int i, double* g) const; doubleROOT::Math::IGradientMultiDim::Derivative(const double* x, unsigned int icoord = 0) const; virtual voidROOT::Math::IGradientFunctionMultiDim::FdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* g) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(const ROOT::Fit::UnBinData& data, const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction& func, int weight = 0, bool extended = false); virtual const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&ModelFunction() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NDim() ",MatchSource.WIKI,root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html:832,Testability,Log,LogLikelihoodFCN,832,"ogLikelihoodGradFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IMultiGradFunction>. Function Members (Methods); public:. virtual~LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(); virtual ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::BaseFunction*Clone() const; virtual const ROOT::Fit::UnBinData&Data() const; virtual doubleDataElement(const double* x, unsigned int i, double* g) const; doubleROOT::Math::IGradientMultiDim::Derivative(const double* x, unsigned int icoord = 0) const; virtual voidROOT::Math::IGradientFunctionMultiDim::FdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* g) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(const ROOT::Fit::UnBinData& data, const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction& func, int weight = 0, bool extended = false); virtual const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&ModelFunction() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NDim() const; virtual unsigned intNFitPoints() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::ResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::Type_tType() const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::UpdateNCalls() const; voidUseSumOfWeightSquare(). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) co",MatchSource.WIKI,root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html:910,Testability,Log,LogLikelihoodFCN,910,"ogLikelihoodGradFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IMultiGradFunction>. Function Members (Methods); public:. virtual~LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(); virtual ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::BaseFunction*Clone() const; virtual const ROOT::Fit::UnBinData&Data() const; virtual doubleDataElement(const double* x, unsigned int i, double* g) const; doubleROOT::Math::IGradientMultiDim::Derivative(const double* x, unsigned int icoord = 0) const; virtual voidROOT::Math::IGradientFunctionMultiDim::FdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* g) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(const ROOT::Fit::UnBinData& data, const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction& func, int weight = 0, bool extended = false); virtual const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&ModelFunction() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NDim() const; virtual unsigned intNFitPoints() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::ResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::Type_tType() const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::UpdateNCalls() const; voidUseSumOfWeightSquare(). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) co",MatchSource.WIKI,root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html:1387,Testability,Log,LogLikelihoodFCN,1387,"ogLikelihoodGradFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IMultiGradFunction>. Function Members (Methods); public:. virtual~LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(); virtual ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::BaseFunction*Clone() const; virtual const ROOT::Fit::UnBinData&Data() const; virtual doubleDataElement(const double* x, unsigned int i, double* g) const; doubleROOT::Math::IGradientMultiDim::Derivative(const double* x, unsigned int icoord = 0) const; virtual voidROOT::Math::IGradientFunctionMultiDim::FdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* g) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(const ROOT::Fit::UnBinData& data, const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction& func, int weight = 0, bool extended = false); virtual const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&ModelFunction() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NDim() const; virtual unsigned intNFitPoints() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::ResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::Type_tType() const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::UpdateNCalls() const; voidUseSumOfWeightSquare(). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) co",MatchSource.WIKI,root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html:1442,Testability,Log,LogLikelihoodFCN,1442,"ogLikelihoodGradFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IMultiGradFunction>. Function Members (Methods); public:. virtual~LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(); virtual ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::BaseFunction*Clone() const; virtual const ROOT::Fit::UnBinData&Data() const; virtual doubleDataElement(const double* x, unsigned int i, double* g) const; doubleROOT::Math::IGradientMultiDim::Derivative(const double* x, unsigned int icoord = 0) const; virtual voidROOT::Math::IGradientFunctionMultiDim::FdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* g) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(const ROOT::Fit::UnBinData& data, const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction& func, int weight = 0, bool extended = false); virtual const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&ModelFunction() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NDim() const; virtual unsigned intNFitPoints() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::ResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::Type_tType() const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::UpdateNCalls() const; voidUseSumOfWeightSquare(). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) co",MatchSource.WIKI,root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html:1549,Testability,Log,LogLikelihoodFCN,1549,"ogLikelihoodGradFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IMultiGradFunction>. Function Members (Methods); public:. virtual~LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(); virtual ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::BaseFunction*Clone() const; virtual const ROOT::Fit::UnBinData&Data() const; virtual doubleDataElement(const double* x, unsigned int i, double* g) const; doubleROOT::Math::IGradientMultiDim::Derivative(const double* x, unsigned int icoord = 0) const; virtual voidROOT::Math::IGradientFunctionMultiDim::FdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* g) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(const ROOT::Fit::UnBinData& data, const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction& func, int weight = 0, bool extended = false); virtual const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&ModelFunction() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NDim() const; virtual unsigned intNFitPoints() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::ResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::Type_tType() const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::UpdateNCalls() const; voidUseSumOfWeightSquare(). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) co",MatchSource.WIKI,root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html:1693,Testability,Log,LogLikelihoodFCN,1693,"ogLikelihoodGradFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IMultiGradFunction>. Function Members (Methods); public:. virtual~LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(); virtual ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::BaseFunction*Clone() const; virtual const ROOT::Fit::UnBinData&Data() const; virtual doubleDataElement(const double* x, unsigned int i, double* g) const; doubleROOT::Math::IGradientMultiDim::Derivative(const double* x, unsigned int icoord = 0) const; virtual voidROOT::Math::IGradientFunctionMultiDim::FdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* g) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(const ROOT::Fit::UnBinData& data, const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction& func, int weight = 0, bool extended = false); virtual const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&ModelFunction() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NDim() const; virtual unsigned intNFitPoints() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::ResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::Type_tType() const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::UpdateNCalls() const; voidUseSumOfWeightSquare(). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) co",MatchSource.WIKI,root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html:2716,Testability,Log,LogLikelihoodFCN,2716,"asicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NDim() const; virtual unsigned intNFitPoints() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::ResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::Type_tType() const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::UpdateNCalls() const; voidUseSumOfWeightSquare(). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&); ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&operator=(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::UnBinData&fData; const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; boolfIsExtendedflag for indicating if likelihood is extended; unsigned intfNEffPointsnumber of effective points used in the fit ; intfWeightflag to indicate if needs to evaluate using weight or weight squared (default weight = 0). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new LogLikelihoodFCN(fData,fFunc,fWeight,fIsExtended); ",MatchSource.WIKI,root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html:2771,Testability,Log,LogLikelihoodFCN,2771,"asicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NDim() const; virtual unsigned intNFitPoints() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::ResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::Type_tType() const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::UpdateNCalls() const; voidUseSumOfWeightSquare(). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&); ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&operator=(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::UnBinData&fData; const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; boolfIsExtendedflag for indicating if likelihood is extended; unsigned intfNEffPointsnumber of effective points used in the fit ; intfWeightflag to indicate if needs to evaluate using weight or weight squared (default weight = 0). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new LogLikelihoodFCN(fData,fFunc,fWeight,fIsExtended); ",MatchSource.WIKI,root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html:2844,Testability,Log,LogLikelihoodFCN,2844,"asicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NDim() const; virtual unsigned intNFitPoints() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::ResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::Type_tType() const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::UpdateNCalls() const; voidUseSumOfWeightSquare(). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&); ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&operator=(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::UnBinData&fData; const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; boolfIsExtendedflag for indicating if likelihood is extended; unsigned intfNEffPointsnumber of effective points used in the fit ; intfWeightflag to indicate if needs to evaluate using weight or weight squared (default weight = 0). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new LogLikelihoodFCN(fData,fFunc,fWeight,fIsExtended); ",MatchSource.WIKI,root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html:2914,Testability,Log,LogLikelihoodFCN,2914,"asicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NDim() const; virtual unsigned intNFitPoints() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::ResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::Type_tType() const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::UpdateNCalls() const; voidUseSumOfWeightSquare(). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&); ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&operator=(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::UnBinData&fData; const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; boolfIsExtendedflag for indicating if likelihood is extended; unsigned intfNEffPointsnumber of effective points used in the fit ; intfWeightflag to indicate if needs to evaluate using weight or weight squared (default weight = 0). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new LogLikelihoodFCN(fData,fFunc,fWeight,fIsExtended); ",MatchSource.WIKI,root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html:2997,Testability,Log,LogLikelihoodFCN,2997,"asicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NDim() const; virtual unsigned intNFitPoints() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::ResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::Type_tType() const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::UpdateNCalls() const; voidUseSumOfWeightSquare(). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&); ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&operator=(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::UnBinData&fData; const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; boolfIsExtendedflag for indicating if likelihood is extended; unsigned intfNEffPointsnumber of effective points used in the fit ; intfWeightflag to indicate if needs to evaluate using weight or weight squared (default weight = 0). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new LogLikelihoodFCN(fData,fFunc,fWeight,fIsExtended); ",MatchSource.WIKI,root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html:3236,Testability,Log,LogLikelihoodFCN,3236,"OOT::Math::IGradientFunctionMultiDim>::Type_tType() const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::UpdateNCalls() const; voidUseSumOfWeightSquare(). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&); ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&operator=(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::UnBinData&fData; const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; boolfIsExtendedflag for indicating if likelihood is extended; unsigned intfNEffPointsnumber of effective points used in the fit ; intfWeightflag to indicate if needs to evaluate using weight or weight squared (default weight = 0). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new LogLikelihoodFCN(fData,fFunc,fWeight,fIsExtended); }. unsigned int NFitPoints() const; using BaseObjFunction::operator();; effective points used in the fit. { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th likelihood contribution and its gradient. void Gradient(const double* x, double* g) const; need to be virtual to be instantited. void UseSumOfWeightSquare(); Use sum of the weight squared in evaluating the likelihood; (this is needed for calculating the errors). double DoEval(const double* x) const. Evaluation of the function (required by interface). dou",MatchSource.WIKI,root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html:3770,Testability,Log,LogLikelihoodFCN,3770,"OOT::Math::IGradientFunctionMultiDim>(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&); ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&operator=(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::UnBinData&fData; const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; boolfIsExtendedflag for indicating if likelihood is extended; unsigned intfNEffPointsnumber of effective points used in the fit ; intfWeightflag to indicate if needs to evaluate using weight or weight squared (default weight = 0). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new LogLikelihoodFCN(fData,fFunc,fWeight,fIsExtended); }. unsigned int NFitPoints() const; using BaseObjFunction::operator();; effective points used in the fit. { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th likelihood contribution and its gradient. void Gradient(const double* x, double* g) const; need to be virtual to be instantited. void UseSumOfWeightSquare(); Use sum of the weight squared in evaluating the likelihood; (this is needed for calculating the errors). double DoEval(const double* x) const. Evaluation of the function (required by interface). double DoDerivative(const double* x, unsigned int icoord) const; for derivatives.  Author: L. Moneta Fri Aug 17 14:29:24 2007  Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: LogLikelihoodFCN.h 42007 2011-11-15 13:23:17Z moneta $  Last generated: 2011-12-02 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation o",MatchSource.WIKI,root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html:4598,Testability,Log,LogLikelihoodFCN,4598,"LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&); ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&operator=(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::UnBinData&fData; const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; boolfIsExtendedflag for indicating if likelihood is extended; unsigned intfNEffPointsnumber of effective points used in the fit ; intfWeightflag to indicate if needs to evaluate using weight or weight squared (default weight = 0). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new LogLikelihoodFCN(fData,fFunc,fWeight,fIsExtended); }. unsigned int NFitPoints() const; using BaseObjFunction::operator();; effective points used in the fit. { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th likelihood contribution and its gradient. void Gradient(const double* x, double* g) const; need to be virtual to be instantited. void UseSumOfWeightSquare(); Use sum of the weight squared in evaluating the likelihood; (this is needed for calculating the errors). double DoEval(const double* x) const. Evaluation of the function (required by interface). double DoDerivative(const double* x, unsigned int icoord) const; for derivatives.  Author: L. Moneta Fri Aug 17 14:29:24 2007  Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: LogLikelihoodFCN.h 42007 2011-11-15 13:23:17Z moneta $  Last generated: 2011-12-02 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__ParameterSettings.html:4102,Deployability,Release,Release,4102,"e limited Parameter. SetLimits(double low, double up). ParameterSettings(const string& name, double val); constructor for fixed Parameter. {}. void Set(const string& name, double value, double step); set value and name (unlimited parameter). SetName(const string& name). SetValue(double val). SetStepSize(double err). void Set(const string& name, double value, double step, double lower, double upper); set a limited parameter. void Set(const string& name, double value); set a fixed parameter. Fix(). ~ParameterSettings(). Destructor (no operations). {}. double Value() const; copy constructor and assignment operators (leave them to the compiler); return parameter value. { return fValue; }. double StepSize() const; return step size. { return fStepSize; }. double LowerLimit() const; return lower limit value. {return fLowerLimit;}. double UpperLimit() const; return upper limit value. {return fUpperLimit;}. bool IsFixed() const; check if is fixed. { return fFix; }. bool HasLowerLimit() const; check if parameter has lower limit. {return fHasLowerLimit; }. bool HasUpperLimit() const; check if parameter has upper limit. {return fHasUpperLimit; }. bool IsBound() const; check if is bound. { return fHasLowerLimit || fHasUpperLimit; }. bool IsDoubleBound() const; check if is double bound (upper AND lower limit). { return fHasLowerLimit && fHasUpperLimit; }. const std::string & Name() const; return name. { return fName; }. void Release(); release the parameter. {fFix = false;}. RemoveLimits(). void SetUpperLimit(double up); set a single upper limit. void SetLowerLimit(double low); set a single lower limit.  Author: L. Moneta Thu Sep 21 16:21:48 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: ParameterSettings.h 37706 2011-01-05 08:54:28Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Fit__ParameterSettings.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__ParameterSettings.html
https://root.cern/root/html532/ROOT__Fit__ParameterSettings.html:4113,Deployability,release,release,4113,"e limited Parameter. SetLimits(double low, double up). ParameterSettings(const string& name, double val); constructor for fixed Parameter. {}. void Set(const string& name, double value, double step); set value and name (unlimited parameter). SetName(const string& name). SetValue(double val). SetStepSize(double err). void Set(const string& name, double value, double step, double lower, double upper); set a limited parameter. void Set(const string& name, double value); set a fixed parameter. Fix(). ~ParameterSettings(). Destructor (no operations). {}. double Value() const; copy constructor and assignment operators (leave them to the compiler); return parameter value. { return fValue; }. double StepSize() const; return step size. { return fStepSize; }. double LowerLimit() const; return lower limit value. {return fLowerLimit;}. double UpperLimit() const; return upper limit value. {return fUpperLimit;}. bool IsFixed() const; check if is fixed. { return fFix; }. bool HasLowerLimit() const; check if parameter has lower limit. {return fHasLowerLimit; }. bool HasUpperLimit() const; check if parameter has upper limit. {return fHasUpperLimit; }. bool IsBound() const; check if is bound. { return fHasLowerLimit || fHasUpperLimit; }. bool IsDoubleBound() const; check if is double bound (upper AND lower limit). { return fHasLowerLimit && fHasUpperLimit; }. const std::string & Name() const; return name. { return fName; }. void Release(); release the parameter. {fFix = false;}. RemoveLimits(). void SetUpperLimit(double up); set a single upper limit. void SetLowerLimit(double low); set a single lower limit.  Author: L. Moneta Thu Sep 21 16:21:48 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: ParameterSettings.h 37706 2011-01-05 08:54:28Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Fit__ParameterSettings.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__ParameterSettings.html
https://root.cern/root/html532/ROOT__Fit__ParameterSettings.html:2326,Modifiability,Inherit,Inheritance,2326,"t::ParameterSettingsParameterSettings(const string& name, double val, double err, double min, double max); voidRelease(); voidRemoveLimits(); voidSet(const string& name, double value); voidSet(const string& name, double value, double step); voidSet(const string& name, double value, double step, double lower, double upper); voidSetLimits(double low, double up); voidSetLowerLimit(double low); voidSetName(const string& name); voidSetStepSize(double err); voidSetUpperLimit(double up); voidSetValue(double val); doubleStepSize() const; doubleUpperLimit() const; doubleValue() const. Data Members; private:. boolfFixflag to control if parameter is fixed ; boolfHasLowerLimitflag to control lower parameter limit; boolfHasUpperLimitflag to control upper parameter limit; doublefLowerLimitlower parameter limit; stringfNameparameter name; doublefStepSizeparameter step size (used by minimizer); doublefUpperLimitupper parameter limit; doublefValueparameter value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ParameterSettings(). Default constructor. {}. ParameterSettings(const string& name, double val, double err); constructor for unlimited named Parameter. {}. ParameterSettings(const string& name, double val, double err, double min, double max); constructor for double limited Parameter. SetLimits(double low, double up). ParameterSettings(const string& name, double val); constructor for fixed Parameter. {}. void Set(const string& name, double value, double step); set value and name (unlimited parameter). SetName(const string& name). SetValue(double val). SetStepSize(double err). void Set(const string& name, double value, double step, double lower, double upper); set a limited parameter. void Set(const string& name, double value); set a fixed parameter. Fix(). ~ParameterSettings(). Destructor (no operations). {}. double Value() const; copy constructor and assignment operators (leave them to the compiler); return parameter value. { return fV",MatchSource.WIKI,root/html532/ROOT__Fit__ParameterSettings.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__ParameterSettings.html
https://root.cern/root/html532/ROOT__Fit__ParameterSettings.html:2339,Modifiability,Inherit,Inherited,2339,"t::ParameterSettingsParameterSettings(const string& name, double val, double err, double min, double max); voidRelease(); voidRemoveLimits(); voidSet(const string& name, double value); voidSet(const string& name, double value, double step); voidSet(const string& name, double value, double step, double lower, double upper); voidSetLimits(double low, double up); voidSetLowerLimit(double low); voidSetName(const string& name); voidSetStepSize(double err); voidSetUpperLimit(double up); voidSetValue(double val); doubleStepSize() const; doubleUpperLimit() const; doubleValue() const. Data Members; private:. boolfFixflag to control if parameter is fixed ; boolfHasLowerLimitflag to control lower parameter limit; boolfHasUpperLimitflag to control upper parameter limit; doublefLowerLimitlower parameter limit; stringfNameparameter name; doublefStepSizeparameter step size (used by minimizer); doublefUpperLimitupper parameter limit; doublefValueparameter value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ParameterSettings(). Default constructor. {}. ParameterSettings(const string& name, double val, double err); constructor for unlimited named Parameter. {}. ParameterSettings(const string& name, double val, double err, double min, double max); constructor for double limited Parameter. SetLimits(double low, double up). ParameterSettings(const string& name, double val); constructor for fixed Parameter. {}. void Set(const string& name, double value, double step); set value and name (unlimited parameter). SetName(const string& name). SetValue(double val). SetStepSize(double err). void Set(const string& name, double value, double step, double lower, double upper); set a limited parameter. void Set(const string& name, double value); set a fixed parameter. Fix(). ~ParameterSettings(). Destructor (no operations). {}. double Value() const; copy constructor and assignment operators (leave them to the compiler); return parameter value. { return fV",MatchSource.WIKI,root/html532/ROOT__Fit__ParameterSettings.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__ParameterSettings.html
https://root.cern/root/html532/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html:4227,Availability,error,errors,4227,":IBaseFunctionMultiDim>(const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::BinData&fData; const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; boolfIsExtendedflag to indicate if is extended (when false is a Multinomial lieklihood), default is true; unsigned intfNEffPointsnumber of effective points used in the fit; intfWeightflag to indicate if needs to evaluate using weight or weight squared (default weight = 0). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new PoissonLikelihoodFCN(fData,fFunc,fWeight,fIsExtended); }. unsigned int NFitPoints() const; effective points used in the fit. { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th likelihood element and its gradient. void Gradient(const double* x, double* g) const; evaluate gradient. bool IsWeighted() const; { return (fWeight != 0); }. void UseSumOfWeights(); Use the weights in evaluating the likelihood. void UseSumOfWeightSquare(); Use sum of the weight squared in evaluating the likelihood; (this is needed for calculating the errors). double DoEval(const double* x) const. Evaluation of the function (required by interface). double DoDerivative(const double* x, unsigned int icoord) const; for derivatives.  Author: L. Moneta Fri Aug 17 14:29:24 2007  Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: PoissonLikelihoodFCN.h 42007 2011-11-15 13:23:17Z moneta $  Last generated: 2011-12-02 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html:2343,Deployability,Update,UpdateNCalls,2343,"t case. @ingroup FitMethodFunc. This class is also known as (typedefs to this class)ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IMultiGenFunction>, ROOT::Fit::PoissonLLFunction. Function Members (Methods); public:. virtual~PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(); virtual ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::BaseFunction*Clone() const; virtual const ROOT::Fit::BinData&Data() const; virtual doubleDataElement(const double* x, unsigned int i, double* g) const; virtual voidGradient(const double* x, double* g) const; boolIsWeighted() const; virtual const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction&ModelFunction() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NDim() const; virtual unsigned intNFitPoints() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(const ROOT::Fit::BinData& data, const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction& func, int weight = 0, bool extended = true); virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::ResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::Type_tType() const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::UpdateNCalls() const; voidUseSumOfWeights(); voidUseSumOfWeightSquare(). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const; ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&operator=(const ROO",MatchSource.WIKI,root/html532/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html:4314,Integrability,interface,interface,4314,":IBaseFunctionMultiDim>(const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::BinData&fData; const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; boolfIsExtendedflag to indicate if is extended (when false is a Multinomial lieklihood), default is true; unsigned intfNEffPointsnumber of effective points used in the fit; intfWeightflag to indicate if needs to evaluate using weight or weight squared (default weight = 0). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new PoissonLikelihoodFCN(fData,fFunc,fWeight,fIsExtended); }. unsigned int NFitPoints() const; effective points used in the fit. { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th likelihood element and its gradient. void Gradient(const double* x, double* g) const; evaluate gradient. bool IsWeighted() const; { return (fWeight != 0); }. void UseSumOfWeights(); Use the weights in evaluating the likelihood. void UseSumOfWeightSquare(); Use sum of the weight squared in evaluating the likelihood; (this is needed for calculating the errors). double DoEval(const double* x) const. Evaluation of the function (required by interface). double DoDerivative(const double* x, unsigned int icoord) const; for derivatives.  Author: L. Moneta Fri Aug 17 14:29:24 2007  Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: PoissonLikelihoodFCN.h 42007 2011-11-15 13:23:17Z moneta $  Last generated: 2011-12-02 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html:2045,Modifiability,extend,extended,2045,"t case. @ingroup FitMethodFunc. This class is also known as (typedefs to this class)ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IMultiGenFunction>, ROOT::Fit::PoissonLLFunction. Function Members (Methods); public:. virtual~PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(); virtual ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::BaseFunction*Clone() const; virtual const ROOT::Fit::BinData&Data() const; virtual doubleDataElement(const double* x, unsigned int i, double* g) const; virtual voidGradient(const double* x, double* g) const; boolIsWeighted() const; virtual const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction&ModelFunction() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NDim() const; virtual unsigned intNFitPoints() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(const ROOT::Fit::BinData& data, const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction& func, int weight = 0, bool extended = true); virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::ResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::Type_tType() const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::UpdateNCalls() const; voidUseSumOfWeights(); voidUseSumOfWeightSquare(). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const; ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&operator=(const ROO",MatchSource.WIKI,root/html532/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html:3225,Modifiability,extend,extended,3225,"ype_tType() const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::UpdateNCalls() const; voidUseSumOfWeights(); voidUseSumOfWeightSquare(). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const; ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&operator=(const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&); ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::BinData&fData; const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; boolfIsExtendedflag to indicate if is extended (when false is a Multinomial lieklihood), default is true; unsigned intfNEffPointsnumber of effective points used in the fit; intfWeightflag to indicate if needs to evaluate using weight or weight squared (default weight = 0). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new PoissonLikelihoodFCN(fData,fFunc,fWeight,fIsExtended); }. unsigned int NFitPoints() const; effective points used in the fit. { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th likelihood element and its gradient. void Gradient(const double* x, double* g) const; evaluate gradient. bool IsWeighted() const; { return (fWeight != 0); }. void UseSumOfWeights(); Use the weights in evaluating the likelihood. void UseSumOfWeightSquare(); Use sum of the weight squared in evaluating the likelihood; (this is needed for calculating the errors). doubl",MatchSource.WIKI,root/html532/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html:3475,Modifiability,Inherit,Inheritance,3475,"rtual doubleDoEval(const double* x) const; ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&operator=(const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&); ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::BinData&fData; const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; boolfIsExtendedflag to indicate if is extended (when false is a Multinomial lieklihood), default is true; unsigned intfNEffPointsnumber of effective points used in the fit; intfWeightflag to indicate if needs to evaluate using weight or weight squared (default weight = 0). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new PoissonLikelihoodFCN(fData,fFunc,fWeight,fIsExtended); }. unsigned int NFitPoints() const; effective points used in the fit. { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th likelihood element and its gradient. void Gradient(const double* x, double* g) const; evaluate gradient. bool IsWeighted() const; { return (fWeight != 0); }. void UseSumOfWeights(); Use the weights in evaluating the likelihood. void UseSumOfWeightSquare(); Use sum of the weight squared in evaluating the likelihood; (this is needed for calculating the errors). double DoEval(const double* x) const. Evaluation of the function (required by interface). double DoDerivative(const double* x, unsigned int icoord) const; for derivatives.  Author: L. Moneta Fri Aug 17 14:29:24 2007  Copyright (c) 2007 LCG ROOT Math Team, CERN/PH",MatchSource.WIKI,root/html532/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html:3488,Modifiability,Inherit,Inherited,3488,"rtual doubleDoEval(const double* x) const; ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&operator=(const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&); ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::BinData&fData; const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; boolfIsExtendedflag to indicate if is extended (when false is a Multinomial lieklihood), default is true; unsigned intfNEffPointsnumber of effective points used in the fit; intfWeightflag to indicate if needs to evaluate using weight or weight squared (default weight = 0). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new PoissonLikelihoodFCN(fData,fFunc,fWeight,fIsExtended); }. unsigned int NFitPoints() const; effective points used in the fit. { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th likelihood element and its gradient. void Gradient(const double* x, double* g) const; evaluate gradient. bool IsWeighted() const; { return (fWeight != 0); }. void UseSumOfWeights(); Use the weights in evaluating the likelihood. void UseSumOfWeightSquare(); Use sum of the weight squared in evaluating the likelihood; (this is needed for calculating the errors). double DoEval(const double* x) const. Evaluation of the function (required by interface). double DoDerivative(const double* x, unsigned int icoord) const; for derivatives.  Author: L. Moneta Fri Aug 17 14:29:24 2007  Copyright (c) 2007 LCG ROOT Math Team, CERN/PH",MatchSource.WIKI,root/html532/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html:522,Testability,log,log,522,". ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>. class ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>: public ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>. class evaluating the log likelihood; for binned Poisson likelihood fits; it is template to distinguish gradient and non-gradient case. @ingroup FitMethodFunc. This class is also known as (typedefs to this class)ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IMultiGenFunction>, ROOT::Fit::PoissonLLFunction. Function Members (Methods); public:. virtual~PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(); virtual ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::BaseFunction*Clone() const; virtual const ROOT::Fit::BinData&Data() const; virtual doubleDataElement(const double* x, unsigned int i, double* g) const; virtual voidGradient(const double* x, double* g) const; boolIsWeighted() const; virtual const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction&ModelFunction() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NDim() const; virtual unsigned intNFitPoints() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(const ROOT::Fit::BinData& data, const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>:",MatchSource.WIKI,root/html532/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html:4519,Availability,error,errors,4519,"nctionMultiDim>(const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::BinData&fData; const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; boolfIsExtendedflag to indicate if is extended (when false is a Multinomial lieklihood), default is true; unsigned intfNEffPointsnumber of effective points used in the fit; intfWeightflag to indicate if needs to evaluate using weight or weight squared (default weight = 0). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new PoissonLikelihoodFCN(fData,fFunc,fWeight,fIsExtended); }. unsigned int NFitPoints() const; effective points used in the fit. { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th likelihood element and its gradient. void Gradient(const double* x, double* g) const; evaluate gradient. bool IsWeighted() const; { return (fWeight != 0); }. void UseSumOfWeights(); Use the weights in evaluating the likelihood. void UseSumOfWeightSquare(); Use sum of the weight squared in evaluating the likelihood; (this is needed for calculating the errors). double DoEval(const double* x) const. Evaluation of the function (required by interface). double DoDerivative(const double* x, unsigned int icoord) const; for derivatives.  Author: L. Moneta Fri Aug 17 14:29:24 2007  Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: PoissonLikelihoodFCN.h 42007 2011-11-15 13:23:17Z moneta $  Last generated: 2011-12-02 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html:2611,Deployability,Update,UpdateNCalls,2611,"PoissonLikelihoodFCN<ROOT::Math::IMultiGradFunction>. Function Members (Methods); public:. virtual~PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(); virtual ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::BaseFunction*Clone() const; virtual const ROOT::Fit::BinData&Data() const; virtual doubleDataElement(const double* x, unsigned int i, double* g) const; doubleROOT::Math::IGradientMultiDim::Derivative(const double* x, unsigned int icoord = 0) const; virtual voidROOT::Math::IGradientFunctionMultiDim::FdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* g) const; boolIsWeighted() const; virtual const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&ModelFunction() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NDim() const; virtual unsigned intNFitPoints() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(const ROOT::Fit::BinData& data, const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction& func, int weight = 0, bool extended = true); virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::ResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::Type_tType() const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::UpdateNCalls() const; voidUseSumOfWeights(); voidUseSumOfWeightSquare(). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual",MatchSource.WIKI,root/html532/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html:4606,Integrability,interface,interface,4606,"nctionMultiDim>(const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::BinData&fData; const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; boolfIsExtendedflag to indicate if is extended (when false is a Multinomial lieklihood), default is true; unsigned intfNEffPointsnumber of effective points used in the fit; intfWeightflag to indicate if needs to evaluate using weight or weight squared (default weight = 0). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new PoissonLikelihoodFCN(fData,fFunc,fWeight,fIsExtended); }. unsigned int NFitPoints() const; effective points used in the fit. { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th likelihood element and its gradient. void Gradient(const double* x, double* g) const; evaluate gradient. bool IsWeighted() const; { return (fWeight != 0); }. void UseSumOfWeights(); Use the weights in evaluating the likelihood. void UseSumOfWeightSquare(); Use sum of the weight squared in evaluating the likelihood; (this is needed for calculating the errors). double DoEval(const double* x) const. Evaluation of the function (required by interface). double DoDerivative(const double* x, unsigned int icoord) const; for derivatives.  Author: L. Moneta Fri Aug 17 14:29:24 2007  Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: PoissonLikelihoodFCN.h 42007 2011-11-15 13:23:17Z moneta $  Last generated: 2011-12-02 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html:2301,Modifiability,extend,extended,2301,"PoissonLikelihoodFCN<ROOT::Math::IMultiGradFunction>. Function Members (Methods); public:. virtual~PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(); virtual ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::BaseFunction*Clone() const; virtual const ROOT::Fit::BinData&Data() const; virtual doubleDataElement(const double* x, unsigned int i, double* g) const; doubleROOT::Math::IGradientMultiDim::Derivative(const double* x, unsigned int icoord = 0) const; virtual voidROOT::Math::IGradientFunctionMultiDim::FdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* g) const; boolIsWeighted() const; virtual const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&ModelFunction() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NDim() const; virtual unsigned intNFitPoints() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(const ROOT::Fit::BinData& data, const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction& func, int weight = 0, bool extended = true); virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::ResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::Type_tType() const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::UpdateNCalls() const; voidUseSumOfWeights(); voidUseSumOfWeightSquare(). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual",MatchSource.WIKI,root/html532/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html:3517,Modifiability,extend,extended,3517," voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::UpdateNCalls() const; voidUseSumOfWeights(); voidUseSumOfWeightSquare(). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const; ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&operator=(const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&); ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::BinData&fData; const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; boolfIsExtendedflag to indicate if is extended (when false is a Multinomial lieklihood), default is true; unsigned intfNEffPointsnumber of effective points used in the fit; intfWeightflag to indicate if needs to evaluate using weight or weight squared (default weight = 0). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new PoissonLikelihoodFCN(fData,fFunc,fWeight,fIsExtended); }. unsigned int NFitPoints() const; effective points used in the fit. { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th likelihood element and its gradient. void Gradient(const double* x, double* g) const; evaluate gradient. bool IsWeighted() const; { return (fWeight != 0); }. void UseSumOfWeights(); Use the weights in evaluating the likelihood. void UseSumOfWeightSquare(); Use sum of the weight squared in evaluating the likelihood; (this is needed for calculating the errors). dou",MatchSource.WIKI,root/html532/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html:3767,Modifiability,Inherit,Inheritance,3767," double* x) const; ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&operator=(const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&); ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::BinData&fData; const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; boolfIsExtendedflag to indicate if is extended (when false is a Multinomial lieklihood), default is true; unsigned intfNEffPointsnumber of effective points used in the fit; intfWeightflag to indicate if needs to evaluate using weight or weight squared (default weight = 0). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new PoissonLikelihoodFCN(fData,fFunc,fWeight,fIsExtended); }. unsigned int NFitPoints() const; effective points used in the fit. { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th likelihood element and its gradient. void Gradient(const double* x, double* g) const; evaluate gradient. bool IsWeighted() const; { return (fWeight != 0); }. void UseSumOfWeights(); Use the weights in evaluating the likelihood. void UseSumOfWeightSquare(); Use sum of the weight squared in evaluating the likelihood; (this is needed for calculating the errors). double DoEval(const double* x) const. Evaluation of the function (required by interface). double DoDerivative(const double* x, unsigned int icoord) const; for derivatives.  Author: L. Moneta Fri Aug 17 14:29:24 2007  Copyright (c) 2007 LCG ROOT Math Team, CERN/PH",MatchSource.WIKI,root/html532/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html:3780,Modifiability,Inherit,Inherited,3780," double* x) const; ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&operator=(const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&); ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::BinData&fData; const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; boolfIsExtendedflag to indicate if is extended (when false is a Multinomial lieklihood), default is true; unsigned intfNEffPointsnumber of effective points used in the fit; intfWeightflag to indicate if needs to evaluate using weight or weight squared (default weight = 0). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new PoissonLikelihoodFCN(fData,fFunc,fWeight,fIsExtended); }. unsigned int NFitPoints() const; effective points used in the fit. { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th likelihood element and its gradient. void Gradient(const double* x, double* g) const; evaluate gradient. bool IsWeighted() const; { return (fWeight != 0); }. void UseSumOfWeights(); Use the weights in evaluating the likelihood. void UseSumOfWeightSquare(); Use sum of the weight squared in evaluating the likelihood; (this is needed for calculating the errors). double DoEval(const double* x) const. Evaluation of the function (required by interface). double DoDerivative(const double* x, unsigned int icoord) const; for derivatives.  Author: L. Moneta Fri Aug 17 14:29:24 2007  Copyright (c) 2007 LCG ROOT Math Team, CERN/PH",MatchSource.WIKI,root/html532/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html:538,Testability,log,log,538,". ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>. class ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>: public ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>. class evaluating the log likelihood; for binned Poisson likelihood fits; it is template to distinguish gradient and non-gradient case. @ingroup FitMethodFunc. This class is also known as (typedefs to this class)ROOT::Fit::PoissonLLGradFunction, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IMultiGradFunction>. Function Members (Methods); public:. virtual~PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(); virtual ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::BaseFunction*Clone() const; virtual const ROOT::Fit::BinData&Data() const; virtual doubleDataElement(const double* x, unsigned int i, double* g) const; doubleROOT::Math::IGradientMultiDim::Derivative(const double* x, unsigned int icoord = 0) const; virtual voidROOT::Math::IGradientFunctionMultiDim::FdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* g) const; boolIsWeighted() const; virtual const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&ModelFunction() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NDim() const; virtual unsigned intNFitPoints() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const d",MatchSource.WIKI,root/html532/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Fit__SparseData.html:459,Availability,error,error,459,". ROOT::Fit::SparseData. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::SparseData. class ROOT::Fit::SparseData: public ROOT::Fit::FitData. Function Members (Methods); public:. virtual~SparseData(); voidAdd(vector<double>& min, vector<double>& max, const double content, const double error = 1.0); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::DataOptions& opt); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::DataRange& range); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::FitData&); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range); voidGetBinData(ROOT::Fit::BinData&) const; voidGetBinDataIntegral(ROOT::Fit::BinData&) const; voidGetBinDataNoZeros(ROOT::Fit::BinData&) const; voidGetPoint(const unsigned int i, vector<double>& min, vector<double>& max, double& content, double& error); static unsigned intROOT::Fit::FitData::MaxSize(); unsigned intNDim() const; unsigned intNPoints() const; ROOT::Fit::SparseData&operator=(const ROOT::Fit::SparseData&); const ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt() const; ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt(); voidPrintList() const; const ROOT::Fit::DataRange&ROOT::Fit::FitData::Range() const; ROOT::Fit::SparseDataSparseData(const ROOT::Fit::SparseData&); ROOT::Fit::SparseDataSparseData(vector<double>& min, vector<double>& max); ROOT::Fit::SparseDataSparseData(const unsigned int dim, double* min, double* max). Data Members; private:. ROOT::Fit::ProxyListBox*fList. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SparseData(vector<double>& min, vector<double>& max); Constructor with a vector. SparseData(const unsigned int dim, double* min, double* m",MatchSource.WIKI,root/html532/ROOT__Fit__SparseData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__SparseData.html
https://root.cern/root/html532/ROOT__Fit__SparseData.html:1123,Availability,error,error,1123,"Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::SparseData. class ROOT::Fit::SparseData: public ROOT::Fit::FitData. Function Members (Methods); public:. virtual~SparseData(); voidAdd(vector<double>& min, vector<double>& max, const double content, const double error = 1.0); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::DataOptions& opt); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::DataRange& range); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::FitData&); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range); voidGetBinData(ROOT::Fit::BinData&) const; voidGetBinDataIntegral(ROOT::Fit::BinData&) const; voidGetBinDataNoZeros(ROOT::Fit::BinData&) const; voidGetPoint(const unsigned int i, vector<double>& min, vector<double>& max, double& content, double& error); static unsigned intROOT::Fit::FitData::MaxSize(); unsigned intNDim() const; unsigned intNPoints() const; ROOT::Fit::SparseData&operator=(const ROOT::Fit::SparseData&); const ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt() const; ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt(); voidPrintList() const; const ROOT::Fit::DataRange&ROOT::Fit::FitData::Range() const; ROOT::Fit::SparseDataSparseData(const ROOT::Fit::SparseData&); ROOT::Fit::SparseDataSparseData(vector<double>& min, vector<double>& max); ROOT::Fit::SparseDataSparseData(const unsigned int dim, double* min, double* max). Data Members; private:. ROOT::Fit::ProxyListBox*fList. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SparseData(vector<double>& min, vector<double>& max); Constructor with a vector. SparseData(const unsigned int dim, double* min, double* max); Constructor with a dimension and two arrays. ~SparseData(); Destructor. unsigned int NP",MatchSource.WIKI,root/html532/ROOT__Fit__SparseData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__SparseData.html
https://root.cern/root/html532/ROOT__Fit__SparseData.html:2302,Availability,error,error,2302," double& error); static unsigned intROOT::Fit::FitData::MaxSize(); unsigned intNDim() const; unsigned intNPoints() const; ROOT::Fit::SparseData&operator=(const ROOT::Fit::SparseData&); const ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt() const; ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt(); voidPrintList() const; const ROOT::Fit::DataRange&ROOT::Fit::FitData::Range() const; ROOT::Fit::SparseDataSparseData(const ROOT::Fit::SparseData&); ROOT::Fit::SparseDataSparseData(vector<double>& min, vector<double>& max); ROOT::Fit::SparseDataSparseData(const unsigned int dim, double* min, double* max). Data Members; private:. ROOT::Fit::ProxyListBox*fList. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SparseData(vector<double>& min, vector<double>& max); Constructor with a vector. SparseData(const unsigned int dim, double* min, double* max); Constructor with a dimension and two arrays. ~SparseData(); Destructor. unsigned int NPoints() const; Returns the number of points stored. unsigned int NDim() const; Returns the dimension of the object (bins). void Add(vector<double>& min, vector<double>& max, const double content, const double error = 1.0); Adds a new bin specified by the vectors. void PrintList() const; Debug method to print the list of bins stored. void GetBinData(ROOT::Fit::BinData& ) const; Transforms the data into a ROOT::Fit::BinData structure. void GetBinDataIntegral(ROOT::Fit::BinData& ) const; Same as before, but with integral format. void GetBinDataNoZeros(ROOT::Fit::BinData& ) const; Same as before, but including zero content bins.  Author: David Gonzalez Maline Wed Aug 28 15:23:43 2009  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: SparseData.h 35349 2010-09-17 09:25:00Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Fit__SparseData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__SparseData.html
https://root.cern/root/html532/ROOT__Fit__SparseData.html:1786,Modifiability,Inherit,Inheritance,1786," ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range); voidGetBinData(ROOT::Fit::BinData&) const; voidGetBinDataIntegral(ROOT::Fit::BinData&) const; voidGetBinDataNoZeros(ROOT::Fit::BinData&) const; voidGetPoint(const unsigned int i, vector<double>& min, vector<double>& max, double& content, double& error); static unsigned intROOT::Fit::FitData::MaxSize(); unsigned intNDim() const; unsigned intNPoints() const; ROOT::Fit::SparseData&operator=(const ROOT::Fit::SparseData&); const ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt() const; ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt(); voidPrintList() const; const ROOT::Fit::DataRange&ROOT::Fit::FitData::Range() const; ROOT::Fit::SparseDataSparseData(const ROOT::Fit::SparseData&); ROOT::Fit::SparseDataSparseData(vector<double>& min, vector<double>& max); ROOT::Fit::SparseDataSparseData(const unsigned int dim, double* min, double* max). Data Members; private:. ROOT::Fit::ProxyListBox*fList. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SparseData(vector<double>& min, vector<double>& max); Constructor with a vector. SparseData(const unsigned int dim, double* min, double* max); Constructor with a dimension and two arrays. ~SparseData(); Destructor. unsigned int NPoints() const; Returns the number of points stored. unsigned int NDim() const; Returns the dimension of the object (bins). void Add(vector<double>& min, vector<double>& max, const double content, const double error = 1.0); Adds a new bin specified by the vectors. void PrintList() const; Debug method to print the list of bins stored. void GetBinData(ROOT::Fit::BinData& ) const; Transforms the data into a ROOT::Fit::BinData structure. void GetBinDataIntegral(ROOT::Fit::BinData& ) const; Same as before, but with integral format. void GetBinDataNoZeros(ROOT::Fit::BinData& ) const; Same as before, but including zero content bins.  Author: David Gonzalez Maline Wed Aug 28 15:23:43 2009  Copyright (c) 2006 LCG ROOT",MatchSource.WIKI,root/html532/ROOT__Fit__SparseData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__SparseData.html
https://root.cern/root/html532/ROOT__Fit__SparseData.html:1799,Modifiability,Inherit,Inherited,1799," ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range); voidGetBinData(ROOT::Fit::BinData&) const; voidGetBinDataIntegral(ROOT::Fit::BinData&) const; voidGetBinDataNoZeros(ROOT::Fit::BinData&) const; voidGetPoint(const unsigned int i, vector<double>& min, vector<double>& max, double& content, double& error); static unsigned intROOT::Fit::FitData::MaxSize(); unsigned intNDim() const; unsigned intNPoints() const; ROOT::Fit::SparseData&operator=(const ROOT::Fit::SparseData&); const ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt() const; ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt(); voidPrintList() const; const ROOT::Fit::DataRange&ROOT::Fit::FitData::Range() const; ROOT::Fit::SparseDataSparseData(const ROOT::Fit::SparseData&); ROOT::Fit::SparseDataSparseData(vector<double>& min, vector<double>& max); ROOT::Fit::SparseDataSparseData(const unsigned int dim, double* min, double* max). Data Members; private:. ROOT::Fit::ProxyListBox*fList. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SparseData(vector<double>& min, vector<double>& max); Constructor with a vector. SparseData(const unsigned int dim, double* min, double* max); Constructor with a dimension and two arrays. ~SparseData(); Destructor. unsigned int NPoints() const; Returns the number of points stored. unsigned int NDim() const; Returns the dimension of the object (bins). void Add(vector<double>& min, vector<double>& max, const double content, const double error = 1.0); Adds a new bin specified by the vectors. void PrintList() const; Debug method to print the list of bins stored. void GetBinData(ROOT::Fit::BinData& ) const; Transforms the data into a ROOT::Fit::BinData structure. void GetBinDataIntegral(ROOT::Fit::BinData& ) const; Same as before, but with integral format. void GetBinDataNoZeros(ROOT::Fit::BinData& ) const; Same as before, but including zero content bins.  Author: David Gonzalez Maline Wed Aug 28 15:23:43 2009  Copyright (c) 2006 LCG ROOT",MatchSource.WIKI,root/html532/ROOT__Fit__SparseData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__SparseData.html
https://root.cern/root/html532/ROOT__Fit__UnBinData.html:579,Energy Efficiency,efficient,efficient,579,". ROOT::Fit::UnBinData. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::UnBinData. class ROOT::Fit::UnBinData: public ROOT::Fit::FitData. Class describing the unbinned data sets (just x coordinates values) of any dimensions. There is the option to construct UnBindata copying the data in (using the DataVector class); or using pointer to external data (DataWrapper) class.; In general is found to be more efficient to copy the data.; In case of really large data sets for limiting memory consumption then the other option can be used; Specialized constructor exists for using external data up to 3 dimensions. When the data are copying in the number of points can be set later (or re-set) using Initialize and; the data are inserted one by one using the Add method.; It is mandatory to set the size before using the Add method. @ingroup FitData. Function Members (Methods); public:. virtual~UnBinData(); voidAdd(double x); voidAdd(const double* x); voidAdd(double x, double y); voidAdd(const double* x, double w); voidAdd(double x, double y, double z); const double*Coords(unsigned int ipoint) const; unsigned intDataSize() const; ROOT::Fit::FitDataROOT::Fit::FitData::FitData(); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::DataOptions& opt); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::DataRange& range); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::FitData&); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range); voidInitialize(unsigned int maxpoints, unsigned int dim = 1, bool isWeighted = false); boolIsWeighted() const; static unsigned intROOT::Fit::FitData::MaxSize(); unsigned intNDim() const; unsigned intNPoints() const; const ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt() const; ROOT::Fit::Dat",MatchSource.WIKI,root/html532/ROOT__Fit__UnBinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__UnBinData.html
https://root.cern/root/html532/ROOT__Fit__UnBinData.html:662,Energy Efficiency,consumption,consumption,662,". ROOT::Fit::UnBinData. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::UnBinData. class ROOT::Fit::UnBinData: public ROOT::Fit::FitData. Class describing the unbinned data sets (just x coordinates values) of any dimensions. There is the option to construct UnBindata copying the data in (using the DataVector class); or using pointer to external data (DataWrapper) class.; In general is found to be more efficient to copy the data.; In case of really large data sets for limiting memory consumption then the other option can be used; Specialized constructor exists for using external data up to 3 dimensions. When the data are copying in the number of points can be set later (or re-set) using Initialize and; the data are inserted one by one using the Add method.; It is mandatory to set the size before using the Add method. @ingroup FitData. Function Members (Methods); public:. virtual~UnBinData(); voidAdd(double x); voidAdd(const double* x); voidAdd(double x, double y); voidAdd(const double* x, double w); voidAdd(double x, double y, double z); const double*Coords(unsigned int ipoint) const; unsigned intDataSize() const; ROOT::Fit::FitDataROOT::Fit::FitData::FitData(); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::DataOptions& opt); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::DataRange& range); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::FitData&); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range); voidInitialize(unsigned int maxpoints, unsigned int dim = 1, bool isWeighted = false); boolIsWeighted() const; static unsigned intROOT::Fit::FitData::MaxSize(); unsigned intNDim() const; unsigned intNPoints() const; const ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt() const; ROOT::Fit::Dat",MatchSource.WIKI,root/html532/ROOT__Fit__UnBinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__UnBinData.html
https://root.cern/root/html532/ROOT__Fit__UnBinData.html:4222,Energy Efficiency,allocate,allocate,4222,"); ROOT::Fit::UnBinDataUnBinData(unsigned int maxpoints, const double* dataX, const double* dataY, const double* dataZ, const ROOT::Fit::DataRange& range, bool isWeighted = false); doubleWeight(unsigned int ipoint) const. protected:. voidSetNPoints(unsigned int n). private:. ROOT::Fit::UnBinData&operator=(const ROOT::Fit::UnBinData&); ROOT::Fit::UnBinDataUnBinData(const ROOT::Fit::UnBinData&). Data Members; private:. ROOT::Fit::DataVector*fDataVectorpointer to internal data vector (null for external data); ROOT::Fit::DataWrapper*fDataWrapperpointer to structure wrapping external data (null when data are copied in); unsigned intfDimcoordinate data dimension; unsigned intfNPointsnumer of fit points; unsigned intfPointSizepoit size dimension (coordinate + weight). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; explicit UnBinData(unsigned int maxpoints = 0, unsigned int dim = 1, bool isWeighted = false). constructor from dimension of point and max number of points (to pre-allocate vector). explicit UnBinData(const ROOT::Fit::DataRange& range, unsigned int maxpoints = 0, unsigned int dim = 1, bool isWeighted = false). constructor from range and default option. UnBinData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range, unsigned int maxpoints = 0, unsigned int dim = 1, bool isWeighted = false). constructor from options and range. UnBinData(unsigned int n, const double* dataX). constructor for 1D external data (data are not copied inside). UnBinData(unsigned int n, const double* dataX, const double* dataY, bool isWeighted = false). constructor for 2D external data (data are not copied inside); or 1D data with a weight (if isWeighted = true). UnBinData(unsigned int n, const double* dataX, const double* dataY, const double* dataZ, bool isWeighted = false). constructor for 3D external data (data are not copied inside); or 2D data with a weight (if isWeighted = true). UnBinData(unsigned int n, const double* dataX, ",MatchSource.WIKI,root/html532/ROOT__Fit__UnBinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__UnBinData.html
https://root.cern/root/html532/ROOT__Fit__UnBinData.html:3763,Integrability,wrap,wrapping,3763,"opt, const ROOT::Fit::DataRange& range, unsigned int maxpoints = 0, unsigned int dim = 1, bool isWeighted = false); ROOT::Fit::UnBinDataUnBinData(unsigned int n, const double* dataX, const double* dataY, const double* dataZ, bool isWeighted = false); ROOT::Fit::UnBinDataUnBinData(unsigned int maxpoints, const double* dataX, const double* dataY, const ROOT::Fit::DataRange& range, bool isWeighted = false); ROOT::Fit::UnBinDataUnBinData(unsigned int maxpoints, const double* dataX, const double* dataY, const double* dataZ, const ROOT::Fit::DataRange& range, bool isWeighted = false); doubleWeight(unsigned int ipoint) const. protected:. voidSetNPoints(unsigned int n). private:. ROOT::Fit::UnBinData&operator=(const ROOT::Fit::UnBinData&); ROOT::Fit::UnBinDataUnBinData(const ROOT::Fit::UnBinData&). Data Members; private:. ROOT::Fit::DataVector*fDataVectorpointer to internal data vector (null for external data); ROOT::Fit::DataWrapper*fDataWrapperpointer to structure wrapping external data (null when data are copied in); unsigned intfDimcoordinate data dimension; unsigned intfNPointsnumer of fit points; unsigned intfPointSizepoit size dimension (coordinate + weight). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; explicit UnBinData(unsigned int maxpoints = 0, unsigned int dim = 1, bool isWeighted = false). constructor from dimension of point and max number of points (to pre-allocate vector). explicit UnBinData(const ROOT::Fit::DataRange& range, unsigned int maxpoints = 0, unsigned int dim = 1, bool isWeighted = false). constructor from range and default option. UnBinData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range, unsigned int maxpoints = 0, unsigned int dim = 1, bool isWeighted = false). constructor from options and range. UnBinData(unsigned int n, const double* dataX). constructor for 1D external data (data are not copied inside). UnBinData(unsigned int n, const double* dataX, const double* dataY, bool is",MatchSource.WIKI,root/html532/ROOT__Fit__UnBinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__UnBinData.html
https://root.cern/root/html532/ROOT__Fit__UnBinData.html:6623,Integrability,wrap,wrapper,6623,"nBinData(unsigned int maxpoints, const double* dataX, const ROOT::Fit::DataRange& range). constructor for 1D data and a range (data are copied inside according to the given range). UnBinData(unsigned int maxpoints, const double* dataX, const double* dataY, const ROOT::Fit::DataRange& range, bool isWeighted = false). constructor for 2D data and a range (data are copied inside according to the given range); or 1 1D data set + weight. If is weighted dataY is the pointer to the list of the weights. UnBinData(unsigned int maxpoints, const double* dataX, const double* dataY, const double* dataZ, const ROOT::Fit::DataRange& range, bool isWeighted = false). constructor for 3D data and a range (data are copied inside according to the given range); or a 2D data set + weights. If is weighted dataZ is the pointer to the list of the weights. UnBinData & operator=(const ROOT::Fit::UnBinData& ); assignment operator (private). { return *this; }. virtual ~UnBinData(). destructor, delete pointer to internal data or external data wrapper. void Initialize(unsigned int maxpoints, unsigned int dim = 1, bool isWeighted = false). preallocate a data set given size and dimension of the coordinates; if a vector already exists with correct dimension (point size) extend the existing one; to a total size of maxpoints (equivalent to a Resize). void Add(double x). add one dim coordinate data (unweighted). void Add(double x, double y). add 2-dim coordinate data; can also be used to add 1-dim data with a weight. void Add(double x, double y, double z). add 3-dim coordinate data; can also be used to add 2-dim data with a weight. void Add(const double* x). add multi-dim coordinate data. void Add(const double* x, double w). add multi-dim coordinate data + weight. const double * Coords(unsigned int ipoint) const. return pointer to coordinate data. bool IsWeighted() const. double Weight(unsigned int ipoint) const. void Resize(unsigned int npoints). resize the vector to the given npoints. unsigned int NPoi",MatchSource.WIKI,root/html532/ROOT__Fit__UnBinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__UnBinData.html
https://root.cern/root/html532/ROOT__Fit__UnBinData.html:3981,Modifiability,Inherit,Inheritance,3981,"* dataZ, bool isWeighted = false); ROOT::Fit::UnBinDataUnBinData(unsigned int maxpoints, const double* dataX, const double* dataY, const ROOT::Fit::DataRange& range, bool isWeighted = false); ROOT::Fit::UnBinDataUnBinData(unsigned int maxpoints, const double* dataX, const double* dataY, const double* dataZ, const ROOT::Fit::DataRange& range, bool isWeighted = false); doubleWeight(unsigned int ipoint) const. protected:. voidSetNPoints(unsigned int n). private:. ROOT::Fit::UnBinData&operator=(const ROOT::Fit::UnBinData&); ROOT::Fit::UnBinDataUnBinData(const ROOT::Fit::UnBinData&). Data Members; private:. ROOT::Fit::DataVector*fDataVectorpointer to internal data vector (null for external data); ROOT::Fit::DataWrapper*fDataWrapperpointer to structure wrapping external data (null when data are copied in); unsigned intfDimcoordinate data dimension; unsigned intfNPointsnumer of fit points; unsigned intfPointSizepoit size dimension (coordinate + weight). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; explicit UnBinData(unsigned int maxpoints = 0, unsigned int dim = 1, bool isWeighted = false). constructor from dimension of point and max number of points (to pre-allocate vector). explicit UnBinData(const ROOT::Fit::DataRange& range, unsigned int maxpoints = 0, unsigned int dim = 1, bool isWeighted = false). constructor from range and default option. UnBinData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range, unsigned int maxpoints = 0, unsigned int dim = 1, bool isWeighted = false). constructor from options and range. UnBinData(unsigned int n, const double* dataX). constructor for 1D external data (data are not copied inside). UnBinData(unsigned int n, const double* dataX, const double* dataY, bool isWeighted = false). constructor for 2D external data (data are not copied inside); or 1D data with a weight (if isWeighted = true). UnBinData(unsigned int n, const double* dataX, const double* dataY, const double* dat",MatchSource.WIKI,root/html532/ROOT__Fit__UnBinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__UnBinData.html
https://root.cern/root/html532/ROOT__Fit__UnBinData.html:3994,Modifiability,Inherit,Inherited,3994,"* dataZ, bool isWeighted = false); ROOT::Fit::UnBinDataUnBinData(unsigned int maxpoints, const double* dataX, const double* dataY, const ROOT::Fit::DataRange& range, bool isWeighted = false); ROOT::Fit::UnBinDataUnBinData(unsigned int maxpoints, const double* dataX, const double* dataY, const double* dataZ, const ROOT::Fit::DataRange& range, bool isWeighted = false); doubleWeight(unsigned int ipoint) const. protected:. voidSetNPoints(unsigned int n). private:. ROOT::Fit::UnBinData&operator=(const ROOT::Fit::UnBinData&); ROOT::Fit::UnBinDataUnBinData(const ROOT::Fit::UnBinData&). Data Members; private:. ROOT::Fit::DataVector*fDataVectorpointer to internal data vector (null for external data); ROOT::Fit::DataWrapper*fDataWrapperpointer to structure wrapping external data (null when data are copied in); unsigned intfDimcoordinate data dimension; unsigned intfNPointsnumer of fit points; unsigned intfPointSizepoit size dimension (coordinate + weight). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; explicit UnBinData(unsigned int maxpoints = 0, unsigned int dim = 1, bool isWeighted = false). constructor from dimension of point and max number of points (to pre-allocate vector). explicit UnBinData(const ROOT::Fit::DataRange& range, unsigned int maxpoints = 0, unsigned int dim = 1, bool isWeighted = false). constructor from range and default option. UnBinData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range, unsigned int maxpoints = 0, unsigned int dim = 1, bool isWeighted = false). constructor from options and range. UnBinData(unsigned int n, const double* dataX). constructor for 1D external data (data are not copied inside). UnBinData(unsigned int n, const double* dataX, const double* dataY, bool isWeighted = false). constructor for 2D external data (data are not copied inside); or 1D data with a weight (if isWeighted = true). UnBinData(unsigned int n, const double* dataX, const double* dataY, const double* dat",MatchSource.WIKI,root/html532/ROOT__Fit__UnBinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__UnBinData.html
https://root.cern/root/html532/ROOT__Fit__UnBinData.html:6851,Modifiability,extend,extend,6851," dataX, const double* dataY, const ROOT::Fit::DataRange& range, bool isWeighted = false). constructor for 2D data and a range (data are copied inside according to the given range); or 1 1D data set + weight. If is weighted dataY is the pointer to the list of the weights. UnBinData(unsigned int maxpoints, const double* dataX, const double* dataY, const double* dataZ, const ROOT::Fit::DataRange& range, bool isWeighted = false). constructor for 3D data and a range (data are copied inside according to the given range); or a 2D data set + weights. If is weighted dataZ is the pointer to the list of the weights. UnBinData & operator=(const ROOT::Fit::UnBinData& ); assignment operator (private). { return *this; }. virtual ~UnBinData(). destructor, delete pointer to internal data or external data wrapper. void Initialize(unsigned int maxpoints, unsigned int dim = 1, bool isWeighted = false). preallocate a data set given size and dimension of the coordinates; if a vector already exists with correct dimension (point size) extend the existing one; to a total size of maxpoints (equivalent to a Resize). void Add(double x). add one dim coordinate data (unweighted). void Add(double x, double y). add 2-dim coordinate data; can also be used to add 1-dim data with a weight. void Add(double x, double y, double z). add 3-dim coordinate data; can also be used to add 2-dim data with a weight. void Add(const double* x). add multi-dim coordinate data. void Add(const double* x, double w). add multi-dim coordinate data + weight. const double * Coords(unsigned int ipoint) const. return pointer to coordinate data. bool IsWeighted() const. double Weight(unsigned int ipoint) const. void Resize(unsigned int npoints). resize the vector to the given npoints. unsigned int NPoints() const. return number of contained points. { return fNPoints; }. unsigned int Size() const. return number of contained points. { return fNPoints; }. unsigned int NDim() const. return coordinate data dimension. { return fDim;",MatchSource.WIKI,root/html532/ROOT__Fit__UnBinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Fit__UnBinData.html
https://root.cern/root/html532/ROOT__Math.html:32046,Deployability,release,releases,32046,"s; Function documentation; double beta_quantile(double x, double a, double b); @defgroup QuantFunc Quantile Functions; * @ingroup StatFunc; *; * Inverse functions of the cumulative distribution functions; * and the inverse of the complement of the cumulative distribution functions; * for various distributions.; * The functions with the extension <em>_quantile</em> calculate the; * inverse of the <em>_cdf</em> function, the; * lower tail integral of the probability density function; * \f$D^{-1}(z)\f$ where; *; * \f[ D(x) = \int_{-\infty}^{x} p(x') dx' \f]; *; * while those with the <em>_quantile_c</em> extension calculate the; * inverse of the <em>_cdf_c</em> functions, the upper tail integral of the probability; * density function \f$D^{-1}(z) \f$ where; *; * \f[ D(x) = \int_{x}^{+\infty} p(x') dx' \f]; *; * These functions are defined in the header file <em>Math/ProbFunc.h<em> or in the global one; * including all statistical dunctions <em>Math/DistFunc.h<em>; *; *; * <strong>NOTE:</strong> In the old releases (< 5.14) the <em>_quantile</em> functions were called; * <em>_quant_inv</em> and the <em>_quantile_c</em> functions were called; * <em>_prob_inv</em>.; * These names are currently kept for backward compatibility, but; * their usage is deprecated.; *. @name Quantile Functions from MathCore; * The implementation is provided in MathCore and for the majority of the function comes from; * <A HREF=""http://www.netlib.org/cephes"">Cephes</A>. @{. Inverse (\f$D^{-1}(z)\f$) of the cumulative distribution; function of the upper tail of the beta distribution; (#beta_cdf_c).; It is implemented using the function incbi from <A HREF=""http://www.netlib.org/cephes"">Cephes</A>. @ingroup QuantFunc. double beta_quantile_c(double x, double a, double b). Inverse (\f$D^{-1}(z)\f$) of the cumulative distribution; function of the lower tail of the beta distribution; (#beta_cdf).; It is implemented using; the function incbi from <A HREF=""http://www.netlib.org/cephes"">Cephes</A>. @ingrou",MatchSource.WIKI,root/html532/ROOT__Math.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math.html
https://root.cern/root/html532/ROOT__Math.html:39587,Testability,log,lognormal,39587,"the cumulative distribution; function of the upper tail of the normal (Gaussian) distribution; (#gaussian_cdf_c). For detailed description see; <A HREF=""http://mathworld.wolfram.com/NormalDistribution.html"">; Mathworld</A>. It can also be evaluated using #normal_quantile_c which will; call the same implementation. @ingroup QuantFunc. double gaussian_quantile(double z, double sigma). Inverse (\f$D^{-1}(z)\f$) of the cumulative distribution; function of the lower tail of the normal (Gaussian) distribution; (#gaussian_cdf). For detailed description see; <A HREF=""http://mathworld.wolfram.com/NormalDistribution.html"">; Mathworld</A>. It can also be evaluated using #normal_quantile which will; call the same implementation.; It is implemented using the function ROOT::Math::Cephes::ndtri taken from; <A HREF=""http://www.netlib.org/cephes"">Cephes</A>. @ingroup QuantFunc. double lognormal_quantile_c(double x, double m, double s). Inverse (\f$D^{-1}(z)\f$) of the cumulative distribution; function of the upper tail of the lognormal distribution; (#lognormal_cdf_c). For detailed description see; <A HREF=""http://mathworld.wolfram.com/LogNormalDistribution.html"">; Mathworld</A>. The implementation used is that of; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_19.html#SEC302"">GSL</A>. @ingroup QuantFunc. double lognormal_quantile(double x, double m, double s). Inverse (\f$D^{-1}(z)\f$) of the cumulative distribution; function of the lower tail of the lognormal distribution; (#lognormal_cdf). For detailed description see; <A HREF=""http://mathworld.wolfram.com/LogNormalDistribution.html"">; Mathworld</A>. The implementation used is that of; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_19.html#SEC302"">GSL</A>. @ingroup QuantFunc. double normal_quantile_c(double z, double sigma). Inverse (\f$D^{-1}(z)\f$) of the cumulative distribution; function of the upper tail of the normal (Gaussian) distribution; (#normal_cdf_c). For detailed description see; <A HREF=""http://mat",MatchSource.WIKI,root/html532/ROOT__Math.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math.html
https://root.cern/root/html532/ROOT__Math.html:39699,Testability,Log,LogNormalDistribution,39699," HREF=""http://mathworld.wolfram.com/NormalDistribution.html"">; Mathworld</A>. It can also be evaluated using #normal_quantile_c which will; call the same implementation. @ingroup QuantFunc. double gaussian_quantile(double z, double sigma). Inverse (\f$D^{-1}(z)\f$) of the cumulative distribution; function of the lower tail of the normal (Gaussian) distribution; (#gaussian_cdf). For detailed description see; <A HREF=""http://mathworld.wolfram.com/NormalDistribution.html"">; Mathworld</A>. It can also be evaluated using #normal_quantile which will; call the same implementation.; It is implemented using the function ROOT::Math::Cephes::ndtri taken from; <A HREF=""http://www.netlib.org/cephes"">Cephes</A>. @ingroup QuantFunc. double lognormal_quantile_c(double x, double m, double s). Inverse (\f$D^{-1}(z)\f$) of the cumulative distribution; function of the upper tail of the lognormal distribution; (#lognormal_cdf_c). For detailed description see; <A HREF=""http://mathworld.wolfram.com/LogNormalDistribution.html"">; Mathworld</A>. The implementation used is that of; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_19.html#SEC302"">GSL</A>. @ingroup QuantFunc. double lognormal_quantile(double x, double m, double s). Inverse (\f$D^{-1}(z)\f$) of the cumulative distribution; function of the lower tail of the lognormal distribution; (#lognormal_cdf). For detailed description see; <A HREF=""http://mathworld.wolfram.com/LogNormalDistribution.html"">; Mathworld</A>. The implementation used is that of; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_19.html#SEC302"">GSL</A>. @ingroup QuantFunc. double normal_quantile_c(double z, double sigma). Inverse (\f$D^{-1}(z)\f$) of the cumulative distribution; function of the upper tail of the normal (Gaussian) distribution; (#normal_cdf_c). For detailed description see; <A HREF=""http://mathworld.wolfram.com/NormalDistribution.html"">; Mathworld</A>. It can also be evaluated using #gaussian_quantile_c which will; call the same impleme",MatchSource.WIKI,root/html532/ROOT__Math.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math.html
https://root.cern/root/html532/ROOT__Math.html:40030,Testability,log,lognormal,40030,"; function of the lower tail of the normal (Gaussian) distribution; (#gaussian_cdf). For detailed description see; <A HREF=""http://mathworld.wolfram.com/NormalDistribution.html"">; Mathworld</A>. It can also be evaluated using #normal_quantile which will; call the same implementation.; It is implemented using the function ROOT::Math::Cephes::ndtri taken from; <A HREF=""http://www.netlib.org/cephes"">Cephes</A>. @ingroup QuantFunc. double lognormal_quantile_c(double x, double m, double s). Inverse (\f$D^{-1}(z)\f$) of the cumulative distribution; function of the upper tail of the lognormal distribution; (#lognormal_cdf_c). For detailed description see; <A HREF=""http://mathworld.wolfram.com/LogNormalDistribution.html"">; Mathworld</A>. The implementation used is that of; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_19.html#SEC302"">GSL</A>. @ingroup QuantFunc. double lognormal_quantile(double x, double m, double s). Inverse (\f$D^{-1}(z)\f$) of the cumulative distribution; function of the lower tail of the lognormal distribution; (#lognormal_cdf). For detailed description see; <A HREF=""http://mathworld.wolfram.com/LogNormalDistribution.html"">; Mathworld</A>. The implementation used is that of; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_19.html#SEC302"">GSL</A>. @ingroup QuantFunc. double normal_quantile_c(double z, double sigma). Inverse (\f$D^{-1}(z)\f$) of the cumulative distribution; function of the upper tail of the normal (Gaussian) distribution; (#normal_cdf_c). For detailed description see; <A HREF=""http://mathworld.wolfram.com/NormalDistribution.html"">; Mathworld</A>. It can also be evaluated using #gaussian_quantile_c which will; call the same implementation.; It is implemented using the function ROOT::Math::Cephes::ndtri taken from; <A HREF=""http://www.netlib.org/cephes"">Cephes</A>. @ingroup QuantFunc. double normal_quantile(double z, double sigma). Inverse (\f$D^{-1}(z)\f$) of the cumulative distribution; function of the lower tail of the ",MatchSource.WIKI,root/html532/ROOT__Math.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math.html
https://root.cern/root/html532/ROOT__Math.html:40140,Testability,Log,LogNormalDistribution,40140,"ram.com/NormalDistribution.html"">; Mathworld</A>. It can also be evaluated using #normal_quantile which will; call the same implementation.; It is implemented using the function ROOT::Math::Cephes::ndtri taken from; <A HREF=""http://www.netlib.org/cephes"">Cephes</A>. @ingroup QuantFunc. double lognormal_quantile_c(double x, double m, double s). Inverse (\f$D^{-1}(z)\f$) of the cumulative distribution; function of the upper tail of the lognormal distribution; (#lognormal_cdf_c). For detailed description see; <A HREF=""http://mathworld.wolfram.com/LogNormalDistribution.html"">; Mathworld</A>. The implementation used is that of; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_19.html#SEC302"">GSL</A>. @ingroup QuantFunc. double lognormal_quantile(double x, double m, double s). Inverse (\f$D^{-1}(z)\f$) of the cumulative distribution; function of the lower tail of the lognormal distribution; (#lognormal_cdf). For detailed description see; <A HREF=""http://mathworld.wolfram.com/LogNormalDistribution.html"">; Mathworld</A>. The implementation used is that of; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_19.html#SEC302"">GSL</A>. @ingroup QuantFunc. double normal_quantile_c(double z, double sigma). Inverse (\f$D^{-1}(z)\f$) of the cumulative distribution; function of the upper tail of the normal (Gaussian) distribution; (#normal_cdf_c). For detailed description see; <A HREF=""http://mathworld.wolfram.com/NormalDistribution.html"">; Mathworld</A>. It can also be evaluated using #gaussian_quantile_c which will; call the same implementation.; It is implemented using the function ROOT::Math::Cephes::ndtri taken from; <A HREF=""http://www.netlib.org/cephes"">Cephes</A>. @ingroup QuantFunc. double normal_quantile(double z, double sigma). Inverse (\f$D^{-1}(z)\f$) of the cumulative distribution; function of the lower tail of the normal (Gaussian) distribution; (#normal_cdf). For detailed description see; <A HREF=""http://mathworld.wolfram.com/NormalDistribution.html"">; Mat",MatchSource.WIKI,root/html532/ROOT__Math.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:2392,Availability,toler,tolerance,2392,"th::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); virtual voidSetRelTolerance(double relTol); voidSetSize(unsigned int size); virtual intStatus() const; virtual ROOT::Math::IntegrationMultiDim::TypeROOT::Math::VirtualIntegratorMultiDim::Type() const. protected:. doubleDoIntegral(const double* xmin, const double* xmax, bool absVal = false). Data Members; private:. doublefAbsTolabsolute tolerance; unsigned intfDimdimentionality of integrand; doublefErrorintegration error ; const ROOT::Math::IMultiGenFunction*fFunpointer to integrand function ; unsigned intfMaxPtsmaximum number of function evaluation requested ; unsigned intfMinPtsminimum number of function evaluation requested ; intfNEvalnumber of function evaluation; doublefRelErrorRelative error; doublefRelTolrelative tolerance; doublefResultlast integration result ; unsigned intfSizemax size of working array (explode with dimension); intfStatusstatus of algorithm (error if not zero). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; AdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0). construct given optionally tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array.; The size of working array represents the number of sub-division used for calculating the integral.; Higher the dimension, larger sizes are required for getting the same accuracy.; The size must be larger than >= (2N + 3) * (1 + MAXPTS/(2**N + 2N(N + 1) + 1))/2). For smaller value passed, the; minimum allowed will be used. AdaptiveIntegratorMultiDi",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:2472,Availability,error,error,2472,"th::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); virtual voidSetRelTolerance(double relTol); voidSetSize(unsigned int size); virtual intStatus() const; virtual ROOT::Math::IntegrationMultiDim::TypeROOT::Math::VirtualIntegratorMultiDim::Type() const. protected:. doubleDoIntegral(const double* xmin, const double* xmax, bool absVal = false). Data Members; private:. doublefAbsTolabsolute tolerance; unsigned intfDimdimentionality of integrand; doublefErrorintegration error ; const ROOT::Math::IMultiGenFunction*fFunpointer to integrand function ; unsigned intfMaxPtsmaximum number of function evaluation requested ; unsigned intfMinPtsminimum number of function evaluation requested ; intfNEvalnumber of function evaluation; doublefRelErrorRelative error; doublefRelTolrelative tolerance; doublefResultlast integration result ; unsigned intfSizemax size of working array (explode with dimension); intfStatusstatus of algorithm (error if not zero). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; AdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0). construct given optionally tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array.; The size of working array represents the number of sub-division used for calculating the integral.; Higher the dimension, larger sizes are required for getting the same accuracy.; The size must be larger than >= (2N + 3) * (1 + MAXPTS/(2**N + 2N(N + 1) + 1))/2). For smaller value passed, the; minimum allowed will be used. AdaptiveIntegratorMultiDi",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:2754,Availability,error,error,2754,"th::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); virtual voidSetRelTolerance(double relTol); voidSetSize(unsigned int size); virtual intStatus() const; virtual ROOT::Math::IntegrationMultiDim::TypeROOT::Math::VirtualIntegratorMultiDim::Type() const. protected:. doubleDoIntegral(const double* xmin, const double* xmax, bool absVal = false). Data Members; private:. doublefAbsTolabsolute tolerance; unsigned intfDimdimentionality of integrand; doublefErrorintegration error ; const ROOT::Math::IMultiGenFunction*fFunpointer to integrand function ; unsigned intfMaxPtsmaximum number of function evaluation requested ; unsigned intfMinPtsminimum number of function evaluation requested ; intfNEvalnumber of function evaluation; doublefRelErrorRelative error; doublefRelTolrelative tolerance; doublefResultlast integration result ; unsigned intfSizemax size of working array (explode with dimension); intfStatusstatus of algorithm (error if not zero). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; AdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0). construct given optionally tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array.; The size of working array represents the number of sub-division used for calculating the integral.; Higher the dimension, larger sizes are required for getting the same accuracy.; The size must be larger than >= (2N + 3) * (1 + MAXPTS/(2**N + 2N(N + 1) + 1))/2). For smaller value passed, the; minimum allowed will be used. AdaptiveIntegratorMultiDi",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:2783,Availability,toler,tolerance,2783,"th::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); virtual voidSetRelTolerance(double relTol); voidSetSize(unsigned int size); virtual intStatus() const; virtual ROOT::Math::IntegrationMultiDim::TypeROOT::Math::VirtualIntegratorMultiDim::Type() const. protected:. doubleDoIntegral(const double* xmin, const double* xmax, bool absVal = false). Data Members; private:. doublefAbsTolabsolute tolerance; unsigned intfDimdimentionality of integrand; doublefErrorintegration error ; const ROOT::Math::IMultiGenFunction*fFunpointer to integrand function ; unsigned intfMaxPtsmaximum number of function evaluation requested ; unsigned intfMinPtsminimum number of function evaluation requested ; intfNEvalnumber of function evaluation; doublefRelErrorRelative error; doublefRelTolrelative tolerance; doublefResultlast integration result ; unsigned intfSizemax size of working array (explode with dimension); intfStatusstatus of algorithm (error if not zero). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; AdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0). construct given optionally tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array.; The size of working array represents the number of sub-division used for calculating the integral.; Higher the dimension, larger sizes are required for getting the same accuracy.; The size must be larger than >= (2N + 3) * (1 + MAXPTS/(2**N + 2N(N + 1) + 1))/2). For smaller value passed, the; minimum allowed will be used. AdaptiveIntegratorMultiDi",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:2933,Availability,error,error,2933,"th::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); virtual voidSetRelTolerance(double relTol); voidSetSize(unsigned int size); virtual intStatus() const; virtual ROOT::Math::IntegrationMultiDim::TypeROOT::Math::VirtualIntegratorMultiDim::Type() const. protected:. doubleDoIntegral(const double* xmin, const double* xmax, bool absVal = false). Data Members; private:. doublefAbsTolabsolute tolerance; unsigned intfDimdimentionality of integrand; doublefErrorintegration error ; const ROOT::Math::IMultiGenFunction*fFunpointer to integrand function ; unsigned intfMaxPtsmaximum number of function evaluation requested ; unsigned intfMinPtsminimum number of function evaluation requested ; intfNEvalnumber of function evaluation; doublefRelErrorRelative error; doublefRelTolrelative tolerance; doublefResultlast integration result ; unsigned intfSizemax size of working array (explode with dimension); intfStatusstatus of algorithm (error if not zero). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; AdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0). construct given optionally tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array.; The size of working array represents the number of sub-division used for calculating the integral.; Higher the dimension, larger sizes are required for getting the same accuracy.; The size must be larger than >= (2N + 3) * (1 + MAXPTS/(2**N + 2N(N + 1) + 1))/2). For smaller value passed, the; minimum allowed will be used. AdaptiveIntegratorMultiDi",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:3197,Availability,toler,tolerance,3197,"::Type() const. protected:. doubleDoIntegral(const double* xmin, const double* xmax, bool absVal = false). Data Members; private:. doublefAbsTolabsolute tolerance; unsigned intfDimdimentionality of integrand; doublefErrorintegration error ; const ROOT::Math::IMultiGenFunction*fFunpointer to integrand function ; unsigned intfMaxPtsmaximum number of function evaluation requested ; unsigned intfMinPtsminimum number of function evaluation requested ; intfNEvalnumber of function evaluation; doublefRelErrorRelative error; doublefRelTolrelative tolerance; doublefResultlast integration result ; unsigned intfSizemax size of working array (explode with dimension); intfStatusstatus of algorithm (error if not zero). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; AdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0). construct given optionally tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array.; The size of working array represents the number of sub-division used for calculating the integral.; Higher the dimension, larger sizes are required for getting the same accuracy.; The size must be larger than >= (2N + 3) * (1 + MAXPTS/(2**N + 2N(N + 1) + 1))/2). For smaller value passed, the; minimum allowed will be used. AdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0). Construct with a reference to the integrand function and given optionally; tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array. virtual ~AdaptiveIntegratorMultiDim(). destructor (no operations). {}. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. return DoIntegral(const double* xmin",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:3878,Availability,toler,tolerance,3878,"ion); intfStatusstatus of algorithm (error if not zero). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; AdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0). construct given optionally tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array.; The size of working array represents the number of sub-division used for calculating the integral.; Higher the dimension, larger sizes are required for getting the same accuracy.; The size must be larger than >= (2N + 3) * (1 + MAXPTS/(2**N + 2N(N + 1) + 1))/2). For smaller value passed, the; minimum allowed will be used. AdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0). Construct with a reference to the integrand function and given optionally; tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array. virtual ~AdaptiveIntegratorMultiDim(). destructor (no operations). {}. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. return DoIntegral(const double* xmin, const double* xmax, bool absVal = false). double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. void SetFunction(const ROOT::Math::IMultiGenFunction& f); set the integration function (must implement multi-dim function interface: IBaseFunctionMultiDim). double Result() const; return result of integration. { return fResult; }. double Error() const; return integration error. { return fError; }. double RelError() const; return relative error. { return fRelError; }. int Status() const; return status of integration. { return fStatus; }. int NEval() const; return num",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:4665,Availability,Error,Error,4665,"IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0). Construct with a reference to the integrand function and given optionally; tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array. virtual ~AdaptiveIntegratorMultiDim(). destructor (no operations). {}. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. return DoIntegral(const double* xmin, const double* xmax, bool absVal = false). double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. void SetFunction(const ROOT::Math::IMultiGenFunction& f); set the integration function (must implement multi-dim function interface: IBaseFunctionMultiDim). double Result() const; return result of integration. { return fResult; }. double Error() const; return integration error. { return fError; }. double RelError() const; return relative error. { return fRelError; }. int Status() const; return status of integration. { return fStatus; }. int NEval() const; return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTol); set relative tolerance. void SetAbsTolerance(double absTol); set absolute tolerance. void SetSize(unsigned int size); set workspace size. { fSize = size; }. void SetMinPts(unsigned int n); set min points. { fMinPts = n; }. void SetMaxPts(unsigned int n); set max points. { fMaxPts = n; }. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options.  Author: M. Slawinska 08/2007  Copyright (c) 2007 , LCG ROOT MathLib Team *;  Last changed: root/mathcore:$Id: AdaptiveIntegratorMultiDim.h 36768 2010-11-19 10:34:53Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding ",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:4699,Availability,error,error,4699,"IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0). Construct with a reference to the integrand function and given optionally; tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array. virtual ~AdaptiveIntegratorMultiDim(). destructor (no operations). {}. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. return DoIntegral(const double* xmin, const double* xmax, bool absVal = false). double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. void SetFunction(const ROOT::Math::IMultiGenFunction& f); set the integration function (must implement multi-dim function interface: IBaseFunctionMultiDim). double Result() const; return result of integration. { return fResult; }. double Error() const; return integration error. { return fError; }. double RelError() const; return relative error. { return fRelError; }. int Status() const; return status of integration. { return fStatus; }. int NEval() const; return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTol); set relative tolerance. void SetAbsTolerance(double absTol); set absolute tolerance. void SetSize(unsigned int size); set workspace size. { fSize = size; }. void SetMinPts(unsigned int n); set min points. { fMinPts = n; }. void SetMaxPts(unsigned int n); set max points. { fMaxPts = n; }. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options.  Author: M. Slawinska 08/2007  Copyright (c) 2007 , LCG ROOT MathLib Team *;  Last changed: root/mathcore:$Id: AdaptiveIntegratorMultiDim.h 36768 2010-11-19 10:34:53Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding ",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:4767,Availability,error,error,4767,"nsigned int maxcall = 100000, unsigned int size = 0). Construct with a reference to the integrand function and given optionally; tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array. virtual ~AdaptiveIntegratorMultiDim(). destructor (no operations). {}. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. return DoIntegral(const double* xmin, const double* xmax, bool absVal = false). double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. void SetFunction(const ROOT::Math::IMultiGenFunction& f); set the integration function (must implement multi-dim function interface: IBaseFunctionMultiDim). double Result() const; return result of integration. { return fResult; }. double Error() const; return integration error. { return fError; }. double RelError() const; return relative error. { return fRelError; }. int Status() const; return status of integration. { return fStatus; }. int NEval() const; return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTol); set relative tolerance. void SetAbsTolerance(double absTol); set absolute tolerance. void SetSize(unsigned int size); set workspace size. { fSize = size; }. void SetMinPts(unsigned int n); set min points. { fMinPts = n; }. void SetMaxPts(unsigned int n); set max points. { fMaxPts = n; }. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options.  Author: M. Slawinska 08/2007  Copyright (c) 2007 , LCG ROOT MathLib Team *;  Last changed: root/mathcore:$Id: AdaptiveIntegratorMultiDim.h 36768 2010-11-19 10:34:53Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT supp",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:5024,Availability,toler,tolerance,5024,"ed int maxcall = 100000, unsigned int size = 0). Construct with a reference to the integrand function and given optionally; tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array. virtual ~AdaptiveIntegratorMultiDim(). destructor (no operations). {}. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. return DoIntegral(const double* xmin, const double* xmax, bool absVal = false). double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. void SetFunction(const ROOT::Math::IMultiGenFunction& f); set the integration function (must implement multi-dim function interface: IBaseFunctionMultiDim). double Result() const; return result of integration. { return fResult; }. double Error() const; return integration error. { return fError; }. double RelError() const; return relative error. { return fRelError; }. int Status() const; return status of integration. { return fStatus; }. int NEval() const; return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTol); set relative tolerance. void SetAbsTolerance(double absTol); set absolute tolerance. void SetSize(unsigned int size); set workspace size. { fSize = size; }. void SetMinPts(unsigned int n); set min points. { fMinPts = n; }. void SetMaxPts(unsigned int n); set max points. { fMaxPts = n; }. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options.  Author: M. Slawinska 08/2007  Copyright (c) 2007 , LCG ROOT MathLib Team *;  Last changed: root/mathcore:$Id: AdaptiveIntegratorMultiDim.h 36768 2010-11-19 10:34:53Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:5085,Availability,toler,tolerance,5085,"ed int maxcall = 100000, unsigned int size = 0). Construct with a reference to the integrand function and given optionally; tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array. virtual ~AdaptiveIntegratorMultiDim(). destructor (no operations). {}. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. return DoIntegral(const double* xmin, const double* xmax, bool absVal = false). double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. void SetFunction(const ROOT::Math::IMultiGenFunction& f); set the integration function (must implement multi-dim function interface: IBaseFunctionMultiDim). double Result() const; return result of integration. { return fResult; }. double Error() const; return integration error. { return fError; }. double RelError() const; return relative error. { return fRelError; }. int Status() const; return status of integration. { return fStatus; }. int NEval() const; return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTol); set relative tolerance. void SetAbsTolerance(double absTol); set absolute tolerance. void SetSize(unsigned int size); set workspace size. { fSize = size; }. void SetMinPts(unsigned int n); set min points. { fMinPts = n; }. void SetMaxPts(unsigned int n); set max points. { fMaxPts = n; }. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options.  Author: M. Slawinska 08/2007  Copyright (c) 2007 , LCG ROOT MathLib Team *;  Last changed: root/mathcore:$Id: AdaptiveIntegratorMultiDim.h 36768 2010-11-19 10:34:53Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:415,Deployability,integrat,integration,415,". ROOT::Math::AdaptiveIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::AdaptiveIntegratorMultiDim. class ROOT::Math::AdaptiveIntegratorMultiDim: public ROOT::Math::VirtualIntegratorMultiDim. class for adaptive quadrature integration in multi-dimensions; Algorithm from A.C. Genz, A.A. Malik, An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. Converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0); virtual doubleError() const; virtual doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); virtual intNEval() const; ROOT::Math::VirtualIntegratorMultiDim&ROOT::Math::VirtualIntegratorMultiDim::operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOption",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:522,Deployability,integrat,integration,522,". ROOT::Math::AdaptiveIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::AdaptiveIntegratorMultiDim. class ROOT::Math::AdaptiveIntegratorMultiDim: public ROOT::Math::VirtualIntegratorMultiDim. class for adaptive quadrature integration in multi-dimensions; Algorithm from A.C. Genz, A.A. Malik, An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. Converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0); virtual doubleError() const; virtual doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); virtual intNEval() const; ROOT::Math::VirtualIntegratorMultiDim&ROOT::Math::VirtualIntegratorMultiDim::operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOption",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:774,Deployability,Integrat,Integration,774,". ROOT::Math::AdaptiveIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::AdaptiveIntegratorMultiDim. class ROOT::Math::AdaptiveIntegratorMultiDim: public ROOT::Math::VirtualIntegratorMultiDim. class for adaptive quadrature integration in multi-dimensions; Algorithm from A.C. Genz, A.A. Malik, An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. Converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0); virtual doubleError() const; virtual doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); virtual intNEval() const; ROOT::Math::VirtualIntegratorMultiDim&ROOT::Math::VirtualIntegratorMultiDim::operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOption",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:1713,Deployability,Integrat,IntegratorMultiDimOptionsOptions,1713,"rsion. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0); virtual doubleError() const; virtual doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); virtual intNEval() const; ROOT::Math::VirtualIntegratorMultiDim&ROOT::Math::VirtualIntegratorMultiDim::operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); virtual voidSetRelTolerance(double relTol); voidSetSize(unsigned int size); virtual intStatus() const; virtual ROOT::Math::IntegrationMultiDim::TypeROOT::Math::VirtualIntegratorMultiDim::Type() const. protected:. doubleDoIntegral(const double* xmin, const double* xmax, bool absVal = false). Data Members; private:. doublefAbsTolabsolute tolerance; unsigned intfDimdimentionality of integrand; doublefErrorintegration error ; const ROOT::Math::IMultiGenFunction*fFunpointer to integrand function ; unsigned intfMaxPtsmaximum number of function evaluation requested ; unsigned intfMinPtsminimum number of function evaluation requested ; intfNEvalnumber of function evaluation; doublefRelErrorRelative erro",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:2021,Deployability,Integrat,IntegratorMultiDimOptions,2021,"rsion. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0); virtual doubleError() const; virtual doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); virtual intNEval() const; ROOT::Math::VirtualIntegratorMultiDim&ROOT::Math::VirtualIntegratorMultiDim::operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); virtual voidSetRelTolerance(double relTol); voidSetSize(unsigned int size); virtual intStatus() const; virtual ROOT::Math::IntegrationMultiDim::TypeROOT::Math::VirtualIntegratorMultiDim::Type() const. protected:. doubleDoIntegral(const double* xmin, const double* xmax, bool absVal = false). Data Members; private:. doublefAbsTolabsolute tolerance; unsigned intfDimdimentionality of integrand; doublefErrorintegration error ; const ROOT::Math::IMultiGenFunction*fFunpointer to integrand function ; unsigned intfMaxPtsmaximum number of function evaluation requested ; unsigned intfMinPtsminimum number of function evaluation requested ; intfNEvalnumber of function evaluation; doublefRelErrorRelative erro",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:2177,Deployability,Integrat,IntegrationMultiDim,2177,"rsion. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0); virtual doubleError() const; virtual doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); virtual intNEval() const; ROOT::Math::VirtualIntegratorMultiDim&ROOT::Math::VirtualIntegratorMultiDim::operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); virtual voidSetRelTolerance(double relTol); voidSetSize(unsigned int size); virtual intStatus() const; virtual ROOT::Math::IntegrationMultiDim::TypeROOT::Math::VirtualIntegratorMultiDim::Type() const. protected:. doubleDoIntegral(const double* xmin, const double* xmax, bool absVal = false). Data Members; private:. doublefAbsTolabsolute tolerance; unsigned intfDimdimentionality of integrand; doublefErrorintegration error ; const ROOT::Math::IMultiGenFunction*fFunpointer to integrand function ; unsigned intfMaxPtsmaximum number of function evaluation requested ; unsigned intfMinPtsminimum number of function evaluation requested ; intfNEvalnumber of function evaluation; doublefRelErrorRelative erro",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:2812,Deployability,integrat,integration,2812,"th::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); virtual voidSetRelTolerance(double relTol); voidSetSize(unsigned int size); virtual intStatus() const; virtual ROOT::Math::IntegrationMultiDim::TypeROOT::Math::VirtualIntegratorMultiDim::Type() const. protected:. doubleDoIntegral(const double* xmin, const double* xmax, bool absVal = false). Data Members; private:. doublefAbsTolabsolute tolerance; unsigned intfDimdimentionality of integrand; doublefErrorintegration error ; const ROOT::Math::IMultiGenFunction*fFunpointer to integrand function ; unsigned intfMaxPtsmaximum number of function evaluation requested ; unsigned intfMinPtsminimum number of function evaluation requested ; intfNEvalnumber of function evaluation; doublefRelErrorRelative error; doublefRelTolrelative tolerance; doublefResultlast integration result ; unsigned intfSizemax size of working array (explode with dimension); intfStatusstatus of algorithm (error if not zero). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; AdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0). construct given optionally tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array.; The size of working array represents the number of sub-division used for calculating the integral.; Higher the dimension, larger sizes are required for getting the same accuracy.; The size must be larger than >= (2N + 3) * (1 + MAXPTS/(2**N + 2N(N + 1) + 1))/2). For smaller value passed, the; minimum allowed will be used. AdaptiveIntegratorMultiDi",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:4493,Deployability,integrat,integration,4493,"t be larger than >= (2N + 3) * (1 + MAXPTS/(2**N + 2N(N + 1) + 1))/2). For smaller value passed, the; minimum allowed will be used. AdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0). Construct with a reference to the integrand function and given optionally; tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array. virtual ~AdaptiveIntegratorMultiDim(). destructor (no operations). {}. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. return DoIntegral(const double* xmin, const double* xmax, bool absVal = false). double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. void SetFunction(const ROOT::Math::IMultiGenFunction& f); set the integration function (must implement multi-dim function interface: IBaseFunctionMultiDim). double Result() const; return result of integration. { return fResult; }. double Error() const; return integration error. { return fError; }. double RelError() const; return relative error. { return fRelError; }. int Status() const; return status of integration. { return fStatus; }. int NEval() const; return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTol); set relative tolerance. void SetAbsTolerance(double absTol); set absolute tolerance. void SetSize(unsigned int size); set workspace size. { fSize = size; }. void SetMinPts(unsigned int n); set min points. { fMinPts = n; }. void SetMaxPts(unsigned int n); set max points. { fMaxPts = n; }. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options.  Author: M. Slawinska 08/2007  Copyright (c) 2007 , LCG ROOT MathLib Team *;  Last changed: root/mathcore:$Id: Adaptiv",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:4624,Deployability,integrat,integration,4624,"imum allowed will be used. AdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0). Construct with a reference to the integrand function and given optionally; tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array. virtual ~AdaptiveIntegratorMultiDim(). destructor (no operations). {}. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. return DoIntegral(const double* xmin, const double* xmax, bool absVal = false). double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. void SetFunction(const ROOT::Math::IMultiGenFunction& f); set the integration function (must implement multi-dim function interface: IBaseFunctionMultiDim). double Result() const; return result of integration. { return fResult; }. double Error() const; return integration error. { return fError; }. double RelError() const; return relative error. { return fRelError; }. int Status() const; return status of integration. { return fStatus; }. int NEval() const; return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTol); set relative tolerance. void SetAbsTolerance(double absTol); set absolute tolerance. void SetSize(unsigned int size); set workspace size. { fSize = size; }. void SetMinPts(unsigned int n); set min points. { fMinPts = n; }. void SetMaxPts(unsigned int n); set max points. { fMaxPts = n; }. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options.  Author: M. Slawinska 08/2007  Copyright (c) 2007 , LCG ROOT MathLib Team *;  Last changed: root/mathcore:$Id: AdaptiveIntegratorMultiDim.h 36768 2010-11-19 10:34:53Z moneta $  Last generated: 2011-11-03 20:04; This page h",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:4687,Deployability,integrat,integration,4687,"IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0). Construct with a reference to the integrand function and given optionally; tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array. virtual ~AdaptiveIntegratorMultiDim(). destructor (no operations). {}. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. return DoIntegral(const double* xmin, const double* xmax, bool absVal = false). double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. void SetFunction(const ROOT::Math::IMultiGenFunction& f); set the integration function (must implement multi-dim function interface: IBaseFunctionMultiDim). double Result() const; return result of integration. { return fResult; }. double Error() const; return integration error. { return fError; }. double RelError() const; return relative error. { return fRelError; }. int Status() const; return status of integration. { return fStatus; }. int NEval() const; return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTol); set relative tolerance. void SetAbsTolerance(double absTol); set absolute tolerance. void SetSize(unsigned int size); set workspace size. { fSize = size; }. void SetMinPts(unsigned int n); set min points. { fMinPts = n; }. void SetMaxPts(unsigned int n); set max points. { fMaxPts = n; }. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options.  Author: M. Slawinska 08/2007  Copyright (c) 2007 , LCG ROOT MathLib Team *;  Last changed: root/mathcore:$Id: AdaptiveIntegratorMultiDim.h 36768 2010-11-19 10:34:53Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding ",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:4834,Deployability,integrat,integration,4834,"ed int maxcall = 100000, unsigned int size = 0). Construct with a reference to the integrand function and given optionally; tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array. virtual ~AdaptiveIntegratorMultiDim(). destructor (no operations). {}. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. return DoIntegral(const double* xmin, const double* xmax, bool absVal = false). double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. void SetFunction(const ROOT::Math::IMultiGenFunction& f); set the integration function (must implement multi-dim function interface: IBaseFunctionMultiDim). double Result() const; return result of integration. { return fResult; }. double Error() const; return integration error. { return fError; }. double RelError() const; return relative error. { return fRelError; }. int Status() const; return status of integration. { return fStatus; }. int NEval() const; return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTol); set relative tolerance. void SetAbsTolerance(double absTol); set absolute tolerance. void SetSize(unsigned int size); set workspace size. { fSize = size; }. void SetMinPts(unsigned int n); set min points. { fMinPts = n; }. void SetMaxPts(unsigned int n); set max points. { fMaxPts = n; }. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options.  Author: M. Slawinska 08/2007  Copyright (c) 2007 , LCG ROOT MathLib Team *;  Last changed: root/mathcore:$Id: AdaptiveIntegratorMultiDim.h 36768 2010-11-19 10:34:53Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:5334,Deployability,Integrat,IntegratorMultiDimOptions,5334,"ed int maxcall = 100000, unsigned int size = 0). Construct with a reference to the integrand function and given optionally; tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array. virtual ~AdaptiveIntegratorMultiDim(). destructor (no operations). {}. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. return DoIntegral(const double* xmin, const double* xmax, bool absVal = false). double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. void SetFunction(const ROOT::Math::IMultiGenFunction& f); set the integration function (must implement multi-dim function interface: IBaseFunctionMultiDim). double Result() const; return result of integration. { return fResult; }. double Error() const; return integration error. { return fError; }. double RelError() const; return relative error. { return fRelError; }. int Status() const; return status of integration. { return fStatus; }. int NEval() const; return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTol); set relative tolerance. void SetAbsTolerance(double absTol); set absolute tolerance. void SetSize(unsigned int size); set workspace size. { fSize = size; }. void SetMinPts(unsigned int n); set min points. { fMinPts = n; }. void SetMaxPts(unsigned int n); set max points. { fMaxPts = n; }. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options.  Author: M. Slawinska 08/2007  Copyright (c) 2007 , LCG ROOT MathLib Team *;  Last changed: root/mathcore:$Id: AdaptiveIntegratorMultiDim.h 36768 2010-11-19 10:34:53Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:14,Energy Efficiency,Adapt,AdaptiveIntegratorMultiDim,14,". ROOT::Math::AdaptiveIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::AdaptiveIntegratorMultiDim. class ROOT::Math::AdaptiveIntegratorMultiDim: public ROOT::Math::VirtualIntegratorMultiDim. class for adaptive quadrature integration in multi-dimensions; Algorithm from A.C. Genz, A.A. Malik, An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. Converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0); virtual doubleError() const; virtual doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); virtual intNEval() const; ROOT::Math::VirtualIntegratorMultiDim&ROOT::Math::VirtualIntegratorMultiDim::operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOption",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:265,Energy Efficiency,Adapt,AdaptiveIntegratorMultiDim,265,". ROOT::Math::AdaptiveIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::AdaptiveIntegratorMultiDim. class ROOT::Math::AdaptiveIntegratorMultiDim: public ROOT::Math::VirtualIntegratorMultiDim. class for adaptive quadrature integration in multi-dimensions; Algorithm from A.C. Genz, A.A. Malik, An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. Converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0); virtual doubleError() const; virtual doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); virtual intNEval() const; ROOT::Math::VirtualIntegratorMultiDim&ROOT::Math::VirtualIntegratorMultiDim::operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOption",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:311,Energy Efficiency,Adapt,AdaptiveIntegratorMultiDim,311,". ROOT::Math::AdaptiveIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::AdaptiveIntegratorMultiDim. class ROOT::Math::AdaptiveIntegratorMultiDim: public ROOT::Math::VirtualIntegratorMultiDim. class for adaptive quadrature integration in multi-dimensions; Algorithm from A.C. Genz, A.A. Malik, An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. Converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0); virtual doubleError() const; virtual doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); virtual intNEval() const; ROOT::Math::VirtualIntegratorMultiDim&ROOT::Math::VirtualIntegratorMultiDim::operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOption",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:395,Energy Efficiency,adapt,adaptive,395,". ROOT::Math::AdaptiveIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::AdaptiveIntegratorMultiDim. class ROOT::Math::AdaptiveIntegratorMultiDim: public ROOT::Math::VirtualIntegratorMultiDim. class for adaptive quadrature integration in multi-dimensions; Algorithm from A.C. Genz, A.A. Malik, An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. Converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0); virtual doubleError() const; virtual doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); virtual intNEval() const; ROOT::Math::VirtualIntegratorMultiDim&ROOT::Math::VirtualIntegratorMultiDim::operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOption",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:489,Energy Efficiency,adapt,adaptive,489,". ROOT::Math::AdaptiveIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::AdaptiveIntegratorMultiDim. class ROOT::Math::AdaptiveIntegratorMultiDim: public ROOT::Math::VirtualIntegratorMultiDim. class for adaptive quadrature integration in multi-dimensions; Algorithm from A.C. Genz, A.A. Malik, An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. Converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0); virtual doubleError() const; virtual doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); virtual intNEval() const; ROOT::Math::VirtualIntegratorMultiDim&ROOT::Math::VirtualIntegratorMultiDim::operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOption",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:628,Energy Efficiency,adapt,adapted,628,". ROOT::Math::AdaptiveIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::AdaptiveIntegratorMultiDim. class ROOT::Math::AdaptiveIntegratorMultiDim: public ROOT::Math::VirtualIntegratorMultiDim. class for adaptive quadrature integration in multi-dimensions; Algorithm from A.C. Genz, A.A. Malik, An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. Converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0); virtual doubleError() const; virtual doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); virtual intNEval() const; ROOT::Math::VirtualIntegratorMultiDim&ROOT::Math::VirtualIntegratorMultiDim::operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOption",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:832,Energy Efficiency,Adapt,AdaptiveIntegratorMultiDim,832,". ROOT::Math::AdaptiveIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::AdaptiveIntegratorMultiDim. class ROOT::Math::AdaptiveIntegratorMultiDim: public ROOT::Math::VirtualIntegratorMultiDim. class for adaptive quadrature integration in multi-dimensions; Algorithm from A.C. Genz, A.A. Malik, An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. Converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0); virtual doubleError() const; virtual doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); virtual intNEval() const; ROOT::Math::VirtualIntegratorMultiDim&ROOT::Math::VirtualIntegratorMultiDim::operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOption",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:874,Energy Efficiency,Adapt,AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim,874,". ROOT::Math::AdaptiveIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::AdaptiveIntegratorMultiDim. class ROOT::Math::AdaptiveIntegratorMultiDim: public ROOT::Math::VirtualIntegratorMultiDim. class for adaptive quadrature integration in multi-dimensions; Algorithm from A.C. Genz, A.A. Malik, An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. Converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0); virtual doubleError() const; virtual doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); virtual intNEval() const; ROOT::Math::VirtualIntegratorMultiDim&ROOT::Math::VirtualIntegratorMultiDim::operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOption",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:945,Energy Efficiency,Adapt,AdaptiveIntegratorMultiDim,945,". ROOT::Math::AdaptiveIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::AdaptiveIntegratorMultiDim. class ROOT::Math::AdaptiveIntegratorMultiDim: public ROOT::Math::VirtualIntegratorMultiDim. class for adaptive quadrature integration in multi-dimensions; Algorithm from A.C. Genz, A.A. Malik, An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. Converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0); virtual doubleError() const; virtual doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); virtual intNEval() const; ROOT::Math::VirtualIntegratorMultiDim&ROOT::Math::VirtualIntegratorMultiDim::operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOption",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:987,Energy Efficiency,Adapt,AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim,987,". ROOT::Math::AdaptiveIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::AdaptiveIntegratorMultiDim. class ROOT::Math::AdaptiveIntegratorMultiDim: public ROOT::Math::VirtualIntegratorMultiDim. class for adaptive quadrature integration in multi-dimensions; Algorithm from A.C. Genz, A.A. Malik, An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. Converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0); virtual doubleError() const; virtual doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); virtual intNEval() const; ROOT::Math::VirtualIntegratorMultiDim&ROOT::Math::VirtualIntegratorMultiDim::operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOption",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:1151,Energy Efficiency,Adapt,AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim,1151,"class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::AdaptiveIntegratorMultiDim. class ROOT::Math::AdaptiveIntegratorMultiDim: public ROOT::Math::VirtualIntegratorMultiDim. class for adaptive quadrature integration in multi-dimensions; Algorithm from A.C. Genz, A.A. Malik, An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. Converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0); virtual doubleError() const; virtual doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); virtual intNEval() const; ROOT::Math::VirtualIntegratorMultiDim&ROOT::Math::VirtualIntegratorMultiDim::operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); virtual voidSetRelTolerance(double relTol); voidSetSize(unsigned int size); virtual intStatus() const; vir",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:3044,Energy Efficiency,Adapt,AdaptiveIntegratorMultiDim,3044,"virtual voidSetRelTolerance(double relTol); voidSetSize(unsigned int size); virtual intStatus() const; virtual ROOT::Math::IntegrationMultiDim::TypeROOT::Math::VirtualIntegratorMultiDim::Type() const. protected:. doubleDoIntegral(const double* xmin, const double* xmax, bool absVal = false). Data Members; private:. doublefAbsTolabsolute tolerance; unsigned intfDimdimentionality of integrand; doublefErrorintegration error ; const ROOT::Math::IMultiGenFunction*fFunpointer to integrand function ; unsigned intfMaxPtsmaximum number of function evaluation requested ; unsigned intfMinPtsminimum number of function evaluation requested ; intfNEvalnumber of function evaluation; doublefRelErrorRelative error; doublefRelTolrelative tolerance; doublefResultlast integration result ; unsigned intfSizemax size of working array (explode with dimension); intfStatusstatus of algorithm (error if not zero). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; AdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0). construct given optionally tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array.; The size of working array represents the number of sub-division used for calculating the integral.; Higher the dimension, larger sizes are required for getting the same accuracy.; The size must be larger than >= (2N + 3) * (1 + MAXPTS/(2**N + 2N(N + 1) + 1))/2). For smaller value passed, the; minimum allowed will be used. AdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0). Construct with a reference to the integrand function and given optionally; tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array. virtual ~AdaptiveIntegratorMultiDim(). destructor (no operatio",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:3636,Energy Efficiency,Adapt,AdaptiveIntegratorMultiDim,3636,"requested ; intfNEvalnumber of function evaluation; doublefRelErrorRelative error; doublefRelTolrelative tolerance; doublefResultlast integration result ; unsigned intfSizemax size of working array (explode with dimension); intfStatusstatus of algorithm (error if not zero). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; AdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0). construct given optionally tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array.; The size of working array represents the number of sub-division used for calculating the integral.; Higher the dimension, larger sizes are required for getting the same accuracy.; The size must be larger than >= (2N + 3) * (1 + MAXPTS/(2**N + 2N(N + 1) + 1))/2). For smaller value passed, the; minimum allowed will be used. AdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0). Construct with a reference to the integrand function and given optionally; tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array. virtual ~AdaptiveIntegratorMultiDim(). destructor (no operations). {}. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. return DoIntegral(const double* xmin, const double* xmax, bool absVal = false). double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. void SetFunction(const ROOT::Math::IMultiGenFunction& f); set the integration function (must implement multi-dim function interface: IBaseFunctionMultiDim). double Result() const; return result of integration. { return fResult; }. double Error() const",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:4001,Energy Efficiency,Adapt,AdaptiveIntegratorMultiDim,4001,"ibraries. Function documentation; AdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0). construct given optionally tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array.; The size of working array represents the number of sub-division used for calculating the integral.; Higher the dimension, larger sizes are required for getting the same accuracy.; The size must be larger than >= (2N + 3) * (1 + MAXPTS/(2**N + 2N(N + 1) + 1))/2). For smaller value passed, the; minimum allowed will be used. AdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0). Construct with a reference to the integrand function and given optionally; tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array. virtual ~AdaptiveIntegratorMultiDim(). destructor (no operations). {}. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. return DoIntegral(const double* xmin, const double* xmax, bool absVal = false). double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. void SetFunction(const ROOT::Math::IMultiGenFunction& f); set the integration function (must implement multi-dim function interface: IBaseFunctionMultiDim). double Result() const; return result of integration. { return fResult; }. double Error() const; return integration error. { return fError; }. double RelError() const; return relative error. { return fRelError; }. int Status() const; return status of integration. { return fStatus; }. int NEval() const; return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTol); ",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:5498,Energy Efficiency,Adapt,AdaptiveIntegratorMultiDim,5498,"ed int maxcall = 100000, unsigned int size = 0). Construct with a reference to the integrand function and given optionally; tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array. virtual ~AdaptiveIntegratorMultiDim(). destructor (no operations). {}. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. return DoIntegral(const double* xmin, const double* xmax, bool absVal = false). double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. void SetFunction(const ROOT::Math::IMultiGenFunction& f); set the integration function (must implement multi-dim function interface: IBaseFunctionMultiDim). double Result() const; return result of integration. { return fResult; }. double Error() const; return integration error. { return fError; }. double RelError() const; return relative error. { return fRelError; }. int Status() const; return status of integration. { return fStatus; }. int NEval() const; return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTol); set relative tolerance. void SetAbsTolerance(double absTol); set absolute tolerance. void SetSize(unsigned int size); set workspace size. { fSize = size; }. void SetMinPts(unsigned int n); set min points. { fMinPts = n; }. void SetMaxPts(unsigned int n); set max points. { fMaxPts = n; }. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options.  Author: M. Slawinska 08/2007  Copyright (c) 2007 , LCG ROOT MathLib Team *;  Last changed: root/mathcore:$Id: AdaptiveIntegratorMultiDim.h 36768 2010-11-19 10:34:53Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:415,Integrability,integrat,integration,415,". ROOT::Math::AdaptiveIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::AdaptiveIntegratorMultiDim. class ROOT::Math::AdaptiveIntegratorMultiDim: public ROOT::Math::VirtualIntegratorMultiDim. class for adaptive quadrature integration in multi-dimensions; Algorithm from A.C. Genz, A.A. Malik, An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. Converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0); virtual doubleError() const; virtual doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); virtual intNEval() const; ROOT::Math::VirtualIntegratorMultiDim&ROOT::Math::VirtualIntegratorMultiDim::operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOption",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:522,Integrability,integrat,integration,522,". ROOT::Math::AdaptiveIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::AdaptiveIntegratorMultiDim. class ROOT::Math::AdaptiveIntegratorMultiDim: public ROOT::Math::VirtualIntegratorMultiDim. class for adaptive quadrature integration in multi-dimensions; Algorithm from A.C. Genz, A.A. Malik, An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. Converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0); virtual doubleError() const; virtual doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); virtual intNEval() const; ROOT::Math::VirtualIntegratorMultiDim&ROOT::Math::VirtualIntegratorMultiDim::operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOption",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:674,Integrability,rout,routine,674,". ROOT::Math::AdaptiveIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::AdaptiveIntegratorMultiDim. class ROOT::Math::AdaptiveIntegratorMultiDim: public ROOT::Math::VirtualIntegratorMultiDim. class for adaptive quadrature integration in multi-dimensions; Algorithm from A.C. Genz, A.A. Malik, An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. Converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0); virtual doubleError() const; virtual doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); virtual intNEval() const; ROOT::Math::VirtualIntegratorMultiDim&ROOT::Math::VirtualIntegratorMultiDim::operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOption",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:774,Integrability,Integrat,Integration,774,". ROOT::Math::AdaptiveIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::AdaptiveIntegratorMultiDim. class ROOT::Math::AdaptiveIntegratorMultiDim: public ROOT::Math::VirtualIntegratorMultiDim. class for adaptive quadrature integration in multi-dimensions; Algorithm from A.C. Genz, A.A. Malik, An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. Converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0); virtual doubleError() const; virtual doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); virtual intNEval() const; ROOT::Math::VirtualIntegratorMultiDim&ROOT::Math::VirtualIntegratorMultiDim::operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOption",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:1713,Integrability,Integrat,IntegratorMultiDimOptionsOptions,1713,"rsion. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0); virtual doubleError() const; virtual doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); virtual intNEval() const; ROOT::Math::VirtualIntegratorMultiDim&ROOT::Math::VirtualIntegratorMultiDim::operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); virtual voidSetRelTolerance(double relTol); voidSetSize(unsigned int size); virtual intStatus() const; virtual ROOT::Math::IntegrationMultiDim::TypeROOT::Math::VirtualIntegratorMultiDim::Type() const. protected:. doubleDoIntegral(const double* xmin, const double* xmax, bool absVal = false). Data Members; private:. doublefAbsTolabsolute tolerance; unsigned intfDimdimentionality of integrand; doublefErrorintegration error ; const ROOT::Math::IMultiGenFunction*fFunpointer to integrand function ; unsigned intfMaxPtsmaximum number of function evaluation requested ; unsigned intfMinPtsminimum number of function evaluation requested ; intfNEvalnumber of function evaluation; doublefRelErrorRelative erro",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:2021,Integrability,Integrat,IntegratorMultiDimOptions,2021,"rsion. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0); virtual doubleError() const; virtual doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); virtual intNEval() const; ROOT::Math::VirtualIntegratorMultiDim&ROOT::Math::VirtualIntegratorMultiDim::operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); virtual voidSetRelTolerance(double relTol); voidSetSize(unsigned int size); virtual intStatus() const; virtual ROOT::Math::IntegrationMultiDim::TypeROOT::Math::VirtualIntegratorMultiDim::Type() const. protected:. doubleDoIntegral(const double* xmin, const double* xmax, bool absVal = false). Data Members; private:. doublefAbsTolabsolute tolerance; unsigned intfDimdimentionality of integrand; doublefErrorintegration error ; const ROOT::Math::IMultiGenFunction*fFunpointer to integrand function ; unsigned intfMaxPtsmaximum number of function evaluation requested ; unsigned intfMinPtsminimum number of function evaluation requested ; intfNEvalnumber of function evaluation; doublefRelErrorRelative erro",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:2177,Integrability,Integrat,IntegrationMultiDim,2177,"rsion. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0); virtual doubleError() const; virtual doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); virtual intNEval() const; ROOT::Math::VirtualIntegratorMultiDim&ROOT::Math::VirtualIntegratorMultiDim::operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); virtual voidSetRelTolerance(double relTol); voidSetSize(unsigned int size); virtual intStatus() const; virtual ROOT::Math::IntegrationMultiDim::TypeROOT::Math::VirtualIntegratorMultiDim::Type() const. protected:. doubleDoIntegral(const double* xmin, const double* xmax, bool absVal = false). Data Members; private:. doublefAbsTolabsolute tolerance; unsigned intfDimdimentionality of integrand; doublefErrorintegration error ; const ROOT::Math::IMultiGenFunction*fFunpointer to integrand function ; unsigned intfMaxPtsmaximum number of function evaluation requested ; unsigned intfMinPtsminimum number of function evaluation requested ; intfNEvalnumber of function evaluation; doublefRelErrorRelative erro",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:2812,Integrability,integrat,integration,2812,"th::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); virtual voidSetRelTolerance(double relTol); voidSetSize(unsigned int size); virtual intStatus() const; virtual ROOT::Math::IntegrationMultiDim::TypeROOT::Math::VirtualIntegratorMultiDim::Type() const. protected:. doubleDoIntegral(const double* xmin, const double* xmax, bool absVal = false). Data Members; private:. doublefAbsTolabsolute tolerance; unsigned intfDimdimentionality of integrand; doublefErrorintegration error ; const ROOT::Math::IMultiGenFunction*fFunpointer to integrand function ; unsigned intfMaxPtsmaximum number of function evaluation requested ; unsigned intfMinPtsminimum number of function evaluation requested ; intfNEvalnumber of function evaluation; doublefRelErrorRelative error; doublefRelTolrelative tolerance; doublefResultlast integration result ; unsigned intfSizemax size of working array (explode with dimension); intfStatusstatus of algorithm (error if not zero). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; AdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0). construct given optionally tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array.; The size of working array represents the number of sub-division used for calculating the integral.; Higher the dimension, larger sizes are required for getting the same accuracy.; The size must be larger than >= (2N + 3) * (1 + MAXPTS/(2**N + 2N(N + 1) + 1))/2). For smaller value passed, the; minimum allowed will be used. AdaptiveIntegratorMultiDi",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:4493,Integrability,integrat,integration,4493,"t be larger than >= (2N + 3) * (1 + MAXPTS/(2**N + 2N(N + 1) + 1))/2). For smaller value passed, the; minimum allowed will be used. AdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0). Construct with a reference to the integrand function and given optionally; tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array. virtual ~AdaptiveIntegratorMultiDim(). destructor (no operations). {}. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. return DoIntegral(const double* xmin, const double* xmax, bool absVal = false). double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. void SetFunction(const ROOT::Math::IMultiGenFunction& f); set the integration function (must implement multi-dim function interface: IBaseFunctionMultiDim). double Result() const; return result of integration. { return fResult; }. double Error() const; return integration error. { return fError; }. double RelError() const; return relative error. { return fRelError; }. int Status() const; return status of integration. { return fStatus; }. int NEval() const; return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTol); set relative tolerance. void SetAbsTolerance(double absTol); set absolute tolerance. void SetSize(unsigned int size); set workspace size. { fSize = size; }. void SetMinPts(unsigned int n); set min points. { fMinPts = n; }. void SetMaxPts(unsigned int n); set max points. { fMaxPts = n; }. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options.  Author: M. Slawinska 08/2007  Copyright (c) 2007 , LCG ROOT MathLib Team *;  Last changed: root/mathcore:$Id: Adaptiv",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:4549,Integrability,interface,interface,4549,"t be larger than >= (2N + 3) * (1 + MAXPTS/(2**N + 2N(N + 1) + 1))/2). For smaller value passed, the; minimum allowed will be used. AdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0). Construct with a reference to the integrand function and given optionally; tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array. virtual ~AdaptiveIntegratorMultiDim(). destructor (no operations). {}. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. return DoIntegral(const double* xmin, const double* xmax, bool absVal = false). double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. void SetFunction(const ROOT::Math::IMultiGenFunction& f); set the integration function (must implement multi-dim function interface: IBaseFunctionMultiDim). double Result() const; return result of integration. { return fResult; }. double Error() const; return integration error. { return fError; }. double RelError() const; return relative error. { return fRelError; }. int Status() const; return status of integration. { return fStatus; }. int NEval() const; return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTol); set relative tolerance. void SetAbsTolerance(double absTol); set absolute tolerance. void SetSize(unsigned int size); set workspace size. { fSize = size; }. void SetMinPts(unsigned int n); set min points. { fMinPts = n; }. void SetMaxPts(unsigned int n); set max points. { fMaxPts = n; }. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options.  Author: M. Slawinska 08/2007  Copyright (c) 2007 , LCG ROOT MathLib Team *;  Last changed: root/mathcore:$Id: Adaptiv",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:4624,Integrability,integrat,integration,4624,"imum allowed will be used. AdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0). Construct with a reference to the integrand function and given optionally; tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array. virtual ~AdaptiveIntegratorMultiDim(). destructor (no operations). {}. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. return DoIntegral(const double* xmin, const double* xmax, bool absVal = false). double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. void SetFunction(const ROOT::Math::IMultiGenFunction& f); set the integration function (must implement multi-dim function interface: IBaseFunctionMultiDim). double Result() const; return result of integration. { return fResult; }. double Error() const; return integration error. { return fError; }. double RelError() const; return relative error. { return fRelError; }. int Status() const; return status of integration. { return fStatus; }. int NEval() const; return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTol); set relative tolerance. void SetAbsTolerance(double absTol); set absolute tolerance. void SetSize(unsigned int size); set workspace size. { fSize = size; }. void SetMinPts(unsigned int n); set min points. { fMinPts = n; }. void SetMaxPts(unsigned int n); set max points. { fMaxPts = n; }. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options.  Author: M. Slawinska 08/2007  Copyright (c) 2007 , LCG ROOT MathLib Team *;  Last changed: root/mathcore:$Id: AdaptiveIntegratorMultiDim.h 36768 2010-11-19 10:34:53Z moneta $  Last generated: 2011-11-03 20:04; This page h",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:4687,Integrability,integrat,integration,4687,"IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0). Construct with a reference to the integrand function and given optionally; tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array. virtual ~AdaptiveIntegratorMultiDim(). destructor (no operations). {}. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. return DoIntegral(const double* xmin, const double* xmax, bool absVal = false). double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. void SetFunction(const ROOT::Math::IMultiGenFunction& f); set the integration function (must implement multi-dim function interface: IBaseFunctionMultiDim). double Result() const; return result of integration. { return fResult; }. double Error() const; return integration error. { return fError; }. double RelError() const; return relative error. { return fRelError; }. int Status() const; return status of integration. { return fStatus; }. int NEval() const; return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTol); set relative tolerance. void SetAbsTolerance(double absTol); set absolute tolerance. void SetSize(unsigned int size); set workspace size. { fSize = size; }. void SetMinPts(unsigned int n); set min points. { fMinPts = n; }. void SetMaxPts(unsigned int n); set max points. { fMaxPts = n; }. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options.  Author: M. Slawinska 08/2007  Copyright (c) 2007 , LCG ROOT MathLib Team *;  Last changed: root/mathcore:$Id: AdaptiveIntegratorMultiDim.h 36768 2010-11-19 10:34:53Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding ",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:4834,Integrability,integrat,integration,4834,"ed int maxcall = 100000, unsigned int size = 0). Construct with a reference to the integrand function and given optionally; tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array. virtual ~AdaptiveIntegratorMultiDim(). destructor (no operations). {}. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. return DoIntegral(const double* xmin, const double* xmax, bool absVal = false). double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. void SetFunction(const ROOT::Math::IMultiGenFunction& f); set the integration function (must implement multi-dim function interface: IBaseFunctionMultiDim). double Result() const; return result of integration. { return fResult; }. double Error() const; return integration error. { return fError; }. double RelError() const; return relative error. { return fRelError; }. int Status() const; return status of integration. { return fStatus; }. int NEval() const; return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTol); set relative tolerance. void SetAbsTolerance(double absTol); set absolute tolerance. void SetSize(unsigned int size); set workspace size. { fSize = size; }. void SetMinPts(unsigned int n); set min points. { fMinPts = n; }. void SetMaxPts(unsigned int n); set max points. { fMaxPts = n; }. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options.  Author: M. Slawinska 08/2007  Copyright (c) 2007 , LCG ROOT MathLib Team *;  Last changed: root/mathcore:$Id: AdaptiveIntegratorMultiDim.h 36768 2010-11-19 10:34:53Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:5334,Integrability,Integrat,IntegratorMultiDimOptions,5334,"ed int maxcall = 100000, unsigned int size = 0). Construct with a reference to the integrand function and given optionally; tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array. virtual ~AdaptiveIntegratorMultiDim(). destructor (no operations). {}. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. return DoIntegral(const double* xmin, const double* xmax, bool absVal = false). double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. void SetFunction(const ROOT::Math::IMultiGenFunction& f); set the integration function (must implement multi-dim function interface: IBaseFunctionMultiDim). double Result() const; return result of integration. { return fResult; }. double Error() const; return integration error. { return fError; }. double RelError() const; return relative error. { return fRelError; }. int Status() const; return status of integration. { return fStatus; }. int NEval() const; return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTol); set relative tolerance. void SetAbsTolerance(double absTol); set absolute tolerance. void SetSize(unsigned int size); set workspace size. { fSize = size; }. void SetMinPts(unsigned int n); set min points. { fMinPts = n; }. void SetMaxPts(unsigned int n); set max points. { fMaxPts = n; }. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options.  Author: M. Slawinska 08/2007  Copyright (c) 2007 , LCG ROOT MathLib Team *;  Last changed: root/mathcore:$Id: AdaptiveIntegratorMultiDim.h 36768 2010-11-19 10:34:53Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:14,Modifiability,Adapt,AdaptiveIntegratorMultiDim,14,". ROOT::Math::AdaptiveIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::AdaptiveIntegratorMultiDim. class ROOT::Math::AdaptiveIntegratorMultiDim: public ROOT::Math::VirtualIntegratorMultiDim. class for adaptive quadrature integration in multi-dimensions; Algorithm from A.C. Genz, A.A. Malik, An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. Converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0); virtual doubleError() const; virtual doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); virtual intNEval() const; ROOT::Math::VirtualIntegratorMultiDim&ROOT::Math::VirtualIntegratorMultiDim::operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOption",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:265,Modifiability,Adapt,AdaptiveIntegratorMultiDim,265,". ROOT::Math::AdaptiveIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::AdaptiveIntegratorMultiDim. class ROOT::Math::AdaptiveIntegratorMultiDim: public ROOT::Math::VirtualIntegratorMultiDim. class for adaptive quadrature integration in multi-dimensions; Algorithm from A.C. Genz, A.A. Malik, An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. Converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0); virtual doubleError() const; virtual doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); virtual intNEval() const; ROOT::Math::VirtualIntegratorMultiDim&ROOT::Math::VirtualIntegratorMultiDim::operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOption",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:311,Modifiability,Adapt,AdaptiveIntegratorMultiDim,311,". ROOT::Math::AdaptiveIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::AdaptiveIntegratorMultiDim. class ROOT::Math::AdaptiveIntegratorMultiDim: public ROOT::Math::VirtualIntegratorMultiDim. class for adaptive quadrature integration in multi-dimensions; Algorithm from A.C. Genz, A.A. Malik, An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. Converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0); virtual doubleError() const; virtual doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); virtual intNEval() const; ROOT::Math::VirtualIntegratorMultiDim&ROOT::Math::VirtualIntegratorMultiDim::operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOption",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:395,Modifiability,adapt,adaptive,395,". ROOT::Math::AdaptiveIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::AdaptiveIntegratorMultiDim. class ROOT::Math::AdaptiveIntegratorMultiDim: public ROOT::Math::VirtualIntegratorMultiDim. class for adaptive quadrature integration in multi-dimensions; Algorithm from A.C. Genz, A.A. Malik, An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. Converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0); virtual doubleError() const; virtual doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); virtual intNEval() const; ROOT::Math::VirtualIntegratorMultiDim&ROOT::Math::VirtualIntegratorMultiDim::operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOption",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:489,Modifiability,adapt,adaptive,489,". ROOT::Math::AdaptiveIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::AdaptiveIntegratorMultiDim. class ROOT::Math::AdaptiveIntegratorMultiDim: public ROOT::Math::VirtualIntegratorMultiDim. class for adaptive quadrature integration in multi-dimensions; Algorithm from A.C. Genz, A.A. Malik, An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. Converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0); virtual doubleError() const; virtual doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); virtual intNEval() const; ROOT::Math::VirtualIntegratorMultiDim&ROOT::Math::VirtualIntegratorMultiDim::operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOption",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:628,Modifiability,adapt,adapted,628,". ROOT::Math::AdaptiveIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::AdaptiveIntegratorMultiDim. class ROOT::Math::AdaptiveIntegratorMultiDim: public ROOT::Math::VirtualIntegratorMultiDim. class for adaptive quadrature integration in multi-dimensions; Algorithm from A.C. Genz, A.A. Malik, An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. Converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0); virtual doubleError() const; virtual doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); virtual intNEval() const; ROOT::Math::VirtualIntegratorMultiDim&ROOT::Math::VirtualIntegratorMultiDim::operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOption",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:832,Modifiability,Adapt,AdaptiveIntegratorMultiDim,832,". ROOT::Math::AdaptiveIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::AdaptiveIntegratorMultiDim. class ROOT::Math::AdaptiveIntegratorMultiDim: public ROOT::Math::VirtualIntegratorMultiDim. class for adaptive quadrature integration in multi-dimensions; Algorithm from A.C. Genz, A.A. Malik, An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. Converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0); virtual doubleError() const; virtual doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); virtual intNEval() const; ROOT::Math::VirtualIntegratorMultiDim&ROOT::Math::VirtualIntegratorMultiDim::operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOption",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:874,Modifiability,Adapt,AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim,874,". ROOT::Math::AdaptiveIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::AdaptiveIntegratorMultiDim. class ROOT::Math::AdaptiveIntegratorMultiDim: public ROOT::Math::VirtualIntegratorMultiDim. class for adaptive quadrature integration in multi-dimensions; Algorithm from A.C. Genz, A.A. Malik, An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. Converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0); virtual doubleError() const; virtual doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); virtual intNEval() const; ROOT::Math::VirtualIntegratorMultiDim&ROOT::Math::VirtualIntegratorMultiDim::operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOption",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:945,Modifiability,Adapt,AdaptiveIntegratorMultiDim,945,". ROOT::Math::AdaptiveIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::AdaptiveIntegratorMultiDim. class ROOT::Math::AdaptiveIntegratorMultiDim: public ROOT::Math::VirtualIntegratorMultiDim. class for adaptive quadrature integration in multi-dimensions; Algorithm from A.C. Genz, A.A. Malik, An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. Converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0); virtual doubleError() const; virtual doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); virtual intNEval() const; ROOT::Math::VirtualIntegratorMultiDim&ROOT::Math::VirtualIntegratorMultiDim::operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOption",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:987,Modifiability,Adapt,AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim,987,". ROOT::Math::AdaptiveIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::AdaptiveIntegratorMultiDim. class ROOT::Math::AdaptiveIntegratorMultiDim: public ROOT::Math::VirtualIntegratorMultiDim. class for adaptive quadrature integration in multi-dimensions; Algorithm from A.C. Genz, A.A. Malik, An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. Converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0); virtual doubleError() const; virtual doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); virtual intNEval() const; ROOT::Math::VirtualIntegratorMultiDim&ROOT::Math::VirtualIntegratorMultiDim::operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOption",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:1151,Modifiability,Adapt,AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim,1151,"class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::AdaptiveIntegratorMultiDim. class ROOT::Math::AdaptiveIntegratorMultiDim: public ROOT::Math::VirtualIntegratorMultiDim. class for adaptive quadrature integration in multi-dimensions; Algorithm from A.C. Genz, A.A. Malik, An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. Converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0); virtual doubleError() const; virtual doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); virtual intNEval() const; ROOT::Math::VirtualIntegratorMultiDim&ROOT::Math::VirtualIntegratorMultiDim::operator=(const ROOT::Math::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); virtual voidSetRelTolerance(double relTol); voidSetSize(unsigned int size); virtual intStatus() const; vir",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:2967,Modifiability,Inherit,Inheritance,2967,"SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); virtual voidSetRelTolerance(double relTol); voidSetSize(unsigned int size); virtual intStatus() const; virtual ROOT::Math::IntegrationMultiDim::TypeROOT::Math::VirtualIntegratorMultiDim::Type() const. protected:. doubleDoIntegral(const double* xmin, const double* xmax, bool absVal = false). Data Members; private:. doublefAbsTolabsolute tolerance; unsigned intfDimdimentionality of integrand; doublefErrorintegration error ; const ROOT::Math::IMultiGenFunction*fFunpointer to integrand function ; unsigned intfMaxPtsmaximum number of function evaluation requested ; unsigned intfMinPtsminimum number of function evaluation requested ; intfNEvalnumber of function evaluation; doublefRelErrorRelative error; doublefRelTolrelative tolerance; doublefResultlast integration result ; unsigned intfSizemax size of working array (explode with dimension); intfStatusstatus of algorithm (error if not zero). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; AdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0). construct given optionally tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array.; The size of working array represents the number of sub-division used for calculating the integral.; Higher the dimension, larger sizes are required for getting the same accuracy.; The size must be larger than >= (2N + 3) * (1 + MAXPTS/(2**N + 2N(N + 1) + 1))/2). For smaller value passed, the; minimum allowed will be used. AdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0). Construct with a reference to the integrand function and given optionally; tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array. v",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:2980,Modifiability,Inherit,Inherited,2980,"SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); virtual voidSetRelTolerance(double relTol); voidSetSize(unsigned int size); virtual intStatus() const; virtual ROOT::Math::IntegrationMultiDim::TypeROOT::Math::VirtualIntegratorMultiDim::Type() const. protected:. doubleDoIntegral(const double* xmin, const double* xmax, bool absVal = false). Data Members; private:. doublefAbsTolabsolute tolerance; unsigned intfDimdimentionality of integrand; doublefErrorintegration error ; const ROOT::Math::IMultiGenFunction*fFunpointer to integrand function ; unsigned intfMaxPtsmaximum number of function evaluation requested ; unsigned intfMinPtsminimum number of function evaluation requested ; intfNEvalnumber of function evaluation; doublefRelErrorRelative error; doublefRelTolrelative tolerance; doublefResultlast integration result ; unsigned intfSizemax size of working array (explode with dimension); intfStatusstatus of algorithm (error if not zero). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; AdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0). construct given optionally tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array.; The size of working array represents the number of sub-division used for calculating the integral.; Higher the dimension, larger sizes are required for getting the same accuracy.; The size must be larger than >= (2N + 3) * (1 + MAXPTS/(2**N + 2N(N + 1) + 1))/2). For smaller value passed, the; minimum allowed will be used. AdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0). Construct with a reference to the integrand function and given optionally; tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array. v",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:3044,Modifiability,Adapt,AdaptiveIntegratorMultiDim,3044,"virtual voidSetRelTolerance(double relTol); voidSetSize(unsigned int size); virtual intStatus() const; virtual ROOT::Math::IntegrationMultiDim::TypeROOT::Math::VirtualIntegratorMultiDim::Type() const. protected:. doubleDoIntegral(const double* xmin, const double* xmax, bool absVal = false). Data Members; private:. doublefAbsTolabsolute tolerance; unsigned intfDimdimentionality of integrand; doublefErrorintegration error ; const ROOT::Math::IMultiGenFunction*fFunpointer to integrand function ; unsigned intfMaxPtsmaximum number of function evaluation requested ; unsigned intfMinPtsminimum number of function evaluation requested ; intfNEvalnumber of function evaluation; doublefRelErrorRelative error; doublefRelTolrelative tolerance; doublefResultlast integration result ; unsigned intfSizemax size of working array (explode with dimension); intfStatusstatus of algorithm (error if not zero). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; AdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0). construct given optionally tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array.; The size of working array represents the number of sub-division used for calculating the integral.; Higher the dimension, larger sizes are required for getting the same accuracy.; The size must be larger than >= (2N + 3) * (1 + MAXPTS/(2**N + 2N(N + 1) + 1))/2). For smaller value passed, the; minimum allowed will be used. AdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0). Construct with a reference to the integrand function and given optionally; tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array. virtual ~AdaptiveIntegratorMultiDim(). destructor (no operatio",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:3636,Modifiability,Adapt,AdaptiveIntegratorMultiDim,3636,"requested ; intfNEvalnumber of function evaluation; doublefRelErrorRelative error; doublefRelTolrelative tolerance; doublefResultlast integration result ; unsigned intfSizemax size of working array (explode with dimension); intfStatusstatus of algorithm (error if not zero). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; AdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0). construct given optionally tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array.; The size of working array represents the number of sub-division used for calculating the integral.; Higher the dimension, larger sizes are required for getting the same accuracy.; The size must be larger than >= (2N + 3) * (1 + MAXPTS/(2**N + 2N(N + 1) + 1))/2). For smaller value passed, the; minimum allowed will be used. AdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0). Construct with a reference to the integrand function and given optionally; tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array. virtual ~AdaptiveIntegratorMultiDim(). destructor (no operations). {}. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. return DoIntegral(const double* xmin, const double* xmax, bool absVal = false). double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. void SetFunction(const ROOT::Math::IMultiGenFunction& f); set the integration function (must implement multi-dim function interface: IBaseFunctionMultiDim). double Result() const; return result of integration. { return fResult; }. double Error() const",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:4001,Modifiability,Adapt,AdaptiveIntegratorMultiDim,4001,"ibraries. Function documentation; AdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0). construct given optionally tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array.; The size of working array represents the number of sub-division used for calculating the integral.; Higher the dimension, larger sizes are required for getting the same accuracy.; The size must be larger than >= (2N + 3) * (1 + MAXPTS/(2**N + 2N(N + 1) + 1))/2). For smaller value passed, the; minimum allowed will be used. AdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0). Construct with a reference to the integrand function and given optionally; tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array. virtual ~AdaptiveIntegratorMultiDim(). destructor (no operations). {}. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. return DoIntegral(const double* xmin, const double* xmax, bool absVal = false). double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. void SetFunction(const ROOT::Math::IMultiGenFunction& f); set the integration function (must implement multi-dim function interface: IBaseFunctionMultiDim). double Result() const; return result of integration. { return fResult; }. double Error() const; return integration error. { return fError; }. double RelError() const; return relative error. { return fRelError; }. int Status() const; return status of integration. { return fStatus; }. int NEval() const; return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTol); ",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:5498,Modifiability,Adapt,AdaptiveIntegratorMultiDim,5498,"ed int maxcall = 100000, unsigned int size = 0). Construct with a reference to the integrand function and given optionally; tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array. virtual ~AdaptiveIntegratorMultiDim(). destructor (no operations). {}. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. return DoIntegral(const double* xmin, const double* xmax, bool absVal = false). double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. void SetFunction(const ROOT::Math::IMultiGenFunction& f); set the integration function (must implement multi-dim function interface: IBaseFunctionMultiDim). double Result() const; return result of integration. { return fResult; }. double Error() const; return integration error. { return fError; }. double RelError() const; return relative error. { return fRelError; }. int Status() const; return status of integration. { return fStatus; }. int NEval() const; return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTol); set relative tolerance. void SetAbsTolerance(double absTol); set absolute tolerance. void SetSize(unsigned int size); set workspace size. { fSize = size; }. void SetMinPts(unsigned int n); set min points. { fMinPts = n; }. void SetMaxPts(unsigned int n); set max points. { fMaxPts = n; }. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options.  Author: M. Slawinska 08/2007  Copyright (c) 2007 , LCG ROOT MathLib Team *;  Last changed: root/mathcore:$Id: AdaptiveIntegratorMultiDim.h 36768 2010-11-19 10:34:53Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html532/ROOT__Math__AxisAngle.html:3176,Modifiability,Inherit,Inheritance,3176,"LorentzVector<ROOT::Math::PxPyPzE4D<double> >operator*(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >& v) const; ROOT::Math::AxisAngle&operator=(ROOT::Math::Rotation3D const& r); ROOT::Math::AxisAngle&operator=(ROOT::Math::EulerAngles const& r); ROOT::Math::AxisAngle&operator=(ROOT::Math::RotationZYX const& r); ROOT::Math::AxisAngle&operator=(ROOT::Math::RotationX const& r); ROOT::Math::AxisAngle&operator=(ROOT::Math::RotationY const& r); ROOT::Math::AxisAngle&operator=(ROOT::Math::RotationZ const& r); ROOT::Math::AxisAngle&operator=(ROOT::Math::Quaternion const& r); ROOT::Math::AxisAngle&operator=(const ROOT::Math::AxisAngle&); booloperator==(const ROOT::Math::AxisAngle& rhs) const; voidRectify(); voidSetComponents(double* begin, double* end). private:. static doublePi(); voidRectifyAngle(). Data Members; private:. ROOT::Math::AxisAngle::ScalarfAnglerotation angle; ROOT::Math::AxisAngle::AxisVectorfAxisrotation axis (3D vector). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; AxisAngle(). Default constructor (axis is z and angle is zero). { }. AxisAngle(const AnyVector & v, Scalar angle). Construct from a non-zero vector (x,y,z) and an angle.; Precondition: the Vector needs to implement x(), y(), z(), and unit(). { }. AxisAngle(IT begin, IT end). Construct given a pair of pointers or iterators defining the; beginning and end of an array of four Scalars, to be treated as; the x, y, and z components of a unit axis vector, and the angle; of rotation.; Precondition: The first three components are assumed to represent; the rotation axis vector and the 4-th the rotation angle.; The angle is assumed to be in the range (-pi,pi].; The axis vector is automatically normalized to be a unit vector. { SetComponents(begin,end); }. void Rectify(); The compiler-generated copy ctor, copy assignment, and dtor are OK. Re-adjust components to eliminate small deviations from the axis; being a unit vector and angles out of the ca",MatchSource.WIKI,root/html532/ROOT__Math__AxisAngle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AxisAngle.html
https://root.cern/root/html532/ROOT__Math__AxisAngle.html:3189,Modifiability,Inherit,Inherited,3189,"LorentzVector<ROOT::Math::PxPyPzE4D<double> >operator*(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >& v) const; ROOT::Math::AxisAngle&operator=(ROOT::Math::Rotation3D const& r); ROOT::Math::AxisAngle&operator=(ROOT::Math::EulerAngles const& r); ROOT::Math::AxisAngle&operator=(ROOT::Math::RotationZYX const& r); ROOT::Math::AxisAngle&operator=(ROOT::Math::RotationX const& r); ROOT::Math::AxisAngle&operator=(ROOT::Math::RotationY const& r); ROOT::Math::AxisAngle&operator=(ROOT::Math::RotationZ const& r); ROOT::Math::AxisAngle&operator=(ROOT::Math::Quaternion const& r); ROOT::Math::AxisAngle&operator=(const ROOT::Math::AxisAngle&); booloperator==(const ROOT::Math::AxisAngle& rhs) const; voidRectify(); voidSetComponents(double* begin, double* end). private:. static doublePi(); voidRectifyAngle(). Data Members; private:. ROOT::Math::AxisAngle::ScalarfAnglerotation angle; ROOT::Math::AxisAngle::AxisVectorfAxisrotation axis (3D vector). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; AxisAngle(). Default constructor (axis is z and angle is zero). { }. AxisAngle(const AnyVector & v, Scalar angle). Construct from a non-zero vector (x,y,z) and an angle.; Precondition: the Vector needs to implement x(), y(), z(), and unit(). { }. AxisAngle(IT begin, IT end). Construct given a pair of pointers or iterators defining the; beginning and end of an array of four Scalars, to be treated as; the x, y, and z components of a unit axis vector, and the angle; of rotation.; Precondition: The first three components are assumed to represent; the rotation axis vector and the 4-th the rotation angle.; The angle is assumed to be in the range (-pi,pi].; The axis vector is automatically normalized to be a unit vector. { SetComponents(begin,end); }. void Rectify(); The compiler-generated copy ctor, copy assignment, and dtor are OK. Re-adjust components to eliminate small deviations from the axis; being a unit vector and angles out of the ca",MatchSource.WIKI,root/html532/ROOT__Math__AxisAngle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AxisAngle.html
https://root.cern/root/html532/ROOT__Math__AxisAngle.html:5223,Security,access,access,5223,"AxisAngle(const ROOT::Math::AxisAngle& ); ======== Construction From other Rotation Forms ==================. Construct from another supported rotation type (see gv_detail::convert ). {gv_detail::convert(r,*this);}. AxisAngle & operator=( OtherRotation const & r ). Assign from another supported rotation type (see gv_detail::convert ). void SetComponents(double* begin, double* end); ======== Components ==============. Set the axis and then the angle given a pair of pointers or iterators; defining the beginning and end of an array of four Scalars.; Precondition: The first three components are assumed to represent; the rotation axis vector and the 4-th the rotation angle.; The angle is assumed to be in the range (-pi,pi].; The axis vector is automatically normalized to be a unit vector. void GetComponents(IT begin, IT end). Get the axis and then the angle into data specified by an iterator begin; and another to the end of the desired data (4 past start). Scalar Angle() const. access to rotation angle. { return fAngle; }. XYZVector operator()(const ROOT::Math::AxisAngle::XYZVector& v) const. AVector operator*(const AVector & v). Overload operator * for rotation on a vector. void Invert(). Invert an AxisAngle rotation in place. { fAngle = -fAngle; }. AxisAngle Inverse() const. Return inverse of an AxisAngle rotation. { AxisAngle result(*this); result.Invert(); return result; }. return ! operator==(rhs). void RectifyAngle(). double Pi(); { return 3.14159265358979323; }. AxisAngle operator*(RotationX const & r1, AxisAngle const & r2). Multiplication of an axial rotation by an AxisAngle. AxisAngle operator*(RotationY const & r1, AxisAngle const & r2). AxisAngle operator*(RotationZ const & r1, AxisAngle const & r2).  Last changed: root/mathcore:$Id: AxisAngle.h 22516 2008-03-07 15:14:26Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROO",MatchSource.WIKI,root/html532/ROOT__Math__AxisAngle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__AxisAngle.html
https://root.cern/root/html532/ROOT__Math__BaseIntegratorOptions.html:638,Availability,avail,available,638,". ROOT::Math::BaseIntegratorOptions. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::BaseIntegratorOptions. class ROOT::Math::BaseIntegratorOptions. Base class for Numerical integration options; common in 1D and multi-dimension; This is an internal class and is not supposed to be instantiated by the user. @ingroup Integration. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~BaseIntegratorOptions(); doubleAbsTolerance() const; ROOT::Math::IOptions*ExtraOptions() const; virtual stringIntegrator() const; ROOT::Math::BaseIntegratorOptions&operator=(const ROOT::Math::BaseIntegratorOptions& opt); doubleRelTolerance() const; voidSetAbsTolerance(double tol); voidSetExtraOptions(const ROOT::Math::IOptions& opt); voidSetRelTolerance(double tol); voidSetWKSize(unsigned int size); unsigned intWKSize() const. protected:. voidClearExtra(). Data Members; protected:. doublefAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*fExtraOptionsextra options ; intfIntegTypeIntegrator type (value converted from enum); unsigned intfNCalls(max) funxtion calls; doublefRelTolerancerelative tolerance ; unsigned intfWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::BaseIntegratorOptions& opt); assignment operators. virtual ~BaseIntegratorOptions(); protected constructor to avoid user creating this class. { ClearExtra(); }. std::string Integrator() const; name of 1D integrator. double AbsTolerance() const; non-static methods for retrivieng options ; absolute tolerance. { return fAbsTolerance; }. double RelTolerance() const; absolute tolerance. { return fRelTolerance; }. unsigned int WK",MatchSource.WIKI,root/html532/ROOT__Math__BaseIntegratorOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BaseIntegratorOptions.html
https://root.cern/root/html532/ROOT__Math__BaseIntegratorOptions.html:1195,Availability,toler,tolerance,1195,"h::BaseIntegratorOptions. Base class for Numerical integration options; common in 1D and multi-dimension; This is an internal class and is not supposed to be instantiated by the user. @ingroup Integration. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~BaseIntegratorOptions(); doubleAbsTolerance() const; ROOT::Math::IOptions*ExtraOptions() const; virtual stringIntegrator() const; ROOT::Math::BaseIntegratorOptions&operator=(const ROOT::Math::BaseIntegratorOptions& opt); doubleRelTolerance() const; voidSetAbsTolerance(double tol); voidSetExtraOptions(const ROOT::Math::IOptions& opt); voidSetRelTolerance(double tol); voidSetWKSize(unsigned int size); unsigned intWKSize() const. protected:. voidClearExtra(). Data Members; protected:. doublefAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*fExtraOptionsextra options ; intfIntegTypeIntegrator type (value converted from enum); unsigned intfNCalls(max) funxtion calls; doublefRelTolerancerelative tolerance ; unsigned intfWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::BaseIntegratorOptions& opt); assignment operators. virtual ~BaseIntegratorOptions(); protected constructor to avoid user creating this class. { ClearExtra(); }. std::string Integrator() const; name of 1D integrator. double AbsTolerance() const; non-static methods for retrivieng options ; absolute tolerance. { return fAbsTolerance; }. double RelTolerance() const; absolute tolerance. { return fRelTolerance; }. unsigned int WKSize() const; size of the workspace. { return fWKSize; }. IOptions * ExtraOptions() const; return extra options. { return fExtraOptions; }. void SetAbsTolerance(double tol); non-static methods for setting options ; set the abs tolerance. { fAbsTolerance = tol; }. void SetRelTolerance(double tol);",MatchSource.WIKI,root/html532/ROOT__Math__BaseIntegratorOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BaseIntegratorOptions.html
https://root.cern/root/html532/ROOT__Math__BaseIntegratorOptions.html:1384,Availability,toler,tolerance,1384,"h::BaseIntegratorOptions. Base class for Numerical integration options; common in 1D and multi-dimension; This is an internal class and is not supposed to be instantiated by the user. @ingroup Integration. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~BaseIntegratorOptions(); doubleAbsTolerance() const; ROOT::Math::IOptions*ExtraOptions() const; virtual stringIntegrator() const; ROOT::Math::BaseIntegratorOptions&operator=(const ROOT::Math::BaseIntegratorOptions& opt); doubleRelTolerance() const; voidSetAbsTolerance(double tol); voidSetExtraOptions(const ROOT::Math::IOptions& opt); voidSetRelTolerance(double tol); voidSetWKSize(unsigned int size); unsigned intWKSize() const. protected:. voidClearExtra(). Data Members; protected:. doublefAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*fExtraOptionsextra options ; intfIntegTypeIntegrator type (value converted from enum); unsigned intfNCalls(max) funxtion calls; doublefRelTolerancerelative tolerance ; unsigned intfWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::BaseIntegratorOptions& opt); assignment operators. virtual ~BaseIntegratorOptions(); protected constructor to avoid user creating this class. { ClearExtra(); }. std::string Integrator() const; name of 1D integrator. double AbsTolerance() const; non-static methods for retrivieng options ; absolute tolerance. { return fAbsTolerance; }. double RelTolerance() const; absolute tolerance. { return fRelTolerance; }. unsigned int WKSize() const; size of the workspace. { return fWKSize; }. IOptions * ExtraOptions() const; return extra options. { return fExtraOptions; }. void SetAbsTolerance(double tol); non-static methods for setting options ; set the abs tolerance. { fAbsTolerance = tol; }. void SetRelTolerance(double tol);",MatchSource.WIKI,root/html532/ROOT__Math__BaseIntegratorOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BaseIntegratorOptions.html
https://root.cern/root/html532/ROOT__Math__BaseIntegratorOptions.html:1872,Availability,toler,tolerance,1872,"rOptions&operator=(const ROOT::Math::BaseIntegratorOptions& opt); doubleRelTolerance() const; voidSetAbsTolerance(double tol); voidSetExtraOptions(const ROOT::Math::IOptions& opt); voidSetRelTolerance(double tol); voidSetWKSize(unsigned int size); unsigned intWKSize() const. protected:. voidClearExtra(). Data Members; protected:. doublefAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*fExtraOptionsextra options ; intfIntegTypeIntegrator type (value converted from enum); unsigned intfNCalls(max) funxtion calls; doublefRelTolerancerelative tolerance ; unsigned intfWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::BaseIntegratorOptions& opt); assignment operators. virtual ~BaseIntegratorOptions(); protected constructor to avoid user creating this class. { ClearExtra(); }. std::string Integrator() const; name of 1D integrator. double AbsTolerance() const; non-static methods for retrivieng options ; absolute tolerance. { return fAbsTolerance; }. double RelTolerance() const; absolute tolerance. { return fRelTolerance; }. unsigned int WKSize() const; size of the workspace. { return fWKSize; }. IOptions * ExtraOptions() const; return extra options. { return fExtraOptions; }. void SetAbsTolerance(double tol); non-static methods for setting options ; set the abs tolerance. { fAbsTolerance = tol; }. void SetRelTolerance(double tol); set the relative tolerance. { fRelTolerance = tol; }. void SetWKSize(unsigned int size); set workspace size. { fWKSize = size; }. void SetExtraOptions(const ROOT::Math::IOptions& opt); set extra options (in this case pointer is cloned). void ClearExtra().  Author: L. Moneta Fri Aug 15 2008  Copyright (c) 2008 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: IntegratorOptions.h 36806 2010-11-20 11:09:14Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or su",MatchSource.WIKI,root/html532/ROOT__Math__BaseIntegratorOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BaseIntegratorOptions.html
https://root.cern/root/html532/ROOT__Math__BaseIntegratorOptions.html:1948,Availability,toler,tolerance,1948,"voidSetAbsTolerance(double tol); voidSetExtraOptions(const ROOT::Math::IOptions& opt); voidSetRelTolerance(double tol); voidSetWKSize(unsigned int size); unsigned intWKSize() const. protected:. voidClearExtra(). Data Members; protected:. doublefAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*fExtraOptionsextra options ; intfIntegTypeIntegrator type (value converted from enum); unsigned intfNCalls(max) funxtion calls; doublefRelTolerancerelative tolerance ; unsigned intfWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::BaseIntegratorOptions& opt); assignment operators. virtual ~BaseIntegratorOptions(); protected constructor to avoid user creating this class. { ClearExtra(); }. std::string Integrator() const; name of 1D integrator. double AbsTolerance() const; non-static methods for retrivieng options ; absolute tolerance. { return fAbsTolerance; }. double RelTolerance() const; absolute tolerance. { return fRelTolerance; }. unsigned int WKSize() const; size of the workspace. { return fWKSize; }. IOptions * ExtraOptions() const; return extra options. { return fExtraOptions; }. void SetAbsTolerance(double tol); non-static methods for setting options ; set the abs tolerance. { fAbsTolerance = tol; }. void SetRelTolerance(double tol); set the relative tolerance. { fRelTolerance = tol; }. void SetWKSize(unsigned int size); set workspace size. { fWKSize = size; }. void SetExtraOptions(const ROOT::Math::IOptions& opt); set extra options (in this case pointer is cloned). void ClearExtra().  Author: L. Moneta Fri Aug 15 2008  Copyright (c) 2008 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: IntegratorOptions.h 36806 2010-11-20 11:09:14Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__BaseIntegratorOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BaseIntegratorOptions.html
https://root.cern/root/html532/ROOT__Math__BaseIntegratorOptions.html:2228,Availability,toler,tolerance,2228,"voidSetAbsTolerance(double tol); voidSetExtraOptions(const ROOT::Math::IOptions& opt); voidSetRelTolerance(double tol); voidSetWKSize(unsigned int size); unsigned intWKSize() const. protected:. voidClearExtra(). Data Members; protected:. doublefAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*fExtraOptionsextra options ; intfIntegTypeIntegrator type (value converted from enum); unsigned intfNCalls(max) funxtion calls; doublefRelTolerancerelative tolerance ; unsigned intfWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::BaseIntegratorOptions& opt); assignment operators. virtual ~BaseIntegratorOptions(); protected constructor to avoid user creating this class. { ClearExtra(); }. std::string Integrator() const; name of 1D integrator. double AbsTolerance() const; non-static methods for retrivieng options ; absolute tolerance. { return fAbsTolerance; }. double RelTolerance() const; absolute tolerance. { return fRelTolerance; }. unsigned int WKSize() const; size of the workspace. { return fWKSize; }. IOptions * ExtraOptions() const; return extra options. { return fExtraOptions; }. void SetAbsTolerance(double tol); non-static methods for setting options ; set the abs tolerance. { fAbsTolerance = tol; }. void SetRelTolerance(double tol); set the relative tolerance. { fRelTolerance = tol; }. void SetWKSize(unsigned int size); set workspace size. { fWKSize = size; }. void SetExtraOptions(const ROOT::Math::IOptions& opt); set extra options (in this case pointer is cloned). void ClearExtra().  Author: L. Moneta Fri Aug 15 2008  Copyright (c) 2008 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: IntegratorOptions.h 36806 2010-11-20 11:09:14Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__BaseIntegratorOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BaseIntegratorOptions.html
https://root.cern/root/html532/ROOT__Math__BaseIntegratorOptions.html:2316,Availability,toler,tolerance,2316,"voidSetAbsTolerance(double tol); voidSetExtraOptions(const ROOT::Math::IOptions& opt); voidSetRelTolerance(double tol); voidSetWKSize(unsigned int size); unsigned intWKSize() const. protected:. voidClearExtra(). Data Members; protected:. doublefAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*fExtraOptionsextra options ; intfIntegTypeIntegrator type (value converted from enum); unsigned intfNCalls(max) funxtion calls; doublefRelTolerancerelative tolerance ; unsigned intfWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::BaseIntegratorOptions& opt); assignment operators. virtual ~BaseIntegratorOptions(); protected constructor to avoid user creating this class. { ClearExtra(); }. std::string Integrator() const; name of 1D integrator. double AbsTolerance() const; non-static methods for retrivieng options ; absolute tolerance. { return fAbsTolerance; }. double RelTolerance() const; absolute tolerance. { return fRelTolerance; }. unsigned int WKSize() const; size of the workspace. { return fWKSize; }. IOptions * ExtraOptions() const; return extra options. { return fExtraOptions; }. void SetAbsTolerance(double tol); non-static methods for setting options ; set the abs tolerance. { fAbsTolerance = tol; }. void SetRelTolerance(double tol); set the relative tolerance. { fRelTolerance = tol; }. void SetWKSize(unsigned int size); set workspace size. { fWKSize = size; }. void SetExtraOptions(const ROOT::Math::IOptions& opt); set extra options (in this case pointer is cloned). void ClearExtra().  Author: L. Moneta Fri Aug 15 2008  Copyright (c) 2008 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: IntegratorOptions.h 36806 2010-11-20 11:09:14Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__BaseIntegratorOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BaseIntegratorOptions.html
https://root.cern/root/html532/ROOT__Math__BaseIntegratorOptions.html:349,Deployability,integrat,integration,349,". ROOT::Math::BaseIntegratorOptions. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::BaseIntegratorOptions. class ROOT::Math::BaseIntegratorOptions. Base class for Numerical integration options; common in 1D and multi-dimension; This is an internal class and is not supposed to be instantiated by the user. @ingroup Integration. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~BaseIntegratorOptions(); doubleAbsTolerance() const; ROOT::Math::IOptions*ExtraOptions() const; virtual stringIntegrator() const; ROOT::Math::BaseIntegratorOptions&operator=(const ROOT::Math::BaseIntegratorOptions& opt); doubleRelTolerance() const; voidSetAbsTolerance(double tol); voidSetExtraOptions(const ROOT::Math::IOptions& opt); voidSetRelTolerance(double tol); voidSetWKSize(unsigned int size); unsigned intWKSize() const. protected:. voidClearExtra(). Data Members; protected:. doublefAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*fExtraOptionsextra options ; intfIntegTypeIntegrator type (value converted from enum); unsigned intfNCalls(max) funxtion calls; doublefRelTolerancerelative tolerance ; unsigned intfWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::BaseIntegratorOptions& opt); assignment operators. virtual ~BaseIntegratorOptions(); protected constructor to avoid user creating this class. { ClearExtra(); }. std::string Integrator() const; name of 1D integrator. double AbsTolerance() const; non-static methods for retrivieng options ; absolute tolerance. { return fAbsTolerance; }. double RelTolerance() const; absolute tolerance. { return fRelTolerance; }. unsigned int WK",MatchSource.WIKI,root/html532/ROOT__Math__BaseIntegratorOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BaseIntegratorOptions.html
https://root.cern/root/html532/ROOT__Math__BaseIntegratorOptions.html:491,Deployability,Integrat,Integration,491,". ROOT::Math::BaseIntegratorOptions. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::BaseIntegratorOptions. class ROOT::Math::BaseIntegratorOptions. Base class for Numerical integration options; common in 1D and multi-dimension; This is an internal class and is not supposed to be instantiated by the user. @ingroup Integration. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~BaseIntegratorOptions(); doubleAbsTolerance() const; ROOT::Math::IOptions*ExtraOptions() const; virtual stringIntegrator() const; ROOT::Math::BaseIntegratorOptions&operator=(const ROOT::Math::BaseIntegratorOptions& opt); doubleRelTolerance() const; voidSetAbsTolerance(double tol); voidSetExtraOptions(const ROOT::Math::IOptions& opt); voidSetRelTolerance(double tol); voidSetWKSize(unsigned int size); unsigned intWKSize() const. protected:. voidClearExtra(). Data Members; protected:. doublefAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*fExtraOptionsextra options ; intfIntegTypeIntegrator type (value converted from enum); unsigned intfNCalls(max) funxtion calls; doublefRelTolerancerelative tolerance ; unsigned intfWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::BaseIntegratorOptions& opt); assignment operators. virtual ~BaseIntegratorOptions(); protected constructor to avoid user creating this class. { ClearExtra(); }. std::string Integrator() const; name of 1D integrator. double AbsTolerance() const; non-static methods for retrivieng options ; absolute tolerance. { return fAbsTolerance; }. double RelTolerance() const; absolute tolerance. { return fRelTolerance; }. unsigned int WK",MatchSource.WIKI,root/html532/ROOT__Math__BaseIntegratorOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BaseIntegratorOptions.html
https://root.cern/root/html532/ROOT__Math__BaseIntegratorOptions.html:1747,Deployability,Integrat,Integrator,1747,"tions() const; virtual stringIntegrator() const; ROOT::Math::BaseIntegratorOptions&operator=(const ROOT::Math::BaseIntegratorOptions& opt); doubleRelTolerance() const; voidSetAbsTolerance(double tol); voidSetExtraOptions(const ROOT::Math::IOptions& opt); voidSetRelTolerance(double tol); voidSetWKSize(unsigned int size); unsigned intWKSize() const. protected:. voidClearExtra(). Data Members; protected:. doublefAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*fExtraOptionsextra options ; intfIntegTypeIntegrator type (value converted from enum); unsigned intfNCalls(max) funxtion calls; doublefRelTolerancerelative tolerance ; unsigned intfWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::BaseIntegratorOptions& opt); assignment operators. virtual ~BaseIntegratorOptions(); protected constructor to avoid user creating this class. { ClearExtra(); }. std::string Integrator() const; name of 1D integrator. double AbsTolerance() const; non-static methods for retrivieng options ; absolute tolerance. { return fAbsTolerance; }. double RelTolerance() const; absolute tolerance. { return fRelTolerance; }. unsigned int WKSize() const; size of the workspace. { return fWKSize; }. IOptions * ExtraOptions() const; return extra options. { return fExtraOptions; }. void SetAbsTolerance(double tol); non-static methods for setting options ; set the abs tolerance. { fAbsTolerance = tol; }. void SetRelTolerance(double tol); set the relative tolerance. { fRelTolerance = tol; }. void SetWKSize(unsigned int size); set workspace size. { fWKSize = size; }. void SetExtraOptions(const ROOT::Math::IOptions& opt); set extra options (in this case pointer is cloned). void ClearExtra().  Author: L. Moneta Fri Aug 15 2008  Copyright (c) 2008 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: IntegratorOptions.h 36806 2010-11-20 11:09:14Z moneta $  Last generated: 2011-1",MatchSource.WIKI,root/html532/ROOT__Math__BaseIntegratorOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BaseIntegratorOptions.html
https://root.cern/root/html532/ROOT__Math__BaseIntegratorOptions.html:1778,Deployability,integrat,integrator,1778,"tions() const; virtual stringIntegrator() const; ROOT::Math::BaseIntegratorOptions&operator=(const ROOT::Math::BaseIntegratorOptions& opt); doubleRelTolerance() const; voidSetAbsTolerance(double tol); voidSetExtraOptions(const ROOT::Math::IOptions& opt); voidSetRelTolerance(double tol); voidSetWKSize(unsigned int size); unsigned intWKSize() const. protected:. voidClearExtra(). Data Members; protected:. doublefAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*fExtraOptionsextra options ; intfIntegTypeIntegrator type (value converted from enum); unsigned intfNCalls(max) funxtion calls; doublefRelTolerancerelative tolerance ; unsigned intfWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::BaseIntegratorOptions& opt); assignment operators. virtual ~BaseIntegratorOptions(); protected constructor to avoid user creating this class. { ClearExtra(); }. std::string Integrator() const; name of 1D integrator. double AbsTolerance() const; non-static methods for retrivieng options ; absolute tolerance. { return fAbsTolerance; }. double RelTolerance() const; absolute tolerance. { return fRelTolerance; }. unsigned int WKSize() const; size of the workspace. { return fWKSize; }. IOptions * ExtraOptions() const; return extra options. { return fExtraOptions; }. void SetAbsTolerance(double tol); non-static methods for setting options ; set the abs tolerance. { fAbsTolerance = tol; }. void SetRelTolerance(double tol); set the relative tolerance. { fRelTolerance = tol; }. void SetWKSize(unsigned int size); set workspace size. { fWKSize = size; }. void SetExtraOptions(const ROOT::Math::IOptions& opt); set extra options (in this case pointer is cloned). void ClearExtra().  Author: L. Moneta Fri Aug 15 2008  Copyright (c) 2008 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: IntegratorOptions.h 36806 2010-11-20 11:09:14Z moneta $  Last generated: 2011-1",MatchSource.WIKI,root/html532/ROOT__Math__BaseIntegratorOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BaseIntegratorOptions.html
https://root.cern/root/html532/ROOT__Math__BaseIntegratorOptions.html:2682,Deployability,Integrat,IntegratorOptions,2682,"voidSetAbsTolerance(double tol); voidSetExtraOptions(const ROOT::Math::IOptions& opt); voidSetRelTolerance(double tol); voidSetWKSize(unsigned int size); unsigned intWKSize() const. protected:. voidClearExtra(). Data Members; protected:. doublefAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*fExtraOptionsextra options ; intfIntegTypeIntegrator type (value converted from enum); unsigned intfNCalls(max) funxtion calls; doublefRelTolerancerelative tolerance ; unsigned intfWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::BaseIntegratorOptions& opt); assignment operators. virtual ~BaseIntegratorOptions(); protected constructor to avoid user creating this class. { ClearExtra(); }. std::string Integrator() const; name of 1D integrator. double AbsTolerance() const; non-static methods for retrivieng options ; absolute tolerance. { return fAbsTolerance; }. double RelTolerance() const; absolute tolerance. { return fRelTolerance; }. unsigned int WKSize() const; size of the workspace. { return fWKSize; }. IOptions * ExtraOptions() const; return extra options. { return fExtraOptions; }. void SetAbsTolerance(double tol); non-static methods for setting options ; set the abs tolerance. { fAbsTolerance = tol; }. void SetRelTolerance(double tol); set the relative tolerance. { fRelTolerance = tol; }. void SetWKSize(unsigned int size); set workspace size. { fWKSize = size; }. void SetExtraOptions(const ROOT::Math::IOptions& opt); set extra options (in this case pointer is cloned). void ClearExtra().  Author: L. Moneta Fri Aug 15 2008  Copyright (c) 2008 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: IntegratorOptions.h 36806 2010-11-20 11:09:14Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__BaseIntegratorOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BaseIntegratorOptions.html
https://root.cern/root/html532/ROOT__Math__BaseIntegratorOptions.html:349,Integrability,integrat,integration,349,". ROOT::Math::BaseIntegratorOptions. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::BaseIntegratorOptions. class ROOT::Math::BaseIntegratorOptions. Base class for Numerical integration options; common in 1D and multi-dimension; This is an internal class and is not supposed to be instantiated by the user. @ingroup Integration. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~BaseIntegratorOptions(); doubleAbsTolerance() const; ROOT::Math::IOptions*ExtraOptions() const; virtual stringIntegrator() const; ROOT::Math::BaseIntegratorOptions&operator=(const ROOT::Math::BaseIntegratorOptions& opt); doubleRelTolerance() const; voidSetAbsTolerance(double tol); voidSetExtraOptions(const ROOT::Math::IOptions& opt); voidSetRelTolerance(double tol); voidSetWKSize(unsigned int size); unsigned intWKSize() const. protected:. voidClearExtra(). Data Members; protected:. doublefAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*fExtraOptionsextra options ; intfIntegTypeIntegrator type (value converted from enum); unsigned intfNCalls(max) funxtion calls; doublefRelTolerancerelative tolerance ; unsigned intfWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::BaseIntegratorOptions& opt); assignment operators. virtual ~BaseIntegratorOptions(); protected constructor to avoid user creating this class. { ClearExtra(); }. std::string Integrator() const; name of 1D integrator. double AbsTolerance() const; non-static methods for retrivieng options ; absolute tolerance. { return fAbsTolerance; }. double RelTolerance() const; absolute tolerance. { return fRelTolerance; }. unsigned int WK",MatchSource.WIKI,root/html532/ROOT__Math__BaseIntegratorOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BaseIntegratorOptions.html
https://root.cern/root/html532/ROOT__Math__BaseIntegratorOptions.html:491,Integrability,Integrat,Integration,491,". ROOT::Math::BaseIntegratorOptions. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::BaseIntegratorOptions. class ROOT::Math::BaseIntegratorOptions. Base class for Numerical integration options; common in 1D and multi-dimension; This is an internal class and is not supposed to be instantiated by the user. @ingroup Integration. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~BaseIntegratorOptions(); doubleAbsTolerance() const; ROOT::Math::IOptions*ExtraOptions() const; virtual stringIntegrator() const; ROOT::Math::BaseIntegratorOptions&operator=(const ROOT::Math::BaseIntegratorOptions& opt); doubleRelTolerance() const; voidSetAbsTolerance(double tol); voidSetExtraOptions(const ROOT::Math::IOptions& opt); voidSetRelTolerance(double tol); voidSetWKSize(unsigned int size); unsigned intWKSize() const. protected:. voidClearExtra(). Data Members; protected:. doublefAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*fExtraOptionsextra options ; intfIntegTypeIntegrator type (value converted from enum); unsigned intfNCalls(max) funxtion calls; doublefRelTolerancerelative tolerance ; unsigned intfWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::BaseIntegratorOptions& opt); assignment operators. virtual ~BaseIntegratorOptions(); protected constructor to avoid user creating this class. { ClearExtra(); }. std::string Integrator() const; name of 1D integrator. double AbsTolerance() const; non-static methods for retrivieng options ; absolute tolerance. { return fAbsTolerance; }. double RelTolerance() const; absolute tolerance. { return fRelTolerance; }. unsigned int WK",MatchSource.WIKI,root/html532/ROOT__Math__BaseIntegratorOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BaseIntegratorOptions.html
https://root.cern/root/html532/ROOT__Math__BaseIntegratorOptions.html:1747,Integrability,Integrat,Integrator,1747,"tions() const; virtual stringIntegrator() const; ROOT::Math::BaseIntegratorOptions&operator=(const ROOT::Math::BaseIntegratorOptions& opt); doubleRelTolerance() const; voidSetAbsTolerance(double tol); voidSetExtraOptions(const ROOT::Math::IOptions& opt); voidSetRelTolerance(double tol); voidSetWKSize(unsigned int size); unsigned intWKSize() const. protected:. voidClearExtra(). Data Members; protected:. doublefAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*fExtraOptionsextra options ; intfIntegTypeIntegrator type (value converted from enum); unsigned intfNCalls(max) funxtion calls; doublefRelTolerancerelative tolerance ; unsigned intfWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::BaseIntegratorOptions& opt); assignment operators. virtual ~BaseIntegratorOptions(); protected constructor to avoid user creating this class. { ClearExtra(); }. std::string Integrator() const; name of 1D integrator. double AbsTolerance() const; non-static methods for retrivieng options ; absolute tolerance. { return fAbsTolerance; }. double RelTolerance() const; absolute tolerance. { return fRelTolerance; }. unsigned int WKSize() const; size of the workspace. { return fWKSize; }. IOptions * ExtraOptions() const; return extra options. { return fExtraOptions; }. void SetAbsTolerance(double tol); non-static methods for setting options ; set the abs tolerance. { fAbsTolerance = tol; }. void SetRelTolerance(double tol); set the relative tolerance. { fRelTolerance = tol; }. void SetWKSize(unsigned int size); set workspace size. { fWKSize = size; }. void SetExtraOptions(const ROOT::Math::IOptions& opt); set extra options (in this case pointer is cloned). void ClearExtra().  Author: L. Moneta Fri Aug 15 2008  Copyright (c) 2008 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: IntegratorOptions.h 36806 2010-11-20 11:09:14Z moneta $  Last generated: 2011-1",MatchSource.WIKI,root/html532/ROOT__Math__BaseIntegratorOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BaseIntegratorOptions.html
https://root.cern/root/html532/ROOT__Math__BaseIntegratorOptions.html:1778,Integrability,integrat,integrator,1778,"tions() const; virtual stringIntegrator() const; ROOT::Math::BaseIntegratorOptions&operator=(const ROOT::Math::BaseIntegratorOptions& opt); doubleRelTolerance() const; voidSetAbsTolerance(double tol); voidSetExtraOptions(const ROOT::Math::IOptions& opt); voidSetRelTolerance(double tol); voidSetWKSize(unsigned int size); unsigned intWKSize() const. protected:. voidClearExtra(). Data Members; protected:. doublefAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*fExtraOptionsextra options ; intfIntegTypeIntegrator type (value converted from enum); unsigned intfNCalls(max) funxtion calls; doublefRelTolerancerelative tolerance ; unsigned intfWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::BaseIntegratorOptions& opt); assignment operators. virtual ~BaseIntegratorOptions(); protected constructor to avoid user creating this class. { ClearExtra(); }. std::string Integrator() const; name of 1D integrator. double AbsTolerance() const; non-static methods for retrivieng options ; absolute tolerance. { return fAbsTolerance; }. double RelTolerance() const; absolute tolerance. { return fRelTolerance; }. unsigned int WKSize() const; size of the workspace. { return fWKSize; }. IOptions * ExtraOptions() const; return extra options. { return fExtraOptions; }. void SetAbsTolerance(double tol); non-static methods for setting options ; set the abs tolerance. { fAbsTolerance = tol; }. void SetRelTolerance(double tol); set the relative tolerance. { fRelTolerance = tol; }. void SetWKSize(unsigned int size); set workspace size. { fWKSize = size; }. void SetExtraOptions(const ROOT::Math::IOptions& opt); set extra options (in this case pointer is cloned). void ClearExtra().  Author: L. Moneta Fri Aug 15 2008  Copyright (c) 2008 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: IntegratorOptions.h 36806 2010-11-20 11:09:14Z moneta $  Last generated: 2011-1",MatchSource.WIKI,root/html532/ROOT__Math__BaseIntegratorOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BaseIntegratorOptions.html
https://root.cern/root/html532/ROOT__Math__BaseIntegratorOptions.html:2682,Integrability,Integrat,IntegratorOptions,2682,"voidSetAbsTolerance(double tol); voidSetExtraOptions(const ROOT::Math::IOptions& opt); voidSetRelTolerance(double tol); voidSetWKSize(unsigned int size); unsigned intWKSize() const. protected:. voidClearExtra(). Data Members; protected:. doublefAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*fExtraOptionsextra options ; intfIntegTypeIntegrator type (value converted from enum); unsigned intfNCalls(max) funxtion calls; doublefRelTolerancerelative tolerance ; unsigned intfWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::BaseIntegratorOptions& opt); assignment operators. virtual ~BaseIntegratorOptions(); protected constructor to avoid user creating this class. { ClearExtra(); }. std::string Integrator() const; name of 1D integrator. double AbsTolerance() const; non-static methods for retrivieng options ; absolute tolerance. { return fAbsTolerance; }. double RelTolerance() const; absolute tolerance. { return fRelTolerance; }. unsigned int WKSize() const; size of the workspace. { return fWKSize; }. IOptions * ExtraOptions() const; return extra options. { return fExtraOptions; }. void SetAbsTolerance(double tol); non-static methods for setting options ; set the abs tolerance. { fAbsTolerance = tol; }. void SetRelTolerance(double tol); set the relative tolerance. { fRelTolerance = tol; }. void SetWKSize(unsigned int size); set workspace size. { fWKSize = size; }. void SetExtraOptions(const ROOT::Math::IOptions& opt); set extra options (in this case pointer is cloned). void ClearExtra().  Author: L. Moneta Fri Aug 15 2008  Copyright (c) 2008 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: IntegratorOptions.h 36806 2010-11-20 11:09:14Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__BaseIntegratorOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BaseIntegratorOptions.html
https://root.cern/root/html532/ROOT__Math__BaseIntegratorOptions.html:1445,Modifiability,Inherit,Inheritance,1445,"y the user. @ingroup Integration. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~BaseIntegratorOptions(); doubleAbsTolerance() const; ROOT::Math::IOptions*ExtraOptions() const; virtual stringIntegrator() const; ROOT::Math::BaseIntegratorOptions&operator=(const ROOT::Math::BaseIntegratorOptions& opt); doubleRelTolerance() const; voidSetAbsTolerance(double tol); voidSetExtraOptions(const ROOT::Math::IOptions& opt); voidSetRelTolerance(double tol); voidSetWKSize(unsigned int size); unsigned intWKSize() const. protected:. voidClearExtra(). Data Members; protected:. doublefAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*fExtraOptionsextra options ; intfIntegTypeIntegrator type (value converted from enum); unsigned intfNCalls(max) funxtion calls; doublefRelTolerancerelative tolerance ; unsigned intfWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::BaseIntegratorOptions& opt); assignment operators. virtual ~BaseIntegratorOptions(); protected constructor to avoid user creating this class. { ClearExtra(); }. std::string Integrator() const; name of 1D integrator. double AbsTolerance() const; non-static methods for retrivieng options ; absolute tolerance. { return fAbsTolerance; }. double RelTolerance() const; absolute tolerance. { return fRelTolerance; }. unsigned int WKSize() const; size of the workspace. { return fWKSize; }. IOptions * ExtraOptions() const; return extra options. { return fExtraOptions; }. void SetAbsTolerance(double tol); non-static methods for setting options ; set the abs tolerance. { fAbsTolerance = tol; }. void SetRelTolerance(double tol); set the relative tolerance. { fRelTolerance = tol; }. void SetWKSize(unsigned int size); set workspace size. { fWKSize = size; }. void SetExtraOptions(const ROOT::Math::IOp",MatchSource.WIKI,root/html532/ROOT__Math__BaseIntegratorOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BaseIntegratorOptions.html
https://root.cern/root/html532/ROOT__Math__BaseIntegratorOptions.html:1458,Modifiability,Inherit,Inherited,1458,"y the user. @ingroup Integration. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~BaseIntegratorOptions(); doubleAbsTolerance() const; ROOT::Math::IOptions*ExtraOptions() const; virtual stringIntegrator() const; ROOT::Math::BaseIntegratorOptions&operator=(const ROOT::Math::BaseIntegratorOptions& opt); doubleRelTolerance() const; voidSetAbsTolerance(double tol); voidSetExtraOptions(const ROOT::Math::IOptions& opt); voidSetRelTolerance(double tol); voidSetWKSize(unsigned int size); unsigned intWKSize() const. protected:. voidClearExtra(). Data Members; protected:. doublefAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*fExtraOptionsextra options ; intfIntegTypeIntegrator type (value converted from enum); unsigned intfNCalls(max) funxtion calls; doublefRelTolerancerelative tolerance ; unsigned intfWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::BaseIntegratorOptions& opt); assignment operators. virtual ~BaseIntegratorOptions(); protected constructor to avoid user creating this class. { ClearExtra(); }. std::string Integrator() const; name of 1D integrator. double AbsTolerance() const; non-static methods for retrivieng options ; absolute tolerance. { return fAbsTolerance; }. double RelTolerance() const; absolute tolerance. { return fRelTolerance; }. unsigned int WKSize() const; size of the workspace. { return fWKSize; }. IOptions * ExtraOptions() const; return extra options. { return fExtraOptions; }. void SetAbsTolerance(double tol); non-static methods for setting options ; set the abs tolerance. { fAbsTolerance = tol; }. void SetRelTolerance(double tol); set the relative tolerance. { fRelTolerance = tol; }. void SetWKSize(unsigned int size); set workspace size. { fWKSize = size; }. void SetExtraOptions(const ROOT::Math::IOp",MatchSource.WIKI,root/html532/ROOT__Math__BaseIntegratorOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BaseIntegratorOptions.html
https://root.cern/root/html532/ROOT__Math__BaseIntegratorOptions.html:1684,Safety,avoid,avoid,1684,":. virtual~BaseIntegratorOptions(); doubleAbsTolerance() const; ROOT::Math::IOptions*ExtraOptions() const; virtual stringIntegrator() const; ROOT::Math::BaseIntegratorOptions&operator=(const ROOT::Math::BaseIntegratorOptions& opt); doubleRelTolerance() const; voidSetAbsTolerance(double tol); voidSetExtraOptions(const ROOT::Math::IOptions& opt); voidSetRelTolerance(double tol); voidSetWKSize(unsigned int size); unsigned intWKSize() const. protected:. voidClearExtra(). Data Members; protected:. doublefAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*fExtraOptionsextra options ; intfIntegTypeIntegrator type (value converted from enum); unsigned intfNCalls(max) funxtion calls; doublefRelTolerancerelative tolerance ; unsigned intfWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::BaseIntegratorOptions& opt); assignment operators. virtual ~BaseIntegratorOptions(); protected constructor to avoid user creating this class. { ClearExtra(); }. std::string Integrator() const; name of 1D integrator. double AbsTolerance() const; non-static methods for retrivieng options ; absolute tolerance. { return fAbsTolerance; }. double RelTolerance() const; absolute tolerance. { return fRelTolerance; }. unsigned int WKSize() const; size of the workspace. { return fWKSize; }. IOptions * ExtraOptions() const; return extra options. { return fExtraOptions; }. void SetAbsTolerance(double tol); non-static methods for setting options ; set the abs tolerance. { fAbsTolerance = tol; }. void SetRelTolerance(double tol); set the relative tolerance. { fRelTolerance = tol; }. void SetWKSize(unsigned int size); set workspace size. { fWKSize = size; }. void SetExtraOptions(const ROOT::Math::IOptions& opt); set extra options (in this case pointer is cloned). void ClearExtra().  Author: L. Moneta Fri Aug 15 2008  Copyright (c) 2008 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/ma",MatchSource.WIKI,root/html532/ROOT__Math__BaseIntegratorOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BaseIntegratorOptions.html
https://root.cern/root/html532/ROOT__Math__BaseIntegratorOptions.html:1718,Usability,Clear,ClearExtra,1718,") const; ROOT::Math::IOptions*ExtraOptions() const; virtual stringIntegrator() const; ROOT::Math::BaseIntegratorOptions&operator=(const ROOT::Math::BaseIntegratorOptions& opt); doubleRelTolerance() const; voidSetAbsTolerance(double tol); voidSetExtraOptions(const ROOT::Math::IOptions& opt); voidSetRelTolerance(double tol); voidSetWKSize(unsigned int size); unsigned intWKSize() const. protected:. voidClearExtra(). Data Members; protected:. doublefAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*fExtraOptionsextra options ; intfIntegTypeIntegrator type (value converted from enum); unsigned intfNCalls(max) funxtion calls; doublefRelTolerancerelative tolerance ; unsigned intfWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::BaseIntegratorOptions& opt); assignment operators. virtual ~BaseIntegratorOptions(); protected constructor to avoid user creating this class. { ClearExtra(); }. std::string Integrator() const; name of 1D integrator. double AbsTolerance() const; non-static methods for retrivieng options ; absolute tolerance. { return fAbsTolerance; }. double RelTolerance() const; absolute tolerance. { return fRelTolerance; }. unsigned int WKSize() const; size of the workspace. { return fWKSize; }. IOptions * ExtraOptions() const; return extra options. { return fExtraOptions; }. void SetAbsTolerance(double tol); non-static methods for setting options ; set the abs tolerance. { fAbsTolerance = tol; }. void SetRelTolerance(double tol); set the relative tolerance. { fRelTolerance = tol; }. void SetWKSize(unsigned int size); set workspace size. { fWKSize = size; }. void SetExtraOptions(const ROOT::Math::IOptions& opt); set extra options (in this case pointer is cloned). void ClearExtra().  Author: L. Moneta Fri Aug 15 2008  Copyright (c) 2008 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: IntegratorOptions.h 36806 2010-11-20 11:09:",MatchSource.WIKI,root/html532/ROOT__Math__BaseIntegratorOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BaseIntegratorOptions.html
https://root.cern/root/html532/ROOT__Math__BaseIntegratorOptions.html:2541,Usability,Clear,ClearExtra,2541,"voidSetAbsTolerance(double tol); voidSetExtraOptions(const ROOT::Math::IOptions& opt); voidSetRelTolerance(double tol); voidSetWKSize(unsigned int size); unsigned intWKSize() const. protected:. voidClearExtra(). Data Members; protected:. doublefAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*fExtraOptionsextra options ; intfIntegTypeIntegrator type (value converted from enum); unsigned intfNCalls(max) funxtion calls; doublefRelTolerancerelative tolerance ; unsigned intfWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::BaseIntegratorOptions& opt); assignment operators. virtual ~BaseIntegratorOptions(); protected constructor to avoid user creating this class. { ClearExtra(); }. std::string Integrator() const; name of 1D integrator. double AbsTolerance() const; non-static methods for retrivieng options ; absolute tolerance. { return fAbsTolerance; }. double RelTolerance() const; absolute tolerance. { return fRelTolerance; }. unsigned int WKSize() const; size of the workspace. { return fWKSize; }. IOptions * ExtraOptions() const; return extra options. { return fExtraOptions; }. void SetAbsTolerance(double tol); non-static methods for setting options ; set the abs tolerance. { fAbsTolerance = tol; }. void SetRelTolerance(double tol); set the relative tolerance. { fRelTolerance = tol; }. void SetWKSize(unsigned int size); set workspace size. { fWKSize = size; }. void SetExtraOptions(const ROOT::Math::IOptions& opt); set extra options (in this case pointer is cloned). void ClearExtra().  Author: L. Moneta Fri Aug 15 2008  Copyright (c) 2008 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: IntegratorOptions.h 36806 2010-11-20 11:09:14Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__BaseIntegratorOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BaseIntegratorOptions.html
https://root.cern/root/html532/ROOT__Math__BasicFitMethodFunction_-p1IBaseFunctionMultiDim_.html:1289,Availability,avail,available,1289,"  ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>. class ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>: public ROOT::Math::IBaseFunctionMultiDim. FitMethodFunction class; Interface for objective functions (like chi2 and likelihood used in the fit); In addition to normal function interface provide interface for calculating each; data contrinution to the function which is required by some algorithm (like Fumili). @ingroup FitMethodFunc. This class is also known as (typedefs to this class)ROOT::Fit::Chi2FCN<ROOT::Math::IBaseFunctionMultiDim>::BaseObjFunction, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::BaseObjFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::BaseObjFunction, ROOT::Math::BasicFitMethodFunction<ROOT::Math::IMultiGenFunction>, ROOT::Math::FitMethodFunction. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; virtual doubleDataElement(const double* x, unsigned int i, double* g = 0) const; virtual unsigned intNCalls() const; virtual unsigned intNDim() const; virtual unsigned intNPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>&operator=(const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>&); virtual voidResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::Type_tType() const; virtual voidUpdateNCalls() const. Data Members; public:. enum Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. unsigned intfNCallsnumber of function calls; unsigned intfNDimfunction dimension ; unsigned intfNPointssize of the data. C",MatchSource.WIKI,root/html532/ROOT__Math__BasicFitMethodFunction_-p1IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BasicFitMethodFunction_-p1IBaseFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Math__BasicFitMethodFunction_-p1IBaseFunctionMultiDim_.html:3076,Deployability,Update,UpdateNCalls,3076,"() const; virtual unsigned intNDim() const; virtual unsigned intNPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>&operator=(const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>&); virtual voidResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::Type_tType() const; virtual voidUpdateNCalls() const. Data Members; public:. enum Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. unsigned intfNCallsnumber of function calls; unsigned intfNDimfunction dimension ; unsigned intfNPointssize of the data. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; unsigned int NDim() const. Number of dimension (parameters) . From IGenMultiFunction interface. { return fNDim; }. double DataElement(const double* x, unsigned int i, double* g = 0) const. method returning the data i-th contribution to the fit objective function; For example the residual for the least square functions or the pdf element for the; likelihood functions.; Estimating eventually also the gradient of the data element if the passed pointer is not null. unsigned int NPoints() const. return the number of data points used in evaluating the function. { return fNPoints; }. unsigned int NCalls() const. return the total number of function calls (overrided if needed). { return fNCalls; }. void UpdateNCalls() const. update number of calls. { fNCalls++; }. void ResetNCalls(). reset number of function calls. { fNCalls = 0; }.  Author: L. Moneta Thu Aug 16 15:40:28 2007  Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: FitMethodFunction.h 40577 2011-08-12 10:43:12Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__BasicFitMethodFunction_-p1IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BasicFitMethodFunction_-p1IBaseFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Math__BasicFitMethodFunction_-p1IBaseFunctionMultiDim_.html:3098,Deployability,update,update,3098,"() const; virtual unsigned intNDim() const; virtual unsigned intNPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>&operator=(const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>&); virtual voidResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::Type_tType() const; virtual voidUpdateNCalls() const. Data Members; public:. enum Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. unsigned intfNCallsnumber of function calls; unsigned intfNDimfunction dimension ; unsigned intfNPointssize of the data. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; unsigned int NDim() const. Number of dimension (parameters) . From IGenMultiFunction interface. { return fNDim; }. double DataElement(const double* x, unsigned int i, double* g = 0) const. method returning the data i-th contribution to the fit objective function; For example the residual for the least square functions or the pdf element for the; likelihood functions.; Estimating eventually also the gradient of the data element if the passed pointer is not null. unsigned int NPoints() const. return the number of data points used in evaluating the function. { return fNPoints; }. unsigned int NCalls() const. return the total number of function calls (overrided if needed). { return fNCalls; }. void UpdateNCalls() const. update number of calls. { fNCalls++; }. void ResetNCalls(). reset number of function calls. { fNCalls = 0; }.  Author: L. Moneta Thu Aug 16 15:40:28 2007  Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: FitMethodFunction.h 40577 2011-08-12 10:43:12Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__BasicFitMethodFunction_-p1IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BasicFitMethodFunction_-p1IBaseFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Math__BasicFitMethodFunction_-p1IBaseFunctionMultiDim_.html:499,Integrability,Interface,Interface,499,". ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>. class ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>: public ROOT::Math::IBaseFunctionMultiDim. FitMethodFunction class; Interface for objective functions (like chi2 and likelihood used in the fit); In addition to normal function interface provide interface for calculating each; data contrinution to the function which is required by some algorithm (like Fumili). @ingroup FitMethodFunc. This class is also known as (typedefs to this class)ROOT::Fit::Chi2FCN<ROOT::Math::IBaseFunctionMultiDim>::BaseObjFunction, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::BaseObjFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::BaseObjFunction, ROOT::Math::BasicFitMethodFunction<ROOT::Math::IMultiGenFunction>, ROOT::Math::FitMethodFunction. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; virtual doubleDataElement(const double* x, unsigned int i, double* g = 0) const; virtual unsigned intNCalls() const; virtual unsigned intNDim() const; virtual unsigned intNPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>&operator=(const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>&); virtual voidResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctio",MatchSource.WIKI,root/html532/ROOT__Math__BasicFitMethodFunction_-p1IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BasicFitMethodFunction_-p1IBaseFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Math__BasicFitMethodFunction_-p1IBaseFunctionMultiDim_.html:608,Integrability,interface,interface,608,". ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>. class ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>: public ROOT::Math::IBaseFunctionMultiDim. FitMethodFunction class; Interface for objective functions (like chi2 and likelihood used in the fit); In addition to normal function interface provide interface for calculating each; data contrinution to the function which is required by some algorithm (like Fumili). @ingroup FitMethodFunc. This class is also known as (typedefs to this class)ROOT::Fit::Chi2FCN<ROOT::Math::IBaseFunctionMultiDim>::BaseObjFunction, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::BaseObjFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::BaseObjFunction, ROOT::Math::BasicFitMethodFunction<ROOT::Math::IMultiGenFunction>, ROOT::Math::FitMethodFunction. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; virtual doubleDataElement(const double* x, unsigned int i, double* g = 0) const; virtual unsigned intNCalls() const; virtual unsigned intNDim() const; virtual unsigned intNPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>&operator=(const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>&); virtual voidResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctio",MatchSource.WIKI,root/html532/ROOT__Math__BasicFitMethodFunction_-p1IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BasicFitMethodFunction_-p1IBaseFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Math__BasicFitMethodFunction_-p1IBaseFunctionMultiDim_.html:626,Integrability,interface,interface,626,". ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>. class ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>: public ROOT::Math::IBaseFunctionMultiDim. FitMethodFunction class; Interface for objective functions (like chi2 and likelihood used in the fit); In addition to normal function interface provide interface for calculating each; data contrinution to the function which is required by some algorithm (like Fumili). @ingroup FitMethodFunc. This class is also known as (typedefs to this class)ROOT::Fit::Chi2FCN<ROOT::Math::IBaseFunctionMultiDim>::BaseObjFunction, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::BaseObjFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::BaseObjFunction, ROOT::Math::BasicFitMethodFunction<ROOT::Math::IMultiGenFunction>, ROOT::Math::FitMethodFunction. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; virtual doubleDataElement(const double* x, unsigned int i, double* g = 0) const; virtual unsigned intNCalls() const; virtual unsigned intNDim() const; virtual unsigned intNPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>&operator=(const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>&); virtual voidResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctio",MatchSource.WIKI,root/html532/ROOT__Math__BasicFitMethodFunction_-p1IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BasicFitMethodFunction_-p1IBaseFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Math__BasicFitMethodFunction_-p1IBaseFunctionMultiDim_.html:2457,Integrability,interface,interface,2457,"eFunctionMultiDim::Clone() const; virtual doubleDataElement(const double* x, unsigned int i, double* g = 0) const; virtual unsigned intNCalls() const; virtual unsigned intNDim() const; virtual unsigned intNPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>&operator=(const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>&); virtual voidResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::Type_tType() const; virtual voidUpdateNCalls() const. Data Members; public:. enum Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. unsigned intfNCallsnumber of function calls; unsigned intfNDimfunction dimension ; unsigned intfNPointssize of the data. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; unsigned int NDim() const. Number of dimension (parameters) . From IGenMultiFunction interface. { return fNDim; }. double DataElement(const double* x, unsigned int i, double* g = 0) const. method returning the data i-th contribution to the fit objective function; For example the residual for the least square functions or the pdf element for the; likelihood functions.; Estimating eventually also the gradient of the data element if the passed pointer is not null. unsigned int NPoints() const. return the number of data points used in evaluating the function. { return fNPoints; }. unsigned int NCalls() const. return the total number of function calls (overrided if needed). { return fNCalls; }. void UpdateNCalls() const. update number of calls. { fNCalls++; }. void ResetNCalls(). reset number of function calls. { fNCalls = 0; }.  Author: L. Moneta Thu Aug 16 15:40:28 2007  Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: FitMethodFunction.h 40577 2011-08-12 10:43:12Z moneta $  Last generated: 2011-11-03 20:04; This page has ",MatchSource.WIKI,root/html532/ROOT__Math__BasicFitMethodFunction_-p1IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BasicFitMethodFunction_-p1IBaseFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Math__BasicFitMethodFunction_-p1IBaseFunctionMultiDim_.html:2295,Modifiability,Inherit,Inheritance,2295,":. virtual~BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; virtual doubleDataElement(const double* x, unsigned int i, double* g = 0) const; virtual unsigned intNCalls() const; virtual unsigned intNDim() const; virtual unsigned intNPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>&operator=(const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>&); virtual voidResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::Type_tType() const; virtual voidUpdateNCalls() const. Data Members; public:. enum Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. unsigned intfNCallsnumber of function calls; unsigned intfNDimfunction dimension ; unsigned intfNPointssize of the data. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; unsigned int NDim() const. Number of dimension (parameters) . From IGenMultiFunction interface. { return fNDim; }. double DataElement(const double* x, unsigned int i, double* g = 0) const. method returning the data i-th contribution to the fit objective function; For example the residual for the least square functions or the pdf element for the; likelihood functions.; Estimating eventually also the gradient of the data element if the passed pointer is not null. unsigned int NPoints() const. return the number of data points used in evaluating the function. { return fNPoints; }. unsigned int NCalls() const. return the total number of function calls (overrided if needed). { return fNCalls; }. void UpdateNCalls() const. update number of calls. { fNCalls++; }. void ResetNCalls(). reset number of function calls. { fNCalls = 0; }.  Author: L. Moneta Thu Aug 16 15:40:28 2007  Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *;  Last chang",MatchSource.WIKI,root/html532/ROOT__Math__BasicFitMethodFunction_-p1IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BasicFitMethodFunction_-p1IBaseFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Math__BasicFitMethodFunction_-p1IBaseFunctionMultiDim_.html:2308,Modifiability,Inherit,Inherited,2308,":. virtual~BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; virtual doubleDataElement(const double* x, unsigned int i, double* g = 0) const; virtual unsigned intNCalls() const; virtual unsigned intNDim() const; virtual unsigned intNPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>&operator=(const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>&); virtual voidResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::Type_tType() const; virtual voidUpdateNCalls() const. Data Members; public:. enum Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. unsigned intfNCallsnumber of function calls; unsigned intfNDimfunction dimension ; unsigned intfNPointssize of the data. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; unsigned int NDim() const. Number of dimension (parameters) . From IGenMultiFunction interface. { return fNDim; }. double DataElement(const double* x, unsigned int i, double* g = 0) const. method returning the data i-th contribution to the fit objective function; For example the residual for the least square functions or the pdf element for the; likelihood functions.; Estimating eventually also the gradient of the data element if the passed pointer is not null. unsigned int NPoints() const. return the number of data points used in evaluating the function. { return fNPoints; }. unsigned int NCalls() const. return the total number of function calls (overrided if needed). { return fNCalls; }. void UpdateNCalls() const. update number of calls. { fNCalls++; }. void ResetNCalls(). reset number of function calls. { fNCalls = 0; }.  Author: L. Moneta Thu Aug 16 15:40:28 2007  Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *;  Last chang",MatchSource.WIKI,root/html532/ROOT__Math__BasicFitMethodFunction_-p1IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BasicFitMethodFunction_-p1IBaseFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Math__BasicFitMethodFunction_-p1IBaseFunctionMultiDim_.html:987,Testability,Log,LogLikelihoodFCN,987,". ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>. class ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>: public ROOT::Math::IBaseFunctionMultiDim. FitMethodFunction class; Interface for objective functions (like chi2 and likelihood used in the fit); In addition to normal function interface provide interface for calculating each; data contrinution to the function which is required by some algorithm (like Fumili). @ingroup FitMethodFunc. This class is also known as (typedefs to this class)ROOT::Fit::Chi2FCN<ROOT::Math::IBaseFunctionMultiDim>::BaseObjFunction, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::BaseObjFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::BaseObjFunction, ROOT::Math::BasicFitMethodFunction<ROOT::Math::IMultiGenFunction>, ROOT::Math::FitMethodFunction. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; virtual doubleDataElement(const double* x, unsigned int i, double* g = 0) const; virtual unsigned intNCalls() const; virtual unsigned intNDim() const; virtual unsigned intNPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>&operator=(const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>&); virtual voidResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctio",MatchSource.WIKI,root/html532/ROOT__Math__BasicFitMethodFunction_-p1IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BasicFitMethodFunction_-p1IBaseFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Math__BasicFitMethodFunction_-p1IGradientFunctionMultiDim_.html:1322,Availability,avail,available,1322,"Function<ROOT::Math::IGradientFunctionMultiDim>. class ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>: public ROOT::Math::IGradientFunctionMultiDim. FitMethodFunction class; Interface for objective functions (like chi2 and likelihood used in the fit); In addition to normal function interface provide interface for calculating each; data contrinution to the function which is required by some algorithm (like Fumili). @ingroup FitMethodFunc. This class is also known as (typedefs to this class)ROOT::Math::FitMethodGradFunction, ROOT::Math::BasicFitMethodFunction<ROOT::Math::IMultiGradFunction>, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::BaseObjFunction, ROOT::Fit::Chi2FCN<ROOT::Math::IGradientFunctionMultiDim>::BaseObjFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::BaseObjFunction. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; virtual doubleDataElement(const double* x, unsigned int i, double* g = 0) const; doubleROOT::Math::IGradientMultiDim::Derivative(const double* x, unsigned int icoord = 0) const; virtual voidROOT::Math::IGradientFunctionMultiDim::FdF(const double* x, double& f, double* df) const; virtual voidROOT::Math::IGradientFunctionMultiDim::Gradient(const double* x, double* grad) const; virtual unsigned intNCalls() const; virtual unsigned intNDim() const; virtual unsigned intNPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>&operator=(const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>&); virtual voidResetNCalls(); virtual ROOT::Math::BasicFitMethodFunct",MatchSource.WIKI,root/html532/ROOT__Math__BasicFitMethodFunction_-p1IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BasicFitMethodFunction_-p1IGradientFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Math__BasicFitMethodFunction_-p1IGradientFunctionMultiDim_.html:3422,Deployability,Update,UpdateNCalls,3422,"rtual unsigned intNDim() const; virtual unsigned intNPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>&operator=(const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>&); virtual voidResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::Type_tType() const; virtual voidUpdateNCalls() const. Data Members; public:. enum Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. unsigned intfNCallsnumber of function calls; unsigned intfNDimfunction dimension ; unsigned intfNPointssize of the data. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; unsigned int NDim() const. Number of dimension (parameters) . From IGenMultiFunction interface. { return fNDim; }. double DataElement(const double* x, unsigned int i, double* g = 0) const. method returning the data i-th contribution to the fit objective function; For example the residual for the least square functions or the pdf element for the; likelihood functions.; Estimating eventually also the gradient of the data element if the passed pointer is not null. unsigned int NPoints() const. return the number of data points used in evaluating the function. { return fNPoints; }. unsigned int NCalls() const. return the total number of function calls (overrided if needed). { return fNCalls; }. void UpdateNCalls() const. update number of calls. { fNCalls++; }. void ResetNCalls(). reset number of function calls. { fNCalls = 0; }.  Author: L. Moneta Thu Aug 16 15:40:28 2007  Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: FitMethodFunction.h 40577 2011-08-12 10:43:12Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__BasicFitMethodFunction_-p1IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BasicFitMethodFunction_-p1IGradientFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Math__BasicFitMethodFunction_-p1IGradientFunctionMultiDim_.html:3444,Deployability,update,update,3444,"rtual unsigned intNDim() const; virtual unsigned intNPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>&operator=(const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>&); virtual voidResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::Type_tType() const; virtual voidUpdateNCalls() const. Data Members; public:. enum Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. unsigned intfNCallsnumber of function calls; unsigned intfNDimfunction dimension ; unsigned intfNPointssize of the data. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; unsigned int NDim() const. Number of dimension (parameters) . From IGenMultiFunction interface. { return fNDim; }. double DataElement(const double* x, unsigned int i, double* g = 0) const. method returning the data i-th contribution to the fit objective function; For example the residual for the least square functions or the pdf element for the; likelihood functions.; Estimating eventually also the gradient of the data element if the passed pointer is not null. unsigned int NPoints() const. return the number of data points used in evaluating the function. { return fNPoints; }. unsigned int NCalls() const. return the total number of function calls (overrided if needed). { return fNCalls; }. void UpdateNCalls() const. update number of calls. { fNCalls++; }. void ResetNCalls(). reset number of function calls. { fNCalls = 0; }.  Author: L. Moneta Thu Aug 16 15:40:28 2007  Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: FitMethodFunction.h 40577 2011-08-12 10:43:12Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__BasicFitMethodFunction_-p1IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BasicFitMethodFunction_-p1IGradientFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Math__BasicFitMethodFunction_-p1IGradientFunctionMultiDim_.html:515,Integrability,Interface,Interface,515,". ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>. class ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>: public ROOT::Math::IGradientFunctionMultiDim. FitMethodFunction class; Interface for objective functions (like chi2 and likelihood used in the fit); In addition to normal function interface provide interface for calculating each; data contrinution to the function which is required by some algorithm (like Fumili). @ingroup FitMethodFunc. This class is also known as (typedefs to this class)ROOT::Math::FitMethodGradFunction, ROOT::Math::BasicFitMethodFunction<ROOT::Math::IMultiGradFunction>, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::BaseObjFunction, ROOT::Fit::Chi2FCN<ROOT::Math::IGradientFunctionMultiDim>::BaseObjFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::BaseObjFunction. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; virtual doubleDataElement(const double* x, unsigned int i, double* g = 0) const; doubleROOT::Math::IGradientMultiDim::Derivative(const double* x, unsigned int icoord = 0) const; virtual voidROOT::Math::IGradientFunctionMultiDim::FdF(const double* x, double& f, double* df) const; virtual voidROOT::Math::IGradientFunctionMultiDim::Gradient(const double* x, double* grad) const; virtual unsigned intNCalls() const; virtual unsigned intNDim() const; virtual unsigned intNPoints() co",MatchSource.WIKI,root/html532/ROOT__Math__BasicFitMethodFunction_-p1IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BasicFitMethodFunction_-p1IGradientFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Math__BasicFitMethodFunction_-p1IGradientFunctionMultiDim_.html:624,Integrability,interface,interface,624,". ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>. class ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>: public ROOT::Math::IGradientFunctionMultiDim. FitMethodFunction class; Interface for objective functions (like chi2 and likelihood used in the fit); In addition to normal function interface provide interface for calculating each; data contrinution to the function which is required by some algorithm (like Fumili). @ingroup FitMethodFunc. This class is also known as (typedefs to this class)ROOT::Math::FitMethodGradFunction, ROOT::Math::BasicFitMethodFunction<ROOT::Math::IMultiGradFunction>, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::BaseObjFunction, ROOT::Fit::Chi2FCN<ROOT::Math::IGradientFunctionMultiDim>::BaseObjFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::BaseObjFunction. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; virtual doubleDataElement(const double* x, unsigned int i, double* g = 0) const; doubleROOT::Math::IGradientMultiDim::Derivative(const double* x, unsigned int icoord = 0) const; virtual voidROOT::Math::IGradientFunctionMultiDim::FdF(const double* x, double& f, double* df) const; virtual voidROOT::Math::IGradientFunctionMultiDim::Gradient(const double* x, double* grad) const; virtual unsigned intNCalls() const; virtual unsigned intNDim() const; virtual unsigned intNPoints() co",MatchSource.WIKI,root/html532/ROOT__Math__BasicFitMethodFunction_-p1IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BasicFitMethodFunction_-p1IGradientFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Math__BasicFitMethodFunction_-p1IGradientFunctionMultiDim_.html:642,Integrability,interface,interface,642,". ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>. class ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>: public ROOT::Math::IGradientFunctionMultiDim. FitMethodFunction class; Interface for objective functions (like chi2 and likelihood used in the fit); In addition to normal function interface provide interface for calculating each; data contrinution to the function which is required by some algorithm (like Fumili). @ingroup FitMethodFunc. This class is also known as (typedefs to this class)ROOT::Math::FitMethodGradFunction, ROOT::Math::BasicFitMethodFunction<ROOT::Math::IMultiGradFunction>, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::BaseObjFunction, ROOT::Fit::Chi2FCN<ROOT::Math::IGradientFunctionMultiDim>::BaseObjFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::BaseObjFunction. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; virtual doubleDataElement(const double* x, unsigned int i, double* g = 0) const; doubleROOT::Math::IGradientMultiDim::Derivative(const double* x, unsigned int icoord = 0) const; virtual voidROOT::Math::IGradientFunctionMultiDim::FdF(const double* x, double& f, double* df) const; virtual voidROOT::Math::IGradientFunctionMultiDim::Gradient(const double* x, double* grad) const; virtual unsigned intNCalls() const; virtual unsigned intNDim() const; virtual unsigned intNPoints() co",MatchSource.WIKI,root/html532/ROOT__Math__BasicFitMethodFunction_-p1IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BasicFitMethodFunction_-p1IGradientFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Math__BasicFitMethodFunction_-p1IGradientFunctionMultiDim_.html:2803,Integrability,interface,interface,2803,"nst; virtual voidROOT::Math::IGradientFunctionMultiDim::Gradient(const double* x, double* grad) const; virtual unsigned intNCalls() const; virtual unsigned intNDim() const; virtual unsigned intNPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>&operator=(const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>&); virtual voidResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::Type_tType() const; virtual voidUpdateNCalls() const. Data Members; public:. enum Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. unsigned intfNCallsnumber of function calls; unsigned intfNDimfunction dimension ; unsigned intfNPointssize of the data. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; unsigned int NDim() const. Number of dimension (parameters) . From IGenMultiFunction interface. { return fNDim; }. double DataElement(const double* x, unsigned int i, double* g = 0) const. method returning the data i-th contribution to the fit objective function; For example the residual for the least square functions or the pdf element for the; likelihood functions.; Estimating eventually also the gradient of the data element if the passed pointer is not null. unsigned int NPoints() const. return the number of data points used in evaluating the function. { return fNPoints; }. unsigned int NCalls() const. return the total number of function calls (overrided if needed). { return fNCalls; }. void UpdateNCalls() const. update number of calls. { fNCalls++; }. void ResetNCalls(). reset number of function calls. { fNCalls = 0; }.  Author: L. Moneta Thu Aug 16 15:40:28 2007  Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: FitMethodFunction.h 40577 2011-08-12 10:43:12Z moneta $  Last generated: 2011-11-03 20:04; This page has ",MatchSource.WIKI,root/html532/ROOT__Math__BasicFitMethodFunction_-p1IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BasicFitMethodFunction_-p1IGradientFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Math__BasicFitMethodFunction_-p1IGradientFunctionMultiDim_.html:2641,Modifiability,Inherit,Inheritance,2641," unsigned int icoord = 0) const; virtual voidROOT::Math::IGradientFunctionMultiDim::FdF(const double* x, double& f, double* df) const; virtual voidROOT::Math::IGradientFunctionMultiDim::Gradient(const double* x, double* grad) const; virtual unsigned intNCalls() const; virtual unsigned intNDim() const; virtual unsigned intNPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>&operator=(const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>&); virtual voidResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::Type_tType() const; virtual voidUpdateNCalls() const. Data Members; public:. enum Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. unsigned intfNCallsnumber of function calls; unsigned intfNDimfunction dimension ; unsigned intfNPointssize of the data. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; unsigned int NDim() const. Number of dimension (parameters) . From IGenMultiFunction interface. { return fNDim; }. double DataElement(const double* x, unsigned int i, double* g = 0) const. method returning the data i-th contribution to the fit objective function; For example the residual for the least square functions or the pdf element for the; likelihood functions.; Estimating eventually also the gradient of the data element if the passed pointer is not null. unsigned int NPoints() const. return the number of data points used in evaluating the function. { return fNPoints; }. unsigned int NCalls() const. return the total number of function calls (overrided if needed). { return fNCalls; }. void UpdateNCalls() const. update number of calls. { fNCalls++; }. void ResetNCalls(). reset number of function calls. { fNCalls = 0; }.  Author: L. Moneta Thu Aug 16 15:40:28 2007  Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *;  Last chang",MatchSource.WIKI,root/html532/ROOT__Math__BasicFitMethodFunction_-p1IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BasicFitMethodFunction_-p1IGradientFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Math__BasicFitMethodFunction_-p1IGradientFunctionMultiDim_.html:2654,Modifiability,Inherit,Inherited,2654," unsigned int icoord = 0) const; virtual voidROOT::Math::IGradientFunctionMultiDim::FdF(const double* x, double& f, double* df) const; virtual voidROOT::Math::IGradientFunctionMultiDim::Gradient(const double* x, double* grad) const; virtual unsigned intNCalls() const; virtual unsigned intNDim() const; virtual unsigned intNPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>&operator=(const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>&); virtual voidResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::Type_tType() const; virtual voidUpdateNCalls() const. Data Members; public:. enum Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. unsigned intfNCallsnumber of function calls; unsigned intfNDimfunction dimension ; unsigned intfNPointssize of the data. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; unsigned int NDim() const. Number of dimension (parameters) . From IGenMultiFunction interface. { return fNDim; }. double DataElement(const double* x, unsigned int i, double* g = 0) const. method returning the data i-th contribution to the fit objective function; For example the residual for the least square functions or the pdf element for the; likelihood functions.; Estimating eventually also the gradient of the data element if the passed pointer is not null. unsigned int NPoints() const. return the number of data points used in evaluating the function. { return fNPoints; }. unsigned int NCalls() const. return the total number of function calls (overrided if needed). { return fNCalls; }. void UpdateNCalls() const. update number of calls. { fNCalls++; }. void ResetNCalls(). reset number of function calls. { fNCalls = 0; }.  Author: L. Moneta Thu Aug 16 15:40:28 2007  Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *;  Last chang",MatchSource.WIKI,root/html532/ROOT__Math__BasicFitMethodFunction_-p1IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BasicFitMethodFunction_-p1IGradientFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Math__BasicFitMethodFunction_-p1IGradientFunctionMultiDim_.html:1114,Testability,Log,LogLikelihoodFCN,1114,". ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>. class ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>: public ROOT::Math::IGradientFunctionMultiDim. FitMethodFunction class; Interface for objective functions (like chi2 and likelihood used in the fit); In addition to normal function interface provide interface for calculating each; data contrinution to the function which is required by some algorithm (like Fumili). @ingroup FitMethodFunc. This class is also known as (typedefs to this class)ROOT::Math::FitMethodGradFunction, ROOT::Math::BasicFitMethodFunction<ROOT::Math::IMultiGradFunction>, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::BaseObjFunction, ROOT::Fit::Chi2FCN<ROOT::Math::IGradientFunctionMultiDim>::BaseObjFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::BaseObjFunction. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; virtual doubleDataElement(const double* x, unsigned int i, double* g = 0) const; doubleROOT::Math::IGradientMultiDim::Derivative(const double* x, unsigned int icoord = 0) const; virtual voidROOT::Math::IGradientFunctionMultiDim::FdF(const double* x, double& f, double* df) const; virtual voidROOT::Math::IGradientFunctionMultiDim::Gradient(const double* x, double* grad) const; virtual unsigned intNCalls() const; virtual unsigned intNDim() const; virtual unsigned intNPoints() co",MatchSource.WIKI,root/html532/ROOT__Math__BasicFitMethodFunction_-p1IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BasicFitMethodFunction_-p1IGradientFunctionMultiDim_.html
https://root.cern/root/html532/ROOT__Math__Boost.html:2687,Modifiability,Inherit,Inheritance,2687,"OOT::Math::PxPyPzE4D<double> >& v) const; ROOT::Math::Boost&operator=(ROOT::Math::Boost const& rhs); ROOT::Math::Boost&operator=(ROOT::Math::BoostX const& bx); ROOT::Math::Boost&operator=(ROOT::Math::BoostY const& by); ROOT::Math::Boost&operator=(ROOT::Math::BoostZ const& bz); booloperator==(const ROOT::Math::Boost& rhs) const; voidRectify(); voidSetComponents(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& beta); voidSetComponents(double* begin, double* end); voidSetComponents(ROOT::Math::Boost::Scalar beta_x, ROOT::Math::Boost::Scalar beta_y, ROOT::Math::Boost::Scalar beta_z). protected:. voidSetIdentity(). Data Members; public:. enum ELorentzRotationMatrixIndex { kLXX; kLXY; kLXZ; kLXT; kLYX; kLYY; kLYZ; kLYT; kLZX; kLZY; kLZZ; kLZT; kLTX; kLTY; kLTZ; kLTT; };; enum EBoostMatrixIndex { kXX; kXY; kXZ; kXT; kYY; kYZ; kYT; kZZ; kZT; kTT; };. private:. ROOT::Math::Boost::ScalarfM[10]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Boost(); ========== Constructors and Assignment =====================. Default constructor (identity transformation). { SetIdentity(); }. Boost(ROOT::Math::Boost::Scalar beta_x, ROOT::Math::Boost::Scalar beta_y, ROOT::Math::Boost::Scalar beta_z). Construct given a three Scalars beta_x, beta_y, and beta_z. { SetComponents(beta_x, beta_y, beta_z); }. Boost(const Avector & beta). Construct given a beta vector (which must have methods x(), y(), z()). { SetComponents(beta); }. Boost(double* begin, double* end). Construct given a pair of pointers or iterators defining the; beginning and end of an array of three Scalars to use as beta_x, _y, and _z. { SetComponents(begin,end); }. Boost(Boost const & b). copy constructor. explicit Boost( BoostX const & bx ). Construct from an axial boost. {SetComponents(bx.BetaVector());}. explicit Boost( BoostY const & by ); {SetComponents(by.BetaVector());}. operator=(Boost const & rhs ); The compiler-genera",MatchSource.WIKI,root/html532/ROOT__Math__Boost.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Boost.html
https://root.cern/root/html532/ROOT__Math__Boost.html:2700,Modifiability,Inherit,Inherited,2700,"OOT::Math::PxPyPzE4D<double> >& v) const; ROOT::Math::Boost&operator=(ROOT::Math::Boost const& rhs); ROOT::Math::Boost&operator=(ROOT::Math::BoostX const& bx); ROOT::Math::Boost&operator=(ROOT::Math::BoostY const& by); ROOT::Math::Boost&operator=(ROOT::Math::BoostZ const& bz); booloperator==(const ROOT::Math::Boost& rhs) const; voidRectify(); voidSetComponents(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& beta); voidSetComponents(double* begin, double* end); voidSetComponents(ROOT::Math::Boost::Scalar beta_x, ROOT::Math::Boost::Scalar beta_y, ROOT::Math::Boost::Scalar beta_z). protected:. voidSetIdentity(). Data Members; public:. enum ELorentzRotationMatrixIndex { kLXX; kLXY; kLXZ; kLXT; kLYX; kLYY; kLYZ; kLYT; kLZX; kLZY; kLZZ; kLZT; kLTX; kLTY; kLTZ; kLTT; };; enum EBoostMatrixIndex { kXX; kXY; kXZ; kXT; kYY; kYZ; kYT; kZZ; kZT; kTT; };. private:. ROOT::Math::Boost::ScalarfM[10]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Boost(); ========== Constructors and Assignment =====================. Default constructor (identity transformation). { SetIdentity(); }. Boost(ROOT::Math::Boost::Scalar beta_x, ROOT::Math::Boost::Scalar beta_y, ROOT::Math::Boost::Scalar beta_z). Construct given a three Scalars beta_x, beta_y, and beta_z. { SetComponents(beta_x, beta_y, beta_z); }. Boost(const Avector & beta). Construct given a beta vector (which must have methods x(), y(), z()). { SetComponents(beta); }. Boost(double* begin, double* end). Construct given a pair of pointers or iterators defining the; beginning and end of an array of three Scalars to use as beta_x, _y, and _z. { SetComponents(begin,end); }. Boost(Boost const & b). copy constructor. explicit Boost( BoostX const & bx ). Construct from an axial boost. {SetComponents(bx.BetaVector());}. explicit Boost( BoostY const & by ); {SetComponents(by.BetaVector());}. operator=(Boost const & rhs ); The compiler-genera",MatchSource.WIKI,root/html532/ROOT__Math__Boost.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Boost.html
https://root.cern/root/html532/ROOT__Math__BoostX.html:1807,Modifiability,Inherit,Inheritance,1807,"* r) const; ROOT::Math::BoostXInverse() const; voidInvert(); booloperator!=(const ROOT::Math::BoostX& rhs) const; ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >operator()(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >& v) const; ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >operator*(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >& v) const; ROOT::Math::BoostX&operator=(const ROOT::Math::BoostX&); booloperator==(const ROOT::Math::BoostX& rhs) const; voidRectify(); voidSetBeta(ROOT::Math::BoostX::Scalar beta); voidSetComponents(ROOT::Math::BoostX::Scalar beta_x). Data Members; public:. enum ELorentzRotationMatrixIndex { kLXX; kLXY; kLXZ; kLXT; kLYX; kLYY; kLYZ; kLYT; kLZX; kLZY; kLZZ; kLZT; kLTX; kLTY; kLTZ; kLTT; };; enum EBoostMatrixIndex { kXX; kXY; kXZ; kXT; kYY; kYZ; kYT; kZZ; kZT; kTT; };. private:. ROOT::Math::BoostX::ScalarfBetaboost beta X; ROOT::Math::BoostX::ScalarfGammaboost gamma. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BoostX(); ========== Constructors and Assignment =====================. Default constructor (identity transformation). explicit BoostX(Scalar beta_x). Construct given a Scalar beta_x. { SetComponents(beta_x); }. void Rectify(); The compiler-generated copy ctor, copy assignment, and dtor are OK. Re-adjust components to eliminate small deviations from a perfect; orthosyplectic matrix. SetComponents(ROOT::Math::BoostX::Scalar beta_x); ======== Components ==============. Set components from a Scalar beta_x. GetComponents(ROOT::Math::BoostX::Scalar& beta_x) const. Get components into a Scalar beta_x. Scalar Beta() const. Retrieve the beta of the Boost. { return fBeta; }. Scalar Gamma() const. Retrieve the gamma of the Boost. { return fGamma; }. void SetBeta(ROOT::Math::BoostX::Scalar beta). Set the given beta of the Boost. { SetComponents(beta); }. XYZVector BetaVector() const. GetLorentzRotation(ROOT::Math::BoostX::Scalar* r) const. Get el",MatchSource.WIKI,root/html532/ROOT__Math__BoostX.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BoostX.html
https://root.cern/root/html532/ROOT__Math__BoostX.html:1820,Modifiability,Inherit,Inherited,1820,"* r) const; ROOT::Math::BoostXInverse() const; voidInvert(); booloperator!=(const ROOT::Math::BoostX& rhs) const; ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >operator()(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >& v) const; ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >operator*(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >& v) const; ROOT::Math::BoostX&operator=(const ROOT::Math::BoostX&); booloperator==(const ROOT::Math::BoostX& rhs) const; voidRectify(); voidSetBeta(ROOT::Math::BoostX::Scalar beta); voidSetComponents(ROOT::Math::BoostX::Scalar beta_x). Data Members; public:. enum ELorentzRotationMatrixIndex { kLXX; kLXY; kLXZ; kLXT; kLYX; kLYY; kLYZ; kLYT; kLZX; kLZY; kLZZ; kLZT; kLTX; kLTY; kLTZ; kLTT; };; enum EBoostMatrixIndex { kXX; kXY; kXZ; kXT; kYY; kYZ; kYT; kZZ; kZT; kTT; };. private:. ROOT::Math::BoostX::ScalarfBetaboost beta X; ROOT::Math::BoostX::ScalarfGammaboost gamma. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BoostX(); ========== Constructors and Assignment =====================. Default constructor (identity transformation). explicit BoostX(Scalar beta_x). Construct given a Scalar beta_x. { SetComponents(beta_x); }. void Rectify(); The compiler-generated copy ctor, copy assignment, and dtor are OK. Re-adjust components to eliminate small deviations from a perfect; orthosyplectic matrix. SetComponents(ROOT::Math::BoostX::Scalar beta_x); ======== Components ==============. Set components from a Scalar beta_x. GetComponents(ROOT::Math::BoostX::Scalar& beta_x) const. Get components into a Scalar beta_x. Scalar Beta() const. Retrieve the beta of the Boost. { return fBeta; }. Scalar Gamma() const. Retrieve the gamma of the Boost. { return fGamma; }. void SetBeta(ROOT::Math::BoostX::Scalar beta). Set the given beta of the Boost. { SetComponents(beta); }. XYZVector BetaVector() const. GetLorentzRotation(ROOT::Math::BoostX::Scalar* r) const. Get el",MatchSource.WIKI,root/html532/ROOT__Math__BoostX.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BoostX.html
https://root.cern/root/html532/ROOT__Math__BoostY.html:1822,Modifiability,Inherit,Inheritance,1822,"T::Math::BoostYInverse() const; voidInvert(); booloperator!=(const ROOT::Math::BoostY& rhs) const; ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >operator()(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >& v) const; ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >operator*(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >& v) const; ROOT::Math::BoostY&operator=(const ROOT::Math::BoostY&); booloperator==(const ROOT::Math::BoostY& rhs) const; voidRectify(); voidSetBeta(ROOT::Math::BoostY::Scalar beta); voidSetComponents(ROOT::Math::BoostY::Scalar beta_y). Data Members; public:. enum ELorentzRotationMatrixIndex { kLXX; kLXY; kLXZ; kLXT; kLYX; kLYY; kLYZ; kLYT; kLZX; kLZY; kLZZ; kLZT; kLTX; kLTY; kLTZ; kLTT; };; enum EBoostMatrixIndex { kXX; kXY; kXZ; kXT; kYY; kYZ; kYT; kZZ; kZT; kTT; };. private:. ROOT::Math::BoostY::ScalarfBetabeta Y of the Boost; ROOT::Math::BoostY::ScalarfGammagamma of the Boost . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BoostY(); ========== Constructors and Assignment =====================. Default constructor (identity transformation). explicit BoostY(Scalar beta_y). Construct given a Scalar beta_y. { SetComponents(beta_y); }. void Rectify(); The compiler-generated copy ctor, copy assignment, and dtor are OK. Re-adjust components to eliminate small deviations from a perfect; orthosyplectic matrix. SetComponents(ROOT::Math::BoostY::Scalar beta_y); ======== Components ==============. Set components from a Scalar beta_y. GetComponents(ROOT::Math::BoostY::Scalar& beta_y) const. Get components into a Scalar beta_y. Scalar Beta() const. Retrieve the beta of the Boost. { return fBeta; }. Scalar Gamma() const. Retrieve the gamma of the Boost. { return fGamma; }. void SetBeta(ROOT::Math::BoostY::Scalar beta). Set the given beta of the Boost. { SetComponents(beta); }. XYZVector BetaVector() const. GetLorentzRotation(ROOT::Math::BoostY::Scalar* r) const. Get el",MatchSource.WIKI,root/html532/ROOT__Math__BoostY.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BoostY.html
https://root.cern/root/html532/ROOT__Math__BoostY.html:1835,Modifiability,Inherit,Inherited,1835,"T::Math::BoostYInverse() const; voidInvert(); booloperator!=(const ROOT::Math::BoostY& rhs) const; ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >operator()(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >& v) const; ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >operator*(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >& v) const; ROOT::Math::BoostY&operator=(const ROOT::Math::BoostY&); booloperator==(const ROOT::Math::BoostY& rhs) const; voidRectify(); voidSetBeta(ROOT::Math::BoostY::Scalar beta); voidSetComponents(ROOT::Math::BoostY::Scalar beta_y). Data Members; public:. enum ELorentzRotationMatrixIndex { kLXX; kLXY; kLXZ; kLXT; kLYX; kLYY; kLYZ; kLYT; kLZX; kLZY; kLZZ; kLZT; kLTX; kLTY; kLTZ; kLTT; };; enum EBoostMatrixIndex { kXX; kXY; kXZ; kXT; kYY; kYZ; kYT; kZZ; kZT; kTT; };. private:. ROOT::Math::BoostY::ScalarfBetabeta Y of the Boost; ROOT::Math::BoostY::ScalarfGammagamma of the Boost . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BoostY(); ========== Constructors and Assignment =====================. Default constructor (identity transformation). explicit BoostY(Scalar beta_y). Construct given a Scalar beta_y. { SetComponents(beta_y); }. void Rectify(); The compiler-generated copy ctor, copy assignment, and dtor are OK. Re-adjust components to eliminate small deviations from a perfect; orthosyplectic matrix. SetComponents(ROOT::Math::BoostY::Scalar beta_y); ======== Components ==============. Set components from a Scalar beta_y. GetComponents(ROOT::Math::BoostY::Scalar& beta_y) const. Get components into a Scalar beta_y. Scalar Beta() const. Retrieve the beta of the Boost. { return fBeta; }. Scalar Gamma() const. Retrieve the gamma of the Boost. { return fGamma; }. void SetBeta(ROOT::Math::BoostY::Scalar beta). Set the given beta of the Boost. { SetComponents(beta); }. XYZVector BetaVector() const. GetLorentzRotation(ROOT::Math::BoostY::Scalar* r) const. Get el",MatchSource.WIKI,root/html532/ROOT__Math__BoostY.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BoostY.html
https://root.cern/root/html532/ROOT__Math__BoostZ.html:1807,Modifiability,Inherit,Inheritance,1807,"* r) const; ROOT::Math::BoostZInverse() const; voidInvert(); booloperator!=(const ROOT::Math::BoostZ& rhs) const; ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >operator()(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >& v) const; ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >operator*(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >& v) const; ROOT::Math::BoostZ&operator=(const ROOT::Math::BoostZ&); booloperator==(const ROOT::Math::BoostZ& rhs) const; voidRectify(); voidSetBeta(ROOT::Math::BoostZ::Scalar beta); voidSetComponents(ROOT::Math::BoostZ::Scalar beta_z). Data Members; public:. enum ELorentzRotationMatrixIndex { kLXX; kLXY; kLXZ; kLXT; kLYX; kLYY; kLYZ; kLYT; kLZX; kLZY; kLZZ; kLZT; kLTX; kLTY; kLTZ; kLTT; };; enum EBoostMatrixIndex { kXX; kXY; kXZ; kXT; kYY; kYZ; kYT; kZZ; kZT; kTT; };. private:. ROOT::Math::BoostZ::ScalarfBetaboost beta z; ROOT::Math::BoostZ::ScalarfGammaboost gamma. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BoostZ(); ========== Constructors and Assignment =====================. Default constructor (identity transformation). explicit BoostZ(Scalar beta_z). Construct given a Scalar beta_z. { SetComponents(beta_z); }. void Rectify(); The compiler-generated copy ctor, copy assignment, and dtor are OK. Re-adjust components to eliminate small deviations from a perfect; orthosyplectic matrix. SetComponents(ROOT::Math::BoostZ::Scalar beta_z); ======== Components ==============. Set components from a Scalar beta_z. GetComponents(ROOT::Math::BoostZ::Scalar& beta_z) const. Get components into a Scalar beta_z. Scalar Beta() const. Retrieve the beta of the Boost. { return fBeta; }. Scalar Gamma() const. Retrieve the gamma of the Boost. { return fGamma; }. void SetBeta(ROOT::Math::BoostZ::Scalar beta). Set the given beta of the Boost. { SetComponents(beta); }. XYZVector BetaVector() const. GetLorentzRotation(ROOT::Math::BoostZ::Scalar* r) const. Get el",MatchSource.WIKI,root/html532/ROOT__Math__BoostZ.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BoostZ.html
https://root.cern/root/html532/ROOT__Math__BoostZ.html:1820,Modifiability,Inherit,Inherited,1820,"* r) const; ROOT::Math::BoostZInverse() const; voidInvert(); booloperator!=(const ROOT::Math::BoostZ& rhs) const; ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >operator()(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >& v) const; ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >operator*(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >& v) const; ROOT::Math::BoostZ&operator=(const ROOT::Math::BoostZ&); booloperator==(const ROOT::Math::BoostZ& rhs) const; voidRectify(); voidSetBeta(ROOT::Math::BoostZ::Scalar beta); voidSetComponents(ROOT::Math::BoostZ::Scalar beta_z). Data Members; public:. enum ELorentzRotationMatrixIndex { kLXX; kLXY; kLXZ; kLXT; kLYX; kLYY; kLYZ; kLYT; kLZX; kLZY; kLZZ; kLZT; kLTX; kLTY; kLTZ; kLTT; };; enum EBoostMatrixIndex { kXX; kXY; kXZ; kXT; kYY; kYZ; kYT; kZZ; kZT; kTT; };. private:. ROOT::Math::BoostZ::ScalarfBetaboost beta z; ROOT::Math::BoostZ::ScalarfGammaboost gamma. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BoostZ(); ========== Constructors and Assignment =====================. Default constructor (identity transformation). explicit BoostZ(Scalar beta_z). Construct given a Scalar beta_z. { SetComponents(beta_z); }. void Rectify(); The compiler-generated copy ctor, copy assignment, and dtor are OK. Re-adjust components to eliminate small deviations from a perfect; orthosyplectic matrix. SetComponents(ROOT::Math::BoostZ::Scalar beta_z); ======== Components ==============. Set components from a Scalar beta_z. GetComponents(ROOT::Math::BoostZ::Scalar& beta_z) const. Get components into a Scalar beta_z. Scalar Beta() const. Retrieve the beta of the Boost. { return fBeta; }. Scalar Gamma() const. Retrieve the gamma of the Boost. { return fGamma; }. void SetBeta(ROOT::Math::BoostZ::Scalar beta). Set the given beta of the Boost. { SetComponents(beta); }. XYZVector BetaVector() const. GetLorentzRotation(ROOT::Math::BoostZ::Scalar* r) const. Get el",MatchSource.WIKI,root/html532/ROOT__Math__BoostZ.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BoostZ.html
https://root.cern/root/html532/ROOT__Math__BrentMinimizer1D.html:1409,Availability,error,error,1409," use the Brent Method for function minimization in a given interval.; First, a grid search is used to bracket the minimum value; with the a step size = (xmax-xmin)/npx. The step size; can be controlled via the SetNpx() function. A default value of npx = 100 is used.; The default value con be changed using the static method SetDefaultNpx.; If the function is unimodal or if its extrema are far apart, setting the fNpx to; a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval.; If the Brent method fails to converge the bracketing is repeted on the latest best estimate of the; interval. The procedure is repeted with a maximum value (default =10) which can be set for all; BrentRootFinder classes with the method SetDefaultNSearch. This class is implemented from TF1::GetMinimum. To use the class, three steps have to be taken:; 1. Create the class.; 2. Set a function within an interval to look for the minimum.; 3. Call the Minimize function with the error parameters. If another minimization is to be performed, repeat the last two steps. @ingroup Min1D. Function Members (Methods); public:. virtual~BrentMinimizer1D(); ROOT::Math::BrentMinimizer1DBrentMinimizer1D(); ROOT::Math::BrentMinimizer1DBrentMinimizer1D(const ROOT::Math::BrentMinimizer1D&); virtual doubleFValLower() const; virtual doubleFValMinimum() const; virtual doubleFValUpper() const; virtual intIterations() const; virtual boolMinimize(int maxIter, double absTol = 1.E-8, double relTol = 1.E-10); virtual const char*Name() const; static voidSetDefaultNpx(int npx); static voidSetDefaultNSearch(int n); voidSetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup); voidSetLogScan(bool on); voidSetNpx(int npx); virtual intStatus() const; virtual doubleXLower() const; virtual doubleXMinimum() const; virtual doubleXUpper() const. private:. ROOT::Math::IMinimizer1D&ROOT::Math::IMinimizer1D::operator=(const ROOT::Math::IMinimizer1D&). Data Members; private:.",MatchSource.WIKI,root/html532/ROOT__Math__BrentMinimizer1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BrentMinimizer1D.html
https://root.cern/root/html532/ROOT__Math__BrentMinimizer1D.html:3791,Availability,toler,tolerance,3791,"arch interval.; doublefXMinimumPosition of the stimated minimum. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BrentMinimizer1D(); Default Constructor. . virtual ~BrentMinimizer1D(); Default Destructor. . {}. double XMinimum() const; Return current estimate of the position of the minimum. . { return fXMinimum; }. double XLower() const; Return current lower bound of the minimization interval. . { return fXMin; }. double XUpper() const; Return current upper bound of the minimization interval. . { return fXMax; }. double FValMinimum() const; Return function value at current estimate of the minimum. . double FValLower() const; Return function value at current lower bound of the minimization interval. . double FValUpper() const; Return function value at current upper bound of the minimization interval. . bool Minimize(int maxIter, double absTol = 1.E-8, double relTol = 1.E-10); Find minimum position iterating until convergence specified by the absolute and relative tolerance or; the maximum number of iteration is reached.; Return true if iterations converged successfully; \@param maxIter maximum number of iterations.; \@param absTol desired absolute error in the minimum position (default 1.E-8); \@param absTol desired relative error in the minimum position (default = 1.E-10). int Iterations() const; Return number of iteration used to find minimum . { return fNIter; }. const char * Name() const; Return name of minimization algorithm (""BrentMinimizer1D"") . void SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup); Sets function to be minimized. \@param f Function to be minimized.; \@param xlow Lower bound of the search interval.; \@param xup Upper bound of the search interval. void SetNpx(int npx); Set the number of point used to bracket root using a grid . { fNpx = npx; }. void SetLogScan(bool on). Set a log grid scan (default is equidistant bins); will work only if xlow > 0. { fLogScan = on; }. int Status() c",MatchSource.WIKI,root/html532/ROOT__Math__BrentMinimizer1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BrentMinimizer1D.html
https://root.cern/root/html532/ROOT__Math__BrentMinimizer1D.html:3979,Availability,error,error,3979,"ntMinimizer1D(); Default Destructor. . {}. double XMinimum() const; Return current estimate of the position of the minimum. . { return fXMinimum; }. double XLower() const; Return current lower bound of the minimization interval. . { return fXMin; }. double XUpper() const; Return current upper bound of the minimization interval. . { return fXMax; }. double FValMinimum() const; Return function value at current estimate of the minimum. . double FValLower() const; Return function value at current lower bound of the minimization interval. . double FValUpper() const; Return function value at current upper bound of the minimization interval. . bool Minimize(int maxIter, double absTol = 1.E-8, double relTol = 1.E-10); Find minimum position iterating until convergence specified by the absolute and relative tolerance or; the maximum number of iteration is reached.; Return true if iterations converged successfully; \@param maxIter maximum number of iterations.; \@param absTol desired absolute error in the minimum position (default 1.E-8); \@param absTol desired relative error in the minimum position (default = 1.E-10). int Iterations() const; Return number of iteration used to find minimum . { return fNIter; }. const char * Name() const; Return name of minimization algorithm (""BrentMinimizer1D"") . void SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup); Sets function to be minimized. \@param f Function to be minimized.; \@param xlow Lower bound of the search interval.; \@param xup Upper bound of the search interval. void SetNpx(int npx); Set the number of point used to bracket root using a grid . { fNpx = npx; }. void SetLogScan(bool on). Set a log grid scan (default is equidistant bins); will work only if xlow > 0. { fLogScan = on; }. int Status() const; Returns status of last estimate. If = 0 is OK . { return fStatus; }. void SetDefaultNpx(int npx); static function used to modify the default parameters; set number of default Npx used at construction time ",MatchSource.WIKI,root/html532/ROOT__Math__BrentMinimizer1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BrentMinimizer1D.html
https://root.cern/root/html532/ROOT__Math__BrentMinimizer1D.html:4058,Availability,error,error,4058,"rent estimate of the position of the minimum. . { return fXMinimum; }. double XLower() const; Return current lower bound of the minimization interval. . { return fXMin; }. double XUpper() const; Return current upper bound of the minimization interval. . { return fXMax; }. double FValMinimum() const; Return function value at current estimate of the minimum. . double FValLower() const; Return function value at current lower bound of the minimization interval. . double FValUpper() const; Return function value at current upper bound of the minimization interval. . bool Minimize(int maxIter, double absTol = 1.E-8, double relTol = 1.E-10); Find minimum position iterating until convergence specified by the absolute and relative tolerance or; the maximum number of iteration is reached.; Return true if iterations converged successfully; \@param maxIter maximum number of iterations.; \@param absTol desired absolute error in the minimum position (default 1.E-8); \@param absTol desired relative error in the minimum position (default = 1.E-10). int Iterations() const; Return number of iteration used to find minimum . { return fNIter; }. const char * Name() const; Return name of minimization algorithm (""BrentMinimizer1D"") . void SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup); Sets function to be minimized. \@param f Function to be minimized.; \@param xlow Lower bound of the search interval.; \@param xup Upper bound of the search interval. void SetNpx(int npx); Set the number of point used to bracket root using a grid . { fNpx = npx; }. void SetLogScan(bool on). Set a log grid scan (default is equidistant bins); will work only if xlow > 0. { fLogScan = on; }. int Status() const; Returns status of last estimate. If = 0 is OK . { return fStatus; }. void SetDefaultNpx(int npx); static function used to modify the default parameters; set number of default Npx used at construction time (when SetNpx is not called); Default value is 100. void SetDefaultNSearch(int ",MatchSource.WIKI,root/html532/ROOT__Math__BrentMinimizer1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BrentMinimizer1D.html
https://root.cern/root/html532/ROOT__Math__BrentMinimizer1D.html:2850,Modifiability,Inherit,Inheritance,2850," double absTol = 1.E-8, double relTol = 1.E-10); virtual const char*Name() const; static voidSetDefaultNpx(int npx); static voidSetDefaultNSearch(int n); voidSetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup); voidSetLogScan(bool on); voidSetNpx(int npx); virtual intStatus() const; virtual doubleXLower() const; virtual doubleXMinimum() const; virtual doubleXUpper() const. private:. ROOT::Math::IMinimizer1D&ROOT::Math::IMinimizer1D::operator=(const ROOT::Math::IMinimizer1D&). Data Members; private:. const ROOT::Math::IGenFunction*fFunctionPointer to the function.; boolfLogScanflag to control usage of a log scan; intfNIterNumber of iterations needed for the last estimation.; intfNpxNumber of points to bracket minimum with grid (def is 100); intfStatusStatus of code of the last estimate; doublefXMaxUpper bound of the search interval; doublefXMinLower bound of the search interval.; doublefXMinimumPosition of the stimated minimum. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BrentMinimizer1D(); Default Constructor. . virtual ~BrentMinimizer1D(); Default Destructor. . {}. double XMinimum() const; Return current estimate of the position of the minimum. . { return fXMinimum; }. double XLower() const; Return current lower bound of the minimization interval. . { return fXMin; }. double XUpper() const; Return current upper bound of the minimization interval. . { return fXMax; }. double FValMinimum() const; Return function value at current estimate of the minimum. . double FValLower() const; Return function value at current lower bound of the minimization interval. . double FValUpper() const; Return function value at current upper bound of the minimization interval. . bool Minimize(int maxIter, double absTol = 1.E-8, double relTol = 1.E-10); Find minimum position iterating until convergence specified by the absolute and relative tolerance or; the maximum number of iteration is reached.; Return true if iterations ",MatchSource.WIKI,root/html532/ROOT__Math__BrentMinimizer1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BrentMinimizer1D.html
https://root.cern/root/html532/ROOT__Math__BrentMinimizer1D.html:2863,Modifiability,Inherit,Inherited,2863," double absTol = 1.E-8, double relTol = 1.E-10); virtual const char*Name() const; static voidSetDefaultNpx(int npx); static voidSetDefaultNSearch(int n); voidSetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup); voidSetLogScan(bool on); voidSetNpx(int npx); virtual intStatus() const; virtual doubleXLower() const; virtual doubleXMinimum() const; virtual doubleXUpper() const. private:. ROOT::Math::IMinimizer1D&ROOT::Math::IMinimizer1D::operator=(const ROOT::Math::IMinimizer1D&). Data Members; private:. const ROOT::Math::IGenFunction*fFunctionPointer to the function.; boolfLogScanflag to control usage of a log scan; intfNIterNumber of iterations needed for the last estimation.; intfNpxNumber of points to bracket minimum with grid (def is 100); intfStatusStatus of code of the last estimate; doublefXMaxUpper bound of the search interval; doublefXMinLower bound of the search interval.; doublefXMinimumPosition of the stimated minimum. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BrentMinimizer1D(); Default Constructor. . virtual ~BrentMinimizer1D(); Default Destructor. . {}. double XMinimum() const; Return current estimate of the position of the minimum. . { return fXMinimum; }. double XLower() const; Return current lower bound of the minimization interval. . { return fXMin; }. double XUpper() const; Return current upper bound of the minimization interval. . { return fXMax; }. double FValMinimum() const; Return function value at current estimate of the minimum. . double FValLower() const; Return function value at current lower bound of the minimization interval. . double FValUpper() const; Return function value at current upper bound of the minimization interval. . bool Minimize(int maxIter, double absTol = 1.E-8, double relTol = 1.E-10); Find minimum position iterating until convergence specified by the absolute and relative tolerance or; the maximum number of iteration is reached.; Return true if iterations ",MatchSource.WIKI,root/html532/ROOT__Math__BrentMinimizer1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BrentMinimizer1D.html
https://root.cern/root/html532/ROOT__Math__BrentMinimizer1D.html:358,Performance,perform,performing,358,". ROOT::Math::BrentMinimizer1D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::BrentMinimizer1D. class ROOT::Math::BrentMinimizer1D: private ROOT::Math::IMinimizer1D. User class for performing function minimization. It will use the Brent Method for function minimization in a given interval.; First, a grid search is used to bracket the minimum value; with the a step size = (xmax-xmin)/npx. The step size; can be controlled via the SetNpx() function. A default value of npx = 100 is used.; The default value con be changed using the static method SetDefaultNpx.; If the function is unimodal or if its extrema are far apart, setting the fNpx to; a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval.; If the Brent method fails to converge the bracketing is repeted on the latest best estimate of the; interval. The procedure is repeted with a maximum value (default =10) which can be set for all; BrentRootFinder classes with the method SetDefaultNSearch. This class is implemented from TF1::GetMinimum. To use the class, three steps have to be taken:; 1. Create the class.; 2. Set a function within an interval to look for the minimum.; 3. Call the Minimize function with the error parameters. If another minimization is to be performed, repeat the last two steps. @ingroup Min1D. Function Members (Methods); public:. virtual~BrentMinimizer1D(); ROOT::Math::BrentMinimizer1DBrentMinimizer1D(); ROOT::Math::BrentMinimizer1DBrentMinimizer1D(const ROOT::Math::BrentMinimizer1D&); virtual doubleFValLower() const; virtual doubleFValMinimum() const; virtual doubleFValUpper() const; virtual intIterations() const; virtual boolMinimize(int maxIter, double absTol = 1.E-8, double relTol = 1.E-10); virtual const char*Name() const; static voidSetDefaultNpx(int npx); static vo",MatchSource.WIKI,root/html532/ROOT__Math__BrentMinimizer1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BrentMinimizer1D.html
https://root.cern/root/html532/ROOT__Math__BrentMinimizer1D.html:1460,Performance,perform,performed,1460,"erval.; First, a grid search is used to bracket the minimum value; with the a step size = (xmax-xmin)/npx. The step size; can be controlled via the SetNpx() function. A default value of npx = 100 is used.; The default value con be changed using the static method SetDefaultNpx.; If the function is unimodal or if its extrema are far apart, setting the fNpx to; a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval.; If the Brent method fails to converge the bracketing is repeted on the latest best estimate of the; interval. The procedure is repeted with a maximum value (default =10) which can be set for all; BrentRootFinder classes with the method SetDefaultNSearch. This class is implemented from TF1::GetMinimum. To use the class, three steps have to be taken:; 1. Create the class.; 2. Set a function within an interval to look for the minimum.; 3. Call the Minimize function with the error parameters. If another minimization is to be performed, repeat the last two steps. @ingroup Min1D. Function Members (Methods); public:. virtual~BrentMinimizer1D(); ROOT::Math::BrentMinimizer1DBrentMinimizer1D(); ROOT::Math::BrentMinimizer1DBrentMinimizer1D(const ROOT::Math::BrentMinimizer1D&); virtual doubleFValLower() const; virtual doubleFValMinimum() const; virtual doubleFValUpper() const; virtual intIterations() const; virtual boolMinimize(int maxIter, double absTol = 1.E-8, double relTol = 1.E-10); virtual const char*Name() const; static voidSetDefaultNpx(int npx); static voidSetDefaultNSearch(int n); voidSetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup); voidSetLogScan(bool on); voidSetNpx(int npx); virtual intStatus() const; virtual doubleXLower() const; virtual doubleXMinimum() const; virtual doubleXUpper() const. private:. ROOT::Math::IMinimizer1D&ROOT::Math::IMinimizer1D::operator=(const ROOT::Math::IMinimizer1D&). Data Members; private:. const ROOT::Math::IGenFunction*fFunctionPointer to the functio",MatchSource.WIKI,root/html532/ROOT__Math__BrentMinimizer1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BrentMinimizer1D.html
https://root.cern/root/html532/ROOT__Math__BrentMinimizer1D.html:2505,Testability,log,log,2505,"on Members (Methods); public:. virtual~BrentMinimizer1D(); ROOT::Math::BrentMinimizer1DBrentMinimizer1D(); ROOT::Math::BrentMinimizer1DBrentMinimizer1D(const ROOT::Math::BrentMinimizer1D&); virtual doubleFValLower() const; virtual doubleFValMinimum() const; virtual doubleFValUpper() const; virtual intIterations() const; virtual boolMinimize(int maxIter, double absTol = 1.E-8, double relTol = 1.E-10); virtual const char*Name() const; static voidSetDefaultNpx(int npx); static voidSetDefaultNSearch(int n); voidSetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup); voidSetLogScan(bool on); voidSetNpx(int npx); virtual intStatus() const; virtual doubleXLower() const; virtual doubleXMinimum() const; virtual doubleXUpper() const. private:. ROOT::Math::IMinimizer1D&ROOT::Math::IMinimizer1D::operator=(const ROOT::Math::IMinimizer1D&). Data Members; private:. const ROOT::Math::IGenFunction*fFunctionPointer to the function.; boolfLogScanflag to control usage of a log scan; intfNIterNumber of iterations needed for the last estimation.; intfNpxNumber of points to bracket minimum with grid (def is 100); intfStatusStatus of code of the last estimate; doublefXMaxUpper bound of the search interval; doublefXMinLower bound of the search interval.; doublefXMinimumPosition of the stimated minimum. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BrentMinimizer1D(); Default Constructor. . virtual ~BrentMinimizer1D(); Default Destructor. . {}. double XMinimum() const; Return current estimate of the position of the minimum. . { return fXMinimum; }. double XLower() const; Return current lower bound of the minimization interval. . { return fXMin; }. double XUpper() const; Return current upper bound of the minimization interval. . { return fXMax; }. double FValMinimum() const; Return function value at current estimate of the minimum. . double FValLower() const; Return function value at current lower bound of the minimization interval",MatchSource.WIKI,root/html532/ROOT__Math__BrentMinimizer1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BrentMinimizer1D.html
https://root.cern/root/html532/ROOT__Math__BrentMinimizer1D.html:4665,Testability,log,log,4665," const; Return function value at current upper bound of the minimization interval. . bool Minimize(int maxIter, double absTol = 1.E-8, double relTol = 1.E-10); Find minimum position iterating until convergence specified by the absolute and relative tolerance or; the maximum number of iteration is reached.; Return true if iterations converged successfully; \@param maxIter maximum number of iterations.; \@param absTol desired absolute error in the minimum position (default 1.E-8); \@param absTol desired relative error in the minimum position (default = 1.E-10). int Iterations() const; Return number of iteration used to find minimum . { return fNIter; }. const char * Name() const; Return name of minimization algorithm (""BrentMinimizer1D"") . void SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup); Sets function to be minimized. \@param f Function to be minimized.; \@param xlow Lower bound of the search interval.; \@param xup Upper bound of the search interval. void SetNpx(int npx); Set the number of point used to bracket root using a grid . { fNpx = npx; }. void SetLogScan(bool on). Set a log grid scan (default is equidistant bins); will work only if xlow > 0. { fLogScan = on; }. int Status() const; Returns status of last estimate. If = 0 is OK . { return fStatus; }. void SetDefaultNpx(int npx); static function used to modify the default parameters; set number of default Npx used at construction time (when SetNpx is not called); Default value is 100. void SetDefaultNSearch(int n); set number of times the bracketing search in combination with is done to find a good interval; Default value is 10.  Author: David Gonzalez Maline 2/2008  Copyright (c) 2004 Maline, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: BrentMinimizer1D.h 41847 2011-11-09 18:03:47Z rdm $  Last generated: 2011-12-02 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__BrentMinimizer1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BrentMinimizer1D.html
https://root.cern/root/html532/ROOT__Math__BrentRootFinder.html:3465,Availability,error,error,3465,"StatusStatus of code of the last estimate; doublefXMaxUpper bound of the search interval; doublefXMinLower bound of the search interval. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BrentRootFinder(); Default Constructor. . virtual ~BrentRootFinder(); Default Destructor. . {}. bool SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup). bool Solve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); Returns the X value corresponding to the function value fy for (xmin<x<xmax).; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx. This way, the step size; can be controlled via the SetNpx() function. If the function is; unimodal or if its extrema are far apart, setting the fNpx to; a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval. \@param maxIter maximum number of iterations.; \@param absTol desired absolute error in the minimum position.; \@param absTol desired relative error in the minimum position. void SetNpx(int npx); Set the number of point used to bracket root using a grid . { fNpx = npx; }. void SetLogScan(bool on). Set a log grid scan (default is equidistant bins); will work only if xlow > 0. { fLogScan = on; }. double Root() const; Returns root value. Need to call first Solve(). . { return fRoot; }. int Status() const; Returns status of last estimate. If = 0 is OK . { return fStatus; }. int Iterations() const; Return number of iteration used to find minimum . { return fNIter; }. const char* Name() const; Return name of root finder algorithm (""BrentRootFinder""). . void SetDefaultNpx(int npx); static function used to modify the default parameters; set number of default Npx used at construction time (when SetNpx is not called); Default value is 100. void SetDefaultNSearch(int n); set number of times the bracketing search in combination with is done to find a good interval; Default",MatchSource.WIKI,root/html532/ROOT__Math__BrentRootFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BrentRootFinder.html
https://root.cern/root/html532/ROOT__Math__BrentRootFinder.html:3529,Availability,error,error,3529,"d of the search interval; doublefXMinLower bound of the search interval. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BrentRootFinder(); Default Constructor. . virtual ~BrentRootFinder(); Default Destructor. . {}. bool SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup). bool Solve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); Returns the X value corresponding to the function value fy for (xmin<x<xmax).; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx. This way, the step size; can be controlled via the SetNpx() function. If the function is; unimodal or if its extrema are far apart, setting the fNpx to; a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval. \@param maxIter maximum number of iterations.; \@param absTol desired absolute error in the minimum position.; \@param absTol desired relative error in the minimum position. void SetNpx(int npx); Set the number of point used to bracket root using a grid . { fNpx = npx; }. void SetLogScan(bool on). Set a log grid scan (default is equidistant bins); will work only if xlow > 0. { fLogScan = on; }. double Root() const; Returns root value. Need to call first Solve(). . { return fRoot; }. int Status() const; Returns status of last estimate. If = 0 is OK . { return fStatus; }. int Iterations() const; Return number of iteration used to find minimum . { return fNIter; }. const char* Name() const; Return name of root finder algorithm (""BrentRootFinder""). . void SetDefaultNpx(int npx); static function used to modify the default parameters; set number of default Npx used at construction time (when SetNpx is not called); Default value is 100. void SetDefaultNSearch(int n); set number of times the bracketing search in combination with is done to find a good interval; Default value is 10.  Last changed: root/mathcore:$Id: BrentRootFinder",MatchSource.WIKI,root/html532/ROOT__Math__BrentRootFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BrentRootFinder.html
https://root.cern/root/html532/ROOT__Math__BrentRootFinder.html:2614,Modifiability,Inherit,Inheritance,2614,") const; virtual const char*Name() const; ROOT::Math::IRootFinderMethod&ROOT::Math::IRootFinderMethod::operator=(const ROOT::Math::IRootFinderMethod&); virtual doubleRoot() const; static voidSetDefaultNpx(int npx); static voidSetDefaultNSearch(int n); virtual boolSetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup); voidSetLogScan(bool on); voidSetNpx(int npx); virtual boolSolve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); virtual intStatus() const. Data Members; private:. const ROOT::Math::IGenFunction*fFunctionPointer to the function.; boolfLogScanflag to control usage of a log scan ; intfNIterNumber of iterations needed for the last estimation.; intfNpxNumber of points to bracket root with initial grid (def is 100); doublefRootCurrent stimation of the function root.; intfStatusStatus of code of the last estimate; doublefXMaxUpper bound of the search interval; doublefXMinLower bound of the search interval. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BrentRootFinder(); Default Constructor. . virtual ~BrentRootFinder(); Default Destructor. . {}. bool SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup). bool Solve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); Returns the X value corresponding to the function value fy for (xmin<x<xmax).; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx. This way, the step size; can be controlled via the SetNpx() function. If the function is; unimodal or if its extrema are far apart, setting the fNpx to; a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval. \@param maxIter maximum number of iterations.; \@param absTol desired absolute error in the minimum position.; \@param absTol desired relative error in the minimum position. void SetNpx(int npx); Set the number of point used to bracket root using a grid ",MatchSource.WIKI,root/html532/ROOT__Math__BrentRootFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BrentRootFinder.html
https://root.cern/root/html532/ROOT__Math__BrentRootFinder.html:2627,Modifiability,Inherit,Inherited,2627,") const; virtual const char*Name() const; ROOT::Math::IRootFinderMethod&ROOT::Math::IRootFinderMethod::operator=(const ROOT::Math::IRootFinderMethod&); virtual doubleRoot() const; static voidSetDefaultNpx(int npx); static voidSetDefaultNSearch(int n); virtual boolSetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup); voidSetLogScan(bool on); voidSetNpx(int npx); virtual boolSolve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); virtual intStatus() const. Data Members; private:. const ROOT::Math::IGenFunction*fFunctionPointer to the function.; boolfLogScanflag to control usage of a log scan ; intfNIterNumber of iterations needed for the last estimation.; intfNpxNumber of points to bracket root with initial grid (def is 100); doublefRootCurrent stimation of the function root.; intfStatusStatus of code of the last estimate; doublefXMaxUpper bound of the search interval; doublefXMinLower bound of the search interval. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BrentRootFinder(); Default Constructor. . virtual ~BrentRootFinder(); Default Destructor. . {}. bool SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup). bool Solve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); Returns the X value corresponding to the function value fy for (xmin<x<xmax).; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx. This way, the step size; can be controlled via the SetNpx() function. If the function is; unimodal or if its extrema are far apart, setting the fNpx to; a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval. \@param maxIter maximum number of iterations.; \@param absTol desired absolute error in the minimum position.; \@param absTol desired relative error in the minimum position. void SetNpx(int npx); Set the number of point used to bracket root using a grid ",MatchSource.WIKI,root/html532/ROOT__Math__BrentRootFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BrentRootFinder.html
https://root.cern/root/html532/ROOT__Math__BrentRootFinder.html:2261,Testability,log,log,2261,"ethod SetDefaultNSearch. This class is implemented from TF1::GetX() method. @ingroup RootFinders. Function Members (Methods); public:. virtual~BrentRootFinder(); ROOT::Math::BrentRootFinderBrentRootFinder(); ROOT::Math::BrentRootFinderBrentRootFinder(const ROOT::Math::BrentRootFinder&); virtual intROOT::Math::IRootFinderMethod::Iterate(); virtual intIterations() const; virtual const char*Name() const; ROOT::Math::IRootFinderMethod&ROOT::Math::IRootFinderMethod::operator=(const ROOT::Math::IRootFinderMethod&); virtual doubleRoot() const; static voidSetDefaultNpx(int npx); static voidSetDefaultNSearch(int n); virtual boolSetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup); voidSetLogScan(bool on); voidSetNpx(int npx); virtual boolSolve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); virtual intStatus() const. Data Members; private:. const ROOT::Math::IGenFunction*fFunctionPointer to the function.; boolfLogScanflag to control usage of a log scan ; intfNIterNumber of iterations needed for the last estimation.; intfNpxNumber of points to bracket root with initial grid (def is 100); doublefRootCurrent stimation of the function root.; intfStatusStatus of code of the last estimate; doublefXMaxUpper bound of the search interval; doublefXMinLower bound of the search interval. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BrentRootFinder(); Default Constructor. . virtual ~BrentRootFinder(); Default Destructor. . {}. bool SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup). bool Solve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); Returns the X value corresponding to the function value fy for (xmin<x<xmax).; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx. This way, the step size; can be controlled via the SetNpx() function. If the function is; unimodal or if its extrema are far apart, setting the fNpx to; a",MatchSource.WIKI,root/html532/ROOT__Math__BrentRootFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BrentRootFinder.html
https://root.cern/root/html532/ROOT__Math__BrentRootFinder.html:3691,Testability,log,log,3691,"ructor. . virtual ~BrentRootFinder(); Default Destructor. . {}. bool SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup). bool Solve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); Returns the X value corresponding to the function value fy for (xmin<x<xmax).; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx. This way, the step size; can be controlled via the SetNpx() function. If the function is; unimodal or if its extrema are far apart, setting the fNpx to; a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval. \@param maxIter maximum number of iterations.; \@param absTol desired absolute error in the minimum position.; \@param absTol desired relative error in the minimum position. void SetNpx(int npx); Set the number of point used to bracket root using a grid . { fNpx = npx; }. void SetLogScan(bool on). Set a log grid scan (default is equidistant bins); will work only if xlow > 0. { fLogScan = on; }. double Root() const; Returns root value. Need to call first Solve(). . { return fRoot; }. int Status() const; Returns status of last estimate. If = 0 is OK . { return fStatus; }. int Iterations() const; Return number of iteration used to find minimum . { return fNIter; }. const char* Name() const; Return name of root finder algorithm (""BrentRootFinder""). . void SetDefaultNpx(int npx); static function used to modify the default parameters; set number of default Npx used at construction time (when SetNpx is not called); Default value is 100. void SetDefaultNSearch(int n); set number of times the bracketing search in combination with is done to find a good interval; Default value is 10.  Last changed: root/mathcore:$Id: BrentRootFinder.h 36905 2010-11-24 15:44:34Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general ple",MatchSource.WIKI,root/html532/ROOT__Math__BrentRootFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__BrentRootFinder.html
https://root.cern/root/html532/ROOT__Math__Cartesian2D_Double32_t_.html:2385,Modifiability,Inherit,Inheritance,2385,"const; ROOT::Math::Cartesian2D<Double32_t>::ScalarPhi() const; ROOT::Math::Cartesian2D<Double32_t>::ScalarR() const; voidRotate(ROOT::Math::Cartesian2D<Double32_t>::Scalar angle); voidScale(ROOT::Math::Cartesian2D<Double32_t>::Scalar a); voidSetCoordinates(ROOT::Math::Cartesian2D<Double32_t>::Scalar xx, ROOT::Math::Cartesian2D<Double32_t>::Scalar yy); voidSetPhi(ROOT::Math::Cartesian2D<Double32_t>::Scalar phi); voidSetR(ROOT::Math::Cartesian2D<Double32_t>::Scalar r); voidSetX(ROOT::Math::Cartesian2D<Double32_t>::Scalar a); voidSetXY(ROOT::Math::Cartesian2D<Double32_t>::Scalar xx, ROOT::Math::Cartesian2D<Double32_t>::Scalar yy); voidSetY(ROOT::Math::Cartesian2D<Double32_t>::Scalar a); ROOT::Math::Cartesian2D<Double32_t>::ScalarX() const; ROOT::Math::Cartesian2D<Double32_t>::Scalarx() const; ROOT::Math::Cartesian2D<Double32_t>::ScalarY() const; ROOT::Math::Cartesian2D<Double32_t>::Scalary() const. Data Members; private:. Double32_tfX; Double32_tfY. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Cartesian2D & operator=(const ROOT::Math::Cartesian2D<Double32_t>& v). assignment operator. void SetCoordinates(ROOT::Math::Cartesian2D<Double32_t>::Scalar xx, ROOT::Math::Cartesian2D<Double32_t>::Scalar yy). Set internal data based on 2 Scalar numbers. { fX=xx; fY=yy; }. void GetCoordinates(ROOT::Math::Cartesian2D<Double32_t>::Scalar& xx, ROOT::Math::Cartesian2D<Double32_t>::Scalar& yy) const. get internal data into 2 Scalar numbers. {xx=fX; yy=fY; }. Scalar X() const; { return fX;}. Scalar Y() const; { return fY;}. Scalar Mag2() const; { return fX*fX + fY*fY; }. Scalar R() const; { return std::sqrt( Mag2());}. Scalar Phi() const; { return (fX==0 && fY==0) ? 0.0 : atan2(fY,fX);}. void SetX(ROOT::Math::Cartesian2D<Double32_t>::Scalar a). set the x coordinate value keeping y constant. { fX = a; }. void SetY(ROOT::Math::Cartesian2D<Double32_t>::Scalar a). set the y coordinate value keeping x constant. { fY = a; }. void SetXY(ROOT::Math::",MatchSource.WIKI,root/html532/ROOT__Math__Cartesian2D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Cartesian2D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__Cartesian2D_Double32_t_.html:2398,Modifiability,Inherit,Inherited,2398,"const; ROOT::Math::Cartesian2D<Double32_t>::ScalarPhi() const; ROOT::Math::Cartesian2D<Double32_t>::ScalarR() const; voidRotate(ROOT::Math::Cartesian2D<Double32_t>::Scalar angle); voidScale(ROOT::Math::Cartesian2D<Double32_t>::Scalar a); voidSetCoordinates(ROOT::Math::Cartesian2D<Double32_t>::Scalar xx, ROOT::Math::Cartesian2D<Double32_t>::Scalar yy); voidSetPhi(ROOT::Math::Cartesian2D<Double32_t>::Scalar phi); voidSetR(ROOT::Math::Cartesian2D<Double32_t>::Scalar r); voidSetX(ROOT::Math::Cartesian2D<Double32_t>::Scalar a); voidSetXY(ROOT::Math::Cartesian2D<Double32_t>::Scalar xx, ROOT::Math::Cartesian2D<Double32_t>::Scalar yy); voidSetY(ROOT::Math::Cartesian2D<Double32_t>::Scalar a); ROOT::Math::Cartesian2D<Double32_t>::ScalarX() const; ROOT::Math::Cartesian2D<Double32_t>::Scalarx() const; ROOT::Math::Cartesian2D<Double32_t>::ScalarY() const; ROOT::Math::Cartesian2D<Double32_t>::Scalary() const. Data Members; private:. Double32_tfX; Double32_tfY. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Cartesian2D & operator=(const ROOT::Math::Cartesian2D<Double32_t>& v). assignment operator. void SetCoordinates(ROOT::Math::Cartesian2D<Double32_t>::Scalar xx, ROOT::Math::Cartesian2D<Double32_t>::Scalar yy). Set internal data based on 2 Scalar numbers. { fX=xx; fY=yy; }. void GetCoordinates(ROOT::Math::Cartesian2D<Double32_t>::Scalar& xx, ROOT::Math::Cartesian2D<Double32_t>::Scalar& yy) const. get internal data into 2 Scalar numbers. {xx=fX; yy=fY; }. Scalar X() const; { return fX;}. Scalar Y() const; { return fY;}. Scalar Mag2() const; { return fX*fX + fY*fY; }. Scalar R() const; { return std::sqrt( Mag2());}. Scalar Phi() const; { return (fX==0 && fY==0) ? 0.0 : atan2(fY,fX);}. void SetX(ROOT::Math::Cartesian2D<Double32_t>::Scalar a). set the x coordinate value keeping y constant. { fX = a; }. void SetY(ROOT::Math::Cartesian2D<Double32_t>::Scalar a). set the y coordinate value keeping x constant. { fY = a; }. void SetXY(ROOT::Math::",MatchSource.WIKI,root/html532/ROOT__Math__Cartesian2D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Cartesian2D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__Cartesian2D_double_.html:2347,Modifiability,Inherit,Inheritance,2347,"double>& v); booloperator==(const ROOT::Math::Cartesian2D<double>& rhs) const; ROOT::Math::Cartesian2D<double>::ScalarPhi() const; ROOT::Math::Cartesian2D<double>::ScalarR() const; voidRotate(ROOT::Math::Cartesian2D<double>::Scalar angle); voidScale(ROOT::Math::Cartesian2D<double>::Scalar a); voidSetCoordinates(ROOT::Math::Cartesian2D<double>::Scalar xx, ROOT::Math::Cartesian2D<double>::Scalar yy); voidSetPhi(ROOT::Math::Cartesian2D<double>::Scalar phi); voidSetR(ROOT::Math::Cartesian2D<double>::Scalar r); voidSetX(ROOT::Math::Cartesian2D<double>::Scalar a); voidSetXY(ROOT::Math::Cartesian2D<double>::Scalar xx, ROOT::Math::Cartesian2D<double>::Scalar yy); voidSetY(ROOT::Math::Cartesian2D<double>::Scalar a); ROOT::Math::Cartesian2D<double>::ScalarX() const; ROOT::Math::Cartesian2D<double>::Scalarx() const; ROOT::Math::Cartesian2D<double>::ScalarY() const; ROOT::Math::Cartesian2D<double>::Scalary() const. Data Members; private:. doublefX; doublefY. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Cartesian2D & operator=(const ROOT::Math::Cartesian2D<double>& v). assignment operator. void SetCoordinates(ROOT::Math::Cartesian2D<double>::Scalar xx, ROOT::Math::Cartesian2D<double>::Scalar yy). Set internal data based on 2 Scalar numbers. { fX=xx; fY=yy; }. void GetCoordinates(ROOT::Math::Cartesian2D<double>::Scalar& xx, ROOT::Math::Cartesian2D<double>::Scalar& yy) const. get internal data into 2 Scalar numbers. {xx=fX; yy=fY; }. Scalar X() const; { return fX;}. Scalar Y() const; { return fY;}. Scalar Mag2() const; { return fX*fX + fY*fY; }. Scalar R() const; { return std::sqrt( Mag2());}. Scalar Phi() const; { return (fX==0 && fY==0) ? 0.0 : atan2(fY,fX);}. void SetX(ROOT::Math::Cartesian2D<double>::Scalar a). set the x coordinate value keeping y constant. { fX = a; }. void SetY(ROOT::Math::Cartesian2D<double>::Scalar a). set the y coordinate value keeping x constant. { fY = a; }. void SetXY(ROOT::Math::Cartesian2D<double>::Scalar ",MatchSource.WIKI,root/html532/ROOT__Math__Cartesian2D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Cartesian2D_double_.html
https://root.cern/root/html532/ROOT__Math__Cartesian2D_double_.html:2360,Modifiability,Inherit,Inherited,2360,"double>& v); booloperator==(const ROOT::Math::Cartesian2D<double>& rhs) const; ROOT::Math::Cartesian2D<double>::ScalarPhi() const; ROOT::Math::Cartesian2D<double>::ScalarR() const; voidRotate(ROOT::Math::Cartesian2D<double>::Scalar angle); voidScale(ROOT::Math::Cartesian2D<double>::Scalar a); voidSetCoordinates(ROOT::Math::Cartesian2D<double>::Scalar xx, ROOT::Math::Cartesian2D<double>::Scalar yy); voidSetPhi(ROOT::Math::Cartesian2D<double>::Scalar phi); voidSetR(ROOT::Math::Cartesian2D<double>::Scalar r); voidSetX(ROOT::Math::Cartesian2D<double>::Scalar a); voidSetXY(ROOT::Math::Cartesian2D<double>::Scalar xx, ROOT::Math::Cartesian2D<double>::Scalar yy); voidSetY(ROOT::Math::Cartesian2D<double>::Scalar a); ROOT::Math::Cartesian2D<double>::ScalarX() const; ROOT::Math::Cartesian2D<double>::Scalarx() const; ROOT::Math::Cartesian2D<double>::ScalarY() const; ROOT::Math::Cartesian2D<double>::Scalary() const. Data Members; private:. doublefX; doublefY. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Cartesian2D & operator=(const ROOT::Math::Cartesian2D<double>& v). assignment operator. void SetCoordinates(ROOT::Math::Cartesian2D<double>::Scalar xx, ROOT::Math::Cartesian2D<double>::Scalar yy). Set internal data based on 2 Scalar numbers. { fX=xx; fY=yy; }. void GetCoordinates(ROOT::Math::Cartesian2D<double>::Scalar& xx, ROOT::Math::Cartesian2D<double>::Scalar& yy) const. get internal data into 2 Scalar numbers. {xx=fX; yy=fY; }. Scalar X() const; { return fX;}. Scalar Y() const; { return fY;}. Scalar Mag2() const; { return fX*fX + fY*fY; }. Scalar R() const; { return std::sqrt( Mag2());}. Scalar Phi() const; { return (fX==0 && fY==0) ? 0.0 : atan2(fY,fX);}. void SetX(ROOT::Math::Cartesian2D<double>::Scalar a). set the x coordinate value keeping y constant. { fX = a; }. void SetY(ROOT::Math::Cartesian2D<double>::Scalar a). set the y coordinate value keeping x constant. { fY = a; }. void SetXY(ROOT::Math::Cartesian2D<double>::Scalar ",MatchSource.WIKI,root/html532/ROOT__Math__Cartesian2D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Cartesian2D_double_.html
https://root.cern/root/html532/ROOT__Math__Cartesian3D_Double32_t_.html:3818,Modifiability,Inherit,Inheritance,3818,"; voidSetPhi(ROOT::Math::Cartesian3D<Double32_t>::Scalar phi); voidSetR(ROOT::Math::Cartesian3D<Double32_t>::Scalar r); voidSetRho(ROOT::Math::Cartesian3D<Double32_t>::Scalar rho); voidSetTheta(ROOT::Math::Cartesian3D<Double32_t>::Scalar theta); voidSetX(ROOT::Math::Cartesian3D<Double32_t>::Scalar xx); voidSetXYZ(ROOT::Math::Cartesian3D<Double32_t>::Scalar xx, ROOT::Math::Cartesian3D<Double32_t>::Scalar yy, ROOT::Math::Cartesian3D<Double32_t>::Scalar zz); voidSetY(ROOT::Math::Cartesian3D<Double32_t>::Scalar yy); voidSetZ(ROOT::Math::Cartesian3D<Double32_t>::Scalar zz); ROOT::Math::Cartesian3D<Double32_t>::ScalarTheta() const; ROOT::Math::Cartesian3D<Double32_t>::ScalarX() const; Double32_tx() const; ROOT::Math::Cartesian3D<Double32_t>::ScalarY() const; Double32_ty() const; ROOT::Math::Cartesian3D<Double32_t>::ScalarZ() const; Double32_tz() const. Data Members; private:. Double32_tfXx coordinate; Double32_tfYy coordinate; Double32_tfZz coordinate. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Cartesian3D & operator=(const ROOT::Math::Cartesian3D<Double32_t>& v). assignment operator. void SetCoordinates(const ROOT::Math::Cartesian3D<Double32_t>::Scalar* src). Set internal data based on an array of 3 Scalar numbers. { fX=src[0]; fY=src[1]; fZ=src[2]; }. void GetCoordinates(ROOT::Math::Cartesian3D<Double32_t>::Scalar* dest) const. get internal data into an array of 3 Scalar numbers. { dest[0] = fX; dest[1] = fY; dest[2] = fZ; }. void SetCoordinates(ROOT::Math::Cartesian3D<Double32_t>::Scalar xx, ROOT::Math::Cartesian3D<Double32_t>::Scalar yy, ROOT::Math::Cartesian3D<Double32_t>::Scalar zz). Set internal data based on 3 Scalar numbers. { fX=xx; fY=yy; fZ=zz; }. void GetCoordinates(ROOT::Math::Cartesian3D<Double32_t>::Scalar& xx, ROOT::Math::Cartesian3D<Double32_t>::Scalar& yy, ROOT::Math::Cartesian3D<Double32_t>::Scalar& zz) const. get internal data into 3 Scalar numbers. {xx=fX; yy=fY; zz=fZ;}. Scalar X() const; { return fX;}.",MatchSource.WIKI,root/html532/ROOT__Math__Cartesian3D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Cartesian3D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__Cartesian3D_Double32_t_.html:3831,Modifiability,Inherit,Inherited,3831,"; voidSetPhi(ROOT::Math::Cartesian3D<Double32_t>::Scalar phi); voidSetR(ROOT::Math::Cartesian3D<Double32_t>::Scalar r); voidSetRho(ROOT::Math::Cartesian3D<Double32_t>::Scalar rho); voidSetTheta(ROOT::Math::Cartesian3D<Double32_t>::Scalar theta); voidSetX(ROOT::Math::Cartesian3D<Double32_t>::Scalar xx); voidSetXYZ(ROOT::Math::Cartesian3D<Double32_t>::Scalar xx, ROOT::Math::Cartesian3D<Double32_t>::Scalar yy, ROOT::Math::Cartesian3D<Double32_t>::Scalar zz); voidSetY(ROOT::Math::Cartesian3D<Double32_t>::Scalar yy); voidSetZ(ROOT::Math::Cartesian3D<Double32_t>::Scalar zz); ROOT::Math::Cartesian3D<Double32_t>::ScalarTheta() const; ROOT::Math::Cartesian3D<Double32_t>::ScalarX() const; Double32_tx() const; ROOT::Math::Cartesian3D<Double32_t>::ScalarY() const; Double32_ty() const; ROOT::Math::Cartesian3D<Double32_t>::ScalarZ() const; Double32_tz() const. Data Members; private:. Double32_tfXx coordinate; Double32_tfYy coordinate; Double32_tfZz coordinate. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Cartesian3D & operator=(const ROOT::Math::Cartesian3D<Double32_t>& v). assignment operator. void SetCoordinates(const ROOT::Math::Cartesian3D<Double32_t>::Scalar* src). Set internal data based on an array of 3 Scalar numbers. { fX=src[0]; fY=src[1]; fZ=src[2]; }. void GetCoordinates(ROOT::Math::Cartesian3D<Double32_t>::Scalar* dest) const. get internal data into an array of 3 Scalar numbers. { dest[0] = fX; dest[1] = fY; dest[2] = fZ; }. void SetCoordinates(ROOT::Math::Cartesian3D<Double32_t>::Scalar xx, ROOT::Math::Cartesian3D<Double32_t>::Scalar yy, ROOT::Math::Cartesian3D<Double32_t>::Scalar zz). Set internal data based on 3 Scalar numbers. { fX=xx; fY=yy; fZ=zz; }. void GetCoordinates(ROOT::Math::Cartesian3D<Double32_t>::Scalar& xx, ROOT::Math::Cartesian3D<Double32_t>::Scalar& yy, ROOT::Math::Cartesian3D<Double32_t>::Scalar& zz) const. get internal data into 3 Scalar numbers. {xx=fX; yy=fY; zz=fZ;}. Scalar X() const; { return fX;}.",MatchSource.WIKI,root/html532/ROOT__Math__Cartesian3D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Cartesian3D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__Cartesian3D_double_.html:4448,Modifiability,Inherit,Inheritance,4448,"n3D<double>::Scalar zz); voidSetEta(ROOT::Math::Cartesian3D<double>::Scalar eta); voidSetPhi(ROOT::Math::Cartesian3D<double>::Scalar phi); voidSetR(ROOT::Math::Cartesian3D<double>::Scalar r); voidSetRho(ROOT::Math::Cartesian3D<double>::Scalar rho); voidSetTheta(ROOT::Math::Cartesian3D<double>::Scalar theta); voidSetX(ROOT::Math::Cartesian3D<double>::Scalar xx); voidSetXYZ(ROOT::Math::Cartesian3D<double>::Scalar xx, ROOT::Math::Cartesian3D<double>::Scalar yy, ROOT::Math::Cartesian3D<double>::Scalar zz); voidSetY(ROOT::Math::Cartesian3D<double>::Scalar yy); voidSetZ(ROOT::Math::Cartesian3D<double>::Scalar zz); ROOT::Math::Cartesian3D<double>::ScalarTheta() const; ROOT::Math::Cartesian3D<double>::ScalarX() const; doublex() const; ROOT::Math::Cartesian3D<double>::ScalarY() const; doubley() const; ROOT::Math::Cartesian3D<double>::ScalarZ() const; doublez() const. Data Members; private:. doublefXx coordinate; doublefYy coordinate; doublefZz coordinate. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Cartesian3D & operator=(const ROOT::Math::Cartesian3D<double>& v). assignment operator. void SetCoordinates(const ROOT::Math::Cartesian3D<double>::Scalar* src). Set internal data based on an array of 3 Scalar numbers. { fX=src[0]; fY=src[1]; fZ=src[2]; }. void GetCoordinates(ROOT::Math::Cartesian3D<double>::Scalar* dest) const. get internal data into an array of 3 Scalar numbers. { dest[0] = fX; dest[1] = fY; dest[2] = fZ; }. void SetCoordinates(ROOT::Math::Cartesian3D<double>::Scalar xx, ROOT::Math::Cartesian3D<double>::Scalar yy, ROOT::Math::Cartesian3D<double>::Scalar zz). Set internal data based on 3 Scalar numbers. { fX=xx; fY=yy; fZ=zz; }. void GetCoordinates(ROOT::Math::Cartesian3D<double>::Scalar& xx, ROOT::Math::Cartesian3D<double>::Scalar& yy, ROOT::Math::Cartesian3D<double>::Scalar& zz) const. get internal data into 3 Scalar numbers. {xx=fX; yy=fY; zz=fZ;}. Scalar X() const; { return fX;}. Scalar Y() const; { return fY;}. Sc",MatchSource.WIKI,root/html532/ROOT__Math__Cartesian3D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Cartesian3D_double_.html
https://root.cern/root/html532/ROOT__Math__Cartesian3D_double_.html:4461,Modifiability,Inherit,Inherited,4461,"n3D<double>::Scalar zz); voidSetEta(ROOT::Math::Cartesian3D<double>::Scalar eta); voidSetPhi(ROOT::Math::Cartesian3D<double>::Scalar phi); voidSetR(ROOT::Math::Cartesian3D<double>::Scalar r); voidSetRho(ROOT::Math::Cartesian3D<double>::Scalar rho); voidSetTheta(ROOT::Math::Cartesian3D<double>::Scalar theta); voidSetX(ROOT::Math::Cartesian3D<double>::Scalar xx); voidSetXYZ(ROOT::Math::Cartesian3D<double>::Scalar xx, ROOT::Math::Cartesian3D<double>::Scalar yy, ROOT::Math::Cartesian3D<double>::Scalar zz); voidSetY(ROOT::Math::Cartesian3D<double>::Scalar yy); voidSetZ(ROOT::Math::Cartesian3D<double>::Scalar zz); ROOT::Math::Cartesian3D<double>::ScalarTheta() const; ROOT::Math::Cartesian3D<double>::ScalarX() const; doublex() const; ROOT::Math::Cartesian3D<double>::ScalarY() const; doubley() const; ROOT::Math::Cartesian3D<double>::ScalarZ() const; doublez() const. Data Members; private:. doublefXx coordinate; doublefYy coordinate; doublefZz coordinate. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Cartesian3D & operator=(const ROOT::Math::Cartesian3D<double>& v). assignment operator. void SetCoordinates(const ROOT::Math::Cartesian3D<double>::Scalar* src). Set internal data based on an array of 3 Scalar numbers. { fX=src[0]; fY=src[1]; fZ=src[2]; }. void GetCoordinates(ROOT::Math::Cartesian3D<double>::Scalar* dest) const. get internal data into an array of 3 Scalar numbers. { dest[0] = fX; dest[1] = fY; dest[2] = fZ; }. void SetCoordinates(ROOT::Math::Cartesian3D<double>::Scalar xx, ROOT::Math::Cartesian3D<double>::Scalar yy, ROOT::Math::Cartesian3D<double>::Scalar zz). Set internal data based on 3 Scalar numbers. { fX=xx; fY=yy; fZ=zz; }. void GetCoordinates(ROOT::Math::Cartesian3D<double>::Scalar& xx, ROOT::Math::Cartesian3D<double>::Scalar& yy, ROOT::Math::Cartesian3D<double>::Scalar& zz) const. get internal data into 3 Scalar numbers. {xx=fX; yy=fY; zz=fZ;}. Scalar X() const; { return fX;}. Scalar Y() const; { return fY;}. Sc",MatchSource.WIKI,root/html532/ROOT__Math__Cartesian3D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Cartesian3D_double_.html
https://root.cern/root/html532/ROOT__Math__Chebyshev.html:2494,Availability,error,error,2494,"nction; size_tfOrder; ROOT::Math::GSLChebSeries*fSeries. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Chebyshev(const ROOT::Math::IGenFunction& f, double a, double b, size_t n). Construct a Chebyshev series approximation to a Function f in range [a,b];; constructor based on functions of type IGenFunction. Chebyshev(ROOT::Math::GSLFuncPointer f, void* p, double a, double b, size_t n). Construct a Chebyshev series approximation to a Function f in range [a,b];; constructor based on free functions with gsl_function type signature. virtual ~Chebyshev(); destructor. Chebyshev(size_t n). construct a Chebyshev series or order n; The series must be initialized from a function. Chebyshev(const ROOT::Math::Chebyshev& ); usually copying is non trivial, so we make this unaccessible. double operator()(double x) const. Evaluate the series at a given point x. std::pair<double, double> EvalErr(double x) const. Evaluate the series at a given point x estimating both the series result and its absolute error.; The error estimate is made from the first neglected term in the series.; A pair containing result and error is returned. double operator()(double x, size_t n) const. Evaluate the series at a given point, to (at most) the given order n. std::pair<double, double> EvalErr(double x, size_t n) const. evaluate the series at a given point x to the given order n,; estimating both the series result and its absolute error.; The error estimate is made from the first neglected term in the series.; A pair containing result and error is returned. Chebyshev * Deriv(). Compute the derivative of the series and return a pointer to a new Chebyshev series with the; derivatives coefficients. The returned pointer must be managed by the user. TO DO: implement copying to return by value. Chebyshev * Integral(). Compute the integral of the series and return a pointer to a new Chebyshev series with the; integral coefficients. The lower limit of the integration i",MatchSource.WIKI,root/html532/ROOT__Math__Chebyshev.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Chebyshev.html
https://root.cern/root/html532/ROOT__Math__Chebyshev.html:2506,Availability,error,error,2506,"nherited Members; Includes; Libraries. Function documentation; Chebyshev(const ROOT::Math::IGenFunction& f, double a, double b, size_t n). Construct a Chebyshev series approximation to a Function f in range [a,b];; constructor based on functions of type IGenFunction. Chebyshev(ROOT::Math::GSLFuncPointer f, void* p, double a, double b, size_t n). Construct a Chebyshev series approximation to a Function f in range [a,b];; constructor based on free functions with gsl_function type signature. virtual ~Chebyshev(); destructor. Chebyshev(size_t n). construct a Chebyshev series or order n; The series must be initialized from a function. Chebyshev(const ROOT::Math::Chebyshev& ); usually copying is non trivial, so we make this unaccessible. double operator()(double x) const. Evaluate the series at a given point x. std::pair<double, double> EvalErr(double x) const. Evaluate the series at a given point x estimating both the series result and its absolute error.; The error estimate is made from the first neglected term in the series.; A pair containing result and error is returned. double operator()(double x, size_t n) const. Evaluate the series at a given point, to (at most) the given order n. std::pair<double, double> EvalErr(double x, size_t n) const. evaluate the series at a given point x to the given order n,; estimating both the series result and its absolute error.; The error estimate is made from the first neglected term in the series.; A pair containing result and error is returned. Chebyshev * Deriv(). Compute the derivative of the series and return a pointer to a new Chebyshev series with the; derivatives coefficients. The returned pointer must be managed by the user. TO DO: implement copying to return by value. Chebyshev * Integral(). Compute the integral of the series and return a pointer to a new Chebyshev series with the; integral coefficients. The lower limit of the integration is the left range value a.; The returned pointer must be managed by the user. TO DO: i",MatchSource.WIKI,root/html532/ROOT__Math__Chebyshev.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Chebyshev.html
https://root.cern/root/html532/ROOT__Math__Chebyshev.html:2604,Availability,error,error,2604,"; Chebyshev(const ROOT::Math::IGenFunction& f, double a, double b, size_t n). Construct a Chebyshev series approximation to a Function f in range [a,b];; constructor based on functions of type IGenFunction. Chebyshev(ROOT::Math::GSLFuncPointer f, void* p, double a, double b, size_t n). Construct a Chebyshev series approximation to a Function f in range [a,b];; constructor based on free functions with gsl_function type signature. virtual ~Chebyshev(); destructor. Chebyshev(size_t n). construct a Chebyshev series or order n; The series must be initialized from a function. Chebyshev(const ROOT::Math::Chebyshev& ); usually copying is non trivial, so we make this unaccessible. double operator()(double x) const. Evaluate the series at a given point x. std::pair<double, double> EvalErr(double x) const. Evaluate the series at a given point x estimating both the series result and its absolute error.; The error estimate is made from the first neglected term in the series.; A pair containing result and error is returned. double operator()(double x, size_t n) const. Evaluate the series at a given point, to (at most) the given order n. std::pair<double, double> EvalErr(double x, size_t n) const. evaluate the series at a given point x to the given order n,; estimating both the series result and its absolute error.; The error estimate is made from the first neglected term in the series.; A pair containing result and error is returned. Chebyshev * Deriv(). Compute the derivative of the series and return a pointer to a new Chebyshev series with the; derivatives coefficients. The returned pointer must be managed by the user. TO DO: implement copying to return by value. Chebyshev * Integral(). Compute the integral of the series and return a pointer to a new Chebyshev series with the; integral coefficients. The lower limit of the integration is the left range value a.; The returned pointer must be managed by the user. TO DO: implement copying to return by value. void Initialize(ROOT::Ma",MatchSource.WIKI,root/html532/ROOT__Math__Chebyshev.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Chebyshev.html
https://root.cern/root/html532/ROOT__Math__Chebyshev.html:2912,Availability,error,error,2912,"e a, double b, size_t n). Construct a Chebyshev series approximation to a Function f in range [a,b];; constructor based on free functions with gsl_function type signature. virtual ~Chebyshev(); destructor. Chebyshev(size_t n). construct a Chebyshev series or order n; The series must be initialized from a function. Chebyshev(const ROOT::Math::Chebyshev& ); usually copying is non trivial, so we make this unaccessible. double operator()(double x) const. Evaluate the series at a given point x. std::pair<double, double> EvalErr(double x) const. Evaluate the series at a given point x estimating both the series result and its absolute error.; The error estimate is made from the first neglected term in the series.; A pair containing result and error is returned. double operator()(double x, size_t n) const. Evaluate the series at a given point, to (at most) the given order n. std::pair<double, double> EvalErr(double x, size_t n) const. evaluate the series at a given point x to the given order n,; estimating both the series result and its absolute error.; The error estimate is made from the first neglected term in the series.; A pair containing result and error is returned. Chebyshev * Deriv(). Compute the derivative of the series and return a pointer to a new Chebyshev series with the; derivatives coefficients. The returned pointer must be managed by the user. TO DO: implement copying to return by value. Chebyshev * Integral(). Compute the integral of the series and return a pointer to a new Chebyshev series with the; integral coefficients. The lower limit of the integration is the left range value a.; The returned pointer must be managed by the user. TO DO: implement copying to return by value. void Initialize(ROOT::Math::GSLFuncPointer f, void* params, double a, double b). Initialize series passing function and range.  Last changed: root/mathmore:$Id: Chebyshev.h 38026 2011-02-10 11:46:12Z rdm $  Last generated: 2011-11-03 20:04; This page has been automatically generate",MatchSource.WIKI,root/html532/ROOT__Math__Chebyshev.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Chebyshev.html
https://root.cern/root/html532/ROOT__Math__Chebyshev.html:2924,Availability,error,error,2924,",b];; constructor based on free functions with gsl_function type signature. virtual ~Chebyshev(); destructor. Chebyshev(size_t n). construct a Chebyshev series or order n; The series must be initialized from a function. Chebyshev(const ROOT::Math::Chebyshev& ); usually copying is non trivial, so we make this unaccessible. double operator()(double x) const. Evaluate the series at a given point x. std::pair<double, double> EvalErr(double x) const. Evaluate the series at a given point x estimating both the series result and its absolute error.; The error estimate is made from the first neglected term in the series.; A pair containing result and error is returned. double operator()(double x, size_t n) const. Evaluate the series at a given point, to (at most) the given order n. std::pair<double, double> EvalErr(double x, size_t n) const. evaluate the series at a given point x to the given order n,; estimating both the series result and its absolute error.; The error estimate is made from the first neglected term in the series.; A pair containing result and error is returned. Chebyshev * Deriv(). Compute the derivative of the series and return a pointer to a new Chebyshev series with the; derivatives coefficients. The returned pointer must be managed by the user. TO DO: implement copying to return by value. Chebyshev * Integral(). Compute the integral of the series and return a pointer to a new Chebyshev series with the; integral coefficients. The lower limit of the integration is the left range value a.; The returned pointer must be managed by the user. TO DO: implement copying to return by value. void Initialize(ROOT::Math::GSLFuncPointer f, void* params, double a, double b). Initialize series passing function and range.  Last changed: root/mathmore:$Id: Chebyshev.h 38026 2011-02-10 11:46:12Z rdm $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail ",MatchSource.WIKI,root/html532/ROOT__Math__Chebyshev.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Chebyshev.html
https://root.cern/root/html532/ROOT__Math__Chebyshev.html:3022,Availability,error,error,3022,"based on free functions with gsl_function type signature. virtual ~Chebyshev(); destructor. Chebyshev(size_t n). construct a Chebyshev series or order n; The series must be initialized from a function. Chebyshev(const ROOT::Math::Chebyshev& ); usually copying is non trivial, so we make this unaccessible. double operator()(double x) const. Evaluate the series at a given point x. std::pair<double, double> EvalErr(double x) const. Evaluate the series at a given point x estimating both the series result and its absolute error.; The error estimate is made from the first neglected term in the series.; A pair containing result and error is returned. double operator()(double x, size_t n) const. Evaluate the series at a given point, to (at most) the given order n. std::pair<double, double> EvalErr(double x, size_t n) const. evaluate the series at a given point x to the given order n,; estimating both the series result and its absolute error.; The error estimate is made from the first neglected term in the series.; A pair containing result and error is returned. Chebyshev * Deriv(). Compute the derivative of the series and return a pointer to a new Chebyshev series with the; derivatives coefficients. The returned pointer must be managed by the user. TO DO: implement copying to return by value. Chebyshev * Integral(). Compute the integral of the series and return a pointer to a new Chebyshev series with the; integral coefficients. The lower limit of the integration is the left range value a.; The returned pointer must be managed by the user. TO DO: implement copying to return by value. void Initialize(ROOT::Math::GSLFuncPointer f, void* params, double a, double b). Initialize series passing function and range.  Last changed: root/mathmore:$Id: Chebyshev.h 38026 2011-02-10 11:46:12Z rdm $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__Chebyshev.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Chebyshev.html
https://root.cern/root/html532/ROOT__Math__Chebyshev.html:3439,Deployability,integrat,integration,3439,"based on free functions with gsl_function type signature. virtual ~Chebyshev(); destructor. Chebyshev(size_t n). construct a Chebyshev series or order n; The series must be initialized from a function. Chebyshev(const ROOT::Math::Chebyshev& ); usually copying is non trivial, so we make this unaccessible. double operator()(double x) const. Evaluate the series at a given point x. std::pair<double, double> EvalErr(double x) const. Evaluate the series at a given point x estimating both the series result and its absolute error.; The error estimate is made from the first neglected term in the series.; A pair containing result and error is returned. double operator()(double x, size_t n) const. Evaluate the series at a given point, to (at most) the given order n. std::pair<double, double> EvalErr(double x, size_t n) const. evaluate the series at a given point x to the given order n,; estimating both the series result and its absolute error.; The error estimate is made from the first neglected term in the series.; A pair containing result and error is returned. Chebyshev * Deriv(). Compute the derivative of the series and return a pointer to a new Chebyshev series with the; derivatives coefficients. The returned pointer must be managed by the user. TO DO: implement copying to return by value. Chebyshev * Integral(). Compute the integral of the series and return a pointer to a new Chebyshev series with the; integral coefficients. The lower limit of the integration is the left range value a.; The returned pointer must be managed by the user. TO DO: implement copying to return by value. void Initialize(ROOT::Math::GSLFuncPointer f, void* params, double a, double b). Initialize series passing function and range.  Last changed: root/mathmore:$Id: Chebyshev.h 38026 2011-02-10 11:46:12Z rdm $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__Chebyshev.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Chebyshev.html
https://root.cern/root/html532/ROOT__Math__Chebyshev.html:3439,Integrability,integrat,integration,3439,"based on free functions with gsl_function type signature. virtual ~Chebyshev(); destructor. Chebyshev(size_t n). construct a Chebyshev series or order n; The series must be initialized from a function. Chebyshev(const ROOT::Math::Chebyshev& ); usually copying is non trivial, so we make this unaccessible. double operator()(double x) const. Evaluate the series at a given point x. std::pair<double, double> EvalErr(double x) const. Evaluate the series at a given point x estimating both the series result and its absolute error.; The error estimate is made from the first neglected term in the series.; A pair containing result and error is returned. double operator()(double x, size_t n) const. Evaluate the series at a given point, to (at most) the given order n. std::pair<double, double> EvalErr(double x, size_t n) const. evaluate the series at a given point x to the given order n,; estimating both the series result and its absolute error.; The error estimate is made from the first neglected term in the series.; A pair containing result and error is returned. Chebyshev * Deriv(). Compute the derivative of the series and return a pointer to a new Chebyshev series with the; derivatives coefficients. The returned pointer must be managed by the user. TO DO: implement copying to return by value. Chebyshev * Integral(). Compute the integral of the series and return a pointer to a new Chebyshev series with the; integral coefficients. The lower limit of the integration is the left range value a.; The returned pointer must be managed by the user. TO DO: implement copying to return by value. void Initialize(ROOT::Math::GSLFuncPointer f, void* params, double a, double b). Initialize series passing function and range.  Last changed: root/mathmore:$Id: Chebyshev.h 38026 2011-02-10 11:46:12Z rdm $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__Chebyshev.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Chebyshev.html
https://root.cern/root/html532/ROOT__Math__Chebyshev.html:1522,Modifiability,Inherit,Inheritance,1522,">. This class does not support copying; @ingroup FuncApprox. Function Members (Methods); public:. virtual~Chebyshev(); ROOT::Math::ChebyshevChebyshev(const ROOT::Math::IGenFunction& f, double a, double b, size_t n); ROOT::Math::ChebyshevChebyshev(ROOT::Math::GSLFuncPointer f, void* p, double a, double b, size_t n); ROOT::Math::Chebyshev*Deriv(); pair<double,double>EvalErr(double x) const; pair<double,double>EvalErr(double x, size_t n) const; ROOT::Math::Chebyshev*Integral(); doubleoperator()(double x) const; doubleoperator()(double x, size_t n) const. protected:. voidInitialize(ROOT::Math::GSLFuncPointer f, void* params, double a, double b). private:. ROOT::Math::ChebyshevChebyshev(size_t n); ROOT::Math::ChebyshevChebyshev(const ROOT::Math::Chebyshev&); ROOT::Math::Chebyshev&operator=(const ROOT::Math::Chebyshev&). Data Members; private:. ROOT::Math::GSLFunctionWrapper*fFunctionpointer to function; size_tfOrder; ROOT::Math::GSLChebSeries*fSeries. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Chebyshev(const ROOT::Math::IGenFunction& f, double a, double b, size_t n). Construct a Chebyshev series approximation to a Function f in range [a,b];; constructor based on functions of type IGenFunction. Chebyshev(ROOT::Math::GSLFuncPointer f, void* p, double a, double b, size_t n). Construct a Chebyshev series approximation to a Function f in range [a,b];; constructor based on free functions with gsl_function type signature. virtual ~Chebyshev(); destructor. Chebyshev(size_t n). construct a Chebyshev series or order n; The series must be initialized from a function. Chebyshev(const ROOT::Math::Chebyshev& ); usually copying is non trivial, so we make this unaccessible. double operator()(double x) const. Evaluate the series at a given point x. std::pair<double, double> EvalErr(double x) const. Evaluate the series at a given point x estimating both the series result and its absolute error.; The error estimate is made from the first negl",MatchSource.WIKI,root/html532/ROOT__Math__Chebyshev.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Chebyshev.html
https://root.cern/root/html532/ROOT__Math__Chebyshev.html:1535,Modifiability,Inherit,Inherited,1535,">. This class does not support copying; @ingroup FuncApprox. Function Members (Methods); public:. virtual~Chebyshev(); ROOT::Math::ChebyshevChebyshev(const ROOT::Math::IGenFunction& f, double a, double b, size_t n); ROOT::Math::ChebyshevChebyshev(ROOT::Math::GSLFuncPointer f, void* p, double a, double b, size_t n); ROOT::Math::Chebyshev*Deriv(); pair<double,double>EvalErr(double x) const; pair<double,double>EvalErr(double x, size_t n) const; ROOT::Math::Chebyshev*Integral(); doubleoperator()(double x) const; doubleoperator()(double x, size_t n) const. protected:. voidInitialize(ROOT::Math::GSLFuncPointer f, void* params, double a, double b). private:. ROOT::Math::ChebyshevChebyshev(size_t n); ROOT::Math::ChebyshevChebyshev(const ROOT::Math::Chebyshev&); ROOT::Math::Chebyshev&operator=(const ROOT::Math::Chebyshev&). Data Members; private:. ROOT::Math::GSLFunctionWrapper*fFunctionpointer to function; size_tfOrder; ROOT::Math::GSLChebSeries*fSeries. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Chebyshev(const ROOT::Math::IGenFunction& f, double a, double b, size_t n). Construct a Chebyshev series approximation to a Function f in range [a,b];; constructor based on functions of type IGenFunction. Chebyshev(ROOT::Math::GSLFuncPointer f, void* p, double a, double b, size_t n). Construct a Chebyshev series approximation to a Function f in range [a,b];; constructor based on free functions with gsl_function type signature. virtual ~Chebyshev(); destructor. Chebyshev(size_t n). construct a Chebyshev series or order n; The series must be initialized from a function. Chebyshev(const ROOT::Math::Chebyshev& ); usually copying is non trivial, so we make this unaccessible. double operator()(double x) const. Evaluate the series at a given point x. std::pair<double, double> EvalErr(double x) const. Evaluate the series at a given point x estimating both the series result and its absolute error.; The error estimate is made from the first negl",MatchSource.WIKI,root/html532/ROOT__Math__Chebyshev.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Chebyshev.html
https://root.cern/root/html532/ROOT__Math__Cylindrical3D_Double32_t_.html:3459,Modifiability,Inherit,Inheritance,3459,"<Double32_t>::Scalar eta); voidSetPhi(Double32_t phi); voidSetR(ROOT::Math::Cylindrical3D<Double32_t>::Scalar r); voidSetRho(Double32_t rho); voidSetTheta(ROOT::Math::Cylindrical3D<Double32_t>::Scalar theta); voidSetX(ROOT::Math::Cylindrical3D<Double32_t>::Scalar xx); voidSetXYZ(ROOT::Math::Cylindrical3D<Double32_t>::Scalar xx, ROOT::Math::Cylindrical3D<Double32_t>::Scalar yy, ROOT::Math::Cylindrical3D<Double32_t>::Scalar zz); voidSetY(ROOT::Math::Cylindrical3D<Double32_t>::Scalar yy); voidSetZ(Double32_t zz); ROOT::Math::Cylindrical3D<Double32_t>::ScalarTheta() const; ROOT::Math::Cylindrical3D<Double32_t>::ScalarX() const; Double32_tx() const; ROOT::Math::Cylindrical3D<Double32_t>::ScalarY() const; Double32_ty() const; ROOT::Math::Cylindrical3D<Double32_t>::ScalarZ() const; Double32_tz() const. private:. static ROOT::Math::Cylindrical3D<Double32_t>::Scalarpi(); voidRestrict(). Data Members; private:. Double32_tfPhi; Double32_tfRho; Double32_tfZ. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Cylindrical3D & operator=(const ROOT::Math::Cylindrical3D<Double32_t>& v). assignment operator. void SetCoordinates(const ROOT::Math::Cylindrical3D<Double32_t>::Scalar* src). Set internal data based on an array of 3 Scalar numbers ( rho, z , phi). { fRho=src[0]; fZ=src[1]; fPhi=src[2]; Restrict(); }. void GetCoordinates(ROOT::Math::Cylindrical3D<Double32_t>::Scalar* dest) const. get internal data into an array of 3 Scalar numbers ( rho, z , phi). { dest[0] = fRho; dest[1] = fZ; dest[2] = fPhi; }. void SetCoordinates(ROOT::Math::Cylindrical3D<Double32_t>::Scalar rho, ROOT::Math::Cylindrical3D<Double32_t>::Scalar zz, ROOT::Math::Cylindrical3D<Double32_t>::Scalar phi). Set internal data based on 3 Scalar numbers ( rho, z , phi). { fRho=rho; fZ=zz; fPhi=phi; Restrict(); }. void GetCoordinates(ROOT::Math::Cylindrical3D<Double32_t>::Scalar& rho, ROOT::Math::Cylindrical3D<Double32_t>::Scalar& zz, ROOT::Math::Cylindrical3D<Double32_t>::Scalar&",MatchSource.WIKI,root/html532/ROOT__Math__Cylindrical3D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Cylindrical3D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__Cylindrical3D_Double32_t_.html:3472,Modifiability,Inherit,Inherited,3472,"<Double32_t>::Scalar eta); voidSetPhi(Double32_t phi); voidSetR(ROOT::Math::Cylindrical3D<Double32_t>::Scalar r); voidSetRho(Double32_t rho); voidSetTheta(ROOT::Math::Cylindrical3D<Double32_t>::Scalar theta); voidSetX(ROOT::Math::Cylindrical3D<Double32_t>::Scalar xx); voidSetXYZ(ROOT::Math::Cylindrical3D<Double32_t>::Scalar xx, ROOT::Math::Cylindrical3D<Double32_t>::Scalar yy, ROOT::Math::Cylindrical3D<Double32_t>::Scalar zz); voidSetY(ROOT::Math::Cylindrical3D<Double32_t>::Scalar yy); voidSetZ(Double32_t zz); ROOT::Math::Cylindrical3D<Double32_t>::ScalarTheta() const; ROOT::Math::Cylindrical3D<Double32_t>::ScalarX() const; Double32_tx() const; ROOT::Math::Cylindrical3D<Double32_t>::ScalarY() const; Double32_ty() const; ROOT::Math::Cylindrical3D<Double32_t>::ScalarZ() const; Double32_tz() const. private:. static ROOT::Math::Cylindrical3D<Double32_t>::Scalarpi(); voidRestrict(). Data Members; private:. Double32_tfPhi; Double32_tfRho; Double32_tfZ. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Cylindrical3D & operator=(const ROOT::Math::Cylindrical3D<Double32_t>& v). assignment operator. void SetCoordinates(const ROOT::Math::Cylindrical3D<Double32_t>::Scalar* src). Set internal data based on an array of 3 Scalar numbers ( rho, z , phi). { fRho=src[0]; fZ=src[1]; fPhi=src[2]; Restrict(); }. void GetCoordinates(ROOT::Math::Cylindrical3D<Double32_t>::Scalar* dest) const. get internal data into an array of 3 Scalar numbers ( rho, z , phi). { dest[0] = fRho; dest[1] = fZ; dest[2] = fPhi; }. void SetCoordinates(ROOT::Math::Cylindrical3D<Double32_t>::Scalar rho, ROOT::Math::Cylindrical3D<Double32_t>::Scalar zz, ROOT::Math::Cylindrical3D<Double32_t>::Scalar phi). Set internal data based on 3 Scalar numbers ( rho, z , phi). { fRho=rho; fZ=zz; fPhi=phi; Restrict(); }. void GetCoordinates(ROOT::Math::Cylindrical3D<Double32_t>::Scalar& rho, ROOT::Math::Cylindrical3D<Double32_t>::Scalar& zz, ROOT::Math::Cylindrical3D<Double32_t>::Scalar&",MatchSource.WIKI,root/html532/ROOT__Math__Cylindrical3D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Cylindrical3D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__Cylindrical3D_Double32_t_.html:4653,Security,access,accessors,4653,"ates(const ROOT::Math::Cylindrical3D<Double32_t>::Scalar* src). Set internal data based on an array of 3 Scalar numbers ( rho, z , phi). { fRho=src[0]; fZ=src[1]; fPhi=src[2]; Restrict(); }. void GetCoordinates(ROOT::Math::Cylindrical3D<Double32_t>::Scalar* dest) const. get internal data into an array of 3 Scalar numbers ( rho, z , phi). { dest[0] = fRho; dest[1] = fZ; dest[2] = fPhi; }. void SetCoordinates(ROOT::Math::Cylindrical3D<Double32_t>::Scalar rho, ROOT::Math::Cylindrical3D<Double32_t>::Scalar zz, ROOT::Math::Cylindrical3D<Double32_t>::Scalar phi). Set internal data based on 3 Scalar numbers ( rho, z , phi). { fRho=rho; fZ=zz; fPhi=phi; Restrict(); }. void GetCoordinates(ROOT::Math::Cylindrical3D<Double32_t>::Scalar& rho, ROOT::Math::Cylindrical3D<Double32_t>::Scalar& zz, ROOT::Math::Cylindrical3D<Double32_t>::Scalar& phi) const. get internal data into 3 Scalar numbers ( rho, z , phi). {rho=fRho; zz=fZ; phi=fPhi;}. Scalar pi(); { return M_PI; }. void Restrict(). Scalar Rho() const; accessors. { return fRho; }. Scalar Z() const; { return fZ; }. Scalar Phi() const; { return fPhi; }. Scalar X() const; { return fRho*std::cos(fPhi); }. Scalar Y() const; { return fRho*std::sin(fPhi); }. Scalar Mag2() const; { return fRho*fRho + fZ*fZ; }. Scalar R() const; { return std::sqrt( Mag2()); }. Scalar Perp2() const; { return fRho*fRho; }. Scalar Theta() const; { return (fRho==0 && fZ==0 ) ? 0 : atan2(fRho,fZ); }. Scalar Eta() const; pseudorapidity - use same implementation as in Cartesian3D. void SetRho(Double32_t rho); setters (only for data members). set the rho coordinate value keeping z and phi constant. void SetZ(Double32_t zz). set the z coordinate value keeping rho and phi constant. void SetPhi(Double32_t phi). set the phi coordinate value keeping rho and z constant. void SetXYZ(ROOT::Math::Cylindrical3D<Double32_t>::Scalar xx, ROOT::Math::Cylindrical3D<Double32_t>::Scalar yy, ROOT::Math::Cylindrical3D<Double32_t>::Scalar zz). set all values using cartesian coordin",MatchSource.WIKI,root/html532/ROOT__Math__Cylindrical3D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Cylindrical3D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__Cylindrical3D_double_.html:3231,Modifiability,Inherit,Inheritance,3231,"zz, ROOT::Math::Cylindrical3D<double>::Scalar phi); voidSetEta(ROOT::Math::Cylindrical3D<double>::Scalar eta); voidSetPhi(double phi); voidSetR(ROOT::Math::Cylindrical3D<double>::Scalar r); voidSetRho(double rho); voidSetTheta(ROOT::Math::Cylindrical3D<double>::Scalar theta); voidSetX(ROOT::Math::Cylindrical3D<double>::Scalar xx); voidSetXYZ(ROOT::Math::Cylindrical3D<double>::Scalar xx, ROOT::Math::Cylindrical3D<double>::Scalar yy, ROOT::Math::Cylindrical3D<double>::Scalar zz); voidSetY(ROOT::Math::Cylindrical3D<double>::Scalar yy); voidSetZ(double zz); ROOT::Math::Cylindrical3D<double>::ScalarTheta() const; ROOT::Math::Cylindrical3D<double>::ScalarX() const; doublex() const; ROOT::Math::Cylindrical3D<double>::ScalarY() const; doubley() const; ROOT::Math::Cylindrical3D<double>::ScalarZ() const; doublez() const. private:. static ROOT::Math::Cylindrical3D<double>::Scalarpi(); voidRestrict(). Data Members; private:. doublefPhi; doublefRho; doublefZ. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Cylindrical3D & operator=(const ROOT::Math::Cylindrical3D<double>& v). assignment operator. void SetCoordinates(const ROOT::Math::Cylindrical3D<double>::Scalar* src). Set internal data based on an array of 3 Scalar numbers ( rho, z , phi). { fRho=src[0]; fZ=src[1]; fPhi=src[2]; Restrict(); }. void GetCoordinates(ROOT::Math::Cylindrical3D<double>::Scalar* dest) const. get internal data into an array of 3 Scalar numbers ( rho, z , phi). { dest[0] = fRho; dest[1] = fZ; dest[2] = fPhi; }. void SetCoordinates(ROOT::Math::Cylindrical3D<double>::Scalar rho, ROOT::Math::Cylindrical3D<double>::Scalar zz, ROOT::Math::Cylindrical3D<double>::Scalar phi). Set internal data based on 3 Scalar numbers ( rho, z , phi). { fRho=rho; fZ=zz; fPhi=phi; Restrict(); }. void GetCoordinates(ROOT::Math::Cylindrical3D<double>::Scalar& rho, ROOT::Math::Cylindrical3D<double>::Scalar& zz, ROOT::Math::Cylindrical3D<double>::Scalar& phi) const. get internal data into ",MatchSource.WIKI,root/html532/ROOT__Math__Cylindrical3D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Cylindrical3D_double_.html
https://root.cern/root/html532/ROOT__Math__Cylindrical3D_double_.html:3244,Modifiability,Inherit,Inherited,3244,"zz, ROOT::Math::Cylindrical3D<double>::Scalar phi); voidSetEta(ROOT::Math::Cylindrical3D<double>::Scalar eta); voidSetPhi(double phi); voidSetR(ROOT::Math::Cylindrical3D<double>::Scalar r); voidSetRho(double rho); voidSetTheta(ROOT::Math::Cylindrical3D<double>::Scalar theta); voidSetX(ROOT::Math::Cylindrical3D<double>::Scalar xx); voidSetXYZ(ROOT::Math::Cylindrical3D<double>::Scalar xx, ROOT::Math::Cylindrical3D<double>::Scalar yy, ROOT::Math::Cylindrical3D<double>::Scalar zz); voidSetY(ROOT::Math::Cylindrical3D<double>::Scalar yy); voidSetZ(double zz); ROOT::Math::Cylindrical3D<double>::ScalarTheta() const; ROOT::Math::Cylindrical3D<double>::ScalarX() const; doublex() const; ROOT::Math::Cylindrical3D<double>::ScalarY() const; doubley() const; ROOT::Math::Cylindrical3D<double>::ScalarZ() const; doublez() const. private:. static ROOT::Math::Cylindrical3D<double>::Scalarpi(); voidRestrict(). Data Members; private:. doublefPhi; doublefRho; doublefZ. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Cylindrical3D & operator=(const ROOT::Math::Cylindrical3D<double>& v). assignment operator. void SetCoordinates(const ROOT::Math::Cylindrical3D<double>::Scalar* src). Set internal data based on an array of 3 Scalar numbers ( rho, z , phi). { fRho=src[0]; fZ=src[1]; fPhi=src[2]; Restrict(); }. void GetCoordinates(ROOT::Math::Cylindrical3D<double>::Scalar* dest) const. get internal data into an array of 3 Scalar numbers ( rho, z , phi). { dest[0] = fRho; dest[1] = fZ; dest[2] = fPhi; }. void SetCoordinates(ROOT::Math::Cylindrical3D<double>::Scalar rho, ROOT::Math::Cylindrical3D<double>::Scalar zz, ROOT::Math::Cylindrical3D<double>::Scalar phi). Set internal data based on 3 Scalar numbers ( rho, z , phi). { fRho=rho; fZ=zz; fPhi=phi; Restrict(); }. void GetCoordinates(ROOT::Math::Cylindrical3D<double>::Scalar& rho, ROOT::Math::Cylindrical3D<double>::Scalar& zz, ROOT::Math::Cylindrical3D<double>::Scalar& phi) const. get internal data into ",MatchSource.WIKI,root/html532/ROOT__Math__Cylindrical3D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Cylindrical3D_double_.html
https://root.cern/root/html532/ROOT__Math__Cylindrical3D_double_.html:4389,Security,access,accessors,4389,"gnment operator. void SetCoordinates(const ROOT::Math::Cylindrical3D<double>::Scalar* src). Set internal data based on an array of 3 Scalar numbers ( rho, z , phi). { fRho=src[0]; fZ=src[1]; fPhi=src[2]; Restrict(); }. void GetCoordinates(ROOT::Math::Cylindrical3D<double>::Scalar* dest) const. get internal data into an array of 3 Scalar numbers ( rho, z , phi). { dest[0] = fRho; dest[1] = fZ; dest[2] = fPhi; }. void SetCoordinates(ROOT::Math::Cylindrical3D<double>::Scalar rho, ROOT::Math::Cylindrical3D<double>::Scalar zz, ROOT::Math::Cylindrical3D<double>::Scalar phi). Set internal data based on 3 Scalar numbers ( rho, z , phi). { fRho=rho; fZ=zz; fPhi=phi; Restrict(); }. void GetCoordinates(ROOT::Math::Cylindrical3D<double>::Scalar& rho, ROOT::Math::Cylindrical3D<double>::Scalar& zz, ROOT::Math::Cylindrical3D<double>::Scalar& phi) const. get internal data into 3 Scalar numbers ( rho, z , phi). {rho=fRho; zz=fZ; phi=fPhi;}. Scalar pi(); { return M_PI; }. void Restrict(). Scalar Rho() const; accessors. { return fRho; }. Scalar Z() const; { return fZ; }. Scalar Phi() const; { return fPhi; }. Scalar X() const; { return fRho*std::cos(fPhi); }. Scalar Y() const; { return fRho*std::sin(fPhi); }. Scalar Mag2() const; { return fRho*fRho + fZ*fZ; }. Scalar R() const; { return std::sqrt( Mag2()); }. Scalar Perp2() const; { return fRho*fRho; }. Scalar Theta() const; { return (fRho==0 && fZ==0 ) ? 0 : atan2(fRho,fZ); }. Scalar Eta() const; pseudorapidity - use same implementation as in Cartesian3D. void SetRho(double rho); setters (only for data members). set the rho coordinate value keeping z and phi constant. void SetZ(double zz). set the z coordinate value keeping rho and phi constant. void SetPhi(double phi). set the phi coordinate value keeping rho and z constant. void SetXYZ(ROOT::Math::Cylindrical3D<double>::Scalar xx, ROOT::Math::Cylindrical3D<double>::Scalar yy, ROOT::Math::Cylindrical3D<double>::Scalar zz). set all values using cartesian coordinates. void Scale(double ",MatchSource.WIKI,root/html532/ROOT__Math__Cylindrical3D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Cylindrical3D_double_.html
https://root.cern/root/html532/ROOT__Math__CylindricalEta3D_Double32_t_.html:3756,Modifiability,Inherit,Inheritance,3756,"e32_t>::Scalar eta, ROOT::Math::CylindricalEta3D<Double32_t>::Scalar phi); voidSetEta(Double32_t eta); voidSetPhi(Double32_t phi); voidSetR(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar r); voidSetRho(Double32_t rho); voidSetTheta(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar theta); voidSetX(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar xx); voidSetXYZ(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar xx, ROOT::Math::CylindricalEta3D<Double32_t>::Scalar yy, ROOT::Math::CylindricalEta3D<Double32_t>::Scalar zz); voidSetY(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar yy); voidSetZ(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar zz); Double32_tTheta() const; Double32_tX() const; Double32_tx() const; Double32_tY() const; Double32_ty() const; Double32_tZ() const; Double32_tz() const. private:. static ROOT::Math::CylindricalEta3D<Double32_t>::Scalarpi(); voidRestrict(). Data Members; private:. Double32_tfEta; Double32_tfPhi; Double32_tfRho. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CylindricalEta3D & operator=(const ROOT::Math::CylindricalEta3D<Double32_t>& v). assignment operator. void SetCoordinates(const ROOT::Math::CylindricalEta3D<Double32_t>::Scalar* src). Set internal data based on an array of 3 Scalar numbers. { fRho=src[0]; fEta=src[1]; fPhi=src[2]; Restrict(); }. void GetCoordinates(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar* dest) const. get internal data into an array of 3 Scalar numbers. { dest[0] = fRho; dest[1] = fEta; dest[2] = fPhi; }. void SetCoordinates(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar rho, ROOT::Math::CylindricalEta3D<Double32_t>::Scalar eta, ROOT::Math::CylindricalEta3D<Double32_t>::Scalar phi). Set internal data based on 3 Scalar numbers. { fRho=rho; fEta=eta; fPhi=phi; Restrict(); }. void GetCoordinates(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar& rho, ROOT::Math::CylindricalEta3D<Double32_t>::Scalar& eta, ROOT::Math::CylindricalEta3D<Double32_t>::Scalar& phi) con",MatchSource.WIKI,root/html532/ROOT__Math__CylindricalEta3D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__CylindricalEta3D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__CylindricalEta3D_Double32_t_.html:3769,Modifiability,Inherit,Inherited,3769,"e32_t>::Scalar eta, ROOT::Math::CylindricalEta3D<Double32_t>::Scalar phi); voidSetEta(Double32_t eta); voidSetPhi(Double32_t phi); voidSetR(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar r); voidSetRho(Double32_t rho); voidSetTheta(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar theta); voidSetX(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar xx); voidSetXYZ(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar xx, ROOT::Math::CylindricalEta3D<Double32_t>::Scalar yy, ROOT::Math::CylindricalEta3D<Double32_t>::Scalar zz); voidSetY(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar yy); voidSetZ(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar zz); Double32_tTheta() const; Double32_tX() const; Double32_tx() const; Double32_tY() const; Double32_ty() const; Double32_tZ() const; Double32_tz() const. private:. static ROOT::Math::CylindricalEta3D<Double32_t>::Scalarpi(); voidRestrict(). Data Members; private:. Double32_tfEta; Double32_tfPhi; Double32_tfRho. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CylindricalEta3D & operator=(const ROOT::Math::CylindricalEta3D<Double32_t>& v). assignment operator. void SetCoordinates(const ROOT::Math::CylindricalEta3D<Double32_t>::Scalar* src). Set internal data based on an array of 3 Scalar numbers. { fRho=src[0]; fEta=src[1]; fPhi=src[2]; Restrict(); }. void GetCoordinates(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar* dest) const. get internal data into an array of 3 Scalar numbers. { dest[0] = fRho; dest[1] = fEta; dest[2] = fPhi; }. void SetCoordinates(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar rho, ROOT::Math::CylindricalEta3D<Double32_t>::Scalar eta, ROOT::Math::CylindricalEta3D<Double32_t>::Scalar phi). Set internal data based on 3 Scalar numbers. { fRho=rho; fEta=eta; fPhi=phi; Restrict(); }. void GetCoordinates(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar& rho, ROOT::Math::CylindricalEta3D<Double32_t>::Scalar& eta, ROOT::Math::CylindricalEta3D<Double32_t>::Scalar& phi) con",MatchSource.WIKI,root/html532/ROOT__Math__CylindricalEta3D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__CylindricalEta3D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__CylindricalEta3D_Double32_t_.html:4923,Security,access,accessors,4923,"ment operator. void SetCoordinates(const ROOT::Math::CylindricalEta3D<Double32_t>::Scalar* src). Set internal data based on an array of 3 Scalar numbers. { fRho=src[0]; fEta=src[1]; fPhi=src[2]; Restrict(); }. void GetCoordinates(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar* dest) const. get internal data into an array of 3 Scalar numbers. { dest[0] = fRho; dest[1] = fEta; dest[2] = fPhi; }. void SetCoordinates(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar rho, ROOT::Math::CylindricalEta3D<Double32_t>::Scalar eta, ROOT::Math::CylindricalEta3D<Double32_t>::Scalar phi). Set internal data based on 3 Scalar numbers. { fRho=rho; fEta=eta; fPhi=phi; Restrict(); }. void GetCoordinates(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar& rho, ROOT::Math::CylindricalEta3D<Double32_t>::Scalar& eta, ROOT::Math::CylindricalEta3D<Double32_t>::Scalar& phi) const. get internal data into 3 Scalar numbers. {rho=fRho; eta=fEta; phi=fPhi;}. Scalar pi(); { return M_PI; }. void Restrict(). T Rho() const; accessors. { return fRho; }. T Eta() const; { return fEta; }. T Phi() const; { return fPhi; }. T X() const; { return fRho*std::cos(fPhi); }. T Y() const; { return fRho*std::sin(fPhi); }. T Z() const. T R() const. T Mag2() const; { return R()*R(); }. T Perp2() const; { return fRho*fRho; }. T Theta() const. void SetRho(Double32_t rho); setters (only for data members). set the rho coordinate value keeping eta and phi constant. void SetEta(Double32_t eta). set the eta coordinate value keeping rho and phi constant. void SetPhi(Double32_t phi). set the phi coordinate value keeping rho and eta constant. void SetXYZ(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar xx, ROOT::Math::CylindricalEta3D<Double32_t>::Scalar yy, ROOT::Math::CylindricalEta3D<Double32_t>::Scalar zz). set all values using cartesian coordinates. void Scale(Double32_t a). scale by a scalar quantity a --; for cylindrical eta coords, as long as a >= 0, only rho changes!. Negate(). bool operator==(const ROOT::Math::Cylindri",MatchSource.WIKI,root/html532/ROOT__Math__CylindricalEta3D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__CylindricalEta3D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__CylindricalEta3D_Double32_t_.html:6068,Testability,test,test,6068,"onst; { return fRho*std::cos(fPhi); }. T Y() const; { return fRho*std::sin(fPhi); }. T Z() const. T R() const. T Mag2() const; { return R()*R(); }. T Perp2() const; { return fRho*fRho; }. T Theta() const. void SetRho(Double32_t rho); setters (only for data members). set the rho coordinate value keeping eta and phi constant. void SetEta(Double32_t eta). set the eta coordinate value keeping rho and phi constant. void SetPhi(Double32_t phi). set the phi coordinate value keeping rho and eta constant. void SetXYZ(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar xx, ROOT::Math::CylindricalEta3D<Double32_t>::Scalar yy, ROOT::Math::CylindricalEta3D<Double32_t>::Scalar zz). set all values using cartesian coordinates. void Scale(Double32_t a). scale by a scalar quantity a --; for cylindrical eta coords, as long as a >= 0, only rho changes!. Negate(). bool operator==(const ROOT::Math::CylindricalEta3D<Double32_t>& rhs) const. Exact component-by-component equality; Note: Peculiar representaions of the zero vector such as (0,1,0) will; not test as equal to one another. bool operator!=(const ROOT::Math::CylindricalEta3D<Double32_t>& rhs) const; {return !(operator==(rhs));}. T x() const; ============= Compatibility section ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X();}. T y() const; { return Y();}. T z() const; { return Z(); }. void SetX(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar xx); ============= Specializations for improved speed ==================; (none); ====== Set member functions for coordinates in other systems =======. void SetY(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar yy). void SetZ(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar zz). void SetR(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar r). void SetTheta(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar theta).  Last changed: root/mathcore:$Id: CylindricalEta3D.h 31938 2009-12-18 1",MatchSource.WIKI,root/html532/ROOT__Math__CylindricalEta3D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__CylindricalEta3D_Double32_t_.html
https://root.cern/root/html532/ROOT__Math__CylindricalEta3D_double_.html:3018,Modifiability,Inherit,Inheritance,3018,"Coordinates(ROOT::Math::CylindricalEta3D<double>::Scalar rho, ROOT::Math::CylindricalEta3D<double>::Scalar eta, ROOT::Math::CylindricalEta3D<double>::Scalar phi); voidSetEta(double eta); voidSetPhi(double phi); voidSetR(ROOT::Math::CylindricalEta3D<double>::Scalar r); voidSetRho(double rho); voidSetTheta(ROOT::Math::CylindricalEta3D<double>::Scalar theta); voidSetX(ROOT::Math::CylindricalEta3D<double>::Scalar xx); voidSetXYZ(ROOT::Math::CylindricalEta3D<double>::Scalar xx, ROOT::Math::CylindricalEta3D<double>::Scalar yy, ROOT::Math::CylindricalEta3D<double>::Scalar zz); voidSetY(ROOT::Math::CylindricalEta3D<double>::Scalar yy); voidSetZ(ROOT::Math::CylindricalEta3D<double>::Scalar zz); doubleTheta() const; doubleX() const; doublex() const; doubleY() const; doubley() const; doubleZ() const; doublez() const. private:. static ROOT::Math::CylindricalEta3D<double>::Scalarpi(); voidRestrict(). Data Members; private:. doublefEta; doublefPhi; doublefRho. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CylindricalEta3D & operator=(const ROOT::Math::CylindricalEta3D<double>& v). assignment operator. void SetCoordinates(const ROOT::Math::CylindricalEta3D<double>::Scalar* src). Set internal data based on an array of 3 Scalar numbers. { fRho=src[0]; fEta=src[1]; fPhi=src[2]; Restrict(); }. void GetCoordinates(ROOT::Math::CylindricalEta3D<double>::Scalar* dest) const. get internal data into an array of 3 Scalar numbers. { dest[0] = fRho; dest[1] = fEta; dest[2] = fPhi; }. void SetCoordinates(ROOT::Math::CylindricalEta3D<double>::Scalar rho, ROOT::Math::CylindricalEta3D<double>::Scalar eta, ROOT::Math::CylindricalEta3D<double>::Scalar phi). Set internal data based on 3 Scalar numbers. { fRho=rho; fEta=eta; fPhi=phi; Restrict(); }. void GetCoordinates(ROOT::Math::CylindricalEta3D<double>::Scalar& rho, ROOT::Math::CylindricalEta3D<double>::Scalar& eta, ROOT::Math::CylindricalEta3D<double>::Scalar& phi) const. get internal data into 3 Scalar ",MatchSource.WIKI,root/html532/ROOT__Math__CylindricalEta3D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__CylindricalEta3D_double_.html
https://root.cern/root/html532/ROOT__Math__CylindricalEta3D_double_.html:3031,Modifiability,Inherit,Inherited,3031,"Coordinates(ROOT::Math::CylindricalEta3D<double>::Scalar rho, ROOT::Math::CylindricalEta3D<double>::Scalar eta, ROOT::Math::CylindricalEta3D<double>::Scalar phi); voidSetEta(double eta); voidSetPhi(double phi); voidSetR(ROOT::Math::CylindricalEta3D<double>::Scalar r); voidSetRho(double rho); voidSetTheta(ROOT::Math::CylindricalEta3D<double>::Scalar theta); voidSetX(ROOT::Math::CylindricalEta3D<double>::Scalar xx); voidSetXYZ(ROOT::Math::CylindricalEta3D<double>::Scalar xx, ROOT::Math::CylindricalEta3D<double>::Scalar yy, ROOT::Math::CylindricalEta3D<double>::Scalar zz); voidSetY(ROOT::Math::CylindricalEta3D<double>::Scalar yy); voidSetZ(ROOT::Math::CylindricalEta3D<double>::Scalar zz); doubleTheta() const; doubleX() const; doublex() const; doubleY() const; doubley() const; doubleZ() const; doublez() const. private:. static ROOT::Math::CylindricalEta3D<double>::Scalarpi(); voidRestrict(). Data Members; private:. doublefEta; doublefPhi; doublefRho. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CylindricalEta3D & operator=(const ROOT::Math::CylindricalEta3D<double>& v). assignment operator. void SetCoordinates(const ROOT::Math::CylindricalEta3D<double>::Scalar* src). Set internal data based on an array of 3 Scalar numbers. { fRho=src[0]; fEta=src[1]; fPhi=src[2]; Restrict(); }. void GetCoordinates(ROOT::Math::CylindricalEta3D<double>::Scalar* dest) const. get internal data into an array of 3 Scalar numbers. { dest[0] = fRho; dest[1] = fEta; dest[2] = fPhi; }. void SetCoordinates(ROOT::Math::CylindricalEta3D<double>::Scalar rho, ROOT::Math::CylindricalEta3D<double>::Scalar eta, ROOT::Math::CylindricalEta3D<double>::Scalar phi). Set internal data based on 3 Scalar numbers. { fRho=rho; fEta=eta; fPhi=phi; Restrict(); }. void GetCoordinates(ROOT::Math::CylindricalEta3D<double>::Scalar& rho, ROOT::Math::CylindricalEta3D<double>::Scalar& eta, ROOT::Math::CylindricalEta3D<double>::Scalar& phi) const. get internal data into 3 Scalar ",MatchSource.WIKI,root/html532/ROOT__Math__CylindricalEta3D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__CylindricalEta3D_double_.html
https://root.cern/root/html532/ROOT__Math__CylindricalEta3D_double_.html:4149,Security,access,accessors,4149,"ndricalEta3D<double>& v). assignment operator. void SetCoordinates(const ROOT::Math::CylindricalEta3D<double>::Scalar* src). Set internal data based on an array of 3 Scalar numbers. { fRho=src[0]; fEta=src[1]; fPhi=src[2]; Restrict(); }. void GetCoordinates(ROOT::Math::CylindricalEta3D<double>::Scalar* dest) const. get internal data into an array of 3 Scalar numbers. { dest[0] = fRho; dest[1] = fEta; dest[2] = fPhi; }. void SetCoordinates(ROOT::Math::CylindricalEta3D<double>::Scalar rho, ROOT::Math::CylindricalEta3D<double>::Scalar eta, ROOT::Math::CylindricalEta3D<double>::Scalar phi). Set internal data based on 3 Scalar numbers. { fRho=rho; fEta=eta; fPhi=phi; Restrict(); }. void GetCoordinates(ROOT::Math::CylindricalEta3D<double>::Scalar& rho, ROOT::Math::CylindricalEta3D<double>::Scalar& eta, ROOT::Math::CylindricalEta3D<double>::Scalar& phi) const. get internal data into 3 Scalar numbers. {rho=fRho; eta=fEta; phi=fPhi;}. Scalar pi(); { return M_PI; }. void Restrict(). T Rho() const; accessors. { return fRho; }. T Eta() const; { return fEta; }. T Phi() const; { return fPhi; }. T X() const; { return fRho*std::cos(fPhi); }. T Y() const; { return fRho*std::sin(fPhi); }. T Z() const. T R() const. T Mag2() const; { return R()*R(); }. T Perp2() const; { return fRho*fRho; }. T Theta() const. void SetRho(double rho); setters (only for data members). set the rho coordinate value keeping eta and phi constant. void SetEta(double eta). set the eta coordinate value keeping rho and phi constant. void SetPhi(double phi). set the phi coordinate value keeping rho and eta constant. void SetXYZ(ROOT::Math::CylindricalEta3D<double>::Scalar xx, ROOT::Math::CylindricalEta3D<double>::Scalar yy, ROOT::Math::CylindricalEta3D<double>::Scalar zz). set all values using cartesian coordinates. void Scale(double a). scale by a scalar quantity a --; for cylindrical eta coords, as long as a >= 0, only rho changes!. Negate(). bool operator==(const ROOT::Math::CylindricalEta3D<double>& rhs) const",MatchSource.WIKI,root/html532/ROOT__Math__CylindricalEta3D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__CylindricalEta3D_double_.html
https://root.cern/root/html532/ROOT__Math__CylindricalEta3D_double_.html:5262,Testability,test,test,5262,"const; { return fPhi; }. T X() const; { return fRho*std::cos(fPhi); }. T Y() const; { return fRho*std::sin(fPhi); }. T Z() const. T R() const. T Mag2() const; { return R()*R(); }. T Perp2() const; { return fRho*fRho; }. T Theta() const. void SetRho(double rho); setters (only for data members). set the rho coordinate value keeping eta and phi constant. void SetEta(double eta). set the eta coordinate value keeping rho and phi constant. void SetPhi(double phi). set the phi coordinate value keeping rho and eta constant. void SetXYZ(ROOT::Math::CylindricalEta3D<double>::Scalar xx, ROOT::Math::CylindricalEta3D<double>::Scalar yy, ROOT::Math::CylindricalEta3D<double>::Scalar zz). set all values using cartesian coordinates. void Scale(double a). scale by a scalar quantity a --; for cylindrical eta coords, as long as a >= 0, only rho changes!. Negate(). bool operator==(const ROOT::Math::CylindricalEta3D<double>& rhs) const. Exact component-by-component equality; Note: Peculiar representaions of the zero vector such as (0,1,0) will; not test as equal to one another. bool operator!=(const ROOT::Math::CylindricalEta3D<double>& rhs) const; {return !(operator==(rhs));}. T x() const; ============= Compatibility section ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X();}. T y() const; { return Y();}. T z() const; { return Z(); }. void SetX(ROOT::Math::CylindricalEta3D<double>::Scalar xx); ============= Specializations for improved speed ==================; (none); ====== Set member functions for coordinates in other systems =======. void SetY(ROOT::Math::CylindricalEta3D<double>::Scalar yy). void SetZ(ROOT::Math::CylindricalEta3D<double>::Scalar zz). void SetR(ROOT::Math::CylindricalEta3D<double>::Scalar r). void SetTheta(ROOT::Math::CylindricalEta3D<double>::Scalar theta).  Last changed: root/mathcore:$Id: CylindricalEta3D.h 31938 2009-12-18 14:49:38Z moneta $  Last",MatchSource.WIKI,root/html532/ROOT__Math__CylindricalEta3D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__CylindricalEta3D_double_.html
https://root.cern/root/html532/ROOT__Math__DefaultCoordinateSystemTag.html:3645,Modifiability,Inherit,Inheritance,3645,"ag, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::CoordinateSystemTag, ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::CoordinateSystemTag, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::CoordinateSystemTag, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::CoordinateSystemTag, ROOT::Math::PositionVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::CoordinateSystemTag, ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::CoordinateSystemTag, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::CoordinateSystemTag, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::CoordinateSystemTag, ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::CoordinateSystemTag, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::CoordinateSystemTag. Function Members (Methods); public:. ~DefaultCoordinateSystemTag(); ROOT::Math::DefaultCoordinateSystemTagDefaultCoordinateSystemTag(); ROOT::Math::DefaultCoordinateSystemTagDefaultCoordinateSystemTag(const ROOT::Math::DefaultCoordinateSystemTag&); ROOT::Math::DefaultCoordinateSystemTag&operator=(const ROOT::Math::DefaultCoordinateSystemTag&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation.  Last changed: root/mathcore:$Id: CoordinateSystemTags.h 22516 2008-03-07 15:14:26Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__DefaultCoordinateSystemTag.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DefaultCoordinateSystemTag.html
https://root.cern/root/html532/ROOT__Math__DefaultCoordinateSystemTag.html:3658,Modifiability,Inherit,Inherited,3658,"ag, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::CoordinateSystemTag, ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::CoordinateSystemTag, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::CoordinateSystemTag, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::CoordinateSystemTag, ROOT::Math::PositionVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::CoordinateSystemTag, ROOT::Math::PositionVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::CoordinateSystemTag, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::CoordinateSystemTag, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::CoordinateSystemTag, ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::CoordinateSystemTag, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::CoordinateSystemTag. Function Members (Methods); public:. ~DefaultCoordinateSystemTag(); ROOT::Math::DefaultCoordinateSystemTagDefaultCoordinateSystemTag(); ROOT::Math::DefaultCoordinateSystemTagDefaultCoordinateSystemTag(const ROOT::Math::DefaultCoordinateSystemTag&); ROOT::Math::DefaultCoordinateSystemTag&operator=(const ROOT::Math::DefaultCoordinateSystemTag&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation.  Last changed: root/mathcore:$Id: CoordinateSystemTags.h 22516 2008-03-07 15:14:26Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__DefaultCoordinateSystemTag.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DefaultCoordinateSystemTag.html
https://root.cern/root/html532/ROOT__Math__Derivator.html:4199,Availability,Error,Error,4199,"vator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8); @name --- Static methods ---; This methods don't require to use a Derivator object, and are designed to be used in; fast calculation. Error and status code cannot be retrieved in this case. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x its",MatchSource.WIKI,root/html532/ROOT__Math__Derivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Derivator.html
https://root.cern/root/html532/ROOT__Math__Derivator.html:6045,Availability,error,error,6045,"ical derivative of a function f at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IMultiGenFunction& f, const double* x, unsigned int icoord = 0, double h = 1E-8); Derivatives for multi-dimension functions. Evaluate the partial derivative of a multi-dim function; with respect coordinate x_icoord at the point x[]. double Eval(ROOT::Math::IParamFunction& f, double x, const double* p, unsigned int ipar = 0, double h = 1E-8). Evaluate the derivative with respect a parameter for one-dim parameteric function; at the point ( x,p[]) with respect the parameter p_ipar. double Eval(ROOT::Math::IParamMultiFunction& f, const double* x, const double* p, unsigned int ipar = 0, double h = 1E-8). Evaluate the derivative with respect a parameter for a multi-dim parameteric function; at the point ( x[],p[]) with respect the parameter p_ipar. int Status() const. return the error status of the last derivative calculation. double Result() const. return the result of the last derivative calculation. double Error() const. return the estimate of the absolute error of the last derivative calculation.  Last changed: root/mathmore:$Id: Derivator.h 21503 2007-12-19 17:34:54Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__Derivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Derivator.html
https://root.cern/root/html532/ROOT__Math__Derivator.html:6178,Availability,Error,Error,6178,"ical derivative of a function f at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IMultiGenFunction& f, const double* x, unsigned int icoord = 0, double h = 1E-8); Derivatives for multi-dimension functions. Evaluate the partial derivative of a multi-dim function; with respect coordinate x_icoord at the point x[]. double Eval(ROOT::Math::IParamFunction& f, double x, const double* p, unsigned int ipar = 0, double h = 1E-8). Evaluate the derivative with respect a parameter for one-dim parameteric function; at the point ( x,p[]) with respect the parameter p_ipar. double Eval(ROOT::Math::IParamMultiFunction& f, const double* x, const double* p, unsigned int ipar = 0, double h = 1E-8). Evaluate the derivative with respect a parameter for a multi-dim parameteric function; at the point ( x[],p[]) with respect the parameter p_ipar. int Status() const. return the error status of the last derivative calculation. double Result() const. return the result of the last derivative calculation. double Error() const. return the estimate of the absolute error of the last derivative calculation.  Last changed: root/mathmore:$Id: Derivator.h 21503 2007-12-19 17:34:54Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__Derivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Derivator.html
https://root.cern/root/html532/ROOT__Math__Derivator.html:6229,Availability,error,error,6229,"ical derivative of a function f at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IMultiGenFunction& f, const double* x, unsigned int icoord = 0, double h = 1E-8); Derivatives for multi-dimension functions. Evaluate the partial derivative of a multi-dim function; with respect coordinate x_icoord at the point x[]. double Eval(ROOT::Math::IParamFunction& f, double x, const double* p, unsigned int ipar = 0, double h = 1E-8). Evaluate the derivative with respect a parameter for one-dim parameteric function; at the point ( x,p[]) with respect the parameter p_ipar. double Eval(ROOT::Math::IParamMultiFunction& f, const double* x, const double* p, unsigned int ipar = 0, double h = 1E-8). Evaluate the derivative with respect a parameter for a multi-dim parameteric function; at the point ( x[],p[]) with respect the parameter p_ipar. int Status() const. return the error status of the last derivative calculation. double Result() const. return the result of the last derivative calculation. double Error() const. return the estimate of the absolute error of the last derivative calculation.  Last changed: root/mathmore:$Id: Derivator.h 21503 2007-12-19 17:34:54Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__Derivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Derivator.html
https://root.cern/root/html532/ROOT__Math__Derivator.html:3281,Energy Efficiency,adapt,adaptive,3281,"n afterwards with Derivator::SetFunction. explicit Derivator(const IGenFunction &f). Construct using a ROOT::Math::IGenFunction interface. explicit Derivator(const ROOT::Math::Derivator::GSLFuncPointer& f, void* p = 0). Construct using a GSL function pointer type; @param f : free function pointer of the GSL required type; @param p : pointer to the object carrying the function state; (for example the function object itself). virtual ~Derivator(); destructor. Derivator(const Derivator &); disable copying. void SetFunction(const ROOT::Math::IGenFunction& f). Template methods for generic functions; Set the function f for evaluating the derivative.; The function type must implement the assigment operator,; <em> double operator() ( double x ) </em>. SetFunction(const ROOT::Math::Derivator::GSLFuncPointer& f, void* p = 0). double Eval(double x, double h = 1E-8) const. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8); @name --- Static methods ---; This methods don't require to use a Derivator object, and are designed to be used in; fast calculation. Error and status code cannot be retrieved in this case. Computes the numeric",MatchSource.WIKI,root/html532/ROOT__Math__Derivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Derivator.html
https://root.cern/root/html532/ROOT__Math__Derivator.html:3448,Energy Efficiency,adapt,adaptive,3448,"h::Derivator::GSLFuncPointer& f, void* p = 0). Construct using a GSL function pointer type; @param f : free function pointer of the GSL required type; @param p : pointer to the object carrying the function state; (for example the function object itself). virtual ~Derivator(); destructor. Derivator(const Derivator &); disable copying. void SetFunction(const ROOT::Math::IGenFunction& f). Template methods for generic functions; Set the function f for evaluating the derivative.; The function type must implement the assigment operator,; <em> double operator() ( double x ) </em>. SetFunction(const ROOT::Math::Derivator::GSLFuncPointer& f, void* p = 0). double Eval(double x, double h = 1E-8) const. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8); @name --- Static methods ---; This methods don't require to use a Derivator object, and are designed to be used in; fast calculation. Error and status code cannot be retrieved in this case. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. doub",MatchSource.WIKI,root/html532/ROOT__Math__Derivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Derivator.html
https://root.cern/root/html532/ROOT__Math__Derivator.html:3616,Energy Efficiency,adapt,adaptive,3616,"r to the object carrying the function state; (for example the function object itself). virtual ~Derivator(); destructor. Derivator(const Derivator &); disable copying. void SetFunction(const ROOT::Math::IGenFunction& f). Template methods for generic functions; Set the function f for evaluating the derivative.; The function type must implement the assigment operator,; <em> double operator() ( double x ) </em>. SetFunction(const ROOT::Math::Derivator::GSLFuncPointer& f, void* p = 0). double Eval(double x, double h = 1E-8) const. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8); @name --- Static methods ---; This methods don't require to use a Derivator object, and are designed to be used in; fast calculation. Error and status code cannot be retrieved in this case. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive central; ",MatchSource.WIKI,root/html532/ROOT__Math__Derivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Derivator.html
https://root.cern/root/html532/ROOT__Math__Derivator.html:3859,Energy Efficiency,adapt,adaptive,3859,"neric functions; Set the function f for evaluating the derivative.; The function type must implement the assigment operator,; <em> double operator() ( double x ) </em>. SetFunction(const ROOT::Math::Derivator::GSLFuncPointer& f, void* p = 0). double Eval(double x, double h = 1E-8) const. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8); @name --- Static methods ---; This methods don't require to use a Derivator object, and are designed to be used in; fast calculation. Error and status code cannot be retrieved in this case. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive forward; difference algorithm with a st",MatchSource.WIKI,root/html532/ROOT__Math__Derivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Derivator.html
https://root.cern/root/html532/ROOT__Math__Derivator.html:4387,Energy Efficiency,adapt,adaptive,4387,"-8) const. Computes the numerical derivative at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8); @name --- Static methods ---; This methods don't require to use a Derivator object, and are designed to be used in; fast calculation. Error and status code cannot be retrieved in this case. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IMultiGenFunction& f, const double* x, unsigned int icoord = 0, double h = 1E-8); Derivatives for multi-dimension functi",MatchSource.WIKI,root/html532/ROOT__Math__Derivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Derivator.html
https://root.cern/root/html532/ROOT__Math__Derivator.html:4599,Energy Efficiency,adapt,adaptive,4599,"ve at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8); @name --- Static methods ---; This methods don't require to use a Derivator object, and are designed to be used in; fast calculation. Error and status code cannot be retrieved in this case. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IMultiGenFunction& f, const double* x, unsigned int icoord = 0, double h = 1E-8); Derivatives for multi-dimension functions. Evaluate the partial derivative of a multi-dim function; with respect coordinate x_icoord at the point x[]. double Eval(ROOT::Math::IParamFunction& f, double x, const double* p, unsigned int ipar = 0, doubl",MatchSource.WIKI,root/html532/ROOT__Math__Derivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Derivator.html
https://root.cern/root/html532/ROOT__Math__Derivator.html:4812,Energy Efficiency,adapt,adaptive,4812,"omputes the numerical derivative at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8); @name --- Static methods ---; This methods don't require to use a Derivator object, and are designed to be used in; fast calculation. Error and status code cannot be retrieved in this case. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IMultiGenFunction& f, const double* x, unsigned int icoord = 0, double h = 1E-8); Derivatives for multi-dimension functions. Evaluate the partial derivative of a multi-dim function; with respect coordinate x_icoord at the point x[]. double Eval(ROOT::Math::IParamFunction& f, double x, const double* p, unsigned int ipar = 0, double h = 1E-8). Evaluate the derivative with respect a parameter for one-dim parameteric function; at the point ( x,p[]) with respect the parameter p_ipar. double Eval(ROOT::Math::IParamMultiFunction& f, const double",MatchSource.WIKI,root/html532/ROOT__Math__Derivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Derivator.html
https://root.cern/root/html532/ROOT__Math__Derivator.html:5100,Energy Efficiency,adapt,adaptive,5100,"; This methods don't require to use a Derivator object, and are designed to be used in; fast calculation. Error and status code cannot be retrieved in this case. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IMultiGenFunction& f, const double* x, unsigned int icoord = 0, double h = 1E-8); Derivatives for multi-dimension functions. Evaluate the partial derivative of a multi-dim function; with respect coordinate x_icoord at the point x[]. double Eval(ROOT::Math::IParamFunction& f, double x, const double* p, unsigned int ipar = 0, double h = 1E-8). Evaluate the derivative with respect a parameter for one-dim parameteric function; at the point ( x,p[]) with respect the parameter p_ipar. double Eval(ROOT::Math::IParamMultiFunction& f, const double* x, const double* p, unsigned int ipar = 0, double h = 1E-8). Evaluate the derivative with respect a parameter for a multi-dim parameteric function; at the point ( x[],p[]) with respect the parameter p_ipar. int Status() const. return the error status of the last derivative calculation.",MatchSource.WIKI,root/html532/ROOT__Math__Derivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Derivator.html
https://root.cern/root/html532/ROOT__Math__Derivator.html:2403,Integrability,interface,interface,2403,"EvalBackward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8); doubleEvalCentral(double x, double h = 1E-8) const; static doubleEvalCentral(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8); doubleEvalForward(double x, double h = 1E-8) const; static doubleEvalForward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8); doubleResult() const; voidSetFunction(const ROOT::Math::IGenFunction& f); voidSetFunction(const ROOT::Math::Derivator::GSLFuncPointer& f, void* p = 0); intStatus() const. private:. ROOT::Math::DerivatorDerivator(const ROOT::Math::Derivator&); ROOT::Math::Derivator&operator=(const ROOT::Math::Derivator&). Data Members; private:. ROOT::Math::GSLDerivator*fDerivator. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Derivator(). Empty Construct for a Derivator class; Need to set the function afterwards with Derivator::SetFunction. explicit Derivator(const IGenFunction &f). Construct using a ROOT::Math::IGenFunction interface. explicit Derivator(const ROOT::Math::Derivator::GSLFuncPointer& f, void* p = 0). Construct using a GSL function pointer type; @param f : free function pointer of the GSL required type; @param p : pointer to the object carrying the function state; (for example the function object itself). virtual ~Derivator(); destructor. Derivator(const Derivator &); disable copying. void SetFunction(const ROOT::Math::IGenFunction& f). Template methods for generic functions; Set the function f for evaluating the derivative.; The function type must implement the assigment operator,; <em> double operator() ( double x ) </em>. SetFunction(const ROOT::Math::Derivator::GSLFuncPointer& f, void* p = 0). double Eval(double x, double h = 1E-8) const. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(double x, double h = 1E-8) c",MatchSource.WIKI,root/html532/ROOT__Math__Derivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Derivator.html
https://root.cern/root/html532/ROOT__Math__Derivator.html:2123,Modifiability,Inherit,Inheritance,2123,", unsigned int ipar = 0, double h = 1E-8); static doubleEval(ROOT::Math::IParamMultiFunction& f, const double* x, const double* p, unsigned int ipar = 0, double h = 1E-8); doubleEvalBackward(double x, double h = 1E-8) const; static doubleEvalBackward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8); doubleEvalCentral(double x, double h = 1E-8) const; static doubleEvalCentral(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8); doubleEvalForward(double x, double h = 1E-8) const; static doubleEvalForward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8); doubleResult() const; voidSetFunction(const ROOT::Math::IGenFunction& f); voidSetFunction(const ROOT::Math::Derivator::GSLFuncPointer& f, void* p = 0); intStatus() const. private:. ROOT::Math::DerivatorDerivator(const ROOT::Math::Derivator&); ROOT::Math::Derivator&operator=(const ROOT::Math::Derivator&). Data Members; private:. ROOT::Math::GSLDerivator*fDerivator. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Derivator(). Empty Construct for a Derivator class; Need to set the function afterwards with Derivator::SetFunction. explicit Derivator(const IGenFunction &f). Construct using a ROOT::Math::IGenFunction interface. explicit Derivator(const ROOT::Math::Derivator::GSLFuncPointer& f, void* p = 0). Construct using a GSL function pointer type; @param f : free function pointer of the GSL required type; @param p : pointer to the object carrying the function state; (for example the function object itself). virtual ~Derivator(); destructor. Derivator(const Derivator &); disable copying. void SetFunction(const ROOT::Math::IGenFunction& f). Template methods for generic functions; Set the function f for evaluating the derivative.; The function type must implement the assigment operator,; <em> double operator() ( double x ) </em>. SetFunction(const ROOT::Math::Derivator::GSLFuncPointer& f, void* p = 0). double Eval(double x, double h = 1E-8) const. ",MatchSource.WIKI,root/html532/ROOT__Math__Derivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Derivator.html
https://root.cern/root/html532/ROOT__Math__Derivator.html:2136,Modifiability,Inherit,Inherited,2136,", unsigned int ipar = 0, double h = 1E-8); static doubleEval(ROOT::Math::IParamMultiFunction& f, const double* x, const double* p, unsigned int ipar = 0, double h = 1E-8); doubleEvalBackward(double x, double h = 1E-8) const; static doubleEvalBackward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8); doubleEvalCentral(double x, double h = 1E-8) const; static doubleEvalCentral(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8); doubleEvalForward(double x, double h = 1E-8) const; static doubleEvalForward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8); doubleResult() const; voidSetFunction(const ROOT::Math::IGenFunction& f); voidSetFunction(const ROOT::Math::Derivator::GSLFuncPointer& f, void* p = 0); intStatus() const. private:. ROOT::Math::DerivatorDerivator(const ROOT::Math::Derivator&); ROOT::Math::Derivator&operator=(const ROOT::Math::Derivator&). Data Members; private:. ROOT::Math::GSLDerivator*fDerivator. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Derivator(). Empty Construct for a Derivator class; Need to set the function afterwards with Derivator::SetFunction. explicit Derivator(const IGenFunction &f). Construct using a ROOT::Math::IGenFunction interface. explicit Derivator(const ROOT::Math::Derivator::GSLFuncPointer& f, void* p = 0). Construct using a GSL function pointer type; @param f : free function pointer of the GSL required type; @param p : pointer to the object carrying the function state; (for example the function object itself). virtual ~Derivator(); destructor. Derivator(const Derivator &); disable copying. void SetFunction(const ROOT::Math::IGenFunction& f). Template methods for generic functions; Set the function f for evaluating the derivative.; The function type must implement the assigment operator,; <em> double operator() ( double x ) </em>. SetFunction(const ROOT::Math::Derivator::GSLFuncPointer& f, void* p = 0). double Eval(double x, double h = 1E-8) const. ",MatchSource.WIKI,root/html532/ROOT__Math__Derivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Derivator.html
https://root.cern/root/html532/ROOT__Math__Derivator.html:3281,Modifiability,adapt,adaptive,3281,"n afterwards with Derivator::SetFunction. explicit Derivator(const IGenFunction &f). Construct using a ROOT::Math::IGenFunction interface. explicit Derivator(const ROOT::Math::Derivator::GSLFuncPointer& f, void* p = 0). Construct using a GSL function pointer type; @param f : free function pointer of the GSL required type; @param p : pointer to the object carrying the function state; (for example the function object itself). virtual ~Derivator(); destructor. Derivator(const Derivator &); disable copying. void SetFunction(const ROOT::Math::IGenFunction& f). Template methods for generic functions; Set the function f for evaluating the derivative.; The function type must implement the assigment operator,; <em> double operator() ( double x ) </em>. SetFunction(const ROOT::Math::Derivator::GSLFuncPointer& f, void* p = 0). double Eval(double x, double h = 1E-8) const. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8); @name --- Static methods ---; This methods don't require to use a Derivator object, and are designed to be used in; fast calculation. Error and status code cannot be retrieved in this case. Computes the numeric",MatchSource.WIKI,root/html532/ROOT__Math__Derivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Derivator.html
https://root.cern/root/html532/ROOT__Math__Derivator.html:3448,Modifiability,adapt,adaptive,3448,"h::Derivator::GSLFuncPointer& f, void* p = 0). Construct using a GSL function pointer type; @param f : free function pointer of the GSL required type; @param p : pointer to the object carrying the function state; (for example the function object itself). virtual ~Derivator(); destructor. Derivator(const Derivator &); disable copying. void SetFunction(const ROOT::Math::IGenFunction& f). Template methods for generic functions; Set the function f for evaluating the derivative.; The function type must implement the assigment operator,; <em> double operator() ( double x ) </em>. SetFunction(const ROOT::Math::Derivator::GSLFuncPointer& f, void* p = 0). double Eval(double x, double h = 1E-8) const. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8); @name --- Static methods ---; This methods don't require to use a Derivator object, and are designed to be used in; fast calculation. Error and status code cannot be retrieved in this case. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. doub",MatchSource.WIKI,root/html532/ROOT__Math__Derivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Derivator.html
https://root.cern/root/html532/ROOT__Math__Derivator.html:3616,Modifiability,adapt,adaptive,3616,"r to the object carrying the function state; (for example the function object itself). virtual ~Derivator(); destructor. Derivator(const Derivator &); disable copying. void SetFunction(const ROOT::Math::IGenFunction& f). Template methods for generic functions; Set the function f for evaluating the derivative.; The function type must implement the assigment operator,; <em> double operator() ( double x ) </em>. SetFunction(const ROOT::Math::Derivator::GSLFuncPointer& f, void* p = 0). double Eval(double x, double h = 1E-8) const. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8); @name --- Static methods ---; This methods don't require to use a Derivator object, and are designed to be used in; fast calculation. Error and status code cannot be retrieved in this case. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive central; ",MatchSource.WIKI,root/html532/ROOT__Math__Derivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Derivator.html
https://root.cern/root/html532/ROOT__Math__Derivator.html:3859,Modifiability,adapt,adaptive,3859,"neric functions; Set the function f for evaluating the derivative.; The function type must implement the assigment operator,; <em> double operator() ( double x ) </em>. SetFunction(const ROOT::Math::Derivator::GSLFuncPointer& f, void* p = 0). double Eval(double x, double h = 1E-8) const. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8); @name --- Static methods ---; This methods don't require to use a Derivator object, and are designed to be used in; fast calculation. Error and status code cannot be retrieved in this case. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive forward; difference algorithm with a st",MatchSource.WIKI,root/html532/ROOT__Math__Derivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Derivator.html
https://root.cern/root/html532/ROOT__Math__Derivator.html:4387,Modifiability,adapt,adaptive,4387,"-8) const. Computes the numerical derivative at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8); @name --- Static methods ---; This methods don't require to use a Derivator object, and are designed to be used in; fast calculation. Error and status code cannot be retrieved in this case. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IMultiGenFunction& f, const double* x, unsigned int icoord = 0, double h = 1E-8); Derivatives for multi-dimension functi",MatchSource.WIKI,root/html532/ROOT__Math__Derivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Derivator.html
https://root.cern/root/html532/ROOT__Math__Derivator.html:4599,Modifiability,adapt,adaptive,4599,"ve at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8); @name --- Static methods ---; This methods don't require to use a Derivator object, and are designed to be used in; fast calculation. Error and status code cannot be retrieved in this case. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IMultiGenFunction& f, const double* x, unsigned int icoord = 0, double h = 1E-8); Derivatives for multi-dimension functions. Evaluate the partial derivative of a multi-dim function; with respect coordinate x_icoord at the point x[]. double Eval(ROOT::Math::IParamFunction& f, double x, const double* p, unsigned int ipar = 0, doubl",MatchSource.WIKI,root/html532/ROOT__Math__Derivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Derivator.html
https://root.cern/root/html532/ROOT__Math__Derivator.html:4812,Modifiability,adapt,adaptive,4812,"omputes the numerical derivative at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8); @name --- Static methods ---; This methods don't require to use a Derivator object, and are designed to be used in; fast calculation. Error and status code cannot be retrieved in this case. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IMultiGenFunction& f, const double* x, unsigned int icoord = 0, double h = 1E-8); Derivatives for multi-dimension functions. Evaluate the partial derivative of a multi-dim function; with respect coordinate x_icoord at the point x[]. double Eval(ROOT::Math::IParamFunction& f, double x, const double* p, unsigned int ipar = 0, double h = 1E-8). Evaluate the derivative with respect a parameter for one-dim parameteric function; at the point ( x,p[]) with respect the parameter p_ipar. double Eval(ROOT::Math::IParamMultiFunction& f, const double",MatchSource.WIKI,root/html532/ROOT__Math__Derivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Derivator.html
https://root.cern/root/html532/ROOT__Math__Derivator.html:5100,Modifiability,adapt,adaptive,5100,"; This methods don't require to use a Derivator object, and are designed to be used in; fast calculation. Error and status code cannot be retrieved in this case. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IMultiGenFunction& f, const double* x, unsigned int icoord = 0, double h = 1E-8); Derivatives for multi-dimension functions. Evaluate the partial derivative of a multi-dim function; with respect coordinate x_icoord at the point x[]. double Eval(ROOT::Math::IParamFunction& f, double x, const double* p, unsigned int ipar = 0, double h = 1E-8). Evaluate the derivative with respect a parameter for one-dim parameteric function; at the point ( x,p[]) with respect the parameter p_ipar. double Eval(ROOT::Math::IParamMultiFunction& f, const double* x, const double* p, unsigned int ipar = 0, double h = 1E-8). Evaluate the derivative with respect a parameter for a multi-dim parameteric function; at the point ( x[],p[]) with respect the parameter p_ipar. int Status() const. return the error status of the last derivative calculation.",MatchSource.WIKI,root/html532/ROOT__Math__Derivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Derivator.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_Double32_t__-p1DefaultCoordinateSystemTag_.html:7812,Modifiability,Inherit,Inheritance,7812,":DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a); ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>Unit() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>unit() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarX() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarx() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const. Data Members; private:. ROOT::Math::Cartesian2D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXY(ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). DisplacementVector2D & operator=(const ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 2D vector type, for example, Hep2Vector; Precondition: v must implement methods x() and y(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector2D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). Set int",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_Double32_t__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_Double32_t__-p1DefaultCoordinateSystemTag_.html:7825,Modifiability,Inherit,Inherited,7825,":DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a); ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>Unit() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>unit() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarX() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarx() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const. Data Members; private:. ROOT::Math::Cartesian2D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXY(ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). DisplacementVector2D & operator=(const ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 2D vector type, for example, Hep2Vector; Precondition: v must implement methods x() and y(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector2D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). Set int",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_Double32_t__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_Double32_t__-p1DefaultCoordinateSystemTag_.html:8461,Security,access,access,8461,"T::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const. Data Members; private:. ROOT::Math::Cartesian2D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXY(ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). DisplacementVector2D & operator=(const ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 2D vector type, for example, Hep2Vector; Precondition: v must implement methods x() and y(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector2D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). Set internal data based on 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. void GetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b) const. get internal data into 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. { fCoordinates.GetCoordinates(a, b); }. bool operator==(const ROOT::Math::DisplacementVector2D<RO",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_Double32_t__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_Double32_t__-p1DefaultCoordinateSystemTag_.html:9788,Security,access,access,9788,"h::DefaultCoordinateSystemTag>::Scalar b). Set internal data based on 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. void GetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b) const. get internal data into 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. { fCoordinates.GetCoordinates(a, b); }. bool operator==(const ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Mag2() const; ----- Other fundamental properties -----. Magnitute squared ( r^2 in spherical coordinate). { return fCoordinates.Mag2();}. DisplacementVector2D Unit() const. return unit vector parallel to this. DisplacementVector2D<CoordSystem, Tag>& SetX(ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a); ------ Setting individual elements present in coordinate system ------. Change X - Cartesian2D coordinates only. Displa",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_Double32_t__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_double__-p1DefaultCoordinateSystemTag_.html:7703,Modifiability,Inherit,Inheritance,7703,"inateSystemTag>&SetY(ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a); ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>Unit() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>unit() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarX() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarx() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const. Data Members; private:. ROOT::Math::Cartesian2D<double>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXY(ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). DisplacementVector2D & operator=(const ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 2D vector type, for example, Hep2Vector; Precondition: v must implement methods x() and y(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector2D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). Set internal data based on ",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_double__-p1DefaultCoordinateSystemTag_.html:7716,Modifiability,Inherit,Inherited,7716,"inateSystemTag>&SetY(ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a); ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>Unit() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>unit() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarX() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarx() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const. Data Members; private:. ROOT::Math::Cartesian2D<double>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXY(ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). DisplacementVector2D & operator=(const ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 2D vector type, for example, Hep2Vector; Precondition: v must implement methods x() and y(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector2D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). Set internal data based on ",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_double__-p1DefaultCoordinateSystemTag_.html:8340,Security,access,access,8340,"g>::Scalarx() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const. Data Members; private:. ROOT::Math::Cartesian2D<double>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXY(ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). DisplacementVector2D & operator=(const ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 2D vector type, for example, Hep2Vector; Precondition: v must implement methods x() and y(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector2D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). Set internal data based on 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. void GetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b) const. get internal data into 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. { fCoordinates.GetCoordinates(a, b); }. bool operator==(const ROOT::Math::DisplacementVector2D<ROOT::Math::Cartes",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_double__-p1DefaultCoordinateSystemTag_.html:9643,Security,access,access,9643,"ouble>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). Set internal data based on 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. void GetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b) const. get internal data into 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. { fCoordinates.GetCoordinates(a, b); }. bool operator==(const ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Mag2() const; ----- Other fundamental properties -----. Magnitute squared ( r^2 in spherical coordinate). { return fCoordinates.Mag2();}. DisplacementVector2D Unit() const. return unit vector parallel to this. DisplacementVector2D<CoordSystem, Tag>& SetX(ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a); ------ Setting individual elements present in coordinate system ------. Change X - Cartesian2D coordinates only. Displaceme",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector2D_-p1Polar2D_Double32_t__-p1DefaultCoordinateSystemTag_.html:7576,Modifiability,Inherit,Inheritance,7576,"inateSystemTag>&SetY(ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a); ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>Unit() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>unit() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarX() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarx() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const. Data Members; private:. ROOT::Math::Polar2D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXY(ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). DisplacementVector2D & operator=(const ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 2D vector type, for example, Hep2Vector; Precondition: v must implement methods x() and y(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector2D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). Set internal data based on ",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector2D_-p1Polar2D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector2D_-p1Polar2D_Double32_t__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector2D_-p1Polar2D_Double32_t__-p1DefaultCoordinateSystemTag_.html:7589,Modifiability,Inherit,Inherited,7589,"inateSystemTag>&SetY(ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a); ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>Unit() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>unit() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarX() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarx() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const. Data Members; private:. ROOT::Math::Polar2D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXY(ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). DisplacementVector2D & operator=(const ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 2D vector type, for example, Hep2Vector; Precondition: v must implement methods x() and y(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector2D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). Set internal data based on ",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector2D_-p1Polar2D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector2D_-p1Polar2D_Double32_t__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector2D_-p1Polar2D_Double32_t__-p1DefaultCoordinateSystemTag_.html:8213,Security,access,access,8213,"g>::Scalarx() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const. Data Members; private:. ROOT::Math::Polar2D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXY(ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). DisplacementVector2D & operator=(const ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 2D vector type, for example, Hep2Vector; Precondition: v must implement methods x() and y(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector2D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). Set internal data based on 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. void GetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b) const. get internal data into 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. { fCoordinates.GetCoordinates(a, b); }. bool operator==(const ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector2D_-p1Polar2D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector2D_-p1Polar2D_Double32_t__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector2D_-p1Polar2D_Double32_t__-p1DefaultCoordinateSystemTag_.html:9516,Security,access,access,9516,"e32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). Set internal data based on 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. void GetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b) const. get internal data into 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. { fCoordinates.GetCoordinates(a, b); }. bool operator==(const ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Mag2() const; ----- Other fundamental properties -----. Magnitute squared ( r^2 in spherical coordinate). { return fCoordinates.Mag2();}. DisplacementVector2D Unit() const. return unit vector parallel to this. DisplacementVector2D<CoordSystem, Tag>& SetX(ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a); ------ Setting individual elements present in coordinate system ------. Change X - Cartesian2D coordinates only. Displaceme",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector2D_-p1Polar2D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector2D_-p1Polar2D_Double32_t__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector2D_-p1Polar2D_double__-p1DefaultCoordinateSystemTag_.html:7473,Modifiability,Inherit,Inheritance,7473,"double>,ROOT::Math::DefaultCoordinateSystemTag>&SetY(ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a); ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>Unit() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>unit() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarX() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarx() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const. Data Members; private:. ROOT::Math::Polar2D<double>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXY(ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). DisplacementVector2D & operator=(const ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 2D vector type, for example, Hep2Vector; Precondition: v must implement methods x() and y(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector2D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). Set internal data based on 2 Scalar numbers.; T",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector2D_-p1Polar2D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector2D_-p1Polar2D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector2D_-p1Polar2D_double__-p1DefaultCoordinateSystemTag_.html:7486,Modifiability,Inherit,Inherited,7486,"double>,ROOT::Math::DefaultCoordinateSystemTag>&SetY(ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a); ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>Unit() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>unit() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarX() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarx() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const. Data Members; private:. ROOT::Math::Polar2D<double>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXY(ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). DisplacementVector2D & operator=(const ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 2D vector type, for example, Hep2Vector; Precondition: v must implement methods x() and y(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector2D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). Set internal data based on 2 Scalar numbers.; T",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector2D_-p1Polar2D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector2D_-p1Polar2D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector2D_-p1Polar2D_double__-p1DefaultCoordinateSystemTag_.html:8098,Security,access,access,8098,"efaultCoordinateSystemTag>::Scalarx() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const. Data Members; private:. ROOT::Math::Polar2D<double>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXY(ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). DisplacementVector2D & operator=(const ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 2D vector type, for example, Hep2Vector; Precondition: v must implement methods x() and y(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector2D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). Set internal data based on 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. void GetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b) const. get internal data into 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. { fCoordinates.GetCoordinates(a, b); }. bool operator==(const ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector2D_-p1Polar2D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector2D_-p1Polar2D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector2D_-p1Polar2D_double__-p1DefaultCoordinateSystemTag_.html:9377,Security,access,access,9377,":Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). Set internal data based on 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. void GetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b) const. get internal data into 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. { fCoordinates.GetCoordinates(a, b); }. bool operator==(const ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Mag2() const; ----- Other fundamental properties -----. Magnitute squared ( r^2 in spherical coordinate). { return fCoordinates.Mag2();}. DisplacementVector2D Unit() const. return unit vector parallel to this. DisplacementVector2D<CoordSystem, Tag>& SetX(ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a); ------ Setting individual elements present in coordinate system ------. Change X - Cartesian2D coordinates only. DisplacementVe",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector2D_-p1Polar2D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector2D_-p1Polar2D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1DefaultCoordinateSystemTag_.html:10827,Modifiability,Inherit,Inheritance,10827,"ntVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>unit() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarX() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarx() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarZ() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Cartesian3D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1DefaultCoordinateSystemTag_.html:10840,Modifiability,Inherit,Inherited,10840,"ntVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>unit() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarX() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarx() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarZ() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Cartesian3D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1DefaultCoordinateSystemTag_.html:11602,Security,access,access,11602,"OT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Cartesian3D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). Set internal data based on 3 Scalar numbers. { fCoordinates.SetCoordinates(a, b, c); return *this; }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT:",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1DefaultCoordinateSystemTag_.html:13617,Security,access,access,13617,"temTag>::Scalar& a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1GlobalCoordinateSystemTag_.html:10623,Modifiability,Inherit,Inheritance,10623,"placementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>unit() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::ScalarX() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalarx() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::ScalarY() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalary() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::ScalarZ() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Cartesian3D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar* src",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1GlobalCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1GlobalCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1GlobalCoordinateSystemTag_.html:10636,Modifiability,Inherit,Inherited,10636,"placementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>unit() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::ScalarX() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalarx() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::ScalarY() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalary() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::ScalarZ() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Cartesian3D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar* src",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1GlobalCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1GlobalCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1GlobalCoordinateSystemTag_.html:11394,Security,access,access,11394,"t; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Cartesian3D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar c). Set internal data based on 3 Scalar numbers. { fCoordinates.SetCoordinates(a, b, c); return *this; }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Mat",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1GlobalCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1GlobalCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1GlobalCoordinateSystemTag_.html:13399,Security,access,access,13399,"teSystemTag>::Scalar& a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar& b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1GlobalCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1GlobalCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1LocalCoordinateSystemTag_.html:10543,Modifiability,Inherit,Inheritance,10543,"th::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>unit() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::ScalarX() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalarx() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::ScalarY() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalary() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::ScalarZ() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Cartesian3D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar* src). Se",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1LocalCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1LocalCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1LocalCoordinateSystemTag_.html:10556,Modifiability,Inherit,Inherited,10556,"th::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>unit() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::ScalarX() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalarx() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::ScalarY() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalary() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::ScalarZ() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Cartesian3D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar* src). Se",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1LocalCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1LocalCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1LocalCoordinateSystemTag_.html:11310,Security,access,access,11310," const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Cartesian3D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar c). Set internal data based on 3 Scalar numbers. { fCoordinates.SetCoordinates(a, b, c); return *this; }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::L",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1LocalCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1LocalCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1LocalCoordinateSystemTag_.html:13305,Security,access,access,13305,"rdinateSystemTag>::Scalar& a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar& b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1LocalCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1LocalCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html:18222,Modifiability,Inherit,Inheritance,18222,"() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>unit() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarX() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarx() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarZ() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Cartesian3D<double>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=( const ForeignVector & v). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); ",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html:18235,Modifiability,Inherit,Inherited,18235,"() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>unit() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarX() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarx() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarZ() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Cartesian3D<double>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=( const ForeignVector & v). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); ",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html:24495,Performance,perform,perform,24495,"3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar ang). Change Phi - Polar3D or CylindricalEta3D coordinates. { fCoordinates.SetPhi(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetRho(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar rr). Change Rho - CylindricalEta3D coordinates only. { fCoordinates.SetRho(rr); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetEta(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v); ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vector b",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html:24708,Performance,perform,perform,24708,"ctor3D<CoordSystem, Tag>& SetRho(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar rr). Change Rho - CylindricalEta3D coordinates only. { fCoordinates.SetRho(rr); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetEta(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v); ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vector by a scalar quantity. DisplacementVector3D & operator/=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). divide this vector by a scal",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html:25002,Performance,perform,perform,25002,"acementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v); ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vector by a scalar quantity. DisplacementVector3D & operator/=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). divide this vector by a scalar quantity. return operator*( Scalar(-1) ). DisplacementVector3D operator/(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a) const. Division of a vector with a real number. Scalar x() const; Methods providing limited backward name compatibi",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html:25282,Performance,perform,perform,25282," Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vector by a scalar quantity. DisplacementVector3D & operator/=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). divide this vector by a scalar quantity. return operator*( Scalar(-1) ). DisplacementVector3D operator/(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a) const. Division of a vector with a real number. Scalar x() const; Methods providing limited backward name compatibility with CLHEP. { return fCoordinates.X(); }. Scalar y() const; { return fCoordinates.Y(); }. Scalar z() const; { return fCoordinates.Z(); }. Scalar theta() const; { return fCoordinates.Theta(); }. Scalar phi() const; { return fCoordinates.Phi(); }. Scalar eta() con",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html:24408,Safety,avoid,avoid,24408,"th::DefaultCoordinateSystemTag>::Scalar ang). Change Theta - Polar3D coordinates only. { fCoordinates.SetTheta(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetPhi(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar ang). Change Phi - Polar3D or CylindricalEta3D coordinates. { fCoordinates.SetPhi(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetRho(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar rr). Change Rho - CylindricalEta3D coordinates only. { fCoordinates.SetRho(rr); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetEta(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v); ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementin",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html:18893,Security,access,access,18893,"isplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarZ() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Cartesian3D<double>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=( const ForeignVector & v). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). Set internal data based on 3 Scalar numbers. { fCoordinates.SetCoordinates(a, b, c); return *this; }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordi",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html:20868,Security,access,access,20868,"DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_Double32_t__-p1DefaultCoordinateSystemTag_.html:10993,Modifiability,Inherit,Inheritance,10993,":Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>unit() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarX() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarx() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarZ() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Cylindrical3D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTa",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_Double32_t__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_Double32_t__-p1DefaultCoordinateSystemTag_.html:11006,Modifiability,Inherit,Inherited,11006,":Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>unit() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarX() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarx() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarZ() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Cylindrical3D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTa",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_Double32_t__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_Double32_t__-p1DefaultCoordinateSystemTag_.html:11776,Security,access,access,11776,"splacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Cylindrical3D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). Set internal data based on 3 Scalar numbers. { fCoordinates.SetCoordinates(a, b, c); return *this; }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double3",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_Double32_t__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_Double32_t__-p1DefaultCoordinateSystemTag_.html:13811,Security,access,access,13811,"calar& a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_Double32_t__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html:14081,Modifiability,Inherit,Inheritance,14081,"Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>unit() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarX() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarx() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarZ() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Cylindrical3D<double>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=( const ForeignVector & v). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinate",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html:14094,Modifiability,Inherit,Inherited,14094,"Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>unit() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarX() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarx() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarZ() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Cylindrical3D<double>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=( const ForeignVector & v). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinate",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html:20469,Performance,perform,perform,20469,"calar ang). Change Phi - Polar3D or CylindricalEta3D coordinates. { fCoordinates.SetPhi(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetRho(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar rr). Change Rho - CylindricalEta3D coordinates only. { fCoordinates.SetRho(rr); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetEta(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& v) const; ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vector by a scalar quantity. DisplacementVector3D & operator/=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). divide this ",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html:20788,Performance,perform,perform,20788,"only. { fCoordinates.SetRho(rr); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetEta(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& v) const; ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vector by a scalar quantity. DisplacementVector3D & operator/=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). divide this vector by a scalar quantity. return operator*( Scalar(-1) ). DisplacementVector3D operator/(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a) const. Division of a vector with a real number. Scalar x() const; Methods providing limited backward name com",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html:21068,Performance,perform,perform,21068,"{ fCoordinates.SetEta(etaval); return *this;}. Scalar Dot(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& v) const; ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vector by a scalar quantity. DisplacementVector3D & operator/=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). divide this vector by a scalar quantity. return operator*( Scalar(-1) ). DisplacementVector3D operator/(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a) const. Division of a vector with a real number. Scalar x() const; Methods providing limited backward name compatibility with CLHEP. { return fCoordinates.X(); }. Scalar y() const; { return fCoordinates.Y(); }. Scalar z() const; { return fCoordinates.Z(); }. Scalar theta() const; { return fCoordinates.Theta(); }. Scalar phi() const; { return fCoordinates.Phi(); }. Scalar eta",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html:20382,Safety,avoid,avoid,20382,"). Change Theta - Polar3D coordinates only. { fCoordinates.SetTheta(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetPhi(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar ang). Change Phi - Polar3D or CylindricalEta3D coordinates. { fCoordinates.SetPhi(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetRho(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar rr). Change Rho - CylindricalEta3D coordinates only. { fCoordinates.SetRho(rr); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetEta(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& v) const; ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::D",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html:14758,Security,access,access,14758,"ector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarZ() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Cylindrical3D<double>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=( const ForeignVector & v). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). Set internal data based on 3 Scalar numbers. { fCoordinates.SetCoordinates(a, b, c); return *this; }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::Def",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html:16753,Security,access,access,16753,"rdinateSystemTag>::Scalar& a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1DefaultCoordinateSystemTag_.html:11242,Modifiability,Inherit,Inheritance,11242,"Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>unit() const; ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarX() const; ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarx() const; ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const; ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarZ() const; ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::CylindricalEta3D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoo",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1DefaultCoordinateSystemTag_.html:11255,Modifiability,Inherit,Inherited,11255,"Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>unit() const; ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarX() const; ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarx() const; ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const; ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarZ() const; ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::CylindricalEta3D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoo",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1DefaultCoordinateSystemTag_.html:12037,Security,access,access,12037,"<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::CylindricalEta3D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). Set internal data based on 3 Scalar numbers. { fCoordinates.SetCoordinates(a, b, c); return *this; }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindric",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1DefaultCoordinateSystemTag_.html:14102,Security,access,access,14102,":Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1GlobalCoordinateSystemTag_.html:11033,Modifiability,Inherit,Inheritance,11033,"lEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>unit() const; ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::ScalarX() const; ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalarx() const; ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::ScalarY() const; ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalary() const; ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::ScalarZ() const; ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::CylindricalEta3D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordina",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1GlobalCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1GlobalCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1GlobalCoordinateSystemTag_.html:11046,Modifiability,Inherit,Inherited,11046,"lEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>unit() const; ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::ScalarX() const; ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalarx() const; ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::ScalarY() const; ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalary() const; ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::ScalarZ() const; ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::CylindricalEta3D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordina",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1GlobalCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1GlobalCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1GlobalCoordinateSystemTag_.html:11824,Security,access,access,11824,"tor3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::CylindricalEta3D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar c). Set internal data based on 3 Scalar numbers. { fCoordinates.SetCoordinates(a, b, c); return *this; }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEt",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1GlobalCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1GlobalCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1GlobalCoordinateSystemTag_.html:13879,Security,access,access,13879,"ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar& b, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1GlobalCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1GlobalCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1LocalCoordinateSystemTag_.html:10953,Modifiability,Inherit,Inheritance,10953,"indricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>unit() const; ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::ScalarX() const; ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalarx() const; ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::ScalarY() const; ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalary() const; ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::ScalarZ() const; ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::CylindricalEta3D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSys",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1LocalCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1LocalCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1LocalCoordinateSystemTag_.html:10966,Modifiability,Inherit,Inherited,10966,"indricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>unit() const; ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::ScalarX() const; ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalarx() const; ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::ScalarY() const; ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalary() const; ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::ScalarZ() const; ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::CylindricalEta3D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSys",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1LocalCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1LocalCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1LocalCoordinateSystemTag_.html:11740,Security,access,access,11740,"ntVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::CylindricalEta3D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar c). Set internal data based on 3 Scalar numbers. { fCoordinates.SetCoordinates(a, b, c); return *this; }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1LocalCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1LocalCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1LocalCoordinateSystemTag_.html:13785,Security,access,access,13785,"& a, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar& b, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1LocalCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1LocalCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html:14882,Modifiability,Inherit,Inheritance,14882,"3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>unit() const; ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarX() const; ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarx() const; ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const; ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarZ() const; ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::CylindricalEta3D<double>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=( const ForeignVector & v). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.S",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html:14895,Modifiability,Inherit,Inherited,14895,"3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>unit() const; ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarX() const; ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarx() const; ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const; ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarZ() const; ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::CylindricalEta3D<double>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=( const ForeignVector & v). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.S",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html:21260,Performance,perform,perform,21260,"CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar ang). Change Phi - Polar3D or CylindricalEta3D coordinates. { fCoordinates.SetPhi(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetRho(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar rr). Change Rho - CylindricalEta3D coordinates only. { fCoordinates.SetRho(rr); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetEta(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v); ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vec",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html:21473,Performance,perform,perform,21473,"rdSystem, Tag>& SetRho(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar rr). Change Rho - CylindricalEta3D coordinates only. { fCoordinates.SetRho(rr); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetEta(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v); ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vector by a scalar quantity. DisplacementVector3D & operator/=(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). divide this vector",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html:21767,Performance,perform,perform,21767,"ntVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v); ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vector by a scalar quantity. DisplacementVector3D & operator/=(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). divide this vector by a scalar quantity. return operator*( Scalar(-1) ). DisplacementVector3D operator/(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a) const. Division of a vector with a real number. Scalar x() const; Methods providing limited backward",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html:22047,Performance,perform,perform,22047," Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vector by a scalar quantity. DisplacementVector3D & operator/=(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). divide this vector by a scalar quantity. return operator*( Scalar(-1) ). DisplacementVector3D operator/(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a) const. Division of a vector with a real number. Scalar x() const; Methods providing limited backward name compatibility with CLHEP. { return fCoordinates.X(); }. Scalar y() const; { return fCoordinates.Y(); }. Scalar z() const; { return fCoordinates.Z(); }. Scalar theta() const; { return fCoordinates.Theta(); }. Scalar phi() const; { return fCoordinates.Phi(); }. S",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html:21173,Safety,avoid,avoid,21173,"dinateSystemTag>::Scalar ang). Change Theta - Polar3D coordinates only. { fCoordinates.SetTheta(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetPhi(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar ang). Change Phi - Polar3D or CylindricalEta3D coordinates. { fCoordinates.SetPhi(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetRho(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar rr). Change Rho - CylindricalEta3D coordinates only. { fCoordinates.SetRho(rr); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetEta(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v); ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementin",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html:15568,Security,access,access,15568,"::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarZ() const; ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::CylindricalEta3D<double>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=( const ForeignVector & v). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). Set internal data based on 3 Scalar numbers. { fCoordinates.SetCoordinates(a, b, c); return *this; }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html:17593,Security,access,access,17593,"g>::Scalar& a, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Polar3D_Double32_t__-p1DefaultCoordinateSystemTag_.html:10495,Modifiability,Inherit,Inheritance,10495,"() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>unit() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarX() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarx() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarZ() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Polar3D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=(const ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1Polar3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Polar3D_Double32_t__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Polar3D_Double32_t__-p1DefaultCoordinateSystemTag_.html:10508,Modifiability,Inherit,Inherited,10508,"() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>unit() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarX() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarx() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarZ() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Polar3D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=(const ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1Polar3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Polar3D_Double32_t__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Polar3D_Double32_t__-p1DefaultCoordinateSystemTag_.html:11254,Security,access,access,11254,"ag>::ScalarZ() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Polar3D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=(const ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). Set internal data based on 3 Scalar numbers. { fCoordinates.SetCoordinates(a, b, c); return *this; }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordi",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1Polar3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Polar3D_Double32_t__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Polar3D_Double32_t__-p1DefaultCoordinateSystemTag_.html:13229,Security,access,access,13229,"DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1Polar3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Polar3D_Double32_t__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html:13742,Modifiability,Inherit,Inheritance,13742,":DefaultCoordinateSystemTag>Unit() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>unit() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarX() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarx() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarZ() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Polar3D<double>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=( const ForeignVector & v). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }.",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html:13755,Modifiability,Inherit,Inherited,13755,":DefaultCoordinateSystemTag>Unit() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>unit() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarX() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarx() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarZ() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Polar3D<double>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=( const ForeignVector & v). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }.",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html:19931,Performance,perform,perform,19931,"cementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar ang). Change Phi - Polar3D or CylindricalEta3D coordinates. { fCoordinates.SetPhi(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetRho(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar rr). Change Rho - CylindricalEta3D coordinates only. { fCoordinates.SetRho(rr); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetEta(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v); ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vector by a ",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html:20144,Performance,perform,perform,20144,"cementVector3D<CoordSystem, Tag>& SetRho(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar rr). Change Rho - CylindricalEta3D coordinates only. { fCoordinates.SetRho(rr); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetEta(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v); ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vector by a scalar quantity. DisplacementVector3D & operator/=(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). divide this vector by a scalar quant",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html:20438,Performance,perform,perform,20438,"isplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v); ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vector by a scalar quantity. DisplacementVector3D & operator/=(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). divide this vector by a scalar quantity. return operator*( Scalar(-1) ). DisplacementVector3D operator/(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a) const. Division of a vector with a real number. Scalar x() const; Methods providing limited backward name compatibility with CL",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html:20718,Performance,perform,perform,20718," Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vector by a scalar quantity. DisplacementVector3D & operator/=(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). divide this vector by a scalar quantity. return operator*( Scalar(-1) ). DisplacementVector3D operator/(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a) const. Division of a vector with a real number. Scalar x() const; Methods providing limited backward name compatibility with CLHEP. { return fCoordinates.X(); }. Scalar y() const; { return fCoordinates.Y(); }. Scalar z() const; { return fCoordinates.Z(); }. Scalar theta() const; { return fCoordinates.Theta(); }. Scalar phi() const; { return fCoordinates.Phi(); }. Scalar eta() const; { return",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html:19844,Safety,avoid,avoid,19844,"le>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar ang). Change Theta - Polar3D coordinates only. { fCoordinates.SetTheta(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetPhi(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar ang). Change Phi - Polar3D or CylindricalEta3D coordinates. { fCoordinates.SetPhi(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetRho(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar rr). Change Rho - CylindricalEta3D coordinates only. { fCoordinates.SetRho(rr); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetEta(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v); ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementin",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html:14401,Security,access,access,14401,"y() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarZ() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Polar3D<double>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=( const ForeignVector & v). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). Set internal data based on 3 Scalar numbers. { fCoordinates.SetCoordinates(a, b, c); return *this; }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scal",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html:16336,Security,access,access,16336,"double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root/html532/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html532/ROOT__Math__DistSampler.html:571,Availability,avail,available,571,". ROOT::Math::DistSampler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::DistSampler. class ROOT::Math::DistSampler. Interface class for generic sampling of a distribution,; i.e. generating random numbers according to arbitrary distributions. @ingroup Random. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~DistSampler(); virtual boolGenerate(unsigned int nevt, ROOT::Fit::UnBinData& data); virtual boolGenerate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true); boolGenerate(unsigned int nevt, int nbins, double xmin, double xmax, ROOT::Fit::BinData& data, bool extend = true); virtual TRandom*GetRandom(); virtual boolInit(const char* = """"); virtual boolInit(const ROOT::Math::DistSamplerOptions& opt); unsigned intNDim() const; const ROOT::Math::IMultiGenFunction&ParentPdf() const; const double*Sample(); virtual boolSample(double* x); virtual doubleSample1D(); virtual boolSampleBin(double prob, double& value, double* error = 0); virtual boolSampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidSetArea(double); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& func); virtual voidSetMode(double); virtual voidSetRandom(TRandom*); voidSetRange(const ROOT::Fit::DataRange& range); voidSetRange(const double* xmin, const double* xmax); voidSetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int). protected:. virtual voidDoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolIsInitialized(); const ROOT::Fit::DataRange&PdfRange() const. Data Members; private:. vector<double>fDatainternal arr",MatchSource.WIKI,root/html532/ROOT__Math__DistSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DistSampler.html
https://root.cern/root/html532/ROOT__Math__DistSampler.html:1263,Availability,error,error,1263," class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::DistSampler. class ROOT::Math::DistSampler. Interface class for generic sampling of a distribution,; i.e. generating random numbers according to arbitrary distributions. @ingroup Random. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~DistSampler(); virtual boolGenerate(unsigned int nevt, ROOT::Fit::UnBinData& data); virtual boolGenerate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true); boolGenerate(unsigned int nevt, int nbins, double xmin, double xmax, ROOT::Fit::BinData& data, bool extend = true); virtual TRandom*GetRandom(); virtual boolInit(const char* = """"); virtual boolInit(const ROOT::Math::DistSamplerOptions& opt); unsigned intNDim() const; const ROOT::Math::IMultiGenFunction&ParentPdf() const; const double*Sample(); virtual boolSample(double* x); virtual doubleSample1D(); virtual boolSampleBin(double prob, double& value, double* error = 0); virtual boolSampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidSetArea(double); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& func); virtual voidSetMode(double); virtual voidSetRandom(TRandom*); voidSetRange(const ROOT::Fit::DataRange& range); voidSetRange(const double* xmin, const double* xmax); voidSetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int). protected:. virtual voidDoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolIsInitialized(); const ROOT::Fit::DataRange&PdfRange() const. Data Members; private:. vector<double>fDatainternal array used to cached the sample data ; const ROOT::Math::IMultiGenFunction*fFuncinternal function (ND); boolfOwnFuncflag to indicate if the function is owned; ROOT::Fit::DataRange*fRangedata range ",MatchSource.WIKI,root/html532/ROOT__Math__DistSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DistSampler.html
https://root.cern/root/html532/ROOT__Math__DistSampler.html:1358,Availability,error,errors,1358," class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::DistSampler. class ROOT::Math::DistSampler. Interface class for generic sampling of a distribution,; i.e. generating random numbers according to arbitrary distributions. @ingroup Random. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~DistSampler(); virtual boolGenerate(unsigned int nevt, ROOT::Fit::UnBinData& data); virtual boolGenerate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true); boolGenerate(unsigned int nevt, int nbins, double xmin, double xmax, ROOT::Fit::BinData& data, bool extend = true); virtual TRandom*GetRandom(); virtual boolInit(const char* = """"); virtual boolInit(const ROOT::Math::DistSamplerOptions& opt); unsigned intNDim() const; const ROOT::Math::IMultiGenFunction&ParentPdf() const; const double*Sample(); virtual boolSample(double* x); virtual doubleSample1D(); virtual boolSampleBin(double prob, double& value, double* error = 0); virtual boolSampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidSetArea(double); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& func); virtual voidSetMode(double); virtual voidSetRandom(TRandom*); voidSetRange(const ROOT::Fit::DataRange& range); voidSetRange(const double* xmin, const double* xmax); voidSetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int). protected:. virtual voidDoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolIsInitialized(); const ROOT::Fit::DataRange&PdfRange() const. Data Members; private:. vector<double>fDatainternal array used to cached the sample data ; const ROOT::Math::IMultiGenFunction*fFuncinternal function (ND); boolfOwnFuncflag to indicate if the function is owned; ROOT::Fit::DataRange*fRangedata range ",MatchSource.WIKI,root/html532/ROOT__Math__DistSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DistSampler.html
https://root.cern/root/html532/ROOT__Math__DistSampler.html:4750,Availability,error,error,4750,"sampler; To be implemented by the derived classes who needs it; Returns zero by default. { return 0; }. void SetRange(double xmin, double xmax, int icoord = 0); set range in a given dimension. void SetRange(const double* xmin, const double* xmax); set range for all dimensions. void SetRange(const ROOT::Fit::DataRange& range); set range using DataRange class. void SetMode(double ); set the mode of the distribution (could be useful to some methods); implemented by derived classes if needed. {}. void SetArea(double ); set the normalization area of distribution; implemented by derived classes if needed. {}. const ROOT::Math::IMultiGenFunction & ParentPdf() const; get the parent distribution function (must be called after setting the function). double Sample1D(). sample one event in one dimension; better implementation could be provided by the derived classes. Sample(double* x). const double * Sample(). sample one event and rerturning array x with coordinates. bool SampleBin(double prob, double& value, double* error = 0). sample one bin given an estimated of the pdf in the bin; (this can be function value at the center or its integral in the bin; divided by the bin width); By default do not do random sample, just return the function values; Typically Poisson statistics will be used. bool SampleBins(unsigned int n, const double* prob, double* values, double* errors = 0). sample a set of bins given a vector of probabilities; Typically multinomial statistics will be used and the sum of the probabilities; will be equal to the total number of events to be generated; For sampling the bins indipendently, SampleBin should be used. bool Generate(unsigned int nevt, ROOT::Fit::UnBinData& data). generate a un-binned data sets (fill the given data set); if dataset has already data append to it. bool Generate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true). generate a bin data set .; A range must have been set before (otherwise inf is returned); and t",MatchSource.WIKI,root/html532/ROOT__Math__DistSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DistSampler.html
https://root.cern/root/html532/ROOT__Math__DistSampler.html:5104,Availability,error,errors,5104,"g DataRange class. void SetMode(double ); set the mode of the distribution (could be useful to some methods); implemented by derived classes if needed. {}. void SetArea(double ); set the normalization area of distribution; implemented by derived classes if needed. {}. const ROOT::Math::IMultiGenFunction & ParentPdf() const; get the parent distribution function (must be called after setting the function). double Sample1D(). sample one event in one dimension; better implementation could be provided by the derived classes. Sample(double* x). const double * Sample(). sample one event and rerturning array x with coordinates. bool SampleBin(double prob, double& value, double* error = 0). sample one bin given an estimated of the pdf in the bin; (this can be function value at the center or its integral in the bin; divided by the bin width); By default do not do random sample, just return the function values; Typically Poisson statistics will be used. bool SampleBins(unsigned int n, const double* prob, double* values, double* errors = 0). sample a set of bins given a vector of probabilities; Typically multinomial statistics will be used and the sum of the probabilities; will be equal to the total number of events to be generated; For sampling the bins indipendently, SampleBin should be used. bool Generate(unsigned int nevt, ROOT::Fit::UnBinData& data). generate a un-binned data sets (fill the given data set); if dataset has already data append to it. bool Generate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true). generate a bin data set .; A range must have been set before (otherwise inf is returned); and the bins are equidinstant in the previously defined range; bin center values must be present in given data set; If the sampler is implemented by a random one, the entries; will be binned according to the Poisson distribution; It is assumed the distribution is normalized, otherwise the nevt must be scaled; accordingly. The expected value/bin ",MatchSource.WIKI,root/html532/ROOT__Math__DistSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DistSampler.html
https://root.cern/root/html532/ROOT__Math__DistSampler.html:294,Integrability,Interface,Interface,294,". ROOT::Math::DistSampler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::DistSampler. class ROOT::Math::DistSampler. Interface class for generic sampling of a distribution,; i.e. generating random numbers according to arbitrary distributions. @ingroup Random. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~DistSampler(); virtual boolGenerate(unsigned int nevt, ROOT::Fit::UnBinData& data); virtual boolGenerate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true); boolGenerate(unsigned int nevt, int nbins, double xmin, double xmax, ROOT::Fit::BinData& data, bool extend = true); virtual TRandom*GetRandom(); virtual boolInit(const char* = """"); virtual boolInit(const ROOT::Math::DistSamplerOptions& opt); unsigned intNDim() const; const ROOT::Math::IMultiGenFunction&ParentPdf() const; const double*Sample(); virtual boolSample(double* x); virtual doubleSample1D(); virtual boolSampleBin(double prob, double& value, double* error = 0); virtual boolSampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidSetArea(double); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& func); virtual voidSetMode(double); virtual voidSetRandom(TRandom*); voidSetRange(const ROOT::Fit::DataRange& range); voidSetRange(const double* xmin, const double* xmax); voidSetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int). protected:. virtual voidDoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolIsInitialized(); const ROOT::Fit::DataRange&PdfRange() const. Data Members; private:. vector<double>fDatainternal arr",MatchSource.WIKI,root/html532/ROOT__Math__DistSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DistSampler.html
https://root.cern/root/html532/ROOT__Math__DistSampler.html:786,Modifiability,extend,extend,786," class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::DistSampler. class ROOT::Math::DistSampler. Interface class for generic sampling of a distribution,; i.e. generating random numbers according to arbitrary distributions. @ingroup Random. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~DistSampler(); virtual boolGenerate(unsigned int nevt, ROOT::Fit::UnBinData& data); virtual boolGenerate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true); boolGenerate(unsigned int nevt, int nbins, double xmin, double xmax, ROOT::Fit::BinData& data, bool extend = true); virtual TRandom*GetRandom(); virtual boolInit(const char* = """"); virtual boolInit(const ROOT::Math::DistSamplerOptions& opt); unsigned intNDim() const; const ROOT::Math::IMultiGenFunction&ParentPdf() const; const double*Sample(); virtual boolSample(double* x); virtual doubleSample1D(); virtual boolSampleBin(double prob, double& value, double* error = 0); virtual boolSampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidSetArea(double); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& func); virtual voidSetMode(double); virtual voidSetRandom(TRandom*); voidSetRange(const ROOT::Fit::DataRange& range); voidSetRange(const double* xmin, const double* xmax); voidSetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int). protected:. virtual voidDoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolIsInitialized(); const ROOT::Fit::DataRange&PdfRange() const. Data Members; private:. vector<double>fDatainternal array used to cached the sample data ; const ROOT::Math::IMultiGenFunction*fFuncinternal function (ND); boolfOwnFuncflag to indicate if the function is owned; ROOT::Fit::DataRange*fRangedata range ",MatchSource.WIKI,root/html532/ROOT__Math__DistSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DistSampler.html
https://root.cern/root/html532/ROOT__Math__DistSampler.html:902,Modifiability,extend,extend,902," class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::DistSampler. class ROOT::Math::DistSampler. Interface class for generic sampling of a distribution,; i.e. generating random numbers according to arbitrary distributions. @ingroup Random. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~DistSampler(); virtual boolGenerate(unsigned int nevt, ROOT::Fit::UnBinData& data); virtual boolGenerate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true); boolGenerate(unsigned int nevt, int nbins, double xmin, double xmax, ROOT::Fit::BinData& data, bool extend = true); virtual TRandom*GetRandom(); virtual boolInit(const char* = """"); virtual boolInit(const ROOT::Math::DistSamplerOptions& opt); unsigned intNDim() const; const ROOT::Math::IMultiGenFunction&ParentPdf() const; const double*Sample(); virtual boolSample(double* x); virtual doubleSample1D(); virtual boolSampleBin(double prob, double& value, double* error = 0); virtual boolSampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidSetArea(double); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& func); virtual voidSetMode(double); virtual voidSetRandom(TRandom*); voidSetRange(const ROOT::Fit::DataRange& range); voidSetRange(const double* xmin, const double* xmax); voidSetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int). protected:. virtual voidDoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolIsInitialized(); const ROOT::Fit::DataRange&PdfRange() const. Data Members; private:. vector<double>fDatainternal array used to cached the sample data ; const ROOT::Math::IMultiGenFunction*fFuncinternal function (ND); boolfOwnFuncflag to indicate if the function is owned; ROOT::Fit::DataRange*fRangedata range ",MatchSource.WIKI,root/html532/ROOT__Math__DistSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DistSampler.html
https://root.cern/root/html532/ROOT__Math__DistSampler.html:2211,Modifiability,Inherit,Inheritance,2211,"ob, double& value, double* error = 0); virtual boolSampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidSetArea(double); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& func); virtual voidSetMode(double); virtual voidSetRandom(TRandom*); voidSetRange(const ROOT::Fit::DataRange& range); voidSetRange(const double* xmin, const double* xmax); voidSetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int). protected:. virtual voidDoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolIsInitialized(); const ROOT::Fit::DataRange&PdfRange() const. Data Members; private:. vector<double>fDatainternal array used to cached the sample data ; const ROOT::Math::IMultiGenFunction*fFuncinternal function (ND); boolfOwnFuncflag to indicate if the function is owned; ROOT::Fit::DataRange*fRangedata range . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~DistSampler(); virtual destructor. void SetFunction(Function & func, unsigned int dim); set the parent function distribution to use for sampling (generic case). DoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); need to clone to avoid temporary. void SetFunction(const ROOT::Math::IGenFunction& func); set the parent function distribution to use for random sampling (one dim case). unsigned int NDim() const; return the dimension of the parent distribution (and the data). { return fData.size(); }. bool Init(const char* = """"). initialize the generators with the given algorithm; Implemented by derived classes who needs it; (like UnuranSampler); If nothing is specified use default algorithm; from DistSamplerOptions::SetDefaultAlgorithm. { return true;}. bool Init(const ROOT::Math::DistSamplerOptions& opt). initialize the generators with the given option; which my include the algorithm but also more if; the method is",MatchSource.WIKI,root/html532/ROOT__Math__DistSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DistSampler.html
https://root.cern/root/html532/ROOT__Math__DistSampler.html:2224,Modifiability,Inherit,Inherited,2224,"ob, double& value, double* error = 0); virtual boolSampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidSetArea(double); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& func); virtual voidSetMode(double); virtual voidSetRandom(TRandom*); voidSetRange(const ROOT::Fit::DataRange& range); voidSetRange(const double* xmin, const double* xmax); voidSetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int). protected:. virtual voidDoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolIsInitialized(); const ROOT::Fit::DataRange&PdfRange() const. Data Members; private:. vector<double>fDatainternal array used to cached the sample data ; const ROOT::Math::IMultiGenFunction*fFuncinternal function (ND); boolfOwnFuncflag to indicate if the function is owned; ROOT::Fit::DataRange*fRangedata range . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~DistSampler(); virtual destructor. void SetFunction(Function & func, unsigned int dim); set the parent function distribution to use for sampling (generic case). DoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); need to clone to avoid temporary. void SetFunction(const ROOT::Math::IGenFunction& func); set the parent function distribution to use for random sampling (one dim case). unsigned int NDim() const; return the dimension of the parent distribution (and the data). { return fData.size(); }. bool Init(const char* = """"). initialize the generators with the given algorithm; Implemented by derived classes who needs it; (like UnuranSampler); If nothing is specified use default algorithm; from DistSamplerOptions::SetDefaultAlgorithm. { return true;}. bool Init(const ROOT::Math::DistSamplerOptions& opt). initialize the generators with the given option; which my include the algorithm but also more if; the method is",MatchSource.WIKI,root/html532/ROOT__Math__DistSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DistSampler.html
https://root.cern/root/html532/ROOT__Math__DistSampler.html:5619,Modifiability,extend,extend,5619,"ed classes. Sample(double* x). const double * Sample(). sample one event and rerturning array x with coordinates. bool SampleBin(double prob, double& value, double* error = 0). sample one bin given an estimated of the pdf in the bin; (this can be function value at the center or its integral in the bin; divided by the bin width); By default do not do random sample, just return the function values; Typically Poisson statistics will be used. bool SampleBins(unsigned int n, const double* prob, double* values, double* errors = 0). sample a set of bins given a vector of probabilities; Typically multinomial statistics will be used and the sum of the probabilities; will be equal to the total number of events to be generated; For sampling the bins indipendently, SampleBin should be used. bool Generate(unsigned int nevt, ROOT::Fit::UnBinData& data). generate a un-binned data sets (fill the given data set); if dataset has already data append to it. bool Generate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true). generate a bin data set .; A range must have been set before (otherwise inf is returned); and the bins are equidinstant in the previously defined range; bin center values must be present in given data set; If the sampler is implemented by a random one, the entries; will be binned according to the Poisson distribution; It is assumed the distribution is normalized, otherwise the nevt must be scaled; accordingly. The expected value/bin nexp = f(x_i) * binArea/ nevt; Extend control if use a fixed (i.e. multinomial statistics) or floating total number of events. bool Generate(unsigned int nevt, int nbins, double xmin, double xmax, ROOT::Fit::BinData& data, bool extend = true). same as before but passing the range in case of 1 dim data. bool IsInitialized(); check if generator have been initialized correctly and one can start generating. const ROOT::Fit::DataRange & PdfRange() const; return the data range of the Pdf . Must be called after set",MatchSource.WIKI,root/html532/ROOT__Math__DistSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DistSampler.html
https://root.cern/root/html532/ROOT__Math__DistSampler.html:6103,Modifiability,Extend,Extend,6103,"es; Typically Poisson statistics will be used. bool SampleBins(unsigned int n, const double* prob, double* values, double* errors = 0). sample a set of bins given a vector of probabilities; Typically multinomial statistics will be used and the sum of the probabilities; will be equal to the total number of events to be generated; For sampling the bins indipendently, SampleBin should be used. bool Generate(unsigned int nevt, ROOT::Fit::UnBinData& data). generate a un-binned data sets (fill the given data set); if dataset has already data append to it. bool Generate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true). generate a bin data set .; A range must have been set before (otherwise inf is returned); and the bins are equidinstant in the previously defined range; bin center values must be present in given data set; If the sampler is implemented by a random one, the entries; will be binned according to the Poisson distribution; It is assumed the distribution is normalized, otherwise the nevt must be scaled; accordingly. The expected value/bin nexp = f(x_i) * binArea/ nevt; Extend control if use a fixed (i.e. multinomial statistics) or floating total number of events. bool Generate(unsigned int nevt, int nbins, double xmin, double xmax, ROOT::Fit::BinData& data, bool extend = true). same as before but passing the range in case of 1 dim data. bool IsInitialized(); check if generator have been initialized correctly and one can start generating. const ROOT::Fit::DataRange & PdfRange() const; return the data range of the Pdf . Must be called after setting the function.  Author: L. Moneta Fri Sep 22 15:06:47 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: DistSampler.h 37371 2010-12-07 16:26:39Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__DistSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DistSampler.html
https://root.cern/root/html532/ROOT__Math__DistSampler.html:6300,Modifiability,extend,extend,6300,"es; Typically Poisson statistics will be used. bool SampleBins(unsigned int n, const double* prob, double* values, double* errors = 0). sample a set of bins given a vector of probabilities; Typically multinomial statistics will be used and the sum of the probabilities; will be equal to the total number of events to be generated; For sampling the bins indipendently, SampleBin should be used. bool Generate(unsigned int nevt, ROOT::Fit::UnBinData& data). generate a un-binned data sets (fill the given data set); if dataset has already data append to it. bool Generate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true). generate a bin data set .; A range must have been set before (otherwise inf is returned); and the bins are equidinstant in the previously defined range; bin center values must be present in given data set; If the sampler is implemented by a random one, the entries; will be binned according to the Poisson distribution; It is assumed the distribution is normalized, otherwise the nevt must be scaled; accordingly. The expected value/bin nexp = f(x_i) * binArea/ nevt; Extend control if use a fixed (i.e. multinomial statistics) or floating total number of events. bool Generate(unsigned int nevt, int nbins, double xmin, double xmax, ROOT::Fit::BinData& data, bool extend = true). same as before but passing the range in case of 1 dim data. bool IsInitialized(); check if generator have been initialized correctly and one can start generating. const ROOT::Fit::DataRange & PdfRange() const; return the data range of the Pdf . Must be called after setting the function.  Author: L. Moneta Fri Sep 22 15:06:47 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: DistSampler.h 37371 2010-12-07 16:26:39Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__DistSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DistSampler.html
https://root.cern/root/html532/ROOT__Math__DistSampler.html:2012,Performance,cache,cached,2012,"Math::IMultiGenFunction&ParentPdf() const; const double*Sample(); virtual boolSample(double* x); virtual doubleSample1D(); virtual boolSampleBin(double prob, double& value, double* error = 0); virtual boolSampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidSetArea(double); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& func); virtual voidSetMode(double); virtual voidSetRandom(TRandom*); voidSetRange(const ROOT::Fit::DataRange& range); voidSetRange(const double* xmin, const double* xmax); voidSetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int). protected:. virtual voidDoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolIsInitialized(); const ROOT::Fit::DataRange&PdfRange() const. Data Members; private:. vector<double>fDatainternal array used to cached the sample data ; const ROOT::Math::IMultiGenFunction*fFuncinternal function (ND); boolfOwnFuncflag to indicate if the function is owned; ROOT::Fit::DataRange*fRangedata range . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~DistSampler(); virtual destructor. void SetFunction(Function & func, unsigned int dim); set the parent function distribution to use for sampling (generic case). DoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); need to clone to avoid temporary. void SetFunction(const ROOT::Math::IGenFunction& func); set the parent function distribution to use for random sampling (one dim case). unsigned int NDim() const; return the dimension of the parent distribution (and the data). { return fData.size(); }. bool Init(const char* = """"). initialize the generators with the given algorithm; Implemented by derived classes who needs it; (like UnuranSampler); If nothing is specified use default algorithm; from DistSamplerOptions::SetDefaultAlgorithm. { return true;}. bool Init(c",MatchSource.WIKI,root/html532/ROOT__Math__DistSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DistSampler.html
https://root.cern/root/html532/ROOT__Math__DistSampler.html:2544,Safety,avoid,avoid,2544,"ltiGenFunction& func); virtual voidSetMode(double); virtual voidSetRandom(TRandom*); voidSetRange(const ROOT::Fit::DataRange& range); voidSetRange(const double* xmin, const double* xmax); voidSetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int). protected:. virtual voidDoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolIsInitialized(); const ROOT::Fit::DataRange&PdfRange() const. Data Members; private:. vector<double>fDatainternal array used to cached the sample data ; const ROOT::Math::IMultiGenFunction*fFuncinternal function (ND); boolfOwnFuncflag to indicate if the function is owned; ROOT::Fit::DataRange*fRangedata range . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~DistSampler(); virtual destructor. void SetFunction(Function & func, unsigned int dim); set the parent function distribution to use for sampling (generic case). DoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); need to clone to avoid temporary. void SetFunction(const ROOT::Math::IGenFunction& func); set the parent function distribution to use for random sampling (one dim case). unsigned int NDim() const; return the dimension of the parent distribution (and the data). { return fData.size(); }. bool Init(const char* = """"). initialize the generators with the given algorithm; Implemented by derived classes who needs it; (like UnuranSampler); If nothing is specified use default algorithm; from DistSamplerOptions::SetDefaultAlgorithm. { return true;}. bool Init(const ROOT::Math::DistSamplerOptions& opt). initialize the generators with the given option; which my include the algorithm but also more if; the method is re-impelmented by derived class; The default implementation calls the above method; passing just the algorithm name. void SetRandom(TRandom* ). Set the random engine to be used; To be implemented by the derived classes who provides; random sampling. {}. void SetSeed(unsi",MatchSource.WIKI,root/html532/ROOT__Math__DistSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DistSampler.html
https://root.cern/root/html532/ROOT__Math__DistSamplerOptions.html:1770,Modifiability,Inherit,Inheritance,1770,"amplerOptions& opt); ROOT::Math::IOptions*ExtraOptions() const; static ROOT::Math::IOptions*FindDefault(const char* name); ROOT::Math::DistSamplerOptions&operator=(const ROOT::Math::DistSamplerOptions& opt); voidPrint(ostream& os = std::cout) const; static voidPrintDefault(const char* name = 0, ostream& os = std::cout); intPrintLevel() const; const string&Sampler() const; voidSetAlgorithm(const char* type); static voidSetDefaultAlgorithm1D(const char* algo); static voidSetDefaultAlgorithmND(const char* algo); static voidSetDefaultPrintLevel(int level); static voidSetDefaultSampler(const char* type); voidSetExtraOptions(const ROOT::Math::IOptions& opt); voidSetPrintLevel(int level); voidSetSampler(const char* type). Data Members; private:. stringfAlgoTypeDistSampler algorithmic specification (for Unuran only); ROOT::Math::IOptions*fExtraOptionsextra options ; intfLeveldebug print level ; stringfSamplerTypeDistSampler type (Unuran, Foam, etc...)xs. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetDefaultSampler(const char* type); static methods for setting and retrieving the default options. void SetDefaultAlgorithm1D(const char* algo). void SetDefaultAlgorithmND(const char* algo). void SetDefaultPrintLevel(int level). const std::string & DefaultSampler(). const std::string & DefaultAlgorithm1D(). const std::string & DefaultAlgorithmND(). int DefaultPrintLevel(). ROOT::Math::IOptions & Default(const char* name); retrieve extra options - if not existing create a IOptions. ROOT::Math::IOptions * FindDefault(const char* name); find extra options - return 0 if not existing. void PrintDefault(const char* name = 0, ostream& os = std::cout); print all the default options for the name given. DistSamplerOptions(int dim = 0); constructor using the default options; pass optionally a pointer to the additional options; otherwise look if they exist for this default minimizer; and in that case they are copied in the constructed instan",MatchSource.WIKI,root/html532/ROOT__Math__DistSamplerOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DistSamplerOptions.html
https://root.cern/root/html532/ROOT__Math__DistSamplerOptions.html:1783,Modifiability,Inherit,Inherited,1783,"amplerOptions& opt); ROOT::Math::IOptions*ExtraOptions() const; static ROOT::Math::IOptions*FindDefault(const char* name); ROOT::Math::DistSamplerOptions&operator=(const ROOT::Math::DistSamplerOptions& opt); voidPrint(ostream& os = std::cout) const; static voidPrintDefault(const char* name = 0, ostream& os = std::cout); intPrintLevel() const; const string&Sampler() const; voidSetAlgorithm(const char* type); static voidSetDefaultAlgorithm1D(const char* algo); static voidSetDefaultAlgorithmND(const char* algo); static voidSetDefaultPrintLevel(int level); static voidSetDefaultSampler(const char* type); voidSetExtraOptions(const ROOT::Math::IOptions& opt); voidSetPrintLevel(int level); voidSetSampler(const char* type). Data Members; private:. stringfAlgoTypeDistSampler algorithmic specification (for Unuran only); ROOT::Math::IOptions*fExtraOptionsextra options ; intfLeveldebug print level ; stringfSamplerTypeDistSampler type (Unuran, Foam, etc...)xs. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetDefaultSampler(const char* type); static methods for setting and retrieving the default options. void SetDefaultAlgorithm1D(const char* algo). void SetDefaultAlgorithmND(const char* algo). void SetDefaultPrintLevel(int level). const std::string & DefaultSampler(). const std::string & DefaultAlgorithm1D(). const std::string & DefaultAlgorithmND(). int DefaultPrintLevel(). ROOT::Math::IOptions & Default(const char* name); retrieve extra options - if not existing create a IOptions. ROOT::Math::IOptions * FindDefault(const char* name); find extra options - return 0 if not existing. void PrintDefault(const char* name = 0, ostream& os = std::cout); print all the default options for the name given. DistSamplerOptions(int dim = 0); constructor using the default options; pass optionally a pointer to the additional options; otherwise look if they exist for this default minimizer; and in that case they are copied in the constructed instan",MatchSource.WIKI,root/html532/ROOT__Math__DistSamplerOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__DistSamplerOptions.html
https://root.cern/root/html532/ROOT__Math__EulerAngles.html:3587,Modifiability,Inherit,Inheritance,3587,"OOT::Math::EulerAngles&operator=(ROOT::Math::RotationY const& r); ROOT::Math::EulerAngles&operator=(ROOT::Math::RotationZ const& r); ROOT::Math::EulerAngles&operator=(const ROOT::Math::EulerAngles&); booloperator==(const ROOT::Math::EulerAngles& rhs) const; ROOT::Math::EulerAngles::ScalarPhi() const; ROOT::Math::EulerAngles::ScalarPsi() const; voidRectify(); voidSetComponents(double* begin, double* end); voidSetComponents(ROOT::Math::EulerAngles::Scalar phi, ROOT::Math::EulerAngles::Scalar theta, ROOT::Math::EulerAngles::Scalar psi); voidSetPhi(ROOT::Math::EulerAngles::Scalar phi); voidSetPsi(ROOT::Math::EulerAngles::Scalar psi); voidSetTheta(ROOT::Math::EulerAngles::Scalar theta); ROOT::Math::EulerAngles::ScalarTheta() const. private:. static doublePi(). Data Members; private:. doublefPhiZ rotation angle (first) defined in [-PI,PI]; doublefPsiZ rotation angle (third) defined in [-PI,PI]; doublefThetaX rotation angle (second) defined only [0,PI]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; EulerAngles(). Default constructor. { }. EulerAngles(ROOT::Math::EulerAngles::Scalar phi, ROOT::Math::EulerAngles::Scalar theta, ROOT::Math::EulerAngles::Scalar psi). Constructor from phi, theta and psi. {Rectify();}. EulerAngles(IT begin, IT end). Construct given a pair of pointers or iterators defining the; beginning and end of an array of three Scalars, to be treated as; the angles phi, theta and psi. { SetComponents(begin,end); }. void Rectify(); The compiler-generated copy ctor, copy assignment, and dtor are OK. Re-adjust components place angles in canonical ranges. EulerAngles & operator=( OtherRotation const & r ). Assign from any other rotation (see gv_detail::convert ). operator=( AxisAngle const & a ). Assign from an AxisAngle. { return operator=(EulerAngles(a)); }. operator=( Quaternion const & q ). Assign from a Quaternion. {return operator=(EulerAngles(q)); }. operator=( RotationZ const & r ). Assign from an axial rotation",MatchSource.WIKI,root/html532/ROOT__Math__EulerAngles.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__EulerAngles.html
https://root.cern/root/html532/ROOT__Math__EulerAngles.html:3600,Modifiability,Inherit,Inherited,3600,"OOT::Math::EulerAngles&operator=(ROOT::Math::RotationY const& r); ROOT::Math::EulerAngles&operator=(ROOT::Math::RotationZ const& r); ROOT::Math::EulerAngles&operator=(const ROOT::Math::EulerAngles&); booloperator==(const ROOT::Math::EulerAngles& rhs) const; ROOT::Math::EulerAngles::ScalarPhi() const; ROOT::Math::EulerAngles::ScalarPsi() const; voidRectify(); voidSetComponents(double* begin, double* end); voidSetComponents(ROOT::Math::EulerAngles::Scalar phi, ROOT::Math::EulerAngles::Scalar theta, ROOT::Math::EulerAngles::Scalar psi); voidSetPhi(ROOT::Math::EulerAngles::Scalar phi); voidSetPsi(ROOT::Math::EulerAngles::Scalar psi); voidSetTheta(ROOT::Math::EulerAngles::Scalar theta); ROOT::Math::EulerAngles::ScalarTheta() const. private:. static doublePi(). Data Members; private:. doublefPhiZ rotation angle (first) defined in [-PI,PI]; doublefPsiZ rotation angle (third) defined in [-PI,PI]; doublefThetaX rotation angle (second) defined only [0,PI]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; EulerAngles(). Default constructor. { }. EulerAngles(ROOT::Math::EulerAngles::Scalar phi, ROOT::Math::EulerAngles::Scalar theta, ROOT::Math::EulerAngles::Scalar psi). Constructor from phi, theta and psi. {Rectify();}. EulerAngles(IT begin, IT end). Construct given a pair of pointers or iterators defining the; beginning and end of an array of three Scalars, to be treated as; the angles phi, theta and psi. { SetComponents(begin,end); }. void Rectify(); The compiler-generated copy ctor, copy assignment, and dtor are OK. Re-adjust components place angles in canonical ranges. EulerAngles & operator=( OtherRotation const & r ). Assign from any other rotation (see gv_detail::convert ). operator=( AxisAngle const & a ). Assign from an AxisAngle. { return operator=(EulerAngles(a)); }. operator=( Quaternion const & q ). Assign from a Quaternion. {return operator=(EulerAngles(q)); }. operator=( RotationZ const & r ). Assign from an axial rotation",MatchSource.WIKI,root/html532/ROOT__Math__EulerAngles.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__EulerAngles.html
https://root.cern/root/html532/ROOT__Math__Factory.html:335,Integrability,interface,interfaces,335,". ROOT::Math::Factory. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::Factory. class ROOT::Math::Factory. Factory class holding static functions to create the interfaces like ROOT::Math::Minimizer; via the Plugin Manager. Function Members (Methods); public:. ~Factory(); static ROOT::Math::DistSampler*CreateDistSampler(const string& samplerType = """"); static ROOT::Math::Minimizer*CreateMinimizer(const string& minimizerType = """", const string& algoType = """"); ROOT::Math::FactoryFactory(); ROOT::Math::FactoryFactory(const ROOT::Math::Factory&); ROOT::Math::Factory&operator=(const ROOT::Math::Factory&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ROOT::Math::Minimizer * CreateMinimizer(const string& minimizerType = """", const string& algoType = """"). static method to create the corrisponding Minimizer given the string; Supported Minimizers types are:; Minuit (TMinuit), Minuit2, GSLMultiMin, GSLMultiFit, GSLSimAn, Linear, Fumili, Genetic; If no name is given use default values defined in MinimizerOptions. ROOT::Math::DistSampler * CreateDistSampler(const string& samplerType = """"). static method to create the distribution sampler class given a string specifying the type; Supported sampler types are:; Unuran, Foam; If no name is given use default values defined in DistSamplerOptions.  Author: L. Moneta Fri Dec 22 14:43:33 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: Factory.h 37448 2010-12-09 20:20:56Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__Factory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Factory.html
https://root.cern/root/html532/ROOT__Math__Factory.html:382,Modifiability,Plugin,Plugin,382,". ROOT::Math::Factory. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::Factory. class ROOT::Math::Factory. Factory class holding static functions to create the interfaces like ROOT::Math::Minimizer; via the Plugin Manager. Function Members (Methods); public:. ~Factory(); static ROOT::Math::DistSampler*CreateDistSampler(const string& samplerType = """"); static ROOT::Math::Minimizer*CreateMinimizer(const string& minimizerType = """", const string& algoType = """"); ROOT::Math::FactoryFactory(); ROOT::Math::FactoryFactory(const ROOT::Math::Factory&); ROOT::Math::Factory&operator=(const ROOT::Math::Factory&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ROOT::Math::Minimizer * CreateMinimizer(const string& minimizerType = """", const string& algoType = """"). static method to create the corrisponding Minimizer given the string; Supported Minimizers types are:; Minuit (TMinuit), Minuit2, GSLMultiMin, GSLMultiFit, GSLSimAn, Linear, Fumili, Genetic; If no name is given use default values defined in MinimizerOptions. ROOT::Math::DistSampler * CreateDistSampler(const string& samplerType = """"). static method to create the distribution sampler class given a string specifying the type; Supported sampler types are:; Unuran, Foam; If no name is given use default values defined in DistSamplerOptions.  Author: L. Moneta Fri Dec 22 14:43:33 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: Factory.h 37448 2010-12-09 20:20:56Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__Factory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Factory.html
https://root.cern/root/html532/ROOT__Math__Factory.html:797,Modifiability,Inherit,Inheritance,797,". ROOT::Math::Factory. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::Factory. class ROOT::Math::Factory. Factory class holding static functions to create the interfaces like ROOT::Math::Minimizer; via the Plugin Manager. Function Members (Methods); public:. ~Factory(); static ROOT::Math::DistSampler*CreateDistSampler(const string& samplerType = """"); static ROOT::Math::Minimizer*CreateMinimizer(const string& minimizerType = """", const string& algoType = """"); ROOT::Math::FactoryFactory(); ROOT::Math::FactoryFactory(const ROOT::Math::Factory&); ROOT::Math::Factory&operator=(const ROOT::Math::Factory&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ROOT::Math::Minimizer * CreateMinimizer(const string& minimizerType = """", const string& algoType = """"). static method to create the corrisponding Minimizer given the string; Supported Minimizers types are:; Minuit (TMinuit), Minuit2, GSLMultiMin, GSLMultiFit, GSLSimAn, Linear, Fumili, Genetic; If no name is given use default values defined in MinimizerOptions. ROOT::Math::DistSampler * CreateDistSampler(const string& samplerType = """"). static method to create the distribution sampler class given a string specifying the type; Supported sampler types are:; Unuran, Foam; If no name is given use default values defined in DistSamplerOptions.  Author: L. Moneta Fri Dec 22 14:43:33 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: Factory.h 37448 2010-12-09 20:20:56Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__Factory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Factory.html
https://root.cern/root/html532/ROOT__Math__Factory.html:810,Modifiability,Inherit,Inherited,810,". ROOT::Math::Factory. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::Factory. class ROOT::Math::Factory. Factory class holding static functions to create the interfaces like ROOT::Math::Minimizer; via the Plugin Manager. Function Members (Methods); public:. ~Factory(); static ROOT::Math::DistSampler*CreateDistSampler(const string& samplerType = """"); static ROOT::Math::Minimizer*CreateMinimizer(const string& minimizerType = """", const string& algoType = """"); ROOT::Math::FactoryFactory(); ROOT::Math::FactoryFactory(const ROOT::Math::Factory&); ROOT::Math::Factory&operator=(const ROOT::Math::Factory&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ROOT::Math::Minimizer * CreateMinimizer(const string& minimizerType = """", const string& algoType = """"). static method to create the corrisponding Minimizer given the string; Supported Minimizers types are:; Minuit (TMinuit), Minuit2, GSLMultiMin, GSLMultiFit, GSLSimAn, Linear, Fumili, Genetic; If no name is given use default values defined in MinimizerOptions. ROOT::Math::DistSampler * CreateDistSampler(const string& samplerType = """"). static method to create the distribution sampler class given a string specifying the type; Supported sampler types are:; Unuran, Foam; If no name is given use default values defined in DistSamplerOptions.  Author: L. Moneta Fri Dec 22 14:43:33 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: Factory.h 37448 2010-12-09 20:20:56Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__Factory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Factory.html
https://root.cern/root/html532/ROOT__Math__Functor.html:378,Integrability,wrap,wrap,378,". ROOT::Math::Functor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::Functor. class ROOT::Math::Functor: public ROOT::Math::IBaseFunctionMultiDim. Documentation for class Functor class.; It is used to wrap in a very simple and convenient way multi-dimensional function objects.; It can wrap all the following types:; <ul>; <li> any C++ callable object implemention double operator()( const double * ); <li> a free C function of type double ()(double * ); <li> a member function with the correct signature like Foo::Eval(const double * ).; In this case one pass the object pointer and a pointer to the member function (&Foo::Eval); </ul>; The function dimension is required when constructing the functor. @ingroup GenFunc. Function Members (Methods); public:. virtual~Functor(); virtual ROOT::Math::Functor::ImplBase*Clone() const; ROOT::Math::FunctorFunctor(); ROOT::Math::FunctorFunctor(const ROOT::Math::Functor&); ROOT::Math::FunctorFunctor(void* p, unsigned int dim, const char* className = 0, const char* methodName = 0); virtual unsigned intNDim() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::Functor&operator=(const ROOT::Math::Functor& rhs). private:. virtual doubleDoEval(const double* x) const. Data Members; private:. auto_ptr<ROOT::Math::IBaseFunctionMultiDim>fImplpointer to base functor handler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunc * Clone() const; clone of the function handler (use copy-ctor). unsigned int NDim() const; constructor for multi-dimensional functions. double DoEval(const double* x) const. Functor(). Default constructor. {}. Functor(const PtrObj& p, MemFn memFn, unsigned int dim ). construct from a pointer to member function (multi-dim type). {}. Functor( const Func & f, unsig",MatchSource.WIKI,root/html532/ROOT__Math__Functor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Functor.html
https://root.cern/root/html532/ROOT__Math__Functor.html:463,Integrability,wrap,wrap,463,". ROOT::Math::Functor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::Functor. class ROOT::Math::Functor: public ROOT::Math::IBaseFunctionMultiDim. Documentation for class Functor class.; It is used to wrap in a very simple and convenient way multi-dimensional function objects.; It can wrap all the following types:; <ul>; <li> any C++ callable object implemention double operator()( const double * ); <li> a free C function of type double ()(double * ); <li> a member function with the correct signature like Foo::Eval(const double * ).; In this case one pass the object pointer and a pointer to the member function (&Foo::Eval); </ul>; The function dimension is required when constructing the functor. @ingroup GenFunc. Function Members (Methods); public:. virtual~Functor(); virtual ROOT::Math::Functor::ImplBase*Clone() const; ROOT::Math::FunctorFunctor(); ROOT::Math::FunctorFunctor(const ROOT::Math::Functor&); ROOT::Math::FunctorFunctor(void* p, unsigned int dim, const char* className = 0, const char* methodName = 0); virtual unsigned intNDim() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::Functor&operator=(const ROOT::Math::Functor& rhs). private:. virtual doubleDoEval(const double* x) const. Data Members; private:. auto_ptr<ROOT::Math::IBaseFunctionMultiDim>fImplpointer to base functor handler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunc * Clone() const; clone of the function handler (use copy-ctor). unsigned int NDim() const; constructor for multi-dimensional functions. double DoEval(const double* x) const. Functor(). Default constructor. {}. Functor(const PtrObj& p, MemFn memFn, unsigned int dim ). construct from a pointer to member function (multi-dim type). {}. Functor( const Func & f, unsig",MatchSource.WIKI,root/html532/ROOT__Math__Functor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Functor.html
https://root.cern/root/html532/ROOT__Math__Functor.html:1551,Modifiability,Inherit,Inheritance,1551," const double * ); <li> a free C function of type double ()(double * ); <li> a member function with the correct signature like Foo::Eval(const double * ).; In this case one pass the object pointer and a pointer to the member function (&Foo::Eval); </ul>; The function dimension is required when constructing the functor. @ingroup GenFunc. Function Members (Methods); public:. virtual~Functor(); virtual ROOT::Math::Functor::ImplBase*Clone() const; ROOT::Math::FunctorFunctor(); ROOT::Math::FunctorFunctor(const ROOT::Math::Functor&); ROOT::Math::FunctorFunctor(void* p, unsigned int dim, const char* className = 0, const char* methodName = 0); virtual unsigned intNDim() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::Functor&operator=(const ROOT::Math::Functor& rhs). private:. virtual doubleDoEval(const double* x) const. Data Members; private:. auto_ptr<ROOT::Math::IBaseFunctionMultiDim>fImplpointer to base functor handler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunc * Clone() const; clone of the function handler (use copy-ctor). unsigned int NDim() const; constructor for multi-dimensional functions. double DoEval(const double* x) const. Functor(). Default constructor. {}. Functor(const PtrObj& p, MemFn memFn, unsigned int dim ). construct from a pointer to member function (multi-dim type). {}. Functor( const Func & f, unsigned int dim ). construct from a callable object of multi-dimension; with the right signature (implementing operator()(double *x). {}. virtual ~Functor(). Destructor (no operations). {}.  Author: L. Moneta Mon Nov 13 15:58:13 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: Functor.h 33180 2010-04-25 10:14:07Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__Functor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Functor.html
https://root.cern/root/html532/ROOT__Math__Functor.html:1564,Modifiability,Inherit,Inherited,1564," const double * ); <li> a free C function of type double ()(double * ); <li> a member function with the correct signature like Foo::Eval(const double * ).; In this case one pass the object pointer and a pointer to the member function (&Foo::Eval); </ul>; The function dimension is required when constructing the functor. @ingroup GenFunc. Function Members (Methods); public:. virtual~Functor(); virtual ROOT::Math::Functor::ImplBase*Clone() const; ROOT::Math::FunctorFunctor(); ROOT::Math::FunctorFunctor(const ROOT::Math::Functor&); ROOT::Math::FunctorFunctor(void* p, unsigned int dim, const char* className = 0, const char* methodName = 0); virtual unsigned intNDim() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::Functor&operator=(const ROOT::Math::Functor& rhs). private:. virtual doubleDoEval(const double* x) const. Data Members; private:. auto_ptr<ROOT::Math::IBaseFunctionMultiDim>fImplpointer to base functor handler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunc * Clone() const; clone of the function handler (use copy-ctor). unsigned int NDim() const; constructor for multi-dimensional functions. double DoEval(const double* x) const. Functor(). Default constructor. {}. Functor(const PtrObj& p, MemFn memFn, unsigned int dim ). construct from a pointer to member function (multi-dim type). {}. Functor( const Func & f, unsigned int dim ). construct from a callable object of multi-dimension; with the right signature (implementing operator()(double *x). {}. virtual ~Functor(). Destructor (no operations). {}.  Author: L. Moneta Mon Nov 13 15:58:13 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: Functor.h 33180 2010-04-25 10:14:07Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__Functor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Functor.html
https://root.cern/root/html532/ROOT__Math__Functor.html:393,Usability,simpl,simple,393,". ROOT::Math::Functor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::Functor. class ROOT::Math::Functor: public ROOT::Math::IBaseFunctionMultiDim. Documentation for class Functor class.; It is used to wrap in a very simple and convenient way multi-dimensional function objects.; It can wrap all the following types:; <ul>; <li> any C++ callable object implemention double operator()( const double * ); <li> a free C function of type double ()(double * ); <li> a member function with the correct signature like Foo::Eval(const double * ).; In this case one pass the object pointer and a pointer to the member function (&Foo::Eval); </ul>; The function dimension is required when constructing the functor. @ingroup GenFunc. Function Members (Methods); public:. virtual~Functor(); virtual ROOT::Math::Functor::ImplBase*Clone() const; ROOT::Math::FunctorFunctor(); ROOT::Math::FunctorFunctor(const ROOT::Math::Functor&); ROOT::Math::FunctorFunctor(void* p, unsigned int dim, const char* className = 0, const char* methodName = 0); virtual unsigned intNDim() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::Functor&operator=(const ROOT::Math::Functor& rhs). private:. virtual doubleDoEval(const double* x) const. Data Members; private:. auto_ptr<ROOT::Math::IBaseFunctionMultiDim>fImplpointer to base functor handler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunc * Clone() const; clone of the function handler (use copy-ctor). unsigned int NDim() const; constructor for multi-dimensional functions. double DoEval(const double* x) const. Functor(). Default constructor. {}. Functor(const PtrObj& p, MemFn memFn, unsigned int dim ). construct from a pointer to member function (multi-dim type). {}. Functor( const Func & f, unsig",MatchSource.WIKI,root/html532/ROOT__Math__Functor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Functor.html
https://root.cern/root/html532/ROOT__Math__Functor1D.html:382,Integrability,wrap,wrap,382,". ROOT::Math::Functor1D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::Functor1D. class ROOT::Math::Functor1D: public ROOT::Math::IBaseFunctionOneDim. Documentation for class Functor class.; It is used to wrap in a very simple and convenient way multi-dimensional function objects.; It can wrap all the following types:; <ul>; <li> any C++ callable object implemention double operator()( const double * ); <li> a free C function of type double ()(double * ); <li> a member function with the correct signature like Foo::Eval(const double * ).; In this case one pass the object pointer and a pointer to the member function (&Foo::Eval); </ul>; The function dimension is required when constructing the functor. @ingroup GenFunc. Function Members (Methods); public:. virtual~Functor1D(); virtual ROOT::Math::Functor1D::ImplBase*Clone() const; ROOT::Math::Functor1DFunctor1D(); ROOT::Math::Functor1DFunctor1D(const ROOT::Math::Functor1D&); ROOT::Math::Functor1DFunctor1D(void* p, const char* className = 0, const char* methodName = 0); doubleROOT::Math::IBaseFunctionOneDim::operator()(double x) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(const double* x) const; ROOT::Math::Functor1D&operator=(const ROOT::Math::Functor1D& rhs). private:. virtual doubleDoEval(double x) const. Data Members; private:. auto_ptr<ROOT::Math::IBaseFunctionOneDim>fImplpointer to base functor handler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunc * Clone() const; clone of the function handler (use copy-ctor). double DoEval(double x) const. Functor1D(). Default constructor. {}. Functor1D(const PtrObj& p, MemFn memFn). construct from a pointer to member function (1D type). {}. Functor1D(const ROOT::Math::Functor1D& ). construct from a callable object with the right signature; ",MatchSource.WIKI,root/html532/ROOT__Math__Functor1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Functor1D.html
https://root.cern/root/html532/ROOT__Math__Functor1D.html:467,Integrability,wrap,wrap,467,". ROOT::Math::Functor1D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::Functor1D. class ROOT::Math::Functor1D: public ROOT::Math::IBaseFunctionOneDim. Documentation for class Functor class.; It is used to wrap in a very simple and convenient way multi-dimensional function objects.; It can wrap all the following types:; <ul>; <li> any C++ callable object implemention double operator()( const double * ); <li> a free C function of type double ()(double * ); <li> a member function with the correct signature like Foo::Eval(const double * ).; In this case one pass the object pointer and a pointer to the member function (&Foo::Eval); </ul>; The function dimension is required when constructing the functor. @ingroup GenFunc. Function Members (Methods); public:. virtual~Functor1D(); virtual ROOT::Math::Functor1D::ImplBase*Clone() const; ROOT::Math::Functor1DFunctor1D(); ROOT::Math::Functor1DFunctor1D(const ROOT::Math::Functor1D&); ROOT::Math::Functor1DFunctor1D(void* p, const char* className = 0, const char* methodName = 0); doubleROOT::Math::IBaseFunctionOneDim::operator()(double x) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(const double* x) const; ROOT::Math::Functor1D&operator=(const ROOT::Math::Functor1D& rhs). private:. virtual doubleDoEval(double x) const. Data Members; private:. auto_ptr<ROOT::Math::IBaseFunctionOneDim>fImplpointer to base functor handler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunc * Clone() const; clone of the function handler (use copy-ctor). double DoEval(double x) const. Functor1D(). Default constructor. {}. Functor1D(const PtrObj& p, MemFn memFn). construct from a pointer to member function (1D type). {}. Functor1D(const ROOT::Math::Functor1D& ). construct from a callable object with the right signature; ",MatchSource.WIKI,root/html532/ROOT__Math__Functor1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Functor1D.html
https://root.cern/root/html532/ROOT__Math__Functor1D.html:1581,Modifiability,Inherit,Inheritance,1581,"rap all the following types:; <ul>; <li> any C++ callable object implemention double operator()( const double * ); <li> a free C function of type double ()(double * ); <li> a member function with the correct signature like Foo::Eval(const double * ).; In this case one pass the object pointer and a pointer to the member function (&Foo::Eval); </ul>; The function dimension is required when constructing the functor. @ingroup GenFunc. Function Members (Methods); public:. virtual~Functor1D(); virtual ROOT::Math::Functor1D::ImplBase*Clone() const; ROOT::Math::Functor1DFunctor1D(); ROOT::Math::Functor1DFunctor1D(const ROOT::Math::Functor1D&); ROOT::Math::Functor1DFunctor1D(void* p, const char* className = 0, const char* methodName = 0); doubleROOT::Math::IBaseFunctionOneDim::operator()(double x) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(const double* x) const; ROOT::Math::Functor1D&operator=(const ROOT::Math::Functor1D& rhs). private:. virtual doubleDoEval(double x) const. Data Members; private:. auto_ptr<ROOT::Math::IBaseFunctionOneDim>fImplpointer to base functor handler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunc * Clone() const; clone of the function handler (use copy-ctor). double DoEval(double x) const. Functor1D(). Default constructor. {}. Functor1D(const PtrObj& p, MemFn memFn). construct from a pointer to member function (1D type). {}. Functor1D(const ROOT::Math::Functor1D& ). construct from a callable object with the right signature; implementing operator() (double x). {}. virtual ~Functor1D(). Destructor (no operations). {}.  Author: L. Moneta Mon Nov 13 15:58:13 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: Functor.h 33180 2010-04-25 10:14:07Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__Functor1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Functor1D.html
https://root.cern/root/html532/ROOT__Math__Functor1D.html:1594,Modifiability,Inherit,Inherited,1594,"rap all the following types:; <ul>; <li> any C++ callable object implemention double operator()( const double * ); <li> a free C function of type double ()(double * ); <li> a member function with the correct signature like Foo::Eval(const double * ).; In this case one pass the object pointer and a pointer to the member function (&Foo::Eval); </ul>; The function dimension is required when constructing the functor. @ingroup GenFunc. Function Members (Methods); public:. virtual~Functor1D(); virtual ROOT::Math::Functor1D::ImplBase*Clone() const; ROOT::Math::Functor1DFunctor1D(); ROOT::Math::Functor1DFunctor1D(const ROOT::Math::Functor1D&); ROOT::Math::Functor1DFunctor1D(void* p, const char* className = 0, const char* methodName = 0); doubleROOT::Math::IBaseFunctionOneDim::operator()(double x) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(const double* x) const; ROOT::Math::Functor1D&operator=(const ROOT::Math::Functor1D& rhs). private:. virtual doubleDoEval(double x) const. Data Members; private:. auto_ptr<ROOT::Math::IBaseFunctionOneDim>fImplpointer to base functor handler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunc * Clone() const; clone of the function handler (use copy-ctor). double DoEval(double x) const. Functor1D(). Default constructor. {}. Functor1D(const PtrObj& p, MemFn memFn). construct from a pointer to member function (1D type). {}. Functor1D(const ROOT::Math::Functor1D& ). construct from a callable object with the right signature; implementing operator() (double x). {}. virtual ~Functor1D(). Destructor (no operations). {}.  Author: L. Moneta Mon Nov 13 15:58:13 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: Functor.h 33180 2010-04-25 10:14:07Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__Functor1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Functor1D.html
https://root.cern/root/html532/ROOT__Math__Functor1D.html:397,Usability,simpl,simple,397,". ROOT::Math::Functor1D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::Functor1D. class ROOT::Math::Functor1D: public ROOT::Math::IBaseFunctionOneDim. Documentation for class Functor class.; It is used to wrap in a very simple and convenient way multi-dimensional function objects.; It can wrap all the following types:; <ul>; <li> any C++ callable object implemention double operator()( const double * ); <li> a free C function of type double ()(double * ); <li> a member function with the correct signature like Foo::Eval(const double * ).; In this case one pass the object pointer and a pointer to the member function (&Foo::Eval); </ul>; The function dimension is required when constructing the functor. @ingroup GenFunc. Function Members (Methods); public:. virtual~Functor1D(); virtual ROOT::Math::Functor1D::ImplBase*Clone() const; ROOT::Math::Functor1DFunctor1D(); ROOT::Math::Functor1DFunctor1D(const ROOT::Math::Functor1D&); ROOT::Math::Functor1DFunctor1D(void* p, const char* className = 0, const char* methodName = 0); doubleROOT::Math::IBaseFunctionOneDim::operator()(double x) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(const double* x) const; ROOT::Math::Functor1D&operator=(const ROOT::Math::Functor1D& rhs). private:. virtual doubleDoEval(double x) const. Data Members; private:. auto_ptr<ROOT::Math::IBaseFunctionOneDim>fImplpointer to base functor handler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunc * Clone() const; clone of the function handler (use copy-ctor). double DoEval(double x) const. Functor1D(). Default constructor. {}. Functor1D(const PtrObj& p, MemFn memFn). construct from a pointer to member function (1D type). {}. Functor1D(const ROOT::Math::Functor1D& ). construct from a callable object with the right signature; ",MatchSource.WIKI,root/html532/ROOT__Math__Functor1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__Functor1D.html
https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html:1807,Availability,error,error,1807,"tegrator&); virtual doubleIntegral(); virtual doubleIntegral(const vector<double>& pts); virtual doubleIntegral(double a, double b); virtual doubleIntegralCauchy(double a, double b, double c); virtual doubleIntegralLow(double b); virtual doubleIntegralUp(double a); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double); virtual intStatus() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. private:. virtual doubleDoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Data Members; protected:. doublefEpsilonRelative error.; const ROOT::Math::IGenFunction*fFunctionPointer to function used.; doublefLastErrorError from the last stimation.; doublefLastResultResult from the last stimation.; boolfUsedOnceBool value to check if the function was at least called once.; static boolfgAbsValueAbsValue used for the calculation of the integral. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~GaussIntegrator(); Destructor . GaussIntegrator(double relTol = 1.E-12); Default Constructor. . void AbsValue(bool flag); Static function: set the fgAbsValue flag.; By default TF1::Integral uses the original function value to compute the integral; However, TF1::Moment, CentralMoment require to compute the integral; using the absolute value of the function. void SetRelTolerance(double ); Implementing VirtualIntegrator Interface; Set the desired relative Error. . void SetAbsTolerance(double ); This method is not implemented. . double Result() const; Returns the resu",MatchSource.WIKI,root/html532/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html:2685,Availability,Error,Error,2685,"atorOneDim::Type() const. private:. virtual doubleDoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Data Members; protected:. doublefEpsilonRelative error.; const ROOT::Math::IGenFunction*fFunctionPointer to function used.; doublefLastErrorError from the last stimation.; doublefLastResultResult from the last stimation.; boolfUsedOnceBool value to check if the function was at least called once.; static boolfgAbsValueAbsValue used for the calculation of the integral. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~GaussIntegrator(); Destructor . GaussIntegrator(double relTol = 1.E-12); Default Constructor. . void AbsValue(bool flag); Static function: set the fgAbsValue flag.; By default TF1::Integral uses the original function value to compute the integral; However, TF1::Moment, CentralMoment require to compute the integral; using the absolute value of the function. void SetRelTolerance(double ); Implementing VirtualIntegrator Interface; Set the desired relative Error. . void SetAbsTolerance(double ); This method is not implemented. . double Result() const; Returns the result of the last Integral calculation. . double Error() const; Return the estimate of the absolute Error of the last Integral calculation. . int Status() const; return the status of the last integration - 0 in case of success . double Integral(double a, double b); Implementing VirtualIntegratorOneDim Interface. Returns Integral of function between a and b.; Based on original CERNLIB routine DGAUSS by Sigfried Kolbig; converted to C++ by Rene Brun. This function computes, to an attempted specified accuracy, the value; of the integral. Method:; For any interval [a,b] we define g8(a,b) and g16(a,b) to be the 8-point; and 16-point Gaussian quadrature approximations to. and define. Then,. where, starting with x0 = A and finishing with xk = B,; the subdivision points xi(i=1,2,...) are given by. is equal to the first member of the; sequen",MatchSource.WIKI,root/html532/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html:2844,Availability,Error,Error,2844,"blefLastErrorError from the last stimation.; doublefLastResultResult from the last stimation.; boolfUsedOnceBool value to check if the function was at least called once.; static boolfgAbsValueAbsValue used for the calculation of the integral. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~GaussIntegrator(); Destructor . GaussIntegrator(double relTol = 1.E-12); Default Constructor. . void AbsValue(bool flag); Static function: set the fgAbsValue flag.; By default TF1::Integral uses the original function value to compute the integral; However, TF1::Moment, CentralMoment require to compute the integral; using the absolute value of the function. void SetRelTolerance(double ); Implementing VirtualIntegrator Interface; Set the desired relative Error. . void SetAbsTolerance(double ); This method is not implemented. . double Result() const; Returns the result of the last Integral calculation. . double Error() const; Return the estimate of the absolute Error of the last Integral calculation. . int Status() const; return the status of the last integration - 0 in case of success . double Integral(double a, double b); Implementing VirtualIntegratorOneDim Interface. Returns Integral of function between a and b.; Based on original CERNLIB routine DGAUSS by Sigfried Kolbig; converted to C++ by Rene Brun. This function computes, to an attempted specified accuracy, the value; of the integral. Method:; For any interval [a,b] we define g8(a,b) and g16(a,b) to be the 8-point; and 16-point Gaussian quadrature approximations to. and define. Then,. where, starting with x0 = A and finishing with xk = B,; the subdivision points xi(i=1,2,...) are given by. is equal to the first member of the; sequence 1,1/2,1/4,... for which r(xi-1, xi) < EPS.; If, at any stage in the process of subdivision, the ratio. is so small that 1+0.005q is indistinguishable from 1 to; machine accuracy, an error exit occurs with the function value; set equal to zero.",MatchSource.WIKI,root/html532/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html:2895,Availability,Error,Error,2895,"blefLastErrorError from the last stimation.; doublefLastResultResult from the last stimation.; boolfUsedOnceBool value to check if the function was at least called once.; static boolfgAbsValueAbsValue used for the calculation of the integral. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~GaussIntegrator(); Destructor . GaussIntegrator(double relTol = 1.E-12); Default Constructor. . void AbsValue(bool flag); Static function: set the fgAbsValue flag.; By default TF1::Integral uses the original function value to compute the integral; However, TF1::Moment, CentralMoment require to compute the integral; using the absolute value of the function. void SetRelTolerance(double ); Implementing VirtualIntegrator Interface; Set the desired relative Error. . void SetAbsTolerance(double ); This method is not implemented. . double Result() const; Returns the result of the last Integral calculation. . double Error() const; Return the estimate of the absolute Error of the last Integral calculation. . int Status() const; return the status of the last integration - 0 in case of success . double Integral(double a, double b); Implementing VirtualIntegratorOneDim Interface. Returns Integral of function between a and b.; Based on original CERNLIB routine DGAUSS by Sigfried Kolbig; converted to C++ by Rene Brun. This function computes, to an attempted specified accuracy, the value; of the integral. Method:; For any interval [a,b] we define g8(a,b) and g16(a,b) to be the 8-point; and 16-point Gaussian quadrature approximations to. and define. Then,. where, starting with x0 = A and finishing with xk = B,; the subdivision points xi(i=1,2,...) are given by. is equal to the first member of the; sequence 1,1/2,1/4,... for which r(xi-1, xi) < EPS.; If, at any stage in the process of subdivision, the ratio. is so small that 1+0.005q is indistinguishable from 1 to; machine accuracy, an error exit occurs with the function value; set equal to zero.",MatchSource.WIKI,root/html532/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html:3824,Availability,error,error,3824,"culation. . double Error() const; Return the estimate of the absolute Error of the last Integral calculation. . int Status() const; return the status of the last integration - 0 in case of success . double Integral(double a, double b); Implementing VirtualIntegratorOneDim Interface. Returns Integral of function between a and b.; Based on original CERNLIB routine DGAUSS by Sigfried Kolbig; converted to C++ by Rene Brun. This function computes, to an attempted specified accuracy, the value; of the integral. Method:; For any interval [a,b] we define g8(a,b) and g16(a,b) to be the 8-point; and 16-point Gaussian quadrature approximations to. and define. Then,. where, starting with x0 = A and finishing with xk = B,; the subdivision points xi(i=1,2,...) are given by. is equal to the first member of the; sequence 1,1/2,1/4,... for which r(xi-1, xi) < EPS.; If, at any stage in the process of subdivision, the ratio. is so small that 1+0.005q is indistinguishable from 1 to; machine accuracy, an error exit occurs with the function value; set equal to zero. Accuracy:; Unless there is severe cancellation of positive and negative values of; f(x) over the interval [A,B], the relative error may be considered as; specifying a bound on the <I>relative</I> error of I in the case; |I|&gt;1, and a bound on the absolute error in the case |I|&lt;1. More; precisely, if k is the number of sub-intervals contributing to the; approximation (see Method), and if. then the relation. will nearly always be true, provided the routine terminates without; printing an error message. For functions f having no singularities in; the closed interval [A,B] the accuracy will usually be much higher than; this. Error handling:; The requested accuracy cannot be obtained (see Method).; The function value is set equal to zero. Note 1:; Values of the function f(x) at the interval end-points A and B are not; required. The subprogram may therefore be used when these values are; undefined. double Integral(); Returns In",MatchSource.WIKI,root/html532/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html:4012,Availability,error,error,4012,"le Integral(double a, double b); Implementing VirtualIntegratorOneDim Interface. Returns Integral of function between a and b.; Based on original CERNLIB routine DGAUSS by Sigfried Kolbig; converted to C++ by Rene Brun. This function computes, to an attempted specified accuracy, the value; of the integral. Method:; For any interval [a,b] we define g8(a,b) and g16(a,b) to be the 8-point; and 16-point Gaussian quadrature approximations to. and define. Then,. where, starting with x0 = A and finishing with xk = B,; the subdivision points xi(i=1,2,...) are given by. is equal to the first member of the; sequence 1,1/2,1/4,... for which r(xi-1, xi) < EPS.; If, at any stage in the process of subdivision, the ratio. is so small that 1+0.005q is indistinguishable from 1 to; machine accuracy, an error exit occurs with the function value; set equal to zero. Accuracy:; Unless there is severe cancellation of positive and negative values of; f(x) over the interval [A,B], the relative error may be considered as; specifying a bound on the <I>relative</I> error of I in the case; |I|&gt;1, and a bound on the absolute error in the case |I|&lt;1. More; precisely, if k is the number of sub-intervals contributing to the; approximation (see Method), and if. then the relation. will nearly always be true, provided the routine terminates without; printing an error message. For functions f having no singularities in; the closed interval [A,B] the accuracy will usually be much higher than; this. Error handling:; The requested accuracy cannot be obtained (see Method).; The function value is set equal to zero. Note 1:; Values of the function f(x) at the interval end-points A and B are not; required. The subprogram may therefore be used when these values are; undefined. double Integral(); Returns Integral of function on an infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approxima",MatchSource.WIKI,root/html532/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html:4082,Availability,error,error,4082,"le Integral(double a, double b); Implementing VirtualIntegratorOneDim Interface. Returns Integral of function between a and b.; Based on original CERNLIB routine DGAUSS by Sigfried Kolbig; converted to C++ by Rene Brun. This function computes, to an attempted specified accuracy, the value; of the integral. Method:; For any interval [a,b] we define g8(a,b) and g16(a,b) to be the 8-point; and 16-point Gaussian quadrature approximations to. and define. Then,. where, starting with x0 = A and finishing with xk = B,; the subdivision points xi(i=1,2,...) are given by. is equal to the first member of the; sequence 1,1/2,1/4,... for which r(xi-1, xi) < EPS.; If, at any stage in the process of subdivision, the ratio. is so small that 1+0.005q is indistinguishable from 1 to; machine accuracy, an error exit occurs with the function value; set equal to zero. Accuracy:; Unless there is severe cancellation of positive and negative values of; f(x) over the interval [A,B], the relative error may be considered as; specifying a bound on the <I>relative</I> error of I in the case; |I|&gt;1, and a bound on the absolute error in the case |I|&lt;1. More; precisely, if k is the number of sub-intervals contributing to the; approximation (see Method), and if. then the relation. will nearly always be true, provided the routine terminates without; printing an error message. For functions f having no singularities in; the closed interval [A,B] the accuracy will usually be much higher than; this. Error handling:; The requested accuracy cannot be obtained (see Method).; The function value is set equal to zero. Note 1:; Values of the function f(x) at the interval end-points A and B are not; required. The subprogram may therefore be used when these values are; undefined. double Integral(); Returns Integral of function on an infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approxima",MatchSource.WIKI,root/html532/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html:4144,Availability,error,error,4144,"le Integral(double a, double b); Implementing VirtualIntegratorOneDim Interface. Returns Integral of function between a and b.; Based on original CERNLIB routine DGAUSS by Sigfried Kolbig; converted to C++ by Rene Brun. This function computes, to an attempted specified accuracy, the value; of the integral. Method:; For any interval [a,b] we define g8(a,b) and g16(a,b) to be the 8-point; and 16-point Gaussian quadrature approximations to. and define. Then,. where, starting with x0 = A and finishing with xk = B,; the subdivision points xi(i=1,2,...) are given by. is equal to the first member of the; sequence 1,1/2,1/4,... for which r(xi-1, xi) < EPS.; If, at any stage in the process of subdivision, the ratio. is so small that 1+0.005q is indistinguishable from 1 to; machine accuracy, an error exit occurs with the function value; set equal to zero. Accuracy:; Unless there is severe cancellation of positive and negative values of; f(x) over the interval [A,B], the relative error may be considered as; specifying a bound on the <I>relative</I> error of I in the case; |I|&gt;1, and a bound on the absolute error in the case |I|&lt;1. More; precisely, if k is the number of sub-intervals contributing to the; approximation (see Method), and if. then the relation. will nearly always be true, provided the routine terminates without; printing an error message. For functions f having no singularities in; the closed interval [A,B] the accuracy will usually be much higher than; this. Error handling:; The requested accuracy cannot be obtained (see Method).; The function value is set equal to zero. Note 1:; Values of the function f(x) at the interval end-points A and B are not; required. The subprogram may therefore be used when these values are; undefined. double Integral(); Returns Integral of function on an infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approxima",MatchSource.WIKI,root/html532/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html:4382,Availability,error,error,4382," any interval [a,b] we define g8(a,b) and g16(a,b) to be the 8-point; and 16-point Gaussian quadrature approximations to. and define. Then,. where, starting with x0 = A and finishing with xk = B,; the subdivision points xi(i=1,2,...) are given by. is equal to the first member of the; sequence 1,1/2,1/4,... for which r(xi-1, xi) < EPS.; If, at any stage in the process of subdivision, the ratio. is so small that 1+0.005q is indistinguishable from 1 to; machine accuracy, an error exit occurs with the function value; set equal to zero. Accuracy:; Unless there is severe cancellation of positive and negative values of; f(x) over the interval [A,B], the relative error may be considered as; specifying a bound on the <I>relative</I> error of I in the case; |I|&gt;1, and a bound on the absolute error in the case |I|&lt;1. More; precisely, if k is the number of sub-intervals contributing to the; approximation (see Method), and if. then the relation. will nearly always be true, provided the routine terminates without; printing an error message. For functions f having no singularities in; the closed interval [A,B] the accuracy will usually be much higher than; this. Error handling:; The requested accuracy cannot be obtained (see Method).; The function value is set equal to zero. Note 1:; Values of the function f(x) at the interval end-points A and B are not; required. The subprogram may therefore be used when these values are; undefined. double Integral(); Returns Integral of function on an infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. double IntegralUp(double a); Returns Integral of function on an upper semi-infinite interval.; This function computes, to an attempted specified accuracy, the value of the integra",MatchSource.WIKI,root/html532/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html:4520,Availability,Error,Error,4520,"ision points xi(i=1,2,...) are given by. is equal to the first member of the; sequence 1,1/2,1/4,... for which r(xi-1, xi) < EPS.; If, at any stage in the process of subdivision, the ratio. is so small that 1+0.005q is indistinguishable from 1 to; machine accuracy, an error exit occurs with the function value; set equal to zero. Accuracy:; Unless there is severe cancellation of positive and negative values of; f(x) over the interval [A,B], the relative error may be considered as; specifying a bound on the <I>relative</I> error of I in the case; |I|&gt;1, and a bound on the absolute error in the case |I|&lt;1. More; precisely, if k is the number of sub-intervals contributing to the; approximation (see Method), and if. then the relation. will nearly always be true, provided the routine terminates without; printing an error message. For functions f having no singularities in; the closed interval [A,B] the accuracy will usually be much higher than; this. Error handling:; The requested accuracy cannot be obtained (see Method).; The function value is set equal to zero. Note 1:; Values of the function f(x) at the interval end-points A and B are not; required. The subprogram may therefore be used when these values are; undefined. double Integral(); Returns Integral of function on an infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. double IntegralUp(double a); Returns Integral of function on an upper semi-infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I.; - A: lower end-point of integration interval. The integral is mapped onto [0,1] using a transformation th",MatchSource.WIKI,root/html532/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html:385,Deployability,integrat,integration,385,". ROOT::Math::GaussIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::GaussIntegrator. class ROOT::Math::GaussIntegrator: public ROOT::Math::VirtualIntegratorOneDim. User class for performing function integration. It will use the Gauss Method for function integration in a given interval.; This class is implemented from TF1::Integral(). @ingroup Integration. Function Members (Methods); public:. virtual~GaussIntegrator(); voidAbsValue(bool flag); virtual doubleError() const; ROOT::Math::GaussIntegratorGaussIntegrator(double relTol = 1.E-12); ROOT::Math::GaussIntegratorGaussIntegrator(const ROOT::Math::GaussIntegrator&); virtual doubleIntegral(); virtual doubleIntegral(const vector<double>& pts); virtual doubleIntegral(double a, double b); virtual doubleIntegralCauchy(double a, double b, double c); virtual doubleIntegralLow(double b); virtual doubleIntegralUp(double a); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double); virtual intStatus() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. private:. virtual doubleDoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Data Members; protected:. doublefEpsilonRelative error.; const ROOT::Math::IGenFunction*fFunctionPointer to function used.; doublefLastErrorError from the last stimation.; doublefLastResultResult from the last stimation.; boolfUsedOnceBool val",MatchSource.WIKI,root/html532/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html:440,Deployability,integrat,integration,440,". ROOT::Math::GaussIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::GaussIntegrator. class ROOT::Math::GaussIntegrator: public ROOT::Math::VirtualIntegratorOneDim. User class for performing function integration. It will use the Gauss Method for function integration in a given interval.; This class is implemented from TF1::Integral(). @ingroup Integration. Function Members (Methods); public:. virtual~GaussIntegrator(); voidAbsValue(bool flag); virtual doubleError() const; ROOT::Math::GaussIntegratorGaussIntegrator(double relTol = 1.E-12); ROOT::Math::GaussIntegratorGaussIntegrator(const ROOT::Math::GaussIntegrator&); virtual doubleIntegral(); virtual doubleIntegral(const vector<double>& pts); virtual doubleIntegral(double a, double b); virtual doubleIntegralCauchy(double a, double b, double c); virtual doubleIntegralLow(double b); virtual doubleIntegralUp(double a); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double); virtual intStatus() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. private:. virtual doubleDoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Data Members; protected:. doublefEpsilonRelative error.; const ROOT::Math::IGenFunction*fFunctionPointer to function used.; doublefLastErrorError from the last stimation.; doublefLastResultResult from the last stimation.; boolfUsedOnceBool val",MatchSource.WIKI,root/html532/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html:531,Deployability,Integrat,Integration,531,". ROOT::Math::GaussIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::GaussIntegrator. class ROOT::Math::GaussIntegrator: public ROOT::Math::VirtualIntegratorOneDim. User class for performing function integration. It will use the Gauss Method for function integration in a given interval.; This class is implemented from TF1::Integral(). @ingroup Integration. Function Members (Methods); public:. virtual~GaussIntegrator(); voidAbsValue(bool flag); virtual doubleError() const; ROOT::Math::GaussIntegratorGaussIntegrator(double relTol = 1.E-12); ROOT::Math::GaussIntegratorGaussIntegrator(const ROOT::Math::GaussIntegrator&); virtual doubleIntegral(); virtual doubleIntegral(const vector<double>& pts); virtual doubleIntegral(double a, double b); virtual doubleIntegralCauchy(double a, double b, double c); virtual doubleIntegralLow(double b); virtual doubleIntegralUp(double a); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double); virtual intStatus() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. private:. virtual doubleDoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Data Members; protected:. doublefEpsilonRelative error.; const ROOT::Math::IGenFunction*fFunctionPointer to function used.; doublefLastErrorError from the last stimation.; doublefLastResultResult from the last stimation.; boolfUsedOnceBool val",MatchSource.WIKI,root/html532/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html:1269,Deployability,Integrat,IntegratorOneDimOptionsOptions,1269,"mbers; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::GaussIntegrator. class ROOT::Math::GaussIntegrator: public ROOT::Math::VirtualIntegratorOneDim. User class for performing function integration. It will use the Gauss Method for function integration in a given interval.; This class is implemented from TF1::Integral(). @ingroup Integration. Function Members (Methods); public:. virtual~GaussIntegrator(); voidAbsValue(bool flag); virtual doubleError() const; ROOT::Math::GaussIntegratorGaussIntegrator(double relTol = 1.E-12); ROOT::Math::GaussIntegratorGaussIntegrator(const ROOT::Math::GaussIntegrator&); virtual doubleIntegral(); virtual doubleIntegral(const vector<double>& pts); virtual doubleIntegral(double a, double b); virtual doubleIntegralCauchy(double a, double b, double c); virtual doubleIntegralLow(double b); virtual doubleIntegralUp(double a); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double); virtual intStatus() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. private:. virtual doubleDoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Data Members; protected:. doublefEpsilonRelative error.; const ROOT::Math::IGenFunction*fFunctionPointer to function used.; doublefLastErrorError from the last stimation.; doublefLastResultResult from the last stimation.; boolfUsedOnceBool value to check if the function was at least called once.; static boolfgAbsValueAbsValue used for the calculation of the integral. Class Charts. Inheritance; Inherited Members; Includes; Libraries",MatchSource.WIKI,root/html532/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html:1475,Deployability,Integrat,IntegratorOneDimOptions,1475,"mbers; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::GaussIntegrator. class ROOT::Math::GaussIntegrator: public ROOT::Math::VirtualIntegratorOneDim. User class for performing function integration. It will use the Gauss Method for function integration in a given interval.; This class is implemented from TF1::Integral(). @ingroup Integration. Function Members (Methods); public:. virtual~GaussIntegrator(); voidAbsValue(bool flag); virtual doubleError() const; ROOT::Math::GaussIntegratorGaussIntegrator(double relTol = 1.E-12); ROOT::Math::GaussIntegratorGaussIntegrator(const ROOT::Math::GaussIntegrator&); virtual doubleIntegral(); virtual doubleIntegral(const vector<double>& pts); virtual doubleIntegral(double a, double b); virtual doubleIntegralCauchy(double a, double b, double c); virtual doubleIntegralLow(double b); virtual doubleIntegralUp(double a); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double); virtual intStatus() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. private:. virtual doubleDoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Data Members; protected:. doublefEpsilonRelative error.; const ROOT::Math::IGenFunction*fFunctionPointer to function used.; doublefLastErrorError from the last stimation.; doublefLastResultResult from the last stimation.; boolfUsedOnceBool value to check if the function was at least called once.; static boolfgAbsValueAbsValue used for the calculation of the integral. Class Charts. Inheritance; Inherited Members; Includes; Libraries",MatchSource.WIKI,root/html532/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html:1590,Deployability,Integrat,IntegrationOneDim,1590,"mbers; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::GaussIntegrator. class ROOT::Math::GaussIntegrator: public ROOT::Math::VirtualIntegratorOneDim. User class for performing function integration. It will use the Gauss Method for function integration in a given interval.; This class is implemented from TF1::Integral(). @ingroup Integration. Function Members (Methods); public:. virtual~GaussIntegrator(); voidAbsValue(bool flag); virtual doubleError() const; ROOT::Math::GaussIntegratorGaussIntegrator(double relTol = 1.E-12); ROOT::Math::GaussIntegratorGaussIntegrator(const ROOT::Math::GaussIntegrator&); virtual doubleIntegral(); virtual doubleIntegral(const vector<double>& pts); virtual doubleIntegral(double a, double b); virtual doubleIntegralCauchy(double a, double b, double c); virtual doubleIntegralLow(double b); virtual doubleIntegralUp(double a); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double); virtual intStatus() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. private:. virtual doubleDoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Data Members; protected:. doublefEpsilonRelative error.; const ROOT::Math::IGenFunction*fFunctionPointer to function used.; doublefLastErrorError from the last stimation.; doublefLastResultResult from the last stimation.; boolfUsedOnceBool value to check if the function was at least called once.; static boolfgAbsValueAbsValue used for the calculation of the integral. Class Charts. Inheritance; Inherited Members; Includes; Libraries",MatchSource.WIKI,root/html532/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html:2987,Deployability,integrat,integration,2987," boolfUsedOnceBool value to check if the function was at least called once.; static boolfgAbsValueAbsValue used for the calculation of the integral. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~GaussIntegrator(); Destructor . GaussIntegrator(double relTol = 1.E-12); Default Constructor. . void AbsValue(bool flag); Static function: set the fgAbsValue flag.; By default TF1::Integral uses the original function value to compute the integral; However, TF1::Moment, CentralMoment require to compute the integral; using the absolute value of the function. void SetRelTolerance(double ); Implementing VirtualIntegrator Interface; Set the desired relative Error. . void SetAbsTolerance(double ); This method is not implemented. . double Result() const; Returns the result of the last Integral calculation. . double Error() const; Return the estimate of the absolute Error of the last Integral calculation. . int Status() const; return the status of the last integration - 0 in case of success . double Integral(double a, double b); Implementing VirtualIntegratorOneDim Interface. Returns Integral of function between a and b.; Based on original CERNLIB routine DGAUSS by Sigfried Kolbig; converted to C++ by Rene Brun. This function computes, to an attempted specified accuracy, the value; of the integral. Method:; For any interval [a,b] we define g8(a,b) and g16(a,b) to be the 8-point; and 16-point Gaussian quadrature approximations to. and define. Then,. where, starting with x0 = A and finishing with xk = B,; the subdivision points xi(i=1,2,...) are given by. is equal to the first member of the; sequence 1,1/2,1/4,... for which r(xi-1, xi) < EPS.; If, at any stage in the process of subdivision, the ratio. is so small that 1+0.005q is indistinguishable from 1 to; machine accuracy, an error exit occurs with the function value; set equal to zero. Accuracy:; Unless there is severe cancellation of positive and negative values of; f(x) over t",MatchSource.WIKI,root/html532/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html:5475,Deployability,integrat,integration,5475,"ccuracy will usually be much higher than; this. Error handling:; The requested accuracy cannot be obtained (see Method).; The function value is set equal to zero. Note 1:; Values of the function f(x) at the interval end-points A and B are not; required. The subprogram may therefore be used when these values are; undefined. double Integral(); Returns Integral of function on an infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. double IntegralUp(double a); Returns Integral of function on an upper semi-infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I.; - A: lower end-point of integration interval. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. double IntegralLow(double b); Returns Integral of function on a lower semi-infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I.; - B: upper end-point of integration interval. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. void SetFunction(const ROOT::Math::IGenFunction& ); Set integration function (flag control if function must be copied inside).; \@param f Function to be used in the calculations. double Integral(const vector<double>& pts); This method is not implemented. . double IntegralCauchy(double a, double b, double c); This method is not implemented. . void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options",MatchSource.WIKI,root/html532/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html:5915,Deployability,integrat,integration,5915,"pecified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. double IntegralUp(double a); Returns Integral of function on an upper semi-infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I.; - A: lower end-point of integration interval. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. double IntegralLow(double b); Returns Integral of function on a lower semi-infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I.; - B: upper end-point of integration interval. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. void SetFunction(const ROOT::Math::IGenFunction& ); Set integration function (flag control if function must be copied inside).; \@param f Function to be used in the calculations. double Integral(const vector<double>& pts); This method is not implemented. . double IntegralCauchy(double a, double b, double c); This method is not implemented. . void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. double DoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Integration surrugate method. Return integral of passed function in interval [a,b]; Derived class (like GaussLegendreIntegrator) can re-implement this method to modify to use; an improved algorithm.  Last changed: root/mathcore:$Id: GaussIntegrator.h 36764 2010-11-19 10:02:00Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically gene",MatchSource.WIKI,root/html532/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html:6105,Deployability,integrat,integration,6105,"value; of the integral I. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. double IntegralUp(double a); Returns Integral of function on an upper semi-infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I.; - A: lower end-point of integration interval. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. double IntegralLow(double b); Returns Integral of function on a lower semi-infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I.; - B: upper end-point of integration interval. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. void SetFunction(const ROOT::Math::IGenFunction& ); Set integration function (flag control if function must be copied inside).; \@param f Function to be used in the calculations. double Integral(const vector<double>& pts); This method is not implemented. . double IntegralCauchy(double a, double b, double c); This method is not implemented. . void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. double DoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Integration surrugate method. Return integral of passed function in interval [a,b]; Derived class (like GaussLegendreIntegrator) can re-implement this method to modify to use; an improved algorithm.  Last changed: root/mathcore:$Id: GaussIntegrator.h 36764 2010-11-19 10:02:00Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html:6427,Deployability,Integrat,IntegratorOneDimOptions,6427,"value; of the integral I. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. double IntegralUp(double a); Returns Integral of function on an upper semi-infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I.; - A: lower end-point of integration interval. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. double IntegralLow(double b); Returns Integral of function on a lower semi-infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I.; - B: upper end-point of integration interval. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. void SetFunction(const ROOT::Math::IGenFunction& ); Set integration function (flag control if function must be copied inside).; \@param f Function to be used in the calculations. double Integral(const vector<double>& pts); This method is not implemented. . double IntegralCauchy(double a, double b, double c); This method is not implemented. . void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. double DoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Integration surrugate method. Return integral of passed function in interval [a,b]; Derived class (like GaussLegendreIntegrator) can re-implement this method to modify to use; an improved algorithm.  Last changed: root/mathcore:$Id: GaussIntegrator.h 36764 2010-11-19 10:02:00Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html:6552,Deployability,Integrat,Integration,6552,"value; of the integral I. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. double IntegralUp(double a); Returns Integral of function on an upper semi-infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I.; - A: lower end-point of integration interval. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. double IntegralLow(double b); Returns Integral of function on a lower semi-infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I.; - B: upper end-point of integration interval. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. void SetFunction(const ROOT::Math::IGenFunction& ); Set integration function (flag control if function must be copied inside).; \@param f Function to be used in the calculations. double Integral(const vector<double>& pts); This method is not implemented. . double IntegralCauchy(double a, double b, double c); This method is not implemented. . void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. double DoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Integration surrugate method. Return integral of passed function in interval [a,b]; Derived class (like GaussLegendreIntegrator) can re-implement this method to modify to use; an improved algorithm.  Last changed: root/mathcore:$Id: GaussIntegrator.h 36764 2010-11-19 10:02:00Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html:385,Integrability,integrat,integration,385,". ROOT::Math::GaussIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::GaussIntegrator. class ROOT::Math::GaussIntegrator: public ROOT::Math::VirtualIntegratorOneDim. User class for performing function integration. It will use the Gauss Method for function integration in a given interval.; This class is implemented from TF1::Integral(). @ingroup Integration. Function Members (Methods); public:. virtual~GaussIntegrator(); voidAbsValue(bool flag); virtual doubleError() const; ROOT::Math::GaussIntegratorGaussIntegrator(double relTol = 1.E-12); ROOT::Math::GaussIntegratorGaussIntegrator(const ROOT::Math::GaussIntegrator&); virtual doubleIntegral(); virtual doubleIntegral(const vector<double>& pts); virtual doubleIntegral(double a, double b); virtual doubleIntegralCauchy(double a, double b, double c); virtual doubleIntegralLow(double b); virtual doubleIntegralUp(double a); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double); virtual intStatus() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. private:. virtual doubleDoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Data Members; protected:. doublefEpsilonRelative error.; const ROOT::Math::IGenFunction*fFunctionPointer to function used.; doublefLastErrorError from the last stimation.; doublefLastResultResult from the last stimation.; boolfUsedOnceBool val",MatchSource.WIKI,root/html532/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html:440,Integrability,integrat,integration,440,". ROOT::Math::GaussIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::GaussIntegrator. class ROOT::Math::GaussIntegrator: public ROOT::Math::VirtualIntegratorOneDim. User class for performing function integration. It will use the Gauss Method for function integration in a given interval.; This class is implemented from TF1::Integral(). @ingroup Integration. Function Members (Methods); public:. virtual~GaussIntegrator(); voidAbsValue(bool flag); virtual doubleError() const; ROOT::Math::GaussIntegratorGaussIntegrator(double relTol = 1.E-12); ROOT::Math::GaussIntegratorGaussIntegrator(const ROOT::Math::GaussIntegrator&); virtual doubleIntegral(); virtual doubleIntegral(const vector<double>& pts); virtual doubleIntegral(double a, double b); virtual doubleIntegralCauchy(double a, double b, double c); virtual doubleIntegralLow(double b); virtual doubleIntegralUp(double a); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double); virtual intStatus() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. private:. virtual doubleDoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Data Members; protected:. doublefEpsilonRelative error.; const ROOT::Math::IGenFunction*fFunctionPointer to function used.; doublefLastErrorError from the last stimation.; doublefLastResultResult from the last stimation.; boolfUsedOnceBool val",MatchSource.WIKI,root/html532/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html:531,Integrability,Integrat,Integration,531,". ROOT::Math::GaussIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::GaussIntegrator. class ROOT::Math::GaussIntegrator: public ROOT::Math::VirtualIntegratorOneDim. User class for performing function integration. It will use the Gauss Method for function integration in a given interval.; This class is implemented from TF1::Integral(). @ingroup Integration. Function Members (Methods); public:. virtual~GaussIntegrator(); voidAbsValue(bool flag); virtual doubleError() const; ROOT::Math::GaussIntegratorGaussIntegrator(double relTol = 1.E-12); ROOT::Math::GaussIntegratorGaussIntegrator(const ROOT::Math::GaussIntegrator&); virtual doubleIntegral(); virtual doubleIntegral(const vector<double>& pts); virtual doubleIntegral(double a, double b); virtual doubleIntegralCauchy(double a, double b, double c); virtual doubleIntegralLow(double b); virtual doubleIntegralUp(double a); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double); virtual intStatus() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. private:. virtual doubleDoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Data Members; protected:. doublefEpsilonRelative error.; const ROOT::Math::IGenFunction*fFunctionPointer to function used.; doublefLastErrorError from the last stimation.; doublefLastResultResult from the last stimation.; boolfUsedOnceBool val",MatchSource.WIKI,root/html532/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html:1269,Integrability,Integrat,IntegratorOneDimOptionsOptions,1269,"mbers; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::GaussIntegrator. class ROOT::Math::GaussIntegrator: public ROOT::Math::VirtualIntegratorOneDim. User class for performing function integration. It will use the Gauss Method for function integration in a given interval.; This class is implemented from TF1::Integral(). @ingroup Integration. Function Members (Methods); public:. virtual~GaussIntegrator(); voidAbsValue(bool flag); virtual doubleError() const; ROOT::Math::GaussIntegratorGaussIntegrator(double relTol = 1.E-12); ROOT::Math::GaussIntegratorGaussIntegrator(const ROOT::Math::GaussIntegrator&); virtual doubleIntegral(); virtual doubleIntegral(const vector<double>& pts); virtual doubleIntegral(double a, double b); virtual doubleIntegralCauchy(double a, double b, double c); virtual doubleIntegralLow(double b); virtual doubleIntegralUp(double a); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double); virtual intStatus() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. private:. virtual doubleDoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Data Members; protected:. doublefEpsilonRelative error.; const ROOT::Math::IGenFunction*fFunctionPointer to function used.; doublefLastErrorError from the last stimation.; doublefLastResultResult from the last stimation.; boolfUsedOnceBool value to check if the function was at least called once.; static boolfgAbsValueAbsValue used for the calculation of the integral. Class Charts. Inheritance; Inherited Members; Includes; Libraries",MatchSource.WIKI,root/html532/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html:1475,Integrability,Integrat,IntegratorOneDimOptions,1475,"mbers; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::GaussIntegrator. class ROOT::Math::GaussIntegrator: public ROOT::Math::VirtualIntegratorOneDim. User class for performing function integration. It will use the Gauss Method for function integration in a given interval.; This class is implemented from TF1::Integral(). @ingroup Integration. Function Members (Methods); public:. virtual~GaussIntegrator(); voidAbsValue(bool flag); virtual doubleError() const; ROOT::Math::GaussIntegratorGaussIntegrator(double relTol = 1.E-12); ROOT::Math::GaussIntegratorGaussIntegrator(const ROOT::Math::GaussIntegrator&); virtual doubleIntegral(); virtual doubleIntegral(const vector<double>& pts); virtual doubleIntegral(double a, double b); virtual doubleIntegralCauchy(double a, double b, double c); virtual doubleIntegralLow(double b); virtual doubleIntegralUp(double a); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double); virtual intStatus() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. private:. virtual doubleDoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Data Members; protected:. doublefEpsilonRelative error.; const ROOT::Math::IGenFunction*fFunctionPointer to function used.; doublefLastErrorError from the last stimation.; doublefLastResultResult from the last stimation.; boolfUsedOnceBool value to check if the function was at least called once.; static boolfgAbsValueAbsValue used for the calculation of the integral. Class Charts. Inheritance; Inherited Members; Includes; Libraries",MatchSource.WIKI,root/html532/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html:1590,Integrability,Integrat,IntegrationOneDim,1590,"mbers; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::GaussIntegrator. class ROOT::Math::GaussIntegrator: public ROOT::Math::VirtualIntegratorOneDim. User class for performing function integration. It will use the Gauss Method for function integration in a given interval.; This class is implemented from TF1::Integral(). @ingroup Integration. Function Members (Methods); public:. virtual~GaussIntegrator(); voidAbsValue(bool flag); virtual doubleError() const; ROOT::Math::GaussIntegratorGaussIntegrator(double relTol = 1.E-12); ROOT::Math::GaussIntegratorGaussIntegrator(const ROOT::Math::GaussIntegrator&); virtual doubleIntegral(); virtual doubleIntegral(const vector<double>& pts); virtual doubleIntegral(double a, double b); virtual doubleIntegralCauchy(double a, double b, double c); virtual doubleIntegralLow(double b); virtual doubleIntegralUp(double a); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double); virtual intStatus() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. private:. virtual doubleDoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Data Members; protected:. doublefEpsilonRelative error.; const ROOT::Math::IGenFunction*fFunctionPointer to function used.; doublefLastErrorError from the last stimation.; doublefLastResultResult from the last stimation.; boolfUsedOnceBool value to check if the function was at least called once.; static boolfgAbsValueAbsValue used for the calculation of the integral. Class Charts. Inheritance; Inherited Members; Includes; Libraries",MatchSource.WIKI,root/html532/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html:2649,Integrability,Interface,Interface,2649,"atorOneDim::Type() const. private:. virtual doubleDoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Data Members; protected:. doublefEpsilonRelative error.; const ROOT::Math::IGenFunction*fFunctionPointer to function used.; doublefLastErrorError from the last stimation.; doublefLastResultResult from the last stimation.; boolfUsedOnceBool value to check if the function was at least called once.; static boolfgAbsValueAbsValue used for the calculation of the integral. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~GaussIntegrator(); Destructor . GaussIntegrator(double relTol = 1.E-12); Default Constructor. . void AbsValue(bool flag); Static function: set the fgAbsValue flag.; By default TF1::Integral uses the original function value to compute the integral; However, TF1::Moment, CentralMoment require to compute the integral; using the absolute value of the function. void SetRelTolerance(double ); Implementing VirtualIntegrator Interface; Set the desired relative Error. . void SetAbsTolerance(double ); This method is not implemented. . double Result() const; Returns the result of the last Integral calculation. . double Error() const; Return the estimate of the absolute Error of the last Integral calculation. . int Status() const; return the status of the last integration - 0 in case of success . double Integral(double a, double b); Implementing VirtualIntegratorOneDim Interface. Returns Integral of function between a and b.; Based on original CERNLIB routine DGAUSS by Sigfried Kolbig; converted to C++ by Rene Brun. This function computes, to an attempted specified accuracy, the value; of the integral. Method:; For any interval [a,b] we define g8(a,b) and g16(a,b) to be the 8-point; and 16-point Gaussian quadrature approximations to. and define. Then,. where, starting with x0 = A and finishing with xk = B,; the subdivision points xi(i=1,2,...) are given by. is equal to the first member of the; sequen",MatchSource.WIKI,root/html532/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html:2987,Integrability,integrat,integration,2987," boolfUsedOnceBool value to check if the function was at least called once.; static boolfgAbsValueAbsValue used for the calculation of the integral. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~GaussIntegrator(); Destructor . GaussIntegrator(double relTol = 1.E-12); Default Constructor. . void AbsValue(bool flag); Static function: set the fgAbsValue flag.; By default TF1::Integral uses the original function value to compute the integral; However, TF1::Moment, CentralMoment require to compute the integral; using the absolute value of the function. void SetRelTolerance(double ); Implementing VirtualIntegrator Interface; Set the desired relative Error. . void SetAbsTolerance(double ); This method is not implemented. . double Result() const; Returns the result of the last Integral calculation. . double Error() const; Return the estimate of the absolute Error of the last Integral calculation. . int Status() const; return the status of the last integration - 0 in case of success . double Integral(double a, double b); Implementing VirtualIntegratorOneDim Interface. Returns Integral of function between a and b.; Based on original CERNLIB routine DGAUSS by Sigfried Kolbig; converted to C++ by Rene Brun. This function computes, to an attempted specified accuracy, the value; of the integral. Method:; For any interval [a,b] we define g8(a,b) and g16(a,b) to be the 8-point; and 16-point Gaussian quadrature approximations to. and define. Then,. where, starting with x0 = A and finishing with xk = B,; the subdivision points xi(i=1,2,...) are given by. is equal to the first member of the; sequence 1,1/2,1/4,... for which r(xi-1, xi) < EPS.; If, at any stage in the process of subdivision, the ratio. is so small that 1+0.005q is indistinguishable from 1 to; machine accuracy, an error exit occurs with the function value; set equal to zero. Accuracy:; Unless there is severe cancellation of positive and negative values of; f(x) over t",MatchSource.WIKI,root/html532/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html:3098,Integrability,Interface,Interface,3098,"olfgAbsValueAbsValue used for the calculation of the integral. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~GaussIntegrator(); Destructor . GaussIntegrator(double relTol = 1.E-12); Default Constructor. . void AbsValue(bool flag); Static function: set the fgAbsValue flag.; By default TF1::Integral uses the original function value to compute the integral; However, TF1::Moment, CentralMoment require to compute the integral; using the absolute value of the function. void SetRelTolerance(double ); Implementing VirtualIntegrator Interface; Set the desired relative Error. . void SetAbsTolerance(double ); This method is not implemented. . double Result() const; Returns the result of the last Integral calculation. . double Error() const; Return the estimate of the absolute Error of the last Integral calculation. . int Status() const; return the status of the last integration - 0 in case of success . double Integral(double a, double b); Implementing VirtualIntegratorOneDim Interface. Returns Integral of function between a and b.; Based on original CERNLIB routine DGAUSS by Sigfried Kolbig; converted to C++ by Rene Brun. This function computes, to an attempted specified accuracy, the value; of the integral. Method:; For any interval [a,b] we define g8(a,b) and g16(a,b) to be the 8-point; and 16-point Gaussian quadrature approximations to. and define. Then,. where, starting with x0 = A and finishing with xk = B,; the subdivision points xi(i=1,2,...) are given by. is equal to the first member of the; sequence 1,1/2,1/4,... for which r(xi-1, xi) < EPS.; If, at any stage in the process of subdivision, the ratio. is so small that 1+0.005q is indistinguishable from 1 to; machine accuracy, an error exit occurs with the function value; set equal to zero. Accuracy:; Unless there is severe cancellation of positive and negative values of; f(x) over the interval [A,B], the relative error may be considered as; specifying a bound on the ",MatchSource.WIKI,root/html532/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html:3182,Integrability,rout,routine,3182,"ion documentation; virtual ~GaussIntegrator(); Destructor . GaussIntegrator(double relTol = 1.E-12); Default Constructor. . void AbsValue(bool flag); Static function: set the fgAbsValue flag.; By default TF1::Integral uses the original function value to compute the integral; However, TF1::Moment, CentralMoment require to compute the integral; using the absolute value of the function. void SetRelTolerance(double ); Implementing VirtualIntegrator Interface; Set the desired relative Error. . void SetAbsTolerance(double ); This method is not implemented. . double Result() const; Returns the result of the last Integral calculation. . double Error() const; Return the estimate of the absolute Error of the last Integral calculation. . int Status() const; return the status of the last integration - 0 in case of success . double Integral(double a, double b); Implementing VirtualIntegratorOneDim Interface. Returns Integral of function between a and b.; Based on original CERNLIB routine DGAUSS by Sigfried Kolbig; converted to C++ by Rene Brun. This function computes, to an attempted specified accuracy, the value; of the integral. Method:; For any interval [a,b] we define g8(a,b) and g16(a,b) to be the 8-point; and 16-point Gaussian quadrature approximations to. and define. Then,. where, starting with x0 = A and finishing with xk = B,; the subdivision points xi(i=1,2,...) are given by. is equal to the first member of the; sequence 1,1/2,1/4,... for which r(xi-1, xi) < EPS.; If, at any stage in the process of subdivision, the ratio. is so small that 1+0.005q is indistinguishable from 1 to; machine accuracy, an error exit occurs with the function value; set equal to zero. Accuracy:; Unless there is severe cancellation of positive and negative values of; f(x) over the interval [A,B], the relative error may be considered as; specifying a bound on the <I>relative</I> error of I in the case; |I|&gt;1, and a bound on the absolute error in the case |I|&lt;1. More; precisely, if k is the ",MatchSource.WIKI,root/html532/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html:4342,Integrability,rout,routine,4342," any interval [a,b] we define g8(a,b) and g16(a,b) to be the 8-point; and 16-point Gaussian quadrature approximations to. and define. Then,. where, starting with x0 = A and finishing with xk = B,; the subdivision points xi(i=1,2,...) are given by. is equal to the first member of the; sequence 1,1/2,1/4,... for which r(xi-1, xi) < EPS.; If, at any stage in the process of subdivision, the ratio. is so small that 1+0.005q is indistinguishable from 1 to; machine accuracy, an error exit occurs with the function value; set equal to zero. Accuracy:; Unless there is severe cancellation of positive and negative values of; f(x) over the interval [A,B], the relative error may be considered as; specifying a bound on the <I>relative</I> error of I in the case; |I|&gt;1, and a bound on the absolute error in the case |I|&lt;1. More; precisely, if k is the number of sub-intervals contributing to the; approximation (see Method), and if. then the relation. will nearly always be true, provided the routine terminates without; printing an error message. For functions f having no singularities in; the closed interval [A,B] the accuracy will usually be much higher than; this. Error handling:; The requested accuracy cannot be obtained (see Method).; The function value is set equal to zero. Note 1:; Values of the function f(x) at the interval end-points A and B are not; required. The subprogram may therefore be used when these values are; undefined. double Integral(); Returns Integral of function on an infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. double IntegralUp(double a); Returns Integral of function on an upper semi-infinite interval.; This function computes, to an attempted specified accuracy, the value of the integra",MatchSource.WIKI,root/html532/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html:4388,Integrability,message,message,4388," any interval [a,b] we define g8(a,b) and g16(a,b) to be the 8-point; and 16-point Gaussian quadrature approximations to. and define. Then,. where, starting with x0 = A and finishing with xk = B,; the subdivision points xi(i=1,2,...) are given by. is equal to the first member of the; sequence 1,1/2,1/4,... for which r(xi-1, xi) < EPS.; If, at any stage in the process of subdivision, the ratio. is so small that 1+0.005q is indistinguishable from 1 to; machine accuracy, an error exit occurs with the function value; set equal to zero. Accuracy:; Unless there is severe cancellation of positive and negative values of; f(x) over the interval [A,B], the relative error may be considered as; specifying a bound on the <I>relative</I> error of I in the case; |I|&gt;1, and a bound on the absolute error in the case |I|&lt;1. More; precisely, if k is the number of sub-intervals contributing to the; approximation (see Method), and if. then the relation. will nearly always be true, provided the routine terminates without; printing an error message. For functions f having no singularities in; the closed interval [A,B] the accuracy will usually be much higher than; this. Error handling:; The requested accuracy cannot be obtained (see Method).; The function value is set equal to zero. Note 1:; Values of the function f(x) at the interval end-points A and B are not; required. The subprogram may therefore be used when these values are; undefined. double Integral(); Returns Integral of function on an infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. double IntegralUp(double a); Returns Integral of function on an upper semi-infinite interval.; This function computes, to an attempted specified accuracy, the value of the integra",MatchSource.WIKI,root/html532/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html:5475,Integrability,integrat,integration,5475,"ccuracy will usually be much higher than; this. Error handling:; The requested accuracy cannot be obtained (see Method).; The function value is set equal to zero. Note 1:; Values of the function f(x) at the interval end-points A and B are not; required. The subprogram may therefore be used when these values are; undefined. double Integral(); Returns Integral of function on an infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. double IntegralUp(double a); Returns Integral of function on an upper semi-infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I.; - A: lower end-point of integration interval. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. double IntegralLow(double b); Returns Integral of function on a lower semi-infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I.; - B: upper end-point of integration interval. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. void SetFunction(const ROOT::Math::IGenFunction& ); Set integration function (flag control if function must be copied inside).; \@param f Function to be used in the calculations. double Integral(const vector<double>& pts); This method is not implemented. . double IntegralCauchy(double a, double b, double c); This method is not implemented. . void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options",MatchSource.WIKI,root/html532/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html:5915,Integrability,integrat,integration,5915,"pecified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. double IntegralUp(double a); Returns Integral of function on an upper semi-infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I.; - A: lower end-point of integration interval. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. double IntegralLow(double b); Returns Integral of function on a lower semi-infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I.; - B: upper end-point of integration interval. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. void SetFunction(const ROOT::Math::IGenFunction& ); Set integration function (flag control if function must be copied inside).; \@param f Function to be used in the calculations. double Integral(const vector<double>& pts); This method is not implemented. . double IntegralCauchy(double a, double b, double c); This method is not implemented. . void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. double DoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Integration surrugate method. Return integral of passed function in interval [a,b]; Derived class (like GaussLegendreIntegrator) can re-implement this method to modify to use; an improved algorithm.  Last changed: root/mathcore:$Id: GaussIntegrator.h 36764 2010-11-19 10:02:00Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically gene",MatchSource.WIKI,root/html532/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html:6105,Integrability,integrat,integration,6105,"value; of the integral I. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. double IntegralUp(double a); Returns Integral of function on an upper semi-infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I.; - A: lower end-point of integration interval. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. double IntegralLow(double b); Returns Integral of function on a lower semi-infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I.; - B: upper end-point of integration interval. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. void SetFunction(const ROOT::Math::IGenFunction& ); Set integration function (flag control if function must be copied inside).; \@param f Function to be used in the calculations. double Integral(const vector<double>& pts); This method is not implemented. . double IntegralCauchy(double a, double b, double c); This method is not implemented. . void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. double DoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Integration surrugate method. Return integral of passed function in interval [a,b]; Derived class (like GaussLegendreIntegrator) can re-implement this method to modify to use; an improved algorithm.  Last changed: root/mathcore:$Id: GaussIntegrator.h 36764 2010-11-19 10:02:00Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html:6427,Integrability,Integrat,IntegratorOneDimOptions,6427,"value; of the integral I. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. double IntegralUp(double a); Returns Integral of function on an upper semi-infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I.; - A: lower end-point of integration interval. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. double IntegralLow(double b); Returns Integral of function on a lower semi-infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I.; - B: upper end-point of integration interval. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. void SetFunction(const ROOT::Math::IGenFunction& ); Set integration function (flag control if function must be copied inside).; \@param f Function to be used in the calculations. double Integral(const vector<double>& pts); This method is not implemented. . double IntegralCauchy(double a, double b, double c); This method is not implemented. . void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. double DoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Integration surrugate method. Return integral of passed function in interval [a,b]; Derived class (like GaussLegendreIntegrator) can re-implement this method to modify to use; an improved algorithm.  Last changed: root/mathcore:$Id: GaussIntegrator.h 36764 2010-11-19 10:02:00Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html:6552,Integrability,Integrat,Integration,6552,"value; of the integral I. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. double IntegralUp(double a); Returns Integral of function on an upper semi-infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I.; - A: lower end-point of integration interval. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. double IntegralLow(double b); Returns Integral of function on a lower semi-infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I.; - B: upper end-point of integration interval. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. void SetFunction(const ROOT::Math::IGenFunction& ); Set integration function (flag control if function must be copied inside).; \@param f Function to be used in the calculations. double Integral(const vector<double>& pts); This method is not implemented. . double IntegralCauchy(double a, double b, double c); This method is not implemented. . void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. double DoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Integration surrugate method. Return integral of passed function in interval [a,b]; Derived class (like GaussLegendreIntegrator) can re-implement this method to modify to use; an improved algorithm.  Last changed: root/mathcore:$Id: GaussIntegrator.h 36764 2010-11-19 10:02:00Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html:2142,Modifiability,Inherit,Inheritance,2142,"::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double); virtual intStatus() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. private:. virtual doubleDoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Data Members; protected:. doublefEpsilonRelative error.; const ROOT::Math::IGenFunction*fFunctionPointer to function used.; doublefLastErrorError from the last stimation.; doublefLastResultResult from the last stimation.; boolfUsedOnceBool value to check if the function was at least called once.; static boolfgAbsValueAbsValue used for the calculation of the integral. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~GaussIntegrator(); Destructor . GaussIntegrator(double relTol = 1.E-12); Default Constructor. . void AbsValue(bool flag); Static function: set the fgAbsValue flag.; By default TF1::Integral uses the original function value to compute the integral; However, TF1::Moment, CentralMoment require to compute the integral; using the absolute value of the function. void SetRelTolerance(double ); Implementing VirtualIntegrator Interface; Set the desired relative Error. . void SetAbsTolerance(double ); This method is not implemented. . double Result() const; Returns the result of the last Integral calculation. . double Error() const; Return the estimate of the absolute Error of the last Integral calculation. . int Status() const; return the status of the last integration - 0 in case of success . double Integral(double a, double b); Implementing VirtualIntegratorOneDim Interface. Returns Integral of function between a and b.; Based on ori",MatchSource.WIKI,root/html532/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html:2155,Modifiability,Inherit,Inherited,2155,"::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double); virtual intStatus() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. private:. virtual doubleDoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Data Members; protected:. doublefEpsilonRelative error.; const ROOT::Math::IGenFunction*fFunctionPointer to function used.; doublefLastErrorError from the last stimation.; doublefLastResultResult from the last stimation.; boolfUsedOnceBool value to check if the function was at least called once.; static boolfgAbsValueAbsValue used for the calculation of the integral. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~GaussIntegrator(); Destructor . GaussIntegrator(double relTol = 1.E-12); Default Constructor. . void AbsValue(bool flag); Static function: set the fgAbsValue flag.; By default TF1::Integral uses the original function value to compute the integral; However, TF1::Moment, CentralMoment require to compute the integral; using the absolute value of the function. void SetRelTolerance(double ); Implementing VirtualIntegrator Interface; Set the desired relative Error. . void SetAbsTolerance(double ); This method is not implemented. . double Result() const; Returns the result of the last Integral calculation. . double Error() const; Return the estimate of the absolute Error of the last Integral calculation. . int Status() const; return the status of the last integration - 0 in case of success . double Integral(double a, double b); Implementing VirtualIntegratorOneDim Interface. Returns Integral of function between a and b.; Based on ori",MatchSource.WIKI,root/html532/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html:365,Performance,perform,performing,365,". ROOT::Math::GaussIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::GaussIntegrator. class ROOT::Math::GaussIntegrator: public ROOT::Math::VirtualIntegratorOneDim. User class for performing function integration. It will use the Gauss Method for function integration in a given interval.; This class is implemented from TF1::Integral(). @ingroup Integration. Function Members (Methods); public:. virtual~GaussIntegrator(); voidAbsValue(bool flag); virtual doubleError() const; ROOT::Math::GaussIntegratorGaussIntegrator(double relTol = 1.E-12); ROOT::Math::GaussIntegratorGaussIntegrator(const ROOT::Math::GaussIntegrator&); virtual doubleIntegral(); virtual doubleIntegral(const vector<double>& pts); virtual doubleIntegral(double a, double b); virtual doubleIntegralCauchy(double a, double b, double c); virtual doubleIntegralLow(double b); virtual doubleIntegralUp(double a); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetFunction(const ROOT::Math::IGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double); virtual intStatus() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. private:. virtual doubleDoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Data Members; protected:. doublefEpsilonRelative error.; const ROOT::Math::IGenFunction*fFunctionPointer to function used.; doublefLastErrorError from the last stimation.; doublefLastResultResult from the last stimation.; boolfUsedOnceBool val",MatchSource.WIKI,root/html532/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html:738,Availability,Error,Error,738,". ROOT::Math::GaussLegendreIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::GaussLegendreIntegrator. class ROOT::Math::GaussLegendreIntegrator: public ROOT::Math::GaussIntegrator. User class for performing function integration. It will use the Gauss-Legendre Method for function integration in a given interval.; This class is implemented from TF1::Integral(). @ingroup Integration. Function Members (Methods); public:. virtual~GaussLegendreIntegrator(); voidROOT::Math::GaussIntegrator::AbsValue(bool flag); virtual doubleROOT::Math::GaussIntegrator::Error() const; ROOT::Math::GaussIntegratorROOT::Math::GaussIntegrator::GaussIntegrator(double relTol = 1.E-12); ROOT::Math::GaussIntegratorROOT::Math::GaussIntegrator::GaussIntegrator(const ROOT::Math::GaussIntegrator&); ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(const ROOT::Math::GaussLegendreIntegrator&); ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(int num = 10, double eps = 1e-12); intGetNumberPoints() const; voidGetWeightVectors(double* x, double* w) const; virtual doubleROOT::Math::GaussIntegrator::Integral(); virtual doubleROOT::Math::GaussIntegrator::Integral(const vector<double>& pts); virtual doubleROOT::Math::GaussIntegrator::Integral(double a, double b); virtual doubleROOT::Math::GaussIntegrator::IntegralCauchy(double a, double b, double c); virtual doubleROOT::Math::GaussIntegrator::IntegralLow(double b); virtual doubleROOT::Math::GaussIntegrator::IntegralUp(double a); virtual intNEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleROOT::Math::GaussIntegrator::Result() const; virtual voidSetAbsTolerance(double); virtual voidROOT::Math::Gaus",MatchSource.WIKI,root/html532/ROOT__Math__GaussLegendreIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html:2560,Availability,error,error,2560,"ual doubleROOT::Math::GaussIntegrator::IntegralLow(double b); virtual doubleROOT::Math::GaussIntegrator::IntegralUp(double a); virtual intNEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleROOT::Math::GaussIntegrator::Result() const; virtual voidSetAbsTolerance(double); virtual voidROOT::Math::GaussIntegrator::SetFunction(const ROOT::Math::IGenFunction&); voidSetNumberPoints(int num); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double); virtual intROOT::Math::GaussIntegrator::Status() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. private:. voidCalcGaussLegendreSamplingPoints(); virtual doubleDoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Data Members; protected:. doubleROOT::Math::GaussIntegrator::fEpsilonRelative error.; const ROOT::Math::IGenFunction*ROOT::Math::GaussIntegrator::fFunctionPointer to function used.; doubleROOT::Math::GaussIntegrator::fLastErrorError from the last stimation.; doubleROOT::Math::GaussIntegrator::fLastResultResult from the last stimation.; intfNumNumber of points used in the stimation of the integral.; boolROOT::Math::GaussIntegrator::fUsedOnceBool value to check if the function was at least called once.; double*fWWeights of the points used.; double*fXAbscisa of the points used.; static boolROOT::Math::GaussIntegrator::fgAbsValueAbsValue used for the calculation of the integral. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GaussLegendreIntegrator(int num = 10, double eps = 1e-12); Basic contructor of GaussLegendreIntegrator.; \@param num Number of desired points to calculate the integration.; \@param eps Desired relative error. virtual ~GaussLegendreIntegrator(); Default Destructor . void SetNumber",MatchSource.WIKI,root/html532/ROOT__Math__GaussLegendreIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html:3459,Availability,error,error,3459,"st ROOT::Math::IGenFunction* func). Data Members; protected:. doubleROOT::Math::GaussIntegrator::fEpsilonRelative error.; const ROOT::Math::IGenFunction*ROOT::Math::GaussIntegrator::fFunctionPointer to function used.; doubleROOT::Math::GaussIntegrator::fLastErrorError from the last stimation.; doubleROOT::Math::GaussIntegrator::fLastResultResult from the last stimation.; intfNumNumber of points used in the stimation of the integral.; boolROOT::Math::GaussIntegrator::fUsedOnceBool value to check if the function was at least called once.; double*fWWeights of the points used.; double*fXAbscisa of the points used.; static boolROOT::Math::GaussIntegrator::fgAbsValueAbsValue used for the calculation of the integral. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GaussLegendreIntegrator(int num = 10, double eps = 1e-12); Basic contructor of GaussLegendreIntegrator.; \@param num Number of desired points to calculate the integration.; \@param eps Desired relative error. virtual ~GaussLegendreIntegrator(); Default Destructor . void SetNumberPoints(int num); Set the number of points used in the calculation of the; integral . void SetRelTolerance(double ); Set the desired relative Error. . void SetAbsTolerance(double ); This method is not implemented. . void GetWeightVectors(double* x, double* w) const; Returns the arrays x and w containing the abscissa and weight of; the Gauss-Legendre n-point quadrature formula. Gauss-Legendre: W(x)=1 -1<x<1; (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}. int GetNumberPoints() const; { return fNum; }. int NEval() const. return number of function evaluations in calculating the integral; This is equivalent to the number of points. { return fNum; }. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. double DoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Integration surrugate method. Return integral of passed function in interval [a,b]; Reimplement method of Gaus",MatchSource.WIKI,root/html532/ROOT__Math__GaussLegendreIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html:3678,Availability,Error,Error,3678,"tion used.; doubleROOT::Math::GaussIntegrator::fLastErrorError from the last stimation.; doubleROOT::Math::GaussIntegrator::fLastResultResult from the last stimation.; intfNumNumber of points used in the stimation of the integral.; boolROOT::Math::GaussIntegrator::fUsedOnceBool value to check if the function was at least called once.; double*fWWeights of the points used.; double*fXAbscisa of the points used.; static boolROOT::Math::GaussIntegrator::fgAbsValueAbsValue used for the calculation of the integral. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GaussLegendreIntegrator(int num = 10, double eps = 1e-12); Basic contructor of GaussLegendreIntegrator.; \@param num Number of desired points to calculate the integration.; \@param eps Desired relative error. virtual ~GaussLegendreIntegrator(); Default Destructor . void SetNumberPoints(int num); Set the number of points used in the calculation of the; integral . void SetRelTolerance(double ); Set the desired relative Error. . void SetAbsTolerance(double ); This method is not implemented. . void GetWeightVectors(double* x, double* w) const; Returns the arrays x and w containing the abscissa and weight of; the Gauss-Legendre n-point quadrature formula. Gauss-Legendre: W(x)=1 -1<x<1; (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}. int GetNumberPoints() const; { return fNum; }. int NEval() const. return number of function evaluations in calculating the integral; This is equivalent to the number of points. { return fNum; }. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. double DoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Integration surrugate method. Return integral of passed function in interval [a,b]; Reimplement method of GaussIntegrator using CalcGaussLegendreSamplingPoints. void CalcGaussLegendreSamplingPoints(). Type: unsafe but fast interface filling the arrays x and w (static method). Given the number of sampling points thi",MatchSource.WIKI,root/html532/ROOT__Math__GaussLegendreIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html:401,Deployability,integrat,integration,401,". ROOT::Math::GaussLegendreIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::GaussLegendreIntegrator. class ROOT::Math::GaussLegendreIntegrator: public ROOT::Math::GaussIntegrator. User class for performing function integration. It will use the Gauss-Legendre Method for function integration in a given interval.; This class is implemented from TF1::Integral(). @ingroup Integration. Function Members (Methods); public:. virtual~GaussLegendreIntegrator(); voidROOT::Math::GaussIntegrator::AbsValue(bool flag); virtual doubleROOT::Math::GaussIntegrator::Error() const; ROOT::Math::GaussIntegratorROOT::Math::GaussIntegrator::GaussIntegrator(double relTol = 1.E-12); ROOT::Math::GaussIntegratorROOT::Math::GaussIntegrator::GaussIntegrator(const ROOT::Math::GaussIntegrator&); ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(const ROOT::Math::GaussLegendreIntegrator&); ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(int num = 10, double eps = 1e-12); intGetNumberPoints() const; voidGetWeightVectors(double* x, double* w) const; virtual doubleROOT::Math::GaussIntegrator::Integral(); virtual doubleROOT::Math::GaussIntegrator::Integral(const vector<double>& pts); virtual doubleROOT::Math::GaussIntegrator::Integral(double a, double b); virtual doubleROOT::Math::GaussIntegrator::IntegralCauchy(double a, double b, double c); virtual doubleROOT::Math::GaussIntegrator::IntegralLow(double b); virtual doubleROOT::Math::GaussIntegrator::IntegralUp(double a); virtual intNEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleROOT::Math::GaussIntegrator::Result() const; virtual voidSetAbsTolerance(double); virtual voidROOT::Math::Gaus",MatchSource.WIKI,root/html532/ROOT__Math__GaussLegendreIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html:465,Deployability,integrat,integration,465,". ROOT::Math::GaussLegendreIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::GaussLegendreIntegrator. class ROOT::Math::GaussLegendreIntegrator: public ROOT::Math::GaussIntegrator. User class for performing function integration. It will use the Gauss-Legendre Method for function integration in a given interval.; This class is implemented from TF1::Integral(). @ingroup Integration. Function Members (Methods); public:. virtual~GaussLegendreIntegrator(); voidROOT::Math::GaussIntegrator::AbsValue(bool flag); virtual doubleROOT::Math::GaussIntegrator::Error() const; ROOT::Math::GaussIntegratorROOT::Math::GaussIntegrator::GaussIntegrator(double relTol = 1.E-12); ROOT::Math::GaussIntegratorROOT::Math::GaussIntegrator::GaussIntegrator(const ROOT::Math::GaussIntegrator&); ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(const ROOT::Math::GaussLegendreIntegrator&); ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(int num = 10, double eps = 1e-12); intGetNumberPoints() const; voidGetWeightVectors(double* x, double* w) const; virtual doubleROOT::Math::GaussIntegrator::Integral(); virtual doubleROOT::Math::GaussIntegrator::Integral(const vector<double>& pts); virtual doubleROOT::Math::GaussIntegrator::Integral(double a, double b); virtual doubleROOT::Math::GaussIntegrator::IntegralCauchy(double a, double b, double c); virtual doubleROOT::Math::GaussIntegrator::IntegralLow(double b); virtual doubleROOT::Math::GaussIntegrator::IntegralUp(double a); virtual intNEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleROOT::Math::GaussIntegrator::Result() const; virtual voidSetAbsTolerance(double); virtual voidROOT::Math::Gaus",MatchSource.WIKI,root/html532/ROOT__Math__GaussLegendreIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html:556,Deployability,Integrat,Integration,556,". ROOT::Math::GaussLegendreIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::GaussLegendreIntegrator. class ROOT::Math::GaussLegendreIntegrator: public ROOT::Math::GaussIntegrator. User class for performing function integration. It will use the Gauss-Legendre Method for function integration in a given interval.; This class is implemented from TF1::Integral(). @ingroup Integration. Function Members (Methods); public:. virtual~GaussLegendreIntegrator(); voidROOT::Math::GaussIntegrator::AbsValue(bool flag); virtual doubleROOT::Math::GaussIntegrator::Error() const; ROOT::Math::GaussIntegratorROOT::Math::GaussIntegrator::GaussIntegrator(double relTol = 1.E-12); ROOT::Math::GaussIntegratorROOT::Math::GaussIntegrator::GaussIntegrator(const ROOT::Math::GaussIntegrator&); ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(const ROOT::Math::GaussLegendreIntegrator&); ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(int num = 10, double eps = 1e-12); intGetNumberPoints() const; voidGetWeightVectors(double* x, double* w) const; virtual doubleROOT::Math::GaussIntegrator::Integral(); virtual doubleROOT::Math::GaussIntegrator::Integral(const vector<double>& pts); virtual doubleROOT::Math::GaussIntegrator::Integral(double a, double b); virtual doubleROOT::Math::GaussIntegrator::IntegralCauchy(double a, double b, double c); virtual doubleROOT::Math::GaussIntegrator::IntegralLow(double b); virtual doubleROOT::Math::GaussIntegrator::IntegralUp(double a); virtual intNEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleROOT::Math::GaussIntegrator::Result() const; virtual voidSetAbsTolerance(double); virtual voidROOT::Math::Gaus",MatchSource.WIKI,root/html532/ROOT__Math__GaussLegendreIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html:1837,Deployability,Integrat,IntegratorOneDimOptionsOptions,1837,"; public:. virtual~GaussLegendreIntegrator(); voidROOT::Math::GaussIntegrator::AbsValue(bool flag); virtual doubleROOT::Math::GaussIntegrator::Error() const; ROOT::Math::GaussIntegratorROOT::Math::GaussIntegrator::GaussIntegrator(double relTol = 1.E-12); ROOT::Math::GaussIntegratorROOT::Math::GaussIntegrator::GaussIntegrator(const ROOT::Math::GaussIntegrator&); ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(const ROOT::Math::GaussLegendreIntegrator&); ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(int num = 10, double eps = 1e-12); intGetNumberPoints() const; voidGetWeightVectors(double* x, double* w) const; virtual doubleROOT::Math::GaussIntegrator::Integral(); virtual doubleROOT::Math::GaussIntegrator::Integral(const vector<double>& pts); virtual doubleROOT::Math::GaussIntegrator::Integral(double a, double b); virtual doubleROOT::Math::GaussIntegrator::IntegralCauchy(double a, double b, double c); virtual doubleROOT::Math::GaussIntegrator::IntegralLow(double b); virtual doubleROOT::Math::GaussIntegrator::IntegralUp(double a); virtual intNEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleROOT::Math::GaussIntegrator::Result() const; virtual voidSetAbsTolerance(double); virtual voidROOT::Math::GaussIntegrator::SetFunction(const ROOT::Math::IGenFunction&); voidSetNumberPoints(int num); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double); virtual intROOT::Math::GaussIntegrator::Status() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. private:. voidCalcGaussLegendreSamplingPoints(); virtual doubleDoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Data Members; protected:. doubleROOT::Math::GaussIntegrator::fEpsilonRelative error.; const ROOT::Math::IGenFuncti",MatchSource.WIKI,root/html532/ROOT__Math__GaussLegendreIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html:2131,Deployability,Integrat,IntegratorOneDimOptions,2131,"; public:. virtual~GaussLegendreIntegrator(); voidROOT::Math::GaussIntegrator::AbsValue(bool flag); virtual doubleROOT::Math::GaussIntegrator::Error() const; ROOT::Math::GaussIntegratorROOT::Math::GaussIntegrator::GaussIntegrator(double relTol = 1.E-12); ROOT::Math::GaussIntegratorROOT::Math::GaussIntegrator::GaussIntegrator(const ROOT::Math::GaussIntegrator&); ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(const ROOT::Math::GaussLegendreIntegrator&); ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(int num = 10, double eps = 1e-12); intGetNumberPoints() const; voidGetWeightVectors(double* x, double* w) const; virtual doubleROOT::Math::GaussIntegrator::Integral(); virtual doubleROOT::Math::GaussIntegrator::Integral(const vector<double>& pts); virtual doubleROOT::Math::GaussIntegrator::Integral(double a, double b); virtual doubleROOT::Math::GaussIntegrator::IntegralCauchy(double a, double b, double c); virtual doubleROOT::Math::GaussIntegrator::IntegralLow(double b); virtual doubleROOT::Math::GaussIntegrator::IntegralUp(double a); virtual intNEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleROOT::Math::GaussIntegrator::Result() const; virtual voidSetAbsTolerance(double); virtual voidROOT::Math::GaussIntegrator::SetFunction(const ROOT::Math::IGenFunction&); voidSetNumberPoints(int num); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double); virtual intROOT::Math::GaussIntegrator::Status() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. private:. voidCalcGaussLegendreSamplingPoints(); virtual doubleDoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Data Members; protected:. doubleROOT::Math::GaussIntegrator::fEpsilonRelative error.; const ROOT::Math::IGenFuncti",MatchSource.WIKI,root/html532/ROOT__Math__GaussLegendreIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html:2275,Deployability,Integrat,IntegrationOneDim,2275,"; public:. virtual~GaussLegendreIntegrator(); voidROOT::Math::GaussIntegrator::AbsValue(bool flag); virtual doubleROOT::Math::GaussIntegrator::Error() const; ROOT::Math::GaussIntegratorROOT::Math::GaussIntegrator::GaussIntegrator(double relTol = 1.E-12); ROOT::Math::GaussIntegratorROOT::Math::GaussIntegrator::GaussIntegrator(const ROOT::Math::GaussIntegrator&); ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(const ROOT::Math::GaussLegendreIntegrator&); ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(int num = 10, double eps = 1e-12); intGetNumberPoints() const; voidGetWeightVectors(double* x, double* w) const; virtual doubleROOT::Math::GaussIntegrator::Integral(); virtual doubleROOT::Math::GaussIntegrator::Integral(const vector<double>& pts); virtual doubleROOT::Math::GaussIntegrator::Integral(double a, double b); virtual doubleROOT::Math::GaussIntegrator::IntegralCauchy(double a, double b, double c); virtual doubleROOT::Math::GaussIntegrator::IntegralLow(double b); virtual doubleROOT::Math::GaussIntegrator::IntegralUp(double a); virtual intNEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleROOT::Math::GaussIntegrator::Result() const; virtual voidSetAbsTolerance(double); virtual voidROOT::Math::GaussIntegrator::SetFunction(const ROOT::Math::IGenFunction&); voidSetNumberPoints(int num); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double); virtual intROOT::Math::GaussIntegrator::Status() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. private:. voidCalcGaussLegendreSamplingPoints(); virtual doubleDoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Data Members; protected:. doubleROOT::Math::GaussIntegrator::fEpsilonRelative error.; const ROOT::Math::IGenFuncti",MatchSource.WIKI,root/html532/ROOT__Math__GaussLegendreIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html:3416,Deployability,integrat,integration,3416,"(); virtual doubleDoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Data Members; protected:. doubleROOT::Math::GaussIntegrator::fEpsilonRelative error.; const ROOT::Math::IGenFunction*ROOT::Math::GaussIntegrator::fFunctionPointer to function used.; doubleROOT::Math::GaussIntegrator::fLastErrorError from the last stimation.; doubleROOT::Math::GaussIntegrator::fLastResultResult from the last stimation.; intfNumNumber of points used in the stimation of the integral.; boolROOT::Math::GaussIntegrator::fUsedOnceBool value to check if the function was at least called once.; double*fWWeights of the points used.; double*fXAbscisa of the points used.; static boolROOT::Math::GaussIntegrator::fgAbsValueAbsValue used for the calculation of the integral. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GaussLegendreIntegrator(int num = 10, double eps = 1e-12); Basic contructor of GaussLegendreIntegrator.; \@param num Number of desired points to calculate the integration.; \@param eps Desired relative error. virtual ~GaussLegendreIntegrator(); Default Destructor . void SetNumberPoints(int num); Set the number of points used in the calculation of the; integral . void SetRelTolerance(double ); Set the desired relative Error. . void SetAbsTolerance(double ); This method is not implemented. . void GetWeightVectors(double* x, double* w) const; Returns the arrays x and w containing the abscissa and weight of; the Gauss-Legendre n-point quadrature formula. Gauss-Legendre: W(x)=1 -1<x<1; (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}. int GetNumberPoints() const; { return fNum; }. int NEval() const. return number of function evaluations in calculating the integral; This is equivalent to the number of points. { return fNum; }. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. double DoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Integration surrugate method. Return integral of passed f",MatchSource.WIKI,root/html532/ROOT__Math__GaussLegendreIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html:4212,Deployability,Integrat,IntegratorOneDimOptions,4212,"es; Libraries. Function documentation; GaussLegendreIntegrator(int num = 10, double eps = 1e-12); Basic contructor of GaussLegendreIntegrator.; \@param num Number of desired points to calculate the integration.; \@param eps Desired relative error. virtual ~GaussLegendreIntegrator(); Default Destructor . void SetNumberPoints(int num); Set the number of points used in the calculation of the; integral . void SetRelTolerance(double ); Set the desired relative Error. . void SetAbsTolerance(double ); This method is not implemented. . void GetWeightVectors(double* x, double* w) const; Returns the arrays x and w containing the abscissa and weight of; the Gauss-Legendre n-point quadrature formula. Gauss-Legendre: W(x)=1 -1<x<1; (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}. int GetNumberPoints() const; { return fNum; }. int NEval() const. return number of function evaluations in calculating the integral; This is equivalent to the number of points. { return fNum; }. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. double DoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Integration surrugate method. Return integral of passed function in interval [a,b]; Reimplement method of GaussIntegrator using CalcGaussLegendreSamplingPoints. void CalcGaussLegendreSamplingPoints(). Type: unsafe but fast interface filling the arrays x and w (static method). Given the number of sampling points this routine fills the arrays x and w; of length num, containing the abscissa and weight of the Gauss-Legendre; n-point quadrature formula. Gauss-Legendre: W(x)=1 -1<x<1; (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}. num is the number of sampling points (>0); x and w are arrays of size num; eps is the relative precision. If num<=0 or eps<=0 no action is done. Reference: Numerical Recipes in C, Second Edition.  Last changed: root/mathcore:$Id: GaussLegendreIntegrator.h 36764 2010-11-19 10:02:00Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically",MatchSource.WIKI,root/html532/ROOT__Math__GaussLegendreIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html:4337,Deployability,Integrat,Integration,4337,"LegendreIntegrator.; \@param num Number of desired points to calculate the integration.; \@param eps Desired relative error. virtual ~GaussLegendreIntegrator(); Default Destructor . void SetNumberPoints(int num); Set the number of points used in the calculation of the; integral . void SetRelTolerance(double ); Set the desired relative Error. . void SetAbsTolerance(double ); This method is not implemented. . void GetWeightVectors(double* x, double* w) const; Returns the arrays x and w containing the abscissa and weight of; the Gauss-Legendre n-point quadrature formula. Gauss-Legendre: W(x)=1 -1<x<1; (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}. int GetNumberPoints() const; { return fNum; }. int NEval() const. return number of function evaluations in calculating the integral; This is equivalent to the number of points. { return fNum; }. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. double DoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Integration surrugate method. Return integral of passed function in interval [a,b]; Reimplement method of GaussIntegrator using CalcGaussLegendreSamplingPoints. void CalcGaussLegendreSamplingPoints(). Type: unsafe but fast interface filling the arrays x and w (static method). Given the number of sampling points this routine fills the arrays x and w; of length num, containing the abscissa and weight of the Gauss-Legendre; n-point quadrature formula. Gauss-Legendre: W(x)=1 -1<x<1; (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}. num is the number of sampling points (>0); x and w are arrays of size num; eps is the relative precision. If num<=0 or eps<=0 no action is done. Reference: Numerical Recipes in C, Second Edition.  Last changed: root/mathcore:$Id: GaussLegendreIntegrator.h 36764 2010-11-19 10:02:00Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__GaussLegendreIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html:401,Integrability,integrat,integration,401,". ROOT::Math::GaussLegendreIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::GaussLegendreIntegrator. class ROOT::Math::GaussLegendreIntegrator: public ROOT::Math::GaussIntegrator. User class for performing function integration. It will use the Gauss-Legendre Method for function integration in a given interval.; This class is implemented from TF1::Integral(). @ingroup Integration. Function Members (Methods); public:. virtual~GaussLegendreIntegrator(); voidROOT::Math::GaussIntegrator::AbsValue(bool flag); virtual doubleROOT::Math::GaussIntegrator::Error() const; ROOT::Math::GaussIntegratorROOT::Math::GaussIntegrator::GaussIntegrator(double relTol = 1.E-12); ROOT::Math::GaussIntegratorROOT::Math::GaussIntegrator::GaussIntegrator(const ROOT::Math::GaussIntegrator&); ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(const ROOT::Math::GaussLegendreIntegrator&); ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(int num = 10, double eps = 1e-12); intGetNumberPoints() const; voidGetWeightVectors(double* x, double* w) const; virtual doubleROOT::Math::GaussIntegrator::Integral(); virtual doubleROOT::Math::GaussIntegrator::Integral(const vector<double>& pts); virtual doubleROOT::Math::GaussIntegrator::Integral(double a, double b); virtual doubleROOT::Math::GaussIntegrator::IntegralCauchy(double a, double b, double c); virtual doubleROOT::Math::GaussIntegrator::IntegralLow(double b); virtual doubleROOT::Math::GaussIntegrator::IntegralUp(double a); virtual intNEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleROOT::Math::GaussIntegrator::Result() const; virtual voidSetAbsTolerance(double); virtual voidROOT::Math::Gaus",MatchSource.WIKI,root/html532/ROOT__Math__GaussLegendreIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html:465,Integrability,integrat,integration,465,". ROOT::Math::GaussLegendreIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::GaussLegendreIntegrator. class ROOT::Math::GaussLegendreIntegrator: public ROOT::Math::GaussIntegrator. User class for performing function integration. It will use the Gauss-Legendre Method for function integration in a given interval.; This class is implemented from TF1::Integral(). @ingroup Integration. Function Members (Methods); public:. virtual~GaussLegendreIntegrator(); voidROOT::Math::GaussIntegrator::AbsValue(bool flag); virtual doubleROOT::Math::GaussIntegrator::Error() const; ROOT::Math::GaussIntegratorROOT::Math::GaussIntegrator::GaussIntegrator(double relTol = 1.E-12); ROOT::Math::GaussIntegratorROOT::Math::GaussIntegrator::GaussIntegrator(const ROOT::Math::GaussIntegrator&); ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(const ROOT::Math::GaussLegendreIntegrator&); ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(int num = 10, double eps = 1e-12); intGetNumberPoints() const; voidGetWeightVectors(double* x, double* w) const; virtual doubleROOT::Math::GaussIntegrator::Integral(); virtual doubleROOT::Math::GaussIntegrator::Integral(const vector<double>& pts); virtual doubleROOT::Math::GaussIntegrator::Integral(double a, double b); virtual doubleROOT::Math::GaussIntegrator::IntegralCauchy(double a, double b, double c); virtual doubleROOT::Math::GaussIntegrator::IntegralLow(double b); virtual doubleROOT::Math::GaussIntegrator::IntegralUp(double a); virtual intNEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleROOT::Math::GaussIntegrator::Result() const; virtual voidSetAbsTolerance(double); virtual voidROOT::Math::Gaus",MatchSource.WIKI,root/html532/ROOT__Math__GaussLegendreIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html:556,Integrability,Integrat,Integration,556,". ROOT::Math::GaussLegendreIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::GaussLegendreIntegrator. class ROOT::Math::GaussLegendreIntegrator: public ROOT::Math::GaussIntegrator. User class for performing function integration. It will use the Gauss-Legendre Method for function integration in a given interval.; This class is implemented from TF1::Integral(). @ingroup Integration. Function Members (Methods); public:. virtual~GaussLegendreIntegrator(); voidROOT::Math::GaussIntegrator::AbsValue(bool flag); virtual doubleROOT::Math::GaussIntegrator::Error() const; ROOT::Math::GaussIntegratorROOT::Math::GaussIntegrator::GaussIntegrator(double relTol = 1.E-12); ROOT::Math::GaussIntegratorROOT::Math::GaussIntegrator::GaussIntegrator(const ROOT::Math::GaussIntegrator&); ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(const ROOT::Math::GaussLegendreIntegrator&); ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(int num = 10, double eps = 1e-12); intGetNumberPoints() const; voidGetWeightVectors(double* x, double* w) const; virtual doubleROOT::Math::GaussIntegrator::Integral(); virtual doubleROOT::Math::GaussIntegrator::Integral(const vector<double>& pts); virtual doubleROOT::Math::GaussIntegrator::Integral(double a, double b); virtual doubleROOT::Math::GaussIntegrator::IntegralCauchy(double a, double b, double c); virtual doubleROOT::Math::GaussIntegrator::IntegralLow(double b); virtual doubleROOT::Math::GaussIntegrator::IntegralUp(double a); virtual intNEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleROOT::Math::GaussIntegrator::Result() const; virtual voidSetAbsTolerance(double); virtual voidROOT::Math::Gaus",MatchSource.WIKI,root/html532/ROOT__Math__GaussLegendreIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html:1837,Integrability,Integrat,IntegratorOneDimOptionsOptions,1837,"; public:. virtual~GaussLegendreIntegrator(); voidROOT::Math::GaussIntegrator::AbsValue(bool flag); virtual doubleROOT::Math::GaussIntegrator::Error() const; ROOT::Math::GaussIntegratorROOT::Math::GaussIntegrator::GaussIntegrator(double relTol = 1.E-12); ROOT::Math::GaussIntegratorROOT::Math::GaussIntegrator::GaussIntegrator(const ROOT::Math::GaussIntegrator&); ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(const ROOT::Math::GaussLegendreIntegrator&); ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(int num = 10, double eps = 1e-12); intGetNumberPoints() const; voidGetWeightVectors(double* x, double* w) const; virtual doubleROOT::Math::GaussIntegrator::Integral(); virtual doubleROOT::Math::GaussIntegrator::Integral(const vector<double>& pts); virtual doubleROOT::Math::GaussIntegrator::Integral(double a, double b); virtual doubleROOT::Math::GaussIntegrator::IntegralCauchy(double a, double b, double c); virtual doubleROOT::Math::GaussIntegrator::IntegralLow(double b); virtual doubleROOT::Math::GaussIntegrator::IntegralUp(double a); virtual intNEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleROOT::Math::GaussIntegrator::Result() const; virtual voidSetAbsTolerance(double); virtual voidROOT::Math::GaussIntegrator::SetFunction(const ROOT::Math::IGenFunction&); voidSetNumberPoints(int num); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double); virtual intROOT::Math::GaussIntegrator::Status() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. private:. voidCalcGaussLegendreSamplingPoints(); virtual doubleDoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Data Members; protected:. doubleROOT::Math::GaussIntegrator::fEpsilonRelative error.; const ROOT::Math::IGenFuncti",MatchSource.WIKI,root/html532/ROOT__Math__GaussLegendreIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html:2131,Integrability,Integrat,IntegratorOneDimOptions,2131,"; public:. virtual~GaussLegendreIntegrator(); voidROOT::Math::GaussIntegrator::AbsValue(bool flag); virtual doubleROOT::Math::GaussIntegrator::Error() const; ROOT::Math::GaussIntegratorROOT::Math::GaussIntegrator::GaussIntegrator(double relTol = 1.E-12); ROOT::Math::GaussIntegratorROOT::Math::GaussIntegrator::GaussIntegrator(const ROOT::Math::GaussIntegrator&); ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(const ROOT::Math::GaussLegendreIntegrator&); ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(int num = 10, double eps = 1e-12); intGetNumberPoints() const; voidGetWeightVectors(double* x, double* w) const; virtual doubleROOT::Math::GaussIntegrator::Integral(); virtual doubleROOT::Math::GaussIntegrator::Integral(const vector<double>& pts); virtual doubleROOT::Math::GaussIntegrator::Integral(double a, double b); virtual doubleROOT::Math::GaussIntegrator::IntegralCauchy(double a, double b, double c); virtual doubleROOT::Math::GaussIntegrator::IntegralLow(double b); virtual doubleROOT::Math::GaussIntegrator::IntegralUp(double a); virtual intNEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleROOT::Math::GaussIntegrator::Result() const; virtual voidSetAbsTolerance(double); virtual voidROOT::Math::GaussIntegrator::SetFunction(const ROOT::Math::IGenFunction&); voidSetNumberPoints(int num); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double); virtual intROOT::Math::GaussIntegrator::Status() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. private:. voidCalcGaussLegendreSamplingPoints(); virtual doubleDoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Data Members; protected:. doubleROOT::Math::GaussIntegrator::fEpsilonRelative error.; const ROOT::Math::IGenFuncti",MatchSource.WIKI,root/html532/ROOT__Math__GaussLegendreIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html:2275,Integrability,Integrat,IntegrationOneDim,2275,"; public:. virtual~GaussLegendreIntegrator(); voidROOT::Math::GaussIntegrator::AbsValue(bool flag); virtual doubleROOT::Math::GaussIntegrator::Error() const; ROOT::Math::GaussIntegratorROOT::Math::GaussIntegrator::GaussIntegrator(double relTol = 1.E-12); ROOT::Math::GaussIntegratorROOT::Math::GaussIntegrator::GaussIntegrator(const ROOT::Math::GaussIntegrator&); ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(const ROOT::Math::GaussLegendreIntegrator&); ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(int num = 10, double eps = 1e-12); intGetNumberPoints() const; voidGetWeightVectors(double* x, double* w) const; virtual doubleROOT::Math::GaussIntegrator::Integral(); virtual doubleROOT::Math::GaussIntegrator::Integral(const vector<double>& pts); virtual doubleROOT::Math::GaussIntegrator::Integral(double a, double b); virtual doubleROOT::Math::GaussIntegrator::IntegralCauchy(double a, double b, double c); virtual doubleROOT::Math::GaussIntegrator::IntegralLow(double b); virtual doubleROOT::Math::GaussIntegrator::IntegralUp(double a); virtual intNEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleROOT::Math::GaussIntegrator::Result() const; virtual voidSetAbsTolerance(double); virtual voidROOT::Math::GaussIntegrator::SetFunction(const ROOT::Math::IGenFunction&); voidSetNumberPoints(int num); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double); virtual intROOT::Math::GaussIntegrator::Status() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. private:. voidCalcGaussLegendreSamplingPoints(); virtual doubleDoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Data Members; protected:. doubleROOT::Math::GaussIntegrator::fEpsilonRelative error.; const ROOT::Math::IGenFuncti",MatchSource.WIKI,root/html532/ROOT__Math__GaussLegendreIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html:3416,Integrability,integrat,integration,3416,"(); virtual doubleDoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Data Members; protected:. doubleROOT::Math::GaussIntegrator::fEpsilonRelative error.; const ROOT::Math::IGenFunction*ROOT::Math::GaussIntegrator::fFunctionPointer to function used.; doubleROOT::Math::GaussIntegrator::fLastErrorError from the last stimation.; doubleROOT::Math::GaussIntegrator::fLastResultResult from the last stimation.; intfNumNumber of points used in the stimation of the integral.; boolROOT::Math::GaussIntegrator::fUsedOnceBool value to check if the function was at least called once.; double*fWWeights of the points used.; double*fXAbscisa of the points used.; static boolROOT::Math::GaussIntegrator::fgAbsValueAbsValue used for the calculation of the integral. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GaussLegendreIntegrator(int num = 10, double eps = 1e-12); Basic contructor of GaussLegendreIntegrator.; \@param num Number of desired points to calculate the integration.; \@param eps Desired relative error. virtual ~GaussLegendreIntegrator(); Default Destructor . void SetNumberPoints(int num); Set the number of points used in the calculation of the; integral . void SetRelTolerance(double ); Set the desired relative Error. . void SetAbsTolerance(double ); This method is not implemented. . void GetWeightVectors(double* x, double* w) const; Returns the arrays x and w containing the abscissa and weight of; the Gauss-Legendre n-point quadrature formula. Gauss-Legendre: W(x)=1 -1<x<1; (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}. int GetNumberPoints() const; { return fNum; }. int NEval() const. return number of function evaluations in calculating the integral; This is equivalent to the number of points. { return fNum; }. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. double DoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Integration surrugate method. Return integral of passed f",MatchSource.WIKI,root/html532/ROOT__Math__GaussLegendreIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html:4212,Integrability,Integrat,IntegratorOneDimOptions,4212,"es; Libraries. Function documentation; GaussLegendreIntegrator(int num = 10, double eps = 1e-12); Basic contructor of GaussLegendreIntegrator.; \@param num Number of desired points to calculate the integration.; \@param eps Desired relative error. virtual ~GaussLegendreIntegrator(); Default Destructor . void SetNumberPoints(int num); Set the number of points used in the calculation of the; integral . void SetRelTolerance(double ); Set the desired relative Error. . void SetAbsTolerance(double ); This method is not implemented. . void GetWeightVectors(double* x, double* w) const; Returns the arrays x and w containing the abscissa and weight of; the Gauss-Legendre n-point quadrature formula. Gauss-Legendre: W(x)=1 -1<x<1; (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}. int GetNumberPoints() const; { return fNum; }. int NEval() const. return number of function evaluations in calculating the integral; This is equivalent to the number of points. { return fNum; }. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. double DoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Integration surrugate method. Return integral of passed function in interval [a,b]; Reimplement method of GaussIntegrator using CalcGaussLegendreSamplingPoints. void CalcGaussLegendreSamplingPoints(). Type: unsafe but fast interface filling the arrays x and w (static method). Given the number of sampling points this routine fills the arrays x and w; of length num, containing the abscissa and weight of the Gauss-Legendre; n-point quadrature formula. Gauss-Legendre: W(x)=1 -1<x<1; (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}. num is the number of sampling points (>0); x and w are arrays of size num; eps is the relative precision. If num<=0 or eps<=0 no action is done. Reference: Numerical Recipes in C, Second Edition.  Last changed: root/mathcore:$Id: GaussLegendreIntegrator.h 36764 2010-11-19 10:02:00Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically",MatchSource.WIKI,root/html532/ROOT__Math__GaussLegendreIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html:4337,Integrability,Integrat,Integration,4337,"LegendreIntegrator.; \@param num Number of desired points to calculate the integration.; \@param eps Desired relative error. virtual ~GaussLegendreIntegrator(); Default Destructor . void SetNumberPoints(int num); Set the number of points used in the calculation of the; integral . void SetRelTolerance(double ); Set the desired relative Error. . void SetAbsTolerance(double ); This method is not implemented. . void GetWeightVectors(double* x, double* w) const; Returns the arrays x and w containing the abscissa and weight of; the Gauss-Legendre n-point quadrature formula. Gauss-Legendre: W(x)=1 -1<x<1; (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}. int GetNumberPoints() const; { return fNum; }. int NEval() const. return number of function evaluations in calculating the integral; This is equivalent to the number of points. { return fNum; }. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. double DoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Integration surrugate method. Return integral of passed function in interval [a,b]; Reimplement method of GaussIntegrator using CalcGaussLegendreSamplingPoints. void CalcGaussLegendreSamplingPoints(). Type: unsafe but fast interface filling the arrays x and w (static method). Given the number of sampling points this routine fills the arrays x and w; of length num, containing the abscissa and weight of the Gauss-Legendre; n-point quadrature formula. Gauss-Legendre: W(x)=1 -1<x<1; (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}. num is the number of sampling points (>0); x and w are arrays of size num; eps is the relative precision. If num<=0 or eps<=0 no action is done. Reference: Numerical Recipes in C, Second Edition.  Last changed: root/mathcore:$Id: GaussLegendreIntegrator.h 36764 2010-11-19 10:02:00Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__GaussLegendreIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html:4560,Integrability,interface,interface,4560,"LegendreIntegrator.; \@param num Number of desired points to calculate the integration.; \@param eps Desired relative error. virtual ~GaussLegendreIntegrator(); Default Destructor . void SetNumberPoints(int num); Set the number of points used in the calculation of the; integral . void SetRelTolerance(double ); Set the desired relative Error. . void SetAbsTolerance(double ); This method is not implemented. . void GetWeightVectors(double* x, double* w) const; Returns the arrays x and w containing the abscissa and weight of; the Gauss-Legendre n-point quadrature formula. Gauss-Legendre: W(x)=1 -1<x<1; (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}. int GetNumberPoints() const; { return fNum; }. int NEval() const. return number of function evaluations in calculating the integral; This is equivalent to the number of points. { return fNum; }. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. double DoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Integration surrugate method. Return integral of passed function in interval [a,b]; Reimplement method of GaussIntegrator using CalcGaussLegendreSamplingPoints. void CalcGaussLegendreSamplingPoints(). Type: unsafe but fast interface filling the arrays x and w (static method). Given the number of sampling points this routine fills the arrays x and w; of length num, containing the abscissa and weight of the Gauss-Legendre; n-point quadrature formula. Gauss-Legendre: W(x)=1 -1<x<1; (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}. num is the number of sampling points (>0); x and w are arrays of size num; eps is the relative precision. If num<=0 or eps<=0 no action is done. Reference: Numerical Recipes in C, Second Edition.  Last changed: root/mathcore:$Id: GaussLegendreIntegrator.h 36764 2010-11-19 10:02:00Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__GaussLegendreIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html:4655,Integrability,rout,routine,4655,"LegendreIntegrator.; \@param num Number of desired points to calculate the integration.; \@param eps Desired relative error. virtual ~GaussLegendreIntegrator(); Default Destructor . void SetNumberPoints(int num); Set the number of points used in the calculation of the; integral . void SetRelTolerance(double ); Set the desired relative Error. . void SetAbsTolerance(double ); This method is not implemented. . void GetWeightVectors(double* x, double* w) const; Returns the arrays x and w containing the abscissa and weight of; the Gauss-Legendre n-point quadrature formula. Gauss-Legendre: W(x)=1 -1<x<1; (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}. int GetNumberPoints() const; { return fNum; }. int NEval() const. return number of function evaluations in calculating the integral; This is equivalent to the number of points. { return fNum; }. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. double DoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Integration surrugate method. Return integral of passed function in interval [a,b]; Reimplement method of GaussIntegrator using CalcGaussLegendreSamplingPoints. void CalcGaussLegendreSamplingPoints(). Type: unsafe but fast interface filling the arrays x and w (static method). Given the number of sampling points this routine fills the arrays x and w; of length num, containing the abscissa and weight of the Gauss-Legendre; n-point quadrature formula. Gauss-Legendre: W(x)=1 -1<x<1; (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}. num is the number of sampling points (>0); x and w are arrays of size num; eps is the relative precision. If num<=0 or eps<=0 no action is done. Reference: Numerical Recipes in C, Second Edition.  Last changed: root/mathcore:$Id: GaussLegendreIntegrator.h 36764 2010-11-19 10:02:00Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__GaussLegendreIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html:3180,Modifiability,Inherit,Inheritance,3180,"l intROOT::Math::GaussIntegrator::Status() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. private:. voidCalcGaussLegendreSamplingPoints(); virtual doubleDoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Data Members; protected:. doubleROOT::Math::GaussIntegrator::fEpsilonRelative error.; const ROOT::Math::IGenFunction*ROOT::Math::GaussIntegrator::fFunctionPointer to function used.; doubleROOT::Math::GaussIntegrator::fLastErrorError from the last stimation.; doubleROOT::Math::GaussIntegrator::fLastResultResult from the last stimation.; intfNumNumber of points used in the stimation of the integral.; boolROOT::Math::GaussIntegrator::fUsedOnceBool value to check if the function was at least called once.; double*fWWeights of the points used.; double*fXAbscisa of the points used.; static boolROOT::Math::GaussIntegrator::fgAbsValueAbsValue used for the calculation of the integral. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GaussLegendreIntegrator(int num = 10, double eps = 1e-12); Basic contructor of GaussLegendreIntegrator.; \@param num Number of desired points to calculate the integration.; \@param eps Desired relative error. virtual ~GaussLegendreIntegrator(); Default Destructor . void SetNumberPoints(int num); Set the number of points used in the calculation of the; integral . void SetRelTolerance(double ); Set the desired relative Error. . void SetAbsTolerance(double ); This method is not implemented. . void GetWeightVectors(double* x, double* w) const; Returns the arrays x and w containing the abscissa and weight of; the Gauss-Legendre n-point quadrature formula. Gauss-Legendre: W(x)=1 -1<x<1; (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}. int GetNumberPoints() const; { return fNum; }. int NEval() const. return number of function evaluations in calculating the integral; This is equivalent to the number of points. { return fNum; }. void SetOptions(const ROOT::",MatchSource.WIKI,root/html532/ROOT__Math__GaussLegendreIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html:3193,Modifiability,Inherit,Inherited,3193,"l intROOT::Math::GaussIntegrator::Status() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. private:. voidCalcGaussLegendreSamplingPoints(); virtual doubleDoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Data Members; protected:. doubleROOT::Math::GaussIntegrator::fEpsilonRelative error.; const ROOT::Math::IGenFunction*ROOT::Math::GaussIntegrator::fFunctionPointer to function used.; doubleROOT::Math::GaussIntegrator::fLastErrorError from the last stimation.; doubleROOT::Math::GaussIntegrator::fLastResultResult from the last stimation.; intfNumNumber of points used in the stimation of the integral.; boolROOT::Math::GaussIntegrator::fUsedOnceBool value to check if the function was at least called once.; double*fWWeights of the points used.; double*fXAbscisa of the points used.; static boolROOT::Math::GaussIntegrator::fgAbsValueAbsValue used for the calculation of the integral. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GaussLegendreIntegrator(int num = 10, double eps = 1e-12); Basic contructor of GaussLegendreIntegrator.; \@param num Number of desired points to calculate the integration.; \@param eps Desired relative error. virtual ~GaussLegendreIntegrator(); Default Destructor . void SetNumberPoints(int num); Set the number of points used in the calculation of the; integral . void SetRelTolerance(double ); Set the desired relative Error. . void SetAbsTolerance(double ); This method is not implemented. . void GetWeightVectors(double* x, double* w) const; Returns the arrays x and w containing the abscissa and weight of; the Gauss-Legendre n-point quadrature formula. Gauss-Legendre: W(x)=1 -1<x<1; (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}. int GetNumberPoints() const; { return fNum; }. int NEval() const. return number of function evaluations in calculating the integral; This is equivalent to the number of points. { return fNum; }. void SetOptions(const ROOT::",MatchSource.WIKI,root/html532/ROOT__Math__GaussLegendreIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html:381,Performance,perform,performing,381,". ROOT::Math::GaussLegendreIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::GaussLegendreIntegrator. class ROOT::Math::GaussLegendreIntegrator: public ROOT::Math::GaussIntegrator. User class for performing function integration. It will use the Gauss-Legendre Method for function integration in a given interval.; This class is implemented from TF1::Integral(). @ingroup Integration. Function Members (Methods); public:. virtual~GaussLegendreIntegrator(); voidROOT::Math::GaussIntegrator::AbsValue(bool flag); virtual doubleROOT::Math::GaussIntegrator::Error() const; ROOT::Math::GaussIntegratorROOT::Math::GaussIntegrator::GaussIntegrator(double relTol = 1.E-12); ROOT::Math::GaussIntegratorROOT::Math::GaussIntegrator::GaussIntegrator(const ROOT::Math::GaussIntegrator&); ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(const ROOT::Math::GaussLegendreIntegrator&); ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(int num = 10, double eps = 1e-12); intGetNumberPoints() const; voidGetWeightVectors(double* x, double* w) const; virtual doubleROOT::Math::GaussIntegrator::Integral(); virtual doubleROOT::Math::GaussIntegrator::Integral(const vector<double>& pts); virtual doubleROOT::Math::GaussIntegrator::Integral(double a, double b); virtual doubleROOT::Math::GaussIntegrator::IntegralCauchy(double a, double b, double c); virtual doubleROOT::Math::GaussIntegrator::IntegralLow(double b); virtual doubleROOT::Math::GaussIntegrator::IntegralUp(double a); virtual intNEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleROOT::Math::GaussIntegrator::Result() const; virtual voidSetAbsTolerance(double); virtual voidROOT::Math::Gaus",MatchSource.WIKI,root/html532/ROOT__Math__GaussLegendreIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html
https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html:4544,Safety,unsafe,unsafe,4544,"LegendreIntegrator.; \@param num Number of desired points to calculate the integration.; \@param eps Desired relative error. virtual ~GaussLegendreIntegrator(); Default Destructor . void SetNumberPoints(int num); Set the number of points used in the calculation of the; integral . void SetRelTolerance(double ); Set the desired relative Error. . void SetAbsTolerance(double ); This method is not implemented. . void GetWeightVectors(double* x, double* w) const; Returns the arrays x and w containing the abscissa and weight of; the Gauss-Legendre n-point quadrature formula. Gauss-Legendre: W(x)=1 -1<x<1; (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}. int GetNumberPoints() const; { return fNum; }. int NEval() const. return number of function evaluations in calculating the integral; This is equivalent to the number of points. { return fNum; }. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. double DoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Integration surrugate method. Return integral of passed function in interval [a,b]; Reimplement method of GaussIntegrator using CalcGaussLegendreSamplingPoints. void CalcGaussLegendreSamplingPoints(). Type: unsafe but fast interface filling the arrays x and w (static method). Given the number of sampling points this routine fills the arrays x and w; of length num, containing the abscissa and weight of the Gauss-Legendre; n-point quadrature formula. Gauss-Legendre: W(x)=1 -1<x<1; (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}. num is the number of sampling points (>0); x and w are arrays of size num; eps is the relative precision. If num<=0 or eps<=0 no action is done. Reference: Numerical Recipes in C, Second Edition.  Last changed: root/mathcore:$Id: GaussLegendreIntegrator.h 36764 2010-11-19 10:02:00Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__GaussLegendreIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GaussLegendreIntegrator.html
https://root.cern/root/html532/ROOT__Math__GeneticMinimizer.html:857,Availability,Error,ErrorDef,857," virtual~GeneticMinimizer(); virtual voidClear(); virtual boolROOT::Math::Minimizer::Contour(unsigned int, unsigned int, unsigned int&, double*, double*); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int i, unsigned int j) const; virtual intROOT::Math::Minimizer::CovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; ROOT::Math::GeneticMinimizerGeneticMinimizer(int = 0); virtual boolROOT::Math::Minimizer::GetCovMatrix(double*) const; virtual boolROOT::Math::Minimizer::GetHessianMatrix(double*) const; virtual boolROOT::Math::Minimizer::GetMinosError(unsigned int, double& errLow, double& errUp, int = 0); virtual doubleROOT::Math::Minimizer::GlobalCC(unsigned int) const; virtual boolROOT::Math::Minimizer::Hesse(); boolROOT::Math::Minimizer::IsValidError() const; unsigned intROOT::Math::Minimizer::MaxFunctionCalls() const; unsigned intROOT::Math::Minimizer::MaxIterations() const; virtual const double*MinGradient() const; virtual boolMinimize(); virtual doubleMinValue() const; virtual unsigned intNCalls() const; virtual unsigned intNDim() const; virtual unsigned intNFree() const; virtual ROOT::Math::MinimizerOptionsOptions() const; doubleROOT::Math::Minimizer::Precision() const; intROOT::Math::Minimizer::PrintLevel() const; virtual voidROOT::Math::Minimizer::PrintResults(); virtual boolProvidesError() const; virtual boolROOT::Math::Minimizer::Scan(unsigned int, unsigned int&, double*, doubl",MatchSource.WIKI,root/html532/ROOT__Math__GeneticMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GeneticMinimizer.html
https://root.cern/root/html532/ROOT__Math__GeneticMinimizer.html:896,Availability,Error,Errors,896," virtual~GeneticMinimizer(); virtual voidClear(); virtual boolROOT::Math::Minimizer::Contour(unsigned int, unsigned int, unsigned int&, double*, double*); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int i, unsigned int j) const; virtual intROOT::Math::Minimizer::CovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; ROOT::Math::GeneticMinimizerGeneticMinimizer(int = 0); virtual boolROOT::Math::Minimizer::GetCovMatrix(double*) const; virtual boolROOT::Math::Minimizer::GetHessianMatrix(double*) const; virtual boolROOT::Math::Minimizer::GetMinosError(unsigned int, double& errLow, double& errUp, int = 0); virtual doubleROOT::Math::Minimizer::GlobalCC(unsigned int) const; virtual boolROOT::Math::Minimizer::Hesse(); boolROOT::Math::Minimizer::IsValidError() const; unsigned intROOT::Math::Minimizer::MaxFunctionCalls() const; unsigned intROOT::Math::Minimizer::MaxIterations() const; virtual const double*MinGradient() const; virtual boolMinimize(); virtual doubleMinValue() const; virtual unsigned intNCalls() const; virtual unsigned intNDim() const; virtual unsigned intNFree() const; virtual ROOT::Math::MinimizerOptionsOptions() const; doubleROOT::Math::Minimizer::Precision() const; intROOT::Math::Minimizer::PrintLevel() const; virtual voidROOT::Math::Minimizer::PrintResults(); virtual boolProvidesError() const; virtual boolROOT::Math::Minimizer::Scan(unsigned int, unsigned int&, double*, doubl",MatchSource.WIKI,root/html532/ROOT__Math__GeneticMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GeneticMinimizer.html
https://root.cern/root/html532/ROOT__Math__GeneticMinimizer.html:3550,Availability,Toler,Tolerance,3550,"ubleROOT::Math::Minimizer::Precision() const; intROOT::Math::Minimizer::PrintLevel() const; virtual voidROOT::Math::Minimizer::PrintResults(); virtual boolProvidesError() const; virtual boolROOT::Math::Minimizer::Scan(unsigned int, unsigned int&, double*, double*, double = 0, double = 0); voidROOT::Math::Minimizer::SetDefaultOptions(); voidROOT::Math::Minimizer::SetErrorDef(double up); virtual boolROOT::Math::Minimizer::SetFixedVariable(unsigned int, const string&, double); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& func); virtual boolSetLimitedVariable(unsigned int, const string&, double, double, double, double); virtual boolROOT::Math::Minimizer::SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); voidROOT::Math::Minimizer::SetMaxFunctionCalls(unsigned int maxfcn); voidROOT::Math::Minimizer::SetMaxIterations(unsigned int maxiter); virtual voidSetOptions(const ROOT::Math::MinimizerOptions& opt); voidSetParameters(const ROOT::Math::GeneticMinimizerParameters& params); voidROOT::Math::Minimizer::SetPrecision(double prec); voidROOT::Math::Minimizer::SetPrintLevel(int level); voidROOT::Math::Minimizer::SetStrategy(int strategyLevel); voidROOT::Math::Minimizer::SetTolerance(double tol); virtual boolROOT::Math::Minimizer::SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); voidROOT::Math::Minimizer::SetValidError(bool on); virtual boolSetVariable(unsigned int ivar, const string& name, double val, double step); virtual boolROOT::Math::Minimizer::SetVariableValue(unsigned int, double); virtual boolROOT::Math::Minimizer::SetVariableValues(const double* x); intROOT::Math::Minimizer::Status() const; intROOT::Math::Minimizer::Strategy() const; doubleROOT::Math::Minimizer::Tolerance() const; virtual intROOT::Math::Minimizer::VariableIndex(const string&) const; virtual stringROOT::Math::Minimizer::VariableName(unsigned int) const; virtual const double*X() const.",MatchSource.WIKI,root/html532/ROOT__Math__GeneticMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GeneticMinimizer.html
https://root.cern/root/html532/ROOT__Math__GeneticMinimizer.html:4507,Availability,error,errors,4507,"boolSetVariable(unsigned int ivar, const string& name, double val, double step); virtual boolROOT::Math::Minimizer::SetVariableValue(unsigned int, double); virtual boolROOT::Math::Minimizer::SetVariableValues(const double* x); intROOT::Math::Minimizer::Status() const; intROOT::Math::Minimizer::Strategy() const; doubleROOT::Math::Minimizer::Tolerance() const; virtual intROOT::Math::Minimizer::VariableIndex(const string&) const; virtual stringROOT::Math::Minimizer::VariableName(unsigned int) const; virtual const double*X() const. protected:. voidGetGeneticOptions(ROOT::Math::MinimizerOptions& opt) const. Data Members; protected:. intROOT::Math::Minimizer::fDebugprint level; TMVA::IFitterTarget*fFitness; unsigned intROOT::Math::Minimizer::fMaxCallsmax number of function calls ; unsigned intROOT::Math::Minimizer::fMaxItermax number or iterations used to find the minimum; ROOT::Math::GeneticMinimizerParametersfParameters; doubleROOT::Math::Minimizer::fPrecprecision; vector<TMVA::Interval*>fRanges; vector<double>fResult; intROOT::Math::Minimizer::fStatusstatus of minimizer ; intROOT::Math::Minimizer::fStrategyminimizer strategy; doubleROOT::Math::Minimizer::fToltolerance (absolute); doubleROOT::Math::Minimizer::fUperror scale ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GeneticMinimizer(int = 0). virtual ~GeneticMinimizer(). void Clear(). void SetFunction(const ROOT::Math::IMultiGenFunction& func). bool SetLimitedVariable(unsigned int , const string& , double , double , double , double ). bool SetVariable(unsigned int ivar, const string& name, double val, double step). bool Minimize(). double MinValue() const. double Edm() const. const double * X() const. const double * MinGradient() const. unsigned int NCalls() const. unsigned int NDim() const. unsigned int NFree() const. bool ProvidesError() const. co",MatchSource.WIKI,root/html532/ROOT__Math__GeneticMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GeneticMinimizer.html
https://root.cern/root/html532/ROOT__Math__GeneticMinimizer.html:5221,Availability,Error,Errors,5221,"al const double*X() const. protected:. voidGetGeneticOptions(ROOT::Math::MinimizerOptions& opt) const. Data Members; protected:. intROOT::Math::Minimizer::fDebugprint level; TMVA::IFitterTarget*fFitness; unsigned intROOT::Math::Minimizer::fMaxCallsmax number of function calls ; unsigned intROOT::Math::Minimizer::fMaxItermax number or iterations used to find the minimum; ROOT::Math::GeneticMinimizerParametersfParameters; doubleROOT::Math::Minimizer::fPrecprecision; vector<TMVA::Interval*>fRanges; vector<double>fResult; intROOT::Math::Minimizer::fStatusstatus of minimizer ; intROOT::Math::Minimizer::fStrategyminimizer strategy; doubleROOT::Math::Minimizer::fToltolerance (absolute); doubleROOT::Math::Minimizer::fUperror scale ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GeneticMinimizer(int = 0). virtual ~GeneticMinimizer(). void Clear(). void SetFunction(const ROOT::Math::IMultiGenFunction& func). bool SetLimitedVariable(unsigned int , const string& , double , double , double , double ). bool SetVariable(unsigned int ivar, const string& name, double val, double step). bool Minimize(). double MinValue() const. double Edm() const. const double * X() const. const double * MinGradient() const. unsigned int NCalls() const. unsigned int NDim() const. unsigned int NFree() const. bool ProvidesError() const. const double * Errors() const. double CovMatrix(unsigned int i, unsigned int j) const. void SetParameters(const ROOT::Math::GeneticMinimizerParameters& params). void SetOptions(const ROOT::Math::MinimizerOptions& opt). void GetGeneticOptions(ROOT::Math::MinimizerOptions& opt) const.  Last changed: root/mathcore:$Id  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__GeneticMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GeneticMinimizer.html
https://root.cern/root/html532/ROOT__Math__GeneticMinimizer.html:3603,Modifiability,Variab,VariableIndex,3603,"ubleROOT::Math::Minimizer::Precision() const; intROOT::Math::Minimizer::PrintLevel() const; virtual voidROOT::Math::Minimizer::PrintResults(); virtual boolProvidesError() const; virtual boolROOT::Math::Minimizer::Scan(unsigned int, unsigned int&, double*, double*, double = 0, double = 0); voidROOT::Math::Minimizer::SetDefaultOptions(); voidROOT::Math::Minimizer::SetErrorDef(double up); virtual boolROOT::Math::Minimizer::SetFixedVariable(unsigned int, const string&, double); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& func); virtual boolSetLimitedVariable(unsigned int, const string&, double, double, double, double); virtual boolROOT::Math::Minimizer::SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); voidROOT::Math::Minimizer::SetMaxFunctionCalls(unsigned int maxfcn); voidROOT::Math::Minimizer::SetMaxIterations(unsigned int maxiter); virtual voidSetOptions(const ROOT::Math::MinimizerOptions& opt); voidSetParameters(const ROOT::Math::GeneticMinimizerParameters& params); voidROOT::Math::Minimizer::SetPrecision(double prec); voidROOT::Math::Minimizer::SetPrintLevel(int level); voidROOT::Math::Minimizer::SetStrategy(int strategyLevel); voidROOT::Math::Minimizer::SetTolerance(double tol); virtual boolROOT::Math::Minimizer::SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); voidROOT::Math::Minimizer::SetValidError(bool on); virtual boolSetVariable(unsigned int ivar, const string& name, double val, double step); virtual boolROOT::Math::Minimizer::SetVariableValue(unsigned int, double); virtual boolROOT::Math::Minimizer::SetVariableValues(const double* x); intROOT::Math::Minimizer::Status() const; intROOT::Math::Minimizer::Strategy() const; doubleROOT::Math::Minimizer::Tolerance() const; virtual intROOT::Math::Minimizer::VariableIndex(const string&) const; virtual stringROOT::Math::Minimizer::VariableName(unsigned int) const; virtual const double*X() const.",MatchSource.WIKI,root/html532/ROOT__Math__GeneticMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GeneticMinimizer.html
https://root.cern/root/html532/ROOT__Math__GeneticMinimizer.html:3676,Modifiability,Variab,VariableName,3676,"ubleROOT::Math::Minimizer::Precision() const; intROOT::Math::Minimizer::PrintLevel() const; virtual voidROOT::Math::Minimizer::PrintResults(); virtual boolProvidesError() const; virtual boolROOT::Math::Minimizer::Scan(unsigned int, unsigned int&, double*, double*, double = 0, double = 0); voidROOT::Math::Minimizer::SetDefaultOptions(); voidROOT::Math::Minimizer::SetErrorDef(double up); virtual boolROOT::Math::Minimizer::SetFixedVariable(unsigned int, const string&, double); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& func); virtual boolSetLimitedVariable(unsigned int, const string&, double, double, double, double); virtual boolROOT::Math::Minimizer::SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); voidROOT::Math::Minimizer::SetMaxFunctionCalls(unsigned int maxfcn); voidROOT::Math::Minimizer::SetMaxIterations(unsigned int maxiter); virtual voidSetOptions(const ROOT::Math::MinimizerOptions& opt); voidSetParameters(const ROOT::Math::GeneticMinimizerParameters& params); voidROOT::Math::Minimizer::SetPrecision(double prec); voidROOT::Math::Minimizer::SetPrintLevel(int level); voidROOT::Math::Minimizer::SetStrategy(int strategyLevel); voidROOT::Math::Minimizer::SetTolerance(double tol); virtual boolROOT::Math::Minimizer::SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); voidROOT::Math::Minimizer::SetValidError(bool on); virtual boolSetVariable(unsigned int ivar, const string& name, double val, double step); virtual boolROOT::Math::Minimizer::SetVariableValue(unsigned int, double); virtual boolROOT::Math::Minimizer::SetVariableValues(const double* x); intROOT::Math::Minimizer::Status() const; intROOT::Math::Minimizer::Strategy() const; doubleROOT::Math::Minimizer::Tolerance() const; virtual intROOT::Math::Minimizer::VariableIndex(const string&) const; virtual stringROOT::Math::Minimizer::VariableName(unsigned int) const; virtual const double*X() const.",MatchSource.WIKI,root/html532/ROOT__Math__GeneticMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GeneticMinimizer.html
https://root.cern/root/html532/ROOT__Math__GeneticMinimizer.html:4588,Modifiability,Inherit,Inheritance,4588,"dex(const string&) const; virtual stringROOT::Math::Minimizer::VariableName(unsigned int) const; virtual const double*X() const. protected:. voidGetGeneticOptions(ROOT::Math::MinimizerOptions& opt) const. Data Members; protected:. intROOT::Math::Minimizer::fDebugprint level; TMVA::IFitterTarget*fFitness; unsigned intROOT::Math::Minimizer::fMaxCallsmax number of function calls ; unsigned intROOT::Math::Minimizer::fMaxItermax number or iterations used to find the minimum; ROOT::Math::GeneticMinimizerParametersfParameters; doubleROOT::Math::Minimizer::fPrecprecision; vector<TMVA::Interval*>fRanges; vector<double>fResult; intROOT::Math::Minimizer::fStatusstatus of minimizer ; intROOT::Math::Minimizer::fStrategyminimizer strategy; doubleROOT::Math::Minimizer::fToltolerance (absolute); doubleROOT::Math::Minimizer::fUperror scale ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GeneticMinimizer(int = 0). virtual ~GeneticMinimizer(). void Clear(). void SetFunction(const ROOT::Math::IMultiGenFunction& func). bool SetLimitedVariable(unsigned int , const string& , double , double , double , double ). bool SetVariable(unsigned int ivar, const string& name, double val, double step). bool Minimize(). double MinValue() const. double Edm() const. const double * X() const. const double * MinGradient() const. unsigned int NCalls() const. unsigned int NDim() const. unsigned int NFree() const. bool ProvidesError() const. const double * Errors() const. double CovMatrix(unsigned int i, unsigned int j) const. void SetParameters(const ROOT::Math::GeneticMinimizerParameters& params). void SetOptions(const ROOT::Math::MinimizerOptions& opt). void GetGeneticOptions(ROOT::Math::MinimizerOptions& opt) const.  Last changed: root/mathcore:$Id  Last generated: 2011-11-03 20:04; This page has been automatically generated. For commen",MatchSource.WIKI,root/html532/ROOT__Math__GeneticMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GeneticMinimizer.html
https://root.cern/root/html532/ROOT__Math__GeneticMinimizer.html:4601,Modifiability,Inherit,Inherited,4601,"dex(const string&) const; virtual stringROOT::Math::Minimizer::VariableName(unsigned int) const; virtual const double*X() const. protected:. voidGetGeneticOptions(ROOT::Math::MinimizerOptions& opt) const. Data Members; protected:. intROOT::Math::Minimizer::fDebugprint level; TMVA::IFitterTarget*fFitness; unsigned intROOT::Math::Minimizer::fMaxCallsmax number of function calls ; unsigned intROOT::Math::Minimizer::fMaxItermax number or iterations used to find the minimum; ROOT::Math::GeneticMinimizerParametersfParameters; doubleROOT::Math::Minimizer::fPrecprecision; vector<TMVA::Interval*>fRanges; vector<double>fResult; intROOT::Math::Minimizer::fStatusstatus of minimizer ; intROOT::Math::Minimizer::fStrategyminimizer strategy; doubleROOT::Math::Minimizer::fToltolerance (absolute); doubleROOT::Math::Minimizer::fUperror scale ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GeneticMinimizer(int = 0). virtual ~GeneticMinimizer(). void Clear(). void SetFunction(const ROOT::Math::IMultiGenFunction& func). bool SetLimitedVariable(unsigned int , const string& , double , double , double , double ). bool SetVariable(unsigned int ivar, const string& name, double val, double step). bool Minimize(). double MinValue() const. double Edm() const. const double * X() const. const double * MinGradient() const. unsigned int NCalls() const. unsigned int NDim() const. unsigned int NFree() const. bool ProvidesError() const. const double * Errors() const. double CovMatrix(unsigned int i, unsigned int j) const. void SetParameters(const ROOT::Math::GeneticMinimizerParameters& params). void SetOptions(const ROOT::Math::MinimizerOptions& opt). void GetGeneticOptions(ROOT::Math::MinimizerOptions& opt) const.  Last changed: root/mathcore:$Id  Last generated: 2011-11-03 20:04; This page has been automatically generated. For commen",MatchSource.WIKI,root/html532/ROOT__Math__GeneticMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GeneticMinimizer.html
https://root.cern/root/html532/ROOT__Math__GeneticMinimizer.html:4524,Security,validat,validated,4524,"boolSetVariable(unsigned int ivar, const string& name, double val, double step); virtual boolROOT::Math::Minimizer::SetVariableValue(unsigned int, double); virtual boolROOT::Math::Minimizer::SetVariableValues(const double* x); intROOT::Math::Minimizer::Status() const; intROOT::Math::Minimizer::Strategy() const; doubleROOT::Math::Minimizer::Tolerance() const; virtual intROOT::Math::Minimizer::VariableIndex(const string&) const; virtual stringROOT::Math::Minimizer::VariableName(unsigned int) const; virtual const double*X() const. protected:. voidGetGeneticOptions(ROOT::Math::MinimizerOptions& opt) const. Data Members; protected:. intROOT::Math::Minimizer::fDebugprint level; TMVA::IFitterTarget*fFitness; unsigned intROOT::Math::Minimizer::fMaxCallsmax number of function calls ; unsigned intROOT::Math::Minimizer::fMaxItermax number or iterations used to find the minimum; ROOT::Math::GeneticMinimizerParametersfParameters; doubleROOT::Math::Minimizer::fPrecprecision; vector<TMVA::Interval*>fRanges; vector<double>fResult; intROOT::Math::Minimizer::fStatusstatus of minimizer ; intROOT::Math::Minimizer::fStrategyminimizer strategy; doubleROOT::Math::Minimizer::fToltolerance (absolute); doubleROOT::Math::Minimizer::fUperror scale ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GeneticMinimizer(int = 0). virtual ~GeneticMinimizer(). void Clear(). void SetFunction(const ROOT::Math::IMultiGenFunction& func). bool SetLimitedVariable(unsigned int , const string& , double , double , double , double ). bool SetVariable(unsigned int ivar, const string& name, double val, double step). bool Minimize(). double MinValue() const. double Edm() const. const double * X() const. const double * MinGradient() const. unsigned int NCalls() const. unsigned int NDim() const. unsigned int NFree() const. bool ProvidesError() const. co",MatchSource.WIKI,root/html532/ROOT__Math__GeneticMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GeneticMinimizer.html
https://root.cern/root/html532/ROOT__Math__GeneticMinimizer.html:4726,Usability,Clear,Clear,4726,"al const double*X() const. protected:. voidGetGeneticOptions(ROOT::Math::MinimizerOptions& opt) const. Data Members; protected:. intROOT::Math::Minimizer::fDebugprint level; TMVA::IFitterTarget*fFitness; unsigned intROOT::Math::Minimizer::fMaxCallsmax number of function calls ; unsigned intROOT::Math::Minimizer::fMaxItermax number or iterations used to find the minimum; ROOT::Math::GeneticMinimizerParametersfParameters; doubleROOT::Math::Minimizer::fPrecprecision; vector<TMVA::Interval*>fRanges; vector<double>fResult; intROOT::Math::Minimizer::fStatusstatus of minimizer ; intROOT::Math::Minimizer::fStrategyminimizer strategy; doubleROOT::Math::Minimizer::fToltolerance (absolute); doubleROOT::Math::Minimizer::fUperror scale ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GeneticMinimizer(int = 0). virtual ~GeneticMinimizer(). void Clear(). void SetFunction(const ROOT::Math::IMultiGenFunction& func). bool SetLimitedVariable(unsigned int , const string& , double , double , double , double ). bool SetVariable(unsigned int ivar, const string& name, double val, double step). bool Minimize(). double MinValue() const. double Edm() const. const double * X() const. const double * MinGradient() const. unsigned int NCalls() const. unsigned int NDim() const. unsigned int NFree() const. bool ProvidesError() const. const double * Errors() const. double CovMatrix(unsigned int i, unsigned int j) const. void SetParameters(const ROOT::Math::GeneticMinimizerParameters& params). void SetOptions(const ROOT::Math::MinimizerOptions& opt). void GetGeneticOptions(ROOT::Math::MinimizerOptions& opt) const.  Last changed: root/mathcore:$Id  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__GeneticMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GeneticMinimizer.html
https://root.cern/root/html532/ROOT__Math__GeneticMinimizerParameters.html:896,Modifiability,Inherit,Inheritance,896,. ROOT::Math::GeneticMinimizerParameters. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  GENETIC;  ROOT::Math::GeneticMinimizerParameters. class ROOT::Math::GeneticMinimizerParameters. structure containing the parameters of the genetic minimizer. Function Members (Methods); public:. ~GeneticMinimizerParameters(); ROOT::Math::GeneticMinimizerParametersGeneticMinimizerParameters(); ROOT::Math::GeneticMinimizerParametersGeneticMinimizerParameters(const ROOT::Math::GeneticMinimizerParameters&); ROOT::Math::GeneticMinimizerParameters&operator=(const ROOT::Math::GeneticMinimizerParameters&). Data Members; public:. Double_tfConvCrit; Int_tfCycles; Int_tfNsteps; Int_tfPopSize; Double_tfSC_factor; Int_tfSC_rate; Int_tfSC_steps. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GeneticMinimizerParameters(); constructor with default value.  Last changed: root/mathcore:$Id  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ,MatchSource.WIKI,root/html532/ROOT__Math__GeneticMinimizerParameters.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GeneticMinimizerParameters.html
https://root.cern/root/html532/ROOT__Math__GeneticMinimizerParameters.html:909,Modifiability,Inherit,Inherited,909,. ROOT::Math::GeneticMinimizerParameters. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  GENETIC;  ROOT::Math::GeneticMinimizerParameters. class ROOT::Math::GeneticMinimizerParameters. structure containing the parameters of the genetic minimizer. Function Members (Methods); public:. ~GeneticMinimizerParameters(); ROOT::Math::GeneticMinimizerParametersGeneticMinimizerParameters(); ROOT::Math::GeneticMinimizerParametersGeneticMinimizerParameters(const ROOT::Math::GeneticMinimizerParameters&); ROOT::Math::GeneticMinimizerParameters&operator=(const ROOT::Math::GeneticMinimizerParameters&). Data Members; public:. Double_tfConvCrit; Int_tfCycles; Int_tfNsteps; Int_tfPopSize; Double_tfSC_factor; Int_tfSC_rate; Int_tfSC_steps. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GeneticMinimizerParameters(); constructor with default value.  Last changed: root/mathcore:$Id  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ,MatchSource.WIKI,root/html532/ROOT__Math__GeneticMinimizerParameters.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GeneticMinimizerParameters.html
https://root.cern/root/html532/ROOT__Math__GlobalCoordinateSystemTag.html:1362,Modifiability,Inherit,Inheritance,1362,". ROOT::Math::GlobalCoordinateSystemTag. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  GENVECTOR;  ROOT::Math::GlobalCoordinateSystemTag. class ROOT::Math::GlobalCoordinateSystemTag. DefaultCoordinateSystemTag; Default tag for identifying any coordinate system. @ingroup GenVector. This class is also known as (typedefs to this class)ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::CoordinateSystemTag, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::CoordinateSystemTag, ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::CoordinateSystemTag, ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::CoordinateSystemTag. Function Members (Methods); public:. ~GlobalCoordinateSystemTag(); ROOT::Math::GlobalCoordinateSystemTagGlobalCoordinateSystemTag(); ROOT::Math::GlobalCoordinateSystemTagGlobalCoordinateSystemTag(const ROOT::Math::GlobalCoordinateSystemTag&); ROOT::Math::GlobalCoordinateSystemTag&operator=(const ROOT::Math::GlobalCoordinateSystemTag&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation.  Last changed: root/mathcore:$Id: CoordinateSystemTags.h 22516 2008-03-07 15:14:26Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__GlobalCoordinateSystemTag.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GlobalCoordinateSystemTag.html
https://root.cern/root/html532/ROOT__Math__GlobalCoordinateSystemTag.html:1375,Modifiability,Inherit,Inherited,1375,". ROOT::Math::GlobalCoordinateSystemTag. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  GENVECTOR;  ROOT::Math::GlobalCoordinateSystemTag. class ROOT::Math::GlobalCoordinateSystemTag. DefaultCoordinateSystemTag; Default tag for identifying any coordinate system. @ingroup GenVector. This class is also known as (typedefs to this class)ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::CoordinateSystemTag, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::CoordinateSystemTag, ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::CoordinateSystemTag, ROOT::Math::PositionVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::CoordinateSystemTag. Function Members (Methods); public:. ~GlobalCoordinateSystemTag(); ROOT::Math::GlobalCoordinateSystemTagGlobalCoordinateSystemTag(); ROOT::Math::GlobalCoordinateSystemTagGlobalCoordinateSystemTag(const ROOT::Math::GlobalCoordinateSystemTag&); ROOT::Math::GlobalCoordinateSystemTag&operator=(const ROOT::Math::GlobalCoordinateSystemTag&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation.  Last changed: root/mathcore:$Id: CoordinateSystemTags.h 22516 2008-03-07 15:14:26Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__GlobalCoordinateSystemTag.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GlobalCoordinateSystemTag.html
https://root.cern/root/html532/ROOT__Math__GoFTest.html:4117,Integrability,interface,interface,4117,"Math::GoFTest::EDistributionfDist; Double_tfMean; vector<std::vector<Double_t> >fSamples; Double_tfSigma; Bool_tfTestSampleFromH0. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GoFTest(UInt_t sample1Size, const Double_t* sample1, UInt_t sample2Size, const Double_t* sample2); Constructor for using only with 2-samples tests. GoFTest(UInt_t sampleSize, const Double_t* sample, ROOT::Math::GoFTest::EDistribution dist = kUndefined); Constructor for using only with 1-sample tests with a specified distribution. GoFTest(UInt_t sampleSize, const Double_t* sample, const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); Templated constructor for using only with 1-sample tests with a user specified distribution. Instantiate(const Double_t* sample, UInt_t sampleSize). GoFTest(UInt_t sampleSize, const Double_t* sample, const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); Specialization using IGenFunction interface. SetUserDistribution(const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0). SetDistributionFunction(const ROOT::Math::IGenFunction& cdf, Bool_t isPDF, Double_t xmin, Double_t xmax). void SetUserPDF(const ROOT::Math::IGenFunction& pdf, Double_t xmin = 1, Double_t xmax = 0); Sets the user input distribution as a probability density function for 1-sample tests. void SetUserCDF(const ROOT::Math::IGenFunction& cdf, Double_t xmin = 1, Double_t xmax = 0); Sets the user input distribution as a cumulative distribution function for 1-sample tests; The CDF must return zero. void SetDistribution(ROOT::Math::GoFTest::EDistribution dist); Sets the distribution for the predefined distribution types. virtual ~GoFTest(). Double_t AndersonDarling2SamplesTest(const Char_t* option = ""p"") const. The Anderson-Darling K",MatchSource.WIKI,root/html532/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GoFTest.html
https://root.cern/root/html532/ROOT__Math__GoFTest.html:3157,Modifiability,Inherit,Inheritance,3157,"ble_t* sample, UInt_t sampleSize); Double_tInterpolatePValues(Double_t dA2, Int_t bin) const; Double_tLogNormalCDF(Double_t x) const; voidLogSample(); ROOT::Math::GoFTestoperator=(ROOT::Math::GoFTest& gof); Double_tPValueAD1Sample(Double_t A2) const; Double_tPValueAD2Samples(Double_t& A2, UInt_t N) const; voidSetCDF(); voidSetDistributionFunction(const ROOT::Math::IGenFunction& cdf, Bool_t isPDF, Double_t xmin, Double_t xmax); voidSetParameters(); voidSetSamples(vector<const Double_t*> samples, const vector<UInt_t> samplesSizes). Data Members; public:. enum EDistribution { kUndefined; kUserDefined; kGaussian; kLogNormal; kExponential; };; enum EUserDistribution { kCDF; kPDF; };; enum ETestType { kAD; kAD2s; kKS; kKS2s; };. private:. auto_ptr<ROOT::Math::IBaseFunctionOneDim>fCDF; vector<Double_t>fCombinedSamples; ROOT::Math::GoFTest::EDistributionfDist; Double_tfMean; vector<std::vector<Double_t> >fSamples; Double_tfSigma; Bool_tfTestSampleFromH0. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GoFTest(UInt_t sample1Size, const Double_t* sample1, UInt_t sample2Size, const Double_t* sample2); Constructor for using only with 2-samples tests. GoFTest(UInt_t sampleSize, const Double_t* sample, ROOT::Math::GoFTest::EDistribution dist = kUndefined); Constructor for using only with 1-sample tests with a specified distribution. GoFTest(UInt_t sampleSize, const Double_t* sample, const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); Templated constructor for using only with 1-sample tests with a user specified distribution. Instantiate(const Double_t* sample, UInt_t sampleSize). GoFTest(UInt_t sampleSize, const Double_t* sample, const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); Specialization using IGenFunction interface. SetUserDistribution(const ROOT::Math::IGenFunction& dis",MatchSource.WIKI,root/html532/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GoFTest.html
https://root.cern/root/html532/ROOT__Math__GoFTest.html:3170,Modifiability,Inherit,Inherited,3170,"ble_t* sample, UInt_t sampleSize); Double_tInterpolatePValues(Double_t dA2, Int_t bin) const; Double_tLogNormalCDF(Double_t x) const; voidLogSample(); ROOT::Math::GoFTestoperator=(ROOT::Math::GoFTest& gof); Double_tPValueAD1Sample(Double_t A2) const; Double_tPValueAD2Samples(Double_t& A2, UInt_t N) const; voidSetCDF(); voidSetDistributionFunction(const ROOT::Math::IGenFunction& cdf, Bool_t isPDF, Double_t xmin, Double_t xmax); voidSetParameters(); voidSetSamples(vector<const Double_t*> samples, const vector<UInt_t> samplesSizes). Data Members; public:. enum EDistribution { kUndefined; kUserDefined; kGaussian; kLogNormal; kExponential; };; enum EUserDistribution { kCDF; kPDF; };; enum ETestType { kAD; kAD2s; kKS; kKS2s; };. private:. auto_ptr<ROOT::Math::IBaseFunctionOneDim>fCDF; vector<Double_t>fCombinedSamples; ROOT::Math::GoFTest::EDistributionfDist; Double_tfMean; vector<std::vector<Double_t> >fSamples; Double_tfSigma; Bool_tfTestSampleFromH0. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GoFTest(UInt_t sample1Size, const Double_t* sample1, UInt_t sample2Size, const Double_t* sample2); Constructor for using only with 2-samples tests. GoFTest(UInt_t sampleSize, const Double_t* sample, ROOT::Math::GoFTest::EDistribution dist = kUndefined); Constructor for using only with 1-sample tests with a specified distribution. GoFTest(UInt_t sampleSize, const Double_t* sample, const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); Templated constructor for using only with 1-sample tests with a user specified distribution. Instantiate(const Double_t* sample, UInt_t sampleSize). GoFTest(UInt_t sampleSize, const Double_t* sample, const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); Specialization using IGenFunction interface. SetUserDistribution(const ROOT::Math::IGenFunction& dis",MatchSource.WIKI,root/html532/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GoFTest.html
https://root.cern/root/html532/ROOT__Math__GoFTest.html:469,Testability,test,testStat,469,"ctions:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::GoFTest. class ROOT::Math::GoFTest. Function Members (Methods); public:. virtual~GoFTest(); Double_tAndersonDarling2SamplesTest(const Char_t* option = ""p"") const; voidAndersonDarling2SamplesTest(Double_t& pvalue, Double_t& testStat) const; Double_tAndersonDarlingTest(const Char_t* option = ""p"") const; voidAndersonDarlingTest(Double_t& pvalue, Double_t& testStat) const; ROOT::Math::GoFTestGoFTest(UInt_t sampleSize, const Double_t* sample, ROOT::Math::GoFTest::EDistribution dist = kUndefined); ROOT::Math::GoFTestGoFTest(UInt_t sample1Size, const Double_t* sample1, UInt_t sample2Size, const Double_t* sample2); ROOT::Math::GoFTestGoFTest(UInt_t sampleSize, const Double_t* sample, const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); Double_tKolmogorovSmirnov2SamplesTest(const Char_t* option = ""p"") const; voidKolmogorovSmirnov2SamplesTest(Double_t& pvalue, Double_t& testStat) const; Double_tKolmogorovSmirnovTest(const Char_t* option = ""p"") const; voidKolmogorovSmirnovTest(Double_t& pvalue, Double_t& testStat) const; Double_toperator()(ROOT::Math::GoFTest::ETestType test = kAD, const Char_t* option = ""p"") const; voidoperator()(ROOT::Math::GoFTest::ETestType test, Double_t& pvalue, Double_t& testStat) const; voidSetDistribution(ROOT::Math::GoFTest::EDistribution dist); voidSetUserCDF(const ROOT::Math::IGenFunction& cdf, Double_t xmin = 1, Double_t xmax = 0); voidSetUserDistribution(const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); voidSetUserPDF(const ROOT::Math::IGenFunction& pdf, Double_t xmin = 1, Double_t xmax = 0). private:. Double_tExponentialCDF(Double_t x) const; Double_tGaussianCDF(Double_t x) const; Double_tGetSigmaN(UInt_t N) const; ROOT::Math::GoFTestGoFTest(); ROOT::Math::GoFTestGoFTest(RO",MatchSource.WIKI,root/html532/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GoFTest.html
https://root.cern/root/html532/ROOT__Math__GoFTest.html:601,Testability,test,testStat,601,"ctions:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::GoFTest. class ROOT::Math::GoFTest. Function Members (Methods); public:. virtual~GoFTest(); Double_tAndersonDarling2SamplesTest(const Char_t* option = ""p"") const; voidAndersonDarling2SamplesTest(Double_t& pvalue, Double_t& testStat) const; Double_tAndersonDarlingTest(const Char_t* option = ""p"") const; voidAndersonDarlingTest(Double_t& pvalue, Double_t& testStat) const; ROOT::Math::GoFTestGoFTest(UInt_t sampleSize, const Double_t* sample, ROOT::Math::GoFTest::EDistribution dist = kUndefined); ROOT::Math::GoFTestGoFTest(UInt_t sample1Size, const Double_t* sample1, UInt_t sample2Size, const Double_t* sample2); ROOT::Math::GoFTestGoFTest(UInt_t sampleSize, const Double_t* sample, const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); Double_tKolmogorovSmirnov2SamplesTest(const Char_t* option = ""p"") const; voidKolmogorovSmirnov2SamplesTest(Double_t& pvalue, Double_t& testStat) const; Double_tKolmogorovSmirnovTest(const Char_t* option = ""p"") const; voidKolmogorovSmirnovTest(Double_t& pvalue, Double_t& testStat) const; Double_toperator()(ROOT::Math::GoFTest::ETestType test = kAD, const Char_t* option = ""p"") const; voidoperator()(ROOT::Math::GoFTest::ETestType test, Double_t& pvalue, Double_t& testStat) const; voidSetDistribution(ROOT::Math::GoFTest::EDistribution dist); voidSetUserCDF(const ROOT::Math::IGenFunction& cdf, Double_t xmin = 1, Double_t xmax = 0); voidSetUserDistribution(const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); voidSetUserPDF(const ROOT::Math::IGenFunction& pdf, Double_t xmin = 1, Double_t xmax = 0). private:. Double_tExponentialCDF(Double_t x) const; Double_tGaussianCDF(Double_t x) const; Double_tGetSigmaN(UInt_t N) const; ROOT::Math::GoFTestGoFTest(); ROOT::Math::GoFTestGoFTest(RO",MatchSource.WIKI,root/html532/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GoFTest.html
https://root.cern/root/html532/ROOT__Math__GoFTest.html:1199,Testability,test,testStat,1199,"ctions:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::GoFTest. class ROOT::Math::GoFTest. Function Members (Methods); public:. virtual~GoFTest(); Double_tAndersonDarling2SamplesTest(const Char_t* option = ""p"") const; voidAndersonDarling2SamplesTest(Double_t& pvalue, Double_t& testStat) const; Double_tAndersonDarlingTest(const Char_t* option = ""p"") const; voidAndersonDarlingTest(Double_t& pvalue, Double_t& testStat) const; ROOT::Math::GoFTestGoFTest(UInt_t sampleSize, const Double_t* sample, ROOT::Math::GoFTest::EDistribution dist = kUndefined); ROOT::Math::GoFTestGoFTest(UInt_t sample1Size, const Double_t* sample1, UInt_t sample2Size, const Double_t* sample2); ROOT::Math::GoFTestGoFTest(UInt_t sampleSize, const Double_t* sample, const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); Double_tKolmogorovSmirnov2SamplesTest(const Char_t* option = ""p"") const; voidKolmogorovSmirnov2SamplesTest(Double_t& pvalue, Double_t& testStat) const; Double_tKolmogorovSmirnovTest(const Char_t* option = ""p"") const; voidKolmogorovSmirnovTest(Double_t& pvalue, Double_t& testStat) const; Double_toperator()(ROOT::Math::GoFTest::ETestType test = kAD, const Char_t* option = ""p"") const; voidoperator()(ROOT::Math::GoFTest::ETestType test, Double_t& pvalue, Double_t& testStat) const; voidSetDistribution(ROOT::Math::GoFTest::EDistribution dist); voidSetUserCDF(const ROOT::Math::IGenFunction& cdf, Double_t xmin = 1, Double_t xmax = 0); voidSetUserDistribution(const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); voidSetUserPDF(const ROOT::Math::IGenFunction& pdf, Double_t xmin = 1, Double_t xmax = 0). private:. Double_tExponentialCDF(Double_t x) const; Double_tGaussianCDF(Double_t x) const; Double_tGetSigmaN(UInt_t N) const; ROOT::Math::GoFTestGoFTest(); ROOT::Math::GoFTestGoFTest(RO",MatchSource.WIKI,root/html532/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GoFTest.html
https://root.cern/root/html532/ROOT__Math__GoFTest.html:1335,Testability,test,testStat,1335,"ctions:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::GoFTest. class ROOT::Math::GoFTest. Function Members (Methods); public:. virtual~GoFTest(); Double_tAndersonDarling2SamplesTest(const Char_t* option = ""p"") const; voidAndersonDarling2SamplesTest(Double_t& pvalue, Double_t& testStat) const; Double_tAndersonDarlingTest(const Char_t* option = ""p"") const; voidAndersonDarlingTest(Double_t& pvalue, Double_t& testStat) const; ROOT::Math::GoFTestGoFTest(UInt_t sampleSize, const Double_t* sample, ROOT::Math::GoFTest::EDistribution dist = kUndefined); ROOT::Math::GoFTestGoFTest(UInt_t sample1Size, const Double_t* sample1, UInt_t sample2Size, const Double_t* sample2); ROOT::Math::GoFTestGoFTest(UInt_t sampleSize, const Double_t* sample, const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); Double_tKolmogorovSmirnov2SamplesTest(const Char_t* option = ""p"") const; voidKolmogorovSmirnov2SamplesTest(Double_t& pvalue, Double_t& testStat) const; Double_tKolmogorovSmirnovTest(const Char_t* option = ""p"") const; voidKolmogorovSmirnovTest(Double_t& pvalue, Double_t& testStat) const; Double_toperator()(ROOT::Math::GoFTest::ETestType test = kAD, const Char_t* option = ""p"") const; voidoperator()(ROOT::Math::GoFTest::ETestType test, Double_t& pvalue, Double_t& testStat) const; voidSetDistribution(ROOT::Math::GoFTest::EDistribution dist); voidSetUserCDF(const ROOT::Math::IGenFunction& cdf, Double_t xmin = 1, Double_t xmax = 0); voidSetUserDistribution(const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); voidSetUserPDF(const ROOT::Math::IGenFunction& pdf, Double_t xmin = 1, Double_t xmax = 0). private:. Double_tExponentialCDF(Double_t x) const; Double_tGaussianCDF(Double_t x) const; Double_tGetSigmaN(UInt_t N) const; ROOT::Math::GoFTestGoFTest(); ROOT::Math::GoFTestGoFTest(RO",MatchSource.WIKI,root/html532/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GoFTest.html
https://root.cern/root/html532/ROOT__Math__GoFTest.html:1402,Testability,test,test,1402,"ctions:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::GoFTest. class ROOT::Math::GoFTest. Function Members (Methods); public:. virtual~GoFTest(); Double_tAndersonDarling2SamplesTest(const Char_t* option = ""p"") const; voidAndersonDarling2SamplesTest(Double_t& pvalue, Double_t& testStat) const; Double_tAndersonDarlingTest(const Char_t* option = ""p"") const; voidAndersonDarlingTest(Double_t& pvalue, Double_t& testStat) const; ROOT::Math::GoFTestGoFTest(UInt_t sampleSize, const Double_t* sample, ROOT::Math::GoFTest::EDistribution dist = kUndefined); ROOT::Math::GoFTestGoFTest(UInt_t sample1Size, const Double_t* sample1, UInt_t sample2Size, const Double_t* sample2); ROOT::Math::GoFTestGoFTest(UInt_t sampleSize, const Double_t* sample, const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); Double_tKolmogorovSmirnov2SamplesTest(const Char_t* option = ""p"") const; voidKolmogorovSmirnov2SamplesTest(Double_t& pvalue, Double_t& testStat) const; Double_tKolmogorovSmirnovTest(const Char_t* option = ""p"") const; voidKolmogorovSmirnovTest(Double_t& pvalue, Double_t& testStat) const; Double_toperator()(ROOT::Math::GoFTest::ETestType test = kAD, const Char_t* option = ""p"") const; voidoperator()(ROOT::Math::GoFTest::ETestType test, Double_t& pvalue, Double_t& testStat) const; voidSetDistribution(ROOT::Math::GoFTest::EDistribution dist); voidSetUserCDF(const ROOT::Math::IGenFunction& cdf, Double_t xmin = 1, Double_t xmax = 0); voidSetUserDistribution(const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); voidSetUserPDF(const ROOT::Math::IGenFunction& pdf, Double_t xmin = 1, Double_t xmax = 0). private:. Double_tExponentialCDF(Double_t x) const; Double_tGaussianCDF(Double_t x) const; Double_tGetSigmaN(UInt_t N) const; ROOT::Math::GoFTestGoFTest(); ROOT::Math::GoFTestGoFTest(RO",MatchSource.WIKI,root/html532/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GoFTest.html
https://root.cern/root/html532/ROOT__Math__GoFTest.html:1495,Testability,test,test,1495,"ctions:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::GoFTest. class ROOT::Math::GoFTest. Function Members (Methods); public:. virtual~GoFTest(); Double_tAndersonDarling2SamplesTest(const Char_t* option = ""p"") const; voidAndersonDarling2SamplesTest(Double_t& pvalue, Double_t& testStat) const; Double_tAndersonDarlingTest(const Char_t* option = ""p"") const; voidAndersonDarlingTest(Double_t& pvalue, Double_t& testStat) const; ROOT::Math::GoFTestGoFTest(UInt_t sampleSize, const Double_t* sample, ROOT::Math::GoFTest::EDistribution dist = kUndefined); ROOT::Math::GoFTestGoFTest(UInt_t sample1Size, const Double_t* sample1, UInt_t sample2Size, const Double_t* sample2); ROOT::Math::GoFTestGoFTest(UInt_t sampleSize, const Double_t* sample, const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); Double_tKolmogorovSmirnov2SamplesTest(const Char_t* option = ""p"") const; voidKolmogorovSmirnov2SamplesTest(Double_t& pvalue, Double_t& testStat) const; Double_tKolmogorovSmirnovTest(const Char_t* option = ""p"") const; voidKolmogorovSmirnovTest(Double_t& pvalue, Double_t& testStat) const; Double_toperator()(ROOT::Math::GoFTest::ETestType test = kAD, const Char_t* option = ""p"") const; voidoperator()(ROOT::Math::GoFTest::ETestType test, Double_t& pvalue, Double_t& testStat) const; voidSetDistribution(ROOT::Math::GoFTest::EDistribution dist); voidSetUserCDF(const ROOT::Math::IGenFunction& cdf, Double_t xmin = 1, Double_t xmax = 0); voidSetUserDistribution(const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); voidSetUserPDF(const ROOT::Math::IGenFunction& pdf, Double_t xmin = 1, Double_t xmax = 0). private:. Double_tExponentialCDF(Double_t x) const; Double_tGaussianCDF(Double_t x) const; Double_tGetSigmaN(UInt_t N) const; ROOT::Math::GoFTestGoFTest(); ROOT::Math::GoFTestGoFTest(RO",MatchSource.WIKI,root/html532/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GoFTest.html
https://root.cern/root/html532/ROOT__Math__GoFTest.html:1529,Testability,test,testStat,1529,"ctions:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::GoFTest. class ROOT::Math::GoFTest. Function Members (Methods); public:. virtual~GoFTest(); Double_tAndersonDarling2SamplesTest(const Char_t* option = ""p"") const; voidAndersonDarling2SamplesTest(Double_t& pvalue, Double_t& testStat) const; Double_tAndersonDarlingTest(const Char_t* option = ""p"") const; voidAndersonDarlingTest(Double_t& pvalue, Double_t& testStat) const; ROOT::Math::GoFTestGoFTest(UInt_t sampleSize, const Double_t* sample, ROOT::Math::GoFTest::EDistribution dist = kUndefined); ROOT::Math::GoFTestGoFTest(UInt_t sample1Size, const Double_t* sample1, UInt_t sample2Size, const Double_t* sample2); ROOT::Math::GoFTestGoFTest(UInt_t sampleSize, const Double_t* sample, const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); Double_tKolmogorovSmirnov2SamplesTest(const Char_t* option = ""p"") const; voidKolmogorovSmirnov2SamplesTest(Double_t& pvalue, Double_t& testStat) const; Double_tKolmogorovSmirnovTest(const Char_t* option = ""p"") const; voidKolmogorovSmirnovTest(Double_t& pvalue, Double_t& testStat) const; Double_toperator()(ROOT::Math::GoFTest::ETestType test = kAD, const Char_t* option = ""p"") const; voidoperator()(ROOT::Math::GoFTest::ETestType test, Double_t& pvalue, Double_t& testStat) const; voidSetDistribution(ROOT::Math::GoFTest::EDistribution dist); voidSetUserCDF(const ROOT::Math::IGenFunction& cdf, Double_t xmin = 1, Double_t xmax = 0); voidSetUserDistribution(const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); voidSetUserPDF(const ROOT::Math::IGenFunction& pdf, Double_t xmin = 1, Double_t xmax = 0). private:. Double_tExponentialCDF(Double_t x) const; Double_tGaussianCDF(Double_t x) const; Double_tGetSigmaN(UInt_t N) const; ROOT::Math::GoFTestGoFTest(); ROOT::Math::GoFTestGoFTest(RO",MatchSource.WIKI,root/html532/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GoFTest.html
https://root.cern/root/html532/ROOT__Math__GoFTest.html:3375,Testability,test,tests,3375,"F(Double_t x) const; voidLogSample(); ROOT::Math::GoFTestoperator=(ROOT::Math::GoFTest& gof); Double_tPValueAD1Sample(Double_t A2) const; Double_tPValueAD2Samples(Double_t& A2, UInt_t N) const; voidSetCDF(); voidSetDistributionFunction(const ROOT::Math::IGenFunction& cdf, Bool_t isPDF, Double_t xmin, Double_t xmax); voidSetParameters(); voidSetSamples(vector<const Double_t*> samples, const vector<UInt_t> samplesSizes). Data Members; public:. enum EDistribution { kUndefined; kUserDefined; kGaussian; kLogNormal; kExponential; };; enum EUserDistribution { kCDF; kPDF; };; enum ETestType { kAD; kAD2s; kKS; kKS2s; };. private:. auto_ptr<ROOT::Math::IBaseFunctionOneDim>fCDF; vector<Double_t>fCombinedSamples; ROOT::Math::GoFTest::EDistributionfDist; Double_tfMean; vector<std::vector<Double_t> >fSamples; Double_tfSigma; Bool_tfTestSampleFromH0. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GoFTest(UInt_t sample1Size, const Double_t* sample1, UInt_t sample2Size, const Double_t* sample2); Constructor for using only with 2-samples tests. GoFTest(UInt_t sampleSize, const Double_t* sample, ROOT::Math::GoFTest::EDistribution dist = kUndefined); Constructor for using only with 1-sample tests with a specified distribution. GoFTest(UInt_t sampleSize, const Double_t* sample, const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); Templated constructor for using only with 1-sample tests with a user specified distribution. Instantiate(const Double_t* sample, UInt_t sampleSize). GoFTest(UInt_t sampleSize, const Double_t* sample, const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); Specialization using IGenFunction interface. SetUserDistribution(const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0). SetDistributio",MatchSource.WIKI,root/html532/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GoFTest.html
https://root.cern/root/html532/ROOT__Math__GoFTest.html:3529,Testability,test,tests,3529,"Int_t N) const; voidSetCDF(); voidSetDistributionFunction(const ROOT::Math::IGenFunction& cdf, Bool_t isPDF, Double_t xmin, Double_t xmax); voidSetParameters(); voidSetSamples(vector<const Double_t*> samples, const vector<UInt_t> samplesSizes). Data Members; public:. enum EDistribution { kUndefined; kUserDefined; kGaussian; kLogNormal; kExponential; };; enum EUserDistribution { kCDF; kPDF; };; enum ETestType { kAD; kAD2s; kKS; kKS2s; };. private:. auto_ptr<ROOT::Math::IBaseFunctionOneDim>fCDF; vector<Double_t>fCombinedSamples; ROOT::Math::GoFTest::EDistributionfDist; Double_tfMean; vector<std::vector<Double_t> >fSamples; Double_tfSigma; Bool_tfTestSampleFromH0. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GoFTest(UInt_t sample1Size, const Double_t* sample1, UInt_t sample2Size, const Double_t* sample2); Constructor for using only with 2-samples tests. GoFTest(UInt_t sampleSize, const Double_t* sample, ROOT::Math::GoFTest::EDistribution dist = kUndefined); Constructor for using only with 1-sample tests with a specified distribution. GoFTest(UInt_t sampleSize, const Double_t* sample, const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); Templated constructor for using only with 1-sample tests with a user specified distribution. Instantiate(const Double_t* sample, UInt_t sampleSize). GoFTest(UInt_t sampleSize, const Double_t* sample, const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); Specialization using IGenFunction interface. SetUserDistribution(const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0). SetDistributionFunction(const ROOT::Math::IGenFunction& cdf, Bool_t isPDF, Double_t xmin, Double_t xmax). void SetUserPDF(const ROOT::Math::IGenFunction& pdf, Double_t xmin = 1, Double_t xmax ",MatchSource.WIKI,root/html532/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GoFTest.html
https://root.cern/root/html532/ROOT__Math__GoFTest.html:3801,Testability,test,tests,3801,"samplesSizes). Data Members; public:. enum EDistribution { kUndefined; kUserDefined; kGaussian; kLogNormal; kExponential; };; enum EUserDistribution { kCDF; kPDF; };; enum ETestType { kAD; kAD2s; kKS; kKS2s; };. private:. auto_ptr<ROOT::Math::IBaseFunctionOneDim>fCDF; vector<Double_t>fCombinedSamples; ROOT::Math::GoFTest::EDistributionfDist; Double_tfMean; vector<std::vector<Double_t> >fSamples; Double_tfSigma; Bool_tfTestSampleFromH0. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GoFTest(UInt_t sample1Size, const Double_t* sample1, UInt_t sample2Size, const Double_t* sample2); Constructor for using only with 2-samples tests. GoFTest(UInt_t sampleSize, const Double_t* sample, ROOT::Math::GoFTest::EDistribution dist = kUndefined); Constructor for using only with 1-sample tests with a specified distribution. GoFTest(UInt_t sampleSize, const Double_t* sample, const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); Templated constructor for using only with 1-sample tests with a user specified distribution. Instantiate(const Double_t* sample, UInt_t sampleSize). GoFTest(UInt_t sampleSize, const Double_t* sample, const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); Specialization using IGenFunction interface. SetUserDistribution(const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0). SetDistributionFunction(const ROOT::Math::IGenFunction& cdf, Bool_t isPDF, Double_t xmin, Double_t xmax). void SetUserPDF(const ROOT::Math::IGenFunction& pdf, Double_t xmin = 1, Double_t xmax = 0); Sets the user input distribution as a probability density function for 1-sample tests. void SetUserCDF(const ROOT::Math::IGenFunction& cdf, Double_t xmin = 1, Double_t xmax = 0); Sets the user input distribution as a cumulati",MatchSource.WIKI,root/html532/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GoFTest.html
https://root.cern/root/html532/ROOT__Math__GoFTest.html:4559,Testability,test,tests,4559,"kUndefined); Constructor for using only with 1-sample tests with a specified distribution. GoFTest(UInt_t sampleSize, const Double_t* sample, const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); Templated constructor for using only with 1-sample tests with a user specified distribution. Instantiate(const Double_t* sample, UInt_t sampleSize). GoFTest(UInt_t sampleSize, const Double_t* sample, const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); Specialization using IGenFunction interface. SetUserDistribution(const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0). SetDistributionFunction(const ROOT::Math::IGenFunction& cdf, Bool_t isPDF, Double_t xmin, Double_t xmax). void SetUserPDF(const ROOT::Math::IGenFunction& pdf, Double_t xmin = 1, Double_t xmax = 0); Sets the user input distribution as a probability density function for 1-sample tests. void SetUserCDF(const ROOT::Math::IGenFunction& cdf, Double_t xmin = 1, Double_t xmax = 0); Sets the user input distribution as a cumulative distribution function for 1-sample tests; The CDF must return zero. void SetDistribution(ROOT::Math::GoFTest::EDistribution dist); Sets the distribution for the predefined distribution types. virtual ~GoFTest(). Double_t AndersonDarling2SamplesTest(const Char_t* option = ""p"") const. The Anderson-Darling K-Sample Test algorithm is described and taken from; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/andeksam.htm; and described and taken from (1); Scholz F.W., Stephens M.A. (1987), K-sample Anderson-Darling Tests, Journal of the American Statistical Association, 82, 918924. (2-samples variant implemented); */ void AndersonDarling2SamplesTest(Double_t& pvalue, Double_t& testStat) const;. Double_t AndersonDarlingTest(const Char_t* option = ",MatchSource.WIKI,root/html532/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GoFTest.html
https://root.cern/root/html532/ROOT__Math__GoFTest.html:4742,Testability,test,tests,4742,"FTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); Templated constructor for using only with 1-sample tests with a user specified distribution. Instantiate(const Double_t* sample, UInt_t sampleSize). GoFTest(UInt_t sampleSize, const Double_t* sample, const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); Specialization using IGenFunction interface. SetUserDistribution(const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0). SetDistributionFunction(const ROOT::Math::IGenFunction& cdf, Bool_t isPDF, Double_t xmin, Double_t xmax). void SetUserPDF(const ROOT::Math::IGenFunction& pdf, Double_t xmin = 1, Double_t xmax = 0); Sets the user input distribution as a probability density function for 1-sample tests. void SetUserCDF(const ROOT::Math::IGenFunction& cdf, Double_t xmin = 1, Double_t xmax = 0); Sets the user input distribution as a cumulative distribution function for 1-sample tests; The CDF must return zero. void SetDistribution(ROOT::Math::GoFTest::EDistribution dist); Sets the distribution for the predefined distribution types. virtual ~GoFTest(). Double_t AndersonDarling2SamplesTest(const Char_t* option = ""p"") const. The Anderson-Darling K-Sample Test algorithm is described and taken from; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/andeksam.htm; and described and taken from (1); Scholz F.W., Stephens M.A. (1987), K-sample Anderson-Darling Tests, Journal of the American Statistical Association, 82, 918924. (2-samples variant implemented); */ void AndersonDarling2SamplesTest(Double_t& pvalue, Double_t& testStat) const;. Double_t AndersonDarlingTest(const Char_t* option = ""p"") const. The Anderson-Darling 1-Sample Test algorithm for a specific distribution is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/andedarl.htm; and describe",MatchSource.WIKI,root/html532/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GoFTest.html
https://root.cern/root/html532/ROOT__Math__GoFTest.html:5021,Testability,Test,Test,5021,"st = kPDF, Double_t xmin = 1, Double_t xmax = 0); Specialization using IGenFunction interface. SetUserDistribution(const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0). SetDistributionFunction(const ROOT::Math::IGenFunction& cdf, Bool_t isPDF, Double_t xmin, Double_t xmax). void SetUserPDF(const ROOT::Math::IGenFunction& pdf, Double_t xmin = 1, Double_t xmax = 0); Sets the user input distribution as a probability density function for 1-sample tests. void SetUserCDF(const ROOT::Math::IGenFunction& cdf, Double_t xmin = 1, Double_t xmax = 0); Sets the user input distribution as a cumulative distribution function for 1-sample tests; The CDF must return zero. void SetDistribution(ROOT::Math::GoFTest::EDistribution dist); Sets the distribution for the predefined distribution types. virtual ~GoFTest(). Double_t AndersonDarling2SamplesTest(const Char_t* option = ""p"") const. The Anderson-Darling K-Sample Test algorithm is described and taken from; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/andeksam.htm; and described and taken from (1); Scholz F.W., Stephens M.A. (1987), K-sample Anderson-Darling Tests, Journal of the American Statistical Association, 82, 918924. (2-samples variant implemented); */ void AndersonDarling2SamplesTest(Double_t& pvalue, Double_t& testStat) const;. Double_t AndersonDarlingTest(const Char_t* option = ""p"") const. The Anderson-Darling 1-Sample Test algorithm for a specific distribution is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/andedarl.htm; and described and taken from (2); Marsaglia J.C.W., Marsaglia G. (2004), Evaluating the Anderson-Darling Distribution, Journal of Statistical Software, Volume 09, Issue i02.; and described and taken from (3); Lewis P.A.W. (1961), The Annals of Mathematical Statistics, Distribution of the Anderson-Darling Statistic, Volume 32, Number 4, 1118-1124.; */ void AndersonDarlingTe",MatchSource.WIKI,root/html532/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GoFTest.html
https://root.cern/root/html532/ROOT__Math__GoFTest.html:5240,Testability,Test,Tests,5240,"= 1, Double_t xmax = 0). SetDistributionFunction(const ROOT::Math::IGenFunction& cdf, Bool_t isPDF, Double_t xmin, Double_t xmax). void SetUserPDF(const ROOT::Math::IGenFunction& pdf, Double_t xmin = 1, Double_t xmax = 0); Sets the user input distribution as a probability density function for 1-sample tests. void SetUserCDF(const ROOT::Math::IGenFunction& cdf, Double_t xmin = 1, Double_t xmax = 0); Sets the user input distribution as a cumulative distribution function for 1-sample tests; The CDF must return zero. void SetDistribution(ROOT::Math::GoFTest::EDistribution dist); Sets the distribution for the predefined distribution types. virtual ~GoFTest(). Double_t AndersonDarling2SamplesTest(const Char_t* option = ""p"") const. The Anderson-Darling K-Sample Test algorithm is described and taken from; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/andeksam.htm; and described and taken from (1); Scholz F.W., Stephens M.A. (1987), K-sample Anderson-Darling Tests, Journal of the American Statistical Association, 82, 918924. (2-samples variant implemented); */ void AndersonDarling2SamplesTest(Double_t& pvalue, Double_t& testStat) const;. Double_t AndersonDarlingTest(const Char_t* option = ""p"") const. The Anderson-Darling 1-Sample Test algorithm for a specific distribution is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/andedarl.htm; and described and taken from (2); Marsaglia J.C.W., Marsaglia G. (2004), Evaluating the Anderson-Darling Distribution, Journal of Statistical Software, Volume 09, Issue i02.; and described and taken from (3); Lewis P.A.W. (1961), The Annals of Mathematical Statistics, Distribution of the Anderson-Darling Statistic, Volume 32, Number 4, 1118-1124.; */ void AndersonDarlingTest(Double_t& pvalue, Double_t& testStat) const;. Double_t KolmogorovSmirnov2SamplesTest(const Char_t* option = ""p"") const. The Kolmogorov-Smirnov 2-Samples Test algorithm is described at; http://www.itl.nist.gov/div898/softw",MatchSource.WIKI,root/html532/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GoFTest.html
https://root.cern/root/html532/ROOT__Math__GoFTest.html:5406,Testability,test,testStat,5406,"xmin, Double_t xmax). void SetUserPDF(const ROOT::Math::IGenFunction& pdf, Double_t xmin = 1, Double_t xmax = 0); Sets the user input distribution as a probability density function for 1-sample tests. void SetUserCDF(const ROOT::Math::IGenFunction& cdf, Double_t xmin = 1, Double_t xmax = 0); Sets the user input distribution as a cumulative distribution function for 1-sample tests; The CDF must return zero. void SetDistribution(ROOT::Math::GoFTest::EDistribution dist); Sets the distribution for the predefined distribution types. virtual ~GoFTest(). Double_t AndersonDarling2SamplesTest(const Char_t* option = ""p"") const. The Anderson-Darling K-Sample Test algorithm is described and taken from; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/andeksam.htm; and described and taken from (1); Scholz F.W., Stephens M.A. (1987), K-sample Anderson-Darling Tests, Journal of the American Statistical Association, 82, 918924. (2-samples variant implemented); */ void AndersonDarling2SamplesTest(Double_t& pvalue, Double_t& testStat) const;. Double_t AndersonDarlingTest(const Char_t* option = ""p"") const. The Anderson-Darling 1-Sample Test algorithm for a specific distribution is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/andedarl.htm; and described and taken from (2); Marsaglia J.C.W., Marsaglia G. (2004), Evaluating the Anderson-Darling Distribution, Journal of Statistical Software, Volume 09, Issue i02.; and described and taken from (3); Lewis P.A.W. (1961), The Annals of Mathematical Statistics, Distribution of the Anderson-Darling Statistic, Volume 32, Number 4, 1118-1124.; */ void AndersonDarlingTest(Double_t& pvalue, Double_t& testStat) const;. Double_t KolmogorovSmirnov2SamplesTest(const Char_t* option = ""p"") const. The Kolmogorov-Smirnov 2-Samples Test algorithm is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/ks2samp.htm; and described and taken from; http://root.cern.ch/root/html/TMath.",MatchSource.WIKI,root/html532/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GoFTest.html
https://root.cern/root/html532/ROOT__Math__GoFTest.html:5518,Testability,Test,Test,5518,"unction for 1-sample tests. void SetUserCDF(const ROOT::Math::IGenFunction& cdf, Double_t xmin = 1, Double_t xmax = 0); Sets the user input distribution as a cumulative distribution function for 1-sample tests; The CDF must return zero. void SetDistribution(ROOT::Math::GoFTest::EDistribution dist); Sets the distribution for the predefined distribution types. virtual ~GoFTest(). Double_t AndersonDarling2SamplesTest(const Char_t* option = ""p"") const. The Anderson-Darling K-Sample Test algorithm is described and taken from; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/andeksam.htm; and described and taken from (1); Scholz F.W., Stephens M.A. (1987), K-sample Anderson-Darling Tests, Journal of the American Statistical Association, 82, 918924. (2-samples variant implemented); */ void AndersonDarling2SamplesTest(Double_t& pvalue, Double_t& testStat) const;. Double_t AndersonDarlingTest(const Char_t* option = ""p"") const. The Anderson-Darling 1-Sample Test algorithm for a specific distribution is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/andedarl.htm; and described and taken from (2); Marsaglia J.C.W., Marsaglia G. (2004), Evaluating the Anderson-Darling Distribution, Journal of Statistical Software, Volume 09, Issue i02.; and described and taken from (3); Lewis P.A.W. (1961), The Annals of Mathematical Statistics, Distribution of the Anderson-Darling Statistic, Volume 32, Number 4, 1118-1124.; */ void AndersonDarlingTest(Double_t& pvalue, Double_t& testStat) const;. Double_t KolmogorovSmirnov2SamplesTest(const Char_t* option = ""p"") const. The Kolmogorov-Smirnov 2-Samples Test algorithm is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/ks2samp.htm; and described and taken from; http://root.cern.ch/root/html/TMath.html#TMath:KolmogorovTest; */ void KolmogorovSmirnov2SamplesTest(Double_t& pvalue, Double_t& testStat) const;. Double_t KolmogorovSmirnovTest(const Char_t* option = ""p"") co",MatchSource.WIKI,root/html532/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GoFTest.html
https://root.cern/root/html532/ROOT__Math__GoFTest.html:6064,Testability,test,testStat,6064,"ribed and taken from; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/andeksam.htm; and described and taken from (1); Scholz F.W., Stephens M.A. (1987), K-sample Anderson-Darling Tests, Journal of the American Statistical Association, 82, 918924. (2-samples variant implemented); */ void AndersonDarling2SamplesTest(Double_t& pvalue, Double_t& testStat) const;. Double_t AndersonDarlingTest(const Char_t* option = ""p"") const. The Anderson-Darling 1-Sample Test algorithm for a specific distribution is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/andedarl.htm; and described and taken from (2); Marsaglia J.C.W., Marsaglia G. (2004), Evaluating the Anderson-Darling Distribution, Journal of Statistical Software, Volume 09, Issue i02.; and described and taken from (3); Lewis P.A.W. (1961), The Annals of Mathematical Statistics, Distribution of the Anderson-Darling Statistic, Volume 32, Number 4, 1118-1124.; */ void AndersonDarlingTest(Double_t& pvalue, Double_t& testStat) const;. Double_t KolmogorovSmirnov2SamplesTest(const Char_t* option = ""p"") const. The Kolmogorov-Smirnov 2-Samples Test algorithm is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/ks2samp.htm; and described and taken from; http://root.cern.ch/root/html/TMath.html#TMath:KolmogorovTest; */ void KolmogorovSmirnov2SamplesTest(Double_t& pvalue, Double_t& testStat) const;. Double_t KolmogorovSmirnovTest(const Char_t* option = ""p"") const. The Kolmogorov-Smirnov 1-Sample Test algorithm for a specific distribution is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/kstest.htm; and described and taken from (4); Press W. H., Teukolsky S.A., Vetterling W.T., Flannery B.P. (2007), Numerical Recipes - The Art of Scientific Computing (Third Edition), Cambridge Univerdity Press; */ void KolmogorovSmirnovTest(Double_t& pvalue, Double_t& testStat) const;. void operator()(ROOT::Math::GoFTest::ETestType test, Dou",MatchSource.WIKI,root/html532/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GoFTest.html
https://root.cern/root/html532/ROOT__Math__GoFTest.html:6189,Testability,Test,Test,6189,"tephens M.A. (1987), K-sample Anderson-Darling Tests, Journal of the American Statistical Association, 82, 918924. (2-samples variant implemented); */ void AndersonDarling2SamplesTest(Double_t& pvalue, Double_t& testStat) const;. Double_t AndersonDarlingTest(const Char_t* option = ""p"") const. The Anderson-Darling 1-Sample Test algorithm for a specific distribution is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/andedarl.htm; and described and taken from (2); Marsaglia J.C.W., Marsaglia G. (2004), Evaluating the Anderson-Darling Distribution, Journal of Statistical Software, Volume 09, Issue i02.; and described and taken from (3); Lewis P.A.W. (1961), The Annals of Mathematical Statistics, Distribution of the Anderson-Darling Statistic, Volume 32, Number 4, 1118-1124.; */ void AndersonDarlingTest(Double_t& pvalue, Double_t& testStat) const;. Double_t KolmogorovSmirnov2SamplesTest(const Char_t* option = ""p"") const. The Kolmogorov-Smirnov 2-Samples Test algorithm is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/ks2samp.htm; and described and taken from; http://root.cern.ch/root/html/TMath.html#TMath:KolmogorovTest; */ void KolmogorovSmirnov2SamplesTest(Double_t& pvalue, Double_t& testStat) const;. Double_t KolmogorovSmirnovTest(const Char_t* option = ""p"") const. The Kolmogorov-Smirnov 1-Sample Test algorithm for a specific distribution is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/kstest.htm; and described and taken from (4); Press W. H., Teukolsky S.A., Vetterling W.T., Flannery B.P. (2007), Numerical Recipes - The Art of Scientific Computing (Third Edition), Cambridge Univerdity Press; */ void KolmogorovSmirnovTest(Double_t& pvalue, Double_t& testStat) const;. void operator()(ROOT::Math::GoFTest::ETestType test, Double_t& pvalue, Double_t& testStat) const; The class's unary functions. Double_t operator()(ROOT::Math::GoFTest::ETestType test = kAD, const Char_t* op",MatchSource.WIKI,root/html532/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GoFTest.html
https://root.cern/root/html532/ROOT__Math__GoFTest.html:6459,Testability,test,testStat,6459,";. Double_t AndersonDarlingTest(const Char_t* option = ""p"") const. The Anderson-Darling 1-Sample Test algorithm for a specific distribution is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/andedarl.htm; and described and taken from (2); Marsaglia J.C.W., Marsaglia G. (2004), Evaluating the Anderson-Darling Distribution, Journal of Statistical Software, Volume 09, Issue i02.; and described and taken from (3); Lewis P.A.W. (1961), The Annals of Mathematical Statistics, Distribution of the Anderson-Darling Statistic, Volume 32, Number 4, 1118-1124.; */ void AndersonDarlingTest(Double_t& pvalue, Double_t& testStat) const;. Double_t KolmogorovSmirnov2SamplesTest(const Char_t* option = ""p"") const. The Kolmogorov-Smirnov 2-Samples Test algorithm is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/ks2samp.htm; and described and taken from; http://root.cern.ch/root/html/TMath.html#TMath:KolmogorovTest; */ void KolmogorovSmirnov2SamplesTest(Double_t& pvalue, Double_t& testStat) const;. Double_t KolmogorovSmirnovTest(const Char_t* option = ""p"") const. The Kolmogorov-Smirnov 1-Sample Test algorithm for a specific distribution is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/kstest.htm; and described and taken from (4); Press W. H., Teukolsky S.A., Vetterling W.T., Flannery B.P. (2007), Numerical Recipes - The Art of Scientific Computing (Third Edition), Cambridge Univerdity Press; */ void KolmogorovSmirnovTest(Double_t& pvalue, Double_t& testStat) const;. void operator()(ROOT::Math::GoFTest::ETestType test, Double_t& pvalue, Double_t& testStat) const; The class's unary functions. Double_t operator()(ROOT::Math::GoFTest::ETestType test = kAD, const Char_t* option = ""p"") const. GoFTest(). GoFTest operator=(ROOT::Math::GoFTest& gof). void SetCDF(). Double_t LogNormalCDF(Double_t x) const. Double_t GaussianCDF(Double_t x) const. Double_t ExponentialCDF(Double_t x) const. Double_t GetS",MatchSource.WIKI,root/html532/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GoFTest.html
https://root.cern/root/html532/ROOT__Math__GoFTest.html:6575,Testability,Test,Test,6575,"ist.gov/div898/software/dataplot/refman1/auxillar/andedarl.htm; and described and taken from (2); Marsaglia J.C.W., Marsaglia G. (2004), Evaluating the Anderson-Darling Distribution, Journal of Statistical Software, Volume 09, Issue i02.; and described and taken from (3); Lewis P.A.W. (1961), The Annals of Mathematical Statistics, Distribution of the Anderson-Darling Statistic, Volume 32, Number 4, 1118-1124.; */ void AndersonDarlingTest(Double_t& pvalue, Double_t& testStat) const;. Double_t KolmogorovSmirnov2SamplesTest(const Char_t* option = ""p"") const. The Kolmogorov-Smirnov 2-Samples Test algorithm is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/ks2samp.htm; and described and taken from; http://root.cern.ch/root/html/TMath.html#TMath:KolmogorovTest; */ void KolmogorovSmirnov2SamplesTest(Double_t& pvalue, Double_t& testStat) const;. Double_t KolmogorovSmirnovTest(const Char_t* option = ""p"") const. The Kolmogorov-Smirnov 1-Sample Test algorithm for a specific distribution is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/kstest.htm; and described and taken from (4); Press W. H., Teukolsky S.A., Vetterling W.T., Flannery B.P. (2007), Numerical Recipes - The Art of Scientific Computing (Third Edition), Cambridge Univerdity Press; */ void KolmogorovSmirnovTest(Double_t& pvalue, Double_t& testStat) const;. void operator()(ROOT::Math::GoFTest::ETestType test, Double_t& pvalue, Double_t& testStat) const; The class's unary functions. Double_t operator()(ROOT::Math::GoFTest::ETestType test = kAD, const Char_t* option = ""p"") const. GoFTest(). GoFTest operator=(ROOT::Math::GoFTest& gof). void SetCDF(). Double_t LogNormalCDF(Double_t x) const. Double_t GaussianCDF(Double_t x) const. Double_t ExponentialCDF(Double_t x) const. Double_t GetSigmaN(UInt_t N) const. Double_t InterpolatePValues(Double_t dA2, Int_t bin) const. Double_t PValueAD2Samples(Double_t& A2, UInt_t N) const. Double_t PValueAD1Sample(Double_t",MatchSource.WIKI,root/html532/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GoFTest.html
https://root.cern/root/html532/ROOT__Math__GoFTest.html:6970,Testability,test,testStat,6970,"ls of Mathematical Statistics, Distribution of the Anderson-Darling Statistic, Volume 32, Number 4, 1118-1124.; */ void AndersonDarlingTest(Double_t& pvalue, Double_t& testStat) const;. Double_t KolmogorovSmirnov2SamplesTest(const Char_t* option = ""p"") const. The Kolmogorov-Smirnov 2-Samples Test algorithm is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/ks2samp.htm; and described and taken from; http://root.cern.ch/root/html/TMath.html#TMath:KolmogorovTest; */ void KolmogorovSmirnov2SamplesTest(Double_t& pvalue, Double_t& testStat) const;. Double_t KolmogorovSmirnovTest(const Char_t* option = ""p"") const. The Kolmogorov-Smirnov 1-Sample Test algorithm for a specific distribution is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/kstest.htm; and described and taken from (4); Press W. H., Teukolsky S.A., Vetterling W.T., Flannery B.P. (2007), Numerical Recipes - The Art of Scientific Computing (Third Edition), Cambridge Univerdity Press; */ void KolmogorovSmirnovTest(Double_t& pvalue, Double_t& testStat) const;. void operator()(ROOT::Math::GoFTest::ETestType test, Double_t& pvalue, Double_t& testStat) const; The class's unary functions. Double_t operator()(ROOT::Math::GoFTest::ETestType test = kAD, const Char_t* option = ""p"") const. GoFTest(). GoFTest operator=(ROOT::Math::GoFTest& gof). void SetCDF(). Double_t LogNormalCDF(Double_t x) const. Double_t GaussianCDF(Double_t x) const. Double_t ExponentialCDF(Double_t x) const. Double_t GetSigmaN(UInt_t N) const. Double_t InterpolatePValues(Double_t dA2, Int_t bin) const. Double_t PValueAD2Samples(Double_t& A2, UInt_t N) const. Double_t PValueAD1Sample(Double_t A2) const. void LogSample(). void SetSamples(vector<const Double_t*> samples, const vector<UInt_t> samplesSizes). void SetParameters().  Last changed: root/mathcore:$Id: GoFTest.h 36911 2010-11-24 17:08:43Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For c",MatchSource.WIKI,root/html532/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GoFTest.html
https://root.cern/root/html532/ROOT__Math__GoFTest.html:7035,Testability,test,test,7035,"24.; */ void AndersonDarlingTest(Double_t& pvalue, Double_t& testStat) const;. Double_t KolmogorovSmirnov2SamplesTest(const Char_t* option = ""p"") const. The Kolmogorov-Smirnov 2-Samples Test algorithm is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/ks2samp.htm; and described and taken from; http://root.cern.ch/root/html/TMath.html#TMath:KolmogorovTest; */ void KolmogorovSmirnov2SamplesTest(Double_t& pvalue, Double_t& testStat) const;. Double_t KolmogorovSmirnovTest(const Char_t* option = ""p"") const. The Kolmogorov-Smirnov 1-Sample Test algorithm for a specific distribution is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/kstest.htm; and described and taken from (4); Press W. H., Teukolsky S.A., Vetterling W.T., Flannery B.P. (2007), Numerical Recipes - The Art of Scientific Computing (Third Edition), Cambridge Univerdity Press; */ void KolmogorovSmirnovTest(Double_t& pvalue, Double_t& testStat) const;. void operator()(ROOT::Math::GoFTest::ETestType test, Double_t& pvalue, Double_t& testStat) const; The class's unary functions. Double_t operator()(ROOT::Math::GoFTest::ETestType test = kAD, const Char_t* option = ""p"") const. GoFTest(). GoFTest operator=(ROOT::Math::GoFTest& gof). void SetCDF(). Double_t LogNormalCDF(Double_t x) const. Double_t GaussianCDF(Double_t x) const. Double_t ExponentialCDF(Double_t x) const. Double_t GetSigmaN(UInt_t N) const. Double_t InterpolatePValues(Double_t dA2, Int_t bin) const. Double_t PValueAD2Samples(Double_t& A2, UInt_t N) const. Double_t PValueAD1Sample(Double_t A2) const. void LogSample(). void SetSamples(vector<const Double_t*> samples, const vector<UInt_t> samplesSizes). void SetParameters().  Last changed: root/mathcore:$Id: GoFTest.h 36911 2010-11-24 17:08:43Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GoFTest.html
https://root.cern/root/html532/ROOT__Math__GoFTest.html:7069,Testability,test,testStat,7069,"24.; */ void AndersonDarlingTest(Double_t& pvalue, Double_t& testStat) const;. Double_t KolmogorovSmirnov2SamplesTest(const Char_t* option = ""p"") const. The Kolmogorov-Smirnov 2-Samples Test algorithm is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/ks2samp.htm; and described and taken from; http://root.cern.ch/root/html/TMath.html#TMath:KolmogorovTest; */ void KolmogorovSmirnov2SamplesTest(Double_t& pvalue, Double_t& testStat) const;. Double_t KolmogorovSmirnovTest(const Char_t* option = ""p"") const. The Kolmogorov-Smirnov 1-Sample Test algorithm for a specific distribution is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/kstest.htm; and described and taken from (4); Press W. H., Teukolsky S.A., Vetterling W.T., Flannery B.P. (2007), Numerical Recipes - The Art of Scientific Computing (Third Edition), Cambridge Univerdity Press; */ void KolmogorovSmirnovTest(Double_t& pvalue, Double_t& testStat) const;. void operator()(ROOT::Math::GoFTest::ETestType test, Double_t& pvalue, Double_t& testStat) const; The class's unary functions. Double_t operator()(ROOT::Math::GoFTest::ETestType test = kAD, const Char_t* option = ""p"") const. GoFTest(). GoFTest operator=(ROOT::Math::GoFTest& gof). void SetCDF(). Double_t LogNormalCDF(Double_t x) const. Double_t GaussianCDF(Double_t x) const. Double_t ExponentialCDF(Double_t x) const. Double_t GetSigmaN(UInt_t N) const. Double_t InterpolatePValues(Double_t dA2, Int_t bin) const. Double_t PValueAD2Samples(Double_t& A2, UInt_t N) const. Double_t PValueAD1Sample(Double_t A2) const. void LogSample(). void SetSamples(vector<const Double_t*> samples, const vector<UInt_t> samplesSizes). void SetParameters().  Last changed: root/mathcore:$Id: GoFTest.h 36911 2010-11-24 17:08:43Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GoFTest.html
https://root.cern/root/html532/ROOT__Math__GoFTest.html:7166,Testability,test,test,7166,"24.; */ void AndersonDarlingTest(Double_t& pvalue, Double_t& testStat) const;. Double_t KolmogorovSmirnov2SamplesTest(const Char_t* option = ""p"") const. The Kolmogorov-Smirnov 2-Samples Test algorithm is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/ks2samp.htm; and described and taken from; http://root.cern.ch/root/html/TMath.html#TMath:KolmogorovTest; */ void KolmogorovSmirnov2SamplesTest(Double_t& pvalue, Double_t& testStat) const;. Double_t KolmogorovSmirnovTest(const Char_t* option = ""p"") const. The Kolmogorov-Smirnov 1-Sample Test algorithm for a specific distribution is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/kstest.htm; and described and taken from (4); Press W. H., Teukolsky S.A., Vetterling W.T., Flannery B.P. (2007), Numerical Recipes - The Art of Scientific Computing (Third Edition), Cambridge Univerdity Press; */ void KolmogorovSmirnovTest(Double_t& pvalue, Double_t& testStat) const;. void operator()(ROOT::Math::GoFTest::ETestType test, Double_t& pvalue, Double_t& testStat) const; The class's unary functions. Double_t operator()(ROOT::Math::GoFTest::ETestType test = kAD, const Char_t* option = ""p"") const. GoFTest(). GoFTest operator=(ROOT::Math::GoFTest& gof). void SetCDF(). Double_t LogNormalCDF(Double_t x) const. Double_t GaussianCDF(Double_t x) const. Double_t ExponentialCDF(Double_t x) const. Double_t GetSigmaN(UInt_t N) const. Double_t InterpolatePValues(Double_t dA2, Int_t bin) const. Double_t PValueAD2Samples(Double_t& A2, UInt_t N) const. Double_t PValueAD1Sample(Double_t A2) const. void LogSample(). void SetSamples(vector<const Double_t*> samples, const vector<UInt_t> samplesSizes). void SetParameters().  Last changed: root/mathcore:$Id: GoFTest.h 36911 2010-11-24 17:08:43Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GoFTest.html
https://root.cern/root/html532/ROOT__Math__GoFTest.html:7293,Testability,Log,LogNormalCDF,7293,"24.; */ void AndersonDarlingTest(Double_t& pvalue, Double_t& testStat) const;. Double_t KolmogorovSmirnov2SamplesTest(const Char_t* option = ""p"") const. The Kolmogorov-Smirnov 2-Samples Test algorithm is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/ks2samp.htm; and described and taken from; http://root.cern.ch/root/html/TMath.html#TMath:KolmogorovTest; */ void KolmogorovSmirnov2SamplesTest(Double_t& pvalue, Double_t& testStat) const;. Double_t KolmogorovSmirnovTest(const Char_t* option = ""p"") const. The Kolmogorov-Smirnov 1-Sample Test algorithm for a specific distribution is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/kstest.htm; and described and taken from (4); Press W. H., Teukolsky S.A., Vetterling W.T., Flannery B.P. (2007), Numerical Recipes - The Art of Scientific Computing (Third Edition), Cambridge Univerdity Press; */ void KolmogorovSmirnovTest(Double_t& pvalue, Double_t& testStat) const;. void operator()(ROOT::Math::GoFTest::ETestType test, Double_t& pvalue, Double_t& testStat) const; The class's unary functions. Double_t operator()(ROOT::Math::GoFTest::ETestType test = kAD, const Char_t* option = ""p"") const. GoFTest(). GoFTest operator=(ROOT::Math::GoFTest& gof). void SetCDF(). Double_t LogNormalCDF(Double_t x) const. Double_t GaussianCDF(Double_t x) const. Double_t ExponentialCDF(Double_t x) const. Double_t GetSigmaN(UInt_t N) const. Double_t InterpolatePValues(Double_t dA2, Int_t bin) const. Double_t PValueAD2Samples(Double_t& A2, UInt_t N) const. Double_t PValueAD1Sample(Double_t A2) const. void LogSample(). void SetSamples(vector<const Double_t*> samples, const vector<UInt_t> samplesSizes). void SetParameters().  Last changed: root/mathcore:$Id: GoFTest.h 36911 2010-11-24 17:08:43Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GoFTest.html
https://root.cern/root/html532/ROOT__Math__GoFTest.html:7611,Testability,Log,LogSample,7611,"24.; */ void AndersonDarlingTest(Double_t& pvalue, Double_t& testStat) const;. Double_t KolmogorovSmirnov2SamplesTest(const Char_t* option = ""p"") const. The Kolmogorov-Smirnov 2-Samples Test algorithm is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/ks2samp.htm; and described and taken from; http://root.cern.ch/root/html/TMath.html#TMath:KolmogorovTest; */ void KolmogorovSmirnov2SamplesTest(Double_t& pvalue, Double_t& testStat) const;. Double_t KolmogorovSmirnovTest(const Char_t* option = ""p"") const. The Kolmogorov-Smirnov 1-Sample Test algorithm for a specific distribution is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/kstest.htm; and described and taken from (4); Press W. H., Teukolsky S.A., Vetterling W.T., Flannery B.P. (2007), Numerical Recipes - The Art of Scientific Computing (Third Edition), Cambridge Univerdity Press; */ void KolmogorovSmirnovTest(Double_t& pvalue, Double_t& testStat) const;. void operator()(ROOT::Math::GoFTest::ETestType test, Double_t& pvalue, Double_t& testStat) const; The class's unary functions. Double_t operator()(ROOT::Math::GoFTest::ETestType test = kAD, const Char_t* option = ""p"") const. GoFTest(). GoFTest operator=(ROOT::Math::GoFTest& gof). void SetCDF(). Double_t LogNormalCDF(Double_t x) const. Double_t GaussianCDF(Double_t x) const. Double_t ExponentialCDF(Double_t x) const. Double_t GetSigmaN(UInt_t N) const. Double_t InterpolatePValues(Double_t dA2, Int_t bin) const. Double_t PValueAD2Samples(Double_t& A2, UInt_t N) const. Double_t PValueAD1Sample(Double_t A2) const. void LogSample(). void SetSamples(vector<const Double_t*> samples, const vector<UInt_t> samplesSizes). void SetParameters().  Last changed: root/mathcore:$Id: GoFTest.h 36911 2010-11-24 17:08:43Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GoFTest.html
https://root.cern/root/html532/ROOT__Math__GradFunctor.html:394,Integrability,wrap,wrap,394,". ROOT::Math::GradFunctor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::GradFunctor. class ROOT::Math::GradFunctor: public ROOT::Math::IGradientFunctionMultiDim. Documentation for class Functor class.; It is used to wrap in a very simple and convenient way multi-dimensional function objects.; It can wrap all the following types:; <ul>; <li> any C++ callable object implemention double operator()( const double * ); <li> a free C function of type double ()(double * ); <li> a member function with the correct signature like Foo::Eval(const double * ).; In this case one pass the object pointer and a pointer to the member function (&Foo::Eval); </ul>; The function dimension is required when constructing the functor. @ingroup GenFunc. Function Members (Methods); public:. virtual~GradFunctor(); virtual ROOT::Math::GradFunctor::ImplBase*Clone() const; doubleROOT::Math::IGradientMultiDim::Derivative(const double* x, unsigned int icoord = 0) const; virtual voidROOT::Math::IGradientFunctionMultiDim::FdF(const double* x, double& f, double* df) const; ROOT::Math::GradFunctorGradFunctor(); ROOT::Math::GradFunctorGradFunctor(const ROOT::Math::GradFunctor&); ROOT::Math::GradFunctorGradFunctor(void* p1, void* p2, unsigned int dim); ROOT::Math::GradFunctorGradFunctor(void* p1, unsigned int dim, const char* className, const char* methodName, const char* derivName); virtual voidROOT::Math::IGradientFunctionMultiDim::Gradient(const double* x, double* grad) const; virtual unsigned intNDim() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::GradFunctor&operator=(const ROOT::Math::GradFunctor& rhs). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const. Data Members; private:. auto_ptr<ROOT::Math::IGrad",MatchSource.WIKI,root/html532/ROOT__Math__GradFunctor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GradFunctor.html
https://root.cern/root/html532/ROOT__Math__GradFunctor.html:479,Integrability,wrap,wrap,479,". ROOT::Math::GradFunctor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::GradFunctor. class ROOT::Math::GradFunctor: public ROOT::Math::IGradientFunctionMultiDim. Documentation for class Functor class.; It is used to wrap in a very simple and convenient way multi-dimensional function objects.; It can wrap all the following types:; <ul>; <li> any C++ callable object implemention double operator()( const double * ); <li> a free C function of type double ()(double * ); <li> a member function with the correct signature like Foo::Eval(const double * ).; In this case one pass the object pointer and a pointer to the member function (&Foo::Eval); </ul>; The function dimension is required when constructing the functor. @ingroup GenFunc. Function Members (Methods); public:. virtual~GradFunctor(); virtual ROOT::Math::GradFunctor::ImplBase*Clone() const; doubleROOT::Math::IGradientMultiDim::Derivative(const double* x, unsigned int icoord = 0) const; virtual voidROOT::Math::IGradientFunctionMultiDim::FdF(const double* x, double& f, double* df) const; ROOT::Math::GradFunctorGradFunctor(); ROOT::Math::GradFunctorGradFunctor(const ROOT::Math::GradFunctor&); ROOT::Math::GradFunctorGradFunctor(void* p1, void* p2, unsigned int dim); ROOT::Math::GradFunctorGradFunctor(void* p1, unsigned int dim, const char* className, const char* methodName, const char* derivName); virtual voidROOT::Math::IGradientFunctionMultiDim::Gradient(const double* x, double* grad) const; virtual unsigned intNDim() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::GradFunctor&operator=(const ROOT::Math::GradFunctor& rhs). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const. Data Members; private:. auto_ptr<ROOT::Math::IGrad",MatchSource.WIKI,root/html532/ROOT__Math__GradFunctor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GradFunctor.html
https://root.cern/root/html532/ROOT__Math__GradFunctor.html:2079,Modifiability,Inherit,Inheritance,2079,"d int icoord = 0) const; virtual voidROOT::Math::IGradientFunctionMultiDim::FdF(const double* x, double& f, double* df) const; ROOT::Math::GradFunctorGradFunctor(); ROOT::Math::GradFunctorGradFunctor(const ROOT::Math::GradFunctor&); ROOT::Math::GradFunctorGradFunctor(void* p1, void* p2, unsigned int dim); ROOT::Math::GradFunctorGradFunctor(void* p1, unsigned int dim, const char* className, const char* methodName, const char* derivName); virtual voidROOT::Math::IGradientFunctionMultiDim::Gradient(const double* x, double* grad) const; virtual unsigned intNDim() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::GradFunctor&operator=(const ROOT::Math::GradFunctor& rhs). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const. Data Members; private:. auto_ptr<ROOT::Math::IGradientFunctionMultiDim>fImplpointer to base grad functor handler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunc * Clone() const; clone of the function handler (use copy-ctor). unsigned int NDim() const; constructor for multi-dimensional functions. double DoEval(const double* x) const. double DoDerivative(double x). GradFunctor(). Default constructor. {}. GradFunctor( const Func & f, unsigned int dim ). construct from a callable object of multi-dimension; implementing operator()(const double *x) and; Derivative(const double * x,icoord). {}. GradFunctor(const PtrObj& p, MemFn memFn, GradMemFn gradFn, unsigned int dim ). construct from a pointer to member function and member function types for function and derivative evaluations. {}. GradFunctor(void* p1, void* p2, unsigned int dim). construct for Gradient Functions of multi-dimension; Func gives the function evaluatiion, GradFunc the partial derivatives; The function dimension is required. { }. virtual ~GradFunctor(). Destructor (no operations). {}.  Author: L. Moneta Mon Nov 13 15:58:13",MatchSource.WIKI,root/html532/ROOT__Math__GradFunctor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GradFunctor.html
https://root.cern/root/html532/ROOT__Math__GradFunctor.html:2092,Modifiability,Inherit,Inherited,2092,"d int icoord = 0) const; virtual voidROOT::Math::IGradientFunctionMultiDim::FdF(const double* x, double& f, double* df) const; ROOT::Math::GradFunctorGradFunctor(); ROOT::Math::GradFunctorGradFunctor(const ROOT::Math::GradFunctor&); ROOT::Math::GradFunctorGradFunctor(void* p1, void* p2, unsigned int dim); ROOT::Math::GradFunctorGradFunctor(void* p1, unsigned int dim, const char* className, const char* methodName, const char* derivName); virtual voidROOT::Math::IGradientFunctionMultiDim::Gradient(const double* x, double* grad) const; virtual unsigned intNDim() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::GradFunctor&operator=(const ROOT::Math::GradFunctor& rhs). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const. Data Members; private:. auto_ptr<ROOT::Math::IGradientFunctionMultiDim>fImplpointer to base grad functor handler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunc * Clone() const; clone of the function handler (use copy-ctor). unsigned int NDim() const; constructor for multi-dimensional functions. double DoEval(const double* x) const. double DoDerivative(double x). GradFunctor(). Default constructor. {}. GradFunctor( const Func & f, unsigned int dim ). construct from a callable object of multi-dimension; implementing operator()(const double *x) and; Derivative(const double * x,icoord). {}. GradFunctor(const PtrObj& p, MemFn memFn, GradMemFn gradFn, unsigned int dim ). construct from a pointer to member function and member function types for function and derivative evaluations. {}. GradFunctor(void* p1, void* p2, unsigned int dim). construct for Gradient Functions of multi-dimension; Func gives the function evaluatiion, GradFunc the partial derivatives; The function dimension is required. { }. virtual ~GradFunctor(). Destructor (no operations). {}.  Author: L. Moneta Mon Nov 13 15:58:13",MatchSource.WIKI,root/html532/ROOT__Math__GradFunctor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GradFunctor.html
https://root.cern/root/html532/ROOT__Math__GradFunctor.html:409,Usability,simpl,simple,409,". ROOT::Math::GradFunctor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::GradFunctor. class ROOT::Math::GradFunctor: public ROOT::Math::IGradientFunctionMultiDim. Documentation for class Functor class.; It is used to wrap in a very simple and convenient way multi-dimensional function objects.; It can wrap all the following types:; <ul>; <li> any C++ callable object implemention double operator()( const double * ); <li> a free C function of type double ()(double * ); <li> a member function with the correct signature like Foo::Eval(const double * ).; In this case one pass the object pointer and a pointer to the member function (&Foo::Eval); </ul>; The function dimension is required when constructing the functor. @ingroup GenFunc. Function Members (Methods); public:. virtual~GradFunctor(); virtual ROOT::Math::GradFunctor::ImplBase*Clone() const; doubleROOT::Math::IGradientMultiDim::Derivative(const double* x, unsigned int icoord = 0) const; virtual voidROOT::Math::IGradientFunctionMultiDim::FdF(const double* x, double& f, double* df) const; ROOT::Math::GradFunctorGradFunctor(); ROOT::Math::GradFunctorGradFunctor(const ROOT::Math::GradFunctor&); ROOT::Math::GradFunctorGradFunctor(void* p1, void* p2, unsigned int dim); ROOT::Math::GradFunctorGradFunctor(void* p1, unsigned int dim, const char* className, const char* methodName, const char* derivName); virtual voidROOT::Math::IGradientFunctionMultiDim::Gradient(const double* x, double* grad) const; virtual unsigned intNDim() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::GradFunctor&operator=(const ROOT::Math::GradFunctor& rhs). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const. Data Members; private:. auto_ptr<ROOT::Math::IGrad",MatchSource.WIKI,root/html532/ROOT__Math__GradFunctor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GradFunctor.html
https://root.cern/root/html532/ROOT__Math__GradFunctor1D.html:398,Integrability,wrap,wrap,398,". ROOT::Math::GradFunctor1D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::GradFunctor1D. class ROOT::Math::GradFunctor1D: public ROOT::Math::IGradientFunctionOneDim. Documentation for class Functor class.; It is used to wrap in a very simple and convenient way multi-dimensional function objects.; It can wrap all the following types:; <ul>; <li> any C++ callable object implemention double operator()( const double * ); <li> a free C function of type double ()(double * ); <li> a member function with the correct signature like Foo::Eval(const double * ).; In this case one pass the object pointer and a pointer to the member function (&Foo::Eval); </ul>; The function dimension is required when constructing the functor. @ingroup GenFunc. Function Members (Methods); public:. virtual~GradFunctor1D(); virtual ROOT::Math::GradFunctor1D::ImplBase*Clone() const; doubleROOT::Math::IGradientOneDim::Derivative(double x) const; doubleROOT::Math::IGradientOneDim::Derivative(const double* x) const; virtual voidROOT::Math::IGradientFunctionOneDim::FdF(double x, double& f, double& df) const; ROOT::Math::GradFunctor1DGradFunctor1D(); ROOT::Math::GradFunctor1DGradFunctor1D(const ROOT::Math::GradFunctor1D&); ROOT::Math::GradFunctor1DGradFunctor1D(void* p1, void* p2); ROOT::Math::GradFunctor1DGradFunctor1D(void* p1, const char* className, const char* methodName, const char* derivName); voidROOT::Math::IGradientOneDim::Gradient(const double* x, double* g) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(double x) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(const double* x) const; ROOT::Math::GradFunctor1D&operator=(const ROOT::Math::GradFunctor1D& rhs). private:. virtual doubleDoDerivative(double x) const; virtual doubleDoEval(double x) const. Data Members; private:. auto_ptr<ROOT::Math::IGradient",MatchSource.WIKI,root/html532/ROOT__Math__GradFunctor1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GradFunctor1D.html
https://root.cern/root/html532/ROOT__Math__GradFunctor1D.html:483,Integrability,wrap,wrap,483,". ROOT::Math::GradFunctor1D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::GradFunctor1D. class ROOT::Math::GradFunctor1D: public ROOT::Math::IGradientFunctionOneDim. Documentation for class Functor class.; It is used to wrap in a very simple and convenient way multi-dimensional function objects.; It can wrap all the following types:; <ul>; <li> any C++ callable object implemention double operator()( const double * ); <li> a free C function of type double ()(double * ); <li> a member function with the correct signature like Foo::Eval(const double * ).; In this case one pass the object pointer and a pointer to the member function (&Foo::Eval); </ul>; The function dimension is required when constructing the functor. @ingroup GenFunc. Function Members (Methods); public:. virtual~GradFunctor1D(); virtual ROOT::Math::GradFunctor1D::ImplBase*Clone() const; doubleROOT::Math::IGradientOneDim::Derivative(double x) const; doubleROOT::Math::IGradientOneDim::Derivative(const double* x) const; virtual voidROOT::Math::IGradientFunctionOneDim::FdF(double x, double& f, double& df) const; ROOT::Math::GradFunctor1DGradFunctor1D(); ROOT::Math::GradFunctor1DGradFunctor1D(const ROOT::Math::GradFunctor1D&); ROOT::Math::GradFunctor1DGradFunctor1D(void* p1, void* p2); ROOT::Math::GradFunctor1DGradFunctor1D(void* p1, const char* className, const char* methodName, const char* derivName); voidROOT::Math::IGradientOneDim::Gradient(const double* x, double* g) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(double x) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(const double* x) const; ROOT::Math::GradFunctor1D&operator=(const ROOT::Math::GradFunctor1D& rhs). private:. virtual doubleDoDerivative(double x) const; virtual doubleDoEval(double x) const. Data Members; private:. auto_ptr<ROOT::Math::IGradient",MatchSource.WIKI,root/html532/ROOT__Math__GradFunctor1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GradFunctor1D.html
https://root.cern/root/html532/ROOT__Math__GradFunctor1D.html:2077,Modifiability,Inherit,Inheritance,2077," doubleROOT::Math::IGradientOneDim::Derivative(const double* x) const; virtual voidROOT::Math::IGradientFunctionOneDim::FdF(double x, double& f, double& df) const; ROOT::Math::GradFunctor1DGradFunctor1D(); ROOT::Math::GradFunctor1DGradFunctor1D(const ROOT::Math::GradFunctor1D&); ROOT::Math::GradFunctor1DGradFunctor1D(void* p1, void* p2); ROOT::Math::GradFunctor1DGradFunctor1D(void* p1, const char* className, const char* methodName, const char* derivName); voidROOT::Math::IGradientOneDim::Gradient(const double* x, double* g) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(double x) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(const double* x) const; ROOT::Math::GradFunctor1D&operator=(const ROOT::Math::GradFunctor1D& rhs). private:. virtual doubleDoDerivative(double x) const; virtual doubleDoEval(double x) const. Data Members; private:. auto_ptr<ROOT::Math::IGradientFunctionOneDim>fImplpointer to base gradient functor handler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunc * Clone() const; clone of the function handler (use copy-ctor). double DoEval(double x) const. double DoDerivative(double x) const. GradFunctor1D(). Default constructor. {}. GradFunctor1D(const ROOT::Math::GradFunctor1D& ). construct from an object with the right signature; implementing both operator() (double x) and Derivative(double x). {}. GradFunctor1D(const PtrObj& p, MemFn memFn, GradMemFn gradFn). construct from a pointer to class and two pointers to member functions, one for; the function evaluation and the other for the derivative.; The member functions must take a double as argument and return a double. {}. GradFunctor1D(void* p1, void* p2). construct from two 1D function objects. {}. virtual ~GradFunctor1D(). Destructor (no operations). {}.  Author: L. Moneta Mon Nov 13 15:58:13 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: Functor.h 33180 2010-04-25 10:14:07Z monet",MatchSource.WIKI,root/html532/ROOT__Math__GradFunctor1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GradFunctor1D.html
https://root.cern/root/html532/ROOT__Math__GradFunctor1D.html:2090,Modifiability,Inherit,Inherited,2090," doubleROOT::Math::IGradientOneDim::Derivative(const double* x) const; virtual voidROOT::Math::IGradientFunctionOneDim::FdF(double x, double& f, double& df) const; ROOT::Math::GradFunctor1DGradFunctor1D(); ROOT::Math::GradFunctor1DGradFunctor1D(const ROOT::Math::GradFunctor1D&); ROOT::Math::GradFunctor1DGradFunctor1D(void* p1, void* p2); ROOT::Math::GradFunctor1DGradFunctor1D(void* p1, const char* className, const char* methodName, const char* derivName); voidROOT::Math::IGradientOneDim::Gradient(const double* x, double* g) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(double x) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(const double* x) const; ROOT::Math::GradFunctor1D&operator=(const ROOT::Math::GradFunctor1D& rhs). private:. virtual doubleDoDerivative(double x) const; virtual doubleDoEval(double x) const. Data Members; private:. auto_ptr<ROOT::Math::IGradientFunctionOneDim>fImplpointer to base gradient functor handler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunc * Clone() const; clone of the function handler (use copy-ctor). double DoEval(double x) const. double DoDerivative(double x) const. GradFunctor1D(). Default constructor. {}. GradFunctor1D(const ROOT::Math::GradFunctor1D& ). construct from an object with the right signature; implementing both operator() (double x) and Derivative(double x). {}. GradFunctor1D(const PtrObj& p, MemFn memFn, GradMemFn gradFn). construct from a pointer to class and two pointers to member functions, one for; the function evaluation and the other for the derivative.; The member functions must take a double as argument and return a double. {}. GradFunctor1D(void* p1, void* p2). construct from two 1D function objects. {}. virtual ~GradFunctor1D(). Destructor (no operations). {}.  Author: L. Moneta Mon Nov 13 15:58:13 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: Functor.h 33180 2010-04-25 10:14:07Z monet",MatchSource.WIKI,root/html532/ROOT__Math__GradFunctor1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GradFunctor1D.html
https://root.cern/root/html532/ROOT__Math__GradFunctor1D.html:413,Usability,simpl,simple,413,". ROOT::Math::GradFunctor1D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::GradFunctor1D. class ROOT::Math::GradFunctor1D: public ROOT::Math::IGradientFunctionOneDim. Documentation for class Functor class.; It is used to wrap in a very simple and convenient way multi-dimensional function objects.; It can wrap all the following types:; <ul>; <li> any C++ callable object implemention double operator()( const double * ); <li> a free C function of type double ()(double * ); <li> a member function with the correct signature like Foo::Eval(const double * ).; In this case one pass the object pointer and a pointer to the member function (&Foo::Eval); </ul>; The function dimension is required when constructing the functor. @ingroup GenFunc. Function Members (Methods); public:. virtual~GradFunctor1D(); virtual ROOT::Math::GradFunctor1D::ImplBase*Clone() const; doubleROOT::Math::IGradientOneDim::Derivative(double x) const; doubleROOT::Math::IGradientOneDim::Derivative(const double* x) const; virtual voidROOT::Math::IGradientFunctionOneDim::FdF(double x, double& f, double& df) const; ROOT::Math::GradFunctor1DGradFunctor1D(); ROOT::Math::GradFunctor1DGradFunctor1D(const ROOT::Math::GradFunctor1D&); ROOT::Math::GradFunctor1DGradFunctor1D(void* p1, void* p2); ROOT::Math::GradFunctor1DGradFunctor1D(void* p1, const char* className, const char* methodName, const char* derivName); voidROOT::Math::IGradientOneDim::Gradient(const double* x, double* g) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(double x) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(const double* x) const; ROOT::Math::GradFunctor1D&operator=(const ROOT::Math::GradFunctor1D& rhs). private:. virtual doubleDoDerivative(double x) const; virtual doubleDoEval(double x) const. Data Members; private:. auto_ptr<ROOT::Math::IGradient",MatchSource.WIKI,root/html532/ROOT__Math__GradFunctor1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GradFunctor1D.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:4850,Availability,Error,Error,4850,"ptions& opt); virtual voidSetRelTolerance(double relTolerance); virtual intStatus() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. protected:. boolCheckFunction(). private:. ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::GSLIntegrator&); ROOT::Math::GSLIntegrator&operator=(const ROOT::Math::GSLIntegrator&). Data Members; private:. doublefAbsTol; doublefError; ROOT::Math::GSLFunctionWrapper*fFunction; size_tfMaxIntervals; intfNEval; doublefRelTol; doublefResult; ROOT::Math::Integration::GKRulefRule; size_tfSize; intfStatus; ROOT::Math::IntegrationOneDim::TypefType; ROOT::Math::GSLIntegrationWorkspace*fWorkspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructors; Default constructor of GSL Integrator for Adaptive Singular integration. @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @par",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:4888,Availability,Error,Error,4888,"ptions& opt); virtual voidSetRelTolerance(double relTolerance); virtual intStatus() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. protected:. boolCheckFunction(). private:. ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::GSLIntegrator&); ROOT::Math::GSLIntegrator&operator=(const ROOT::Math::GSLIntegrator&). Data Members; private:. doublefAbsTol; doublefError; ROOT::Math::GSLFunctionWrapper*fFunction; size_tfMaxIntervals; intfNEval; doublefRelTol; doublefResult; ROOT::Math::Integration::GKRulefRule; size_tfSize; intfStatus; ROOT::Math::IntegrationOneDim::TypefType; ROOT::Math::GSLIntegrationWorkspace*fWorkspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructors; Default constructor of GSL Integrator for Adaptive Singular integration. @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @par",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:5311,Availability,Error,Error,5311,"OOT::Math::GSLFunctionWrapper*fFunction; size_tfMaxIntervals; intfNEval; doublefRelTol; doublefResult; ROOT::Math::Integration::GKRulefRule; size_tfSize; intfStatus; ROOT::Math::IntegrationOneDim::TypefType; ROOT::Math::GSLIntegrationWorkspace*fWorkspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructors; Default constructor of GSL Integrator for Adaptive Singular integration. @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (need a char * instead of enumerations). @param type type of integration. The possible types are defined in the Int",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:5349,Availability,Error,Error,5349,"OOT::Math::GSLFunctionWrapper*fFunction; size_tfMaxIntervals; intfNEval; doublefRelTol; doublefResult; ROOT::Math::Integration::GKRulefRule; size_tfSize; intfStatus; ROOT::Math::IntegrationOneDim::TypefType; ROOT::Math::GSLIntegrationWorkspace*fWorkspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructors; Default constructor of GSL Integrator for Adaptive Singular integration. @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (need a char * instead of enumerations). @param type type of integration. The possible types are defined in the Int",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:5868,Availability,Error,Error,5868,"am relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (need a char * instead of enumerations). @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:5906,Availability,Error,Error,5906,"am relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (need a char * instead of enumerations). @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:6410,Availability,Error,Error,6410,"r of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (need a char * instead of enumerations). @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0). Set function from a GSL pointer function type. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); methods using IGenFunction. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @p",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:6448,Availability,Error,Error,6448,"r of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (need a char * instead of enumerations). @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0). Set function from a GSL pointer function type. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); methods using IGenFunction. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @p",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:12417,Availability,Error,Error,12417,"on function; @param p pointer to the Parameters of the function; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(ROOT::Math::GSLFuncPointer f, void* p). evaluate the Integral of a function f over the infinite interval (-inf,+inf) passing a free function pointer. double IntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer. double IntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) passing a free function pointer. double Integral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts). evaluate the Integral of a function f with knows singular points over the over a defined interval passing a free function pointer. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. void SetAbsTolerance(double absTolerance). set the desired absolute Error. void SetIntegrationRule(ROOT::Math::Integration::GKRule ). set the integration rule (Gauss-Kronrod rule).; The possible rules are defined in the Integration::GKRule enumeration.; The integration rule can be modified only for ADAPTIVE type integrations. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. IntegrationOneDim::Type GetType() const; get type name. { return fType; }. const char * GetTypeName() const. return the name. bool CheckFunction(); internal method to check validi",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:12468,Availability,Error,Error,12468,"f the function; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(ROOT::Math::GSLFuncPointer f, void* p). evaluate the Integral of a function f over the infinite interval (-inf,+inf) passing a free function pointer. double IntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer. double IntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) passing a free function pointer. double Integral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts). evaluate the Integral of a function f with knows singular points over the over a defined interval passing a free function pointer. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. void SetAbsTolerance(double absTolerance). set the desired absolute Error. void SetIntegrationRule(ROOT::Math::Integration::GKRule ). set the integration rule (Gauss-Kronrod rule).; The possible rules are defined in the Integration::GKRule enumeration.; The integration rule can be modified only for ADAPTIVE type integrations. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. IntegrationOneDim::Type GetType() const; get type name. { return fType; }. const char * GetTypeName() const. return the name. bool CheckFunction(); internal method to check validity of GSL function pointer.  Last changed: root/",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:12539,Availability,Error,Error,12539,"of the integration interval. double Integral(ROOT::Math::GSLFuncPointer f, void* p). evaluate the Integral of a function f over the infinite interval (-inf,+inf) passing a free function pointer. double IntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer. double IntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) passing a free function pointer. double Integral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts). evaluate the Integral of a function f with knows singular points over the over a defined interval passing a free function pointer. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. void SetAbsTolerance(double absTolerance). set the desired absolute Error. void SetIntegrationRule(ROOT::Math::Integration::GKRule ). set the integration rule (Gauss-Kronrod rule).; The possible rules are defined in the Integration::GKRule enumeration.; The integration rule can be modified only for ADAPTIVE type integrations. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. IntegrationOneDim::Type GetType() const; get type name. { return fType; }. const char * GetTypeName() const. return the name. bool CheckFunction(); internal method to check validity of GSL function pointer.  Last changed: root/mathmore:$Id: GSLIntegrator.h 36764 2010-11-19 10:02:00Z moneta $  Last generated: 201",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:12824,Availability,Error,Error,12824,"a free function pointer. double IntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer. double IntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) passing a free function pointer. double Integral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts). evaluate the Integral of a function f with knows singular points over the over a defined interval passing a free function pointer. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. void SetAbsTolerance(double absTolerance). set the desired absolute Error. void SetIntegrationRule(ROOT::Math::Integration::GKRule ). set the integration rule (Gauss-Kronrod rule).; The possible rules are defined in the Integration::GKRule enumeration.; The integration rule can be modified only for ADAPTIVE type integrations. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. IntegrationOneDim::Type GetType() const; get type name. { return fType; }. const char * GetTypeName() const. return the name. bool CheckFunction(); internal method to check validity of GSL function pointer.  Last changed: root/mathmore:$Id: GSLIntegrator.h 36764 2010-11-19 10:02:00Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:12899,Availability,Error,Error,12899,"a free function pointer. double IntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer. double IntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) passing a free function pointer. double Integral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts). evaluate the Integral of a function f with knows singular points over the over a defined interval passing a free function pointer. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. void SetAbsTolerance(double absTolerance). set the desired absolute Error. void SetIntegrationRule(ROOT::Math::Integration::GKRule ). set the integration rule (Gauss-Kronrod rule).; The possible rules are defined in the Integration::GKRule enumeration.; The integration rule can be modified only for ADAPTIVE type integrations. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. IntegrationOneDim::Type GetType() const; get type name. { return fType; }. const char * GetTypeName() const. return the name. bool CheckFunction(); internal method to check validity of GSL function pointer.  Last changed: root/mathmore:$Id: GSLIntegrator.h 36764 2010-11-19 10:02:00Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:375,Deployability,integrat,integration,375,". ROOT::Math::GSLIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:442,Deployability,integrat,integration,442,". ROOT::Math::GSLIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:542,Deployability,integrat,integration,542,". ROOT::Math::GSLIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:625,Deployability,integrat,integration,625,". ROOT::Math::GSLIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:667,Deployability,integrat,integration,667,". ROOT::Math::GSLIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:746,Deployability,integrat,integration,746,". ROOT::Math::GSLIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:785,Deployability,Integrat,Integration,785,". ROOT::Math::GSLIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:872,Deployability,integrat,integration,872,". ROOT::Math::GSLIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:990,Deployability,integrat,integration,990,". ROOT::Math::GSLIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:1043,Deployability,integrat,integration,1043,"lass Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::I",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:1091,Deployability,Integrat,Integration,1091,"lass Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::I",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:1158,Deployability,integrat,integration,1158,"ATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::IntegrationOneDim:",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:1565,Deployability,integrat,integration,1565,"ortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, const ROOT::Math::Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); virtual doubleIntegral(); doubleIntegral(const ROOT::Math::IGenFunction& f); virtual doubleIntegral(const vector<",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:1665,Deployability,Integrat,Integration,1665,"d. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, const ROOT::Math::Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); virtual doubleIntegral(); doubleIntegral(const ROOT::Math::IGenFunction& f); virtual doubleIntegral(const vector<double>& pts); doubleIntegral(const ROOT::Math::IGenFunction& f, const vec",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:1708,Deployability,Integrat,Integration,1708,"e ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, const ROOT::Math::Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); virtual doubleIntegral(); doubleIntegral(const ROOT::Math::IGenFunction& f); virtual doubleIntegral(const vector<double>& pts); doubleIntegral(const ROOT::Math::IGenFunction& f, const vector<double>& pts); virtual doubleIntegral(double a, double b",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:1824,Deployability,Integrat,IntegrationOneDim,1824,"type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, const ROOT::Math::Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); virtual doubleIntegral(); doubleIntegral(const ROOT::Math::IGenFunction& f); virtual doubleIntegral(const vector<double>& pts); doubleIntegral(const ROOT::Math::IGenFunction& f, const vector<double>& pts); virtual doubleIntegral(double a, double b); doubleIntegral(ROOT::Math::GSLFuncPointer f, void* p); doubleIntegral(const ROOT::Math::IGenFunction& f, double a, double b); doubleIntegral(RO",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:2058,Deployability,Integrat,IntegrationOneDim,2058,"IVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, const ROOT::Math::Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); virtual doubleIntegral(); doubleIntegral(const ROOT::Math::IGenFunction& f); virtual doubleIntegral(const vector<double>& pts); doubleIntegral(const ROOT::Math::IGenFunction& f, const vector<double>& pts); virtual doubleIntegral(double a, double b); doubleIntegral(ROOT::Math::GSLFuncPointer f, void* p); doubleIntegral(const ROOT::Math::IGenFunction& f, double a, double b); doubleIntegral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts); doubleIntegral(ROOT::Math::GSLFuncPointer f, void* p, double a, double b); virtual doubleIntegralCauchy(double",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:2211,Deployability,Integrat,IntegrationOneDim,2211,"nges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, const ROOT::Math::Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); virtual doubleIntegral(); doubleIntegral(const ROOT::Math::IGenFunction& f); virtual doubleIntegral(const vector<double>& pts); doubleIntegral(const ROOT::Math::IGenFunction& f, const vector<double>& pts); virtual doubleIntegral(double a, double b); doubleIntegral(ROOT::Math::GSLFuncPointer f, void* p); doubleIntegral(const ROOT::Math::IGenFunction& f, double a, double b); doubleIntegral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts); doubleIntegral(ROOT::Math::GSLFuncPointer f, void* p, double a, double b); virtual doubleIntegralCauchy(double a, double b, double c); doubleIntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c); virtual doubleIntegralLow(double b); doubleIntegralLow(const RO",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:2259,Deployability,Integrat,Integration,2259,"nges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, const ROOT::Math::Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); virtual doubleIntegral(); doubleIntegral(const ROOT::Math::IGenFunction& f); virtual doubleIntegral(const vector<double>& pts); doubleIntegral(const ROOT::Math::IGenFunction& f, const vector<double>& pts); virtual doubleIntegral(double a, double b); doubleIntegral(ROOT::Math::GSLFuncPointer f, void* p); doubleIntegral(const ROOT::Math::IGenFunction& f, double a, double b); doubleIntegral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts); doubleIntegral(ROOT::Math::GSLFuncPointer f, void* p, double a, double b); virtual doubleIntegralCauchy(double a, double b, double c); doubleIntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c); virtual doubleIntegralLow(double b); doubleIntegralLow(const RO",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:3523,Deployability,Integrat,IntegratorOneDimOptionsOptions,3523,"Integrator(const ROOT::Math::IntegrationOneDim::Type type, const ROOT::Math::Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); virtual doubleIntegral(); doubleIntegral(const ROOT::Math::IGenFunction& f); virtual doubleIntegral(const vector<double>& pts); doubleIntegral(const ROOT::Math::IGenFunction& f, const vector<double>& pts); virtual doubleIntegral(double a, double b); doubleIntegral(ROOT::Math::GSLFuncPointer f, void* p); doubleIntegral(const ROOT::Math::IGenFunction& f, double a, double b); doubleIntegral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts); doubleIntegral(ROOT::Math::GSLFuncPointer f, void* p, double a, double b); virtual doubleIntegralCauchy(double a, double b, double c); doubleIntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c); virtual doubleIntegralLow(double b); doubleIntegralLow(const ROOT::Math::IGenFunction& f, double b); doubleIntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b); virtual doubleIntegralUp(double a); doubleIntegralUp(const ROOT::Math::IGenFunction& f, double a); doubleIntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a); virtual intNEval() const; virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTolerance); virtual voidSetFunction(const ROOT::Math::IGenFunction& f); voidSetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0); voidSetIntegrationRule(ROOT::Math::Integration::GKRule); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double relTolerance); virtual intStatus() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. protected:. boolCheckFunction(). private:. ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::GSLIntegrator&); ROO",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:3798,Deployability,Integrat,Integration,3798,"Integrator(const ROOT::Math::IntegrationOneDim::Type type, const ROOT::Math::Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); virtual doubleIntegral(); doubleIntegral(const ROOT::Math::IGenFunction& f); virtual doubleIntegral(const vector<double>& pts); doubleIntegral(const ROOT::Math::IGenFunction& f, const vector<double>& pts); virtual doubleIntegral(double a, double b); doubleIntegral(ROOT::Math::GSLFuncPointer f, void* p); doubleIntegral(const ROOT::Math::IGenFunction& f, double a, double b); doubleIntegral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts); doubleIntegral(ROOT::Math::GSLFuncPointer f, void* p, double a, double b); virtual doubleIntegralCauchy(double a, double b, double c); doubleIntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c); virtual doubleIntegralLow(double b); doubleIntegralLow(const ROOT::Math::IGenFunction& f, double b); doubleIntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b); virtual doubleIntegralUp(double a); doubleIntegralUp(const ROOT::Math::IGenFunction& f, double a); doubleIntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a); virtual intNEval() const; virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTolerance); virtual voidSetFunction(const ROOT::Math::IGenFunction& f); voidSetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0); voidSetIntegrationRule(ROOT::Math::Integration::GKRule); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double relTolerance); virtual intStatus() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. protected:. boolCheckFunction(). private:. ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::GSLIntegrator&); ROO",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:3861,Deployability,Integrat,IntegratorOneDimOptions,3861,"Integrator(const ROOT::Math::IntegrationOneDim::Type type, const ROOT::Math::Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); virtual doubleIntegral(); doubleIntegral(const ROOT::Math::IGenFunction& f); virtual doubleIntegral(const vector<double>& pts); doubleIntegral(const ROOT::Math::IGenFunction& f, const vector<double>& pts); virtual doubleIntegral(double a, double b); doubleIntegral(ROOT::Math::GSLFuncPointer f, void* p); doubleIntegral(const ROOT::Math::IGenFunction& f, double a, double b); doubleIntegral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts); doubleIntegral(ROOT::Math::GSLFuncPointer f, void* p, double a, double b); virtual doubleIntegralCauchy(double a, double b, double c); doubleIntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c); virtual doubleIntegralLow(double b); doubleIntegralLow(const ROOT::Math::IGenFunction& f, double b); doubleIntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b); virtual doubleIntegralUp(double a); doubleIntegralUp(const ROOT::Math::IGenFunction& f, double a); doubleIntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a); virtual intNEval() const; virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTolerance); virtual voidSetFunction(const ROOT::Math::IGenFunction& f); voidSetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0); voidSetIntegrationRule(ROOT::Math::Integration::GKRule); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double relTolerance); virtual intStatus() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. protected:. boolCheckFunction(). private:. ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::GSLIntegrator&); ROO",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:3989,Deployability,Integrat,IntegrationOneDim,3989,"Integrator(const ROOT::Math::IntegrationOneDim::Type type, const ROOT::Math::Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); virtual doubleIntegral(); doubleIntegral(const ROOT::Math::IGenFunction& f); virtual doubleIntegral(const vector<double>& pts); doubleIntegral(const ROOT::Math::IGenFunction& f, const vector<double>& pts); virtual doubleIntegral(double a, double b); doubleIntegral(ROOT::Math::GSLFuncPointer f, void* p); doubleIntegral(const ROOT::Math::IGenFunction& f, double a, double b); doubleIntegral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts); doubleIntegral(ROOT::Math::GSLFuncPointer f, void* p, double a, double b); virtual doubleIntegralCauchy(double a, double b, double c); doubleIntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c); virtual doubleIntegralLow(double b); doubleIntegralLow(const ROOT::Math::IGenFunction& f, double b); doubleIntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b); virtual doubleIntegralUp(double a); doubleIntegralUp(const ROOT::Math::IGenFunction& f, double a); doubleIntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a); virtual intNEval() const; virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTolerance); virtual voidSetFunction(const ROOT::Math::IGenFunction& f); voidSetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0); voidSetIntegrationRule(ROOT::Math::Integration::GKRule); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double relTolerance); virtual intStatus() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. protected:. boolCheckFunction(). private:. ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::GSLIntegrator&); ROO",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:4420,Deployability,Integrat,Integration,4420,"ntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a); virtual intNEval() const; virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTolerance); virtual voidSetFunction(const ROOT::Math::IGenFunction& f); voidSetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0); voidSetIntegrationRule(ROOT::Math::Integration::GKRule); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double relTolerance); virtual intStatus() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. protected:. boolCheckFunction(). private:. ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::GSLIntegrator&); ROOT::Math::GSLIntegrator&operator=(const ROOT::Math::GSLIntegrator&). Data Members; private:. doublefAbsTol; doublefError; ROOT::Math::GSLFunctionWrapper*fFunction; size_tfMaxIntervals; intfNEval; doublefRelTol; doublefResult; ROOT::Math::Integration::GKRulefRule; size_tfSize; intfStatus; ROOT::Math::IntegrationOneDim::TypefType; ROOT::Math::GSLIntegrationWorkspace*fWorkspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructors; Default constructor of GSL Integrator for Adaptive Singular integration. @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(co",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:4483,Deployability,Integrat,IntegrationOneDim,4483,"ntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a); virtual intNEval() const; virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTolerance); virtual voidSetFunction(const ROOT::Math::IGenFunction& f); voidSetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0); voidSetIntegrationRule(ROOT::Math::Integration::GKRule); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double relTolerance); virtual intStatus() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. protected:. boolCheckFunction(). private:. ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::GSLIntegrator&); ROOT::Math::GSLIntegrator&operator=(const ROOT::Math::GSLIntegrator&). Data Members; private:. doublefAbsTol; doublefError; ROOT::Math::GSLFunctionWrapper*fFunction; size_tfMaxIntervals; intfNEval; doublefRelTol; doublefResult; ROOT::Math::Integration::GKRulefRule; size_tfSize; intfStatus; ROOT::Math::IntegrationOneDim::TypefType; ROOT::Math::GSLIntegrationWorkspace*fWorkspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructors; Default constructor of GSL Integrator for Adaptive Singular integration. @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(co",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:4773,Deployability,Integrat,Integrator,4773,"id* p = 0); voidSetIntegrationRule(ROOT::Math::Integration::GKRule); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double relTolerance); virtual intStatus() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. protected:. boolCheckFunction(). private:. ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::GSLIntegrator&); ROOT::Math::GSLIntegrator&operator=(const ROOT::Math::GSLIntegrator&). Data Members; private:. doublefAbsTol; doublefError; ROOT::Math::GSLFunctionWrapper*fFunction; size_tfMaxIntervals; intfNEval; doublefRelTol; doublefResult; ROOT::Math::Integration::GKRulefRule; size_tfSize; intfStatus; ROOT::Math::IntegrationOneDim::TypefType; ROOT::Math::GSLIntegrationWorkspace*fWorkspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructors; Default constructor of GSL Integrator for Adaptive Singular integration. @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Inte",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:4806,Deployability,integrat,integration,4806,"id* p = 0); voidSetIntegrationRule(ROOT::Math::Integration::GKRule); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double relTolerance); virtual intStatus() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. protected:. boolCheckFunction(). private:. ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::GSLIntegrator&); ROOT::Math::GSLIntegrator&operator=(const ROOT::Math::GSLIntegrator&). Data Members; private:. doublefAbsTol; doublefError; ROOT::Math::GSLFunctionWrapper*fFunction; size_tfMaxIntervals; intfNEval; doublefRelTol; doublefResult; ROOT::Math::Integration::GKRulefRule; size_tfSize; intfStatus; ROOT::Math::IntegrationOneDim::TypefType; ROOT::Math::GSLIntegrationWorkspace*fWorkspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructors; Default constructor of GSL Integrator for Adaptive Singular integration. @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Inte",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:4972,Deployability,Integrat,IntegrationOneDim,4972,"OT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. protected:. boolCheckFunction(). private:. ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::GSLIntegrator&); ROOT::Math::GSLIntegrator&operator=(const ROOT::Math::GSLIntegrator&). Data Members; private:. doublefAbsTol; doublefError; ROOT::Math::GSLFunctionWrapper*fFunction; size_tfMaxIntervals; intfNEval; doublefRelTol; doublefResult; ROOT::Math::Integration::GKRulefRule; size_tfSize; intfStatus; ROOT::Math::IntegrationOneDim::TypefType; ROOT::Math::GSLIntegrationWorkspace*fWorkspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructors; Default constructor of GSL Integrator for Adaptive Singular integration. @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const ch",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:5087,Deployability,Integrat,Integrator,5087,"st. protected:. boolCheckFunction(). private:. ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::GSLIntegrator&); ROOT::Math::GSLIntegrator&operator=(const ROOT::Math::GSLIntegrator&). Data Members; private:. doublefAbsTol; doublefError; ROOT::Math::GSLFunctionWrapper*fFunction; size_tfMaxIntervals; intfNEval; doublefRelTol; doublefResult; ROOT::Math::Integration::GKRulefRule; size_tfSize; intfStatus; ROOT::Math::IntegrationOneDim::TypefType; ROOT::Math::GSLIntegrationWorkspace*fWorkspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructors; Default constructor of GSL Integrator for Adaptive Singular integration. @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of ",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:5123,Deployability,integrat,integration,5123,"egrator(const ROOT::Math::GSLIntegrator&); ROOT::Math::GSLIntegrator&operator=(const ROOT::Math::GSLIntegrator&). Data Members; private:. doublefAbsTol; doublefError; ROOT::Math::GSLFunctionWrapper*fFunction; size_tfMaxIntervals; intfNEval; doublefRelTol; doublefResult; ROOT::Math::Integration::GKRulefRule; size_tfSize; intfStatus; ROOT::Math::IntegrationOneDim::TypefType; ROOT::Math::GSLIntegrationWorkspace*fWorkspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructors; Default constructor of GSL Integrator for Adaptive Singular integration. @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 ",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:5198,Deployability,integrat,integration,5198,"SLIntegrator&operator=(const ROOT::Math::GSLIntegrator&). Data Members; private:. doublefAbsTol; doublefError; ROOT::Math::GSLFunctionWrapper*fFunction; size_tfMaxIntervals; intfNEval; doublefRelTol; doublefResult; ROOT::Math::Integration::GKRulefRule; size_tfSize; intfStatus; ROOT::Math::IntegrationOneDim::TypefType; ROOT::Math::GSLIntegrationWorkspace*fWorkspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructors; Default constructor of GSL Integrator for Adaptive Singular integration. @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (nee",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:5249,Deployability,Integrat,Integration,5249,"OOT::Math::GSLFunctionWrapper*fFunction; size_tfMaxIntervals; intfNEval; doublefRelTol; doublefResult; ROOT::Math::Integration::GKRulefRule; size_tfSize; intfStatus; ROOT::Math::IntegrationOneDim::TypefType; ROOT::Math::GSLIntegrationWorkspace*fWorkspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructors; Default constructor of GSL Integrator for Adaptive Singular integration. @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (need a char * instead of enumerations). @param type type of integration. The possible types are defined in the Int",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:5421,Deployability,Integrat,Integration,5421,"ize_tfSize; intfStatus; ROOT::Math::IntegrationOneDim::TypefType; ROOT::Math::GSLIntegrationWorkspace*fWorkspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructors; Default constructor of GSL Integrator for Adaptive Singular integration. @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (need a char * instead of enumerations). @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative ",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:5451,Deployability,Integrat,Integration,5451,"ize_tfSize; intfStatus; ROOT::Math::IntegrationOneDim::TypefType; ROOT::Math::GSLIntegrationWorkspace*fWorkspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructors; Default constructor of GSL Integrator for Adaptive Singular integration. @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (need a char * instead of enumerations). @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative ",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:5571,Deployability,Integrat,Integrator,5571,"lass Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructors; Default constructor of GSL Integrator for Adaptive Singular integration. @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (need a char * instead of enumerations). @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(con",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:5603,Deployability,integrat,integration,5603,"Members; Includes; Libraries. Function documentation; GSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructors; Default constructor of GSL Integrator for Adaptive Singular integration. @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (need a char * instead of enumerations). @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disa",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:5654,Deployability,Integrat,Integration,5654,"(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructors; Default constructor of GSL Integrator for Adaptive Singular integration. @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (need a char * instead of enumerations). @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLInteg",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:5747,Deployability,Integrat,Integration,5747,"tors; Default constructor of GSL Integrator for Adaptive Singular integration. @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (need a char * instead of enumerations). @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template met",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:5804,Deployability,Integrat,Integration,5804,"am relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (need a char * instead of enumerations). @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:6063,Deployability,Integrat,Integrator,6063," = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (need a char * instead of enumerations). @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0). Set fu",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:6099,Deployability,integrat,integration,6099,"ule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (need a char * instead of enumerations). @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0). Set function from a GSL pointer function type. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); methods using IGenFunct",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:6251,Deployability,integrat,integration,6251,"he Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (need a char * instead of enumerations). @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0). Set function from a GSL pointer function type. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); methods using IGenFunction. evaluate the Integral of a function f over the defined interval (a,b); @param f integratio",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:6302,Deployability,Integrat,Integration,6302,"r of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (need a char * instead of enumerations). @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0). Set function from a GSL pointer function type. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); methods using IGenFunction. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @p",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:6796,Deployability,integrat,integration,6796,"ined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (need a char * instead of enumerations). @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0). Set function from a GSL pointer function type. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); methods using IGenFunction. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralCauchy(double a, double b, double c). 	evaluate the Cauchy principal value of the integral of a previously defined function f ov",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:6827,Deployability,integrat,integration,6827,"ion; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (need a char * instead of enumerations). @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0). Set function from a GSL pointer function type. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); methods using IGenFunction. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralCauchy(double a, double b, double c). 	evaluate the Cauchy principal value of the integral of a previously defined function f over; the defined interval (a,b) with a sin",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:7237,Deployability,integrat,integration,7237,"stead of enumerations). @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0). Set function from a GSL pointer function type. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); methods using IGenFunction. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralCauchy(double a, double b, double c). 	evaluate the Cauchy principal value of the integral of a previously defined function f over; the defined interval (a,b) with a singularity at c; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). 	evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b); with a singularity at c; @param f integration function. The function type mus",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:7357,Deployability,integrat,integration,7357,"e Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0). Set function from a GSL pointer function type. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); methods using IGenFunction. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralCauchy(double a, double b, double c). 	evaluate the Cauchy principal value of the integral of a previously defined function f over; the defined interval (a,b) with a singularity at c; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). 	evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b); with a singularity at c; @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower interval value; @param b lower interval value; @param c singular value o",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:7407,Deployability,integrat,integration,7407,"e Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0). Set function from a GSL pointer function type. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); methods using IGenFunction. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralCauchy(double a, double b, double c). 	evaluate the Cauchy principal value of the integral of a previously defined function f over; the defined interval (a,b) with a singularity at c; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). 	evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b); with a singularity at c; @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower interval value; @param b lower interval value; @param c singular value o",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:7557,Deployability,integrat,integration,7557,"); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0). Set function from a GSL pointer function type. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); methods using IGenFunction. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralCauchy(double a, double b, double c). 	evaluate the Cauchy principal value of the integral of a previously defined function f over; the defined interval (a,b) with a singularity at c; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). 	evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b); with a singularity at c; @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. T",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:8164,Deployability,integrat,integration,8164,", double a, double b); methods using IGenFunction. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralCauchy(double a, double b, double c). 	evaluate the Cauchy principal value of the integral of a previously defined function f over; the defined interval (a,b) with a singularity at c; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). 	evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b); with a singularity at c; @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. double Integral(double a, double b). evaluate the Integral of a function f with known singular points over the defined Integral (a,b); @param f integration fu",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:8501,Deployability,integrat,integration,8501,"f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralCauchy(double a, double b, double c). 	evaluate the Cauchy principal value of the integral of a previously defined function f over; the defined interval (a,b) with a singularity at c; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). 	evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b); with a singularity at c; @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. double Integral(double a, double b). evaluate the Integral of a function f with known singular points over the defined Integral (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(double a, double b); evaluate using ca",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:8621,Deployability,integrat,integration,8621," function type must implement the mathlib::IGenFunction interface. double IntegralCauchy(double a, double b, double c). 	evaluate the Cauchy principal value of the integral of a previously defined function f over; the defined interval (a,b) with a singularity at c; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). 	evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b); with a singularity at c; @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. double Integral(double a, double b). evaluate the Integral of a function f with known singular points over the defined Integral (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(double a, double b); evaluate using cached function. evaluate the Integral over the defined interval (a,b) using the function previously set with GSLInte",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:8806,Deployability,integrat,integration,8806,"sly defined function f over; the defined interval (a,b) with a singularity at c; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). 	evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b); with a singularity at c; @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. double Integral(double a, double b). evaluate the Integral of a function f with known singular points over the defined Integral (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(double a, double b); evaluate using cached function. evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(). evaluate the Integral over the infinit",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:8926,Deployability,integrat,integration,8926," lower interval value; @param c singular value of f. double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). 	evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b); with a singularity at c; @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. double Integral(double a, double b). evaluate the Integral of a function f with known singular points over the defined Integral (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(double a, double b); evaluate using cached function. evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(). evaluate the Integral over the infinite interval (-inf,+inf) using the function previously set with GSLIntegrator::SetFunction method. double IntegralUp(doubl",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:9092,Deployability,integrat,integration,9092," principal value of the integral of a function f over the defined interval (a,b); with a singularity at c; @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. double Integral(double a, double b). evaluate the Integral of a function f with known singular points over the defined Integral (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(double a, double b); evaluate using cached function. evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(). evaluate the Integral over the infinite interval (-inf,+inf) using the function previously set with GSLIntegrator::SetFunction method. double IntegralUp(double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) using the function previously set with GSLIntegrator::SetFunction method.; @p",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:9350,Deployability,integrat,integration,9350,"uble IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. double Integral(double a, double b). evaluate the Integral of a function f with known singular points over the defined Integral (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(double a, double b); evaluate using cached function. evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(). evaluate the Integral over the infinite interval (-inf,+inf) using the function previously set with GSLIntegrator::SetFunction method. double IntegralUp(double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) using the function previously set with GSLIntegrator::SetFunction method.; @param a lower value of the integration interval. double IntegralLow(double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) using the function previously set with GSLIntegrator::SetFunction method.; @param b upper value of the integration interval. double Inte",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:9638,Deployability,integrat,integration,9638,"aram a lower value of the integration interval. double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. double Integral(double a, double b). evaluate the Integral of a function f with known singular points over the defined Integral (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(double a, double b); evaluate using cached function. evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(). evaluate the Integral over the infinite interval (-inf,+inf) using the function previously set with GSLIntegrator::SetFunction method. double IntegralUp(double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) using the function previously set with GSLIntegrator::SetFunction method.; @param a lower value of the integration interval. double IntegralLow(double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) using the function previously set with GSLIntegrator::SetFunction method.; @param b upper value of the integration interval. double Integral( const std::vector<double> & pts). evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method. The function has known singular points.; @param pts vector containing both t",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:9688,Deployability,integrat,integration,9688,"aram a lower value of the integration interval. double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. double Integral(double a, double b). evaluate the Integral of a function f with known singular points over the defined Integral (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(double a, double b); evaluate using cached function. evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(). evaluate the Integral over the infinite interval (-inf,+inf) using the function previously set with GSLIntegrator::SetFunction method. double IntegralUp(double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) using the function previously set with GSLIntegrator::SetFunction method.; @param a lower value of the integration interval. double IntegralLow(double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) using the function previously set with GSLIntegrator::SetFunction method.; @param b upper value of the integration interval. double Integral( const std::vector<double> & pts). evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method. The function has known singular points.; @param pts vector containing both t",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:10075,Deployability,integrat,integration,10075,"egral (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(double a, double b); evaluate using cached function. evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(). evaluate the Integral over the infinite interval (-inf,+inf) using the function previously set with GSLIntegrator::SetFunction method. double IntegralUp(double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) using the function previously set with GSLIntegrator::SetFunction method.; @param a lower value of the integration interval. double IntegralLow(double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) using the function previously set with GSLIntegrator::SetFunction method.; @param b upper value of the integration interval. double Integral( const std::vector<double> & pts). evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method. The function has known singular points.; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(ROOT::Math::GSLFuncPointer f, void* p, double a, double b); evaluate using free function pointer (same GSL signature). signature for function pointers used by GSL. typedef double ( * GSLFuncPointer ) ( double, void * );. evaluate the Integral of of a function f over",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:10318,Deployability,integrat,integration,10318," first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(double a, double b); evaluate using cached function. evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(). evaluate the Integral over the infinite interval (-inf,+inf) using the function previously set with GSLIntegrator::SetFunction method. double IntegralUp(double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) using the function previously set with GSLIntegrator::SetFunction method.; @param a lower value of the integration interval. double IntegralLow(double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) using the function previously set with GSLIntegrator::SetFunction method.; @param b upper value of the integration interval. double Integral( const std::vector<double> & pts). evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method. The function has known singular points.; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(ROOT::Math::GSLFuncPointer f, void* p, double a, double b); evaluate using free function pointer (same GSL signature). signature for function pointers used by GSL. typedef double ( * GSLFuncPointer ) ( double, void * );. evaluate the Integral of of a function f over the defined interval (a,b) passing a free function pointer; The integration function must be a free function and have a signature consistent with GSL functions:. <em>double my_function ( double x, void * p ) { ...... } </em>. This method is t",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:10726,Deployability,integrat,integration,10726,"). evaluate the Integral over the infinite interval (-inf,+inf) using the function previously set with GSLIntegrator::SetFunction method. double IntegralUp(double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) using the function previously set with GSLIntegrator::SetFunction method.; @param a lower value of the integration interval. double IntegralLow(double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) using the function previously set with GSLIntegrator::SetFunction method.; @param b upper value of the integration interval. double Integral( const std::vector<double> & pts). evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method. The function has known singular points.; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(ROOT::Math::GSLFuncPointer f, void* p, double a, double b); evaluate using free function pointer (same GSL signature). signature for function pointers used by GSL. typedef double ( * GSLFuncPointer ) ( double, void * );. evaluate the Integral of of a function f over the defined interval (a,b) passing a free function pointer; The integration function must be a free function and have a signature consistent with GSL functions:. <em>double my_function ( double x, void * p ) { ...... } </em>. This method is the most efficient since no internal adapter to GSL function is created.; @param f pointer to the integration function; @param p pointer to the Parameters of the function; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(ROOT::Math::GSLFuncPointer f, void* p). evaluate the Integral of a function f over the infinite interval (-inf,+inf) passing a",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:11136,Deployability,integrat,integration,11136,"aluate the Integral of a function f over the over the semi-infinite interval (-inf,b) using the function previously set with GSLIntegrator::SetFunction method.; @param b upper value of the integration interval. double Integral( const std::vector<double> & pts). evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method. The function has known singular points.; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(ROOT::Math::GSLFuncPointer f, void* p, double a, double b); evaluate using free function pointer (same GSL signature). signature for function pointers used by GSL. typedef double ( * GSLFuncPointer ) ( double, void * );. evaluate the Integral of of a function f over the defined interval (a,b) passing a free function pointer; The integration function must be a free function and have a signature consistent with GSL functions:. <em>double my_function ( double x, void * p ) { ...... } </em>. This method is the most efficient since no internal adapter to GSL function is created.; @param f pointer to the integration function; @param p pointer to the Parameters of the function; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(ROOT::Math::GSLFuncPointer f, void* p). evaluate the Integral of a function f over the infinite interval (-inf,+inf) passing a free function pointer. double IntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer. double IntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) passing a free function pointer. double I",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:11411,Deployability,integrat,integration,11411,"GSLIntegrator::SetFunction method. The function has known singular points.; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(ROOT::Math::GSLFuncPointer f, void* p, double a, double b); evaluate using free function pointer (same GSL signature). signature for function pointers used by GSL. typedef double ( * GSLFuncPointer ) ( double, void * );. evaluate the Integral of of a function f over the defined interval (a,b) passing a free function pointer; The integration function must be a free function and have a signature consistent with GSL functions:. <em>double my_function ( double x, void * p ) { ...... } </em>. This method is the most efficient since no internal adapter to GSL function is created.; @param f pointer to the integration function; @param p pointer to the Parameters of the function; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(ROOT::Math::GSLFuncPointer f, void* p). evaluate the Integral of a function f over the infinite interval (-inf,+inf) passing a free function pointer. double IntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer. double IntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) passing a free function pointer. double Integral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts). evaluate the Integral of a function f with knows singular points over the over a defined interval passing a free function pointer. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:11513,Deployability,integrat,integration,11513,"GSLIntegrator::SetFunction method. The function has known singular points.; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(ROOT::Math::GSLFuncPointer f, void* p, double a, double b); evaluate using free function pointer (same GSL signature). signature for function pointers used by GSL. typedef double ( * GSLFuncPointer ) ( double, void * );. evaluate the Integral of of a function f over the defined interval (a,b) passing a free function pointer; The integration function must be a free function and have a signature consistent with GSL functions:. <em>double my_function ( double x, void * p ) { ...... } </em>. This method is the most efficient since no internal adapter to GSL function is created.; @param f pointer to the integration function; @param p pointer to the Parameters of the function; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(ROOT::Math::GSLFuncPointer f, void* p). evaluate the Integral of a function f over the infinite interval (-inf,+inf) passing a free function pointer. double IntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer. double IntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) passing a free function pointer. double Integral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts). evaluate the Integral of a function f with knows singular points over the over a defined interval passing a free function pointer. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:11563,Deployability,integrat,integration,11563,"GSLIntegrator::SetFunction method. The function has known singular points.; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(ROOT::Math::GSLFuncPointer f, void* p, double a, double b); evaluate using free function pointer (same GSL signature). signature for function pointers used by GSL. typedef double ( * GSLFuncPointer ) ( double, void * );. evaluate the Integral of of a function f over the defined interval (a,b) passing a free function pointer; The integration function must be a free function and have a signature consistent with GSL functions:. <em>double my_function ( double x, void * p ) { ...... } </em>. This method is the most efficient since no internal adapter to GSL function is created.; @param f pointer to the integration function; @param p pointer to the Parameters of the function; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(ROOT::Math::GSLFuncPointer f, void* p). evaluate the Integral of a function f over the infinite interval (-inf,+inf) passing a free function pointer. double IntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer. double IntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) passing a free function pointer. double Integral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts). evaluate the Integral of a function f with knows singular points over the over a defined interval passing a free function pointer. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:12942,Deployability,Integrat,Integration,12942,"a free function pointer. double IntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer. double IntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) passing a free function pointer. double Integral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts). evaluate the Integral of a function f with knows singular points over the over a defined interval passing a free function pointer. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. void SetAbsTolerance(double absTolerance). set the desired absolute Error. void SetIntegrationRule(ROOT::Math::Integration::GKRule ). set the integration rule (Gauss-Kronrod rule).; The possible rules are defined in the Integration::GKRule enumeration.; The integration rule can be modified only for ADAPTIVE type integrations. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. IntegrationOneDim::Type GetType() const; get type name. { return fType; }. const char * GetTypeName() const. return the name. bool CheckFunction(); internal method to check validity of GSL function pointer.  Last changed: root/mathmore:$Id: GSLIntegrator.h 36764 2010-11-19 10:02:00Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:12973,Deployability,integrat,integration,12973,"a free function pointer. double IntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer. double IntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) passing a free function pointer. double Integral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts). evaluate the Integral of a function f with knows singular points over the over a defined interval passing a free function pointer. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. void SetAbsTolerance(double absTolerance). set the desired absolute Error. void SetIntegrationRule(ROOT::Math::Integration::GKRule ). set the integration rule (Gauss-Kronrod rule).; The possible rules are defined in the Integration::GKRule enumeration.; The integration rule can be modified only for ADAPTIVE type integrations. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. IntegrationOneDim::Type GetType() const; get type name. { return fType; }. const char * GetTypeName() const. return the name. bool CheckFunction(); internal method to check validity of GSL function pointer.  Last changed: root/mathmore:$Id: GSLIntegrator.h 36764 2010-11-19 10:02:00Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:13051,Deployability,Integrat,Integration,13051,"a free function pointer. double IntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer. double IntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) passing a free function pointer. double Integral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts). evaluate the Integral of a function f with knows singular points over the over a defined interval passing a free function pointer. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. void SetAbsTolerance(double absTolerance). set the desired absolute Error. void SetIntegrationRule(ROOT::Math::Integration::GKRule ). set the integration rule (Gauss-Kronrod rule).; The possible rules are defined in the Integration::GKRule enumeration.; The integration rule can be modified only for ADAPTIVE type integrations. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. IntegrationOneDim::Type GetType() const; get type name. { return fType; }. const char * GetTypeName() const. return the name. bool CheckFunction(); internal method to check validity of GSL function pointer.  Last changed: root/mathmore:$Id: GSLIntegrator.h 36764 2010-11-19 10:02:00Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:13089,Deployability,integrat,integration,13089,"a free function pointer. double IntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer. double IntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) passing a free function pointer. double Integral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts). evaluate the Integral of a function f with knows singular points over the over a defined interval passing a free function pointer. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. void SetAbsTolerance(double absTolerance). set the desired absolute Error. void SetIntegrationRule(ROOT::Math::Integration::GKRule ). set the integration rule (Gauss-Kronrod rule).; The possible rules are defined in the Integration::GKRule enumeration.; The integration rule can be modified only for ADAPTIVE type integrations. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. IntegrationOneDim::Type GetType() const; get type name. { return fType; }. const char * GetTypeName() const. return the name. bool CheckFunction(); internal method to check validity of GSL function pointer.  Last changed: root/mathmore:$Id: GSLIntegrator.h 36764 2010-11-19 10:02:00Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:13145,Deployability,integrat,integrations,13145,"a free function pointer. double IntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer. double IntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) passing a free function pointer. double Integral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts). evaluate the Integral of a function f with knows singular points over the over a defined interval passing a free function pointer. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. void SetAbsTolerance(double absTolerance). set the desired absolute Error. void SetIntegrationRule(ROOT::Math::Integration::GKRule ). set the integration rule (Gauss-Kronrod rule).; The possible rules are defined in the Integration::GKRule enumeration.; The integration rule can be modified only for ADAPTIVE type integrations. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. IntegrationOneDim::Type GetType() const; get type name. { return fType; }. const char * GetTypeName() const. return the name. bool CheckFunction(); internal method to check validity of GSL function pointer.  Last changed: root/mathmore:$Id: GSLIntegrator.h 36764 2010-11-19 10:02:00Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:13193,Deployability,Integrat,IntegratorOneDimOptions,13193,"a free function pointer. double IntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer. double IntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) passing a free function pointer. double Integral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts). evaluate the Integral of a function f with knows singular points over the over a defined interval passing a free function pointer. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. void SetAbsTolerance(double absTolerance). set the desired absolute Error. void SetIntegrationRule(ROOT::Math::Integration::GKRule ). set the integration rule (Gauss-Kronrod rule).; The possible rules are defined in the Integration::GKRule enumeration.; The integration rule can be modified only for ADAPTIVE type integrations. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. IntegrationOneDim::Type GetType() const; get type name. { return fType; }. const char * GetTypeName() const. return the name. bool CheckFunction(); internal method to check validity of GSL function pointer.  Last changed: root/mathmore:$Id: GSLIntegrator.h 36764 2010-11-19 10:02:00Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:13241,Deployability,Integrat,IntegrationOneDim,13241,"a free function pointer. double IntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer. double IntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) passing a free function pointer. double Integral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts). evaluate the Integral of a function f with knows singular points over the over a defined interval passing a free function pointer. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. void SetAbsTolerance(double absTolerance). set the desired absolute Error. void SetIntegrationRule(ROOT::Math::Integration::GKRule ). set the integration rule (Gauss-Kronrod rule).; The possible rules are defined in the Integration::GKRule enumeration.; The integration rule can be modified only for ADAPTIVE type integrations. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. IntegrationOneDim::Type GetType() const; get type name. { return fType; }. const char * GetTypeName() const. return the name. bool CheckFunction(); internal method to check validity of GSL function pointer.  Last changed: root/mathmore:$Id: GSLIntegrator.h 36764 2010-11-19 10:02:00Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:599,Energy Efficiency,adapt,adaptive,599,". ROOT::Math::GSLIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:616,Energy Efficiency,adapt,adaptive,616,". ROOT::Math::GSLIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:863,Energy Efficiency,adapt,adaptive,863,". ROOT::Math::GSLIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:903,Energy Efficiency,ADAPT,ADAPTIVESINGULAR,903,". ROOT::Math::GSLIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:1024,Energy Efficiency,ADAPT,ADAPTIVE,1024,"lass Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::I",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:1235,Energy Efficiency,ADAPT,ADAPTIVESINGULAR,1235,"ATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::IntegrationOneDim:",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:1321,Energy Efficiency,ADAPT,ADAPTIVESINGULAR,1321,"lass for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, const ROOT::Math::Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:1491,Energy Efficiency,ADAPT,ADAPTIVE,1491," algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, const ROOT::Math::Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const char* type, int rule, double absTol, double relTol, size_",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:4788,Energy Efficiency,Adapt,Adaptive,4788,"id* p = 0); voidSetIntegrationRule(ROOT::Math::Integration::GKRule); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double relTolerance); virtual intStatus() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. protected:. boolCheckFunction(). private:. ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::GSLIntegrator&); ROOT::Math::GSLIntegrator&operator=(const ROOT::Math::GSLIntegrator&). Data Members; private:. doublefAbsTol; doublefError; ROOT::Math::GSLFunctionWrapper*fFunction; size_tfMaxIntervals; intfNEval; doublefRelTol; doublefResult; ROOT::Math::Integration::GKRulefRule; size_tfSize; intfStatus; ROOT::Math::IntegrationOneDim::TypefType; ROOT::Math::GSLIntegrationWorkspace*fWorkspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructors; Default constructor of GSL Integrator for Adaptive Singular integration. @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Inte",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:5114,Energy Efficiency,Adapt,Adaptive,5114,"egrator(const ROOT::Math::GSLIntegrator&); ROOT::Math::GSLIntegrator&operator=(const ROOT::Math::GSLIntegrator&). Data Members; private:. doublefAbsTol; doublefError; ROOT::Math::GSLFunctionWrapper*fFunction; size_tfMaxIntervals; intfNEval; doublefRelTol; doublefResult; ROOT::Math::Integration::GKRulefRule; size_tfSize; intfStatus; ROOT::Math::IntegrationOneDim::TypefType; ROOT::Math::GSLIntegrationWorkspace*fWorkspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructors; Default constructor of GSL Integrator for Adaptive Singular integration. @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 ",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:5737,Energy Efficiency,ADAPT,ADAPTIVE,5737,"tors; Default constructor of GSL Integrator for Adaptive Singular integration. @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (need a char * instead of enumerations). @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template met",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:6090,Energy Efficiency,Adapt,Adaptive,6090,"ule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (need a char * instead of enumerations). @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0). Set function from a GSL pointer function type. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); methods using IGenFunct",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:11322,Energy Efficiency,efficient,efficient,11322,"ouble Integral( const std::vector<double> & pts). evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method. The function has known singular points.; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(ROOT::Math::GSLFuncPointer f, void* p, double a, double b); evaluate using free function pointer (same GSL signature). signature for function pointers used by GSL. typedef double ( * GSLFuncPointer ) ( double, void * );. evaluate the Integral of of a function f over the defined interval (a,b) passing a free function pointer; The integration function must be a free function and have a signature consistent with GSL functions:. <em>double my_function ( double x, void * p ) { ...... } </em>. This method is the most efficient since no internal adapter to GSL function is created.; @param f pointer to the integration function; @param p pointer to the Parameters of the function; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(ROOT::Math::GSLFuncPointer f, void* p). evaluate the Integral of a function f over the infinite interval (-inf,+inf) passing a free function pointer. double IntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer. double IntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) passing a free function pointer. double Integral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts). evaluate the Integral of a function f with knows singular points over the over a defined interval passing a free function pointer. double",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:11350,Energy Efficiency,adapt,adapter,11350,"ouble Integral( const std::vector<double> & pts). evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method. The function has known singular points.; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(ROOT::Math::GSLFuncPointer f, void* p, double a, double b); evaluate using free function pointer (same GSL signature). signature for function pointers used by GSL. typedef double ( * GSLFuncPointer ) ( double, void * );. evaluate the Integral of of a function f over the defined interval (a,b) passing a free function pointer; The integration function must be a free function and have a signature consistent with GSL functions:. <em>double my_function ( double x, void * p ) { ...... } </em>. This method is the most efficient since no internal adapter to GSL function is created.; @param f pointer to the integration function; @param p pointer to the Parameters of the function; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(ROOT::Math::GSLFuncPointer f, void* p). evaluate the Integral of a function f over the infinite interval (-inf,+inf) passing a free function pointer. double IntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer. double IntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) passing a free function pointer. double Integral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts). evaluate the Integral of a function f with knows singular points over the over a defined interval passing a free function pointer. double",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:13131,Energy Efficiency,ADAPT,ADAPTIVE,13131,"a free function pointer. double IntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer. double IntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) passing a free function pointer. double Integral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts). evaluate the Integral of a function f with knows singular points over the over a defined interval passing a free function pointer. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. void SetAbsTolerance(double absTolerance). set the desired absolute Error. void SetIntegrationRule(ROOT::Math::Integration::GKRule ). set the integration rule (Gauss-Kronrod rule).; The possible rules are defined in the Integration::GKRule enumeration.; The integration rule can be modified only for ADAPTIVE type integrations. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. IntegrationOneDim::Type GetType() const; get type name. { return fType; }. const char * GetTypeName() const. return the name. bool CheckFunction(); internal method to check validity of GSL function pointer.  Last changed: root/mathmore:$Id: GSLIntegrator.h 36764 2010-11-19 10:02:00Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:375,Integrability,integrat,integration,375,". ROOT::Math::GSLIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:442,Integrability,integrat,integration,442,". ROOT::Math::GSLIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:542,Integrability,integrat,integration,542,". ROOT::Math::GSLIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:625,Integrability,integrat,integration,625,". ROOT::Math::GSLIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:667,Integrability,integrat,integration,667,". ROOT::Math::GSLIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:746,Integrability,integrat,integration,746,". ROOT::Math::GSLIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:785,Integrability,Integrat,Integration,785,". ROOT::Math::GSLIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:872,Integrability,integrat,integration,872,". ROOT::Math::GSLIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:990,Integrability,integrat,integration,990,". ROOT::Math::GSLIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:1043,Integrability,integrat,integration,1043,"lass Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::I",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:1091,Integrability,Integrat,Integration,1091,"lass Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::I",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:1158,Integrability,integrat,integration,1158,"ATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::IntegrationOneDim:",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:1565,Integrability,integrat,integration,1565,"ortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, const ROOT::Math::Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); virtual doubleIntegral(); doubleIntegral(const ROOT::Math::IGenFunction& f); virtual doubleIntegral(const vector<",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:1665,Integrability,Integrat,Integration,1665,"d. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, const ROOT::Math::Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); virtual doubleIntegral(); doubleIntegral(const ROOT::Math::IGenFunction& f); virtual doubleIntegral(const vector<double>& pts); doubleIntegral(const ROOT::Math::IGenFunction& f, const vec",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:1708,Integrability,Integrat,Integration,1708,"e ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, const ROOT::Math::Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); virtual doubleIntegral(); doubleIntegral(const ROOT::Math::IGenFunction& f); virtual doubleIntegral(const vector<double>& pts); doubleIntegral(const ROOT::Math::IGenFunction& f, const vector<double>& pts); virtual doubleIntegral(double a, double b",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:1824,Integrability,Integrat,IntegrationOneDim,1824,"type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, const ROOT::Math::Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); virtual doubleIntegral(); doubleIntegral(const ROOT::Math::IGenFunction& f); virtual doubleIntegral(const vector<double>& pts); doubleIntegral(const ROOT::Math::IGenFunction& f, const vector<double>& pts); virtual doubleIntegral(double a, double b); doubleIntegral(ROOT::Math::GSLFuncPointer f, void* p); doubleIntegral(const ROOT::Math::IGenFunction& f, double a, double b); doubleIntegral(RO",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:2058,Integrability,Integrat,IntegrationOneDim,2058,"IVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, const ROOT::Math::Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); virtual doubleIntegral(); doubleIntegral(const ROOT::Math::IGenFunction& f); virtual doubleIntegral(const vector<double>& pts); doubleIntegral(const ROOT::Math::IGenFunction& f, const vector<double>& pts); virtual doubleIntegral(double a, double b); doubleIntegral(ROOT::Math::GSLFuncPointer f, void* p); doubleIntegral(const ROOT::Math::IGenFunction& f, double a, double b); doubleIntegral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts); doubleIntegral(ROOT::Math::GSLFuncPointer f, void* p, double a, double b); virtual doubleIntegralCauchy(double",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:2211,Integrability,Integrat,IntegrationOneDim,2211,"nges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, const ROOT::Math::Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); virtual doubleIntegral(); doubleIntegral(const ROOT::Math::IGenFunction& f); virtual doubleIntegral(const vector<double>& pts); doubleIntegral(const ROOT::Math::IGenFunction& f, const vector<double>& pts); virtual doubleIntegral(double a, double b); doubleIntegral(ROOT::Math::GSLFuncPointer f, void* p); doubleIntegral(const ROOT::Math::IGenFunction& f, double a, double b); doubleIntegral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts); doubleIntegral(ROOT::Math::GSLFuncPointer f, void* p, double a, double b); virtual doubleIntegralCauchy(double a, double b, double c); doubleIntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c); virtual doubleIntegralLow(double b); doubleIntegralLow(const RO",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:2259,Integrability,Integrat,Integration,2259,"nges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, const ROOT::Math::Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); virtual doubleIntegral(); doubleIntegral(const ROOT::Math::IGenFunction& f); virtual doubleIntegral(const vector<double>& pts); doubleIntegral(const ROOT::Math::IGenFunction& f, const vector<double>& pts); virtual doubleIntegral(double a, double b); doubleIntegral(ROOT::Math::GSLFuncPointer f, void* p); doubleIntegral(const ROOT::Math::IGenFunction& f, double a, double b); doubleIntegral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts); doubleIntegral(ROOT::Math::GSLFuncPointer f, void* p, double a, double b); virtual doubleIntegralCauchy(double a, double b, double c); doubleIntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c); virtual doubleIntegralLow(double b); doubleIntegralLow(const RO",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:3523,Integrability,Integrat,IntegratorOneDimOptionsOptions,3523,"Integrator(const ROOT::Math::IntegrationOneDim::Type type, const ROOT::Math::Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); virtual doubleIntegral(); doubleIntegral(const ROOT::Math::IGenFunction& f); virtual doubleIntegral(const vector<double>& pts); doubleIntegral(const ROOT::Math::IGenFunction& f, const vector<double>& pts); virtual doubleIntegral(double a, double b); doubleIntegral(ROOT::Math::GSLFuncPointer f, void* p); doubleIntegral(const ROOT::Math::IGenFunction& f, double a, double b); doubleIntegral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts); doubleIntegral(ROOT::Math::GSLFuncPointer f, void* p, double a, double b); virtual doubleIntegralCauchy(double a, double b, double c); doubleIntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c); virtual doubleIntegralLow(double b); doubleIntegralLow(const ROOT::Math::IGenFunction& f, double b); doubleIntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b); virtual doubleIntegralUp(double a); doubleIntegralUp(const ROOT::Math::IGenFunction& f, double a); doubleIntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a); virtual intNEval() const; virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTolerance); virtual voidSetFunction(const ROOT::Math::IGenFunction& f); voidSetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0); voidSetIntegrationRule(ROOT::Math::Integration::GKRule); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double relTolerance); virtual intStatus() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. protected:. boolCheckFunction(). private:. ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::GSLIntegrator&); ROO",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:3798,Integrability,Integrat,Integration,3798,"Integrator(const ROOT::Math::IntegrationOneDim::Type type, const ROOT::Math::Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); virtual doubleIntegral(); doubleIntegral(const ROOT::Math::IGenFunction& f); virtual doubleIntegral(const vector<double>& pts); doubleIntegral(const ROOT::Math::IGenFunction& f, const vector<double>& pts); virtual doubleIntegral(double a, double b); doubleIntegral(ROOT::Math::GSLFuncPointer f, void* p); doubleIntegral(const ROOT::Math::IGenFunction& f, double a, double b); doubleIntegral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts); doubleIntegral(ROOT::Math::GSLFuncPointer f, void* p, double a, double b); virtual doubleIntegralCauchy(double a, double b, double c); doubleIntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c); virtual doubleIntegralLow(double b); doubleIntegralLow(const ROOT::Math::IGenFunction& f, double b); doubleIntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b); virtual doubleIntegralUp(double a); doubleIntegralUp(const ROOT::Math::IGenFunction& f, double a); doubleIntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a); virtual intNEval() const; virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTolerance); virtual voidSetFunction(const ROOT::Math::IGenFunction& f); voidSetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0); voidSetIntegrationRule(ROOT::Math::Integration::GKRule); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double relTolerance); virtual intStatus() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. protected:. boolCheckFunction(). private:. ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::GSLIntegrator&); ROO",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:3861,Integrability,Integrat,IntegratorOneDimOptions,3861,"Integrator(const ROOT::Math::IntegrationOneDim::Type type, const ROOT::Math::Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); virtual doubleIntegral(); doubleIntegral(const ROOT::Math::IGenFunction& f); virtual doubleIntegral(const vector<double>& pts); doubleIntegral(const ROOT::Math::IGenFunction& f, const vector<double>& pts); virtual doubleIntegral(double a, double b); doubleIntegral(ROOT::Math::GSLFuncPointer f, void* p); doubleIntegral(const ROOT::Math::IGenFunction& f, double a, double b); doubleIntegral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts); doubleIntegral(ROOT::Math::GSLFuncPointer f, void* p, double a, double b); virtual doubleIntegralCauchy(double a, double b, double c); doubleIntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c); virtual doubleIntegralLow(double b); doubleIntegralLow(const ROOT::Math::IGenFunction& f, double b); doubleIntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b); virtual doubleIntegralUp(double a); doubleIntegralUp(const ROOT::Math::IGenFunction& f, double a); doubleIntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a); virtual intNEval() const; virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTolerance); virtual voidSetFunction(const ROOT::Math::IGenFunction& f); voidSetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0); voidSetIntegrationRule(ROOT::Math::Integration::GKRule); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double relTolerance); virtual intStatus() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. protected:. boolCheckFunction(). private:. ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::GSLIntegrator&); ROO",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:3989,Integrability,Integrat,IntegrationOneDim,3989,"Integrator(const ROOT::Math::IntegrationOneDim::Type type, const ROOT::Math::Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); virtual doubleIntegral(); doubleIntegral(const ROOT::Math::IGenFunction& f); virtual doubleIntegral(const vector<double>& pts); doubleIntegral(const ROOT::Math::IGenFunction& f, const vector<double>& pts); virtual doubleIntegral(double a, double b); doubleIntegral(ROOT::Math::GSLFuncPointer f, void* p); doubleIntegral(const ROOT::Math::IGenFunction& f, double a, double b); doubleIntegral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts); doubleIntegral(ROOT::Math::GSLFuncPointer f, void* p, double a, double b); virtual doubleIntegralCauchy(double a, double b, double c); doubleIntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c); virtual doubleIntegralLow(double b); doubleIntegralLow(const ROOT::Math::IGenFunction& f, double b); doubleIntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b); virtual doubleIntegralUp(double a); doubleIntegralUp(const ROOT::Math::IGenFunction& f, double a); doubleIntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a); virtual intNEval() const; virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTolerance); virtual voidSetFunction(const ROOT::Math::IGenFunction& f); voidSetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0); voidSetIntegrationRule(ROOT::Math::Integration::GKRule); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double relTolerance); virtual intStatus() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. protected:. boolCheckFunction(). private:. ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::GSLIntegrator&); ROO",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:4420,Integrability,Integrat,Integration,4420,"ntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a); virtual intNEval() const; virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTolerance); virtual voidSetFunction(const ROOT::Math::IGenFunction& f); voidSetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0); voidSetIntegrationRule(ROOT::Math::Integration::GKRule); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double relTolerance); virtual intStatus() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. protected:. boolCheckFunction(). private:. ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::GSLIntegrator&); ROOT::Math::GSLIntegrator&operator=(const ROOT::Math::GSLIntegrator&). Data Members; private:. doublefAbsTol; doublefError; ROOT::Math::GSLFunctionWrapper*fFunction; size_tfMaxIntervals; intfNEval; doublefRelTol; doublefResult; ROOT::Math::Integration::GKRulefRule; size_tfSize; intfStatus; ROOT::Math::IntegrationOneDim::TypefType; ROOT::Math::GSLIntegrationWorkspace*fWorkspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructors; Default constructor of GSL Integrator for Adaptive Singular integration. @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(co",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:4483,Integrability,Integrat,IntegrationOneDim,4483,"ntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a); virtual intNEval() const; virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTolerance); virtual voidSetFunction(const ROOT::Math::IGenFunction& f); voidSetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0); voidSetIntegrationRule(ROOT::Math::Integration::GKRule); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double relTolerance); virtual intStatus() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. protected:. boolCheckFunction(). private:. ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::GSLIntegrator&); ROOT::Math::GSLIntegrator&operator=(const ROOT::Math::GSLIntegrator&). Data Members; private:. doublefAbsTol; doublefError; ROOT::Math::GSLFunctionWrapper*fFunction; size_tfMaxIntervals; intfNEval; doublefRelTol; doublefResult; ROOT::Math::Integration::GKRulefRule; size_tfSize; intfStatus; ROOT::Math::IntegrationOneDim::TypefType; ROOT::Math::GSLIntegrationWorkspace*fWorkspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructors; Default constructor of GSL Integrator for Adaptive Singular integration. @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(co",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:4773,Integrability,Integrat,Integrator,4773,"id* p = 0); voidSetIntegrationRule(ROOT::Math::Integration::GKRule); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double relTolerance); virtual intStatus() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. protected:. boolCheckFunction(). private:. ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::GSLIntegrator&); ROOT::Math::GSLIntegrator&operator=(const ROOT::Math::GSLIntegrator&). Data Members; private:. doublefAbsTol; doublefError; ROOT::Math::GSLFunctionWrapper*fFunction; size_tfMaxIntervals; intfNEval; doublefRelTol; doublefResult; ROOT::Math::Integration::GKRulefRule; size_tfSize; intfStatus; ROOT::Math::IntegrationOneDim::TypefType; ROOT::Math::GSLIntegrationWorkspace*fWorkspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructors; Default constructor of GSL Integrator for Adaptive Singular integration. @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Inte",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:4806,Integrability,integrat,integration,4806,"id* p = 0); voidSetIntegrationRule(ROOT::Math::Integration::GKRule); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double relTolerance); virtual intStatus() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. protected:. boolCheckFunction(). private:. ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::GSLIntegrator&); ROOT::Math::GSLIntegrator&operator=(const ROOT::Math::GSLIntegrator&). Data Members; private:. doublefAbsTol; doublefError; ROOT::Math::GSLFunctionWrapper*fFunction; size_tfMaxIntervals; intfNEval; doublefRelTol; doublefResult; ROOT::Math::Integration::GKRulefRule; size_tfSize; intfStatus; ROOT::Math::IntegrationOneDim::TypefType; ROOT::Math::GSLIntegrationWorkspace*fWorkspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructors; Default constructor of GSL Integrator for Adaptive Singular integration. @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Inte",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:4972,Integrability,Integrat,IntegrationOneDim,4972,"OT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. protected:. boolCheckFunction(). private:. ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::GSLIntegrator&); ROOT::Math::GSLIntegrator&operator=(const ROOT::Math::GSLIntegrator&). Data Members; private:. doublefAbsTol; doublefError; ROOT::Math::GSLFunctionWrapper*fFunction; size_tfMaxIntervals; intfNEval; doublefRelTol; doublefResult; ROOT::Math::Integration::GKRulefRule; size_tfSize; intfStatus; ROOT::Math::IntegrationOneDim::TypefType; ROOT::Math::GSLIntegrationWorkspace*fWorkspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructors; Default constructor of GSL Integrator for Adaptive Singular integration. @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const ch",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:5087,Integrability,Integrat,Integrator,5087,"st. protected:. boolCheckFunction(). private:. ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::GSLIntegrator&); ROOT::Math::GSLIntegrator&operator=(const ROOT::Math::GSLIntegrator&). Data Members; private:. doublefAbsTol; doublefError; ROOT::Math::GSLFunctionWrapper*fFunction; size_tfMaxIntervals; intfNEval; doublefRelTol; doublefResult; ROOT::Math::Integration::GKRulefRule; size_tfSize; intfStatus; ROOT::Math::IntegrationOneDim::TypefType; ROOT::Math::GSLIntegrationWorkspace*fWorkspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructors; Default constructor of GSL Integrator for Adaptive Singular integration. @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of ",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:5123,Integrability,integrat,integration,5123,"egrator(const ROOT::Math::GSLIntegrator&); ROOT::Math::GSLIntegrator&operator=(const ROOT::Math::GSLIntegrator&). Data Members; private:. doublefAbsTol; doublefError; ROOT::Math::GSLFunctionWrapper*fFunction; size_tfMaxIntervals; intfNEval; doublefRelTol; doublefResult; ROOT::Math::Integration::GKRulefRule; size_tfSize; intfStatus; ROOT::Math::IntegrationOneDim::TypefType; ROOT::Math::GSLIntegrationWorkspace*fWorkspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructors; Default constructor of GSL Integrator for Adaptive Singular integration. @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 ",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:5198,Integrability,integrat,integration,5198,"SLIntegrator&operator=(const ROOT::Math::GSLIntegrator&). Data Members; private:. doublefAbsTol; doublefError; ROOT::Math::GSLFunctionWrapper*fFunction; size_tfMaxIntervals; intfNEval; doublefRelTol; doublefResult; ROOT::Math::Integration::GKRulefRule; size_tfSize; intfStatus; ROOT::Math::IntegrationOneDim::TypefType; ROOT::Math::GSLIntegrationWorkspace*fWorkspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructors; Default constructor of GSL Integrator for Adaptive Singular integration. @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (nee",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:5249,Integrability,Integrat,Integration,5249,"OOT::Math::GSLFunctionWrapper*fFunction; size_tfMaxIntervals; intfNEval; doublefRelTol; doublefResult; ROOT::Math::Integration::GKRulefRule; size_tfSize; intfStatus; ROOT::Math::IntegrationOneDim::TypefType; ROOT::Math::GSLIntegrationWorkspace*fWorkspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructors; Default constructor of GSL Integrator for Adaptive Singular integration. @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (need a char * instead of enumerations). @param type type of integration. The possible types are defined in the Int",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:5421,Integrability,Integrat,Integration,5421,"ize_tfSize; intfStatus; ROOT::Math::IntegrationOneDim::TypefType; ROOT::Math::GSLIntegrationWorkspace*fWorkspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructors; Default constructor of GSL Integrator for Adaptive Singular integration. @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (need a char * instead of enumerations). @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative ",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:5451,Integrability,Integrat,Integration,5451,"ize_tfSize; intfStatus; ROOT::Math::IntegrationOneDim::TypefType; ROOT::Math::GSLIntegrationWorkspace*fWorkspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructors; Default constructor of GSL Integrator for Adaptive Singular integration. @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (need a char * instead of enumerations). @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative ",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:5571,Integrability,Integrat,Integrator,5571,"lass Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructors; Default constructor of GSL Integrator for Adaptive Singular integration. @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (need a char * instead of enumerations). @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(con",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:5603,Integrability,integrat,integration,5603,"Members; Includes; Libraries. Function documentation; GSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructors; Default constructor of GSL Integrator for Adaptive Singular integration. @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (need a char * instead of enumerations). @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disa",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:5654,Integrability,Integrat,Integration,5654,"(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructors; Default constructor of GSL Integrator for Adaptive Singular integration. @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (need a char * instead of enumerations). @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLInteg",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:5747,Integrability,Integrat,Integration,5747,"tors; Default constructor of GSL Integrator for Adaptive Singular integration. @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (need a char * instead of enumerations). @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template met",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:5804,Integrability,Integrat,Integration,5804,"am relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (need a char * instead of enumerations). @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:6063,Integrability,Integrat,Integrator,6063," = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (need a char * instead of enumerations). @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0). Set fu",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:6099,Integrability,integrat,integration,6099,"ule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (need a char * instead of enumerations). @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0). Set function from a GSL pointer function type. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); methods using IGenFunct",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:6251,Integrability,integrat,integration,6251,"he Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (need a char * instead of enumerations). @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0). Set function from a GSL pointer function type. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); methods using IGenFunction. evaluate the Integral of a function f over the defined interval (a,b); @param f integratio",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:6302,Integrability,Integrat,Integration,6302,"r of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (need a char * instead of enumerations). @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0). Set function from a GSL pointer function type. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); methods using IGenFunction. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @p",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:6796,Integrability,integrat,integration,6796,"ined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (need a char * instead of enumerations). @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0). Set function from a GSL pointer function type. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); methods using IGenFunction. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralCauchy(double a, double b, double c). 	evaluate the Cauchy principal value of the integral of a previously defined function f ov",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:6827,Integrability,integrat,integration,6827,"ion; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (need a char * instead of enumerations). @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0). Set function from a GSL pointer function type. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); methods using IGenFunction. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralCauchy(double a, double b, double c). 	evaluate the Cauchy principal value of the integral of a previously defined function f over; the defined interval (a,b) with a sin",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:7237,Integrability,integrat,integration,7237,"stead of enumerations). @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0). Set function from a GSL pointer function type. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); methods using IGenFunction. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralCauchy(double a, double b, double c). 	evaluate the Cauchy principal value of the integral of a previously defined function f over; the defined interval (a,b) with a singularity at c; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). 	evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b); with a singularity at c; @param f integration function. The function type mus",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:7318,Integrability,interface,interface,7318,"e Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0). Set function from a GSL pointer function type. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); methods using IGenFunction. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralCauchy(double a, double b, double c). 	evaluate the Cauchy principal value of the integral of a previously defined function f over; the defined interval (a,b) with a singularity at c; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). 	evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b); with a singularity at c; @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower interval value; @param b lower interval value; @param c singular value o",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:7357,Integrability,integrat,integration,7357,"e Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0). Set function from a GSL pointer function type. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); methods using IGenFunction. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralCauchy(double a, double b, double c). 	evaluate the Cauchy principal value of the integral of a previously defined function f over; the defined interval (a,b) with a singularity at c; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). 	evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b); with a singularity at c; @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower interval value; @param b lower interval value; @param c singular value o",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:7407,Integrability,integrat,integration,7407,"e Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0). Set function from a GSL pointer function type. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); methods using IGenFunction. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralCauchy(double a, double b, double c). 	evaluate the Cauchy principal value of the integral of a previously defined function f over; the defined interval (a,b) with a singularity at c; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). 	evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b); with a singularity at c; @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower interval value; @param b lower interval value; @param c singular value o",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:7557,Integrability,integrat,integration,7557,"); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0). Set function from a GSL pointer function type. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); methods using IGenFunction. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralCauchy(double a, double b, double c). 	evaluate the Cauchy principal value of the integral of a previously defined function f over; the defined interval (a,b) with a singularity at c; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). 	evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b); with a singularity at c; @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. T",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:7638,Integrability,interface,interface,7638," GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0). Set function from a GSL pointer function type. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); methods using IGenFunction. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralCauchy(double a, double b, double c). 	evaluate the Cauchy principal value of the integral of a previously defined function f over; the defined interval (a,b) with a singularity at c; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). 	evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b); with a singularity at c; @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:8164,Integrability,integrat,integration,8164,", double a, double b); methods using IGenFunction. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralCauchy(double a, double b, double c). 	evaluate the Cauchy principal value of the integral of a previously defined function f over; the defined interval (a,b) with a singularity at c; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). 	evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b); with a singularity at c; @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. double Integral(double a, double b). evaluate the Integral of a function f with known singular points over the defined Integral (a,b); @param f integration fu",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:8245,Integrability,interface,interface,8245,"ction type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralCauchy(double a, double b, double c). 	evaluate the Cauchy principal value of the integral of a previously defined function f over; the defined interval (a,b) with a singularity at c; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). 	evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b); with a singularity at c; @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. double Integral(double a, double b). evaluate the Integral of a function f with known singular points over the defined Integral (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param pts vector containing both the function singular points and the lower/upper",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:8501,Integrability,integrat,integration,8501,"f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralCauchy(double a, double b, double c). 	evaluate the Cauchy principal value of the integral of a previously defined function f over; the defined interval (a,b) with a singularity at c; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). 	evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b); with a singularity at c; @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. double Integral(double a, double b). evaluate the Integral of a function f with known singular points over the defined Integral (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(double a, double b); evaluate using ca",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:8582,Integrability,interface,interface,8582," function type must implement the mathlib::IGenFunction interface. double IntegralCauchy(double a, double b, double c). 	evaluate the Cauchy principal value of the integral of a previously defined function f over; the defined interval (a,b) with a singularity at c; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). 	evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b); with a singularity at c; @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. double Integral(double a, double b). evaluate the Integral of a function f with known singular points over the defined Integral (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(double a, double b); evaluate using cached function. evaluate the Integral over the defined interval (a,b) using the function previously set with GSLInte",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:8621,Integrability,integrat,integration,8621," function type must implement the mathlib::IGenFunction interface. double IntegralCauchy(double a, double b, double c). 	evaluate the Cauchy principal value of the integral of a previously defined function f over; the defined interval (a,b) with a singularity at c; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). 	evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b); with a singularity at c; @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. double Integral(double a, double b). evaluate the Integral of a function f with known singular points over the defined Integral (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(double a, double b); evaluate using cached function. evaluate the Integral over the defined interval (a,b) using the function previously set with GSLInte",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:8806,Integrability,integrat,integration,8806,"sly defined function f over; the defined interval (a,b) with a singularity at c; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). 	evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b); with a singularity at c; @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. double Integral(double a, double b). evaluate the Integral of a function f with known singular points over the defined Integral (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(double a, double b); evaluate using cached function. evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(). evaluate the Integral over the infinit",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:8887,Integrability,interface,interface,8887," lower interval value; @param c singular value of f. double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). 	evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b); with a singularity at c; @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. double Integral(double a, double b). evaluate the Integral of a function f with known singular points over the defined Integral (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(double a, double b); evaluate using cached function. evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(). evaluate the Integral over the infinite interval (-inf,+inf) using the function previously set with GSLIntegrator::SetFunction method. double IntegralUp(doubl",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:8926,Integrability,integrat,integration,8926," lower interval value; @param c singular value of f. double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). 	evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b); with a singularity at c; @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. double Integral(double a, double b). evaluate the Integral of a function f with known singular points over the defined Integral (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(double a, double b); evaluate using cached function. evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(). evaluate the Integral over the infinite interval (-inf,+inf) using the function previously set with GSLIntegrator::SetFunction method. double IntegralUp(doubl",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:9092,Integrability,integrat,integration,9092," principal value of the integral of a function f over the defined interval (a,b); with a singularity at c; @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. double Integral(double a, double b). evaluate the Integral of a function f with known singular points over the defined Integral (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(double a, double b); evaluate using cached function. evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(). evaluate the Integral over the infinite interval (-inf,+inf) using the function previously set with GSLIntegrator::SetFunction method. double IntegralUp(double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) using the function previously set with GSLIntegrator::SetFunction method.; @p",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:9173,Integrability,interface,interface,9173,"pe must implement the mathlib::IGenFunction interface; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. double Integral(double a, double b). evaluate the Integral of a function f with known singular points over the defined Integral (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(double a, double b); evaluate using cached function. evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(). evaluate the Integral over the infinite interval (-inf,+inf) using the function previously set with GSLIntegrator::SetFunction method. double IntegralUp(double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) using the function previously set with GSLIntegrator::SetFunction method.; @param a lower value of the integration interval. double IntegralLow(double b). evaluate the Integral of a function f over the over the semi-infinite inte",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:9350,Integrability,integrat,integration,9350,"uble IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. double Integral(double a, double b). evaluate the Integral of a function f with known singular points over the defined Integral (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(double a, double b); evaluate using cached function. evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(). evaluate the Integral over the infinite interval (-inf,+inf) using the function previously set with GSLIntegrator::SetFunction method. double IntegralUp(double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) using the function previously set with GSLIntegrator::SetFunction method.; @param a lower value of the integration interval. double IntegralLow(double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) using the function previously set with GSLIntegrator::SetFunction method.; @param b upper value of the integration interval. double Inte",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:9638,Integrability,integrat,integration,9638,"aram a lower value of the integration interval. double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. double Integral(double a, double b). evaluate the Integral of a function f with known singular points over the defined Integral (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(double a, double b); evaluate using cached function. evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(). evaluate the Integral over the infinite interval (-inf,+inf) using the function previously set with GSLIntegrator::SetFunction method. double IntegralUp(double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) using the function previously set with GSLIntegrator::SetFunction method.; @param a lower value of the integration interval. double IntegralLow(double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) using the function previously set with GSLIntegrator::SetFunction method.; @param b upper value of the integration interval. double Integral( const std::vector<double> & pts). evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method. The function has known singular points.; @param pts vector containing both t",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:9688,Integrability,integrat,integration,9688,"aram a lower value of the integration interval. double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. double Integral(double a, double b). evaluate the Integral of a function f with known singular points over the defined Integral (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(double a, double b); evaluate using cached function. evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(). evaluate the Integral over the infinite interval (-inf,+inf) using the function previously set with GSLIntegrator::SetFunction method. double IntegralUp(double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) using the function previously set with GSLIntegrator::SetFunction method.; @param a lower value of the integration interval. double IntegralLow(double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) using the function previously set with GSLIntegrator::SetFunction method.; @param b upper value of the integration interval. double Integral( const std::vector<double> & pts). evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method. The function has known singular points.; @param pts vector containing both t",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:10075,Integrability,integrat,integration,10075,"egral (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(double a, double b); evaluate using cached function. evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(). evaluate the Integral over the infinite interval (-inf,+inf) using the function previously set with GSLIntegrator::SetFunction method. double IntegralUp(double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) using the function previously set with GSLIntegrator::SetFunction method.; @param a lower value of the integration interval. double IntegralLow(double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) using the function previously set with GSLIntegrator::SetFunction method.; @param b upper value of the integration interval. double Integral( const std::vector<double> & pts). evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method. The function has known singular points.; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(ROOT::Math::GSLFuncPointer f, void* p, double a, double b); evaluate using free function pointer (same GSL signature). signature for function pointers used by GSL. typedef double ( * GSLFuncPointer ) ( double, void * );. evaluate the Integral of of a function f over",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:10318,Integrability,integrat,integration,10318," first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(double a, double b); evaluate using cached function. evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(). evaluate the Integral over the infinite interval (-inf,+inf) using the function previously set with GSLIntegrator::SetFunction method. double IntegralUp(double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) using the function previously set with GSLIntegrator::SetFunction method.; @param a lower value of the integration interval. double IntegralLow(double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) using the function previously set with GSLIntegrator::SetFunction method.; @param b upper value of the integration interval. double Integral( const std::vector<double> & pts). evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method. The function has known singular points.; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(ROOT::Math::GSLFuncPointer f, void* p, double a, double b); evaluate using free function pointer (same GSL signature). signature for function pointers used by GSL. typedef double ( * GSLFuncPointer ) ( double, void * );. evaluate the Integral of of a function f over the defined interval (a,b) passing a free function pointer; The integration function must be a free function and have a signature consistent with GSL functions:. <em>double my_function ( double x, void * p ) { ...... } </em>. This method is t",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:10726,Integrability,integrat,integration,10726,"). evaluate the Integral over the infinite interval (-inf,+inf) using the function previously set with GSLIntegrator::SetFunction method. double IntegralUp(double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) using the function previously set with GSLIntegrator::SetFunction method.; @param a lower value of the integration interval. double IntegralLow(double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) using the function previously set with GSLIntegrator::SetFunction method.; @param b upper value of the integration interval. double Integral( const std::vector<double> & pts). evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method. The function has known singular points.; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(ROOT::Math::GSLFuncPointer f, void* p, double a, double b); evaluate using free function pointer (same GSL signature). signature for function pointers used by GSL. typedef double ( * GSLFuncPointer ) ( double, void * );. evaluate the Integral of of a function f over the defined interval (a,b) passing a free function pointer; The integration function must be a free function and have a signature consistent with GSL functions:. <em>double my_function ( double x, void * p ) { ...... } </em>. This method is the most efficient since no internal adapter to GSL function is created.; @param f pointer to the integration function; @param p pointer to the Parameters of the function; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(ROOT::Math::GSLFuncPointer f, void* p). evaluate the Integral of a function f over the infinite interval (-inf,+inf) passing a",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:11136,Integrability,integrat,integration,11136,"aluate the Integral of a function f over the over the semi-infinite interval (-inf,b) using the function previously set with GSLIntegrator::SetFunction method.; @param b upper value of the integration interval. double Integral( const std::vector<double> & pts). evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method. The function has known singular points.; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(ROOT::Math::GSLFuncPointer f, void* p, double a, double b); evaluate using free function pointer (same GSL signature). signature for function pointers used by GSL. typedef double ( * GSLFuncPointer ) ( double, void * );. evaluate the Integral of of a function f over the defined interval (a,b) passing a free function pointer; The integration function must be a free function and have a signature consistent with GSL functions:. <em>double my_function ( double x, void * p ) { ...... } </em>. This method is the most efficient since no internal adapter to GSL function is created.; @param f pointer to the integration function; @param p pointer to the Parameters of the function; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(ROOT::Math::GSLFuncPointer f, void* p). evaluate the Integral of a function f over the infinite interval (-inf,+inf) passing a free function pointer. double IntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer. double IntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) passing a free function pointer. double I",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:11350,Integrability,adapter,adapter,11350,"ouble Integral( const std::vector<double> & pts). evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method. The function has known singular points.; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(ROOT::Math::GSLFuncPointer f, void* p, double a, double b); evaluate using free function pointer (same GSL signature). signature for function pointers used by GSL. typedef double ( * GSLFuncPointer ) ( double, void * );. evaluate the Integral of of a function f over the defined interval (a,b) passing a free function pointer; The integration function must be a free function and have a signature consistent with GSL functions:. <em>double my_function ( double x, void * p ) { ...... } </em>. This method is the most efficient since no internal adapter to GSL function is created.; @param f pointer to the integration function; @param p pointer to the Parameters of the function; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(ROOT::Math::GSLFuncPointer f, void* p). evaluate the Integral of a function f over the infinite interval (-inf,+inf) passing a free function pointer. double IntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer. double IntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) passing a free function pointer. double Integral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts). evaluate the Integral of a function f with knows singular points over the over a defined interval passing a free function pointer. double",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:11411,Integrability,integrat,integration,11411,"GSLIntegrator::SetFunction method. The function has known singular points.; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(ROOT::Math::GSLFuncPointer f, void* p, double a, double b); evaluate using free function pointer (same GSL signature). signature for function pointers used by GSL. typedef double ( * GSLFuncPointer ) ( double, void * );. evaluate the Integral of of a function f over the defined interval (a,b) passing a free function pointer; The integration function must be a free function and have a signature consistent with GSL functions:. <em>double my_function ( double x, void * p ) { ...... } </em>. This method is the most efficient since no internal adapter to GSL function is created.; @param f pointer to the integration function; @param p pointer to the Parameters of the function; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(ROOT::Math::GSLFuncPointer f, void* p). evaluate the Integral of a function f over the infinite interval (-inf,+inf) passing a free function pointer. double IntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer. double IntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) passing a free function pointer. double Integral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts). evaluate the Integral of a function f with knows singular points over the over a defined interval passing a free function pointer. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:11513,Integrability,integrat,integration,11513,"GSLIntegrator::SetFunction method. The function has known singular points.; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(ROOT::Math::GSLFuncPointer f, void* p, double a, double b); evaluate using free function pointer (same GSL signature). signature for function pointers used by GSL. typedef double ( * GSLFuncPointer ) ( double, void * );. evaluate the Integral of of a function f over the defined interval (a,b) passing a free function pointer; The integration function must be a free function and have a signature consistent with GSL functions:. <em>double my_function ( double x, void * p ) { ...... } </em>. This method is the most efficient since no internal adapter to GSL function is created.; @param f pointer to the integration function; @param p pointer to the Parameters of the function; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(ROOT::Math::GSLFuncPointer f, void* p). evaluate the Integral of a function f over the infinite interval (-inf,+inf) passing a free function pointer. double IntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer. double IntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) passing a free function pointer. double Integral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts). evaluate the Integral of a function f with knows singular points over the over a defined interval passing a free function pointer. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:11563,Integrability,integrat,integration,11563,"GSLIntegrator::SetFunction method. The function has known singular points.; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(ROOT::Math::GSLFuncPointer f, void* p, double a, double b); evaluate using free function pointer (same GSL signature). signature for function pointers used by GSL. typedef double ( * GSLFuncPointer ) ( double, void * );. evaluate the Integral of of a function f over the defined interval (a,b) passing a free function pointer; The integration function must be a free function and have a signature consistent with GSL functions:. <em>double my_function ( double x, void * p ) { ...... } </em>. This method is the most efficient since no internal adapter to GSL function is created.; @param f pointer to the integration function; @param p pointer to the Parameters of the function; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(ROOT::Math::GSLFuncPointer f, void* p). evaluate the Integral of a function f over the infinite interval (-inf,+inf) passing a free function pointer. double IntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer. double IntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) passing a free function pointer. double Integral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts). evaluate the Integral of a function f with knows singular points over the over a defined interval passing a free function pointer. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:12942,Integrability,Integrat,Integration,12942,"a free function pointer. double IntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer. double IntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) passing a free function pointer. double Integral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts). evaluate the Integral of a function f with knows singular points over the over a defined interval passing a free function pointer. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. void SetAbsTolerance(double absTolerance). set the desired absolute Error. void SetIntegrationRule(ROOT::Math::Integration::GKRule ). set the integration rule (Gauss-Kronrod rule).; The possible rules are defined in the Integration::GKRule enumeration.; The integration rule can be modified only for ADAPTIVE type integrations. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. IntegrationOneDim::Type GetType() const; get type name. { return fType; }. const char * GetTypeName() const. return the name. bool CheckFunction(); internal method to check validity of GSL function pointer.  Last changed: root/mathmore:$Id: GSLIntegrator.h 36764 2010-11-19 10:02:00Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:12973,Integrability,integrat,integration,12973,"a free function pointer. double IntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer. double IntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) passing a free function pointer. double Integral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts). evaluate the Integral of a function f with knows singular points over the over a defined interval passing a free function pointer. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. void SetAbsTolerance(double absTolerance). set the desired absolute Error. void SetIntegrationRule(ROOT::Math::Integration::GKRule ). set the integration rule (Gauss-Kronrod rule).; The possible rules are defined in the Integration::GKRule enumeration.; The integration rule can be modified only for ADAPTIVE type integrations. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. IntegrationOneDim::Type GetType() const; get type name. { return fType; }. const char * GetTypeName() const. return the name. bool CheckFunction(); internal method to check validity of GSL function pointer.  Last changed: root/mathmore:$Id: GSLIntegrator.h 36764 2010-11-19 10:02:00Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:13051,Integrability,Integrat,Integration,13051,"a free function pointer. double IntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer. double IntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) passing a free function pointer. double Integral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts). evaluate the Integral of a function f with knows singular points over the over a defined interval passing a free function pointer. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. void SetAbsTolerance(double absTolerance). set the desired absolute Error. void SetIntegrationRule(ROOT::Math::Integration::GKRule ). set the integration rule (Gauss-Kronrod rule).; The possible rules are defined in the Integration::GKRule enumeration.; The integration rule can be modified only for ADAPTIVE type integrations. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. IntegrationOneDim::Type GetType() const; get type name. { return fType; }. const char * GetTypeName() const. return the name. bool CheckFunction(); internal method to check validity of GSL function pointer.  Last changed: root/mathmore:$Id: GSLIntegrator.h 36764 2010-11-19 10:02:00Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:13089,Integrability,integrat,integration,13089,"a free function pointer. double IntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer. double IntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) passing a free function pointer. double Integral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts). evaluate the Integral of a function f with knows singular points over the over a defined interval passing a free function pointer. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. void SetAbsTolerance(double absTolerance). set the desired absolute Error. void SetIntegrationRule(ROOT::Math::Integration::GKRule ). set the integration rule (Gauss-Kronrod rule).; The possible rules are defined in the Integration::GKRule enumeration.; The integration rule can be modified only for ADAPTIVE type integrations. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. IntegrationOneDim::Type GetType() const; get type name. { return fType; }. const char * GetTypeName() const. return the name. bool CheckFunction(); internal method to check validity of GSL function pointer.  Last changed: root/mathmore:$Id: GSLIntegrator.h 36764 2010-11-19 10:02:00Z moneta $  Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html
