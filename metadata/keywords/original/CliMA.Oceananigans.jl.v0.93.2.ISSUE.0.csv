id,quality_attribute,keyword,matched_word,match_idx,sentence,source,author,repo,version,wiki,url
https://github.com/CliMA/Oceananigans.jl/pull/4:75,Testability,test,tests,75,"This fixes a minor bug in the grid constructor and contributes some simple tests to verify correct grid construction. It also adds the syntax. ```julia; g = RegularCartesianGrid(Float32, (nx, ny, nz), (Lx, Ly, Lz)); ```. for constructing grids with element type `Float32` (for example).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/4
https://github.com/CliMA/Oceananigans.jl/pull/4:68,Usability,simpl,simple,68,"This fixes a minor bug in the grid constructor and contributes some simple tests to verify correct grid construction. It also adds the syntax. ```julia; g = RegularCartesianGrid(Float32, (nx, ny, nz), (Lx, Ly, Lz)); ```. for constructing grids with element type `Float32` (for example).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/4
https://github.com/CliMA/Oceananigans.jl/issues/5:565,Usability,intuit,intuitive,565,"@glwagner Mostly a couple of notes of where I was in case you're thinking of working on the abstractions:. Currently `Field` is a struct with an `f::Array` in them, and are collected together in a struct of type `FieldCollection`. This kind of sucks because to create a new set of velocity + tracer fields and set the surface temperature field to 300 K for example, the code looks like:; ```; using OceanDispatch; g = RegularCartesianGrid((100, 100, 50), (2000, 2000, 1000), Float64); fs = Fields(g); fs.θ.f[:, :, 1] .= 300; ```; when I think it would be much more intuitive to be able to just write `fs.θ[:, :, 1] .= 300`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/5
https://github.com/CliMA/Oceananigans.jl/issues/7:132,Testability,test,tested,132,"The 3D solver with mixed boundary conditions (periodic in the horizontal with DFTs, Neumann in the vertical with DCTs) works now as tested against an analytic solution but for some reason once I switched to DCTs it's only first-order convergent. The relevant function is [`solve_poisson_3d_mbc`](https://github.com/ali-ramadhan/OceanDispatch.jl/blob/d7310255347ced6c12472903c07c7e0004882a44/src/spectral_solvers.jl#L121). ![solve_poisson_3d_mbc first order convergence](https://user-images.githubusercontent.com/20099589/48667435-603d5080-eaa3-11e8-9fb0-5dabc47ebcbb.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/7
https://github.com/CliMA/Oceananigans.jl/issues/8:172,Deployability,update,update,172,"I guess this is not something I was thinking of but John pointed out that it's crucial that the Fourier-spectral solver returns a nonhydrostatic pressure that when used to update the velocity field, produces a velocity field that is non-divergent at every grid point. Otherwise mass is being unphysically accumulated and tracer quantities will also be accumulated due to nonzero Q(∇·**u**) terms in the flux divergence operators ∇·(**u**Q) = Q(∇·**u**) + **u**·∇Q, leading to divergences and blowups. Right now the wavenumbers are computed as; ```; kx = 2π/Lx # DFT; ky = 2π/Ly # DFT; kz = 1π/Ly # DCT; ```; which should lead to a solver whose solutions converge spectrally. While it may solve for the pressure at the center of the cells very accurately, if ∇·**u** is non-zero this will be a big problem. This will require some testing on my part to see which solver best satisfies ∇·**u**. If we can satisfy it to machine precision, that would be amazing. If not, hopefully it can satisfy it better than the conjugate-gradient method and then we can use the continuity equation to enforce ∇·**u**=0. An alternative (not sure if this would work) is to discretize the derivative operators using a second-order centered-difference scheme (which I believe I've done for the 1D solver, and previous 3D solver) which explicitly places the discretization points on the center of the cells. Then the wavenumbers are; ```; kˣ² = (4 / Δx²) * sin(πl / Nˣ)² # DFT; kʸ² = (4 / Δy²) * sin(πm / Nʸ)² # DFT; kᶻ² = (2 / Δz²) * (cos(πn / Nᶻ) - 1) # DCT; ```; and of course you expect second-order convergence. But if it better satisfies ∇·**u**=0 then it might be the way to go. You can also derive wavenumbers for fourth-order discretization. EDIT: Fixed second-order wavenumbers.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/8
https://github.com/CliMA/Oceananigans.jl/issues/8:829,Testability,test,testing,829,"I guess this is not something I was thinking of but John pointed out that it's crucial that the Fourier-spectral solver returns a nonhydrostatic pressure that when used to update the velocity field, produces a velocity field that is non-divergent at every grid point. Otherwise mass is being unphysically accumulated and tracer quantities will also be accumulated due to nonzero Q(∇·**u**) terms in the flux divergence operators ∇·(**u**Q) = Q(∇·**u**) + **u**·∇Q, leading to divergences and blowups. Right now the wavenumbers are computed as; ```; kx = 2π/Lx # DFT; ky = 2π/Ly # DFT; kz = 1π/Ly # DCT; ```; which should lead to a solver whose solutions converge spectrally. While it may solve for the pressure at the center of the cells very accurately, if ∇·**u** is non-zero this will be a big problem. This will require some testing on my part to see which solver best satisfies ∇·**u**. If we can satisfy it to machine precision, that would be amazing. If not, hopefully it can satisfy it better than the conjugate-gradient method and then we can use the continuity equation to enforce ∇·**u**=0. An alternative (not sure if this would work) is to discretize the derivative operators using a second-order centered-difference scheme (which I believe I've done for the 1D solver, and previous 3D solver) which explicitly places the discretization points on the center of the cells. Then the wavenumbers are; ```; kˣ² = (4 / Δx²) * sin(πl / Nˣ)² # DFT; kʸ² = (4 / Δy²) * sin(πm / Nʸ)² # DFT; kᶻ² = (2 / Δz²) * (cos(πn / Nᶻ) - 1) # DCT; ```; and of course you expect second-order convergence. But if it better satisfies ∇·**u**=0 then it might be the way to go. You can also derive wavenumbers for fourth-order discretization. EDIT: Fixed second-order wavenumbers.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/8
https://github.com/CliMA/Oceananigans.jl/issues/9:349,Usability,intuit,intuitively,349,"@ali-ramadhan this looks odd to me; https://github.com/ali-ramadhan/OceanDispatch.jl/blob/c4aaa79323008270294d9052c088da7ddaf47fb2/src/operators.jl#L34. if I do ; ```; julia> a=Vector(1:4);circshift(a,1); ```; I get; ```; 4-element Array{Int64,1}:; 4; 1; 2; 3; ```. doesn't this mean that ; ```; δˣ(f) = (f .- circshift(f, (1, 0, 0))); ```. is more intuitively. ```; δˣ(f) = (circshift(f, (1, 0, 0)) .- f); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/9
https://github.com/CliMA/Oceananigans.jl/issues/13:747,Testability,benchmark,benchmark,747,"Apparently it's 4~5x faster to do operations on `Field.data` instead of `Field` even thought I've inlined `getindex` and `setindex!`, not that it changes things much.; ```julia; @inline getindex(f::Field, inds...) = getindex(f.data, inds...); @inline setindex!(f::Field, v, inds...) = setindex!(f.data, v, inds...); ```; Probably just missing something simple but for now I'll use `Field.data`. Would be nice to figure this out though. ```julia; g = RegularCartesianGrid((100, 100, 100), (10, 10, 10)); f1, f2 = CellField(g), FaceFieldX(g). function δx1!(g::RegularCartesianGrid, f::CellField, δxf::FaceField); for k in 1:g.Nz, j in 1:g.Ny, i in 1:g.Nx; @inbounds δxf[i, j, k] = f[i, j, k] - f[decmod1(i, g.Nx), j, k]; end; end; ```; ```; julia> @benchmark δx1!(g, f1, f2); BenchmarkTools.Trial:; memory estimate: 0 bytes; allocs estimate: 0; --------------; minimum time: 4.542 ms (0.00% GC); median time: 5.007 ms (0.00% GC); mean time: 5.120 ms (0.00% GC); maximum time: 11.010 ms (0.00% GC); --------------; samples: 975; evals/sample: 1; ```; ```julia; function δx2!(g::RegularCartesianGrid, f::CellField, δxf::FaceField); for k in 1:g.Nz, j in 1:g.Ny, i in 1:g.Nx; @inbounds δxf.data[i, j, k] = f.data[i, j, k] - f.data[decmod1(i, g.Nx), j, k]; end; end; ```; ```; julia> @benchmark δx2!(g, f2, f1); BenchmarkTools.Trial:; memory estimate: 0 bytes; allocs estimate: 0; --------------; minimum time: 1.099 ms (0.00% GC); median time: 1.198 ms (0.00% GC); mean time: 1.253 ms (0.00% GC); maximum time: 2.679 ms (0.00% GC); --------------; samples: 3967; evals/sample: 1; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/13
https://github.com/CliMA/Oceananigans.jl/issues/13:774,Testability,Benchmark,BenchmarkTools,774,"Apparently it's 4~5x faster to do operations on `Field.data` instead of `Field` even thought I've inlined `getindex` and `setindex!`, not that it changes things much.; ```julia; @inline getindex(f::Field, inds...) = getindex(f.data, inds...); @inline setindex!(f::Field, v, inds...) = setindex!(f.data, v, inds...); ```; Probably just missing something simple but for now I'll use `Field.data`. Would be nice to figure this out though. ```julia; g = RegularCartesianGrid((100, 100, 100), (10, 10, 10)); f1, f2 = CellField(g), FaceFieldX(g). function δx1!(g::RegularCartesianGrid, f::CellField, δxf::FaceField); for k in 1:g.Nz, j in 1:g.Ny, i in 1:g.Nx; @inbounds δxf[i, j, k] = f[i, j, k] - f[decmod1(i, g.Nx), j, k]; end; end; ```; ```; julia> @benchmark δx1!(g, f1, f2); BenchmarkTools.Trial:; memory estimate: 0 bytes; allocs estimate: 0; --------------; minimum time: 4.542 ms (0.00% GC); median time: 5.007 ms (0.00% GC); mean time: 5.120 ms (0.00% GC); maximum time: 11.010 ms (0.00% GC); --------------; samples: 975; evals/sample: 1; ```; ```julia; function δx2!(g::RegularCartesianGrid, f::CellField, δxf::FaceField); for k in 1:g.Nz, j in 1:g.Ny, i in 1:g.Nx; @inbounds δxf.data[i, j, k] = f.data[i, j, k] - f.data[decmod1(i, g.Nx), j, k]; end; end; ```; ```; julia> @benchmark δx2!(g, f2, f1); BenchmarkTools.Trial:; memory estimate: 0 bytes; allocs estimate: 0; --------------; minimum time: 1.099 ms (0.00% GC); median time: 1.198 ms (0.00% GC); mean time: 1.253 ms (0.00% GC); maximum time: 2.679 ms (0.00% GC); --------------; samples: 3967; evals/sample: 1; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/13
https://github.com/CliMA/Oceananigans.jl/issues/13:1279,Testability,benchmark,benchmark,1279,"Apparently it's 4~5x faster to do operations on `Field.data` instead of `Field` even thought I've inlined `getindex` and `setindex!`, not that it changes things much.; ```julia; @inline getindex(f::Field, inds...) = getindex(f.data, inds...); @inline setindex!(f::Field, v, inds...) = setindex!(f.data, v, inds...); ```; Probably just missing something simple but for now I'll use `Field.data`. Would be nice to figure this out though. ```julia; g = RegularCartesianGrid((100, 100, 100), (10, 10, 10)); f1, f2 = CellField(g), FaceFieldX(g). function δx1!(g::RegularCartesianGrid, f::CellField, δxf::FaceField); for k in 1:g.Nz, j in 1:g.Ny, i in 1:g.Nx; @inbounds δxf[i, j, k] = f[i, j, k] - f[decmod1(i, g.Nx), j, k]; end; end; ```; ```; julia> @benchmark δx1!(g, f1, f2); BenchmarkTools.Trial:; memory estimate: 0 bytes; allocs estimate: 0; --------------; minimum time: 4.542 ms (0.00% GC); median time: 5.007 ms (0.00% GC); mean time: 5.120 ms (0.00% GC); maximum time: 11.010 ms (0.00% GC); --------------; samples: 975; evals/sample: 1; ```; ```julia; function δx2!(g::RegularCartesianGrid, f::CellField, δxf::FaceField); for k in 1:g.Nz, j in 1:g.Ny, i in 1:g.Nx; @inbounds δxf.data[i, j, k] = f.data[i, j, k] - f.data[decmod1(i, g.Nx), j, k]; end; end; ```; ```; julia> @benchmark δx2!(g, f2, f1); BenchmarkTools.Trial:; memory estimate: 0 bytes; allocs estimate: 0; --------------; minimum time: 1.099 ms (0.00% GC); median time: 1.198 ms (0.00% GC); mean time: 1.253 ms (0.00% GC); maximum time: 2.679 ms (0.00% GC); --------------; samples: 3967; evals/sample: 1; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/13
https://github.com/CliMA/Oceananigans.jl/issues/13:1306,Testability,Benchmark,BenchmarkTools,1306,"Apparently it's 4~5x faster to do operations on `Field.data` instead of `Field` even thought I've inlined `getindex` and `setindex!`, not that it changes things much.; ```julia; @inline getindex(f::Field, inds...) = getindex(f.data, inds...); @inline setindex!(f::Field, v, inds...) = setindex!(f.data, v, inds...); ```; Probably just missing something simple but for now I'll use `Field.data`. Would be nice to figure this out though. ```julia; g = RegularCartesianGrid((100, 100, 100), (10, 10, 10)); f1, f2 = CellField(g), FaceFieldX(g). function δx1!(g::RegularCartesianGrid, f::CellField, δxf::FaceField); for k in 1:g.Nz, j in 1:g.Ny, i in 1:g.Nx; @inbounds δxf[i, j, k] = f[i, j, k] - f[decmod1(i, g.Nx), j, k]; end; end; ```; ```; julia> @benchmark δx1!(g, f1, f2); BenchmarkTools.Trial:; memory estimate: 0 bytes; allocs estimate: 0; --------------; minimum time: 4.542 ms (0.00% GC); median time: 5.007 ms (0.00% GC); mean time: 5.120 ms (0.00% GC); maximum time: 11.010 ms (0.00% GC); --------------; samples: 975; evals/sample: 1; ```; ```julia; function δx2!(g::RegularCartesianGrid, f::CellField, δxf::FaceField); for k in 1:g.Nz, j in 1:g.Ny, i in 1:g.Nx; @inbounds δxf.data[i, j, k] = f.data[i, j, k] - f.data[decmod1(i, g.Nx), j, k]; end; end; ```; ```; julia> @benchmark δx2!(g, f2, f1); BenchmarkTools.Trial:; memory estimate: 0 bytes; allocs estimate: 0; --------------; minimum time: 1.099 ms (0.00% GC); median time: 1.198 ms (0.00% GC); mean time: 1.253 ms (0.00% GC); maximum time: 2.679 ms (0.00% GC); --------------; samples: 3967; evals/sample: 1; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/13
https://github.com/CliMA/Oceananigans.jl/issues/13:353,Usability,simpl,simple,353,"Apparently it's 4~5x faster to do operations on `Field.data` instead of `Field` even thought I've inlined `getindex` and `setindex!`, not that it changes things much.; ```julia; @inline getindex(f::Field, inds...) = getindex(f.data, inds...); @inline setindex!(f::Field, v, inds...) = setindex!(f.data, v, inds...); ```; Probably just missing something simple but for now I'll use `Field.data`. Would be nice to figure this out though. ```julia; g = RegularCartesianGrid((100, 100, 100), (10, 10, 10)); f1, f2 = CellField(g), FaceFieldX(g). function δx1!(g::RegularCartesianGrid, f::CellField, δxf::FaceField); for k in 1:g.Nz, j in 1:g.Ny, i in 1:g.Nx; @inbounds δxf[i, j, k] = f[i, j, k] - f[decmod1(i, g.Nx), j, k]; end; end; ```; ```; julia> @benchmark δx1!(g, f1, f2); BenchmarkTools.Trial:; memory estimate: 0 bytes; allocs estimate: 0; --------------; minimum time: 4.542 ms (0.00% GC); median time: 5.007 ms (0.00% GC); mean time: 5.120 ms (0.00% GC); maximum time: 11.010 ms (0.00% GC); --------------; samples: 975; evals/sample: 1; ```; ```julia; function δx2!(g::RegularCartesianGrid, f::CellField, δxf::FaceField); for k in 1:g.Nz, j in 1:g.Ny, i in 1:g.Nx; @inbounds δxf.data[i, j, k] = f.data[i, j, k] - f.data[decmod1(i, g.Nx), j, k]; end; end; ```; ```; julia> @benchmark δx2!(g, f2, f1); BenchmarkTools.Trial:; memory estimate: 0 bytes; allocs estimate: 0; --------------; minimum time: 1.099 ms (0.00% GC); median time: 1.198 ms (0.00% GC); mean time: 1.253 ms (0.00% GC); maximum time: 2.679 ms (0.00% GC); --------------; samples: 3967; evals/sample: 1; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/13
https://github.com/CliMA/Oceananigans.jl/pull/15:333,Performance,optimiz,optimize,333,"Coded some difference and averaging operators using the `@views` macro. Just a proof of concept right now as the model goes run on a GPU when creating a `Problem` with `arch=:gpu`, but because the kernels are very small (and there are many of them) it's very slow. At least we have something that runs, now we can worry about how to optimize for performance. Some hacks were used to get this to work but the operators and time stepping is completely shared. The only bit that is different is the quasi-spectral solver as cuFFT does not perform R2R or DCT transforms (`FFTW.REDFT01` and `FFTW.REDFT10`) in particular. A GPU-compatible DCT/IDCT transform was coded that calculates the DCT/IDCT in terms of `fft!` and `ifft!`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/15
https://github.com/CliMA/Oceananigans.jl/pull/15:346,Performance,perform,performance,346,"Coded some difference and averaging operators using the `@views` macro. Just a proof of concept right now as the model goes run on a GPU when creating a `Problem` with `arch=:gpu`, but because the kernels are very small (and there are many of them) it's very slow. At least we have something that runs, now we can worry about how to optimize for performance. Some hacks were used to get this to work but the operators and time stepping is completely shared. The only bit that is different is the quasi-spectral solver as cuFFT does not perform R2R or DCT transforms (`FFTW.REDFT01` and `FFTW.REDFT10`) in particular. A GPU-compatible DCT/IDCT transform was coded that calculates the DCT/IDCT in terms of `fft!` and `ifft!`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/15
https://github.com/CliMA/Oceananigans.jl/pull/15:536,Performance,perform,perform,536,"Coded some difference and averaging operators using the `@views` macro. Just a proof of concept right now as the model goes run on a GPU when creating a `Problem` with `arch=:gpu`, but because the kernels are very small (and there are many of them) it's very slow. At least we have something that runs, now we can worry about how to optimize for performance. Some hacks were used to get this to work but the operators and time stepping is completely shared. The only bit that is different is the quasi-spectral solver as cuFFT does not perform R2R or DCT transforms (`FFTW.REDFT01` and `FFTW.REDFT10`) in particular. A GPU-compatible DCT/IDCT transform was coded that calculates the DCT/IDCT in terms of `fft!` and `ifft!`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/15
https://github.com/CliMA/Oceananigans.jl/issues/26:50,Usability,simpl,simple,50,"See `show(io::IO, g::RegularCartesianGrid)` for a simple example.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/26
https://github.com/CliMA/Oceananigans.jl/issues/35:63,Modifiability,evolve,evolve,63,"E.g. no need to calculate y-derivatives or y-averages, or even evolve v if the model is a 2D xz-slice. But this is low priority as it only affects the already fast 2D and 1D models.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/35
https://github.com/CliMA/Oceananigans.jl/issues/37:55,Energy Efficiency,adapt,adaptive,55,"This is probably fine as I don't think the MITgcm uses adaptive time stepping and for what we do I doubt we'll be changing Δt halfway through a simulation, but as it stands if Δt changes it will break some code, `read_output(...)` methods in particular.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/37
https://github.com/CliMA/Oceananigans.jl/issues/37:55,Modifiability,adapt,adaptive,55,"This is probably fine as I don't think the MITgcm uses adaptive time stepping and for what we do I doubt we'll be changing Δt halfway through a simulation, but as it stands if Δt changes it will break some code, `read_output(...)` methods in particular.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/37
https://github.com/CliMA/Oceananigans.jl/issues/42:154,Modifiability,flexible,flexible,154,https://github.com/ali-ramadhan/Oceananigans.jl/blob/a41c604e9360ba79ce11efe6d4d6370bf79a3cc6/src/model.jl#L1. It would make model construction much more flexible. Would this hinder performance?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/42
https://github.com/CliMA/Oceananigans.jl/issues/42:182,Performance,perform,performance,182,https://github.com/ali-ramadhan/Oceananigans.jl/blob/a41c604e9360ba79ce11efe6d4d6370bf79a3cc6/src/model.jl#L1. It would make model construction much more flexible. Would this hinder performance?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/42
https://github.com/CliMA/Oceananigans.jl/issues/44:295,Performance,perform,performance,295,"Jumping the gun here but instead of accessing e.g. `model.tracers.T[i, j, k+1]` multiple times during a time step, can it be prefetched, i.e. `T_kp1 = model.tracers.T[i, j, k+1]`, and then reused multiple times? Would the value or the pointer need to be accessed?. The only reason to do this is performance gain. Will this work or will the code turn into spaghetti? Can some sort of compiler figure this stuff out for us?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/44
https://github.com/CliMA/Oceananigans.jl/issues/44:36,Security,access,accessing,36,"Jumping the gun here but instead of accessing e.g. `model.tracers.T[i, j, k+1]` multiple times during a time step, can it be prefetched, i.e. `T_kp1 = model.tracers.T[i, j, k+1]`, and then reused multiple times? Would the value or the pointer need to be accessed?. The only reason to do this is performance gain. Will this work or will the code turn into spaghetti? Can some sort of compiler figure this stuff out for us?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/44
https://github.com/CliMA/Oceananigans.jl/issues/44:254,Security,access,accessed,254,"Jumping the gun here but instead of accessing e.g. `model.tracers.T[i, j, k+1]` multiple times during a time step, can it be prefetched, i.e. `T_kp1 = model.tracers.T[i, j, k+1]`, and then reused multiple times? Would the value or the pointer need to be accessed?. The only reason to do this is performance gain. Will this work or will the code turn into spaghetti? Can some sort of compiler figure this stuff out for us?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/44
https://github.com/CliMA/Oceananigans.jl/issues/45:770,Modifiability,parameteriz,parameterized,770,"[This `if`-statement](https://github.com/ali-ramadhan/Oceananigans.jl/blob/e1be1f0e3f067cdb4236eb5e7b962e0c772ce4d1/src/time_steppers.jl#L140) is not necessary, because the architecture can be known from the array types of the `CellField`s. Specifically, [this line](https://github.com/ali-ramadhan/Oceananigans.jl/blob/e1be1f0e3f067cdb4236eb5e7b962e0c772ce4d1/src/spectral_solvers.jl#L389) can be changed to. ```; function solve_poisson_3d_ppn_planned!(ssp::SpectralSolverParameters, g::RegularCartesianGrid, f::CellField{T}, ϕ::CellField{T}) where T<:CuArray. ... end; ```. I think it would actually be preferable to dispatch on the type of the arrays in `RegularCartesianGrid`. However, it does not appear that the arrays representing the coordinates of the grid are parameterized in [the definition of `RegularCartesianGrid`](https://github.com/ali-ramadhan/Oceananigans.jl/blob/e1be1f0e3f067cdb4236eb5e7b962e0c772ce4d1/src/grids.jl#L12). Why is that? . If the array type of the problem is part of `RegularCartesianGrid`, then dispatch can be used in place of `if`-statements all over the code, especially in `fields.jl`. Finally, the term 'spectral solvers' is misleading here. The solver does not have spectral accuracy; it simply uses the FFT, which *happens* to be used to solve different problems that have a 'spectral' character.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/45
https://github.com/CliMA/Oceananigans.jl/issues/45:1230,Usability,simpl,simply,1230,"[This `if`-statement](https://github.com/ali-ramadhan/Oceananigans.jl/blob/e1be1f0e3f067cdb4236eb5e7b962e0c772ce4d1/src/time_steppers.jl#L140) is not necessary, because the architecture can be known from the array types of the `CellField`s. Specifically, [this line](https://github.com/ali-ramadhan/Oceananigans.jl/blob/e1be1f0e3f067cdb4236eb5e7b962e0c772ce4d1/src/spectral_solvers.jl#L389) can be changed to. ```; function solve_poisson_3d_ppn_planned!(ssp::SpectralSolverParameters, g::RegularCartesianGrid, f::CellField{T}, ϕ::CellField{T}) where T<:CuArray. ... end; ```. I think it would actually be preferable to dispatch on the type of the arrays in `RegularCartesianGrid`. However, it does not appear that the arrays representing the coordinates of the grid are parameterized in [the definition of `RegularCartesianGrid`](https://github.com/ali-ramadhan/Oceananigans.jl/blob/e1be1f0e3f067cdb4236eb5e7b962e0c772ce4d1/src/grids.jl#L12). Why is that? . If the array type of the problem is part of `RegularCartesianGrid`, then dispatch can be used in place of `if`-statements all over the code, especially in `fields.jl`. Finally, the term 'spectral solvers' is misleading here. The solver does not have spectral accuracy; it simply uses the FFT, which *happens* to be used to solve different problems that have a 'spectral' character.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/45
https://github.com/CliMA/Oceananigans.jl/issues/47:173,Modifiability,variab,variable,173,"Current operators assume constant Δz which allow the model to use faster operators and use a tiny bit less space, so they'd have to be rewritten a tiny bit to account for a variable Δz when that gets implemented. We can either write new operators that get dispatched on `HorizontallyRegularCartesianGrid` structs (already possible), or maybe the performance gain is so tiny that we just make `RegularCartesianGrid` a subset of `HorizontallyRegularCartesianGrid` and only have one set of operators. `HorizontallyRegularCartesianGrid` might be a descriptive but pretty bad struct name.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/47
https://github.com/CliMA/Oceananigans.jl/issues/47:346,Performance,perform,performance,346,"Current operators assume constant Δz which allow the model to use faster operators and use a tiny bit less space, so they'd have to be rewritten a tiny bit to account for a variable Δz when that gets implemented. We can either write new operators that get dispatched on `HorizontallyRegularCartesianGrid` structs (already possible), or maybe the performance gain is so tiny that we just make `RegularCartesianGrid` a subset of `HorizontallyRegularCartesianGrid` and only have one set of operators. `HorizontallyRegularCartesianGrid` might be a descriptive but pretty bad struct name.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/47
https://github.com/CliMA/Oceananigans.jl/issues/53:51,Testability,test,test,51,"Right now easiest thing to do would be to manually test the package on Supercloud or somewhere with multiple GPUs, but CI with GPUs would be nice. See for ideas: https://github.com/JuliaGPU/gitlab-ci. Might not be worth setting up for a while, seems like too much work.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/53
https://github.com/CliMA/Oceananigans.jl/pull/54:1106,Deployability,integrat,integrating,1106,"Rewrote the time stepping algorithm to perform operations element-wise which allows the MITgcm algorithm to fully utilize a GPU (for large enough problems). And the same code runs on the CPU. Essentially we have a massive triple for loop iterating over all the grid points and functions that e.g. calculate u-momentum advection at grid point (i,j,k). The code is ugly and unorganized right now but I just wanted to get something working. Now we can work on cleaning up the code and optimizing performance. You can see for yourselves how bad the native type element-wise operators are but the time stepping loop should clean up nicely. It's split up into 4-5 kernels as the GPU needs to synchronize between certain steps. I've had to make some compromises writing it for the GPU, mainly by stripping away all the abstractions as the GPU will only deal with native data types. But we can figure this stuff out, it can only get better from here. This time stepping will essentially replace what's already in place (and turn the code into a CPU/GPU capable package) so might as well merge and start working on integrating it (and getting some sort sort of GPU CI working). Resolves #49",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/54
https://github.com/CliMA/Oceananigans.jl/pull/54:686,Integrability,synchroniz,synchronize,686,"Rewrote the time stepping algorithm to perform operations element-wise which allows the MITgcm algorithm to fully utilize a GPU (for large enough problems). And the same code runs on the CPU. Essentially we have a massive triple for loop iterating over all the grid points and functions that e.g. calculate u-momentum advection at grid point (i,j,k). The code is ugly and unorganized right now but I just wanted to get something working. Now we can work on cleaning up the code and optimizing performance. You can see for yourselves how bad the native type element-wise operators are but the time stepping loop should clean up nicely. It's split up into 4-5 kernels as the GPU needs to synchronize between certain steps. I've had to make some compromises writing it for the GPU, mainly by stripping away all the abstractions as the GPU will only deal with native data types. But we can figure this stuff out, it can only get better from here. This time stepping will essentially replace what's already in place (and turn the code into a CPU/GPU capable package) so might as well merge and start working on integrating it (and getting some sort sort of GPU CI working). Resolves #49",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/54
https://github.com/CliMA/Oceananigans.jl/pull/54:1106,Integrability,integrat,integrating,1106,"Rewrote the time stepping algorithm to perform operations element-wise which allows the MITgcm algorithm to fully utilize a GPU (for large enough problems). And the same code runs on the CPU. Essentially we have a massive triple for loop iterating over all the grid points and functions that e.g. calculate u-momentum advection at grid point (i,j,k). The code is ugly and unorganized right now but I just wanted to get something working. Now we can work on cleaning up the code and optimizing performance. You can see for yourselves how bad the native type element-wise operators are but the time stepping loop should clean up nicely. It's split up into 4-5 kernels as the GPU needs to synchronize between certain steps. I've had to make some compromises writing it for the GPU, mainly by stripping away all the abstractions as the GPU will only deal with native data types. But we can figure this stuff out, it can only get better from here. This time stepping will essentially replace what's already in place (and turn the code into a CPU/GPU capable package) so might as well merge and start working on integrating it (and getting some sort sort of GPU CI working). Resolves #49",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/54
https://github.com/CliMA/Oceananigans.jl/pull/54:39,Performance,perform,perform,39,"Rewrote the time stepping algorithm to perform operations element-wise which allows the MITgcm algorithm to fully utilize a GPU (for large enough problems). And the same code runs on the CPU. Essentially we have a massive triple for loop iterating over all the grid points and functions that e.g. calculate u-momentum advection at grid point (i,j,k). The code is ugly and unorganized right now but I just wanted to get something working. Now we can work on cleaning up the code and optimizing performance. You can see for yourselves how bad the native type element-wise operators are but the time stepping loop should clean up nicely. It's split up into 4-5 kernels as the GPU needs to synchronize between certain steps. I've had to make some compromises writing it for the GPU, mainly by stripping away all the abstractions as the GPU will only deal with native data types. But we can figure this stuff out, it can only get better from here. This time stepping will essentially replace what's already in place (and turn the code into a CPU/GPU capable package) so might as well merge and start working on integrating it (and getting some sort sort of GPU CI working). Resolves #49",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/54
https://github.com/CliMA/Oceananigans.jl/pull/54:482,Performance,optimiz,optimizing,482,"Rewrote the time stepping algorithm to perform operations element-wise which allows the MITgcm algorithm to fully utilize a GPU (for large enough problems). And the same code runs on the CPU. Essentially we have a massive triple for loop iterating over all the grid points and functions that e.g. calculate u-momentum advection at grid point (i,j,k). The code is ugly and unorganized right now but I just wanted to get something working. Now we can work on cleaning up the code and optimizing performance. You can see for yourselves how bad the native type element-wise operators are but the time stepping loop should clean up nicely. It's split up into 4-5 kernels as the GPU needs to synchronize between certain steps. I've had to make some compromises writing it for the GPU, mainly by stripping away all the abstractions as the GPU will only deal with native data types. But we can figure this stuff out, it can only get better from here. This time stepping will essentially replace what's already in place (and turn the code into a CPU/GPU capable package) so might as well merge and start working on integrating it (and getting some sort sort of GPU CI working). Resolves #49",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/54
https://github.com/CliMA/Oceananigans.jl/pull/54:493,Performance,perform,performance,493,"Rewrote the time stepping algorithm to perform operations element-wise which allows the MITgcm algorithm to fully utilize a GPU (for large enough problems). And the same code runs on the CPU. Essentially we have a massive triple for loop iterating over all the grid points and functions that e.g. calculate u-momentum advection at grid point (i,j,k). The code is ugly and unorganized right now but I just wanted to get something working. Now we can work on cleaning up the code and optimizing performance. You can see for yourselves how bad the native type element-wise operators are but the time stepping loop should clean up nicely. It's split up into 4-5 kernels as the GPU needs to synchronize between certain steps. I've had to make some compromises writing it for the GPU, mainly by stripping away all the abstractions as the GPU will only deal with native data types. But we can figure this stuff out, it can only get better from here. This time stepping will essentially replace what's already in place (and turn the code into a CPU/GPU capable package) so might as well merge and start working on integrating it (and getting some sort sort of GPU CI working). Resolves #49",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/54
https://github.com/CliMA/Oceananigans.jl/issues/56:751,Availability,error,errors,751,"I could not get the Poisson pressure solver to work on the GPU. Most of it works but CUDA does not have a DCT function so I had to perform the DCT/IDCT in terms of the FFT/IFFT. The DCT/IDCT functions work in isolation (regression tested with `FFTW.r2r!`, see link to Jupyter notebook below) but not in the Poisson solver. More specifically, the IDCT fails when applied to the third dimension (after or before the IFFT is applied to dimensions 1 and 2). For now I got around this by copying the right hand side to the CPU, doing the transform on the CPU, and copying the geopotential back to the GPU. This operation is so much slower than the time stepping that it takes up like 98%+ of wall clock time. It might also be introducing further numerical errors. Link to current Poisson GPU solver:; https://github.com/ali-ramadhan/Oceananigans.jl/blob/93aa0038b3126470f263475d648bceb9562bbe91/src/spectral_solvers.jl#L421. Messy Jupyter notebook: [Testing DCT/IDCT on the GPU](https://github.com/ali-ramadhan/random-jupyter-notebooks/blob/master/Oceananigans.jl/DCT%2BIDCT%20from%20DFT%2BIDFT.ipynb). Messy Jupyter notebook: [Testing GPU Poisson solver](https://github.com/ali-ramadhan/random-jupyter-notebooks/blob/master/Oceananigans.jl/GPU/Testing%20GPU%20Poisson%20solver.ipynb)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/56
https://github.com/CliMA/Oceananigans.jl/issues/56:131,Performance,perform,perform,131,"I could not get the Poisson pressure solver to work on the GPU. Most of it works but CUDA does not have a DCT function so I had to perform the DCT/IDCT in terms of the FFT/IFFT. The DCT/IDCT functions work in isolation (regression tested with `FFTW.r2r!`, see link to Jupyter notebook below) but not in the Poisson solver. More specifically, the IDCT fails when applied to the third dimension (after or before the IFFT is applied to dimensions 1 and 2). For now I got around this by copying the right hand side to the CPU, doing the transform on the CPU, and copying the geopotential back to the GPU. This operation is so much slower than the time stepping that it takes up like 98%+ of wall clock time. It might also be introducing further numerical errors. Link to current Poisson GPU solver:; https://github.com/ali-ramadhan/Oceananigans.jl/blob/93aa0038b3126470f263475d648bceb9562bbe91/src/spectral_solvers.jl#L421. Messy Jupyter notebook: [Testing DCT/IDCT on the GPU](https://github.com/ali-ramadhan/random-jupyter-notebooks/blob/master/Oceananigans.jl/DCT%2BIDCT%20from%20DFT%2BIDFT.ipynb). Messy Jupyter notebook: [Testing GPU Poisson solver](https://github.com/ali-ramadhan/random-jupyter-notebooks/blob/master/Oceananigans.jl/GPU/Testing%20GPU%20Poisson%20solver.ipynb)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/56
https://github.com/CliMA/Oceananigans.jl/issues/56:231,Testability,test,tested,231,"I could not get the Poisson pressure solver to work on the GPU. Most of it works but CUDA does not have a DCT function so I had to perform the DCT/IDCT in terms of the FFT/IFFT. The DCT/IDCT functions work in isolation (regression tested with `FFTW.r2r!`, see link to Jupyter notebook below) but not in the Poisson solver. More specifically, the IDCT fails when applied to the third dimension (after or before the IFFT is applied to dimensions 1 and 2). For now I got around this by copying the right hand side to the CPU, doing the transform on the CPU, and copying the geopotential back to the GPU. This operation is so much slower than the time stepping that it takes up like 98%+ of wall clock time. It might also be introducing further numerical errors. Link to current Poisson GPU solver:; https://github.com/ali-ramadhan/Oceananigans.jl/blob/93aa0038b3126470f263475d648bceb9562bbe91/src/spectral_solvers.jl#L421. Messy Jupyter notebook: [Testing DCT/IDCT on the GPU](https://github.com/ali-ramadhan/random-jupyter-notebooks/blob/master/Oceananigans.jl/DCT%2BIDCT%20from%20DFT%2BIDFT.ipynb). Messy Jupyter notebook: [Testing GPU Poisson solver](https://github.com/ali-ramadhan/random-jupyter-notebooks/blob/master/Oceananigans.jl/GPU/Testing%20GPU%20Poisson%20solver.ipynb)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/56
https://github.com/CliMA/Oceananigans.jl/issues/56:945,Testability,Test,Testing,945,"I could not get the Poisson pressure solver to work on the GPU. Most of it works but CUDA does not have a DCT function so I had to perform the DCT/IDCT in terms of the FFT/IFFT. The DCT/IDCT functions work in isolation (regression tested with `FFTW.r2r!`, see link to Jupyter notebook below) but not in the Poisson solver. More specifically, the IDCT fails when applied to the third dimension (after or before the IFFT is applied to dimensions 1 and 2). For now I got around this by copying the right hand side to the CPU, doing the transform on the CPU, and copying the geopotential back to the GPU. This operation is so much slower than the time stepping that it takes up like 98%+ of wall clock time. It might also be introducing further numerical errors. Link to current Poisson GPU solver:; https://github.com/ali-ramadhan/Oceananigans.jl/blob/93aa0038b3126470f263475d648bceb9562bbe91/src/spectral_solvers.jl#L421. Messy Jupyter notebook: [Testing DCT/IDCT on the GPU](https://github.com/ali-ramadhan/random-jupyter-notebooks/blob/master/Oceananigans.jl/DCT%2BIDCT%20from%20DFT%2BIDFT.ipynb). Messy Jupyter notebook: [Testing GPU Poisson solver](https://github.com/ali-ramadhan/random-jupyter-notebooks/blob/master/Oceananigans.jl/GPU/Testing%20GPU%20Poisson%20solver.ipynb)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/56
https://github.com/CliMA/Oceananigans.jl/issues/56:1123,Testability,Test,Testing,1123,"I could not get the Poisson pressure solver to work on the GPU. Most of it works but CUDA does not have a DCT function so I had to perform the DCT/IDCT in terms of the FFT/IFFT. The DCT/IDCT functions work in isolation (regression tested with `FFTW.r2r!`, see link to Jupyter notebook below) but not in the Poisson solver. More specifically, the IDCT fails when applied to the third dimension (after or before the IFFT is applied to dimensions 1 and 2). For now I got around this by copying the right hand side to the CPU, doing the transform on the CPU, and copying the geopotential back to the GPU. This operation is so much slower than the time stepping that it takes up like 98%+ of wall clock time. It might also be introducing further numerical errors. Link to current Poisson GPU solver:; https://github.com/ali-ramadhan/Oceananigans.jl/blob/93aa0038b3126470f263475d648bceb9562bbe91/src/spectral_solvers.jl#L421. Messy Jupyter notebook: [Testing DCT/IDCT on the GPU](https://github.com/ali-ramadhan/random-jupyter-notebooks/blob/master/Oceananigans.jl/DCT%2BIDCT%20from%20DFT%2BIDFT.ipynb). Messy Jupyter notebook: [Testing GPU Poisson solver](https://github.com/ali-ramadhan/random-jupyter-notebooks/blob/master/Oceananigans.jl/GPU/Testing%20GPU%20Poisson%20solver.ipynb)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/56
https://github.com/CliMA/Oceananigans.jl/issues/56:1240,Testability,Test,Testing,1240,"I could not get the Poisson pressure solver to work on the GPU. Most of it works but CUDA does not have a DCT function so I had to perform the DCT/IDCT in terms of the FFT/IFFT. The DCT/IDCT functions work in isolation (regression tested with `FFTW.r2r!`, see link to Jupyter notebook below) but not in the Poisson solver. More specifically, the IDCT fails when applied to the third dimension (after or before the IFFT is applied to dimensions 1 and 2). For now I got around this by copying the right hand side to the CPU, doing the transform on the CPU, and copying the geopotential back to the GPU. This operation is so much slower than the time stepping that it takes up like 98%+ of wall clock time. It might also be introducing further numerical errors. Link to current Poisson GPU solver:; https://github.com/ali-ramadhan/Oceananigans.jl/blob/93aa0038b3126470f263475d648bceb9562bbe91/src/spectral_solvers.jl#L421. Messy Jupyter notebook: [Testing DCT/IDCT on the GPU](https://github.com/ali-ramadhan/random-jupyter-notebooks/blob/master/Oceananigans.jl/DCT%2BIDCT%20from%20DFT%2BIDFT.ipynb). Messy Jupyter notebook: [Testing GPU Poisson solver](https://github.com/ali-ramadhan/random-jupyter-notebooks/blob/master/Oceananigans.jl/GPU/Testing%20GPU%20Poisson%20solver.ipynb)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/56
https://github.com/CliMA/Oceananigans.jl/issues/57:373,Energy Efficiency,Efficient,Efficient,373,"@vchuravy suggested using if-else statements instead of; ```julia; @inline incmod1(a, n) = a == n ? one(a) : a + 1; @inline decmod1(a, n) = a == 1 ? n : a - 1; ```; as it might be faster on the GPU. Also worth checking out Julia's `mod1(x, y)` function. I'll test a bunch of different mod1 functions once we have the algorithm fully working on the GPU. See also: [/r/Julia/Efficient wrap-around with 1-based indexing?](https://www.reddit.com/r/Julia/comments/6hhryc/efficient_wraparound_with_1based_indexing/)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/57
https://github.com/CliMA/Oceananigans.jl/issues/57:383,Integrability,wrap,wrap-around,383,"@vchuravy suggested using if-else statements instead of; ```julia; @inline incmod1(a, n) = a == n ? one(a) : a + 1; @inline decmod1(a, n) = a == 1 ? n : a - 1; ```; as it might be faster on the GPU. Also worth checking out Julia's `mod1(x, y)` function. I'll test a bunch of different mod1 functions once we have the algorithm fully working on the GPU. See also: [/r/Julia/Efficient wrap-around with 1-based indexing?](https://www.reddit.com/r/Julia/comments/6hhryc/efficient_wraparound_with_1based_indexing/)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/57
https://github.com/CliMA/Oceananigans.jl/issues/57:259,Testability,test,test,259,"@vchuravy suggested using if-else statements instead of; ```julia; @inline incmod1(a, n) = a == n ? one(a) : a + 1; @inline decmod1(a, n) = a == 1 ? n : a - 1; ```; as it might be faster on the GPU. Also worth checking out Julia's `mod1(x, y)` function. I'll test a bunch of different mod1 functions once we have the algorithm fully working on the GPU. See also: [/r/Julia/Efficient wrap-around with 1-based indexing?](https://www.reddit.com/r/Julia/comments/6hhryc/efficient_wraparound_with_1based_indexing/)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/57
https://github.com/CliMA/Oceananigans.jl/issues/58:314,Availability,down,down,314,@peterahrens suggested that instead of having `@inbounds` and `@inline` everywhere in [ops_regular_cartesian_grid_elementwise.jl](https://github.com/ali-ramadhan/Oceananigans.jl/blob/master/src/operators/ops_regular_cartesian_grid_elementwise.jl) we can use a `@inbounds begin` and it should propagate all the way down unless we explicitly use `@boundscheck`. See: [Julia Docs: Propagating inbounds](https://docs.julialang.org/en/v1/devdocs/boundscheck/index.html#Propagating-inbounds-1),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/58
https://github.com/CliMA/Oceananigans.jl/issues/59:673,Availability,down,down,673,"@peterahrens suggested removing `ModelMetadata` from `Field` structs and make the `Grid` a parameter, i.e. `Grid{T,G}` then it should be isbitstype. It's not isbits right now because T<:AbstractArray. Then we should be able to use some abstractions in the CPU/GPU element-wise kernels as well as multiple dispatch and won't need to have `δx_c2f`, `δx_f2c`, `δx_e2f`, `δx_f2e`, etc. Some goals for guidance:; - [ ] Prototype grid and field types that are `isbitstype`.; - [ ] Test that they do work with GPUifyLoops on the GPU. For this I will extend the example from https://github.com/vchuravy/GPUifyLoops.jl/pull/18; - [ ] Benchmark the simple example to see things slow down. I don't expect to see much of a difference.; - [ ] Refactor the operators and time stepping loop to use the new abstractions!; - [ ] Add tests to make sure any structure that may be passed to a CUDA kernel `isbitstype`. Just construct a bunch of grids, fields, and forcing functions and test that they are indeed `isbitstype`.; - [ ] Benchmark the model with `isbitstype` abstractions to make sure performance hasn't degraded.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/59
https://github.com/CliMA/Oceananigans.jl/issues/59:1096,Availability,degraded,degraded,1096,"@peterahrens suggested removing `ModelMetadata` from `Field` structs and make the `Grid` a parameter, i.e. `Grid{T,G}` then it should be isbitstype. It's not isbits right now because T<:AbstractArray. Then we should be able to use some abstractions in the CPU/GPU element-wise kernels as well as multiple dispatch and won't need to have `δx_c2f`, `δx_f2c`, `δx_e2f`, `δx_f2e`, etc. Some goals for guidance:; - [ ] Prototype grid and field types that are `isbitstype`.; - [ ] Test that they do work with GPUifyLoops on the GPU. For this I will extend the example from https://github.com/vchuravy/GPUifyLoops.jl/pull/18; - [ ] Benchmark the simple example to see things slow down. I don't expect to see much of a difference.; - [ ] Refactor the operators and time stepping loop to use the new abstractions!; - [ ] Add tests to make sure any structure that may be passed to a CUDA kernel `isbitstype`. Just construct a bunch of grids, fields, and forcing functions and test that they are indeed `isbitstype`.; - [ ] Benchmark the model with `isbitstype` abstractions to make sure performance hasn't degraded.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/59
https://github.com/CliMA/Oceananigans.jl/issues/59:543,Modifiability,extend,extend,543,"@peterahrens suggested removing `ModelMetadata` from `Field` structs and make the `Grid` a parameter, i.e. `Grid{T,G}` then it should be isbitstype. It's not isbits right now because T<:AbstractArray. Then we should be able to use some abstractions in the CPU/GPU element-wise kernels as well as multiple dispatch and won't need to have `δx_c2f`, `δx_f2c`, `δx_e2f`, `δx_f2e`, etc. Some goals for guidance:; - [ ] Prototype grid and field types that are `isbitstype`.; - [ ] Test that they do work with GPUifyLoops on the GPU. For this I will extend the example from https://github.com/vchuravy/GPUifyLoops.jl/pull/18; - [ ] Benchmark the simple example to see things slow down. I don't expect to see much of a difference.; - [ ] Refactor the operators and time stepping loop to use the new abstractions!; - [ ] Add tests to make sure any structure that may be passed to a CUDA kernel `isbitstype`. Just construct a bunch of grids, fields, and forcing functions and test that they are indeed `isbitstype`.; - [ ] Benchmark the model with `isbitstype` abstractions to make sure performance hasn't degraded.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/59
https://github.com/CliMA/Oceananigans.jl/issues/59:730,Modifiability,Refactor,Refactor,730,"@peterahrens suggested removing `ModelMetadata` from `Field` structs and make the `Grid` a parameter, i.e. `Grid{T,G}` then it should be isbitstype. It's not isbits right now because T<:AbstractArray. Then we should be able to use some abstractions in the CPU/GPU element-wise kernels as well as multiple dispatch and won't need to have `δx_c2f`, `δx_f2c`, `δx_e2f`, `δx_f2e`, etc. Some goals for guidance:; - [ ] Prototype grid and field types that are `isbitstype`.; - [ ] Test that they do work with GPUifyLoops on the GPU. For this I will extend the example from https://github.com/vchuravy/GPUifyLoops.jl/pull/18; - [ ] Benchmark the simple example to see things slow down. I don't expect to see much of a difference.; - [ ] Refactor the operators and time stepping loop to use the new abstractions!; - [ ] Add tests to make sure any structure that may be passed to a CUDA kernel `isbitstype`. Just construct a bunch of grids, fields, and forcing functions and test that they are indeed `isbitstype`.; - [ ] Benchmark the model with `isbitstype` abstractions to make sure performance hasn't degraded.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/59
https://github.com/CliMA/Oceananigans.jl/issues/59:1077,Performance,perform,performance,1077,"@peterahrens suggested removing `ModelMetadata` from `Field` structs and make the `Grid` a parameter, i.e. `Grid{T,G}` then it should be isbitstype. It's not isbits right now because T<:AbstractArray. Then we should be able to use some abstractions in the CPU/GPU element-wise kernels as well as multiple dispatch and won't need to have `δx_c2f`, `δx_f2c`, `δx_e2f`, `δx_f2e`, etc. Some goals for guidance:; - [ ] Prototype grid and field types that are `isbitstype`.; - [ ] Test that they do work with GPUifyLoops on the GPU. For this I will extend the example from https://github.com/vchuravy/GPUifyLoops.jl/pull/18; - [ ] Benchmark the simple example to see things slow down. I don't expect to see much of a difference.; - [ ] Refactor the operators and time stepping loop to use the new abstractions!; - [ ] Add tests to make sure any structure that may be passed to a CUDA kernel `isbitstype`. Just construct a bunch of grids, fields, and forcing functions and test that they are indeed `isbitstype`.; - [ ] Benchmark the model with `isbitstype` abstractions to make sure performance hasn't degraded.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/59
https://github.com/CliMA/Oceananigans.jl/issues/59:475,Testability,Test,Test,475,"@peterahrens suggested removing `ModelMetadata` from `Field` structs and make the `Grid` a parameter, i.e. `Grid{T,G}` then it should be isbitstype. It's not isbits right now because T<:AbstractArray. Then we should be able to use some abstractions in the CPU/GPU element-wise kernels as well as multiple dispatch and won't need to have `δx_c2f`, `δx_f2c`, `δx_e2f`, `δx_f2e`, etc. Some goals for guidance:; - [ ] Prototype grid and field types that are `isbitstype`.; - [ ] Test that they do work with GPUifyLoops on the GPU. For this I will extend the example from https://github.com/vchuravy/GPUifyLoops.jl/pull/18; - [ ] Benchmark the simple example to see things slow down. I don't expect to see much of a difference.; - [ ] Refactor the operators and time stepping loop to use the new abstractions!; - [ ] Add tests to make sure any structure that may be passed to a CUDA kernel `isbitstype`. Just construct a bunch of grids, fields, and forcing functions and test that they are indeed `isbitstype`.; - [ ] Benchmark the model with `isbitstype` abstractions to make sure performance hasn't degraded.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/59
https://github.com/CliMA/Oceananigans.jl/issues/59:625,Testability,Benchmark,Benchmark,625,"@peterahrens suggested removing `ModelMetadata` from `Field` structs and make the `Grid` a parameter, i.e. `Grid{T,G}` then it should be isbitstype. It's not isbits right now because T<:AbstractArray. Then we should be able to use some abstractions in the CPU/GPU element-wise kernels as well as multiple dispatch and won't need to have `δx_c2f`, `δx_f2c`, `δx_e2f`, `δx_f2e`, etc. Some goals for guidance:; - [ ] Prototype grid and field types that are `isbitstype`.; - [ ] Test that they do work with GPUifyLoops on the GPU. For this I will extend the example from https://github.com/vchuravy/GPUifyLoops.jl/pull/18; - [ ] Benchmark the simple example to see things slow down. I don't expect to see much of a difference.; - [ ] Refactor the operators and time stepping loop to use the new abstractions!; - [ ] Add tests to make sure any structure that may be passed to a CUDA kernel `isbitstype`. Just construct a bunch of grids, fields, and forcing functions and test that they are indeed `isbitstype`.; - [ ] Benchmark the model with `isbitstype` abstractions to make sure performance hasn't degraded.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/59
https://github.com/CliMA/Oceananigans.jl/issues/59:816,Testability,test,tests,816,"@peterahrens suggested removing `ModelMetadata` from `Field` structs and make the `Grid` a parameter, i.e. `Grid{T,G}` then it should be isbitstype. It's not isbits right now because T<:AbstractArray. Then we should be able to use some abstractions in the CPU/GPU element-wise kernels as well as multiple dispatch and won't need to have `δx_c2f`, `δx_f2c`, `δx_e2f`, `δx_f2e`, etc. Some goals for guidance:; - [ ] Prototype grid and field types that are `isbitstype`.; - [ ] Test that they do work with GPUifyLoops on the GPU. For this I will extend the example from https://github.com/vchuravy/GPUifyLoops.jl/pull/18; - [ ] Benchmark the simple example to see things slow down. I don't expect to see much of a difference.; - [ ] Refactor the operators and time stepping loop to use the new abstractions!; - [ ] Add tests to make sure any structure that may be passed to a CUDA kernel `isbitstype`. Just construct a bunch of grids, fields, and forcing functions and test that they are indeed `isbitstype`.; - [ ] Benchmark the model with `isbitstype` abstractions to make sure performance hasn't degraded.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/59
https://github.com/CliMA/Oceananigans.jl/issues/59:966,Testability,test,test,966,"@peterahrens suggested removing `ModelMetadata` from `Field` structs and make the `Grid` a parameter, i.e. `Grid{T,G}` then it should be isbitstype. It's not isbits right now because T<:AbstractArray. Then we should be able to use some abstractions in the CPU/GPU element-wise kernels as well as multiple dispatch and won't need to have `δx_c2f`, `δx_f2c`, `δx_e2f`, `δx_f2e`, etc. Some goals for guidance:; - [ ] Prototype grid and field types that are `isbitstype`.; - [ ] Test that they do work with GPUifyLoops on the GPU. For this I will extend the example from https://github.com/vchuravy/GPUifyLoops.jl/pull/18; - [ ] Benchmark the simple example to see things slow down. I don't expect to see much of a difference.; - [ ] Refactor the operators and time stepping loop to use the new abstractions!; - [ ] Add tests to make sure any structure that may be passed to a CUDA kernel `isbitstype`. Just construct a bunch of grids, fields, and forcing functions and test that they are indeed `isbitstype`.; - [ ] Benchmark the model with `isbitstype` abstractions to make sure performance hasn't degraded.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/59
https://github.com/CliMA/Oceananigans.jl/issues/59:1013,Testability,Benchmark,Benchmark,1013,"@peterahrens suggested removing `ModelMetadata` from `Field` structs and make the `Grid` a parameter, i.e. `Grid{T,G}` then it should be isbitstype. It's not isbits right now because T<:AbstractArray. Then we should be able to use some abstractions in the CPU/GPU element-wise kernels as well as multiple dispatch and won't need to have `δx_c2f`, `δx_f2c`, `δx_e2f`, `δx_f2e`, etc. Some goals for guidance:; - [ ] Prototype grid and field types that are `isbitstype`.; - [ ] Test that they do work with GPUifyLoops on the GPU. For this I will extend the example from https://github.com/vchuravy/GPUifyLoops.jl/pull/18; - [ ] Benchmark the simple example to see things slow down. I don't expect to see much of a difference.; - [ ] Refactor the operators and time stepping loop to use the new abstractions!; - [ ] Add tests to make sure any structure that may be passed to a CUDA kernel `isbitstype`. Just construct a bunch of grids, fields, and forcing functions and test that they are indeed `isbitstype`.; - [ ] Benchmark the model with `isbitstype` abstractions to make sure performance hasn't degraded.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/59
https://github.com/CliMA/Oceananigans.jl/issues/59:397,Usability,guid,guidance,397,"@peterahrens suggested removing `ModelMetadata` from `Field` structs and make the `Grid` a parameter, i.e. `Grid{T,G}` then it should be isbitstype. It's not isbits right now because T<:AbstractArray. Then we should be able to use some abstractions in the CPU/GPU element-wise kernels as well as multiple dispatch and won't need to have `δx_c2f`, `δx_f2c`, `δx_e2f`, `δx_f2e`, etc. Some goals for guidance:; - [ ] Prototype grid and field types that are `isbitstype`.; - [ ] Test that they do work with GPUifyLoops on the GPU. For this I will extend the example from https://github.com/vchuravy/GPUifyLoops.jl/pull/18; - [ ] Benchmark the simple example to see things slow down. I don't expect to see much of a difference.; - [ ] Refactor the operators and time stepping loop to use the new abstractions!; - [ ] Add tests to make sure any structure that may be passed to a CUDA kernel `isbitstype`. Just construct a bunch of grids, fields, and forcing functions and test that they are indeed `isbitstype`.; - [ ] Benchmark the model with `isbitstype` abstractions to make sure performance hasn't degraded.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/59
https://github.com/CliMA/Oceananigans.jl/issues/59:639,Usability,simpl,simple,639,"@peterahrens suggested removing `ModelMetadata` from `Field` structs and make the `Grid` a parameter, i.e. `Grid{T,G}` then it should be isbitstype. It's not isbits right now because T<:AbstractArray. Then we should be able to use some abstractions in the CPU/GPU element-wise kernels as well as multiple dispatch and won't need to have `δx_c2f`, `δx_f2c`, `δx_e2f`, `δx_f2e`, etc. Some goals for guidance:; - [ ] Prototype grid and field types that are `isbitstype`.; - [ ] Test that they do work with GPUifyLoops on the GPU. For this I will extend the example from https://github.com/vchuravy/GPUifyLoops.jl/pull/18; - [ ] Benchmark the simple example to see things slow down. I don't expect to see much of a difference.; - [ ] Refactor the operators and time stepping loop to use the new abstractions!; - [ ] Add tests to make sure any structure that may be passed to a CUDA kernel `isbitstype`. Just construct a bunch of grids, fields, and forcing functions and test that they are indeed `isbitstype`.; - [ ] Benchmark the model with `isbitstype` abstractions to make sure performance hasn't degraded.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/59
https://github.com/CliMA/Oceananigans.jl/issues/62:87,Availability,error,erroring,87,Right now it won't run on a computer without CUDA and is also why Travis CI builds are erroring. A quick hack would be to do something like what CliMA does:; ```julia; const HAVE_CUDA = try; using CUDAdrv; using CUDAnative; true; catch; false; end. macro hascuda(ex); return HAVE_CUDA ? :($(esc(ex))) : :(nothing); end. @hascuda device!(MPI.Comm_rank(mpicomm) % length(devices())); ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/62
https://github.com/CliMA/Oceananigans.jl/issues/64:540,Deployability,Update,Update,540,"Right now I'm just constructing grids with dimensions that are multiples of 16 so; ```julia; Tx, Ty = 16, 16 # Threads per block; Bx, By, Bz = Int(Nx/Tx), Int(Ny/Ty), Nz # Blocks in grid.; ```. @vchuravy suggested laying them out to fill out the _x_-direction first, then the _y_-direction, then the _z_-direction. That would also let us use grids with arbitrary sizes, i.e. not just multiples of 16. Not sure if it would affect performance for large problems. See https://github.com/vchuravy/GPUifyLoops.jl/pull/18#issuecomment-465150581. Update: Yeah I should have done this a long time ago. This issue is preventing us from running small grids (e.g. 1D column models) on the GPU and running certain tests.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/64
https://github.com/CliMA/Oceananigans.jl/issues/64:429,Performance,perform,performance,429,"Right now I'm just constructing grids with dimensions that are multiples of 16 so; ```julia; Tx, Ty = 16, 16 # Threads per block; Bx, By, Bz = Int(Nx/Tx), Int(Ny/Ty), Nz # Blocks in grid.; ```. @vchuravy suggested laying them out to fill out the _x_-direction first, then the _y_-direction, then the _z_-direction. That would also let us use grids with arbitrary sizes, i.e. not just multiples of 16. Not sure if it would affect performance for large problems. See https://github.com/vchuravy/GPUifyLoops.jl/pull/18#issuecomment-465150581. Update: Yeah I should have done this a long time ago. This issue is preventing us from running small grids (e.g. 1D column models) on the GPU and running certain tests.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/64
https://github.com/CliMA/Oceananigans.jl/issues/64:702,Testability,test,tests,702,"Right now I'm just constructing grids with dimensions that are multiples of 16 so; ```julia; Tx, Ty = 16, 16 # Threads per block; Bx, By, Bz = Int(Nx/Tx), Int(Ny/Ty), Nz # Blocks in grid.; ```. @vchuravy suggested laying them out to fill out the _x_-direction first, then the _y_-direction, then the _z_-direction. That would also let us use grids with arbitrary sizes, i.e. not just multiples of 16. Not sure if it would affect performance for large problems. See https://github.com/vchuravy/GPUifyLoops.jl/pull/18#issuecomment-465150581. Update: Yeah I should have done this a long time ago. This issue is preventing us from running small grids (e.g. 1D column models) on the GPU and running certain tests.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/64
https://github.com/CliMA/Oceananigans.jl/issues/66:177,Energy Efficiency,reduce,reduce,177,"Currently it takes 6-7 minutes to compile before the model will start running on the GPU. This is expected but is there a way to compile once and run multiple times, or even to reduce the compile time? Maybe this is the price we pay for zero-cost high-level abstractions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/66
https://github.com/CliMA/Oceananigans.jl/issues/67:125,Performance,perform,performance,125,"We should have some more sophisticated CPU and GPU benchmarks to make sure commits and pull requests don't surprisingly kill performance. Ideally along with CI (not sure if JuliaGPU's GitLab CI will let us do extensive benchmarking). Right now I just benchmark the global operators on the CPU, but I think a more meaningful benchmark would be something like average wall clock time per model time step between time steps 10-90 to avoid transients (+ no disk output) or something. Have a look at: https://github.com/KristofferC/TimerOutputs.jl; Also see: https://github.com/glwagner/CuBenchmarks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/67
https://github.com/CliMA/Oceananigans.jl/issues/67:430,Safety,avoid,avoid,430,"We should have some more sophisticated CPU and GPU benchmarks to make sure commits and pull requests don't surprisingly kill performance. Ideally along with CI (not sure if JuliaGPU's GitLab CI will let us do extensive benchmarking). Right now I just benchmark the global operators on the CPU, but I think a more meaningful benchmark would be something like average wall clock time per model time step between time steps 10-90 to avoid transients (+ no disk output) or something. Have a look at: https://github.com/KristofferC/TimerOutputs.jl; Also see: https://github.com/glwagner/CuBenchmarks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/67
https://github.com/CliMA/Oceananigans.jl/issues/67:51,Testability,benchmark,benchmarks,51,"We should have some more sophisticated CPU and GPU benchmarks to make sure commits and pull requests don't surprisingly kill performance. Ideally along with CI (not sure if JuliaGPU's GitLab CI will let us do extensive benchmarking). Right now I just benchmark the global operators on the CPU, but I think a more meaningful benchmark would be something like average wall clock time per model time step between time steps 10-90 to avoid transients (+ no disk output) or something. Have a look at: https://github.com/KristofferC/TimerOutputs.jl; Also see: https://github.com/glwagner/CuBenchmarks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/67
https://github.com/CliMA/Oceananigans.jl/issues/67:219,Testability,benchmark,benchmarking,219,"We should have some more sophisticated CPU and GPU benchmarks to make sure commits and pull requests don't surprisingly kill performance. Ideally along with CI (not sure if JuliaGPU's GitLab CI will let us do extensive benchmarking). Right now I just benchmark the global operators on the CPU, but I think a more meaningful benchmark would be something like average wall clock time per model time step between time steps 10-90 to avoid transients (+ no disk output) or something. Have a look at: https://github.com/KristofferC/TimerOutputs.jl; Also see: https://github.com/glwagner/CuBenchmarks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/67
https://github.com/CliMA/Oceananigans.jl/issues/67:251,Testability,benchmark,benchmark,251,"We should have some more sophisticated CPU and GPU benchmarks to make sure commits and pull requests don't surprisingly kill performance. Ideally along with CI (not sure if JuliaGPU's GitLab CI will let us do extensive benchmarking). Right now I just benchmark the global operators on the CPU, but I think a more meaningful benchmark would be something like average wall clock time per model time step between time steps 10-90 to avoid transients (+ no disk output) or something. Have a look at: https://github.com/KristofferC/TimerOutputs.jl; Also see: https://github.com/glwagner/CuBenchmarks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/67
https://github.com/CliMA/Oceananigans.jl/issues/67:324,Testability,benchmark,benchmark,324,"We should have some more sophisticated CPU and GPU benchmarks to make sure commits and pull requests don't surprisingly kill performance. Ideally along with CI (not sure if JuliaGPU's GitLab CI will let us do extensive benchmarking). Right now I just benchmark the global operators on the CPU, but I think a more meaningful benchmark would be something like average wall clock time per model time step between time steps 10-90 to avoid transients (+ no disk output) or something. Have a look at: https://github.com/KristofferC/TimerOutputs.jl; Also see: https://github.com/glwagner/CuBenchmarks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/67
https://github.com/CliMA/Oceananigans.jl/issues/68:216,Availability,error,error,216,"This happens after a number of time steps; ```julia; CUFFTError(code 2, cuFFT failed to allocate GPU or CPU memory). Stacktrace:; [1] macro expansion at /home/gridsan/aramadhan/.julia/packages/CuArrays/PD3UJ/src/fft/error.jl:59 [inlined]; [2] _mkplan(::UInt8, ::Tuple{Int64,Int64,Int64}, ::Array{Int64,1}) at /home/gridsan/aramadhan/.julia/packages/CuArrays/PD3UJ/src/fft/wrappers.jl:27; [3] plan_fft! at /home/gridsan/aramadhan/.julia/packages/CuArrays/PD3UJ/src/fft/highlevel.jl:10 [inlined]; [4] fft! at /home/gridsan/aramadhan/.julia/packages/AbstractFFTs/7WCaR/src/definitions.jl:51 [inlined]; [5] solve_poisson_3d_ppn_gpu!(::Int64, ::Int64, ::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32}, ::CellField{CuArray{Complex{Float64},3}}, ::CellField{CuArray{Complex{Float64},3}}, ::CuArray{Float64,1}, ::CuArray{Float64,1}, ::CuArray{Float64,1}, ::CuArray{Complex{Float64},3}, ::CuArray{Complex{Float64},3}) at /home/gridsan/aramadhan/Oceananigans.jl/src/spectral_solvers.jl:426; [6] time_step_kernel!(::Model, ::Int64, ::Int64) at /home/gridsan/aramadhan/Oceananigans.jl/src/time_steppers.jl:375; [7] deep_convection_3d_gpu() at /home/gridsan/aramadhan/Oceananigans.jl/examples/deep_convection_3d_gpu.jl:17; [8] top-level scope at In[5]:1; ```. Or if you just save output to disk every ~10 time steps, the garbage collector has a chance to catch up.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/68
https://github.com/CliMA/Oceananigans.jl/issues/68:88,Energy Efficiency,allocate,allocate,88,"This happens after a number of time steps; ```julia; CUFFTError(code 2, cuFFT failed to allocate GPU or CPU memory). Stacktrace:; [1] macro expansion at /home/gridsan/aramadhan/.julia/packages/CuArrays/PD3UJ/src/fft/error.jl:59 [inlined]; [2] _mkplan(::UInt8, ::Tuple{Int64,Int64,Int64}, ::Array{Int64,1}) at /home/gridsan/aramadhan/.julia/packages/CuArrays/PD3UJ/src/fft/wrappers.jl:27; [3] plan_fft! at /home/gridsan/aramadhan/.julia/packages/CuArrays/PD3UJ/src/fft/highlevel.jl:10 [inlined]; [4] fft! at /home/gridsan/aramadhan/.julia/packages/AbstractFFTs/7WCaR/src/definitions.jl:51 [inlined]; [5] solve_poisson_3d_ppn_gpu!(::Int64, ::Int64, ::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32}, ::CellField{CuArray{Complex{Float64},3}}, ::CellField{CuArray{Complex{Float64},3}}, ::CuArray{Float64,1}, ::CuArray{Float64,1}, ::CuArray{Float64,1}, ::CuArray{Complex{Float64},3}, ::CuArray{Complex{Float64},3}) at /home/gridsan/aramadhan/Oceananigans.jl/src/spectral_solvers.jl:426; [6] time_step_kernel!(::Model, ::Int64, ::Int64) at /home/gridsan/aramadhan/Oceananigans.jl/src/time_steppers.jl:375; [7] deep_convection_3d_gpu() at /home/gridsan/aramadhan/Oceananigans.jl/examples/deep_convection_3d_gpu.jl:17; [8] top-level scope at In[5]:1; ```. Or if you just save output to disk every ~10 time steps, the garbage collector has a chance to catch up.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/68
https://github.com/CliMA/Oceananigans.jl/issues/68:372,Integrability,wrap,wrappers,372,"This happens after a number of time steps; ```julia; CUFFTError(code 2, cuFFT failed to allocate GPU or CPU memory). Stacktrace:; [1] macro expansion at /home/gridsan/aramadhan/.julia/packages/CuArrays/PD3UJ/src/fft/error.jl:59 [inlined]; [2] _mkplan(::UInt8, ::Tuple{Int64,Int64,Int64}, ::Array{Int64,1}) at /home/gridsan/aramadhan/.julia/packages/CuArrays/PD3UJ/src/fft/wrappers.jl:27; [3] plan_fft! at /home/gridsan/aramadhan/.julia/packages/CuArrays/PD3UJ/src/fft/highlevel.jl:10 [inlined]; [4] fft! at /home/gridsan/aramadhan/.julia/packages/AbstractFFTs/7WCaR/src/definitions.jl:51 [inlined]; [5] solve_poisson_3d_ppn_gpu!(::Int64, ::Int64, ::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32}, ::CellField{CuArray{Complex{Float64},3}}, ::CellField{CuArray{Complex{Float64},3}}, ::CuArray{Float64,1}, ::CuArray{Float64,1}, ::CuArray{Float64,1}, ::CuArray{Complex{Float64},3}, ::CuArray{Complex{Float64},3}) at /home/gridsan/aramadhan/Oceananigans.jl/src/spectral_solvers.jl:426; [6] time_step_kernel!(::Model, ::Int64, ::Int64) at /home/gridsan/aramadhan/Oceananigans.jl/src/time_steppers.jl:375; [7] deep_convection_3d_gpu() at /home/gridsan/aramadhan/Oceananigans.jl/examples/deep_convection_3d_gpu.jl:17; [8] top-level scope at In[5]:1; ```. Or if you just save output to disk every ~10 time steps, the garbage collector has a chance to catch up.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/68
https://github.com/CliMA/Oceananigans.jl/issues/69:65,Safety,avoid,avoid,65,We must play this annoying game of organizing the definitions to avoid mutually circular type declarations. See: https://github.com/JuliaLang/julia/issues/269,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/69
https://github.com/CliMA/Oceananigans.jl/issues/71:5,Testability,log,logging,5,Good logging should be a high priority item. Python's logging is great... Some options:; * [Base logging](https://docs.julialang.org/en/v1/stdlib/Logging/index.html); * [Memento.jl](https://github.com/invenia/Memento.jl); * [MicroLogging.jl](https://github.com/c42f/MicroLogging.jl),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/71
https://github.com/CliMA/Oceananigans.jl/issues/71:54,Testability,log,logging,54,Good logging should be a high priority item. Python's logging is great... Some options:; * [Base logging](https://docs.julialang.org/en/v1/stdlib/Logging/index.html); * [Memento.jl](https://github.com/invenia/Memento.jl); * [MicroLogging.jl](https://github.com/c42f/MicroLogging.jl),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/71
https://github.com/CliMA/Oceananigans.jl/issues/71:97,Testability,log,logging,97,Good logging should be a high priority item. Python's logging is great... Some options:; * [Base logging](https://docs.julialang.org/en/v1/stdlib/Logging/index.html); * [Memento.jl](https://github.com/invenia/Memento.jl); * [MicroLogging.jl](https://github.com/c42f/MicroLogging.jl),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/71
https://github.com/CliMA/Oceananigans.jl/issues/71:146,Testability,Log,Logging,146,Good logging should be a high priority item. Python's logging is great... Some options:; * [Base logging](https://docs.julialang.org/en/v1/stdlib/Logging/index.html); * [Memento.jl](https://github.com/invenia/Memento.jl); * [MicroLogging.jl](https://github.com/c42f/MicroLogging.jl),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/71
https://github.com/CliMA/Oceananigans.jl/issues/73:304,Integrability,inject,injected,304,"Ideally the user would just define an element-wise function `closure(..., i, j, k)` that gets passed to the model and is added to the velocity or tracer source terms, acting as a forcing term in the momentum and tracer advection equations. Defining an element-wise function will allow the function to be injected into CPU and GPU kernels.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/73
https://github.com/CliMA/Oceananigans.jl/issues/73:304,Security,inject,injected,304,"Ideally the user would just define an element-wise function `closure(..., i, j, k)` that gets passed to the model and is added to the velocity or tracer source terms, acting as a forcing term in the momentum and tracer advection equations. Defining an element-wise function will allow the function to be injected into CPU and GPU kernels.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/73
https://github.com/CliMA/Oceananigans.jl/issues/78:130,Deployability,pipeline,pipeline,130,Ideally all the tests we run on the CPU should be replicated with GPU models. This will mean more work for the JuliaGPU GitLab CI pipeline.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/78
https://github.com/CliMA/Oceananigans.jl/issues/78:16,Testability,test,tests,16,Ideally all the tests we run on the CPU should be replicated with GPU models. This will mean more work for the JuliaGPU GitLab CI pipeline.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/78
https://github.com/CliMA/Oceananigans.jl/issues/79:34,Deployability,install,install,34,Low priority item. But no need to install CUDA packages if you're only going to run on a CPU.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/79
https://github.com/CliMA/Oceananigans.jl/issues/81:52,Testability,test,tests,52,"This has been discussed quite a bit but beyond unit tests we also need model verification tests that ensure the model output is mathematically/scientifically correct by comparison with known analytic solutions or statistics. The only one we've done so far is confirming the existence of steady-state convection rolls in Rayleigh–Bénard convection at Ra=5000 with an aspect ratio of 6. We can start with basic tests like isotropic diffusion and build up to more complicated stuff like slantwise convection. @edoddridge has a lot of ideas regarding this, he might be a good person to talk to here.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/81
https://github.com/CliMA/Oceananigans.jl/issues/81:90,Testability,test,tests,90,"This has been discussed quite a bit but beyond unit tests we also need model verification tests that ensure the model output is mathematically/scientifically correct by comparison with known analytic solutions or statistics. The only one we've done so far is confirming the existence of steady-state convection rolls in Rayleigh–Bénard convection at Ra=5000 with an aspect ratio of 6. We can start with basic tests like isotropic diffusion and build up to more complicated stuff like slantwise convection. @edoddridge has a lot of ideas regarding this, he might be a good person to talk to here.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/81
https://github.com/CliMA/Oceananigans.jl/issues/81:409,Testability,test,tests,409,"This has been discussed quite a bit but beyond unit tests we also need model verification tests that ensure the model output is mathematically/scientifically correct by comparison with known analytic solutions or statistics. The only one we've done so far is confirming the existence of steady-state convection rolls in Rayleigh–Bénard convection at Ra=5000 with an aspect ratio of 6. We can start with basic tests like isotropic diffusion and build up to more complicated stuff like slantwise convection. @edoddridge has a lot of ideas regarding this, he might be a good person to talk to here.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/81
https://github.com/CliMA/Oceananigans.jl/issues/82:115,Performance,perform,perform,115,```julia; CuArrays.allowscalar(false); ```; to disable slow fallback methods for CuArrays so we don't accidentally perform some slow operation.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/82
https://github.com/CliMA/Oceananigans.jl/pull/85:439,Availability,down,down,439,"Just hacked something together that allows for user-defined forcing functions for the CPU. Have not tested on the GPU yet. Basically there's a struct `Forcing` that stores the user-defined forcing functions. It will replace the old `ForcingFields` struct. See `examples/deep_convection_3d.jl` for how I switched to using a forcing function for T to enforce a cooling surface heat flux. A big issue is that the current implementation slows down the time stepping by a factor of 2-3x. So we'll have to figure out why before merging. The function must have a signature like `F(u, v, w, T, S, Nx, Ny, Nz, Δx, Δy, Δz, i, j, k)` right now so this won't produce a nice solution as we will have to figure out #59 before the function signature can look as nice as `surface_cooling_disk(grid, velocities, tracers, i, j, k)`. This is work for another branch. Will keep working on this before merging. Just wanted to start something. Resolves #73",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/85
https://github.com/CliMA/Oceananigans.jl/pull/85:100,Testability,test,tested,100,"Just hacked something together that allows for user-defined forcing functions for the CPU. Have not tested on the GPU yet. Basically there's a struct `Forcing` that stores the user-defined forcing functions. It will replace the old `ForcingFields` struct. See `examples/deep_convection_3d.jl` for how I switched to using a forcing function for T to enforce a cooling surface heat flux. A big issue is that the current implementation slows down the time stepping by a factor of 2-3x. So we'll have to figure out why before merging. The function must have a signature like `F(u, v, w, T, S, Nx, Ny, Nz, Δx, Δy, Δz, i, j, k)` right now so this won't produce a nice solution as we will have to figure out #59 before the function signature can look as nice as `surface_cooling_disk(grid, velocities, tracers, i, j, k)`. This is work for another branch. Will keep working on this before merging. Just wanted to start something. Resolves #73",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/85
https://github.com/CliMA/Oceananigans.jl/issues/86:1127,Availability,Ping,Pinging,1127,"Would be nice to have a nice and user-friendly API for setting boundary conditions. What boundary conditions should we be supporting? What should this API look like? Just starting a discussion around this that I've had with @SandreOuza and @glwagner. @glwagner made the point that the user should just have to specify whether they'd like Dirchlet, Neumann, or Robin boundary conditions. Periodic should be another option. We don't have to support all combinations. But in finite volume boundary conditions are converted into conditions on the fluxes. Right now we have something like this; ```julia; model.boundary_conditions = BoundaryConditions(x=:periodic, y=:periodic, top=:free_slip, bottom=:free_slip); ```; and all the ugliness is swept under the rug. This may involve refactoring some of the difference and interpolation operators as they might have been implicitly assuming that free-slip is being imposed. Will have to confirm with @jm-c. PS: Assigning multiple people as I don't have much experience around this (just to get your attention) Would be good to talk and figure out what kind of API works for all of us. Pinging: @SandreOuza",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/86
https://github.com/CliMA/Oceananigans.jl/issues/86:776,Modifiability,refactor,refactoring,776,"Would be nice to have a nice and user-friendly API for setting boundary conditions. What boundary conditions should we be supporting? What should this API look like? Just starting a discussion around this that I've had with @SandreOuza and @glwagner. @glwagner made the point that the user should just have to specify whether they'd like Dirchlet, Neumann, or Robin boundary conditions. Periodic should be another option. We don't have to support all combinations. But in finite volume boundary conditions are converted into conditions on the fluxes. Right now we have something like this; ```julia; model.boundary_conditions = BoundaryConditions(x=:periodic, y=:periodic, top=:free_slip, bottom=:free_slip); ```; and all the ugliness is swept under the rug. This may involve refactoring some of the difference and interpolation operators as they might have been implicitly assuming that free-slip is being imposed. Will have to confirm with @jm-c. PS: Assigning multiple people as I don't have much experience around this (just to get your attention) Would be good to talk and figure out what kind of API works for all of us. Pinging: @SandreOuza",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/86
https://github.com/CliMA/Oceananigans.jl/issues/86:33,Usability,user-friendly,user-friendly,33,"Would be nice to have a nice and user-friendly API for setting boundary conditions. What boundary conditions should we be supporting? What should this API look like? Just starting a discussion around this that I've had with @SandreOuza and @glwagner. @glwagner made the point that the user should just have to specify whether they'd like Dirchlet, Neumann, or Robin boundary conditions. Periodic should be another option. We don't have to support all combinations. But in finite volume boundary conditions are converted into conditions on the fluxes. Right now we have something like this; ```julia; model.boundary_conditions = BoundaryConditions(x=:periodic, y=:periodic, top=:free_slip, bottom=:free_slip); ```; and all the ugliness is swept under the rug. This may involve refactoring some of the difference and interpolation operators as they might have been implicitly assuming that free-slip is being imposed. Will have to confirm with @jm-c. PS: Assigning multiple people as I don't have much experience around this (just to get your attention) Would be good to talk and figure out what kind of API works for all of us. Pinging: @SandreOuza",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/86
https://github.com/CliMA/Oceananigans.jl/issues/89:483,Performance,cache,cache,483,Each Appveyor build takes 30-50 minutes to run (and they run sequentially) so Appveyor takes forever to finish testing. Compare with ~10 minutes per build on Travis and JuliaGPU's CI on GitLab. It also builds CUDA packages unsuccessfully so maybe defining a CPU testing env and using it on Travis and Appveyor can help? See https://github.com/ali-ramadhan/Oceananigans.jl/issues/79. Problem might go away on its own but otherwise this might help: https://www.appveyor.com/docs/build-cache/,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/89
https://github.com/CliMA/Oceananigans.jl/issues/89:111,Testability,test,testing,111,Each Appveyor build takes 30-50 minutes to run (and they run sequentially) so Appveyor takes forever to finish testing. Compare with ~10 minutes per build on Travis and JuliaGPU's CI on GitLab. It also builds CUDA packages unsuccessfully so maybe defining a CPU testing env and using it on Travis and Appveyor can help? See https://github.com/ali-ramadhan/Oceananigans.jl/issues/79. Problem might go away on its own but otherwise this might help: https://www.appveyor.com/docs/build-cache/,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/89
https://github.com/CliMA/Oceananigans.jl/issues/89:262,Testability,test,testing,262,Each Appveyor build takes 30-50 minutes to run (and they run sequentially) so Appveyor takes forever to finish testing. Compare with ~10 minutes per build on Travis and JuliaGPU's CI on GitLab. It also builds CUDA packages unsuccessfully so maybe defining a CPU testing env and using it on Travis and Appveyor can help? See https://github.com/ali-ramadhan/Oceananigans.jl/issues/79. Problem might go away on its own but otherwise this might help: https://www.appveyor.com/docs/build-cache/,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/89
https://github.com/CliMA/Oceananigans.jl/issues/90:1233,Availability,down,down,1233,"id`, `Oceananigans.jl` uses a convention in which indexing for the `z` coordinate in arrays is treated differently from `x` and `y`: the third index (call it `k`) *decreases* with increasing `z`, unlike the first and second indices which increase with increasing `x` and `y`. This means `z` derivative operators look different from `x` and `y` derivative operators. For example, a `z` differential is defined as positive for the difference between `k` and `k+1`. ```Julia; @inline function δz_e2f(f, Nz, i, j, k); if k == Nz; @inbounds return f[i, j, k]; else; @inbounds return f[i, j, k] - f[i, j, k+1]; end; end; ```. from [here](https://github.com/ali-ramadhan/Oceananigans.jl/blob/30150f965a1e0db95f239fa092ce33fe4ceedd29/src/operators/ops_regular_cartesian_grid_elementwise.jl#L38). I recognize that some users, especially oceanographers, appreciate this feature in their output --- in particular because `k=1` corresponds to the 'surface', which has a special status in (some) oceanographic applications. . However, I believe this 'reverse indexing' convention for the third direction is potentially confusing to developers and users with backgrounds in physics or engineering and may lead to bugs, slow down development, and stymie super-users who need to write code that indexes into arrays. I propose that we consider using the convention where indices increase with increasing coordinates in all directions (for all coordinate systems), so that for a Cartesian coordinate system `z` and `k` increase upwards, like 'x', 'y', 'i' and 'j'. I believe this behavior is probably expected for the majority of developers of fluid codes in general, and also for a large fraction of users. To satisfy users who prefer the oceanographic indexing convention in their output, we can provide users with the option (and make it default if we wish) to flip output and grids on their head before saving, so that `k=1` corresponds to the surface *in output*. @ali-ramadhan @christophernhill @jm-c @SandreOuza",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/90
https://github.com/CliMA/Oceananigans.jl/issues/91:59,Modifiability,variab,variables,59,Might be good to choose some standard names for the NetCDF variables (and output in general). Following the standard CMIP6 names might be one idea. Apparently some programs assume that NetCDF variables follow these conventions. See:; * https://www.earthsystemcog.org/projects/wip/CMIP6DataRequest; * http://clipc-services.ceda.ac.uk/dreq/index/standardname.html,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/91
https://github.com/CliMA/Oceananigans.jl/issues/91:192,Modifiability,variab,variables,192,Might be good to choose some standard names for the NetCDF variables (and output in general). Following the standard CMIP6 names might be one idea. Apparently some programs assume that NetCDF variables follow these conventions. See:; * https://www.earthsystemcog.org/projects/wip/CMIP6DataRequest; * http://clipc-services.ceda.ac.uk/dreq/index/standardname.html,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/91
https://github.com/CliMA/Oceananigans.jl/issues/92:222,Deployability,configurat,configuration,222,All the arrays right now are of size `Nx*Ny*Nz` but technically there are `Nx` volumes in the _x_-direction and `Nx+1` faces so the output should match this and make sense. The easiest thing to do with the doubly periodic configuration we have right now is to have row `Nx+1` be a repeat of row `1` but writing out the fields at the very bottom (`k=Nz+1`) might require some extra computation?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/92
https://github.com/CliMA/Oceananigans.jl/issues/92:222,Modifiability,config,configuration,222,All the arrays right now are of size `Nx*Ny*Nz` but technically there are `Nx` volumes in the _x_-direction and `Nx+1` faces so the output should match this and make sense. The easiest thing to do with the doubly periodic configuration we have right now is to have row `Nx+1` be a repeat of row `1` but writing out the fields at the very bottom (`k=Nz+1`) might require some extra computation?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/92
https://github.com/CliMA/Oceananigans.jl/pull/93:857,Modifiability,variab,variable,857,Just merging this so I can work on cleaning up the examples. Couple of NetCDF related issues I hit:; * [NetCDF.jl](https://github.com/JuliaGeo/NetCDF.jl) seems to be missing some features and isn't really being maintained (See https://github.com/JuliaGeo/NetCDF.jl/issues/62 about saving time values and https://github.com/JuliaGeo/NetCDF.jl/issues/39). Maybe it's worth switching to [NCDatasets.jl](https://github.com/Alexander-Barth/NCDatasets.jl) which takes a more data frames approach to NetCDF and is actively maintained and grew out of bugs that weren't being fixed in NetCDF.jl. Unfortunately we're choosing between two relatively young packages. An alternative would be to use the much more mature [netcdf4-python](http://unidata.github.io/netcdf4-python/) but I'd rather not have to use PyCall...; * We might need to decide on some standard field/variable names. #91; * Output might need to take into account cell-centered and face-centered fields #92. Reopens #31,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/93
https://github.com/CliMA/Oceananigans.jl/issues/94:116,Modifiability,variab,variables,116,"> As discussed with @jm-c, I think another feature we will need is the ability to design closure-specific temporary variables.; > ; > For example, the implementation of Constant Smagorinsky or Anisotropic Minimum Dissipation will benefit from the ability to compute the eddy viscosity (at 4 locations in a cell --- 3 `FaceField`s and 1 `CellField`) and re-use it in calculating the contribution of the subgrid closure to the momentum 'source terms'.; > ; > _Originally posted by @glwagner in https://github.com/ali-ramadhan/Oceananigans.jl/issues/73#issuecomment-467660286_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/94
https://github.com/CliMA/Oceananigans.jl/issues/95:60,Integrability,interface,interface,60,"> Building on what @jm-c said, I think we want to design an interface in which an equation is expressed as something like ; > ; > ```; > φ_t = Lφ + Ν(φ); > ```; > ; > where `φ` is the solution (an array of fields in this case, probably), `L` is a linear operator that can be treated implicitly (depending on the time-stepping scheme), and `N(φ)` is a nonlinear operator.; > ; > The challenge is including the pressure correction in this paradigm. I think it should be possible --- we may just have to consider only time-steppers that invoke the special pressure correction substep.; > ; > I think the design should be about more than just 'marking' the terms. We can tackle the problem of designing a time-stepper to step forward an equation of a certain form completely independent from the development of an algorithm to calculate nonlinear terms, pressure corrections, and linear terms for a specific kind of equation. Then we put the pieces together to solve the problem.; > ; > _Originally posted by @glwagner in https://github.com/ali-ramadhan/Oceananigans.jl/issues/49#issuecomment-463209211_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/95
https://github.com/CliMA/Oceananigans.jl/issues/95:295,Integrability,depend,depending,295,"> Building on what @jm-c said, I think we want to design an interface in which an equation is expressed as something like ; > ; > ```; > φ_t = Lφ + Ν(φ); > ```; > ; > where `φ` is the solution (an array of fields in this case, probably), `L` is a linear operator that can be treated implicitly (depending on the time-stepping scheme), and `N(φ)` is a nonlinear operator.; > ; > The challenge is including the pressure correction in this paradigm. I think it should be possible --- we may just have to consider only time-steppers that invoke the special pressure correction substep.; > ; > I think the design should be about more than just 'marking' the terms. We can tackle the problem of designing a time-stepper to step forward an equation of a certain form completely independent from the development of an algorithm to calculate nonlinear terms, pressure corrections, and linear terms for a specific kind of equation. Then we put the pieces together to solve the problem.; > ; > _Originally posted by @glwagner in https://github.com/ali-ramadhan/Oceananigans.jl/issues/49#issuecomment-463209211_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/95
https://github.com/CliMA/Oceananigans.jl/pull/96:21,Availability,down,down,21,Number of tests went down as a lot of them were regression tests between the three different sets of operators. But we will rebuild.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/96
https://github.com/CliMA/Oceananigans.jl/pull/96:10,Testability,test,tests,10,Number of tests went down as a lot of them were regression tests between the three different sets of operators. But we will rebuild.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/96
https://github.com/CliMA/Oceananigans.jl/pull/96:59,Testability,test,tests,59,Number of tests went down as a lot of them were regression tests between the three different sets of operators. But we will rebuild.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/96
https://github.com/CliMA/Oceananigans.jl/pull/97:111,Energy Efficiency,reduce,reduce,111,"The main contribution of this pull request is a refactor of the function `time_step!` and related functions to reduce code duplication and improve readability. There is now a function called `time_step_kernel!` that dispatches on the value of its first argument (provided by `model.metadata`) to execute on the CPU or GPU. A `Model` constructor is now provided in which all important information can be input via keyword arguments. I favor this kind of design for fluids codes because I believe it improves the understand-ability of scripts, as it encourages explicit naming of parameters passed into the `Model` constructor. The output writing functionality has also been refactored slightly. However, many more changes will be made in the future so this is not consequential. I also reduced the computational burden of a few of the tests, and changed to factor of 2 resolutions since this makes sense for FFTs (though relatively unimportant for testing, I think should encourage users to use powers of 2 and make a habit of using them ourselves). A few more notes:. * We need tests for output writers, and the output writing functionality needs to be revamped; * The model constructor needs work; * The examples are outdated. We should probably reduce the number of examples until the code becomes more stable, and commit to maintaining the few that remain; * We should get rid of model metadata and simply include the 'architecture' as a type parameter of `Model`; * and so much more... Lots of work to do!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/97
https://github.com/CliMA/Oceananigans.jl/pull/97:785,Energy Efficiency,reduce,reduced,785,"The main contribution of this pull request is a refactor of the function `time_step!` and related functions to reduce code duplication and improve readability. There is now a function called `time_step_kernel!` that dispatches on the value of its first argument (provided by `model.metadata`) to execute on the CPU or GPU. A `Model` constructor is now provided in which all important information can be input via keyword arguments. I favor this kind of design for fluids codes because I believe it improves the understand-ability of scripts, as it encourages explicit naming of parameters passed into the `Model` constructor. The output writing functionality has also been refactored slightly. However, many more changes will be made in the future so this is not consequential. I also reduced the computational burden of a few of the tests, and changed to factor of 2 resolutions since this makes sense for FFTs (though relatively unimportant for testing, I think should encourage users to use powers of 2 and make a habit of using them ourselves). A few more notes:. * We need tests for output writers, and the output writing functionality needs to be revamped; * The model constructor needs work; * The examples are outdated. We should probably reduce the number of examples until the code becomes more stable, and commit to maintaining the few that remain; * We should get rid of model metadata and simply include the 'architecture' as a type parameter of `Model`; * and so much more... Lots of work to do!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/97
https://github.com/CliMA/Oceananigans.jl/pull/97:994,Energy Efficiency,power,powers,994,"The main contribution of this pull request is a refactor of the function `time_step!` and related functions to reduce code duplication and improve readability. There is now a function called `time_step_kernel!` that dispatches on the value of its first argument (provided by `model.metadata`) to execute on the CPU or GPU. A `Model` constructor is now provided in which all important information can be input via keyword arguments. I favor this kind of design for fluids codes because I believe it improves the understand-ability of scripts, as it encourages explicit naming of parameters passed into the `Model` constructor. The output writing functionality has also been refactored slightly. However, many more changes will be made in the future so this is not consequential. I also reduced the computational burden of a few of the tests, and changed to factor of 2 resolutions since this makes sense for FFTs (though relatively unimportant for testing, I think should encourage users to use powers of 2 and make a habit of using them ourselves). A few more notes:. * We need tests for output writers, and the output writing functionality needs to be revamped; * The model constructor needs work; * The examples are outdated. We should probably reduce the number of examples until the code becomes more stable, and commit to maintaining the few that remain; * We should get rid of model metadata and simply include the 'architecture' as a type parameter of `Model`; * and so much more... Lots of work to do!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/97
https://github.com/CliMA/Oceananigans.jl/pull/97:1247,Energy Efficiency,reduce,reduce,1247,"The main contribution of this pull request is a refactor of the function `time_step!` and related functions to reduce code duplication and improve readability. There is now a function called `time_step_kernel!` that dispatches on the value of its first argument (provided by `model.metadata`) to execute on the CPU or GPU. A `Model` constructor is now provided in which all important information can be input via keyword arguments. I favor this kind of design for fluids codes because I believe it improves the understand-ability of scripts, as it encourages explicit naming of parameters passed into the `Model` constructor. The output writing functionality has also been refactored slightly. However, many more changes will be made in the future so this is not consequential. I also reduced the computational burden of a few of the tests, and changed to factor of 2 resolutions since this makes sense for FFTs (though relatively unimportant for testing, I think should encourage users to use powers of 2 and make a habit of using them ourselves). A few more notes:. * We need tests for output writers, and the output writing functionality needs to be revamped; * The model constructor needs work; * The examples are outdated. We should probably reduce the number of examples until the code becomes more stable, and commit to maintaining the few that remain; * We should get rid of model metadata and simply include the 'architecture' as a type parameter of `Model`; * and so much more... Lots of work to do!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/97
https://github.com/CliMA/Oceananigans.jl/pull/97:48,Modifiability,refactor,refactor,48,"The main contribution of this pull request is a refactor of the function `time_step!` and related functions to reduce code duplication and improve readability. There is now a function called `time_step_kernel!` that dispatches on the value of its first argument (provided by `model.metadata`) to execute on the CPU or GPU. A `Model` constructor is now provided in which all important information can be input via keyword arguments. I favor this kind of design for fluids codes because I believe it improves the understand-ability of scripts, as it encourages explicit naming of parameters passed into the `Model` constructor. The output writing functionality has also been refactored slightly. However, many more changes will be made in the future so this is not consequential. I also reduced the computational burden of a few of the tests, and changed to factor of 2 resolutions since this makes sense for FFTs (though relatively unimportant for testing, I think should encourage users to use powers of 2 and make a habit of using them ourselves). A few more notes:. * We need tests for output writers, and the output writing functionality needs to be revamped; * The model constructor needs work; * The examples are outdated. We should probably reduce the number of examples until the code becomes more stable, and commit to maintaining the few that remain; * We should get rid of model metadata and simply include the 'architecture' as a type parameter of `Model`; * and so much more... Lots of work to do!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/97
https://github.com/CliMA/Oceananigans.jl/pull/97:673,Modifiability,refactor,refactored,673,"The main contribution of this pull request is a refactor of the function `time_step!` and related functions to reduce code duplication and improve readability. There is now a function called `time_step_kernel!` that dispatches on the value of its first argument (provided by `model.metadata`) to execute on the CPU or GPU. A `Model` constructor is now provided in which all important information can be input via keyword arguments. I favor this kind of design for fluids codes because I believe it improves the understand-ability of scripts, as it encourages explicit naming of parameters passed into the `Model` constructor. The output writing functionality has also been refactored slightly. However, many more changes will be made in the future so this is not consequential. I also reduced the computational burden of a few of the tests, and changed to factor of 2 resolutions since this makes sense for FFTs (though relatively unimportant for testing, I think should encourage users to use powers of 2 and make a habit of using them ourselves). A few more notes:. * We need tests for output writers, and the output writing functionality needs to be revamped; * The model constructor needs work; * The examples are outdated. We should probably reduce the number of examples until the code becomes more stable, and commit to maintaining the few that remain; * We should get rid of model metadata and simply include the 'architecture' as a type parameter of `Model`; * and so much more... Lots of work to do!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/97
https://github.com/CliMA/Oceananigans.jl/pull/97:834,Testability,test,tests,834,"The main contribution of this pull request is a refactor of the function `time_step!` and related functions to reduce code duplication and improve readability. There is now a function called `time_step_kernel!` that dispatches on the value of its first argument (provided by `model.metadata`) to execute on the CPU or GPU. A `Model` constructor is now provided in which all important information can be input via keyword arguments. I favor this kind of design for fluids codes because I believe it improves the understand-ability of scripts, as it encourages explicit naming of parameters passed into the `Model` constructor. The output writing functionality has also been refactored slightly. However, many more changes will be made in the future so this is not consequential. I also reduced the computational burden of a few of the tests, and changed to factor of 2 resolutions since this makes sense for FFTs (though relatively unimportant for testing, I think should encourage users to use powers of 2 and make a habit of using them ourselves). A few more notes:. * We need tests for output writers, and the output writing functionality needs to be revamped; * The model constructor needs work; * The examples are outdated. We should probably reduce the number of examples until the code becomes more stable, and commit to maintaining the few that remain; * We should get rid of model metadata and simply include the 'architecture' as a type parameter of `Model`; * and so much more... Lots of work to do!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/97
https://github.com/CliMA/Oceananigans.jl/pull/97:947,Testability,test,testing,947,"The main contribution of this pull request is a refactor of the function `time_step!` and related functions to reduce code duplication and improve readability. There is now a function called `time_step_kernel!` that dispatches on the value of its first argument (provided by `model.metadata`) to execute on the CPU or GPU. A `Model` constructor is now provided in which all important information can be input via keyword arguments. I favor this kind of design for fluids codes because I believe it improves the understand-ability of scripts, as it encourages explicit naming of parameters passed into the `Model` constructor. The output writing functionality has also been refactored slightly. However, many more changes will be made in the future so this is not consequential. I also reduced the computational burden of a few of the tests, and changed to factor of 2 resolutions since this makes sense for FFTs (though relatively unimportant for testing, I think should encourage users to use powers of 2 and make a habit of using them ourselves). A few more notes:. * We need tests for output writers, and the output writing functionality needs to be revamped; * The model constructor needs work; * The examples are outdated. We should probably reduce the number of examples until the code becomes more stable, and commit to maintaining the few that remain; * We should get rid of model metadata and simply include the 'architecture' as a type parameter of `Model`; * and so much more... Lots of work to do!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/97
https://github.com/CliMA/Oceananigans.jl/pull/97:1078,Testability,test,tests,1078,"The main contribution of this pull request is a refactor of the function `time_step!` and related functions to reduce code duplication and improve readability. There is now a function called `time_step_kernel!` that dispatches on the value of its first argument (provided by `model.metadata`) to execute on the CPU or GPU. A `Model` constructor is now provided in which all important information can be input via keyword arguments. I favor this kind of design for fluids codes because I believe it improves the understand-ability of scripts, as it encourages explicit naming of parameters passed into the `Model` constructor. The output writing functionality has also been refactored slightly. However, many more changes will be made in the future so this is not consequential. I also reduced the computational burden of a few of the tests, and changed to factor of 2 resolutions since this makes sense for FFTs (though relatively unimportant for testing, I think should encourage users to use powers of 2 and make a habit of using them ourselves). A few more notes:. * We need tests for output writers, and the output writing functionality needs to be revamped; * The model constructor needs work; * The examples are outdated. We should probably reduce the number of examples until the code becomes more stable, and commit to maintaining the few that remain; * We should get rid of model metadata and simply include the 'architecture' as a type parameter of `Model`; * and so much more... Lots of work to do!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/97
https://github.com/CliMA/Oceananigans.jl/pull/97:1402,Usability,simpl,simply,1402,"The main contribution of this pull request is a refactor of the function `time_step!` and related functions to reduce code duplication and improve readability. There is now a function called `time_step_kernel!` that dispatches on the value of its first argument (provided by `model.metadata`) to execute on the CPU or GPU. A `Model` constructor is now provided in which all important information can be input via keyword arguments. I favor this kind of design for fluids codes because I believe it improves the understand-ability of scripts, as it encourages explicit naming of parameters passed into the `Model` constructor. The output writing functionality has also been refactored slightly. However, many more changes will be made in the future so this is not consequential. I also reduced the computational burden of a few of the tests, and changed to factor of 2 resolutions since this makes sense for FFTs (though relatively unimportant for testing, I think should encourage users to use powers of 2 and make a habit of using them ourselves). A few more notes:. * We need tests for output writers, and the output writing functionality needs to be revamped; * The model constructor needs work; * The examples are outdated. We should probably reduce the number of examples until the code becomes more stable, and commit to maintaining the few that remain; * We should get rid of model metadata and simply include the 'architecture' as a type parameter of `Model`; * and so much more... Lots of work to do!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/97
https://github.com/CliMA/Oceananigans.jl/pull/101:255,Testability,test,testing,255,"Just cleaning up some stuff and removing unnecessary cruft: operator temporary fields, forcing fields, density field, and hydrostatic pressure field. This will save us a lot of memory!. Also added a CPU and GPU environment which we can start using for CI testing and local runs. Resolves #65",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/101
https://github.com/CliMA/Oceananigans.jl/pull/103:43,Deployability,update,updates,43,This PR improves the existing examples and updates them to work with the current version of the model. There were also a couple of minor changes:; * Output writer API: Filename suffix is now called a file extension. No more inserting underscores for empty names and filename_prefix. User should include underscore if they want one.; * Model metadata: Use `:CPU` and `:GPU` instead of `:cpu` and `:gpu`. This is so that Oceananigans.jl agrees with the symbols used in GPUifyLoops.jl.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/103
https://github.com/CliMA/Oceananigans.jl/issues/106:217,Safety,avoid,avoid,217,">The core of the method is an eigenfunction expansion of the discrete Poisson operator... I think?; >; >Perhaps we can call this a `EigenPoissonSolver`, or even `FFTPoissonSolver` --- through we should use caution to avoid misleading people into thinking that our code is spectral. This algorithm solves the Poisson equation when it has been *discretized on a staggered grid*. We should not discuss spectral methods or Fourier transforms, and the word 'spectral' should not appear anywhere in the code. I think this is very misleading. It should be a high priority to change this language.; >; >_Originally posted by @glwagner in https://github.com/climate-machine/Oceananigans.jl/issues/102#issuecomment-468947308_. I think `EigenPoissonSolver` is a better name. Just creating a separate issue as this should be a pretty easy item to resolve, and is separate from updating the documentation.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/106
https://github.com/CliMA/Oceananigans.jl/issues/108:60,Performance,Perform,Performance,60,> @ali-ramadhan why not broadcast over CuArrays? Is there a Performance hit?; > ; > _Originally posted by @glwagner in https://github.com/climate-machine/Oceananigans.jl/issues/104#issuecomment-469749450_,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/108
https://github.com/CliMA/Oceananigans.jl/issues/110:445,Availability,Ping,Pinging,445,"Following up from https://github.com/climate-machine/Oceananigans.jl/issues/73 it would be nice if the forcing can be also be expressed as an array. This might be nice for a couple of applications:; 1. A forcing that is constant and very expensive to compute (e.g. lots of calculations, branching statements, or intermediate calculations).; 2. Forcing array can be passed around and filled elsewhere, e.g. by a biogeochemical agent-based model. Pinging: @zhenwu0728",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/110
https://github.com/CliMA/Oceananigans.jl/issues/115:343,Energy Efficiency,efficient,efficiently,343,"Right now the element-wise operators are all written for the constant _Δx_, _Δy_, _Δz_ case. As we transition to supporting variable grid spacings, the operators should be written as finite volume operators that take into account the variable areas and volumes. We should be able to figure out a way to write the operators such that they work efficiently for all Cartesian grids. Would be good to do this before #47 is implemented. This may require #59 to be resolved first.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/115
https://github.com/CliMA/Oceananigans.jl/issues/115:124,Modifiability,variab,variable,124,"Right now the element-wise operators are all written for the constant _Δx_, _Δy_, _Δz_ case. As we transition to supporting variable grid spacings, the operators should be written as finite volume operators that take into account the variable areas and volumes. We should be able to figure out a way to write the operators such that they work efficiently for all Cartesian grids. Would be good to do this before #47 is implemented. This may require #59 to be resolved first.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/115
https://github.com/CliMA/Oceananigans.jl/issues/115:234,Modifiability,variab,variable,234,"Right now the element-wise operators are all written for the constant _Δx_, _Δy_, _Δz_ case. As we transition to supporting variable grid spacings, the operators should be written as finite volume operators that take into account the variable areas and volumes. We should be able to figure out a way to write the operators such that they work efficiently for all Cartesian grids. Would be good to do this before #47 is implemented. This may require #59 to be resolved first.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/115
https://github.com/CliMA/Oceananigans.jl/pull/116:3636,Availability,down,down,3636,"4x 64x 64 static ocean (CPU, Float64) 10 635ms 0.19% 63.5ms 13.5KiB 0.49% 1.35KiB; 128x128x128 static ocean (GPU, Float64) 10 80.2ms 0.02% 8.02ms 332KiB 12.0% 33.2KiB; 128x128x128 static ocean (GPU, Float32) 10 77.0ms 0.02% 7.70ms 329KiB 11.9% 32.9KiB; 32x 32x 32 static ocean (CPU, Float32) 10 72.3ms 0.02% 7.23ms 13.1KiB 0.47% 1.31KiB; 32x 32x 32 static ocean (CPU, Float64) 10 45.1ms 0.01% 4.51ms 13.5KiB 0.49% 1.35KiB; 64x 64x 64 static ocean (GPU, Float64) 10 8.30ms 0.00% 830μs 332KiB 12.0% 33.2KiB; 64x 64x 64 static ocean (GPU, Float32) 10 8.05ms 0.00% 805μs 329KiB 11.9% 32.9KiB; 32x 32x 32 static ocean (GPU, Float64) 10 3.63ms 0.00% 363μs 332KiB 12.0% 33.2KiB; 32x 32x 32 static ocean (GPU, Float32) 10 3.45ms 0.00% 345μs 329KiB 11.9% 32.9KiB; ──────────────────────────────────────────────────────────────────────────────────────────────────. CPU Float64 -> Float32 speedups:; 32x 32x 32 static ocean: 0.623; 64x 64x 64 static ocean: 0.614; 128x128x128 static ocean: 0.723; 256x256x256 static ocean: 0.841. GPU Float64 -> Float32 speedups:; 32x 32x 32 static ocean: 1.052; 64x 64x 64 static ocean: 1.031; 128x128x128 static ocean: 1.042; 256x256x256 static ocean: 1.038. CPU -> GPU speedsup:; 32x 32x 32 static ocean (Float32): 20.923; 32x 32x 32 static ocean (Float64): 12.402; 64x 64x 64 static ocean (Float32): 128.536; 64x 64x 64 static ocean (Float64): 76.582; 128x128x128 static ocean (Float32): 161.689; 128x128x128 static ocean (Float64): 112.144; 256x256x256 static ocean (Float32): 195.877; 256x256x256 static ocean (Float64): 158.772; ```. Some comments:; * Switching to `Float32` actually slowed things down on my CPU (and on the cluster).; * No surprise: GPU does better with bigger problems. Running another benchmark with 512x512x512 to see if we can break 200x!; * When I did this kind of timing a couple of weeks ago I only saw CPU->GPU speedups of ~90x but now we're getting ~195x for the largest model with `Float32`. We've improved performance without even knowing it!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/116
https://github.com/CliMA/Oceananigans.jl/pull/116:511,Deployability,configurat,configuration,511,"This PR adds a benchmarking script that times how long a single time step takes on the CPU and GPU using `Float32` and `Float64` for various model resolutions. It uses TimerOutputs.jl to nicely format the benchmarks. It also prints out CPU->GPU speedups and Float64->Float32 ""speedups"". It only executes the GPU benchmarks if executed on a CUDA-enabled machine. We can later extend it to time model initialization, different parts of the time stepping, etc. Right now it only benchmarks a simple ""static ocean"" configuration so no fancy forcing functions are used, but we can extend the number of scenarios/experiments we benchmark. The time stepping and Poisson solver still takes the same amount of time whether the ocean is static or active. Resolves #67. Well, kind of. It's not clear to me how to easily incorperate this with CI in a way that doesn't involve one of us eyeballing the text output. For now we should at least run this script every time we make a change that might potentially impact performance. Example output; ```; ──────────────────────────────────────────────────────────────────────────────────────────────────; Oceananigans.jl benchmarks Time Allocations; ────────────────────── ───────────────────────; Tot / % measured: 718s / 46.6% 17.2GiB / 0.02%. Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────────────────; 256x256x256 static ocean (CPU, Float32) 10 168s 50.2% 16.8s 20.3KiB 0.73% 2.03KiB; 256x256x256 static ocean (CPU, Float64) 10 141s 42.3% 14.1s 20.3KiB 0.73% 2.03KiB; 128x128x128 static ocean (CPU, Float32) 10 12.4s 3.72% 1.24s 14.5KiB 0.52% 1.45KiB; 128x128x128 static ocean (CPU, Float64) 10 9.00s 2.69% 900ms 14.8KiB 0.54% 1.48KiB; 64x 64x 64 static ocean (CPU, Float32) 10 1.03s 0.31% 103ms 14.2KiB 0.51% 1.42KiB; 256x256x256 static ocean (GPU, Float64) 10 891ms 0.27% 89.1ms 333KiB 12.0% 33.3KiB; 256x256x256 static ocean (GPU, Float32) 10 859ms 0.26% 85.9ms 329KiB 11.9% 32",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/116
https://github.com/CliMA/Oceananigans.jl/pull/116:375,Modifiability,extend,extend,375,"This PR adds a benchmarking script that times how long a single time step takes on the CPU and GPU using `Float32` and `Float64` for various model resolutions. It uses TimerOutputs.jl to nicely format the benchmarks. It also prints out CPU->GPU speedups and Float64->Float32 ""speedups"". It only executes the GPU benchmarks if executed on a CUDA-enabled machine. We can later extend it to time model initialization, different parts of the time stepping, etc. Right now it only benchmarks a simple ""static ocean"" configuration so no fancy forcing functions are used, but we can extend the number of scenarios/experiments we benchmark. The time stepping and Poisson solver still takes the same amount of time whether the ocean is static or active. Resolves #67. Well, kind of. It's not clear to me how to easily incorperate this with CI in a way that doesn't involve one of us eyeballing the text output. For now we should at least run this script every time we make a change that might potentially impact performance. Example output; ```; ──────────────────────────────────────────────────────────────────────────────────────────────────; Oceananigans.jl benchmarks Time Allocations; ────────────────────── ───────────────────────; Tot / % measured: 718s / 46.6% 17.2GiB / 0.02%. Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────────────────; 256x256x256 static ocean (CPU, Float32) 10 168s 50.2% 16.8s 20.3KiB 0.73% 2.03KiB; 256x256x256 static ocean (CPU, Float64) 10 141s 42.3% 14.1s 20.3KiB 0.73% 2.03KiB; 128x128x128 static ocean (CPU, Float32) 10 12.4s 3.72% 1.24s 14.5KiB 0.52% 1.45KiB; 128x128x128 static ocean (CPU, Float64) 10 9.00s 2.69% 900ms 14.8KiB 0.54% 1.48KiB; 64x 64x 64 static ocean (CPU, Float32) 10 1.03s 0.31% 103ms 14.2KiB 0.51% 1.42KiB; 256x256x256 static ocean (GPU, Float64) 10 891ms 0.27% 89.1ms 333KiB 12.0% 33.3KiB; 256x256x256 static ocean (GPU, Float32) 10 859ms 0.26% 85.9ms 329KiB 11.9% 32",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/116
https://github.com/CliMA/Oceananigans.jl/pull/116:511,Modifiability,config,configuration,511,"This PR adds a benchmarking script that times how long a single time step takes on the CPU and GPU using `Float32` and `Float64` for various model resolutions. It uses TimerOutputs.jl to nicely format the benchmarks. It also prints out CPU->GPU speedups and Float64->Float32 ""speedups"". It only executes the GPU benchmarks if executed on a CUDA-enabled machine. We can later extend it to time model initialization, different parts of the time stepping, etc. Right now it only benchmarks a simple ""static ocean"" configuration so no fancy forcing functions are used, but we can extend the number of scenarios/experiments we benchmark. The time stepping and Poisson solver still takes the same amount of time whether the ocean is static or active. Resolves #67. Well, kind of. It's not clear to me how to easily incorperate this with CI in a way that doesn't involve one of us eyeballing the text output. For now we should at least run this script every time we make a change that might potentially impact performance. Example output; ```; ──────────────────────────────────────────────────────────────────────────────────────────────────; Oceananigans.jl benchmarks Time Allocations; ────────────────────── ───────────────────────; Tot / % measured: 718s / 46.6% 17.2GiB / 0.02%. Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────────────────; 256x256x256 static ocean (CPU, Float32) 10 168s 50.2% 16.8s 20.3KiB 0.73% 2.03KiB; 256x256x256 static ocean (CPU, Float64) 10 141s 42.3% 14.1s 20.3KiB 0.73% 2.03KiB; 128x128x128 static ocean (CPU, Float32) 10 12.4s 3.72% 1.24s 14.5KiB 0.52% 1.45KiB; 128x128x128 static ocean (CPU, Float64) 10 9.00s 2.69% 900ms 14.8KiB 0.54% 1.48KiB; 64x 64x 64 static ocean (CPU, Float32) 10 1.03s 0.31% 103ms 14.2KiB 0.51% 1.42KiB; 256x256x256 static ocean (GPU, Float64) 10 891ms 0.27% 89.1ms 333KiB 12.0% 33.3KiB; 256x256x256 static ocean (GPU, Float32) 10 859ms 0.26% 85.9ms 329KiB 11.9% 32",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/116
https://github.com/CliMA/Oceananigans.jl/pull/116:576,Modifiability,extend,extend,576,"This PR adds a benchmarking script that times how long a single time step takes on the CPU and GPU using `Float32` and `Float64` for various model resolutions. It uses TimerOutputs.jl to nicely format the benchmarks. It also prints out CPU->GPU speedups and Float64->Float32 ""speedups"". It only executes the GPU benchmarks if executed on a CUDA-enabled machine. We can later extend it to time model initialization, different parts of the time stepping, etc. Right now it only benchmarks a simple ""static ocean"" configuration so no fancy forcing functions are used, but we can extend the number of scenarios/experiments we benchmark. The time stepping and Poisson solver still takes the same amount of time whether the ocean is static or active. Resolves #67. Well, kind of. It's not clear to me how to easily incorperate this with CI in a way that doesn't involve one of us eyeballing the text output. For now we should at least run this script every time we make a change that might potentially impact performance. Example output; ```; ──────────────────────────────────────────────────────────────────────────────────────────────────; Oceananigans.jl benchmarks Time Allocations; ────────────────────── ───────────────────────; Tot / % measured: 718s / 46.6% 17.2GiB / 0.02%. Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────────────────; 256x256x256 static ocean (CPU, Float32) 10 168s 50.2% 16.8s 20.3KiB 0.73% 2.03KiB; 256x256x256 static ocean (CPU, Float64) 10 141s 42.3% 14.1s 20.3KiB 0.73% 2.03KiB; 128x128x128 static ocean (CPU, Float32) 10 12.4s 3.72% 1.24s 14.5KiB 0.52% 1.45KiB; 128x128x128 static ocean (CPU, Float64) 10 9.00s 2.69% 900ms 14.8KiB 0.54% 1.48KiB; 64x 64x 64 static ocean (CPU, Float32) 10 1.03s 0.31% 103ms 14.2KiB 0.51% 1.42KiB; 256x256x256 static ocean (GPU, Float64) 10 891ms 0.27% 89.1ms 333KiB 12.0% 33.3KiB; 256x256x256 static ocean (GPU, Float32) 10 859ms 0.26% 85.9ms 329KiB 11.9% 32",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/116
https://github.com/CliMA/Oceananigans.jl/pull/116:1003,Performance,perform,performance,1003,"This PR adds a benchmarking script that times how long a single time step takes on the CPU and GPU using `Float32` and `Float64` for various model resolutions. It uses TimerOutputs.jl to nicely format the benchmarks. It also prints out CPU->GPU speedups and Float64->Float32 ""speedups"". It only executes the GPU benchmarks if executed on a CUDA-enabled machine. We can later extend it to time model initialization, different parts of the time stepping, etc. Right now it only benchmarks a simple ""static ocean"" configuration so no fancy forcing functions are used, but we can extend the number of scenarios/experiments we benchmark. The time stepping and Poisson solver still takes the same amount of time whether the ocean is static or active. Resolves #67. Well, kind of. It's not clear to me how to easily incorperate this with CI in a way that doesn't involve one of us eyeballing the text output. For now we should at least run this script every time we make a change that might potentially impact performance. Example output; ```; ──────────────────────────────────────────────────────────────────────────────────────────────────; Oceananigans.jl benchmarks Time Allocations; ────────────────────── ───────────────────────; Tot / % measured: 718s / 46.6% 17.2GiB / 0.02%. Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────────────────; 256x256x256 static ocean (CPU, Float32) 10 168s 50.2% 16.8s 20.3KiB 0.73% 2.03KiB; 256x256x256 static ocean (CPU, Float64) 10 141s 42.3% 14.1s 20.3KiB 0.73% 2.03KiB; 128x128x128 static ocean (CPU, Float32) 10 12.4s 3.72% 1.24s 14.5KiB 0.52% 1.45KiB; 128x128x128 static ocean (CPU, Float64) 10 9.00s 2.69% 900ms 14.8KiB 0.54% 1.48KiB; 64x 64x 64 static ocean (CPU, Float32) 10 1.03s 0.31% 103ms 14.2KiB 0.51% 1.42KiB; 256x256x256 static ocean (GPU, Float64) 10 891ms 0.27% 89.1ms 333KiB 12.0% 33.3KiB; 256x256x256 static ocean (GPU, Float32) 10 859ms 0.26% 85.9ms 329KiB 11.9% 32",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/116
https://github.com/CliMA/Oceananigans.jl/pull/116:3973,Performance,perform,performance,3973,"4x 64x 64 static ocean (CPU, Float64) 10 635ms 0.19% 63.5ms 13.5KiB 0.49% 1.35KiB; 128x128x128 static ocean (GPU, Float64) 10 80.2ms 0.02% 8.02ms 332KiB 12.0% 33.2KiB; 128x128x128 static ocean (GPU, Float32) 10 77.0ms 0.02% 7.70ms 329KiB 11.9% 32.9KiB; 32x 32x 32 static ocean (CPU, Float32) 10 72.3ms 0.02% 7.23ms 13.1KiB 0.47% 1.31KiB; 32x 32x 32 static ocean (CPU, Float64) 10 45.1ms 0.01% 4.51ms 13.5KiB 0.49% 1.35KiB; 64x 64x 64 static ocean (GPU, Float64) 10 8.30ms 0.00% 830μs 332KiB 12.0% 33.2KiB; 64x 64x 64 static ocean (GPU, Float32) 10 8.05ms 0.00% 805μs 329KiB 11.9% 32.9KiB; 32x 32x 32 static ocean (GPU, Float64) 10 3.63ms 0.00% 363μs 332KiB 12.0% 33.2KiB; 32x 32x 32 static ocean (GPU, Float32) 10 3.45ms 0.00% 345μs 329KiB 11.9% 32.9KiB; ──────────────────────────────────────────────────────────────────────────────────────────────────. CPU Float64 -> Float32 speedups:; 32x 32x 32 static ocean: 0.623; 64x 64x 64 static ocean: 0.614; 128x128x128 static ocean: 0.723; 256x256x256 static ocean: 0.841. GPU Float64 -> Float32 speedups:; 32x 32x 32 static ocean: 1.052; 64x 64x 64 static ocean: 1.031; 128x128x128 static ocean: 1.042; 256x256x256 static ocean: 1.038. CPU -> GPU speedsup:; 32x 32x 32 static ocean (Float32): 20.923; 32x 32x 32 static ocean (Float64): 12.402; 64x 64x 64 static ocean (Float32): 128.536; 64x 64x 64 static ocean (Float64): 76.582; 128x128x128 static ocean (Float32): 161.689; 128x128x128 static ocean (Float64): 112.144; 256x256x256 static ocean (Float32): 195.877; 256x256x256 static ocean (Float64): 158.772; ```. Some comments:; * Switching to `Float32` actually slowed things down on my CPU (and on the cluster).; * No surprise: GPU does better with bigger problems. Running another benchmark with 512x512x512 to see if we can break 200x!; * When I did this kind of timing a couple of weeks ago I only saw CPU->GPU speedups of ~90x but now we're getting ~195x for the largest model with `Float32`. We've improved performance without even knowing it!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/116
https://github.com/CliMA/Oceananigans.jl/pull/116:15,Testability,benchmark,benchmarking,15,"This PR adds a benchmarking script that times how long a single time step takes on the CPU and GPU using `Float32` and `Float64` for various model resolutions. It uses TimerOutputs.jl to nicely format the benchmarks. It also prints out CPU->GPU speedups and Float64->Float32 ""speedups"". It only executes the GPU benchmarks if executed on a CUDA-enabled machine. We can later extend it to time model initialization, different parts of the time stepping, etc. Right now it only benchmarks a simple ""static ocean"" configuration so no fancy forcing functions are used, but we can extend the number of scenarios/experiments we benchmark. The time stepping and Poisson solver still takes the same amount of time whether the ocean is static or active. Resolves #67. Well, kind of. It's not clear to me how to easily incorperate this with CI in a way that doesn't involve one of us eyeballing the text output. For now we should at least run this script every time we make a change that might potentially impact performance. Example output; ```; ──────────────────────────────────────────────────────────────────────────────────────────────────; Oceananigans.jl benchmarks Time Allocations; ────────────────────── ───────────────────────; Tot / % measured: 718s / 46.6% 17.2GiB / 0.02%. Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────────────────; 256x256x256 static ocean (CPU, Float32) 10 168s 50.2% 16.8s 20.3KiB 0.73% 2.03KiB; 256x256x256 static ocean (CPU, Float64) 10 141s 42.3% 14.1s 20.3KiB 0.73% 2.03KiB; 128x128x128 static ocean (CPU, Float32) 10 12.4s 3.72% 1.24s 14.5KiB 0.52% 1.45KiB; 128x128x128 static ocean (CPU, Float64) 10 9.00s 2.69% 900ms 14.8KiB 0.54% 1.48KiB; 64x 64x 64 static ocean (CPU, Float32) 10 1.03s 0.31% 103ms 14.2KiB 0.51% 1.42KiB; 256x256x256 static ocean (GPU, Float64) 10 891ms 0.27% 89.1ms 333KiB 12.0% 33.3KiB; 256x256x256 static ocean (GPU, Float32) 10 859ms 0.26% 85.9ms 329KiB 11.9% 32",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/116
https://github.com/CliMA/Oceananigans.jl/pull/116:205,Testability,benchmark,benchmarks,205,"This PR adds a benchmarking script that times how long a single time step takes on the CPU and GPU using `Float32` and `Float64` for various model resolutions. It uses TimerOutputs.jl to nicely format the benchmarks. It also prints out CPU->GPU speedups and Float64->Float32 ""speedups"". It only executes the GPU benchmarks if executed on a CUDA-enabled machine. We can later extend it to time model initialization, different parts of the time stepping, etc. Right now it only benchmarks a simple ""static ocean"" configuration so no fancy forcing functions are used, but we can extend the number of scenarios/experiments we benchmark. The time stepping and Poisson solver still takes the same amount of time whether the ocean is static or active. Resolves #67. Well, kind of. It's not clear to me how to easily incorperate this with CI in a way that doesn't involve one of us eyeballing the text output. For now we should at least run this script every time we make a change that might potentially impact performance. Example output; ```; ──────────────────────────────────────────────────────────────────────────────────────────────────; Oceananigans.jl benchmarks Time Allocations; ────────────────────── ───────────────────────; Tot / % measured: 718s / 46.6% 17.2GiB / 0.02%. Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────────────────; 256x256x256 static ocean (CPU, Float32) 10 168s 50.2% 16.8s 20.3KiB 0.73% 2.03KiB; 256x256x256 static ocean (CPU, Float64) 10 141s 42.3% 14.1s 20.3KiB 0.73% 2.03KiB; 128x128x128 static ocean (CPU, Float32) 10 12.4s 3.72% 1.24s 14.5KiB 0.52% 1.45KiB; 128x128x128 static ocean (CPU, Float64) 10 9.00s 2.69% 900ms 14.8KiB 0.54% 1.48KiB; 64x 64x 64 static ocean (CPU, Float32) 10 1.03s 0.31% 103ms 14.2KiB 0.51% 1.42KiB; 256x256x256 static ocean (GPU, Float64) 10 891ms 0.27% 89.1ms 333KiB 12.0% 33.3KiB; 256x256x256 static ocean (GPU, Float32) 10 859ms 0.26% 85.9ms 329KiB 11.9% 32",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/116
https://github.com/CliMA/Oceananigans.jl/pull/116:312,Testability,benchmark,benchmarks,312,"This PR adds a benchmarking script that times how long a single time step takes on the CPU and GPU using `Float32` and `Float64` for various model resolutions. It uses TimerOutputs.jl to nicely format the benchmarks. It also prints out CPU->GPU speedups and Float64->Float32 ""speedups"". It only executes the GPU benchmarks if executed on a CUDA-enabled machine. We can later extend it to time model initialization, different parts of the time stepping, etc. Right now it only benchmarks a simple ""static ocean"" configuration so no fancy forcing functions are used, but we can extend the number of scenarios/experiments we benchmark. The time stepping and Poisson solver still takes the same amount of time whether the ocean is static or active. Resolves #67. Well, kind of. It's not clear to me how to easily incorperate this with CI in a way that doesn't involve one of us eyeballing the text output. For now we should at least run this script every time we make a change that might potentially impact performance. Example output; ```; ──────────────────────────────────────────────────────────────────────────────────────────────────; Oceananigans.jl benchmarks Time Allocations; ────────────────────── ───────────────────────; Tot / % measured: 718s / 46.6% 17.2GiB / 0.02%. Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────────────────; 256x256x256 static ocean (CPU, Float32) 10 168s 50.2% 16.8s 20.3KiB 0.73% 2.03KiB; 256x256x256 static ocean (CPU, Float64) 10 141s 42.3% 14.1s 20.3KiB 0.73% 2.03KiB; 128x128x128 static ocean (CPU, Float32) 10 12.4s 3.72% 1.24s 14.5KiB 0.52% 1.45KiB; 128x128x128 static ocean (CPU, Float64) 10 9.00s 2.69% 900ms 14.8KiB 0.54% 1.48KiB; 64x 64x 64 static ocean (CPU, Float32) 10 1.03s 0.31% 103ms 14.2KiB 0.51% 1.42KiB; 256x256x256 static ocean (GPU, Float64) 10 891ms 0.27% 89.1ms 333KiB 12.0% 33.3KiB; 256x256x256 static ocean (GPU, Float32) 10 859ms 0.26% 85.9ms 329KiB 11.9% 32",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/116
https://github.com/CliMA/Oceananigans.jl/pull/116:476,Testability,benchmark,benchmarks,476,"This PR adds a benchmarking script that times how long a single time step takes on the CPU and GPU using `Float32` and `Float64` for various model resolutions. It uses TimerOutputs.jl to nicely format the benchmarks. It also prints out CPU->GPU speedups and Float64->Float32 ""speedups"". It only executes the GPU benchmarks if executed on a CUDA-enabled machine. We can later extend it to time model initialization, different parts of the time stepping, etc. Right now it only benchmarks a simple ""static ocean"" configuration so no fancy forcing functions are used, but we can extend the number of scenarios/experiments we benchmark. The time stepping and Poisson solver still takes the same amount of time whether the ocean is static or active. Resolves #67. Well, kind of. It's not clear to me how to easily incorperate this with CI in a way that doesn't involve one of us eyeballing the text output. For now we should at least run this script every time we make a change that might potentially impact performance. Example output; ```; ──────────────────────────────────────────────────────────────────────────────────────────────────; Oceananigans.jl benchmarks Time Allocations; ────────────────────── ───────────────────────; Tot / % measured: 718s / 46.6% 17.2GiB / 0.02%. Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────────────────; 256x256x256 static ocean (CPU, Float32) 10 168s 50.2% 16.8s 20.3KiB 0.73% 2.03KiB; 256x256x256 static ocean (CPU, Float64) 10 141s 42.3% 14.1s 20.3KiB 0.73% 2.03KiB; 128x128x128 static ocean (CPU, Float32) 10 12.4s 3.72% 1.24s 14.5KiB 0.52% 1.45KiB; 128x128x128 static ocean (CPU, Float64) 10 9.00s 2.69% 900ms 14.8KiB 0.54% 1.48KiB; 64x 64x 64 static ocean (CPU, Float32) 10 1.03s 0.31% 103ms 14.2KiB 0.51% 1.42KiB; 256x256x256 static ocean (GPU, Float64) 10 891ms 0.27% 89.1ms 333KiB 12.0% 33.3KiB; 256x256x256 static ocean (GPU, Float32) 10 859ms 0.26% 85.9ms 329KiB 11.9% 32",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/116
https://github.com/CliMA/Oceananigans.jl/pull/116:622,Testability,benchmark,benchmark,622,"This PR adds a benchmarking script that times how long a single time step takes on the CPU and GPU using `Float32` and `Float64` for various model resolutions. It uses TimerOutputs.jl to nicely format the benchmarks. It also prints out CPU->GPU speedups and Float64->Float32 ""speedups"". It only executes the GPU benchmarks if executed on a CUDA-enabled machine. We can later extend it to time model initialization, different parts of the time stepping, etc. Right now it only benchmarks a simple ""static ocean"" configuration so no fancy forcing functions are used, but we can extend the number of scenarios/experiments we benchmark. The time stepping and Poisson solver still takes the same amount of time whether the ocean is static or active. Resolves #67. Well, kind of. It's not clear to me how to easily incorperate this with CI in a way that doesn't involve one of us eyeballing the text output. For now we should at least run this script every time we make a change that might potentially impact performance. Example output; ```; ──────────────────────────────────────────────────────────────────────────────────────────────────; Oceananigans.jl benchmarks Time Allocations; ────────────────────── ───────────────────────; Tot / % measured: 718s / 46.6% 17.2GiB / 0.02%. Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────────────────; 256x256x256 static ocean (CPU, Float32) 10 168s 50.2% 16.8s 20.3KiB 0.73% 2.03KiB; 256x256x256 static ocean (CPU, Float64) 10 141s 42.3% 14.1s 20.3KiB 0.73% 2.03KiB; 128x128x128 static ocean (CPU, Float32) 10 12.4s 3.72% 1.24s 14.5KiB 0.52% 1.45KiB; 128x128x128 static ocean (CPU, Float64) 10 9.00s 2.69% 900ms 14.8KiB 0.54% 1.48KiB; 64x 64x 64 static ocean (CPU, Float32) 10 1.03s 0.31% 103ms 14.2KiB 0.51% 1.42KiB; 256x256x256 static ocean (GPU, Float64) 10 891ms 0.27% 89.1ms 333KiB 12.0% 33.3KiB; 256x256x256 static ocean (GPU, Float32) 10 859ms 0.26% 85.9ms 329KiB 11.9% 32",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/116
https://github.com/CliMA/Oceananigans.jl/pull/116:1153,Testability,benchmark,benchmarks,1153," benchmarks. It also prints out CPU->GPU speedups and Float64->Float32 ""speedups"". It only executes the GPU benchmarks if executed on a CUDA-enabled machine. We can later extend it to time model initialization, different parts of the time stepping, etc. Right now it only benchmarks a simple ""static ocean"" configuration so no fancy forcing functions are used, but we can extend the number of scenarios/experiments we benchmark. The time stepping and Poisson solver still takes the same amount of time whether the ocean is static or active. Resolves #67. Well, kind of. It's not clear to me how to easily incorperate this with CI in a way that doesn't involve one of us eyeballing the text output. For now we should at least run this script every time we make a change that might potentially impact performance. Example output; ```; ──────────────────────────────────────────────────────────────────────────────────────────────────; Oceananigans.jl benchmarks Time Allocations; ────────────────────── ───────────────────────; Tot / % measured: 718s / 46.6% 17.2GiB / 0.02%. Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────────────────; 256x256x256 static ocean (CPU, Float32) 10 168s 50.2% 16.8s 20.3KiB 0.73% 2.03KiB; 256x256x256 static ocean (CPU, Float64) 10 141s 42.3% 14.1s 20.3KiB 0.73% 2.03KiB; 128x128x128 static ocean (CPU, Float32) 10 12.4s 3.72% 1.24s 14.5KiB 0.52% 1.45KiB; 128x128x128 static ocean (CPU, Float64) 10 9.00s 2.69% 900ms 14.8KiB 0.54% 1.48KiB; 64x 64x 64 static ocean (CPU, Float32) 10 1.03s 0.31% 103ms 14.2KiB 0.51% 1.42KiB; 256x256x256 static ocean (GPU, Float64) 10 891ms 0.27% 89.1ms 333KiB 12.0% 33.3KiB; 256x256x256 static ocean (GPU, Float32) 10 859ms 0.26% 85.9ms 329KiB 11.9% 32.9KiB; 64x 64x 64 static ocean (CPU, Float64) 10 635ms 0.19% 63.5ms 13.5KiB 0.49% 1.35KiB; 128x128x128 static ocean (GPU, Float64) 10 80.2ms 0.02% 8.02ms 332KiB 12.0% 33.2KiB; 128x128x128 static ocean (G",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/116
https://github.com/CliMA/Oceananigans.jl/pull/116:3743,Testability,benchmark,benchmark,3743,"4x 64x 64 static ocean (CPU, Float64) 10 635ms 0.19% 63.5ms 13.5KiB 0.49% 1.35KiB; 128x128x128 static ocean (GPU, Float64) 10 80.2ms 0.02% 8.02ms 332KiB 12.0% 33.2KiB; 128x128x128 static ocean (GPU, Float32) 10 77.0ms 0.02% 7.70ms 329KiB 11.9% 32.9KiB; 32x 32x 32 static ocean (CPU, Float32) 10 72.3ms 0.02% 7.23ms 13.1KiB 0.47% 1.31KiB; 32x 32x 32 static ocean (CPU, Float64) 10 45.1ms 0.01% 4.51ms 13.5KiB 0.49% 1.35KiB; 64x 64x 64 static ocean (GPU, Float64) 10 8.30ms 0.00% 830μs 332KiB 12.0% 33.2KiB; 64x 64x 64 static ocean (GPU, Float32) 10 8.05ms 0.00% 805μs 329KiB 11.9% 32.9KiB; 32x 32x 32 static ocean (GPU, Float64) 10 3.63ms 0.00% 363μs 332KiB 12.0% 33.2KiB; 32x 32x 32 static ocean (GPU, Float32) 10 3.45ms 0.00% 345μs 329KiB 11.9% 32.9KiB; ──────────────────────────────────────────────────────────────────────────────────────────────────. CPU Float64 -> Float32 speedups:; 32x 32x 32 static ocean: 0.623; 64x 64x 64 static ocean: 0.614; 128x128x128 static ocean: 0.723; 256x256x256 static ocean: 0.841. GPU Float64 -> Float32 speedups:; 32x 32x 32 static ocean: 1.052; 64x 64x 64 static ocean: 1.031; 128x128x128 static ocean: 1.042; 256x256x256 static ocean: 1.038. CPU -> GPU speedsup:; 32x 32x 32 static ocean (Float32): 20.923; 32x 32x 32 static ocean (Float64): 12.402; 64x 64x 64 static ocean (Float32): 128.536; 64x 64x 64 static ocean (Float64): 76.582; 128x128x128 static ocean (Float32): 161.689; 128x128x128 static ocean (Float64): 112.144; 256x256x256 static ocean (Float32): 195.877; 256x256x256 static ocean (Float64): 158.772; ```. Some comments:; * Switching to `Float32` actually slowed things down on my CPU (and on the cluster).; * No surprise: GPU does better with bigger problems. Running another benchmark with 512x512x512 to see if we can break 200x!; * When I did this kind of timing a couple of weeks ago I only saw CPU->GPU speedups of ~90x but now we're getting ~195x for the largest model with `Float32`. We've improved performance without even knowing it!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/116
https://github.com/CliMA/Oceananigans.jl/pull/116:489,Usability,simpl,simple,489,"This PR adds a benchmarking script that times how long a single time step takes on the CPU and GPU using `Float32` and `Float64` for various model resolutions. It uses TimerOutputs.jl to nicely format the benchmarks. It also prints out CPU->GPU speedups and Float64->Float32 ""speedups"". It only executes the GPU benchmarks if executed on a CUDA-enabled machine. We can later extend it to time model initialization, different parts of the time stepping, etc. Right now it only benchmarks a simple ""static ocean"" configuration so no fancy forcing functions are used, but we can extend the number of scenarios/experiments we benchmark. The time stepping and Poisson solver still takes the same amount of time whether the ocean is static or active. Resolves #67. Well, kind of. It's not clear to me how to easily incorperate this with CI in a way that doesn't involve one of us eyeballing the text output. For now we should at least run this script every time we make a change that might potentially impact performance. Example output; ```; ──────────────────────────────────────────────────────────────────────────────────────────────────; Oceananigans.jl benchmarks Time Allocations; ────────────────────── ───────────────────────; Tot / % measured: 718s / 46.6% 17.2GiB / 0.02%. Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────────────────; 256x256x256 static ocean (CPU, Float32) 10 168s 50.2% 16.8s 20.3KiB 0.73% 2.03KiB; 256x256x256 static ocean (CPU, Float64) 10 141s 42.3% 14.1s 20.3KiB 0.73% 2.03KiB; 128x128x128 static ocean (CPU, Float32) 10 12.4s 3.72% 1.24s 14.5KiB 0.52% 1.45KiB; 128x128x128 static ocean (CPU, Float64) 10 9.00s 2.69% 900ms 14.8KiB 0.54% 1.48KiB; 64x 64x 64 static ocean (CPU, Float32) 10 1.03s 0.31% 103ms 14.2KiB 0.51% 1.42KiB; 256x256x256 static ocean (GPU, Float64) 10 891ms 0.27% 89.1ms 333KiB 12.0% 33.3KiB; 256x256x256 static ocean (GPU, Float32) 10 859ms 0.26% 85.9ms 329KiB 11.9% 32",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/116
https://github.com/CliMA/Oceananigans.jl/pull/116:783,Usability,clear,clear,783,"This PR adds a benchmarking script that times how long a single time step takes on the CPU and GPU using `Float32` and `Float64` for various model resolutions. It uses TimerOutputs.jl to nicely format the benchmarks. It also prints out CPU->GPU speedups and Float64->Float32 ""speedups"". It only executes the GPU benchmarks if executed on a CUDA-enabled machine. We can later extend it to time model initialization, different parts of the time stepping, etc. Right now it only benchmarks a simple ""static ocean"" configuration so no fancy forcing functions are used, but we can extend the number of scenarios/experiments we benchmark. The time stepping and Poisson solver still takes the same amount of time whether the ocean is static or active. Resolves #67. Well, kind of. It's not clear to me how to easily incorperate this with CI in a way that doesn't involve one of us eyeballing the text output. For now we should at least run this script every time we make a change that might potentially impact performance. Example output; ```; ──────────────────────────────────────────────────────────────────────────────────────────────────; Oceananigans.jl benchmarks Time Allocations; ────────────────────── ───────────────────────; Tot / % measured: 718s / 46.6% 17.2GiB / 0.02%. Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────────────────; 256x256x256 static ocean (CPU, Float32) 10 168s 50.2% 16.8s 20.3KiB 0.73% 2.03KiB; 256x256x256 static ocean (CPU, Float64) 10 141s 42.3% 14.1s 20.3KiB 0.73% 2.03KiB; 128x128x128 static ocean (CPU, Float32) 10 12.4s 3.72% 1.24s 14.5KiB 0.52% 1.45KiB; 128x128x128 static ocean (CPU, Float64) 10 9.00s 2.69% 900ms 14.8KiB 0.54% 1.48KiB; 64x 64x 64 static ocean (CPU, Float32) 10 1.03s 0.31% 103ms 14.2KiB 0.51% 1.42KiB; 256x256x256 static ocean (GPU, Float64) 10 891ms 0.27% 89.1ms 333KiB 12.0% 33.3KiB; 256x256x256 static ocean (GPU, Float32) 10 859ms 0.26% 85.9ms 329KiB 11.9% 32",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/116
https://github.com/CliMA/Oceananigans.jl/pull/118:2894,Modifiability,config,configure,2894,"left` and `right`; * `FieldBoundaryConditions` with fields `x`, `y`, and `z`; * `BoundaryConditions` with fields `u`, `v`, `w`, `T`, and `S`. ### Specifying boundary conditions and user API. A boundary condition is now specified by defining a function that calculates it within a kernel that loops over the boundary in question. The arguments of a flux boundary conditions on a top or bottom boundary (the only situation supported so far) are. ```julia; u, v, w, T, S, t, step, Nx, Ny, Nz, Δx, Δy, Δz, i, j; ```. This will probably change in the future. The user API is rather threadbare at the moment. To define a constant flux boundary condition, for example, the user might write (to specify the boundary condition as a function). ```julia; model = Model(...). const constant_flux = # something; surface_temperature_flux(args...) = constant_flux; flux_bc = BoundaryCondition{Flux}(surface_temperature_flux); model.boundary_conditions.T.z.right = flux_bc; ```. to specify the boundary condition as a constant, . ```julia; model = Model(...). flux_bc = BoundaryCondition(Flux, constant_flux); model.boundary_conditions.T.z.right = flux_bc; ```. There are probably some sugary things that we can implement to smooth this specification. ### Caveats. * We support only flux boundary conditions at top and bottom at the moment; * We can only handle fluxes in terms of the constant vertical viscosities and diffusivities; * If the viscosities and diffusivities are allowed to vary in the vertical at some point in the future, we will have to re-configure the implementation; * We cannot intercept the specification of a flux if we have, for example, a parameterization like KPP that takes care of the surface fluxes with a closure (rather than as a boundary condition). ### A side note. I think that, at some point, it would be preferable to move the implementation of boundary conditions and equations to a new file / module so that new physics can be easily implemented my modifying that module / file.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/118
https://github.com/CliMA/Oceananigans.jl/pull/118:3001,Modifiability,parameteriz,parameterization,3001,"left` and `right`; * `FieldBoundaryConditions` with fields `x`, `y`, and `z`; * `BoundaryConditions` with fields `u`, `v`, `w`, `T`, and `S`. ### Specifying boundary conditions and user API. A boundary condition is now specified by defining a function that calculates it within a kernel that loops over the boundary in question. The arguments of a flux boundary conditions on a top or bottom boundary (the only situation supported so far) are. ```julia; u, v, w, T, S, t, step, Nx, Ny, Nz, Δx, Δy, Δz, i, j; ```. This will probably change in the future. The user API is rather threadbare at the moment. To define a constant flux boundary condition, for example, the user might write (to specify the boundary condition as a function). ```julia; model = Model(...). const constant_flux = # something; surface_temperature_flux(args...) = constant_flux; flux_bc = BoundaryCondition{Flux}(surface_temperature_flux); model.boundary_conditions.T.z.right = flux_bc; ```. to specify the boundary condition as a constant, . ```julia; model = Model(...). flux_bc = BoundaryCondition(Flux, constant_flux); model.boundary_conditions.T.z.right = flux_bc; ```. There are probably some sugary things that we can implement to smooth this specification. ### Caveats. * We support only flux boundary conditions at top and bottom at the moment; * We can only handle fluxes in terms of the constant vertical viscosities and diffusivities; * If the viscosities and diffusivities are allowed to vary in the vertical at some point in the future, we will have to re-configure the implementation; * We cannot intercept the specification of a flux if we have, for example, a parameterization like KPP that takes care of the surface fluxes with a closure (rather than as a boundary condition). ### A side note. I think that, at some point, it would be preferable to move the implementation of boundary conditions and equations to a new file / module so that new physics can be easily implemented my modifying that module / file.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/118
https://github.com/CliMA/Oceananigans.jl/pull/118:110,Testability,test,tests,110,"This PR implements a new boundary condition API. It's a bit of a work in progress. Before merging we need:; * tests (simple 1D test with temperature to see if budgets are correct?); * export some appropriate objects / functions to user; * some API development to make boundary condition specification easier; * documentation. Criticism welcome!. ## Summary of implementation: the `BoundaryCondition`. The core type of this PR is `BoundaryCondition`. The `BoundaryCondition` has one field, `calc`, and is made callable via. ```julia; (bc::BoundaryCondition)(args...) = bc.calc(args...); ```. A `BoundaryCondition` has one parameter: `BCType`. The `BCType` can be `Default`, `Flux`, or `Value`. We include `Default` because the specification of boundary conditions is baked in to the algorithm. In the case of 'default' boundary conditions, no calculations are made. ### `nboundary_conditions = nfields x ndims x 2`. In principle, the user can specify `5 x 3 x 2` boundary conditions: on each of the 5 fields (which we currently have --- unfortunately, we may want more in the future), the user can specify a condition on any of the 6 boundaries. The model is initialized with all 30 boundary conditions set to `Default`. We allow for all possible boundaries to have conditions by introducing three structs:. * `CoordinateBoundaryConditions` with fields `left` and `right`; * `FieldBoundaryConditions` with fields `x`, `y`, and `z`; * `BoundaryConditions` with fields `u`, `v`, `w`, `T`, and `S`. ### Specifying boundary conditions and user API. A boundary condition is now specified by defining a function that calculates it within a kernel that loops over the boundary in question. The arguments of a flux boundary conditions on a top or bottom boundary (the only situation supported so far) are. ```julia; u, v, w, T, S, t, step, Nx, Ny, Nz, Δx, Δy, Δz, i, j; ```. This will probably change in the future. The user API is rather threadbare at the moment. To define a constant flux boundary condition,",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/118
https://github.com/CliMA/Oceananigans.jl/pull/118:127,Testability,test,test,127,"This PR implements a new boundary condition API. It's a bit of a work in progress. Before merging we need:; * tests (simple 1D test with temperature to see if budgets are correct?); * export some appropriate objects / functions to user; * some API development to make boundary condition specification easier; * documentation. Criticism welcome!. ## Summary of implementation: the `BoundaryCondition`. The core type of this PR is `BoundaryCondition`. The `BoundaryCondition` has one field, `calc`, and is made callable via. ```julia; (bc::BoundaryCondition)(args...) = bc.calc(args...); ```. A `BoundaryCondition` has one parameter: `BCType`. The `BCType` can be `Default`, `Flux`, or `Value`. We include `Default` because the specification of boundary conditions is baked in to the algorithm. In the case of 'default' boundary conditions, no calculations are made. ### `nboundary_conditions = nfields x ndims x 2`. In principle, the user can specify `5 x 3 x 2` boundary conditions: on each of the 5 fields (which we currently have --- unfortunately, we may want more in the future), the user can specify a condition on any of the 6 boundaries. The model is initialized with all 30 boundary conditions set to `Default`. We allow for all possible boundaries to have conditions by introducing three structs:. * `CoordinateBoundaryConditions` with fields `left` and `right`; * `FieldBoundaryConditions` with fields `x`, `y`, and `z`; * `BoundaryConditions` with fields `u`, `v`, `w`, `T`, and `S`. ### Specifying boundary conditions and user API. A boundary condition is now specified by defining a function that calculates it within a kernel that loops over the boundary in question. The arguments of a flux boundary conditions on a top or bottom boundary (the only situation supported so far) are. ```julia; u, v, w, T, S, t, step, Nx, Ny, Nz, Δx, Δy, Δz, i, j; ```. This will probably change in the future. The user API is rather threadbare at the moment. To define a constant flux boundary condition,",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/118
https://github.com/CliMA/Oceananigans.jl/pull/118:117,Usability,simpl,simple,117,"This PR implements a new boundary condition API. It's a bit of a work in progress. Before merging we need:; * tests (simple 1D test with temperature to see if budgets are correct?); * export some appropriate objects / functions to user; * some API development to make boundary condition specification easier; * documentation. Criticism welcome!. ## Summary of implementation: the `BoundaryCondition`. The core type of this PR is `BoundaryCondition`. The `BoundaryCondition` has one field, `calc`, and is made callable via. ```julia; (bc::BoundaryCondition)(args...) = bc.calc(args...); ```. A `BoundaryCondition` has one parameter: `BCType`. The `BCType` can be `Default`, `Flux`, or `Value`. We include `Default` because the specification of boundary conditions is baked in to the algorithm. In the case of 'default' boundary conditions, no calculations are made. ### `nboundary_conditions = nfields x ndims x 2`. In principle, the user can specify `5 x 3 x 2` boundary conditions: on each of the 5 fields (which we currently have --- unfortunately, we may want more in the future), the user can specify a condition on any of the 6 boundaries. The model is initialized with all 30 boundary conditions set to `Default`. We allow for all possible boundaries to have conditions by introducing three structs:. * `CoordinateBoundaryConditions` with fields `left` and `right`; * `FieldBoundaryConditions` with fields `x`, `y`, and `z`; * `BoundaryConditions` with fields `u`, `v`, `w`, `T`, and `S`. ### Specifying boundary conditions and user API. A boundary condition is now specified by defining a function that calculates it within a kernel that loops over the boundary in question. The arguments of a flux boundary conditions on a top or bottom boundary (the only situation supported so far) are. ```julia; u, v, w, T, S, t, step, Nx, Ny, Nz, Δx, Δy, Δz, i, j; ```. This will probably change in the future. The user API is rather threadbare at the moment. To define a constant flux boundary condition,",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/118
https://github.com/CliMA/Oceananigans.jl/issues/119:133,Availability,avail,available,133,> Do you think that we should allow people to plan multithreaded FFTs on the CPU? There's no reason not to use multithreading if its available.; > ; > _Originally posted by @glwagner in https://github.com/climate-machine/Oceananigans.jl/pull/116#issuecomment-470798886_,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/119
https://github.com/CliMA/Oceananigans.jl/issues/120:732,Energy Efficiency,energy,energy,732,"A high priority on the to-do list right now is writing LES closures. I'd like to discuss the implementation here before we open a PR. I propose that we view a ""closure"" as the addition of a viscosity/diffusivity, even a constant isotropic 'molecular' diffusivity. Moving the implementation of viscosity/diffusivity to the closure will make it less painful to write closures that modify boundary conditions, as they sometimes do. In addition, we may need to implement special time-stepping methods that apply both to LES closures and diffusivities (as discussed with @jm-c, @ali-ramadhan and @SandreOuza and in #95). We may also want/need to implement LES closures that add additional 'tracers' (like subgrid scale turbulent kinetic energy) that have their own evolution equations. We'll do the easy 'eddy diffusivity' closures first, but we must keep in mind that including optional evolution equations for closure-specific tracers requires an implementation of an abstraction for equations (as discussed in #110). For now, (and for example) we can implement something like. ```julia; struct TurbulentDiffusivity{P}; u::Function; v::Function; w::Function; c::Function; params::P; end; ```; and add a field to `Model` called `closure` (perhaps). The fields of `TurbulentDiffusivity` are functions that compute stress/flux divergence for momentum and tracers at `i`, `j`, `k` (and we need them to have a common function signature to call in the time-stepping loop). In the case of constant but anisotropic diffusivity (which is currently implemented), for example, we could have. ```julia; @inline function 𝜈∇²u(closure, u, Nx, Ny, Nz, Δx, Δy, Δz, i, j, k); (; closure.params.𝜈h/Δx^2 * δx²_f2c2f(u, Nx, i, j, k); + closure.params.𝜈h/Δy^2 * δy²_f2e2f(u, Ny, i, j, k) ; + closure.params.𝜈v/Δz^2 * δz²_f2e2f(u, Nz, i, j, k); ); end. params = AnisotropicDiffusion(𝜈h, 𝜈v, ...); closure = TurbulentDiffusivity(𝜈∇²u, ..., params); ```. and then, in the time_stepping,. ```julia; ...; # u-momentum equation; @i",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/120
https://github.com/CliMA/Oceananigans.jl/issues/120:3149,Integrability,Interface,Interface,3149,", i, j, k); ); end. params = AnisotropicDiffusion(𝜈h, 𝜈v, ...); closure = TurbulentDiffusivity(𝜈∇²u, ..., params); ```. and then, in the time_stepping,. ```julia; ...; # u-momentum equation; @inbounds Gu[i, j, k] = (-u∇u(u, v, w, Nx, Ny, Nz, Δx, Δy, Δz, i, j, k); + fCor*avg_xy(v, Nx, Ny, i, j, k); - δx_c2f(pHY′, Nx, i, j, k) / (Δx * ρ₀); + closure.u(u, 𝜈h, 𝜈v, Nx, Ny, Nz, Δx, Δy, Δz, i, j, k); + F.u(u, v, w, T, S, Nx, Ny, Nz, Δx, Δy, Δz, i, j, k)); ```. does that make sense? Please criticize. The LES closures will involve much more complicated functions. LES closures like [""Constant Smagorinsky""](https://en.wikipedia.org/wiki/Large_eddy_simulation#Smagorinsky%E2%80%93Lilly_model) and [""Anisotropic Minimum Dissipation"" (AMD)](https://aip.scitation.org/doi/abs/10.1063/1.4928700) fall into the category of ""eddy diffusivity closures"", in that the closure is expressed as a locally evaluated nonlinear eddy viscosity and diffusivity (see also the [dedaLES documentation](https://dedales.readthedocs.io/en/latest/closures/anisotropic_minimum_dissipation.html) for AMD). As discussed long ago with @jm-c, the implementation of an eddy diffusivity closure on a staggered grid requires computing the eddy viscosity at cell centers and on all three faces. In our new notation, these four locations are . * `(Center, Center, Center)` ; * `(Interface, Center, Center)`; * `(Center, Interface, Center)`; * `(Center, Center, Interface)`. In order to calculate the stress divergence for eddy viscosities, therefore, we need the eddy viscosity at `(Center, Center, Center)` . On the other hand, to compute tracer fluxes we need the eddy diffusivity at the three other locations. Something to consider. @jm-c may have more to say on the matter. Looking at the [AMD formulas](https://dedales.readthedocs.io/en/latest/closures/anisotropic_minimum_dissipation.html) it seems that some averaging/interpolation is necessary to calculate the terms that contribute to the eddy viscosity in the correct locations.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/120
https://github.com/CliMA/Oceananigans.jl/issues/120:3190,Integrability,Interface,Interface,3190,", i, j, k); ); end. params = AnisotropicDiffusion(𝜈h, 𝜈v, ...); closure = TurbulentDiffusivity(𝜈∇²u, ..., params); ```. and then, in the time_stepping,. ```julia; ...; # u-momentum equation; @inbounds Gu[i, j, k] = (-u∇u(u, v, w, Nx, Ny, Nz, Δx, Δy, Δz, i, j, k); + fCor*avg_xy(v, Nx, Ny, i, j, k); - δx_c2f(pHY′, Nx, i, j, k) / (Δx * ρ₀); + closure.u(u, 𝜈h, 𝜈v, Nx, Ny, Nz, Δx, Δy, Δz, i, j, k); + F.u(u, v, w, T, S, Nx, Ny, Nz, Δx, Δy, Δz, i, j, k)); ```. does that make sense? Please criticize. The LES closures will involve much more complicated functions. LES closures like [""Constant Smagorinsky""](https://en.wikipedia.org/wiki/Large_eddy_simulation#Smagorinsky%E2%80%93Lilly_model) and [""Anisotropic Minimum Dissipation"" (AMD)](https://aip.scitation.org/doi/abs/10.1063/1.4928700) fall into the category of ""eddy diffusivity closures"", in that the closure is expressed as a locally evaluated nonlinear eddy viscosity and diffusivity (see also the [dedaLES documentation](https://dedales.readthedocs.io/en/latest/closures/anisotropic_minimum_dissipation.html) for AMD). As discussed long ago with @jm-c, the implementation of an eddy diffusivity closure on a staggered grid requires computing the eddy viscosity at cell centers and on all three faces. In our new notation, these four locations are . * `(Center, Center, Center)` ; * `(Interface, Center, Center)`; * `(Center, Interface, Center)`; * `(Center, Center, Interface)`. In order to calculate the stress divergence for eddy viscosities, therefore, we need the eddy viscosity at `(Center, Center, Center)` . On the other hand, to compute tracer fluxes we need the eddy diffusivity at the three other locations. Something to consider. @jm-c may have more to say on the matter. Looking at the [AMD formulas](https://dedales.readthedocs.io/en/latest/closures/anisotropic_minimum_dissipation.html) it seems that some averaging/interpolation is necessary to calculate the terms that contribute to the eddy viscosity in the correct locations.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/120
https://github.com/CliMA/Oceananigans.jl/issues/120:3231,Integrability,Interface,Interface,3231,", i, j, k); ); end. params = AnisotropicDiffusion(𝜈h, 𝜈v, ...); closure = TurbulentDiffusivity(𝜈∇²u, ..., params); ```. and then, in the time_stepping,. ```julia; ...; # u-momentum equation; @inbounds Gu[i, j, k] = (-u∇u(u, v, w, Nx, Ny, Nz, Δx, Δy, Δz, i, j, k); + fCor*avg_xy(v, Nx, Ny, i, j, k); - δx_c2f(pHY′, Nx, i, j, k) / (Δx * ρ₀); + closure.u(u, 𝜈h, 𝜈v, Nx, Ny, Nz, Δx, Δy, Δz, i, j, k); + F.u(u, v, w, T, S, Nx, Ny, Nz, Δx, Δy, Δz, i, j, k)); ```. does that make sense? Please criticize. The LES closures will involve much more complicated functions. LES closures like [""Constant Smagorinsky""](https://en.wikipedia.org/wiki/Large_eddy_simulation#Smagorinsky%E2%80%93Lilly_model) and [""Anisotropic Minimum Dissipation"" (AMD)](https://aip.scitation.org/doi/abs/10.1063/1.4928700) fall into the category of ""eddy diffusivity closures"", in that the closure is expressed as a locally evaluated nonlinear eddy viscosity and diffusivity (see also the [dedaLES documentation](https://dedales.readthedocs.io/en/latest/closures/anisotropic_minimum_dissipation.html) for AMD). As discussed long ago with @jm-c, the implementation of an eddy diffusivity closure on a staggered grid requires computing the eddy viscosity at cell centers and on all three faces. In our new notation, these four locations are . * `(Center, Center, Center)` ; * `(Interface, Center, Center)`; * `(Center, Interface, Center)`; * `(Center, Center, Interface)`. In order to calculate the stress divergence for eddy viscosities, therefore, we need the eddy viscosity at `(Center, Center, Center)` . On the other hand, to compute tracer fluxes we need the eddy diffusivity at the three other locations. Something to consider. @jm-c may have more to say on the matter. Looking at the [AMD formulas](https://dedales.readthedocs.io/en/latest/closures/anisotropic_minimum_dissipation.html) it seems that some averaging/interpolation is necessary to calculate the terms that contribute to the eddy viscosity in the correct locations.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/120
https://github.com/CliMA/Oceananigans.jl/pull/123:28,Testability,test,testing,28,Just some small things from testing free convection with @SandreOuza,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/123
https://github.com/CliMA/Oceananigans.jl/issues/126:50,Testability,test,tests,50,@glwagner and @SandreOuza suggested the following tests. We should implement these using the new boundary conditions API #118. No flux tests:; 1. Set _T(t=0) = 1_ and make sure it stays the same.; 2. Set _T(t=0) = cos(z) + 1/2_ and _∂T/∂z =_ and make sure you get _T(t) -> 1/2_. Diffusion test:; * Set _T(t=0)_ to be a linear temperature profile with slope _c_ and impose that _∂T/∂z = c_ at the top and bottom. Make sure this stably stratified temperature profile is maintained. Boussinesq test:; * Free convection test: set a cooling flux _Q_ at the surface and a stratification of _N²_. Make sure the mixed layer deepens at the correct rate. Related to #81.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/126
https://github.com/CliMA/Oceananigans.jl/issues/126:135,Testability,test,tests,135,@glwagner and @SandreOuza suggested the following tests. We should implement these using the new boundary conditions API #118. No flux tests:; 1. Set _T(t=0) = 1_ and make sure it stays the same.; 2. Set _T(t=0) = cos(z) + 1/2_ and _∂T/∂z =_ and make sure you get _T(t) -> 1/2_. Diffusion test:; * Set _T(t=0)_ to be a linear temperature profile with slope _c_ and impose that _∂T/∂z = c_ at the top and bottom. Make sure this stably stratified temperature profile is maintained. Boussinesq test:; * Free convection test: set a cooling flux _Q_ at the surface and a stratification of _N²_. Make sure the mixed layer deepens at the correct rate. Related to #81.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/126
https://github.com/CliMA/Oceananigans.jl/issues/126:289,Testability,test,test,289,@glwagner and @SandreOuza suggested the following tests. We should implement these using the new boundary conditions API #118. No flux tests:; 1. Set _T(t=0) = 1_ and make sure it stays the same.; 2. Set _T(t=0) = cos(z) + 1/2_ and _∂T/∂z =_ and make sure you get _T(t) -> 1/2_. Diffusion test:; * Set _T(t=0)_ to be a linear temperature profile with slope _c_ and impose that _∂T/∂z = c_ at the top and bottom. Make sure this stably stratified temperature profile is maintained. Boussinesq test:; * Free convection test: set a cooling flux _Q_ at the surface and a stratification of _N²_. Make sure the mixed layer deepens at the correct rate. Related to #81.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/126
https://github.com/CliMA/Oceananigans.jl/issues/126:491,Testability,test,test,491,@glwagner and @SandreOuza suggested the following tests. We should implement these using the new boundary conditions API #118. No flux tests:; 1. Set _T(t=0) = 1_ and make sure it stays the same.; 2. Set _T(t=0) = cos(z) + 1/2_ and _∂T/∂z =_ and make sure you get _T(t) -> 1/2_. Diffusion test:; * Set _T(t=0)_ to be a linear temperature profile with slope _c_ and impose that _∂T/∂z = c_ at the top and bottom. Make sure this stably stratified temperature profile is maintained. Boussinesq test:; * Free convection test: set a cooling flux _Q_ at the surface and a stratification of _N²_. Make sure the mixed layer deepens at the correct rate. Related to #81.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/126
https://github.com/CliMA/Oceananigans.jl/issues/126:516,Testability,test,test,516,@glwagner and @SandreOuza suggested the following tests. We should implement these using the new boundary conditions API #118. No flux tests:; 1. Set _T(t=0) = 1_ and make sure it stays the same.; 2. Set _T(t=0) = cos(z) + 1/2_ and _∂T/∂z =_ and make sure you get _T(t) -> 1/2_. Diffusion test:; * Set _T(t=0)_ to be a linear temperature profile with slope _c_ and impose that _∂T/∂z = c_ at the top and bottom. Make sure this stably stratified temperature profile is maintained. Boussinesq test:; * Free convection test: set a cooling flux _Q_ at the surface and a stratification of _N²_. Make sure the mixed layer deepens at the correct rate. Related to #81.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/126
https://github.com/CliMA/Oceananigans.jl/pull/134:73,Testability,test,tests,73,"Still a work in progress but working on bringing in more unit and system tests. The system tests will include some that we've already implemented (e.g. #126) and some regression tests on simple examples. Also working on comprehensive GPU testing so that we're testing the GPU as much as we're testing the CPU. In particular, the Poisson solver isn't tested on the GPU right now which is kind of scary. **Warning**: GPU testing can take a while as a lot of compilation is involved :( See #66. Resolves #18 ; Resolves #22; Resolves #78",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/134
https://github.com/CliMA/Oceananigans.jl/pull/134:91,Testability,test,tests,91,"Still a work in progress but working on bringing in more unit and system tests. The system tests will include some that we've already implemented (e.g. #126) and some regression tests on simple examples. Also working on comprehensive GPU testing so that we're testing the GPU as much as we're testing the CPU. In particular, the Poisson solver isn't tested on the GPU right now which is kind of scary. **Warning**: GPU testing can take a while as a lot of compilation is involved :( See #66. Resolves #18 ; Resolves #22; Resolves #78",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/134
https://github.com/CliMA/Oceananigans.jl/pull/134:178,Testability,test,tests,178,"Still a work in progress but working on bringing in more unit and system tests. The system tests will include some that we've already implemented (e.g. #126) and some regression tests on simple examples. Also working on comprehensive GPU testing so that we're testing the GPU as much as we're testing the CPU. In particular, the Poisson solver isn't tested on the GPU right now which is kind of scary. **Warning**: GPU testing can take a while as a lot of compilation is involved :( See #66. Resolves #18 ; Resolves #22; Resolves #78",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/134
https://github.com/CliMA/Oceananigans.jl/pull/134:238,Testability,test,testing,238,"Still a work in progress but working on bringing in more unit and system tests. The system tests will include some that we've already implemented (e.g. #126) and some regression tests on simple examples. Also working on comprehensive GPU testing so that we're testing the GPU as much as we're testing the CPU. In particular, the Poisson solver isn't tested on the GPU right now which is kind of scary. **Warning**: GPU testing can take a while as a lot of compilation is involved :( See #66. Resolves #18 ; Resolves #22; Resolves #78",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/134
https://github.com/CliMA/Oceananigans.jl/pull/134:260,Testability,test,testing,260,"Still a work in progress but working on bringing in more unit and system tests. The system tests will include some that we've already implemented (e.g. #126) and some regression tests on simple examples. Also working on comprehensive GPU testing so that we're testing the GPU as much as we're testing the CPU. In particular, the Poisson solver isn't tested on the GPU right now which is kind of scary. **Warning**: GPU testing can take a while as a lot of compilation is involved :( See #66. Resolves #18 ; Resolves #22; Resolves #78",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/134
https://github.com/CliMA/Oceananigans.jl/pull/134:293,Testability,test,testing,293,"Still a work in progress but working on bringing in more unit and system tests. The system tests will include some that we've already implemented (e.g. #126) and some regression tests on simple examples. Also working on comprehensive GPU testing so that we're testing the GPU as much as we're testing the CPU. In particular, the Poisson solver isn't tested on the GPU right now which is kind of scary. **Warning**: GPU testing can take a while as a lot of compilation is involved :( See #66. Resolves #18 ; Resolves #22; Resolves #78",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/134
https://github.com/CliMA/Oceananigans.jl/pull/134:350,Testability,test,tested,350,"Still a work in progress but working on bringing in more unit and system tests. The system tests will include some that we've already implemented (e.g. #126) and some regression tests on simple examples. Also working on comprehensive GPU testing so that we're testing the GPU as much as we're testing the CPU. In particular, the Poisson solver isn't tested on the GPU right now which is kind of scary. **Warning**: GPU testing can take a while as a lot of compilation is involved :( See #66. Resolves #18 ; Resolves #22; Resolves #78",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/134
https://github.com/CliMA/Oceananigans.jl/pull/134:419,Testability,test,testing,419,"Still a work in progress but working on bringing in more unit and system tests. The system tests will include some that we've already implemented (e.g. #126) and some regression tests on simple examples. Also working on comprehensive GPU testing so that we're testing the GPU as much as we're testing the CPU. In particular, the Poisson solver isn't tested on the GPU right now which is kind of scary. **Warning**: GPU testing can take a while as a lot of compilation is involved :( See #66. Resolves #18 ; Resolves #22; Resolves #78",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/134
https://github.com/CliMA/Oceananigans.jl/pull/134:187,Usability,simpl,simple,187,"Still a work in progress but working on bringing in more unit and system tests. The system tests will include some that we've already implemented (e.g. #126) and some regression tests on simple examples. Also working on comprehensive GPU testing so that we're testing the GPU as much as we're testing the CPU. In particular, the Poisson solver isn't tested on the GPU right now which is kind of scary. **Warning**: GPU testing can take a while as a lot of compilation is involved :( See #66. Resolves #18 ; Resolves #22; Resolves #78",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/134
https://github.com/CliMA/Oceananigans.jl/pull/135:0,Deployability,Update,Updated,0,Updated the matplotlib scripts that I used to produce contourf3d and pcolormesh3d plots using the NetCDF output from Oceananigans. They're now in two separate files with a more general function call for re-usability. Example output: the 3D deep convection figure in the README. @SandreOuza we can use these to make 3D plots of free convection. But a NetCDF viewer like Panoply might be better for quick inspection.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/135
https://github.com/CliMA/Oceananigans.jl/pull/135:206,Usability,usab,usability,206,Updated the matplotlib scripts that I used to produce contourf3d and pcolormesh3d plots using the NetCDF output from Oceananigans. They're now in two separate files with a more general function call for re-usability. Example output: the 3D deep convection figure in the README. @SandreOuza we can use these to make 3D plots of free convection. But a NetCDF viewer like Panoply might be better for quick inspection.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/135
https://github.com/CliMA/Oceananigans.jl/issues/136:189,Energy Efficiency,energy,energy,189,"We should incorporate the following validation tests which we can also use for performance benchmarking.; - [ ] Free convection (check heat budget, mixed layer depth, and turbulent kinetic energy); - [ ] Rayleigh–Bénard convection (compare Nusselt and Péclet numbers); - [x] Deep convection (regression test); - [x] Rising thermal bubble?; - [ ] Stress-driven flow (not clear which experiment we run)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/136
https://github.com/CliMA/Oceananigans.jl/issues/136:79,Performance,perform,performance,79,"We should incorporate the following validation tests which we can also use for performance benchmarking.; - [ ] Free convection (check heat budget, mixed layer depth, and turbulent kinetic energy); - [ ] Rayleigh–Bénard convection (compare Nusselt and Péclet numbers); - [x] Deep convection (regression test); - [x] Rising thermal bubble?; - [ ] Stress-driven flow (not clear which experiment we run)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/136
https://github.com/CliMA/Oceananigans.jl/issues/136:36,Security,validat,validation,36,"We should incorporate the following validation tests which we can also use for performance benchmarking.; - [ ] Free convection (check heat budget, mixed layer depth, and turbulent kinetic energy); - [ ] Rayleigh–Bénard convection (compare Nusselt and Péclet numbers); - [x] Deep convection (regression test); - [x] Rising thermal bubble?; - [ ] Stress-driven flow (not clear which experiment we run)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/136
https://github.com/CliMA/Oceananigans.jl/issues/136:47,Testability,test,tests,47,"We should incorporate the following validation tests which we can also use for performance benchmarking.; - [ ] Free convection (check heat budget, mixed layer depth, and turbulent kinetic energy); - [ ] Rayleigh–Bénard convection (compare Nusselt and Péclet numbers); - [x] Deep convection (regression test); - [x] Rising thermal bubble?; - [ ] Stress-driven flow (not clear which experiment we run)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/136
https://github.com/CliMA/Oceananigans.jl/issues/136:91,Testability,benchmark,benchmarking,91,"We should incorporate the following validation tests which we can also use for performance benchmarking.; - [ ] Free convection (check heat budget, mixed layer depth, and turbulent kinetic energy); - [ ] Rayleigh–Bénard convection (compare Nusselt and Péclet numbers); - [x] Deep convection (regression test); - [x] Rising thermal bubble?; - [ ] Stress-driven flow (not clear which experiment we run)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/136
https://github.com/CliMA/Oceananigans.jl/issues/136:303,Testability,test,test,303,"We should incorporate the following validation tests which we can also use for performance benchmarking.; - [ ] Free convection (check heat budget, mixed layer depth, and turbulent kinetic energy); - [ ] Rayleigh–Bénard convection (compare Nusselt and Péclet numbers); - [x] Deep convection (regression test); - [x] Rising thermal bubble?; - [ ] Stress-driven flow (not clear which experiment we run)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/136
https://github.com/CliMA/Oceananigans.jl/issues/136:370,Usability,clear,clear,370,"We should incorporate the following validation tests which we can also use for performance benchmarking.; - [ ] Free convection (check heat budget, mixed layer depth, and turbulent kinetic energy); - [ ] Rayleigh–Bénard convection (compare Nusselt and Péclet numbers); - [x] Deep convection (regression test); - [x] Rising thermal bubble?; - [ ] Stress-driven flow (not clear which experiment we run)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/136
https://github.com/CliMA/Oceananigans.jl/issues/138:31,Testability,test,tests,31,Travis CI does not run the GPU tests so the code coverage statistics is submits to Codecov and Coveralls is not accurate. We should probably be submitting code coverage statistics from GitLab CI which does run GPU tests.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/138
https://github.com/CliMA/Oceananigans.jl/issues/138:214,Testability,test,tests,214,Travis CI does not run the GPU tests so the code coverage statistics is submits to Codecov and Coveralls is not accurate. We should probably be submitting code coverage statistics from GitLab CI which does run GPU tests.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/138
https://github.com/CliMA/Oceananigans.jl/issues/139:2435,Availability,avail,available,2435,"ee #82). We will also need to run the test suite on the following architectures in the future:; 1. single-core CPU (Travis CI and Appveyor are fine here); 2. single GPU (JuliaGPU's GitLab CI pipeline works great here); 3. multi-core single CPU (MPI) (paid CI plans will probably work here); 4. multiple distributed CPU nodes (MPI) (no idea where to run this); 5. multiple GPUs (MPI) (no idea where to run this). Some ideas for things to do that will help:; 1. Explicitly split the tests up into 2-3 suites; 1.1. **Unit tests**: should run in a few minutes so we can run them during development and on every commit/PR/etc.; 1.2. **Integration tests**: can take a while to run so we don't want to run these locally all the time but probably on every PR. Shouldn't take much more than 1 hour to run so we don't have to wait forever to merge PR's.; 1.3. **Model verification tests** (also called _end-to-end_ tests): will probably take a long time to run. Maybe run this once a day? Or manually if there's a PR that changes core functionality.; 2. Run the tests in parallel. I think the main Julia repo does this. We might have to roll our own parallel solution (see [this thread](https://discourse.julialang.org/t/run-pkg-test-with-several-processors/6917)). This would also require expensive paid CI plans (but very much worth it in my opinion).; 3. Thinking long-term, if we had a multi-CPU multi-GPU machine available we could probably roll our own CI solution for these distributed architectures. Ideally we'd want to see if we can get this through a service although it would probably cost $$$$$. cc @christophernhill @jm-c @glwagner: I know we all care about testing. cc @charleskawczynski @simonbyrne: Just wondering if this is a problem you guys are anticipating for CliMA.jl? We might be able to share some common solutions?. Resources:; * [Nvidia slides on building a GPU-focused CI solution](http://on-demand.gputechconf.com/gtc/2018/presentation/s8563-building-a-gpu-focused-ci-solution.pdf)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/139
https://github.com/CliMA/Oceananigans.jl/issues/139:51,Deployability,integrat,integration,51,"Right now all our tests are lumped into one (unit, integration, and model verification tests) and we run the tests on the CPU and the GPU (most tests are shared). This is not a high priority item right now, but it's already annoying that I have to wait several minutes for the GPU tests to run as I'm debugging. So just starting up a discussion around this topic. I can see us hitting some limitations soon:; 1. A comprehensive test suite will take time to run, long enough that we cannot keep running it during development and debugging.; 2. Comprehensive model verification tests (or system tests?) will take even longer to run and are absolutely crucial (see #81 #136), so this problem will get worse in the future.; 3. GPU tests take a while to run because of long compile time (#66) and they run on top of all the CPU tests. In general, setting up GPU models take more time so it's not ideal that we're setting up tons of tiny models for testing. Testing GPU stuff may also involve some expensive scalar CUDA operations (see #82). We will also need to run the test suite on the following architectures in the future:; 1. single-core CPU (Travis CI and Appveyor are fine here); 2. single GPU (JuliaGPU's GitLab CI pipeline works great here); 3. multi-core single CPU (MPI) (paid CI plans will probably work here); 4. multiple distributed CPU nodes (MPI) (no idea where to run this); 5. multiple GPUs (MPI) (no idea where to run this). Some ideas for things to do that will help:; 1. Explicitly split the tests up into 2-3 suites; 1.1. **Unit tests**: should run in a few minutes so we can run them during development and on every commit/PR/etc.; 1.2. **Integration tests**: can take a while to run so we don't want to run these locally all the time but probably on every PR. Shouldn't take much more than 1 hour to run so we don't have to wait forever to merge PR's.; 1.3. **Model verification tests** (also called _end-to-end_ tests): will probably take a long time to run. Maybe run this once a ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/139
https://github.com/CliMA/Oceananigans.jl/issues/139:1218,Deployability,pipeline,pipeline,1218,"already annoying that I have to wait several minutes for the GPU tests to run as I'm debugging. So just starting up a discussion around this topic. I can see us hitting some limitations soon:; 1. A comprehensive test suite will take time to run, long enough that we cannot keep running it during development and debugging.; 2. Comprehensive model verification tests (or system tests?) will take even longer to run and are absolutely crucial (see #81 #136), so this problem will get worse in the future.; 3. GPU tests take a while to run because of long compile time (#66) and they run on top of all the CPU tests. In general, setting up GPU models take more time so it's not ideal that we're setting up tons of tiny models for testing. Testing GPU stuff may also involve some expensive scalar CUDA operations (see #82). We will also need to run the test suite on the following architectures in the future:; 1. single-core CPU (Travis CI and Appveyor are fine here); 2. single GPU (JuliaGPU's GitLab CI pipeline works great here); 3. multi-core single CPU (MPI) (paid CI plans will probably work here); 4. multiple distributed CPU nodes (MPI) (no idea where to run this); 5. multiple GPUs (MPI) (no idea where to run this). Some ideas for things to do that will help:; 1. Explicitly split the tests up into 2-3 suites; 1.1. **Unit tests**: should run in a few minutes so we can run them during development and on every commit/PR/etc.; 1.2. **Integration tests**: can take a while to run so we don't want to run these locally all the time but probably on every PR. Shouldn't take much more than 1 hour to run so we don't have to wait forever to merge PR's.; 1.3. **Model verification tests** (also called _end-to-end_ tests): will probably take a long time to run. Maybe run this once a day? Or manually if there's a PR that changes core functionality.; 2. Run the tests in parallel. I think the main Julia repo does this. We might have to roll our own parallel solution (see [this thread](https://disc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/139
https://github.com/CliMA/Oceananigans.jl/issues/139:1657,Deployability,Integrat,Integration,1657,"e.; 3. GPU tests take a while to run because of long compile time (#66) and they run on top of all the CPU tests. In general, setting up GPU models take more time so it's not ideal that we're setting up tons of tiny models for testing. Testing GPU stuff may also involve some expensive scalar CUDA operations (see #82). We will also need to run the test suite on the following architectures in the future:; 1. single-core CPU (Travis CI and Appveyor are fine here); 2. single GPU (JuliaGPU's GitLab CI pipeline works great here); 3. multi-core single CPU (MPI) (paid CI plans will probably work here); 4. multiple distributed CPU nodes (MPI) (no idea where to run this); 5. multiple GPUs (MPI) (no idea where to run this). Some ideas for things to do that will help:; 1. Explicitly split the tests up into 2-3 suites; 1.1. **Unit tests**: should run in a few minutes so we can run them during development and on every commit/PR/etc.; 1.2. **Integration tests**: can take a while to run so we don't want to run these locally all the time but probably on every PR. Shouldn't take much more than 1 hour to run so we don't have to wait forever to merge PR's.; 1.3. **Model verification tests** (also called _end-to-end_ tests): will probably take a long time to run. Maybe run this once a day? Or manually if there's a PR that changes core functionality.; 2. Run the tests in parallel. I think the main Julia repo does this. We might have to roll our own parallel solution (see [this thread](https://discourse.julialang.org/t/run-pkg-test-with-several-processors/6917)). This would also require expensive paid CI plans (but very much worth it in my opinion).; 3. Thinking long-term, if we had a multi-CPU multi-GPU machine available we could probably roll our own CI solution for these distributed architectures. Ideally we'd want to see if we can get this through a service although it would probably cost $$$$$. cc @christophernhill @jm-c @glwagner: I know we all care about testing. cc @charleskawczyn",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/139
https://github.com/CliMA/Oceananigans.jl/issues/139:51,Integrability,integrat,integration,51,"Right now all our tests are lumped into one (unit, integration, and model verification tests) and we run the tests on the CPU and the GPU (most tests are shared). This is not a high priority item right now, but it's already annoying that I have to wait several minutes for the GPU tests to run as I'm debugging. So just starting up a discussion around this topic. I can see us hitting some limitations soon:; 1. A comprehensive test suite will take time to run, long enough that we cannot keep running it during development and debugging.; 2. Comprehensive model verification tests (or system tests?) will take even longer to run and are absolutely crucial (see #81 #136), so this problem will get worse in the future.; 3. GPU tests take a while to run because of long compile time (#66) and they run on top of all the CPU tests. In general, setting up GPU models take more time so it's not ideal that we're setting up tons of tiny models for testing. Testing GPU stuff may also involve some expensive scalar CUDA operations (see #82). We will also need to run the test suite on the following architectures in the future:; 1. single-core CPU (Travis CI and Appveyor are fine here); 2. single GPU (JuliaGPU's GitLab CI pipeline works great here); 3. multi-core single CPU (MPI) (paid CI plans will probably work here); 4. multiple distributed CPU nodes (MPI) (no idea where to run this); 5. multiple GPUs (MPI) (no idea where to run this). Some ideas for things to do that will help:; 1. Explicitly split the tests up into 2-3 suites; 1.1. **Unit tests**: should run in a few minutes so we can run them during development and on every commit/PR/etc.; 1.2. **Integration tests**: can take a while to run so we don't want to run these locally all the time but probably on every PR. Shouldn't take much more than 1 hour to run so we don't have to wait forever to merge PR's.; 1.3. **Model verification tests** (also called _end-to-end_ tests): will probably take a long time to run. Maybe run this once a ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/139
https://github.com/CliMA/Oceananigans.jl/issues/139:1657,Integrability,Integrat,Integration,1657,"e.; 3. GPU tests take a while to run because of long compile time (#66) and they run on top of all the CPU tests. In general, setting up GPU models take more time so it's not ideal that we're setting up tons of tiny models for testing. Testing GPU stuff may also involve some expensive scalar CUDA operations (see #82). We will also need to run the test suite on the following architectures in the future:; 1. single-core CPU (Travis CI and Appveyor are fine here); 2. single GPU (JuliaGPU's GitLab CI pipeline works great here); 3. multi-core single CPU (MPI) (paid CI plans will probably work here); 4. multiple distributed CPU nodes (MPI) (no idea where to run this); 5. multiple GPUs (MPI) (no idea where to run this). Some ideas for things to do that will help:; 1. Explicitly split the tests up into 2-3 suites; 1.1. **Unit tests**: should run in a few minutes so we can run them during development and on every commit/PR/etc.; 1.2. **Integration tests**: can take a while to run so we don't want to run these locally all the time but probably on every PR. Shouldn't take much more than 1 hour to run so we don't have to wait forever to merge PR's.; 1.3. **Model verification tests** (also called _end-to-end_ tests): will probably take a long time to run. Maybe run this once a day? Or manually if there's a PR that changes core functionality.; 2. Run the tests in parallel. I think the main Julia repo does this. We might have to roll our own parallel solution (see [this thread](https://discourse.julialang.org/t/run-pkg-test-with-several-processors/6917)). This would also require expensive paid CI plans (but very much worth it in my opinion).; 3. Thinking long-term, if we had a multi-CPU multi-GPU machine available we could probably roll our own CI solution for these distributed architectures. Ideally we'd want to see if we can get this through a service although it would probably cost $$$$$. cc @christophernhill @jm-c @glwagner: I know we all care about testing. cc @charleskawczyn",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/139
https://github.com/CliMA/Oceananigans.jl/issues/139:18,Testability,test,tests,18,"Right now all our tests are lumped into one (unit, integration, and model verification tests) and we run the tests on the CPU and the GPU (most tests are shared). This is not a high priority item right now, but it's already annoying that I have to wait several minutes for the GPU tests to run as I'm debugging. So just starting up a discussion around this topic. I can see us hitting some limitations soon:; 1. A comprehensive test suite will take time to run, long enough that we cannot keep running it during development and debugging.; 2. Comprehensive model verification tests (or system tests?) will take even longer to run and are absolutely crucial (see #81 #136), so this problem will get worse in the future.; 3. GPU tests take a while to run because of long compile time (#66) and they run on top of all the CPU tests. In general, setting up GPU models take more time so it's not ideal that we're setting up tons of tiny models for testing. Testing GPU stuff may also involve some expensive scalar CUDA operations (see #82). We will also need to run the test suite on the following architectures in the future:; 1. single-core CPU (Travis CI and Appveyor are fine here); 2. single GPU (JuliaGPU's GitLab CI pipeline works great here); 3. multi-core single CPU (MPI) (paid CI plans will probably work here); 4. multiple distributed CPU nodes (MPI) (no idea where to run this); 5. multiple GPUs (MPI) (no idea where to run this). Some ideas for things to do that will help:; 1. Explicitly split the tests up into 2-3 suites; 1.1. **Unit tests**: should run in a few minutes so we can run them during development and on every commit/PR/etc.; 1.2. **Integration tests**: can take a while to run so we don't want to run these locally all the time but probably on every PR. Shouldn't take much more than 1 hour to run so we don't have to wait forever to merge PR's.; 1.3. **Model verification tests** (also called _end-to-end_ tests): will probably take a long time to run. Maybe run this once a ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/139
https://github.com/CliMA/Oceananigans.jl/issues/139:87,Testability,test,tests,87,"Right now all our tests are lumped into one (unit, integration, and model verification tests) and we run the tests on the CPU and the GPU (most tests are shared). This is not a high priority item right now, but it's already annoying that I have to wait several minutes for the GPU tests to run as I'm debugging. So just starting up a discussion around this topic. I can see us hitting some limitations soon:; 1. A comprehensive test suite will take time to run, long enough that we cannot keep running it during development and debugging.; 2. Comprehensive model verification tests (or system tests?) will take even longer to run and are absolutely crucial (see #81 #136), so this problem will get worse in the future.; 3. GPU tests take a while to run because of long compile time (#66) and they run on top of all the CPU tests. In general, setting up GPU models take more time so it's not ideal that we're setting up tons of tiny models for testing. Testing GPU stuff may also involve some expensive scalar CUDA operations (see #82). We will also need to run the test suite on the following architectures in the future:; 1. single-core CPU (Travis CI and Appveyor are fine here); 2. single GPU (JuliaGPU's GitLab CI pipeline works great here); 3. multi-core single CPU (MPI) (paid CI plans will probably work here); 4. multiple distributed CPU nodes (MPI) (no idea where to run this); 5. multiple GPUs (MPI) (no idea where to run this). Some ideas for things to do that will help:; 1. Explicitly split the tests up into 2-3 suites; 1.1. **Unit tests**: should run in a few minutes so we can run them during development and on every commit/PR/etc.; 1.2. **Integration tests**: can take a while to run so we don't want to run these locally all the time but probably on every PR. Shouldn't take much more than 1 hour to run so we don't have to wait forever to merge PR's.; 1.3. **Model verification tests** (also called _end-to-end_ tests): will probably take a long time to run. Maybe run this once a ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/139
https://github.com/CliMA/Oceananigans.jl/issues/139:109,Testability,test,tests,109,"Right now all our tests are lumped into one (unit, integration, and model verification tests) and we run the tests on the CPU and the GPU (most tests are shared). This is not a high priority item right now, but it's already annoying that I have to wait several minutes for the GPU tests to run as I'm debugging. So just starting up a discussion around this topic. I can see us hitting some limitations soon:; 1. A comprehensive test suite will take time to run, long enough that we cannot keep running it during development and debugging.; 2. Comprehensive model verification tests (or system tests?) will take even longer to run and are absolutely crucial (see #81 #136), so this problem will get worse in the future.; 3. GPU tests take a while to run because of long compile time (#66) and they run on top of all the CPU tests. In general, setting up GPU models take more time so it's not ideal that we're setting up tons of tiny models for testing. Testing GPU stuff may also involve some expensive scalar CUDA operations (see #82). We will also need to run the test suite on the following architectures in the future:; 1. single-core CPU (Travis CI and Appveyor are fine here); 2. single GPU (JuliaGPU's GitLab CI pipeline works great here); 3. multi-core single CPU (MPI) (paid CI plans will probably work here); 4. multiple distributed CPU nodes (MPI) (no idea where to run this); 5. multiple GPUs (MPI) (no idea where to run this). Some ideas for things to do that will help:; 1. Explicitly split the tests up into 2-3 suites; 1.1. **Unit tests**: should run in a few minutes so we can run them during development and on every commit/PR/etc.; 1.2. **Integration tests**: can take a while to run so we don't want to run these locally all the time but probably on every PR. Shouldn't take much more than 1 hour to run so we don't have to wait forever to merge PR's.; 1.3. **Model verification tests** (also called _end-to-end_ tests): will probably take a long time to run. Maybe run this once a ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/139
https://github.com/CliMA/Oceananigans.jl/issues/139:144,Testability,test,tests,144,"Right now all our tests are lumped into one (unit, integration, and model verification tests) and we run the tests on the CPU and the GPU (most tests are shared). This is not a high priority item right now, but it's already annoying that I have to wait several minutes for the GPU tests to run as I'm debugging. So just starting up a discussion around this topic. I can see us hitting some limitations soon:; 1. A comprehensive test suite will take time to run, long enough that we cannot keep running it during development and debugging.; 2. Comprehensive model verification tests (or system tests?) will take even longer to run and are absolutely crucial (see #81 #136), so this problem will get worse in the future.; 3. GPU tests take a while to run because of long compile time (#66) and they run on top of all the CPU tests. In general, setting up GPU models take more time so it's not ideal that we're setting up tons of tiny models for testing. Testing GPU stuff may also involve some expensive scalar CUDA operations (see #82). We will also need to run the test suite on the following architectures in the future:; 1. single-core CPU (Travis CI and Appveyor are fine here); 2. single GPU (JuliaGPU's GitLab CI pipeline works great here); 3. multi-core single CPU (MPI) (paid CI plans will probably work here); 4. multiple distributed CPU nodes (MPI) (no idea where to run this); 5. multiple GPUs (MPI) (no idea where to run this). Some ideas for things to do that will help:; 1. Explicitly split the tests up into 2-3 suites; 1.1. **Unit tests**: should run in a few minutes so we can run them during development and on every commit/PR/etc.; 1.2. **Integration tests**: can take a while to run so we don't want to run these locally all the time but probably on every PR. Shouldn't take much more than 1 hour to run so we don't have to wait forever to merge PR's.; 1.3. **Model verification tests** (also called _end-to-end_ tests): will probably take a long time to run. Maybe run this once a ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/139
https://github.com/CliMA/Oceananigans.jl/issues/139:281,Testability,test,tests,281,"Right now all our tests are lumped into one (unit, integration, and model verification tests) and we run the tests on the CPU and the GPU (most tests are shared). This is not a high priority item right now, but it's already annoying that I have to wait several minutes for the GPU tests to run as I'm debugging. So just starting up a discussion around this topic. I can see us hitting some limitations soon:; 1. A comprehensive test suite will take time to run, long enough that we cannot keep running it during development and debugging.; 2. Comprehensive model verification tests (or system tests?) will take even longer to run and are absolutely crucial (see #81 #136), so this problem will get worse in the future.; 3. GPU tests take a while to run because of long compile time (#66) and they run on top of all the CPU tests. In general, setting up GPU models take more time so it's not ideal that we're setting up tons of tiny models for testing. Testing GPU stuff may also involve some expensive scalar CUDA operations (see #82). We will also need to run the test suite on the following architectures in the future:; 1. single-core CPU (Travis CI and Appveyor are fine here); 2. single GPU (JuliaGPU's GitLab CI pipeline works great here); 3. multi-core single CPU (MPI) (paid CI plans will probably work here); 4. multiple distributed CPU nodes (MPI) (no idea where to run this); 5. multiple GPUs (MPI) (no idea where to run this). Some ideas for things to do that will help:; 1. Explicitly split the tests up into 2-3 suites; 1.1. **Unit tests**: should run in a few minutes so we can run them during development and on every commit/PR/etc.; 1.2. **Integration tests**: can take a while to run so we don't want to run these locally all the time but probably on every PR. Shouldn't take much more than 1 hour to run so we don't have to wait forever to merge PR's.; 1.3. **Model verification tests** (also called _end-to-end_ tests): will probably take a long time to run. Maybe run this once a ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/139
https://github.com/CliMA/Oceananigans.jl/issues/139:428,Testability,test,test,428,"Right now all our tests are lumped into one (unit, integration, and model verification tests) and we run the tests on the CPU and the GPU (most tests are shared). This is not a high priority item right now, but it's already annoying that I have to wait several minutes for the GPU tests to run as I'm debugging. So just starting up a discussion around this topic. I can see us hitting some limitations soon:; 1. A comprehensive test suite will take time to run, long enough that we cannot keep running it during development and debugging.; 2. Comprehensive model verification tests (or system tests?) will take even longer to run and are absolutely crucial (see #81 #136), so this problem will get worse in the future.; 3. GPU tests take a while to run because of long compile time (#66) and they run on top of all the CPU tests. In general, setting up GPU models take more time so it's not ideal that we're setting up tons of tiny models for testing. Testing GPU stuff may also involve some expensive scalar CUDA operations (see #82). We will also need to run the test suite on the following architectures in the future:; 1. single-core CPU (Travis CI and Appveyor are fine here); 2. single GPU (JuliaGPU's GitLab CI pipeline works great here); 3. multi-core single CPU (MPI) (paid CI plans will probably work here); 4. multiple distributed CPU nodes (MPI) (no idea where to run this); 5. multiple GPUs (MPI) (no idea where to run this). Some ideas for things to do that will help:; 1. Explicitly split the tests up into 2-3 suites; 1.1. **Unit tests**: should run in a few minutes so we can run them during development and on every commit/PR/etc.; 1.2. **Integration tests**: can take a while to run so we don't want to run these locally all the time but probably on every PR. Shouldn't take much more than 1 hour to run so we don't have to wait forever to merge PR's.; 1.3. **Model verification tests** (also called _end-to-end_ tests): will probably take a long time to run. Maybe run this once a ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/139
https://github.com/CliMA/Oceananigans.jl/issues/139:576,Testability,test,tests,576,"Right now all our tests are lumped into one (unit, integration, and model verification tests) and we run the tests on the CPU and the GPU (most tests are shared). This is not a high priority item right now, but it's already annoying that I have to wait several minutes for the GPU tests to run as I'm debugging. So just starting up a discussion around this topic. I can see us hitting some limitations soon:; 1. A comprehensive test suite will take time to run, long enough that we cannot keep running it during development and debugging.; 2. Comprehensive model verification tests (or system tests?) will take even longer to run and are absolutely crucial (see #81 #136), so this problem will get worse in the future.; 3. GPU tests take a while to run because of long compile time (#66) and they run on top of all the CPU tests. In general, setting up GPU models take more time so it's not ideal that we're setting up tons of tiny models for testing. Testing GPU stuff may also involve some expensive scalar CUDA operations (see #82). We will also need to run the test suite on the following architectures in the future:; 1. single-core CPU (Travis CI and Appveyor are fine here); 2. single GPU (JuliaGPU's GitLab CI pipeline works great here); 3. multi-core single CPU (MPI) (paid CI plans will probably work here); 4. multiple distributed CPU nodes (MPI) (no idea where to run this); 5. multiple GPUs (MPI) (no idea where to run this). Some ideas for things to do that will help:; 1. Explicitly split the tests up into 2-3 suites; 1.1. **Unit tests**: should run in a few minutes so we can run them during development and on every commit/PR/etc.; 1.2. **Integration tests**: can take a while to run so we don't want to run these locally all the time but probably on every PR. Shouldn't take much more than 1 hour to run so we don't have to wait forever to merge PR's.; 1.3. **Model verification tests** (also called _end-to-end_ tests): will probably take a long time to run. Maybe run this once a ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/139
https://github.com/CliMA/Oceananigans.jl/issues/139:593,Testability,test,tests,593,"Right now all our tests are lumped into one (unit, integration, and model verification tests) and we run the tests on the CPU and the GPU (most tests are shared). This is not a high priority item right now, but it's already annoying that I have to wait several minutes for the GPU tests to run as I'm debugging. So just starting up a discussion around this topic. I can see us hitting some limitations soon:; 1. A comprehensive test suite will take time to run, long enough that we cannot keep running it during development and debugging.; 2. Comprehensive model verification tests (or system tests?) will take even longer to run and are absolutely crucial (see #81 #136), so this problem will get worse in the future.; 3. GPU tests take a while to run because of long compile time (#66) and they run on top of all the CPU tests. In general, setting up GPU models take more time so it's not ideal that we're setting up tons of tiny models for testing. Testing GPU stuff may also involve some expensive scalar CUDA operations (see #82). We will also need to run the test suite on the following architectures in the future:; 1. single-core CPU (Travis CI and Appveyor are fine here); 2. single GPU (JuliaGPU's GitLab CI pipeline works great here); 3. multi-core single CPU (MPI) (paid CI plans will probably work here); 4. multiple distributed CPU nodes (MPI) (no idea where to run this); 5. multiple GPUs (MPI) (no idea where to run this). Some ideas for things to do that will help:; 1. Explicitly split the tests up into 2-3 suites; 1.1. **Unit tests**: should run in a few minutes so we can run them during development and on every commit/PR/etc.; 1.2. **Integration tests**: can take a while to run so we don't want to run these locally all the time but probably on every PR. Shouldn't take much more than 1 hour to run so we don't have to wait forever to merge PR's.; 1.3. **Model verification tests** (also called _end-to-end_ tests): will probably take a long time to run. Maybe run this once a ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/139
https://github.com/CliMA/Oceananigans.jl/issues/139:727,Testability,test,tests,727,"Right now all our tests are lumped into one (unit, integration, and model verification tests) and we run the tests on the CPU and the GPU (most tests are shared). This is not a high priority item right now, but it's already annoying that I have to wait several minutes for the GPU tests to run as I'm debugging. So just starting up a discussion around this topic. I can see us hitting some limitations soon:; 1. A comprehensive test suite will take time to run, long enough that we cannot keep running it during development and debugging.; 2. Comprehensive model verification tests (or system tests?) will take even longer to run and are absolutely crucial (see #81 #136), so this problem will get worse in the future.; 3. GPU tests take a while to run because of long compile time (#66) and they run on top of all the CPU tests. In general, setting up GPU models take more time so it's not ideal that we're setting up tons of tiny models for testing. Testing GPU stuff may also involve some expensive scalar CUDA operations (see #82). We will also need to run the test suite on the following architectures in the future:; 1. single-core CPU (Travis CI and Appveyor are fine here); 2. single GPU (JuliaGPU's GitLab CI pipeline works great here); 3. multi-core single CPU (MPI) (paid CI plans will probably work here); 4. multiple distributed CPU nodes (MPI) (no idea where to run this); 5. multiple GPUs (MPI) (no idea where to run this). Some ideas for things to do that will help:; 1. Explicitly split the tests up into 2-3 suites; 1.1. **Unit tests**: should run in a few minutes so we can run them during development and on every commit/PR/etc.; 1.2. **Integration tests**: can take a while to run so we don't want to run these locally all the time but probably on every PR. Shouldn't take much more than 1 hour to run so we don't have to wait forever to merge PR's.; 1.3. **Model verification tests** (also called _end-to-end_ tests): will probably take a long time to run. Maybe run this once a ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/139
https://github.com/CliMA/Oceananigans.jl/issues/139:823,Testability,test,tests,823,"Right now all our tests are lumped into one (unit, integration, and model verification tests) and we run the tests on the CPU and the GPU (most tests are shared). This is not a high priority item right now, but it's already annoying that I have to wait several minutes for the GPU tests to run as I'm debugging. So just starting up a discussion around this topic. I can see us hitting some limitations soon:; 1. A comprehensive test suite will take time to run, long enough that we cannot keep running it during development and debugging.; 2. Comprehensive model verification tests (or system tests?) will take even longer to run and are absolutely crucial (see #81 #136), so this problem will get worse in the future.; 3. GPU tests take a while to run because of long compile time (#66) and they run on top of all the CPU tests. In general, setting up GPU models take more time so it's not ideal that we're setting up tons of tiny models for testing. Testing GPU stuff may also involve some expensive scalar CUDA operations (see #82). We will also need to run the test suite on the following architectures in the future:; 1. single-core CPU (Travis CI and Appveyor are fine here); 2. single GPU (JuliaGPU's GitLab CI pipeline works great here); 3. multi-core single CPU (MPI) (paid CI plans will probably work here); 4. multiple distributed CPU nodes (MPI) (no idea where to run this); 5. multiple GPUs (MPI) (no idea where to run this). Some ideas for things to do that will help:; 1. Explicitly split the tests up into 2-3 suites; 1.1. **Unit tests**: should run in a few minutes so we can run them during development and on every commit/PR/etc.; 1.2. **Integration tests**: can take a while to run so we don't want to run these locally all the time but probably on every PR. Shouldn't take much more than 1 hour to run so we don't have to wait forever to merge PR's.; 1.3. **Model verification tests** (also called _end-to-end_ tests): will probably take a long time to run. Maybe run this once a ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/139
https://github.com/CliMA/Oceananigans.jl/issues/139:943,Testability,test,testing,943,"Right now all our tests are lumped into one (unit, integration, and model verification tests) and we run the tests on the CPU and the GPU (most tests are shared). This is not a high priority item right now, but it's already annoying that I have to wait several minutes for the GPU tests to run as I'm debugging. So just starting up a discussion around this topic. I can see us hitting some limitations soon:; 1. A comprehensive test suite will take time to run, long enough that we cannot keep running it during development and debugging.; 2. Comprehensive model verification tests (or system tests?) will take even longer to run and are absolutely crucial (see #81 #136), so this problem will get worse in the future.; 3. GPU tests take a while to run because of long compile time (#66) and they run on top of all the CPU tests. In general, setting up GPU models take more time so it's not ideal that we're setting up tons of tiny models for testing. Testing GPU stuff may also involve some expensive scalar CUDA operations (see #82). We will also need to run the test suite on the following architectures in the future:; 1. single-core CPU (Travis CI and Appveyor are fine here); 2. single GPU (JuliaGPU's GitLab CI pipeline works great here); 3. multi-core single CPU (MPI) (paid CI plans will probably work here); 4. multiple distributed CPU nodes (MPI) (no idea where to run this); 5. multiple GPUs (MPI) (no idea where to run this). Some ideas for things to do that will help:; 1. Explicitly split the tests up into 2-3 suites; 1.1. **Unit tests**: should run in a few minutes so we can run them during development and on every commit/PR/etc.; 1.2. **Integration tests**: can take a while to run so we don't want to run these locally all the time but probably on every PR. Shouldn't take much more than 1 hour to run so we don't have to wait forever to merge PR's.; 1.3. **Model verification tests** (also called _end-to-end_ tests): will probably take a long time to run. Maybe run this once a ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/139
https://github.com/CliMA/Oceananigans.jl/issues/139:952,Testability,Test,Testing,952,"Right now all our tests are lumped into one (unit, integration, and model verification tests) and we run the tests on the CPU and the GPU (most tests are shared). This is not a high priority item right now, but it's already annoying that I have to wait several minutes for the GPU tests to run as I'm debugging. So just starting up a discussion around this topic. I can see us hitting some limitations soon:; 1. A comprehensive test suite will take time to run, long enough that we cannot keep running it during development and debugging.; 2. Comprehensive model verification tests (or system tests?) will take even longer to run and are absolutely crucial (see #81 #136), so this problem will get worse in the future.; 3. GPU tests take a while to run because of long compile time (#66) and they run on top of all the CPU tests. In general, setting up GPU models take more time so it's not ideal that we're setting up tons of tiny models for testing. Testing GPU stuff may also involve some expensive scalar CUDA operations (see #82). We will also need to run the test suite on the following architectures in the future:; 1. single-core CPU (Travis CI and Appveyor are fine here); 2. single GPU (JuliaGPU's GitLab CI pipeline works great here); 3. multi-core single CPU (MPI) (paid CI plans will probably work here); 4. multiple distributed CPU nodes (MPI) (no idea where to run this); 5. multiple GPUs (MPI) (no idea where to run this). Some ideas for things to do that will help:; 1. Explicitly split the tests up into 2-3 suites; 1.1. **Unit tests**: should run in a few minutes so we can run them during development and on every commit/PR/etc.; 1.2. **Integration tests**: can take a while to run so we don't want to run these locally all the time but probably on every PR. Shouldn't take much more than 1 hour to run so we don't have to wait forever to merge PR's.; 1.3. **Model verification tests** (also called _end-to-end_ tests): will probably take a long time to run. Maybe run this once a ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/139
https://github.com/CliMA/Oceananigans.jl/issues/139:1065,Testability,test,test,1065,"cation tests) and we run the tests on the CPU and the GPU (most tests are shared). This is not a high priority item right now, but it's already annoying that I have to wait several minutes for the GPU tests to run as I'm debugging. So just starting up a discussion around this topic. I can see us hitting some limitations soon:; 1. A comprehensive test suite will take time to run, long enough that we cannot keep running it during development and debugging.; 2. Comprehensive model verification tests (or system tests?) will take even longer to run and are absolutely crucial (see #81 #136), so this problem will get worse in the future.; 3. GPU tests take a while to run because of long compile time (#66) and they run on top of all the CPU tests. In general, setting up GPU models take more time so it's not ideal that we're setting up tons of tiny models for testing. Testing GPU stuff may also involve some expensive scalar CUDA operations (see #82). We will also need to run the test suite on the following architectures in the future:; 1. single-core CPU (Travis CI and Appveyor are fine here); 2. single GPU (JuliaGPU's GitLab CI pipeline works great here); 3. multi-core single CPU (MPI) (paid CI plans will probably work here); 4. multiple distributed CPU nodes (MPI) (no idea where to run this); 5. multiple GPUs (MPI) (no idea where to run this). Some ideas for things to do that will help:; 1. Explicitly split the tests up into 2-3 suites; 1.1. **Unit tests**: should run in a few minutes so we can run them during development and on every commit/PR/etc.; 1.2. **Integration tests**: can take a while to run so we don't want to run these locally all the time but probably on every PR. Shouldn't take much more than 1 hour to run so we don't have to wait forever to merge PR's.; 1.3. **Model verification tests** (also called _end-to-end_ tests): will probably take a long time to run. Maybe run this once a day? Or manually if there's a PR that changes core functionality.; 2. Run the t",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/139
https://github.com/CliMA/Oceananigans.jl/issues/139:1508,Testability,test,tests,1508," development and debugging.; 2. Comprehensive model verification tests (or system tests?) will take even longer to run and are absolutely crucial (see #81 #136), so this problem will get worse in the future.; 3. GPU tests take a while to run because of long compile time (#66) and they run on top of all the CPU tests. In general, setting up GPU models take more time so it's not ideal that we're setting up tons of tiny models for testing. Testing GPU stuff may also involve some expensive scalar CUDA operations (see #82). We will also need to run the test suite on the following architectures in the future:; 1. single-core CPU (Travis CI and Appveyor are fine here); 2. single GPU (JuliaGPU's GitLab CI pipeline works great here); 3. multi-core single CPU (MPI) (paid CI plans will probably work here); 4. multiple distributed CPU nodes (MPI) (no idea where to run this); 5. multiple GPUs (MPI) (no idea where to run this). Some ideas for things to do that will help:; 1. Explicitly split the tests up into 2-3 suites; 1.1. **Unit tests**: should run in a few minutes so we can run them during development and on every commit/PR/etc.; 1.2. **Integration tests**: can take a while to run so we don't want to run these locally all the time but probably on every PR. Shouldn't take much more than 1 hour to run so we don't have to wait forever to merge PR's.; 1.3. **Model verification tests** (also called _end-to-end_ tests): will probably take a long time to run. Maybe run this once a day? Or manually if there's a PR that changes core functionality.; 2. Run the tests in parallel. I think the main Julia repo does this. We might have to roll our own parallel solution (see [this thread](https://discourse.julialang.org/t/run-pkg-test-with-several-processors/6917)). This would also require expensive paid CI plans (but very much worth it in my opinion).; 3. Thinking long-term, if we had a multi-CPU multi-GPU machine available we could probably roll our own CI solution for these distributed a",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/139
https://github.com/CliMA/Oceananigans.jl/issues/139:1546,Testability,test,tests,1546,"tests?) will take even longer to run and are absolutely crucial (see #81 #136), so this problem will get worse in the future.; 3. GPU tests take a while to run because of long compile time (#66) and they run on top of all the CPU tests. In general, setting up GPU models take more time so it's not ideal that we're setting up tons of tiny models for testing. Testing GPU stuff may also involve some expensive scalar CUDA operations (see #82). We will also need to run the test suite on the following architectures in the future:; 1. single-core CPU (Travis CI and Appveyor are fine here); 2. single GPU (JuliaGPU's GitLab CI pipeline works great here); 3. multi-core single CPU (MPI) (paid CI plans will probably work here); 4. multiple distributed CPU nodes (MPI) (no idea where to run this); 5. multiple GPUs (MPI) (no idea where to run this). Some ideas for things to do that will help:; 1. Explicitly split the tests up into 2-3 suites; 1.1. **Unit tests**: should run in a few minutes so we can run them during development and on every commit/PR/etc.; 1.2. **Integration tests**: can take a while to run so we don't want to run these locally all the time but probably on every PR. Shouldn't take much more than 1 hour to run so we don't have to wait forever to merge PR's.; 1.3. **Model verification tests** (also called _end-to-end_ tests): will probably take a long time to run. Maybe run this once a day? Or manually if there's a PR that changes core functionality.; 2. Run the tests in parallel. I think the main Julia repo does this. We might have to roll our own parallel solution (see [this thread](https://discourse.julialang.org/t/run-pkg-test-with-several-processors/6917)). This would also require expensive paid CI plans (but very much worth it in my opinion).; 3. Thinking long-term, if we had a multi-CPU multi-GPU machine available we could probably roll our own CI solution for these distributed architectures. Ideally we'd want to see if we can get this through a service althou",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/139
https://github.com/CliMA/Oceananigans.jl/issues/139:1669,Testability,test,tests,1669,"e.; 3. GPU tests take a while to run because of long compile time (#66) and they run on top of all the CPU tests. In general, setting up GPU models take more time so it's not ideal that we're setting up tons of tiny models for testing. Testing GPU stuff may also involve some expensive scalar CUDA operations (see #82). We will also need to run the test suite on the following architectures in the future:; 1. single-core CPU (Travis CI and Appveyor are fine here); 2. single GPU (JuliaGPU's GitLab CI pipeline works great here); 3. multi-core single CPU (MPI) (paid CI plans will probably work here); 4. multiple distributed CPU nodes (MPI) (no idea where to run this); 5. multiple GPUs (MPI) (no idea where to run this). Some ideas for things to do that will help:; 1. Explicitly split the tests up into 2-3 suites; 1.1. **Unit tests**: should run in a few minutes so we can run them during development and on every commit/PR/etc.; 1.2. **Integration tests**: can take a while to run so we don't want to run these locally all the time but probably on every PR. Shouldn't take much more than 1 hour to run so we don't have to wait forever to merge PR's.; 1.3. **Model verification tests** (also called _end-to-end_ tests): will probably take a long time to run. Maybe run this once a day? Or manually if there's a PR that changes core functionality.; 2. Run the tests in parallel. I think the main Julia repo does this. We might have to roll our own parallel solution (see [this thread](https://discourse.julialang.org/t/run-pkg-test-with-several-processors/6917)). This would also require expensive paid CI plans (but very much worth it in my opinion).; 3. Thinking long-term, if we had a multi-CPU multi-GPU machine available we could probably roll our own CI solution for these distributed architectures. Ideally we'd want to see if we can get this through a service although it would probably cost $$$$$. cc @christophernhill @jm-c @glwagner: I know we all care about testing. cc @charleskawczyn",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/139
https://github.com/CliMA/Oceananigans.jl/issues/139:1898,Testability,test,tests,1898,"tiny models for testing. Testing GPU stuff may also involve some expensive scalar CUDA operations (see #82). We will also need to run the test suite on the following architectures in the future:; 1. single-core CPU (Travis CI and Appveyor are fine here); 2. single GPU (JuliaGPU's GitLab CI pipeline works great here); 3. multi-core single CPU (MPI) (paid CI plans will probably work here); 4. multiple distributed CPU nodes (MPI) (no idea where to run this); 5. multiple GPUs (MPI) (no idea where to run this). Some ideas for things to do that will help:; 1. Explicitly split the tests up into 2-3 suites; 1.1. **Unit tests**: should run in a few minutes so we can run them during development and on every commit/PR/etc.; 1.2. **Integration tests**: can take a while to run so we don't want to run these locally all the time but probably on every PR. Shouldn't take much more than 1 hour to run so we don't have to wait forever to merge PR's.; 1.3. **Model verification tests** (also called _end-to-end_ tests): will probably take a long time to run. Maybe run this once a day? Or manually if there's a PR that changes core functionality.; 2. Run the tests in parallel. I think the main Julia repo does this. We might have to roll our own parallel solution (see [this thread](https://discourse.julialang.org/t/run-pkg-test-with-several-processors/6917)). This would also require expensive paid CI plans (but very much worth it in my opinion).; 3. Thinking long-term, if we had a multi-CPU multi-GPU machine available we could probably roll our own CI solution for these distributed architectures. Ideally we'd want to see if we can get this through a service although it would probably cost $$$$$. cc @christophernhill @jm-c @glwagner: I know we all care about testing. cc @charleskawczynski @simonbyrne: Just wondering if this is a problem you guys are anticipating for CliMA.jl? We might be able to share some common solutions?. Resources:; * [Nvidia slides on building a GPU-focused CI solution](",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/139
https://github.com/CliMA/Oceananigans.jl/issues/139:1932,Testability,test,tests,1932,"tiny models for testing. Testing GPU stuff may also involve some expensive scalar CUDA operations (see #82). We will also need to run the test suite on the following architectures in the future:; 1. single-core CPU (Travis CI and Appveyor are fine here); 2. single GPU (JuliaGPU's GitLab CI pipeline works great here); 3. multi-core single CPU (MPI) (paid CI plans will probably work here); 4. multiple distributed CPU nodes (MPI) (no idea where to run this); 5. multiple GPUs (MPI) (no idea where to run this). Some ideas for things to do that will help:; 1. Explicitly split the tests up into 2-3 suites; 1.1. **Unit tests**: should run in a few minutes so we can run them during development and on every commit/PR/etc.; 1.2. **Integration tests**: can take a while to run so we don't want to run these locally all the time but probably on every PR. Shouldn't take much more than 1 hour to run so we don't have to wait forever to merge PR's.; 1.3. **Model verification tests** (also called _end-to-end_ tests): will probably take a long time to run. Maybe run this once a day? Or manually if there's a PR that changes core functionality.; 2. Run the tests in parallel. I think the main Julia repo does this. We might have to roll our own parallel solution (see [this thread](https://discourse.julialang.org/t/run-pkg-test-with-several-processors/6917)). This would also require expensive paid CI plans (but very much worth it in my opinion).; 3. Thinking long-term, if we had a multi-CPU multi-GPU machine available we could probably roll our own CI solution for these distributed architectures. Ideally we'd want to see if we can get this through a service although it would probably cost $$$$$. cc @christophernhill @jm-c @glwagner: I know we all care about testing. cc @charleskawczynski @simonbyrne: Just wondering if this is a problem you guys are anticipating for CliMA.jl? We might be able to share some common solutions?. Resources:; * [Nvidia slides on building a GPU-focused CI solution](",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/139
https://github.com/CliMA/Oceananigans.jl/issues/139:2079,Testability,test,tests,2079,"ee #82). We will also need to run the test suite on the following architectures in the future:; 1. single-core CPU (Travis CI and Appveyor are fine here); 2. single GPU (JuliaGPU's GitLab CI pipeline works great here); 3. multi-core single CPU (MPI) (paid CI plans will probably work here); 4. multiple distributed CPU nodes (MPI) (no idea where to run this); 5. multiple GPUs (MPI) (no idea where to run this). Some ideas for things to do that will help:; 1. Explicitly split the tests up into 2-3 suites; 1.1. **Unit tests**: should run in a few minutes so we can run them during development and on every commit/PR/etc.; 1.2. **Integration tests**: can take a while to run so we don't want to run these locally all the time but probably on every PR. Shouldn't take much more than 1 hour to run so we don't have to wait forever to merge PR's.; 1.3. **Model verification tests** (also called _end-to-end_ tests): will probably take a long time to run. Maybe run this once a day? Or manually if there's a PR that changes core functionality.; 2. Run the tests in parallel. I think the main Julia repo does this. We might have to roll our own parallel solution (see [this thread](https://discourse.julialang.org/t/run-pkg-test-with-several-processors/6917)). This would also require expensive paid CI plans (but very much worth it in my opinion).; 3. Thinking long-term, if we had a multi-CPU multi-GPU machine available we could probably roll our own CI solution for these distributed architectures. Ideally we'd want to see if we can get this through a service although it would probably cost $$$$$. cc @christophernhill @jm-c @glwagner: I know we all care about testing. cc @charleskawczynski @simonbyrne: Just wondering if this is a problem you guys are anticipating for CliMA.jl? We might be able to share some common solutions?. Resources:; * [Nvidia slides on building a GPU-focused CI solution](http://on-demand.gputechconf.com/gtc/2018/presentation/s8563-building-a-gpu-focused-ci-solution.pdf)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/139
https://github.com/CliMA/Oceananigans.jl/issues/139:2246,Testability,test,test-with-several-processors,2246,"ee #82). We will also need to run the test suite on the following architectures in the future:; 1. single-core CPU (Travis CI and Appveyor are fine here); 2. single GPU (JuliaGPU's GitLab CI pipeline works great here); 3. multi-core single CPU (MPI) (paid CI plans will probably work here); 4. multiple distributed CPU nodes (MPI) (no idea where to run this); 5. multiple GPUs (MPI) (no idea where to run this). Some ideas for things to do that will help:; 1. Explicitly split the tests up into 2-3 suites; 1.1. **Unit tests**: should run in a few minutes so we can run them during development and on every commit/PR/etc.; 1.2. **Integration tests**: can take a while to run so we don't want to run these locally all the time but probably on every PR. Shouldn't take much more than 1 hour to run so we don't have to wait forever to merge PR's.; 1.3. **Model verification tests** (also called _end-to-end_ tests): will probably take a long time to run. Maybe run this once a day? Or manually if there's a PR that changes core functionality.; 2. Run the tests in parallel. I think the main Julia repo does this. We might have to roll our own parallel solution (see [this thread](https://discourse.julialang.org/t/run-pkg-test-with-several-processors/6917)). This would also require expensive paid CI plans (but very much worth it in my opinion).; 3. Thinking long-term, if we had a multi-CPU multi-GPU machine available we could probably roll our own CI solution for these distributed architectures. Ideally we'd want to see if we can get this through a service although it would probably cost $$$$$. cc @christophernhill @jm-c @glwagner: I know we all care about testing. cc @charleskawczynski @simonbyrne: Just wondering if this is a problem you guys are anticipating for CliMA.jl? We might be able to share some common solutions?. Resources:; * [Nvidia slides on building a GPU-focused CI solution](http://on-demand.gputechconf.com/gtc/2018/presentation/s8563-building-a-gpu-focused-ci-solution.pdf)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/139
https://github.com/CliMA/Oceananigans.jl/issues/139:2689,Testability,test,testing,2689,"ee #82). We will also need to run the test suite on the following architectures in the future:; 1. single-core CPU (Travis CI and Appveyor are fine here); 2. single GPU (JuliaGPU's GitLab CI pipeline works great here); 3. multi-core single CPU (MPI) (paid CI plans will probably work here); 4. multiple distributed CPU nodes (MPI) (no idea where to run this); 5. multiple GPUs (MPI) (no idea where to run this). Some ideas for things to do that will help:; 1. Explicitly split the tests up into 2-3 suites; 1.1. **Unit tests**: should run in a few minutes so we can run them during development and on every commit/PR/etc.; 1.2. **Integration tests**: can take a while to run so we don't want to run these locally all the time but probably on every PR. Shouldn't take much more than 1 hour to run so we don't have to wait forever to merge PR's.; 1.3. **Model verification tests** (also called _end-to-end_ tests): will probably take a long time to run. Maybe run this once a day? Or manually if there's a PR that changes core functionality.; 2. Run the tests in parallel. I think the main Julia repo does this. We might have to roll our own parallel solution (see [this thread](https://discourse.julialang.org/t/run-pkg-test-with-several-processors/6917)). This would also require expensive paid CI plans (but very much worth it in my opinion).; 3. Thinking long-term, if we had a multi-CPU multi-GPU machine available we could probably roll our own CI solution for these distributed architectures. Ideally we'd want to see if we can get this through a service although it would probably cost $$$$$. cc @christophernhill @jm-c @glwagner: I know we all care about testing. cc @charleskawczynski @simonbyrne: Just wondering if this is a problem you guys are anticipating for CliMA.jl? We might be able to share some common solutions?. Resources:; * [Nvidia slides on building a GPU-focused CI solution](http://on-demand.gputechconf.com/gtc/2018/presentation/s8563-building-a-gpu-focused-ci-solution.pdf)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/139
https://github.com/CliMA/Oceananigans.jl/pull/140:156,Availability,checkpoint,checkpointing,156,"Call them system tests, model verification tests, or end-to-end tests, that's what this PR is about. Currently a work in progress as I hit a roadblock with checkpointing so **the tests will fail**. See #141. BUT, for testing we can just set `model.forcings = nothing` and manually reconstruct the forcings as we know them. Tests implemented so far:; 1. Checkpointing integration test: Run two coarse rising thermal bubble simulations and make sure that when restarting from a checkpoint, the restarted simulation matches the non-restarted simulation numerically.; 2. NetCDF output integration test: Run a coarse thermal bubble simulation and save the output to NetCDF at the 10th time step. Then read back the output and test that it matches the model's state.; 3. Thermal bubble golden master test: Run the coarse thermal bubble simulation for 10 time steps and check that the model output matches a golden master output.; 4. Deep convection golden master test. @jm-c @christophernhill: do post any ideas for tests that should be implemented in this PR.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/140
https://github.com/CliMA/Oceananigans.jl/pull/140:353,Availability,Checkpoint,Checkpointing,353,"Call them system tests, model verification tests, or end-to-end tests, that's what this PR is about. Currently a work in progress as I hit a roadblock with checkpointing so **the tests will fail**. See #141. BUT, for testing we can just set `model.forcings = nothing` and manually reconstruct the forcings as we know them. Tests implemented so far:; 1. Checkpointing integration test: Run two coarse rising thermal bubble simulations and make sure that when restarting from a checkpoint, the restarted simulation matches the non-restarted simulation numerically.; 2. NetCDF output integration test: Run a coarse thermal bubble simulation and save the output to NetCDF at the 10th time step. Then read back the output and test that it matches the model's state.; 3. Thermal bubble golden master test: Run the coarse thermal bubble simulation for 10 time steps and check that the model output matches a golden master output.; 4. Deep convection golden master test. @jm-c @christophernhill: do post any ideas for tests that should be implemented in this PR.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/140
https://github.com/CliMA/Oceananigans.jl/pull/140:476,Availability,checkpoint,checkpoint,476,"Call them system tests, model verification tests, or end-to-end tests, that's what this PR is about. Currently a work in progress as I hit a roadblock with checkpointing so **the tests will fail**. See #141. BUT, for testing we can just set `model.forcings = nothing` and manually reconstruct the forcings as we know them. Tests implemented so far:; 1. Checkpointing integration test: Run two coarse rising thermal bubble simulations and make sure that when restarting from a checkpoint, the restarted simulation matches the non-restarted simulation numerically.; 2. NetCDF output integration test: Run a coarse thermal bubble simulation and save the output to NetCDF at the 10th time step. Then read back the output and test that it matches the model's state.; 3. Thermal bubble golden master test: Run the coarse thermal bubble simulation for 10 time steps and check that the model output matches a golden master output.; 4. Deep convection golden master test. @jm-c @christophernhill: do post any ideas for tests that should be implemented in this PR.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/140
https://github.com/CliMA/Oceananigans.jl/pull/140:367,Deployability,integrat,integration,367,"Call them system tests, model verification tests, or end-to-end tests, that's what this PR is about. Currently a work in progress as I hit a roadblock with checkpointing so **the tests will fail**. See #141. BUT, for testing we can just set `model.forcings = nothing` and manually reconstruct the forcings as we know them. Tests implemented so far:; 1. Checkpointing integration test: Run two coarse rising thermal bubble simulations and make sure that when restarting from a checkpoint, the restarted simulation matches the non-restarted simulation numerically.; 2. NetCDF output integration test: Run a coarse thermal bubble simulation and save the output to NetCDF at the 10th time step. Then read back the output and test that it matches the model's state.; 3. Thermal bubble golden master test: Run the coarse thermal bubble simulation for 10 time steps and check that the model output matches a golden master output.; 4. Deep convection golden master test. @jm-c @christophernhill: do post any ideas for tests that should be implemented in this PR.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/140
https://github.com/CliMA/Oceananigans.jl/pull/140:581,Deployability,integrat,integration,581,"Call them system tests, model verification tests, or end-to-end tests, that's what this PR is about. Currently a work in progress as I hit a roadblock with checkpointing so **the tests will fail**. See #141. BUT, for testing we can just set `model.forcings = nothing` and manually reconstruct the forcings as we know them. Tests implemented so far:; 1. Checkpointing integration test: Run two coarse rising thermal bubble simulations and make sure that when restarting from a checkpoint, the restarted simulation matches the non-restarted simulation numerically.; 2. NetCDF output integration test: Run a coarse thermal bubble simulation and save the output to NetCDF at the 10th time step. Then read back the output and test that it matches the model's state.; 3. Thermal bubble golden master test: Run the coarse thermal bubble simulation for 10 time steps and check that the model output matches a golden master output.; 4. Deep convection golden master test. @jm-c @christophernhill: do post any ideas for tests that should be implemented in this PR.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/140
https://github.com/CliMA/Oceananigans.jl/pull/140:367,Integrability,integrat,integration,367,"Call them system tests, model verification tests, or end-to-end tests, that's what this PR is about. Currently a work in progress as I hit a roadblock with checkpointing so **the tests will fail**. See #141. BUT, for testing we can just set `model.forcings = nothing` and manually reconstruct the forcings as we know them. Tests implemented so far:; 1. Checkpointing integration test: Run two coarse rising thermal bubble simulations and make sure that when restarting from a checkpoint, the restarted simulation matches the non-restarted simulation numerically.; 2. NetCDF output integration test: Run a coarse thermal bubble simulation and save the output to NetCDF at the 10th time step. Then read back the output and test that it matches the model's state.; 3. Thermal bubble golden master test: Run the coarse thermal bubble simulation for 10 time steps and check that the model output matches a golden master output.; 4. Deep convection golden master test. @jm-c @christophernhill: do post any ideas for tests that should be implemented in this PR.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/140
https://github.com/CliMA/Oceananigans.jl/pull/140:581,Integrability,integrat,integration,581,"Call them system tests, model verification tests, or end-to-end tests, that's what this PR is about. Currently a work in progress as I hit a roadblock with checkpointing so **the tests will fail**. See #141. BUT, for testing we can just set `model.forcings = nothing` and manually reconstruct the forcings as we know them. Tests implemented so far:; 1. Checkpointing integration test: Run two coarse rising thermal bubble simulations and make sure that when restarting from a checkpoint, the restarted simulation matches the non-restarted simulation numerically.; 2. NetCDF output integration test: Run a coarse thermal bubble simulation and save the output to NetCDF at the 10th time step. Then read back the output and test that it matches the model's state.; 3. Thermal bubble golden master test: Run the coarse thermal bubble simulation for 10 time steps and check that the model output matches a golden master output.; 4. Deep convection golden master test. @jm-c @christophernhill: do post any ideas for tests that should be implemented in this PR.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/140
https://github.com/CliMA/Oceananigans.jl/pull/140:17,Testability,test,tests,17,"Call them system tests, model verification tests, or end-to-end tests, that's what this PR is about. Currently a work in progress as I hit a roadblock with checkpointing so **the tests will fail**. See #141. BUT, for testing we can just set `model.forcings = nothing` and manually reconstruct the forcings as we know them. Tests implemented so far:; 1. Checkpointing integration test: Run two coarse rising thermal bubble simulations and make sure that when restarting from a checkpoint, the restarted simulation matches the non-restarted simulation numerically.; 2. NetCDF output integration test: Run a coarse thermal bubble simulation and save the output to NetCDF at the 10th time step. Then read back the output and test that it matches the model's state.; 3. Thermal bubble golden master test: Run the coarse thermal bubble simulation for 10 time steps and check that the model output matches a golden master output.; 4. Deep convection golden master test. @jm-c @christophernhill: do post any ideas for tests that should be implemented in this PR.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/140
https://github.com/CliMA/Oceananigans.jl/pull/140:43,Testability,test,tests,43,"Call them system tests, model verification tests, or end-to-end tests, that's what this PR is about. Currently a work in progress as I hit a roadblock with checkpointing so **the tests will fail**. See #141. BUT, for testing we can just set `model.forcings = nothing` and manually reconstruct the forcings as we know them. Tests implemented so far:; 1. Checkpointing integration test: Run two coarse rising thermal bubble simulations and make sure that when restarting from a checkpoint, the restarted simulation matches the non-restarted simulation numerically.; 2. NetCDF output integration test: Run a coarse thermal bubble simulation and save the output to NetCDF at the 10th time step. Then read back the output and test that it matches the model's state.; 3. Thermal bubble golden master test: Run the coarse thermal bubble simulation for 10 time steps and check that the model output matches a golden master output.; 4. Deep convection golden master test. @jm-c @christophernhill: do post any ideas for tests that should be implemented in this PR.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/140
https://github.com/CliMA/Oceananigans.jl/pull/140:64,Testability,test,tests,64,"Call them system tests, model verification tests, or end-to-end tests, that's what this PR is about. Currently a work in progress as I hit a roadblock with checkpointing so **the tests will fail**. See #141. BUT, for testing we can just set `model.forcings = nothing` and manually reconstruct the forcings as we know them. Tests implemented so far:; 1. Checkpointing integration test: Run two coarse rising thermal bubble simulations and make sure that when restarting from a checkpoint, the restarted simulation matches the non-restarted simulation numerically.; 2. NetCDF output integration test: Run a coarse thermal bubble simulation and save the output to NetCDF at the 10th time step. Then read back the output and test that it matches the model's state.; 3. Thermal bubble golden master test: Run the coarse thermal bubble simulation for 10 time steps and check that the model output matches a golden master output.; 4. Deep convection golden master test. @jm-c @christophernhill: do post any ideas for tests that should be implemented in this PR.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/140
https://github.com/CliMA/Oceananigans.jl/pull/140:179,Testability,test,tests,179,"Call them system tests, model verification tests, or end-to-end tests, that's what this PR is about. Currently a work in progress as I hit a roadblock with checkpointing so **the tests will fail**. See #141. BUT, for testing we can just set `model.forcings = nothing` and manually reconstruct the forcings as we know them. Tests implemented so far:; 1. Checkpointing integration test: Run two coarse rising thermal bubble simulations and make sure that when restarting from a checkpoint, the restarted simulation matches the non-restarted simulation numerically.; 2. NetCDF output integration test: Run a coarse thermal bubble simulation and save the output to NetCDF at the 10th time step. Then read back the output and test that it matches the model's state.; 3. Thermal bubble golden master test: Run the coarse thermal bubble simulation for 10 time steps and check that the model output matches a golden master output.; 4. Deep convection golden master test. @jm-c @christophernhill: do post any ideas for tests that should be implemented in this PR.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/140
https://github.com/CliMA/Oceananigans.jl/pull/140:217,Testability,test,testing,217,"Call them system tests, model verification tests, or end-to-end tests, that's what this PR is about. Currently a work in progress as I hit a roadblock with checkpointing so **the tests will fail**. See #141. BUT, for testing we can just set `model.forcings = nothing` and manually reconstruct the forcings as we know them. Tests implemented so far:; 1. Checkpointing integration test: Run two coarse rising thermal bubble simulations and make sure that when restarting from a checkpoint, the restarted simulation matches the non-restarted simulation numerically.; 2. NetCDF output integration test: Run a coarse thermal bubble simulation and save the output to NetCDF at the 10th time step. Then read back the output and test that it matches the model's state.; 3. Thermal bubble golden master test: Run the coarse thermal bubble simulation for 10 time steps and check that the model output matches a golden master output.; 4. Deep convection golden master test. @jm-c @christophernhill: do post any ideas for tests that should be implemented in this PR.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/140
https://github.com/CliMA/Oceananigans.jl/pull/140:323,Testability,Test,Tests,323,"Call them system tests, model verification tests, or end-to-end tests, that's what this PR is about. Currently a work in progress as I hit a roadblock with checkpointing so **the tests will fail**. See #141. BUT, for testing we can just set `model.forcings = nothing` and manually reconstruct the forcings as we know them. Tests implemented so far:; 1. Checkpointing integration test: Run two coarse rising thermal bubble simulations and make sure that when restarting from a checkpoint, the restarted simulation matches the non-restarted simulation numerically.; 2. NetCDF output integration test: Run a coarse thermal bubble simulation and save the output to NetCDF at the 10th time step. Then read back the output and test that it matches the model's state.; 3. Thermal bubble golden master test: Run the coarse thermal bubble simulation for 10 time steps and check that the model output matches a golden master output.; 4. Deep convection golden master test. @jm-c @christophernhill: do post any ideas for tests that should be implemented in this PR.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/140
https://github.com/CliMA/Oceananigans.jl/pull/140:379,Testability,test,test,379,"Call them system tests, model verification tests, or end-to-end tests, that's what this PR is about. Currently a work in progress as I hit a roadblock with checkpointing so **the tests will fail**. See #141. BUT, for testing we can just set `model.forcings = nothing` and manually reconstruct the forcings as we know them. Tests implemented so far:; 1. Checkpointing integration test: Run two coarse rising thermal bubble simulations and make sure that when restarting from a checkpoint, the restarted simulation matches the non-restarted simulation numerically.; 2. NetCDF output integration test: Run a coarse thermal bubble simulation and save the output to NetCDF at the 10th time step. Then read back the output and test that it matches the model's state.; 3. Thermal bubble golden master test: Run the coarse thermal bubble simulation for 10 time steps and check that the model output matches a golden master output.; 4. Deep convection golden master test. @jm-c @christophernhill: do post any ideas for tests that should be implemented in this PR.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/140
https://github.com/CliMA/Oceananigans.jl/pull/140:593,Testability,test,test,593,"Call them system tests, model verification tests, or end-to-end tests, that's what this PR is about. Currently a work in progress as I hit a roadblock with checkpointing so **the tests will fail**. See #141. BUT, for testing we can just set `model.forcings = nothing` and manually reconstruct the forcings as we know them. Tests implemented so far:; 1. Checkpointing integration test: Run two coarse rising thermal bubble simulations and make sure that when restarting from a checkpoint, the restarted simulation matches the non-restarted simulation numerically.; 2. NetCDF output integration test: Run a coarse thermal bubble simulation and save the output to NetCDF at the 10th time step. Then read back the output and test that it matches the model's state.; 3. Thermal bubble golden master test: Run the coarse thermal bubble simulation for 10 time steps and check that the model output matches a golden master output.; 4. Deep convection golden master test. @jm-c @christophernhill: do post any ideas for tests that should be implemented in this PR.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/140
https://github.com/CliMA/Oceananigans.jl/pull/140:721,Testability,test,test,721,"Call them system tests, model verification tests, or end-to-end tests, that's what this PR is about. Currently a work in progress as I hit a roadblock with checkpointing so **the tests will fail**. See #141. BUT, for testing we can just set `model.forcings = nothing` and manually reconstruct the forcings as we know them. Tests implemented so far:; 1. Checkpointing integration test: Run two coarse rising thermal bubble simulations and make sure that when restarting from a checkpoint, the restarted simulation matches the non-restarted simulation numerically.; 2. NetCDF output integration test: Run a coarse thermal bubble simulation and save the output to NetCDF at the 10th time step. Then read back the output and test that it matches the model's state.; 3. Thermal bubble golden master test: Run the coarse thermal bubble simulation for 10 time steps and check that the model output matches a golden master output.; 4. Deep convection golden master test. @jm-c @christophernhill: do post any ideas for tests that should be implemented in this PR.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/140
https://github.com/CliMA/Oceananigans.jl/pull/140:794,Testability,test,test,794,"Call them system tests, model verification tests, or end-to-end tests, that's what this PR is about. Currently a work in progress as I hit a roadblock with checkpointing so **the tests will fail**. See #141. BUT, for testing we can just set `model.forcings = nothing` and manually reconstruct the forcings as we know them. Tests implemented so far:; 1. Checkpointing integration test: Run two coarse rising thermal bubble simulations and make sure that when restarting from a checkpoint, the restarted simulation matches the non-restarted simulation numerically.; 2. NetCDF output integration test: Run a coarse thermal bubble simulation and save the output to NetCDF at the 10th time step. Then read back the output and test that it matches the model's state.; 3. Thermal bubble golden master test: Run the coarse thermal bubble simulation for 10 time steps and check that the model output matches a golden master output.; 4. Deep convection golden master test. @jm-c @christophernhill: do post any ideas for tests that should be implemented in this PR.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/140
https://github.com/CliMA/Oceananigans.jl/pull/140:957,Testability,test,test,957,"Call them system tests, model verification tests, or end-to-end tests, that's what this PR is about. Currently a work in progress as I hit a roadblock with checkpointing so **the tests will fail**. See #141. BUT, for testing we can just set `model.forcings = nothing` and manually reconstruct the forcings as we know them. Tests implemented so far:; 1. Checkpointing integration test: Run two coarse rising thermal bubble simulations and make sure that when restarting from a checkpoint, the restarted simulation matches the non-restarted simulation numerically.; 2. NetCDF output integration test: Run a coarse thermal bubble simulation and save the output to NetCDF at the 10th time step. Then read back the output and test that it matches the model's state.; 3. Thermal bubble golden master test: Run the coarse thermal bubble simulation for 10 time steps and check that the model output matches a golden master output.; 4. Deep convection golden master test. @jm-c @christophernhill: do post any ideas for tests that should be implemented in this PR.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/140
https://github.com/CliMA/Oceananigans.jl/pull/140:1010,Testability,test,tests,1010,"Call them system tests, model verification tests, or end-to-end tests, that's what this PR is about. Currently a work in progress as I hit a roadblock with checkpointing so **the tests will fail**. See #141. BUT, for testing we can just set `model.forcings = nothing` and manually reconstruct the forcings as we know them. Tests implemented so far:; 1. Checkpointing integration test: Run two coarse rising thermal bubble simulations and make sure that when restarting from a checkpoint, the restarted simulation matches the non-restarted simulation numerically.; 2. NetCDF output integration test: Run a coarse thermal bubble simulation and save the output to NetCDF at the 10th time step. Then read back the output and test that it matches the model's state.; 3. Thermal bubble golden master test: Run the coarse thermal bubble simulation for 10 time steps and check that the model output matches a golden master output.; 4. Deep convection golden master test. @jm-c @christophernhill: do post any ideas for tests that should be implemented in this PR.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/140
https://github.com/CliMA/Oceananigans.jl/issues/141:17,Availability,checkpoint,checkpointing,17,"I cannot get the checkpointing test running in PR #140 as JLD is not able to serialize the model to disk with forcing functions. We can go back to forcing arrays but we I think that's a bad idea as we should avoid increasing GPU memory usage. I believe that [JLD2.jl](https://github.com/JuliaIO/JLD2.jl) might be able to serialize functions to disk but it's not actively maintained anymore and their README says ""If your tolerance for data loss is low, JLD may be a better choice at this time."". If we can fix this and figure out how to serialize functions to disk, then we may also be able to serialize the FFTW and CuFFT plans to disk (although we might still want to reconstruct them as in case the model is restored on a different computer with a different architecture). Stacktrace:; ```julia; Deserializing model from disk: test_model_checkpoint_5.jld; error parsing type string Oceananigans.Forcing{Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func}; Checkpointing: Error During Test at D:\Home\Git\Oceananigans.jl\test\runtests.jl:246; Got exception outside of a @test; syntax: incomplete: premature end of input; Stacktrace:; [1] eval at .\boot.jl:328 [inlined]; [2] eval at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:3 [inlined]; [3] _julia_type(::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:983; [4] julia_type(::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:30; [5] jldatatype(::JLD.JldFile, ::HDF5.HDF5Datatype) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:701; [6] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [7] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:502; [8] jlconvert(::Type{Model}, ::JLD.JldFile, ::Ptr{UInt8}) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:387; [9] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at C:\Users\Ali\.julia",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/141
https://github.com/CliMA/Oceananigans.jl/issues/141:421,Availability,toler,tolerance,421,"I cannot get the checkpointing test running in PR #140 as JLD is not able to serialize the model to disk with forcing functions. We can go back to forcing arrays but we I think that's a bad idea as we should avoid increasing GPU memory usage. I believe that [JLD2.jl](https://github.com/JuliaIO/JLD2.jl) might be able to serialize functions to disk but it's not actively maintained anymore and their README says ""If your tolerance for data loss is low, JLD may be a better choice at this time."". If we can fix this and figure out how to serialize functions to disk, then we may also be able to serialize the FFTW and CuFFT plans to disk (although we might still want to reconstruct them as in case the model is restored on a different computer with a different architecture). Stacktrace:; ```julia; Deserializing model from disk: test_model_checkpoint_5.jld; error parsing type string Oceananigans.Forcing{Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func}; Checkpointing: Error During Test at D:\Home\Git\Oceananigans.jl\test\runtests.jl:246; Got exception outside of a @test; syntax: incomplete: premature end of input; Stacktrace:; [1] eval at .\boot.jl:328 [inlined]; [2] eval at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:3 [inlined]; [3] _julia_type(::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:983; [4] julia_type(::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:30; [5] jldatatype(::JLD.JldFile, ::HDF5.HDF5Datatype) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:701; [6] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [7] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:502; [8] jlconvert(::Type{Model}, ::JLD.JldFile, ::Ptr{UInt8}) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:387; [9] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at C:\Users\Ali\.julia",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/141
https://github.com/CliMA/Oceananigans.jl/issues/141:859,Availability,error,error,859,"I cannot get the checkpointing test running in PR #140 as JLD is not able to serialize the model to disk with forcing functions. We can go back to forcing arrays but we I think that's a bad idea as we should avoid increasing GPU memory usage. I believe that [JLD2.jl](https://github.com/JuliaIO/JLD2.jl) might be able to serialize functions to disk but it's not actively maintained anymore and their README says ""If your tolerance for data loss is low, JLD may be a better choice at this time."". If we can fix this and figure out how to serialize functions to disk, then we may also be able to serialize the FFTW and CuFFT plans to disk (although we might still want to reconstruct them as in case the model is restored on a different computer with a different architecture). Stacktrace:; ```julia; Deserializing model from disk: test_model_checkpoint_5.jld; error parsing type string Oceananigans.Forcing{Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func}; Checkpointing: Error During Test at D:\Home\Git\Oceananigans.jl\test\runtests.jl:246; Got exception outside of a @test; syntax: incomplete: premature end of input; Stacktrace:; [1] eval at .\boot.jl:328 [inlined]; [2] eval at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:3 [inlined]; [3] _julia_type(::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:983; [4] julia_type(::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:30; [5] jldatatype(::JLD.JldFile, ::HDF5.HDF5Datatype) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:701; [6] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [7] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:502; [8] jlconvert(::Type{Model}, ::JLD.JldFile, ::Ptr{UInt8}) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:387; [9] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at C:\Users\Ali\.julia",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/141
https://github.com/CliMA/Oceananigans.jl/issues/141:1028,Availability,Checkpoint,Checkpointing,1028,"40 as JLD is not able to serialize the model to disk with forcing functions. We can go back to forcing arrays but we I think that's a bad idea as we should avoid increasing GPU memory usage. I believe that [JLD2.jl](https://github.com/JuliaIO/JLD2.jl) might be able to serialize functions to disk but it's not actively maintained anymore and their README says ""If your tolerance for data loss is low, JLD may be a better choice at this time."". If we can fix this and figure out how to serialize functions to disk, then we may also be able to serialize the FFTW and CuFFT plans to disk (although we might still want to reconstruct them as in case the model is restored on a different computer with a different architecture). Stacktrace:; ```julia; Deserializing model from disk: test_model_checkpoint_5.jld; error parsing type string Oceananigans.Forcing{Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func}; Checkpointing: Error During Test at D:\Home\Git\Oceananigans.jl\test\runtests.jl:246; Got exception outside of a @test; syntax: incomplete: premature end of input; Stacktrace:; [1] eval at .\boot.jl:328 [inlined]; [2] eval at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:3 [inlined]; [3] _julia_type(::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:983; [4] julia_type(::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:30; [5] jldatatype(::JLD.JldFile, ::HDF5.HDF5Datatype) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:701; [6] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [7] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:502; [8] jlconvert(::Type{Model}, ::JLD.JldFile, ::Ptr{UInt8}) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:387; [9] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:398; [10] read(::JLD",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/141
https://github.com/CliMA/Oceananigans.jl/issues/141:1043,Availability,Error,Error,1043,"40 as JLD is not able to serialize the model to disk with forcing functions. We can go back to forcing arrays but we I think that's a bad idea as we should avoid increasing GPU memory usage. I believe that [JLD2.jl](https://github.com/JuliaIO/JLD2.jl) might be able to serialize functions to disk but it's not actively maintained anymore and their README says ""If your tolerance for data loss is low, JLD may be a better choice at this time."". If we can fix this and figure out how to serialize functions to disk, then we may also be able to serialize the FFTW and CuFFT plans to disk (although we might still want to reconstruct them as in case the model is restored on a different computer with a different architecture). Stacktrace:; ```julia; Deserializing model from disk: test_model_checkpoint_5.jld; error parsing type string Oceananigans.Forcing{Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func}; Checkpointing: Error During Test at D:\Home\Git\Oceananigans.jl\test\runtests.jl:246; Got exception outside of a @test; syntax: incomplete: premature end of input; Stacktrace:; [1] eval at .\boot.jl:328 [inlined]; [2] eval at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:3 [inlined]; [3] _julia_type(::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:983; [4] julia_type(::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:30; [5] jldatatype(::JLD.JldFile, ::HDF5.HDF5Datatype) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:701; [6] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [7] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:502; [8] jlconvert(::Type{Model}, ::JLD.JldFile, ::Ptr{UInt8}) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:387; [9] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:398; [10] read(::JLD",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/141
https://github.com/CliMA/Oceananigans.jl/issues/141:3215,Performance,load,loading,3215,"(::JLD.JldFile, ::HDF5.HDF5Datatype) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:701; [6] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [7] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:502; [8] jlconvert(::Type{Model}, ::JLD.JldFile, ::Ptr{UInt8}) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:387; [9] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:398; [10] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [11] read(::JLD.JldFile, ::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:346; [12] restore_from_checkpoint(::String) at D:\Home\Git\Oceananigans.jl\src\output_writers.jl:77; [13] run_basic_checkpointer_tests() at D:\Home\Git\Oceananigans.jl\test\test_output_writers.jl:34; [14] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:247; [15] top-level scope at C:\cygwin\home\Administrator\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.1\Test\src\Test.jl:1083; [16] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:247; [17] top-level scope at C:\cygwin\home\Administrator\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.1\Test\src\Test.jl:1083; [18] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:244; [19] top-level scope at C:\cygwin\home\Administrator\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.1\Test\src\Test.jl:1083; [20] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:243; [21] include at .\boot.jl:326 [inlined]; [22] include_relative(::Module, ::String) at .\loading.jl:1038; [23] include(::Module, ::String) at .\sysimg.jl:29; [24] include(::String) at .\client.jl:403; [25] top-level scope at none:0; [26] eval(::Module, ::Any) at .\boot.jl:328; [27] exec_options(::Base.JLOptions) at .\client.jl:243; [28] _start() at .\client.jl:436; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/141
https://github.com/CliMA/Oceananigans.jl/issues/141:208,Safety,avoid,avoid,208,"I cannot get the checkpointing test running in PR #140 as JLD is not able to serialize the model to disk with forcing functions. We can go back to forcing arrays but we I think that's a bad idea as we should avoid increasing GPU memory usage. I believe that [JLD2.jl](https://github.com/JuliaIO/JLD2.jl) might be able to serialize functions to disk but it's not actively maintained anymore and their README says ""If your tolerance for data loss is low, JLD may be a better choice at this time."". If we can fix this and figure out how to serialize functions to disk, then we may also be able to serialize the FFTW and CuFFT plans to disk (although we might still want to reconstruct them as in case the model is restored on a different computer with a different architecture). Stacktrace:; ```julia; Deserializing model from disk: test_model_checkpoint_5.jld; error parsing type string Oceananigans.Forcing{Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func}; Checkpointing: Error During Test at D:\Home\Git\Oceananigans.jl\test\runtests.jl:246; Got exception outside of a @test; syntax: incomplete: premature end of input; Stacktrace:; [1] eval at .\boot.jl:328 [inlined]; [2] eval at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:3 [inlined]; [3] _julia_type(::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:983; [4] julia_type(::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:30; [5] jldatatype(::JLD.JldFile, ::HDF5.HDF5Datatype) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:701; [6] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [7] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:502; [8] jlconvert(::Type{Model}, ::JLD.JldFile, ::Ptr{UInt8}) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:387; [9] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at C:\Users\Ali\.julia",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/141
https://github.com/CliMA/Oceananigans.jl/issues/141:31,Testability,test,test,31,"I cannot get the checkpointing test running in PR #140 as JLD is not able to serialize the model to disk with forcing functions. We can go back to forcing arrays but we I think that's a bad idea as we should avoid increasing GPU memory usage. I believe that [JLD2.jl](https://github.com/JuliaIO/JLD2.jl) might be able to serialize functions to disk but it's not actively maintained anymore and their README says ""If your tolerance for data loss is low, JLD may be a better choice at this time."". If we can fix this and figure out how to serialize functions to disk, then we may also be able to serialize the FFTW and CuFFT plans to disk (although we might still want to reconstruct them as in case the model is restored on a different computer with a different architecture). Stacktrace:; ```julia; Deserializing model from disk: test_model_checkpoint_5.jld; error parsing type string Oceananigans.Forcing{Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func}; Checkpointing: Error During Test at D:\Home\Git\Oceananigans.jl\test\runtests.jl:246; Got exception outside of a @test; syntax: incomplete: premature end of input; Stacktrace:; [1] eval at .\boot.jl:328 [inlined]; [2] eval at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:3 [inlined]; [3] _julia_type(::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:983; [4] julia_type(::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:30; [5] jldatatype(::JLD.JldFile, ::HDF5.HDF5Datatype) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:701; [6] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [7] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:502; [8] jlconvert(::Type{Model}, ::JLD.JldFile, ::Ptr{UInt8}) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:387; [9] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at C:\Users\Ali\.julia",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/141
https://github.com/CliMA/Oceananigans.jl/issues/141:1056,Testability,Test,Test,1056,"40 as JLD is not able to serialize the model to disk with forcing functions. We can go back to forcing arrays but we I think that's a bad idea as we should avoid increasing GPU memory usage. I believe that [JLD2.jl](https://github.com/JuliaIO/JLD2.jl) might be able to serialize functions to disk but it's not actively maintained anymore and their README says ""If your tolerance for data loss is low, JLD may be a better choice at this time."". If we can fix this and figure out how to serialize functions to disk, then we may also be able to serialize the FFTW and CuFFT plans to disk (although we might still want to reconstruct them as in case the model is restored on a different computer with a different architecture). Stacktrace:; ```julia; Deserializing model from disk: test_model_checkpoint_5.jld; error parsing type string Oceananigans.Forcing{Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func}; Checkpointing: Error During Test at D:\Home\Git\Oceananigans.jl\test\runtests.jl:246; Got exception outside of a @test; syntax: incomplete: premature end of input; Stacktrace:; [1] eval at .\boot.jl:328 [inlined]; [2] eval at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:3 [inlined]; [3] _julia_type(::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:983; [4] julia_type(::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:30; [5] jldatatype(::JLD.JldFile, ::HDF5.HDF5Datatype) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:701; [6] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [7] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:502; [8] jlconvert(::Type{Model}, ::JLD.JldFile, ::Ptr{UInt8}) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:387; [9] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:398; [10] read(::JLD",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/141
https://github.com/CliMA/Oceananigans.jl/issues/141:1092,Testability,test,test,1092,"to disk with forcing functions. We can go back to forcing arrays but we I think that's a bad idea as we should avoid increasing GPU memory usage. I believe that [JLD2.jl](https://github.com/JuliaIO/JLD2.jl) might be able to serialize functions to disk but it's not actively maintained anymore and their README says ""If your tolerance for data loss is low, JLD may be a better choice at this time."". If we can fix this and figure out how to serialize functions to disk, then we may also be able to serialize the FFTW and CuFFT plans to disk (although we might still want to reconstruct them as in case the model is restored on a different computer with a different architecture). Stacktrace:; ```julia; Deserializing model from disk: test_model_checkpoint_5.jld; error parsing type string Oceananigans.Forcing{Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func}; Checkpointing: Error During Test at D:\Home\Git\Oceananigans.jl\test\runtests.jl:246; Got exception outside of a @test; syntax: incomplete: premature end of input; Stacktrace:; [1] eval at .\boot.jl:328 [inlined]; [2] eval at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:3 [inlined]; [3] _julia_type(::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:983; [4] julia_type(::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:30; [5] jldatatype(::JLD.JldFile, ::HDF5.HDF5Datatype) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:701; [6] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [7] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:502; [8] jlconvert(::Type{Model}, ::JLD.JldFile, ::Ptr{UInt8}) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:387; [9] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:398; [10] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\J",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/141
https://github.com/CliMA/Oceananigans.jl/issues/141:1142,Testability,test,test,1142,"but we I think that's a bad idea as we should avoid increasing GPU memory usage. I believe that [JLD2.jl](https://github.com/JuliaIO/JLD2.jl) might be able to serialize functions to disk but it's not actively maintained anymore and their README says ""If your tolerance for data loss is low, JLD may be a better choice at this time."". If we can fix this and figure out how to serialize functions to disk, then we may also be able to serialize the FFTW and CuFFT plans to disk (although we might still want to reconstruct them as in case the model is restored on a different computer with a different architecture). Stacktrace:; ```julia; Deserializing model from disk: test_model_checkpoint_5.jld; error parsing type string Oceananigans.Forcing{Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func}; Checkpointing: Error During Test at D:\Home\Git\Oceananigans.jl\test\runtests.jl:246; Got exception outside of a @test; syntax: incomplete: premature end of input; Stacktrace:; [1] eval at .\boot.jl:328 [inlined]; [2] eval at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:3 [inlined]; [3] _julia_type(::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:983; [4] julia_type(::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:30; [5] jldatatype(::JLD.JldFile, ::HDF5.HDF5Datatype) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:701; [6] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [7] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:502; [8] jlconvert(::Type{Model}, ::JLD.JldFile, ::Ptr{UInt8}) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:387; [9] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:398; [10] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [11] read(::JLD.JldFile, ::String) at C",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/141
https://github.com/CliMA/Oceananigans.jl/issues/141:2379,Testability,test,test,2379,"LD.jl:983; [4] julia_type(::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:30; [5] jldatatype(::JLD.JldFile, ::HDF5.HDF5Datatype) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:701; [6] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [7] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:502; [8] jlconvert(::Type{Model}, ::JLD.JldFile, ::Ptr{UInt8}) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:387; [9] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:398; [10] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [11] read(::JLD.JldFile, ::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:346; [12] restore_from_checkpoint(::String) at D:\Home\Git\Oceananigans.jl\src\output_writers.jl:77; [13] run_basic_checkpointer_tests() at D:\Home\Git\Oceananigans.jl\test\test_output_writers.jl:34; [14] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:247; [15] top-level scope at C:\cygwin\home\Administrator\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.1\Test\src\Test.jl:1083; [16] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:247; [17] top-level scope at C:\cygwin\home\Administrator\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.1\Test\src\Test.jl:1083; [18] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:244; [19] top-level scope at C:\cygwin\home\Administrator\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.1\Test\src\Test.jl:1083; [20] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:243; [21] include at .\boot.jl:326 [inlined]; [22] include_relative(::Module, ::String) at .\loading.jl:1038; [23] include(::Module, ::String) at .\sysimg.jl:29; [24] include(::String) at .\client.jl:403; [25] top-level scope at none:0; [26] eval(::Module, ::Any) at .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/141
https://github.com/CliMA/Oceananigans.jl/issues/141:2463,Testability,test,test,2463,"src\JLD.jl:30; [5] jldatatype(::JLD.JldFile, ::HDF5.HDF5Datatype) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:701; [6] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [7] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:502; [8] jlconvert(::Type{Model}, ::JLD.JldFile, ::Ptr{UInt8}) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:387; [9] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:398; [10] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [11] read(::JLD.JldFile, ::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:346; [12] restore_from_checkpoint(::String) at D:\Home\Git\Oceananigans.jl\src\output_writers.jl:77; [13] run_basic_checkpointer_tests() at D:\Home\Git\Oceananigans.jl\test\test_output_writers.jl:34; [14] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:247; [15] top-level scope at C:\cygwin\home\Administrator\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.1\Test\src\Test.jl:1083; [16] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:247; [17] top-level scope at C:\cygwin\home\Administrator\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.1\Test\src\Test.jl:1083; [18] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:244; [19] top-level scope at C:\cygwin\home\Administrator\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.1\Test\src\Test.jl:1083; [20] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:243; [21] include at .\boot.jl:326 [inlined]; [22] include_relative(::Module, ::String) at .\loading.jl:1038; [23] include(::Module, ::String) at .\sysimg.jl:29; [24] include(::String) at .\client.jl:403; [25] top-level scope at none:0; [26] eval(::Module, ::Any) at .\boot.jl:328; [27] exec_options(::Base.JLOptions) at .\client.jl:243; [28] _sta",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/141
https://github.com/CliMA/Oceananigans.jl/issues/141:2602,Testability,Test,Test,2602,"(::JLD.JldFile, ::HDF5.HDF5Datatype) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:701; [6] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [7] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:502; [8] jlconvert(::Type{Model}, ::JLD.JldFile, ::Ptr{UInt8}) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:387; [9] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:398; [10] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [11] read(::JLD.JldFile, ::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:346; [12] restore_from_checkpoint(::String) at D:\Home\Git\Oceananigans.jl\src\output_writers.jl:77; [13] run_basic_checkpointer_tests() at D:\Home\Git\Oceananigans.jl\test\test_output_writers.jl:34; [14] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:247; [15] top-level scope at C:\cygwin\home\Administrator\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.1\Test\src\Test.jl:1083; [16] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:247; [17] top-level scope at C:\cygwin\home\Administrator\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.1\Test\src\Test.jl:1083; [18] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:244; [19] top-level scope at C:\cygwin\home\Administrator\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.1\Test\src\Test.jl:1083; [20] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:243; [21] include at .\boot.jl:326 [inlined]; [22] include_relative(::Module, ::String) at .\loading.jl:1038; [23] include(::Module, ::String) at .\sysimg.jl:29; [24] include(::String) at .\client.jl:403; [25] top-level scope at none:0; [26] eval(::Module, ::Any) at .\boot.jl:328; [27] exec_options(::Base.JLOptions) at .\client.jl:243; [28] _start() at .\client.jl:436; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/141
https://github.com/CliMA/Oceananigans.jl/issues/141:2611,Testability,Test,Test,2611,"(::JLD.JldFile, ::HDF5.HDF5Datatype) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:701; [6] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [7] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:502; [8] jlconvert(::Type{Model}, ::JLD.JldFile, ::Ptr{UInt8}) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:387; [9] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:398; [10] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [11] read(::JLD.JldFile, ::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:346; [12] restore_from_checkpoint(::String) at D:\Home\Git\Oceananigans.jl\src\output_writers.jl:77; [13] run_basic_checkpointer_tests() at D:\Home\Git\Oceananigans.jl\test\test_output_writers.jl:34; [14] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:247; [15] top-level scope at C:\cygwin\home\Administrator\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.1\Test\src\Test.jl:1083; [16] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:247; [17] top-level scope at C:\cygwin\home\Administrator\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.1\Test\src\Test.jl:1083; [18] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:244; [19] top-level scope at C:\cygwin\home\Administrator\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.1\Test\src\Test.jl:1083; [20] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:243; [21] include at .\boot.jl:326 [inlined]; [22] include_relative(::Module, ::String) at .\loading.jl:1038; [23] include(::Module, ::String) at .\sysimg.jl:29; [24] include(::String) at .\client.jl:403; [25] top-level scope at none:0; [26] eval(::Module, ::Any) at .\boot.jl:328; [27] exec_options(::Base.JLOptions) at .\client.jl:243; [28] _start() at .\client.jl:436; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/141
https://github.com/CliMA/Oceananigans.jl/issues/141:2677,Testability,test,test,2677,"(::JLD.JldFile, ::HDF5.HDF5Datatype) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:701; [6] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [7] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:502; [8] jlconvert(::Type{Model}, ::JLD.JldFile, ::Ptr{UInt8}) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:387; [9] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:398; [10] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [11] read(::JLD.JldFile, ::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:346; [12] restore_from_checkpoint(::String) at D:\Home\Git\Oceananigans.jl\src\output_writers.jl:77; [13] run_basic_checkpointer_tests() at D:\Home\Git\Oceananigans.jl\test\test_output_writers.jl:34; [14] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:247; [15] top-level scope at C:\cygwin\home\Administrator\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.1\Test\src\Test.jl:1083; [16] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:247; [17] top-level scope at C:\cygwin\home\Administrator\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.1\Test\src\Test.jl:1083; [18] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:244; [19] top-level scope at C:\cygwin\home\Administrator\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.1\Test\src\Test.jl:1083; [20] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:243; [21] include at .\boot.jl:326 [inlined]; [22] include_relative(::Module, ::String) at .\loading.jl:1038; [23] include(::Module, ::String) at .\sysimg.jl:29; [24] include(::String) at .\client.jl:403; [25] top-level scope at none:0; [26] eval(::Module, ::Any) at .\boot.jl:328; [27] exec_options(::Base.JLOptions) at .\client.jl:243; [28] _start() at .\client.jl:436; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/141
https://github.com/CliMA/Oceananigans.jl/issues/141:2816,Testability,Test,Test,2816,"(::JLD.JldFile, ::HDF5.HDF5Datatype) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:701; [6] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [7] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:502; [8] jlconvert(::Type{Model}, ::JLD.JldFile, ::Ptr{UInt8}) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:387; [9] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:398; [10] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [11] read(::JLD.JldFile, ::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:346; [12] restore_from_checkpoint(::String) at D:\Home\Git\Oceananigans.jl\src\output_writers.jl:77; [13] run_basic_checkpointer_tests() at D:\Home\Git\Oceananigans.jl\test\test_output_writers.jl:34; [14] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:247; [15] top-level scope at C:\cygwin\home\Administrator\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.1\Test\src\Test.jl:1083; [16] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:247; [17] top-level scope at C:\cygwin\home\Administrator\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.1\Test\src\Test.jl:1083; [18] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:244; [19] top-level scope at C:\cygwin\home\Administrator\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.1\Test\src\Test.jl:1083; [20] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:243; [21] include at .\boot.jl:326 [inlined]; [22] include_relative(::Module, ::String) at .\loading.jl:1038; [23] include(::Module, ::String) at .\sysimg.jl:29; [24] include(::String) at .\client.jl:403; [25] top-level scope at none:0; [26] eval(::Module, ::Any) at .\boot.jl:328; [27] exec_options(::Base.JLOptions) at .\client.jl:243; [28] _start() at .\client.jl:436; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/141
https://github.com/CliMA/Oceananigans.jl/issues/141:2825,Testability,Test,Test,2825,"(::JLD.JldFile, ::HDF5.HDF5Datatype) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:701; [6] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [7] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:502; [8] jlconvert(::Type{Model}, ::JLD.JldFile, ::Ptr{UInt8}) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:387; [9] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:398; [10] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [11] read(::JLD.JldFile, ::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:346; [12] restore_from_checkpoint(::String) at D:\Home\Git\Oceananigans.jl\src\output_writers.jl:77; [13] run_basic_checkpointer_tests() at D:\Home\Git\Oceananigans.jl\test\test_output_writers.jl:34; [14] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:247; [15] top-level scope at C:\cygwin\home\Administrator\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.1\Test\src\Test.jl:1083; [16] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:247; [17] top-level scope at C:\cygwin\home\Administrator\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.1\Test\src\Test.jl:1083; [18] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:244; [19] top-level scope at C:\cygwin\home\Administrator\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.1\Test\src\Test.jl:1083; [20] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:243; [21] include at .\boot.jl:326 [inlined]; [22] include_relative(::Module, ::String) at .\loading.jl:1038; [23] include(::Module, ::String) at .\sysimg.jl:29; [24] include(::String) at .\client.jl:403; [25] top-level scope at none:0; [26] eval(::Module, ::Any) at .\boot.jl:328; [27] exec_options(::Base.JLOptions) at .\client.jl:243; [28] _start() at .\client.jl:436; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/141
https://github.com/CliMA/Oceananigans.jl/issues/141:2891,Testability,test,test,2891,"(::JLD.JldFile, ::HDF5.HDF5Datatype) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:701; [6] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [7] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:502; [8] jlconvert(::Type{Model}, ::JLD.JldFile, ::Ptr{UInt8}) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:387; [9] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:398; [10] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [11] read(::JLD.JldFile, ::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:346; [12] restore_from_checkpoint(::String) at D:\Home\Git\Oceananigans.jl\src\output_writers.jl:77; [13] run_basic_checkpointer_tests() at D:\Home\Git\Oceananigans.jl\test\test_output_writers.jl:34; [14] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:247; [15] top-level scope at C:\cygwin\home\Administrator\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.1\Test\src\Test.jl:1083; [16] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:247; [17] top-level scope at C:\cygwin\home\Administrator\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.1\Test\src\Test.jl:1083; [18] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:244; [19] top-level scope at C:\cygwin\home\Administrator\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.1\Test\src\Test.jl:1083; [20] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:243; [21] include at .\boot.jl:326 [inlined]; [22] include_relative(::Module, ::String) at .\loading.jl:1038; [23] include(::Module, ::String) at .\sysimg.jl:29; [24] include(::String) at .\client.jl:403; [25] top-level scope at none:0; [26] eval(::Module, ::Any) at .\boot.jl:328; [27] exec_options(::Base.JLOptions) at .\client.jl:243; [28] _start() at .\client.jl:436; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/141
https://github.com/CliMA/Oceananigans.jl/issues/141:3030,Testability,Test,Test,3030,"(::JLD.JldFile, ::HDF5.HDF5Datatype) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:701; [6] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [7] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:502; [8] jlconvert(::Type{Model}, ::JLD.JldFile, ::Ptr{UInt8}) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:387; [9] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:398; [10] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [11] read(::JLD.JldFile, ::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:346; [12] restore_from_checkpoint(::String) at D:\Home\Git\Oceananigans.jl\src\output_writers.jl:77; [13] run_basic_checkpointer_tests() at D:\Home\Git\Oceananigans.jl\test\test_output_writers.jl:34; [14] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:247; [15] top-level scope at C:\cygwin\home\Administrator\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.1\Test\src\Test.jl:1083; [16] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:247; [17] top-level scope at C:\cygwin\home\Administrator\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.1\Test\src\Test.jl:1083; [18] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:244; [19] top-level scope at C:\cygwin\home\Administrator\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.1\Test\src\Test.jl:1083; [20] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:243; [21] include at .\boot.jl:326 [inlined]; [22] include_relative(::Module, ::String) at .\loading.jl:1038; [23] include(::Module, ::String) at .\sysimg.jl:29; [24] include(::String) at .\client.jl:403; [25] top-level scope at none:0; [26] eval(::Module, ::Any) at .\boot.jl:328; [27] exec_options(::Base.JLOptions) at .\client.jl:243; [28] _start() at .\client.jl:436; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/141
https://github.com/CliMA/Oceananigans.jl/issues/141:3039,Testability,Test,Test,3039,"(::JLD.JldFile, ::HDF5.HDF5Datatype) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:701; [6] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [7] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:502; [8] jlconvert(::Type{Model}, ::JLD.JldFile, ::Ptr{UInt8}) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:387; [9] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:398; [10] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [11] read(::JLD.JldFile, ::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:346; [12] restore_from_checkpoint(::String) at D:\Home\Git\Oceananigans.jl\src\output_writers.jl:77; [13] run_basic_checkpointer_tests() at D:\Home\Git\Oceananigans.jl\test\test_output_writers.jl:34; [14] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:247; [15] top-level scope at C:\cygwin\home\Administrator\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.1\Test\src\Test.jl:1083; [16] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:247; [17] top-level scope at C:\cygwin\home\Administrator\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.1\Test\src\Test.jl:1083; [18] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:244; [19] top-level scope at C:\cygwin\home\Administrator\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.1\Test\src\Test.jl:1083; [20] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:243; [21] include at .\boot.jl:326 [inlined]; [22] include_relative(::Module, ::String) at .\loading.jl:1038; [23] include(::Module, ::String) at .\sysimg.jl:29; [24] include(::String) at .\client.jl:403; [25] top-level scope at none:0; [26] eval(::Module, ::Any) at .\boot.jl:328; [27] exec_options(::Base.JLOptions) at .\client.jl:243; [28] _start() at .\client.jl:436; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/141
https://github.com/CliMA/Oceananigans.jl/issues/141:3105,Testability,test,test,3105,"(::JLD.JldFile, ::HDF5.HDF5Datatype) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:701; [6] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [7] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:502; [8] jlconvert(::Type{Model}, ::JLD.JldFile, ::Ptr{UInt8}) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:387; [9] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:398; [10] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [11] read(::JLD.JldFile, ::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:346; [12] restore_from_checkpoint(::String) at D:\Home\Git\Oceananigans.jl\src\output_writers.jl:77; [13] run_basic_checkpointer_tests() at D:\Home\Git\Oceananigans.jl\test\test_output_writers.jl:34; [14] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:247; [15] top-level scope at C:\cygwin\home\Administrator\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.1\Test\src\Test.jl:1083; [16] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:247; [17] top-level scope at C:\cygwin\home\Administrator\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.1\Test\src\Test.jl:1083; [18] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:244; [19] top-level scope at C:\cygwin\home\Administrator\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.1\Test\src\Test.jl:1083; [20] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:243; [21] include at .\boot.jl:326 [inlined]; [22] include_relative(::Module, ::String) at .\loading.jl:1038; [23] include(::Module, ::String) at .\sysimg.jl:29; [24] include(::String) at .\client.jl:403; [25] top-level scope at none:0; [26] eval(::Module, ::Any) at .\boot.jl:328; [27] exec_options(::Base.JLOptions) at .\client.jl:243; [28] _start() at .\client.jl:436; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/141
https://github.com/CliMA/Oceananigans.jl/issues/142:166,Availability,error,error,166,"I tried submitting it as a package through an attobot request a few weeks ago but the PR build failed on METADATA.jl and I'm not sure why. Well, I think this was the error but not sure what to do about it as I put Julia 1.1 in the REQUIRE file.; ```; ERROR: LoadError: METADATA/Oceananigans/versions/0.4.0/requires: no julia entry (>= 0.6.0 needed); ```. See:; * https://github.com/JuliaLang/METADATA.jl/pull/21774",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/142
https://github.com/CliMA/Oceananigans.jl/issues/142:251,Availability,ERROR,ERROR,251,"I tried submitting it as a package through an attobot request a few weeks ago but the PR build failed on METADATA.jl and I'm not sure why. Well, I think this was the error but not sure what to do about it as I put Julia 1.1 in the REQUIRE file.; ```; ERROR: LoadError: METADATA/Oceananigans/versions/0.4.0/requires: no julia entry (>= 0.6.0 needed); ```. See:; * https://github.com/JuliaLang/METADATA.jl/pull/21774",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/142
https://github.com/CliMA/Oceananigans.jl/issues/142:258,Performance,Load,LoadError,258,"I tried submitting it as a package through an attobot request a few weeks ago but the PR build failed on METADATA.jl and I'm not sure why. Well, I think this was the error but not sure what to do about it as I put Julia 1.1 in the REQUIRE file.; ```; ERROR: LoadError: METADATA/Oceananigans/versions/0.4.0/requires: no julia entry (>= 0.6.0 needed); ```. See:; * https://github.com/JuliaLang/METADATA.jl/pull/21774",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/142
https://github.com/CliMA/Oceananigans.jl/issues/144:103,Deployability,configurat,configurations,103,"Would be nice to specify a list of e.g. 32 parameters and just spin off 32 models running in different configurations, maybe on Google Cloud. I think this is something Chris might have already figured out:; * https://github.com/christophernhill/oceananiganshacks; * https://github.com/ali-ramadhan/gcloudhacks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/144
https://github.com/CliMA/Oceananigans.jl/issues/144:103,Modifiability,config,configurations,103,"Would be nice to specify a list of e.g. 32 parameters and just spin off 32 models running in different configurations, maybe on Google Cloud. I think this is something Chris might have already figured out:; * https://github.com/christophernhill/oceananiganshacks; * https://github.com/ali-ramadhan/gcloudhacks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/144
https://github.com/CliMA/Oceananigans.jl/issues/145:1496,Modifiability,portab,portable,1496,"ng packages. An alternative would be to use the much more mature [netcdf4-python](http://unidata.github.io/netcdf4-python/) but I'd rather not have to use PyCall...; > ; > _Originally posted by @ali-ramadhan in https://github.com/climate-machine/Oceananigans.jl/issues/31#issuecomment-468288154_. Some more comments:; * Right now NetCDF output is much slower than expected. We have asynchronous output writing #137 but spending 2-3 minutes to write out the fields of a 256³ grid is ridiculous.; * Compression doesn't seem to work in NetCDF.jl: See https://github.com/JuliaGeo/NetCDF.jl/issues/87; * We might want to share this output writing feature with CliMA.jl. See https://github.com/climate-machine/CLIMA/issues/114; * @simonbyrne and @charleskawczynski suggested looking at [HDF5.jl](https://github.com/JuliaIO/HDF5.jl). As NetCDF4 is built on HDF5, we should be able to generate valid NetCDF files with it.; * Whatever we end up doing, @christophernhill makes a good point that we should produce portable NetCDF files as this is what all our potential users would expect and want.; * Thinking more long-term @lcw says that IO performance is a hard problem and thinks we are going to want something that plays well on clusters (e.g., something MPI IO based). Some extra features we might want in the short-term:; - [ ] Option to only write out a specific subset of the model state, e.g. surface velocities only, or a vertical temperature slice. This would really speed up IO if you don't need full 3D fields.; - [ ] Select which fields to write out to NetCDF.; - [ ] Include diagnostics in NetCDF output. I believe this will be possible if we resolve the item above as output writing occurs right after diagnostics are run, so diagnostic fields can just be included as one of the fields to write out.; - [ ] Option to create one NetCDF file for each iteration, or to combine all output into one NeCDF file. I think the main point of this issue is that we should decide how to output NetCDF. Pac",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/145
https://github.com/CliMA/Oceananigans.jl/issues/145:1626,Performance,perform,performance,1626,"ata.github.io/netcdf4-python/) but I'd rather not have to use PyCall...; > ; > _Originally posted by @ali-ramadhan in https://github.com/climate-machine/Oceananigans.jl/issues/31#issuecomment-468288154_. Some more comments:; * Right now NetCDF output is much slower than expected. We have asynchronous output writing #137 but spending 2-3 minutes to write out the fields of a 256³ grid is ridiculous.; * Compression doesn't seem to work in NetCDF.jl: See https://github.com/JuliaGeo/NetCDF.jl/issues/87; * We might want to share this output writing feature with CliMA.jl. See https://github.com/climate-machine/CLIMA/issues/114; * @simonbyrne and @charleskawczynski suggested looking at [HDF5.jl](https://github.com/JuliaIO/HDF5.jl). As NetCDF4 is built on HDF5, we should be able to generate valid NetCDF files with it.; * Whatever we end up doing, @christophernhill makes a good point that we should produce portable NetCDF files as this is what all our potential users would expect and want.; * Thinking more long-term @lcw says that IO performance is a hard problem and thinks we are going to want something that plays well on clusters (e.g., something MPI IO based). Some extra features we might want in the short-term:; - [ ] Option to only write out a specific subset of the model state, e.g. surface velocities only, or a vertical temperature slice. This would really speed up IO if you don't need full 3D fields.; - [ ] Select which fields to write out to NetCDF.; - [ ] Include diagnostics in NetCDF output. I believe this will be possible if we resolve the item above as output writing occurs right after diagnostics are run, so diagnostic fields can just be included as one of the fields to write out.; - [ ] Option to create one NetCDF file for each iteration, or to combine all output into one NeCDF file. I think the main point of this issue is that we should decide how to output NetCDF. Packages we could choose from are NCDatasets.jl and HDF5.jl. Or we could go with something else.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/145
https://github.com/CliMA/Oceananigans.jl/issues/146:756,Integrability,Interface,Interface,756,"> @jm-c and I talked today and we have an additional point to make (this is related to #115 as well).; > ; > Notice first that the [operators `δz_f2c` and `δz_e2f`](https://github.com/glwagner/Oceananigans.jl/blob/3307031283dab154d32c071c47d9e275f1a6e17e/src/operators/ops_regular_cartesian_grid.jl#L29) are identical:; > ; > ```julia; > @inline function δz_f2c(f, Nz, i, j, k); > if k == Nz; > @inbounds return f[i, j, k]; > else; > @inbounds return f[i, j, k] - f[i, j, k+1]; > end; > end; > ; > @inline function δz_e2f(f, Nz, i, j, k); > if k == Nz; > @inbounds return f[i, j, k]; > else; > @inbounds return f[i, j, k] - f[i, j, k+1]; > end; > end; > ```; > ; > Our solution:; > ; > ```julia; > abstract type Location end; > struct Center end; > struct Interface end; > ; > struct Field{Lx<:Location, Ly<:Location, Lz<:Location, A, G}; > data::A; > grid::G; > end; > ```; > ; > we then need only two `δz` functions that dispatch on `Lz`; for example:; > ; > ```julia; > δz(f::Field{Lx, Ly, Lz}, i, j, k) where {Lx, Ly, Lz<:Center} = ...; > δz(f::Field{Lx, Ly, Lz}, i, j, k) where {Lx, Ly, Lz<:Interface} = ...; > ```; > ; > _Originally posted by @glwagner in https://github.com/climate-machine/Oceananigans.jl/issues/59#issuecomment-471136259_. Also see discussion that followed for more clarification.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/146
https://github.com/CliMA/Oceananigans.jl/issues/146:1096,Integrability,Interface,Interface,1096,"> @jm-c and I talked today and we have an additional point to make (this is related to #115 as well).; > ; > Notice first that the [operators `δz_f2c` and `δz_e2f`](https://github.com/glwagner/Oceananigans.jl/blob/3307031283dab154d32c071c47d9e275f1a6e17e/src/operators/ops_regular_cartesian_grid.jl#L29) are identical:; > ; > ```julia; > @inline function δz_f2c(f, Nz, i, j, k); > if k == Nz; > @inbounds return f[i, j, k]; > else; > @inbounds return f[i, j, k] - f[i, j, k+1]; > end; > end; > ; > @inline function δz_e2f(f, Nz, i, j, k); > if k == Nz; > @inbounds return f[i, j, k]; > else; > @inbounds return f[i, j, k] - f[i, j, k+1]; > end; > end; > ```; > ; > Our solution:; > ; > ```julia; > abstract type Location end; > struct Center end; > struct Interface end; > ; > struct Field{Lx<:Location, Ly<:Location, Lz<:Location, A, G}; > data::A; > grid::G; > end; > ```; > ; > we then need only two `δz` functions that dispatch on `Lz`; for example:; > ; > ```julia; > δz(f::Field{Lx, Ly, Lz}, i, j, k) where {Lx, Ly, Lz<:Center} = ...; > δz(f::Field{Lx, Ly, Lz}, i, j, k) where {Lx, Ly, Lz<:Interface} = ...; > ```; > ; > _Originally posted by @glwagner in https://github.com/climate-machine/Oceananigans.jl/issues/59#issuecomment-471136259_. Also see discussion that followed for more clarification.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/146
https://github.com/CliMA/Oceananigans.jl/pull/147:381,Deployability,update,updated,381,"This PR refactors many of the existing abstractions so that they can be passed to GPU kernels #59. It massively cleans up the operators and time-stepping loop, allowing us to keep using beautiful abstractions even in GPU kernels. Note that after this PR is merged, `CUDAnative#master` and `GPUifyLoops#vc/interactive` will be required until the respective fixes are merged into an updated release. I will update the `Project.toml` when we can move to a new release. Once this is merged I will also release v0.5.0. When completed and merged this PR will:; Resolve #19; Resolve #59; Resolve #60; Resolve #66; Resolve #74 ; Resolve #133 ; Resolve #153",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/147
https://github.com/CliMA/Oceananigans.jl/pull/147:389,Deployability,release,release,389,"This PR refactors many of the existing abstractions so that they can be passed to GPU kernels #59. It massively cleans up the operators and time-stepping loop, allowing us to keep using beautiful abstractions even in GPU kernels. Note that after this PR is merged, `CUDAnative#master` and `GPUifyLoops#vc/interactive` will be required until the respective fixes are merged into an updated release. I will update the `Project.toml` when we can move to a new release. Once this is merged I will also release v0.5.0. When completed and merged this PR will:; Resolve #19; Resolve #59; Resolve #60; Resolve #66; Resolve #74 ; Resolve #133 ; Resolve #153",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/147
https://github.com/CliMA/Oceananigans.jl/pull/147:405,Deployability,update,update,405,"This PR refactors many of the existing abstractions so that they can be passed to GPU kernels #59. It massively cleans up the operators and time-stepping loop, allowing us to keep using beautiful abstractions even in GPU kernels. Note that after this PR is merged, `CUDAnative#master` and `GPUifyLoops#vc/interactive` will be required until the respective fixes are merged into an updated release. I will update the `Project.toml` when we can move to a new release. Once this is merged I will also release v0.5.0. When completed and merged this PR will:; Resolve #19; Resolve #59; Resolve #60; Resolve #66; Resolve #74 ; Resolve #133 ; Resolve #153",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/147
https://github.com/CliMA/Oceananigans.jl/pull/147:457,Deployability,release,release,457,"This PR refactors many of the existing abstractions so that they can be passed to GPU kernels #59. It massively cleans up the operators and time-stepping loop, allowing us to keep using beautiful abstractions even in GPU kernels. Note that after this PR is merged, `CUDAnative#master` and `GPUifyLoops#vc/interactive` will be required until the respective fixes are merged into an updated release. I will update the `Project.toml` when we can move to a new release. Once this is merged I will also release v0.5.0. When completed and merged this PR will:; Resolve #19; Resolve #59; Resolve #60; Resolve #66; Resolve #74 ; Resolve #133 ; Resolve #153",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/147
https://github.com/CliMA/Oceananigans.jl/pull/147:498,Deployability,release,release,498,"This PR refactors many of the existing abstractions so that they can be passed to GPU kernels #59. It massively cleans up the operators and time-stepping loop, allowing us to keep using beautiful abstractions even in GPU kernels. Note that after this PR is merged, `CUDAnative#master` and `GPUifyLoops#vc/interactive` will be required until the respective fixes are merged into an updated release. I will update the `Project.toml` when we can move to a new release. Once this is merged I will also release v0.5.0. When completed and merged this PR will:; Resolve #19; Resolve #59; Resolve #60; Resolve #66; Resolve #74 ; Resolve #133 ; Resolve #153",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/147
https://github.com/CliMA/Oceananigans.jl/pull/147:8,Modifiability,refactor,refactors,8,"This PR refactors many of the existing abstractions so that they can be passed to GPU kernels #59. It massively cleans up the operators and time-stepping loop, allowing us to keep using beautiful abstractions even in GPU kernels. Note that after this PR is merged, `CUDAnative#master` and `GPUifyLoops#vc/interactive` will be required until the respective fixes are merged into an updated release. I will update the `Project.toml` when we can move to a new release. Once this is merged I will also release v0.5.0. When completed and merged this PR will:; Resolve #19; Resolve #59; Resolve #60; Resolve #66; Resolve #74 ; Resolve #133 ; Resolve #153",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/147
https://github.com/CliMA/Oceananigans.jl/pull/148:15,Availability,avail,available,15,Also:; * Print available `CuDevice`s at startup; * Throw `ArgumentError` when attempting to construct a `Model{GPU}` when no CUDA-enabled GPU is detected. Resolves #82,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/148
https://github.com/CliMA/Oceananigans.jl/pull/148:145,Safety,detect,detected,145,Also:; * Print available `CuDevice`s at startup; * Throw `ArgumentError` when attempting to construct a `Model{GPU}` when no CUDA-enabled GPU is detected. Resolves #82,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/148
https://github.com/CliMA/Oceananigans.jl/issues/151:126,Deployability,integrat,integrate,126,Would be nice to have a Docker image so we have an easy-to-use environment for running Oceananigans. It would also be nice to integrate it into our CI so we know the package build fails. See:; * https://github.com/docker/labs; * https://docs.docker.com/docker-hub/builds/; * https://docs.docker.com/docker-hub/builds/link-source/; * https://repo2docker.readthedocs.io/en/latest/,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/151
https://github.com/CliMA/Oceananigans.jl/issues/151:126,Integrability,integrat,integrate,126,Would be nice to have a Docker image so we have an easy-to-use environment for running Oceananigans. It would also be nice to integrate it into our CI so we know the package build fails. See:; * https://github.com/docker/labs; * https://docs.docker.com/docker-hub/builds/; * https://docs.docker.com/docker-hub/builds/link-source/; * https://repo2docker.readthedocs.io/en/latest/,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/151
https://github.com/CliMA/Oceananigans.jl/issues/152:40,Deployability,install,install,40,"Should have instructions for:; * How to install the package as a user.; * How to `git clone`, `instantiate`, and `test` the package as a developer.; * CPU instructions.; * GPU instructions.; * When #151 is resolved, docker installation instructions. CPU and GPU instructions should not be separate but when #79 is solved, we should be able to run on the CPU without installing (and failing to build) all the CUDA packages.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/152
https://github.com/CliMA/Oceananigans.jl/issues/152:223,Deployability,install,installation,223,"Should have instructions for:; * How to install the package as a user.; * How to `git clone`, `instantiate`, and `test` the package as a developer.; * CPU instructions.; * GPU instructions.; * When #151 is resolved, docker installation instructions. CPU and GPU instructions should not be separate but when #79 is solved, we should be able to run on the CPU without installing (and failing to build) all the CUDA packages.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/152
https://github.com/CliMA/Oceananigans.jl/issues/152:366,Deployability,install,installing,366,"Should have instructions for:; * How to install the package as a user.; * How to `git clone`, `instantiate`, and `test` the package as a developer.; * CPU instructions.; * GPU instructions.; * When #151 is resolved, docker installation instructions. CPU and GPU instructions should not be separate but when #79 is solved, we should be able to run on the CPU without installing (and failing to build) all the CUDA packages.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/152
https://github.com/CliMA/Oceananigans.jl/issues/152:114,Testability,test,test,114,"Should have instructions for:; * How to install the package as a user.; * How to `git clone`, `instantiate`, and `test` the package as a developer.; * CPU instructions.; * GPU instructions.; * When #151 is resolved, docker installation instructions. CPU and GPU instructions should not be separate but when #79 is solved, we should be able to run on the CPU without installing (and failing to build) all the CUDA packages.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/152
https://github.com/CliMA/Oceananigans.jl/issues/153:78,Deployability,release,released,78,Quick test tells me everything works with latest CUDA packages which just got released but will have to refactor a bit to make use of GPUifyLoop's new `@launch` functionality (and remove the `@setup` calls).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/153
https://github.com/CliMA/Oceananigans.jl/issues/153:104,Modifiability,refactor,refactor,104,Quick test tells me everything works with latest CUDA packages which just got released but will have to refactor a bit to make use of GPUifyLoop's new `@launch` functionality (and remove the `@setup` calls).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/153
https://github.com/CliMA/Oceananigans.jl/issues/153:6,Testability,test,test,6,Quick test tells me everything works with latest CUDA packages which just got released but will have to refactor a bit to make use of GPUifyLoop's new `@launch` functionality (and remove the `@setup` calls).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/153
https://github.com/CliMA/Oceananigans.jl/issues/155:281,Deployability,configurat,configuration,281,"Right now we have monstrosities like (this one is a bit extreme); ```julia; Nx, Ny, Nz = model.grid.Nx, model.grid.Ny, model.grid.Nz; Lx, Ly, Lz = model.grid.Lx, model.grid.Ly, model.grid.Lz; Δx, Δy, Δz = model.grid.Δx, model.grid.Δy, model.grid.Δz. grid = model.grid; cfg = model.configuration; bcs = model.boundary_conditions; clock = model.clock. G = model.G; Gp = model.Gp; constants = model.constants; eos = model.eos; U = model.velocities; tr = model.tracers; pr = model.pressures; forcing = model.forcing; poisson_solver = model.poisson_solver. δρ = model.stepper_tmp.fC1; RHS = model.stepper_tmp.fCC1; ϕ = model.stepper_tmp.fCC2. gΔz = model.constants.g * model.grid.Δz; fCor = model.constants.f. uvw = U.u.data, U.v.data, U.w.data; TS = tr.T.data, tr.S.data; Guvw = G.Gu.data, G.Gv.data, G.Gw.data. # Source terms at current (Gⁿ) and previous (G⁻) time steps.; Gⁿ = G.Gu.data, G.Gv.data, G.Gw.data, G.GT.data, G.GS.data; G⁻ = Gp.Gu.data, Gp.Gv.data, Gp.Gw.data, Gp.GT.data, Gp.GS.data; ```. Would be nice to prettify or abstract away this unpacking. @charleskawczynski I noticed you used some @unpack macros in the code you showed on Monday, is it up on GitHub by any chance?. I think [Parameters.jl](https://github.com/mauro3/Parameters.jl) implements an @unpack macro, might be good to look at.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/155
https://github.com/CliMA/Oceananigans.jl/issues/155:281,Modifiability,config,configuration,281,"Right now we have monstrosities like (this one is a bit extreme); ```julia; Nx, Ny, Nz = model.grid.Nx, model.grid.Ny, model.grid.Nz; Lx, Ly, Lz = model.grid.Lx, model.grid.Ly, model.grid.Lz; Δx, Δy, Δz = model.grid.Δx, model.grid.Δy, model.grid.Δz. grid = model.grid; cfg = model.configuration; bcs = model.boundary_conditions; clock = model.clock. G = model.G; Gp = model.Gp; constants = model.constants; eos = model.eos; U = model.velocities; tr = model.tracers; pr = model.pressures; forcing = model.forcing; poisson_solver = model.poisson_solver. δρ = model.stepper_tmp.fC1; RHS = model.stepper_tmp.fCC1; ϕ = model.stepper_tmp.fCC2. gΔz = model.constants.g * model.grid.Δz; fCor = model.constants.f. uvw = U.u.data, U.v.data, U.w.data; TS = tr.T.data, tr.S.data; Guvw = G.Gu.data, G.Gv.data, G.Gw.data. # Source terms at current (Gⁿ) and previous (G⁻) time steps.; Gⁿ = G.Gu.data, G.Gv.data, G.Gw.data, G.GT.data, G.GS.data; G⁻ = Gp.Gu.data, Gp.Gv.data, Gp.Gw.data, Gp.GT.data, Gp.GS.data; ```. Would be nice to prettify or abstract away this unpacking. @charleskawczynski I noticed you used some @unpack macros in the code you showed on Monday, is it up on GitHub by any chance?. I think [Parameters.jl](https://github.com/mauro3/Parameters.jl) implements an @unpack macro, might be good to look at.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/155
https://github.com/CliMA/Oceananigans.jl/issues/157:155,Availability,down,down,155,At some point we should implement the following tests suggested by @edoddridge in https://github.com/climate-machine/Oceananigans.jl/issues/81. - [ ] Spin down of a flow-field under the influence of friction; - [ ] Thermal wind balance: specify a density structure and compare model velocity fields with analytical solution; - [ ] Rayleigh–Bénard convection (I think analytic solutions exist at low Rayleigh number?); - [ ] Onset of baroclinic instability: compare growth rates with analytical predictions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/157
https://github.com/CliMA/Oceananigans.jl/issues/157:494,Safety,predict,predictions,494,At some point we should implement the following tests suggested by @edoddridge in https://github.com/climate-machine/Oceananigans.jl/issues/81. - [ ] Spin down of a flow-field under the influence of friction; - [ ] Thermal wind balance: specify a density structure and compare model velocity fields with analytical solution; - [ ] Rayleigh–Bénard convection (I think analytic solutions exist at low Rayleigh number?); - [ ] Onset of baroclinic instability: compare growth rates with analytical predictions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/157
https://github.com/CliMA/Oceananigans.jl/issues/157:48,Testability,test,tests,48,At some point we should implement the following tests suggested by @edoddridge in https://github.com/climate-machine/Oceananigans.jl/issues/81. - [ ] Spin down of a flow-field under the influence of friction; - [ ] Thermal wind balance: specify a density structure and compare model velocity fields with analytical solution; - [ ] Rayleigh–Bénard convection (I think analytic solutions exist at low Rayleigh number?); - [ ] Onset of baroclinic instability: compare growth rates with analytical predictions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/157
https://github.com/CliMA/Oceananigans.jl/issues/158:48,Testability,test,tests,48,At some point we should implement the following tests suggested by @edoddridge in https://github.com/climate-machine/Oceananigans.jl/issues/81. - [ ] Munk gyre; - [ ] Stommel gyre,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/158
https://github.com/CliMA/Oceananigans.jl/issues/159:176,Energy Efficiency,energy,energy,176,At some point we should implement the following tests suggested by @edoddridge in https://github.com/climate-machine/Oceananigans.jl/issues/81. - [ ] 2D QG turbulence: explore energy and enstrophy cascades; - [ ] lee wave generation and breaking (will require large-scale flow field and bathymetry),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/159
https://github.com/CliMA/Oceananigans.jl/issues/159:48,Testability,test,tests,48,At some point we should implement the following tests suggested by @edoddridge in https://github.com/climate-machine/Oceananigans.jl/issues/81. - [ ] 2D QG turbulence: explore energy and enstrophy cascades; - [ ] lee wave generation and breaking (will require large-scale flow field and bathymetry),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/159
https://github.com/CliMA/Oceananigans.jl/issues/161:716,Availability,error,error,716,"@jm-c suggested the following changes that might improve `Float32` precision for simulations with 100,000+ iterations. > Regarding issue with float32 precision: I looked to the code and; > I can see few things that would be easy to change and could make some difference; > regarding this precision issue:; > 1) Temp in Celcius instead of Kelvin (but this is probably not a big problem); > 2) recompute W from continuity instead of stepping forward W using: G_w - d.PNH/dz; > 3) apply pressure solver on provisional solution:; > with RHS = Div(u*,v*,w*) with u* = U + DeltaT * Gu (same for v*,w*); > instead of on tendencies with RHS = Div.(Gu,Gv,Gw); > ; > The problem with the way (2) is currently done is that the error in continuity equation; > are larger ; And with the way we currently do (3), these error can accumulate with time.; > Finally, with T in Kelvin, error in continuity equation can produce larger error in; > temperature.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/161
https://github.com/CliMA/Oceananigans.jl/issues/161:805,Availability,error,error,805,"@jm-c suggested the following changes that might improve `Float32` precision for simulations with 100,000+ iterations. > Regarding issue with float32 precision: I looked to the code and; > I can see few things that would be easy to change and could make some difference; > regarding this precision issue:; > 1) Temp in Celcius instead of Kelvin (but this is probably not a big problem); > 2) recompute W from continuity instead of stepping forward W using: G_w - d.PNH/dz; > 3) apply pressure solver on provisional solution:; > with RHS = Div(u*,v*,w*) with u* = U + DeltaT * Gu (same for v*,w*); > instead of on tendencies with RHS = Div.(Gu,Gv,Gw); > ; > The problem with the way (2) is currently done is that the error in continuity equation; > are larger ; And with the way we currently do (3), these error can accumulate with time.; > Finally, with T in Kelvin, error in continuity equation can produce larger error in; > temperature.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/161
https://github.com/CliMA/Oceananigans.jl/issues/161:867,Availability,error,error,867,"@jm-c suggested the following changes that might improve `Float32` precision for simulations with 100,000+ iterations. > Regarding issue with float32 precision: I looked to the code and; > I can see few things that would be easy to change and could make some difference; > regarding this precision issue:; > 1) Temp in Celcius instead of Kelvin (but this is probably not a big problem); > 2) recompute W from continuity instead of stepping forward W using: G_w - d.PNH/dz; > 3) apply pressure solver on provisional solution:; > with RHS = Div(u*,v*,w*) with u* = U + DeltaT * Gu (same for v*,w*); > instead of on tendencies with RHS = Div.(Gu,Gv,Gw); > ; > The problem with the way (2) is currently done is that the error in continuity equation; > are larger ; And with the way we currently do (3), these error can accumulate with time.; > Finally, with T in Kelvin, error in continuity equation can produce larger error in; > temperature.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/161
https://github.com/CliMA/Oceananigans.jl/issues/161:915,Availability,error,error,915,"@jm-c suggested the following changes that might improve `Float32` precision for simulations with 100,000+ iterations. > Regarding issue with float32 precision: I looked to the code and; > I can see few things that would be easy to change and could make some difference; > regarding this precision issue:; > 1) Temp in Celcius instead of Kelvin (but this is probably not a big problem); > 2) recompute W from continuity instead of stepping forward W using: G_w - d.PNH/dz; > 3) apply pressure solver on provisional solution:; > with RHS = Div(u*,v*,w*) with u* = U + DeltaT * Gu (same for v*,w*); > instead of on tendencies with RHS = Div.(Gu,Gv,Gw); > ; > The problem with the way (2) is currently done is that the error in continuity equation; > are larger ; And with the way we currently do (3), these error can accumulate with time.; > Finally, with T in Kelvin, error in continuity equation can produce larger error in; > temperature.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/161
https://github.com/CliMA/Oceananigans.jl/issues/162:84,Availability,down,down,84,"Might be good to start learning how to properly profile Oceananigans. It is slowing down a little bit as we add more things and develop stuff (see https://github.com/climate-machine/Oceananigans.jl/pull/147#issuecomment-479474578). We can easily profile it on a CPU to see where the code spends the most time and maybe find some easy things to optimize before profiling it on a GPU where things might be less obvious. Some useful links:; * https://docs.julialang.org/en/v1/manual/profile/index.html; * https://github.com/JuliaLang/julia/issues/4483 (might have to patch LLVM, could be a pain to get working).; * https://docs.nvidia.com/cuda/profiler-users-guide/index.html; * https://juliagpu.github.io/CUDAnative.jl/stable/man/performance.html#Optimizing-1; * https://discourse.julialang.org/t/writing-fast-stencil-computation-kernels-that-work-on-both-cpus-and-gpus/20200 (I pasted some commands where I use nvprof)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/162
https://github.com/CliMA/Oceananigans.jl/issues/162:564,Deployability,patch,patch,564,"Might be good to start learning how to properly profile Oceananigans. It is slowing down a little bit as we add more things and develop stuff (see https://github.com/climate-machine/Oceananigans.jl/pull/147#issuecomment-479474578). We can easily profile it on a CPU to see where the code spends the most time and maybe find some easy things to optimize before profiling it on a GPU where things might be less obvious. Some useful links:; * https://docs.julialang.org/en/v1/manual/profile/index.html; * https://github.com/JuliaLang/julia/issues/4483 (might have to patch LLVM, could be a pain to get working).; * https://docs.nvidia.com/cuda/profiler-users-guide/index.html; * https://juliagpu.github.io/CUDAnative.jl/stable/man/performance.html#Optimizing-1; * https://discourse.julialang.org/t/writing-fast-stencil-computation-kernels-that-work-on-both-cpus-and-gpus/20200 (I pasted some commands where I use nvprof)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/162
https://github.com/CliMA/Oceananigans.jl/issues/162:344,Performance,optimiz,optimize,344,"Might be good to start learning how to properly profile Oceananigans. It is slowing down a little bit as we add more things and develop stuff (see https://github.com/climate-machine/Oceananigans.jl/pull/147#issuecomment-479474578). We can easily profile it on a CPU to see where the code spends the most time and maybe find some easy things to optimize before profiling it on a GPU where things might be less obvious. Some useful links:; * https://docs.julialang.org/en/v1/manual/profile/index.html; * https://github.com/JuliaLang/julia/issues/4483 (might have to patch LLVM, could be a pain to get working).; * https://docs.nvidia.com/cuda/profiler-users-guide/index.html; * https://juliagpu.github.io/CUDAnative.jl/stable/man/performance.html#Optimizing-1; * https://discourse.julialang.org/t/writing-fast-stencil-computation-kernels-that-work-on-both-cpus-and-gpus/20200 (I pasted some commands where I use nvprof)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/162
https://github.com/CliMA/Oceananigans.jl/issues/162:728,Performance,perform,performance,728,"Might be good to start learning how to properly profile Oceananigans. It is slowing down a little bit as we add more things and develop stuff (see https://github.com/climate-machine/Oceananigans.jl/pull/147#issuecomment-479474578). We can easily profile it on a CPU to see where the code spends the most time and maybe find some easy things to optimize before profiling it on a GPU where things might be less obvious. Some useful links:; * https://docs.julialang.org/en/v1/manual/profile/index.html; * https://github.com/JuliaLang/julia/issues/4483 (might have to patch LLVM, could be a pain to get working).; * https://docs.nvidia.com/cuda/profiler-users-guide/index.html; * https://juliagpu.github.io/CUDAnative.jl/stable/man/performance.html#Optimizing-1; * https://discourse.julialang.org/t/writing-fast-stencil-computation-kernels-that-work-on-both-cpus-and-gpus/20200 (I pasted some commands where I use nvprof)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/162
https://github.com/CliMA/Oceananigans.jl/issues/162:745,Performance,Optimiz,Optimizing-,745,"Might be good to start learning how to properly profile Oceananigans. It is slowing down a little bit as we add more things and develop stuff (see https://github.com/climate-machine/Oceananigans.jl/pull/147#issuecomment-479474578). We can easily profile it on a CPU to see where the code spends the most time and maybe find some easy things to optimize before profiling it on a GPU where things might be less obvious. Some useful links:; * https://docs.julialang.org/en/v1/manual/profile/index.html; * https://github.com/JuliaLang/julia/issues/4483 (might have to patch LLVM, could be a pain to get working).; * https://docs.nvidia.com/cuda/profiler-users-guide/index.html; * https://juliagpu.github.io/CUDAnative.jl/stable/man/performance.html#Optimizing-1; * https://discourse.julialang.org/t/writing-fast-stencil-computation-kernels-that-work-on-both-cpus-and-gpus/20200 (I pasted some commands where I use nvprof)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/162
https://github.com/CliMA/Oceananigans.jl/issues/162:23,Usability,learn,learning,23,"Might be good to start learning how to properly profile Oceananigans. It is slowing down a little bit as we add more things and develop stuff (see https://github.com/climate-machine/Oceananigans.jl/pull/147#issuecomment-479474578). We can easily profile it on a CPU to see where the code spends the most time and maybe find some easy things to optimize before profiling it on a GPU where things might be less obvious. Some useful links:; * https://docs.julialang.org/en/v1/manual/profile/index.html; * https://github.com/JuliaLang/julia/issues/4483 (might have to patch LLVM, could be a pain to get working).; * https://docs.nvidia.com/cuda/profiler-users-guide/index.html; * https://juliagpu.github.io/CUDAnative.jl/stable/man/performance.html#Optimizing-1; * https://discourse.julialang.org/t/writing-fast-stencil-computation-kernels-that-work-on-both-cpus-and-gpus/20200 (I pasted some commands where I use nvprof)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/162
https://github.com/CliMA/Oceananigans.jl/issues/162:656,Usability,guid,guide,656,"Might be good to start learning how to properly profile Oceananigans. It is slowing down a little bit as we add more things and develop stuff (see https://github.com/climate-machine/Oceananigans.jl/pull/147#issuecomment-479474578). We can easily profile it on a CPU to see where the code spends the most time and maybe find some easy things to optimize before profiling it on a GPU where things might be less obvious. Some useful links:; * https://docs.julialang.org/en/v1/manual/profile/index.html; * https://github.com/JuliaLang/julia/issues/4483 (might have to patch LLVM, could be a pain to get working).; * https://docs.nvidia.com/cuda/profiler-users-guide/index.html; * https://juliagpu.github.io/CUDAnative.jl/stable/man/performance.html#Optimizing-1; * https://discourse.julialang.org/t/writing-fast-stencil-computation-kernels-that-work-on-both-cpus-and-gpus/20200 (I pasted some commands where I use nvprof)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/162
https://github.com/CliMA/Oceananigans.jl/issues/163:17,Energy Efficiency,adapt,adapt,17,"Would be good to adapt our `Field` structs to be `isbits` for CUDA kernels. Same with `FieldSet` structs, although `FieldVector`s might be a good choice here. We would have to adapt `FieldVector` ourselves though. See this PR for an example on how to adapt: https://github.com/JuliaArrays/OffsetArrays.jl/pull/57",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/163
https://github.com/CliMA/Oceananigans.jl/issues/163:176,Energy Efficiency,adapt,adapt,176,"Would be good to adapt our `Field` structs to be `isbits` for CUDA kernels. Same with `FieldSet` structs, although `FieldVector`s might be a good choice here. We would have to adapt `FieldVector` ourselves though. See this PR for an example on how to adapt: https://github.com/JuliaArrays/OffsetArrays.jl/pull/57",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/163
https://github.com/CliMA/Oceananigans.jl/issues/163:251,Energy Efficiency,adapt,adapt,251,"Would be good to adapt our `Field` structs to be `isbits` for CUDA kernels. Same with `FieldSet` structs, although `FieldVector`s might be a good choice here. We would have to adapt `FieldVector` ourselves though. See this PR for an example on how to adapt: https://github.com/JuliaArrays/OffsetArrays.jl/pull/57",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/163
https://github.com/CliMA/Oceananigans.jl/issues/163:17,Modifiability,adapt,adapt,17,"Would be good to adapt our `Field` structs to be `isbits` for CUDA kernels. Same with `FieldSet` structs, although `FieldVector`s might be a good choice here. We would have to adapt `FieldVector` ourselves though. See this PR for an example on how to adapt: https://github.com/JuliaArrays/OffsetArrays.jl/pull/57",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/163
https://github.com/CliMA/Oceananigans.jl/issues/163:176,Modifiability,adapt,adapt,176,"Would be good to adapt our `Field` structs to be `isbits` for CUDA kernels. Same with `FieldSet` structs, although `FieldVector`s might be a good choice here. We would have to adapt `FieldVector` ourselves though. See this PR for an example on how to adapt: https://github.com/JuliaArrays/OffsetArrays.jl/pull/57",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/163
https://github.com/CliMA/Oceananigans.jl/issues/163:251,Modifiability,adapt,adapt,251,"Would be good to adapt our `Field` structs to be `isbits` for CUDA kernels. Same with `FieldSet` structs, although `FieldVector`s might be a good choice here. We would have to adapt `FieldVector` ourselves though. See this PR for an example on how to adapt: https://github.com/JuliaArrays/OffsetArrays.jl/pull/57",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/163
https://github.com/CliMA/Oceananigans.jl/issues/164:285,Testability,test,test,285,"> Another thing I noticed is that `@inbounds` is used in places where it can't really be guaranteed, like *inside* [difference operator functions](https://github.com/climate-machine/Oceananigans.jl/blob/master/src/operators/ops_regular_cartesian_grid.jl). I couldn't figure out how to test this, but I wonder if `@inbounds` propagates to all of the functions that are called inside its scope (is that the right language)? ; > ; > Specifically I'm referring to patterns like the [RHS calculation for u](https://github.com/climate-machine/Oceananigans.jl/blob/2220ee62685a0570d4dec944f148634a539e9220/src/time_steppers.jl#L160), which is `@inbounds`, but subsequently calls operators like [this](https://github.com/climate-machine/Oceananigans.jl/blob/2220ee62685a0570d4dec944f148634a539e9220/src/operators/ops_regular_cartesian_grid.jl#L71) that are *also* have `@inbounds`.; > ; > In other words, we only need *one* `@inbounds` statement; we don't need multiple nested `@inbounds` statements. @vchuravy can you confirm/deny this? ; > ; > A separate issue with `@inbounds` in places where it can't be guaranteed is that if users write functions / analysis tools using those operators, they might screw up and give out-of-bounds indices to functions that have guaranteed `@inbounds` (and in consequence get mysterious segfaults?) It seems the natural place for `@inbounds` is in the scope of a loop.; > ; > _Originally posted by @glwagner in https://github.com/climate-machine/Oceananigans.jl/issues/163#issuecomment-479829199_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/164
https://github.com/CliMA/Oceananigans.jl/issues/166:48,Testability,test,tests,48,"@mukund-gupta has been trying to run some model tests but might need to set Dirchlet/`Value` boundary conditions for the velocities at the top and bottom. @glwagner would this be easy to add in? For `Flux` boundary conditions I assume we'd have to use 𝜈 instead of κ so something like; ```julia; Gϕ[i, j, 1] += 𝜈*top_gradient.condition / grid.Δz; ```; instead of; ```julia; Gϕ[i, j, 1] += κ*top_gradient.condition / grid.Δz; ```; And for `Value` boundary conditions I assume it's just the line below?; ```julia; ϕ[i, j, 1] = top_value.condition # Note we're setting ϕ, not adding to Gϕ.; ```. I can try adding these in, shouldn't be too hard but just want to double check.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/166
https://github.com/CliMA/Oceananigans.jl/pull/167:51,Integrability,wrap,wrap-around,51,"This PR introduces _halo regions_ instead of using wrap-around `indmod1` and `decmod1` functions to account for horizontally periodic boundary conditions. It will allow us to more easily implement multiple wall-bounded dimensions, e.g. channel models #100. This is also a good first step towards distributed parallelization with MPI. Resolves #45 ; Resolves #104 ; Resolves #122",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/167
https://github.com/CliMA/Oceananigans.jl/issues/168:361,Integrability,depend,dependence,361,"- [x] Try comparing with an analytical solution, e.g. Poiseuille flow or Couette flow. This would test the pressure solver.; - [x] See if there's a difference between `Float64` on the CPU and GPU beyond machine epsilon.; - [x] Compare with MITgcm, both running `Float64` on the same CPU.; - [ ] Try comparing with MITgcm at different time steps to look at time-dependence.; - [ ] Try `Float128`. Might not play nice with the GPU.; - [x] We can try some of the stuff from #161 but that might be more work.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/168
https://github.com/CliMA/Oceananigans.jl/issues/168:98,Testability,test,test,98,"- [x] Try comparing with an analytical solution, e.g. Poiseuille flow or Couette flow. This would test the pressure solver.; - [x] See if there's a difference between `Float64` on the CPU and GPU beyond machine epsilon.; - [x] Compare with MITgcm, both running `Float64` on the same CPU.; - [ ] Try comparing with MITgcm at different time steps to look at time-dependence.; - [ ] Try `Float128`. Might not play nice with the GPU.; - [x] We can try some of the stuff from #161 but that might be more work.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/168
https://github.com/CliMA/Oceananigans.jl/issues/169:1004,Integrability,synchroniz,synchronize,1004,"Thanks to some preliminary CSI profiling by @banex19 we have some timings for the time-stepping loop; ```; Function time_step!: 1 times (average runtime : 20186 ms); Function update_buoyancy!: 1 times (average runtime : 8631 ms); Function calculate_interior_source_terms!: 1 times (average runtime : 4315 ms); Function solve_poisson_3d_ppn_planned!: 1 times (average runtime : 1131 ms); Function update_velocities_and_tracers!: 1 times (average runtime : 728 ms); Function adams_bashforth_update_source_terms!: 1 times (average runtime : 526 ms); Function store_previous_source_terms!: 1 times (average runtime : 353 ms); Function calculate_source_term_divergence!: 1 times (average runtime : 295 ms); ```. I kind of overlooked this but the `update_buoyancy!` function is taking up 43% of the time stepping cycles because each grid point gets one thread that calculates the buoyancy for all grid points above them (quadratic time for no reason). Well, the reason I did it this way was to avoid having to synchronize between threads, but there is no need to synchronize. This should be changed so that each column gets a thread that is responsible for calculating the buoyancy in that column. So when launching this kernel with CUDA it should be called with `threads=(Tx, Ty), blocks=(Bx, By)`. This is probably only performant for large grids with `Nx*Ny >> 1024`. On the CPU this might speed up `update_buoyancy!` by ~10x and the entire time stepping by ~60%! Should speed up the GPU models as well. Note: The absolute times themselves don't mean much as the profiler is pretty sophisticated/invasive.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/169
https://github.com/CliMA/Oceananigans.jl/issues/169:1057,Integrability,synchroniz,synchronize,1057,"Thanks to some preliminary CSI profiling by @banex19 we have some timings for the time-stepping loop; ```; Function time_step!: 1 times (average runtime : 20186 ms); Function update_buoyancy!: 1 times (average runtime : 8631 ms); Function calculate_interior_source_terms!: 1 times (average runtime : 4315 ms); Function solve_poisson_3d_ppn_planned!: 1 times (average runtime : 1131 ms); Function update_velocities_and_tracers!: 1 times (average runtime : 728 ms); Function adams_bashforth_update_source_terms!: 1 times (average runtime : 526 ms); Function store_previous_source_terms!: 1 times (average runtime : 353 ms); Function calculate_source_term_divergence!: 1 times (average runtime : 295 ms); ```. I kind of overlooked this but the `update_buoyancy!` function is taking up 43% of the time stepping cycles because each grid point gets one thread that calculates the buoyancy for all grid points above them (quadratic time for no reason). Well, the reason I did it this way was to avoid having to synchronize between threads, but there is no need to synchronize. This should be changed so that each column gets a thread that is responsible for calculating the buoyancy in that column. So when launching this kernel with CUDA it should be called with `threads=(Tx, Ty), blocks=(Bx, By)`. This is probably only performant for large grids with `Nx*Ny >> 1024`. On the CPU this might speed up `update_buoyancy!` by ~10x and the entire time stepping by ~60%! Should speed up the GPU models as well. Note: The absolute times themselves don't mean much as the profiler is pretty sophisticated/invasive.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/169
https://github.com/CliMA/Oceananigans.jl/issues/169:1316,Performance,perform,performant,1316,"Thanks to some preliminary CSI profiling by @banex19 we have some timings for the time-stepping loop; ```; Function time_step!: 1 times (average runtime : 20186 ms); Function update_buoyancy!: 1 times (average runtime : 8631 ms); Function calculate_interior_source_terms!: 1 times (average runtime : 4315 ms); Function solve_poisson_3d_ppn_planned!: 1 times (average runtime : 1131 ms); Function update_velocities_and_tracers!: 1 times (average runtime : 728 ms); Function adams_bashforth_update_source_terms!: 1 times (average runtime : 526 ms); Function store_previous_source_terms!: 1 times (average runtime : 353 ms); Function calculate_source_term_divergence!: 1 times (average runtime : 295 ms); ```. I kind of overlooked this but the `update_buoyancy!` function is taking up 43% of the time stepping cycles because each grid point gets one thread that calculates the buoyancy for all grid points above them (quadratic time for no reason). Well, the reason I did it this way was to avoid having to synchronize between threads, but there is no need to synchronize. This should be changed so that each column gets a thread that is responsible for calculating the buoyancy in that column. So when launching this kernel with CUDA it should be called with `threads=(Tx, Ty), blocks=(Bx, By)`. This is probably only performant for large grids with `Nx*Ny >> 1024`. On the CPU this might speed up `update_buoyancy!` by ~10x and the entire time stepping by ~60%! Should speed up the GPU models as well. Note: The absolute times themselves don't mean much as the profiler is pretty sophisticated/invasive.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/169
https://github.com/CliMA/Oceananigans.jl/issues/169:988,Safety,avoid,avoid,988,"Thanks to some preliminary CSI profiling by @banex19 we have some timings for the time-stepping loop; ```; Function time_step!: 1 times (average runtime : 20186 ms); Function update_buoyancy!: 1 times (average runtime : 8631 ms); Function calculate_interior_source_terms!: 1 times (average runtime : 4315 ms); Function solve_poisson_3d_ppn_planned!: 1 times (average runtime : 1131 ms); Function update_velocities_and_tracers!: 1 times (average runtime : 728 ms); Function adams_bashforth_update_source_terms!: 1 times (average runtime : 526 ms); Function store_previous_source_terms!: 1 times (average runtime : 353 ms); Function calculate_source_term_divergence!: 1 times (average runtime : 295 ms); ```. I kind of overlooked this but the `update_buoyancy!` function is taking up 43% of the time stepping cycles because each grid point gets one thread that calculates the buoyancy for all grid points above them (quadratic time for no reason). Well, the reason I did it this way was to avoid having to synchronize between threads, but there is no need to synchronize. This should be changed so that each column gets a thread that is responsible for calculating the buoyancy in that column. So when launching this kernel with CUDA it should be called with `threads=(Tx, Ty), blocks=(Bx, By)`. This is probably only performant for large grids with `Nx*Ny >> 1024`. On the CPU this might speed up `update_buoyancy!` by ~10x and the entire time stepping by ~60%! Should speed up the GPU models as well. Note: The absolute times themselves don't mean much as the profiler is pretty sophisticated/invasive.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/169
https://github.com/CliMA/Oceananigans.jl/pull/170:214,Integrability,depend,dependency,214,A NaN checker diagnostic that aborts the simulation when NaN values are detected. We could have some shell script that look for this and sends an email or something. Julia could do this too but then we'd add a big dependency for a small diagnostic. Resolves #38,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/170
https://github.com/CliMA/Oceananigans.jl/pull/170:30,Safety,abort,aborts,30,A NaN checker diagnostic that aborts the simulation when NaN values are detected. We could have some shell script that look for this and sends an email or something. Julia could do this too but then we'd add a big dependency for a small diagnostic. Resolves #38,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/170
https://github.com/CliMA/Oceananigans.jl/pull/170:72,Safety,detect,detected,72,A NaN checker diagnostic that aborts the simulation when NaN values are detected. We could have some shell script that look for this and sends an email or something. Julia could do this too but then we'd add a big dependency for a small diagnostic. Resolves #38,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/170
https://github.com/CliMA/Oceananigans.jl/issues/171:414,Integrability,wrap,wrapper,414,"For many purposes, e.g. writing output, calculating statistical diagnostics, etc. that is very inefficient on CuArrays because of scalar operations, it turns out to be faster to just convert the CuArray to an Array and do the operation. I wonder if there's a nicer way of doing this. I guess CUDAnative.jl has a rough list of CuArray-compatible functions that we should refer to more often. We can also just use a wrapper function but this feels a little weird and we'd have to remember where we need to use it; ```julia; wrapper(A::Array) = A; wrapper(A::CuArray) = Array(A); ```; which isn't much better than always using `Array(A)` as we mostly run on the GPU. This feels like a pretty minor issue but thought I'd document it here since I found myself doing this several times today.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/171
https://github.com/CliMA/Oceananigans.jl/issues/171:522,Integrability,wrap,wrapper,522,"For many purposes, e.g. writing output, calculating statistical diagnostics, etc. that is very inefficient on CuArrays because of scalar operations, it turns out to be faster to just convert the CuArray to an Array and do the operation. I wonder if there's a nicer way of doing this. I guess CUDAnative.jl has a rough list of CuArray-compatible functions that we should refer to more often. We can also just use a wrapper function but this feels a little weird and we'd have to remember where we need to use it; ```julia; wrapper(A::Array) = A; wrapper(A::CuArray) = Array(A); ```; which isn't much better than always using `Array(A)` as we mostly run on the GPU. This feels like a pretty minor issue but thought I'd document it here since I found myself doing this several times today.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/171
https://github.com/CliMA/Oceananigans.jl/issues/171:545,Integrability,wrap,wrapper,545,"For many purposes, e.g. writing output, calculating statistical diagnostics, etc. that is very inefficient on CuArrays because of scalar operations, it turns out to be faster to just convert the CuArray to an Array and do the operation. I wonder if there's a nicer way of doing this. I guess CUDAnative.jl has a rough list of CuArray-compatible functions that we should refer to more often. We can also just use a wrapper function but this feels a little weird and we'd have to remember where we need to use it; ```julia; wrapper(A::Array) = A; wrapper(A::CuArray) = Array(A); ```; which isn't much better than always using `Array(A)` as we mostly run on the GPU. This feels like a pretty minor issue but thought I'd document it here since I found myself doing this several times today.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/171
https://github.com/CliMA/Oceananigans.jl/issues/176:368,Availability,down,download,368,"The deep convection golden master fails intermittently even if the random number generator is seeded with the same value. Some randomness is added to the initial surface temperature. For now the 5 tests affected by this are skipped with `@test_skip` and will show up as ""Broken"". @christophernhill suggested using a portable random number generator: http://mitgcm.org/download/daily_snapshot/MITgcm/model/src/port_rand.F",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/176
https://github.com/CliMA/Oceananigans.jl/issues/176:316,Modifiability,portab,portable,316,"The deep convection golden master fails intermittently even if the random number generator is seeded with the same value. Some randomness is added to the initial surface temperature. For now the 5 tests affected by this are skipped with `@test_skip` and will show up as ""Broken"". @christophernhill suggested using a portable random number generator: http://mitgcm.org/download/daily_snapshot/MITgcm/model/src/port_rand.F",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/176
https://github.com/CliMA/Oceananigans.jl/issues/176:197,Testability,test,tests,197,"The deep convection golden master fails intermittently even if the random number generator is seeded with the same value. Some randomness is added to the initial surface temperature. For now the 5 tests affected by this are skipped with `@test_skip` and will show up as ""Broken"". @christophernhill suggested using a portable random number generator: http://mitgcm.org/download/daily_snapshot/MITgcm/model/src/port_rand.F",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/176
https://github.com/CliMA/Oceananigans.jl/issues/177:181,Availability,checkpoint,checkpointing,181,"For now the 10 tests affected by this are skipped with `@test_skip` and will show up as ""Broken"". Maybe we just have to define `convert` for Fields with OffsetArrays?. ```; Testing checkpointing...; WARNING: Forcing functions will not be serialized!; [Checkpointer] Serializing model to disk: ./test_model_checkpoint_0.jld; [Checkpointer] Reconstructing FFT plans...; WARNING: Forcing functions will not be serialized!; [Checkpointer] Serializing model to disk: ./test_model_checkpoint_5.jld; [Checkpointer] Reconstructing FFT plans...; Deserializing model from disk: test_model_checkpoint_5.jld; ┌ Warning: type Oceananigans.FaceFieldX{OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}},Oceananigans.RegularCartesianGrid{Core.Float64,Base.StepRangeLen{Core.Float64,Base.TwicePrecision{Core.Float64},Base.TwicePrecision{Core.Float64}}}} not present in workspace; reconstructing; └ @ JLD ~/.julia/packages/JLD/1BoSz/src/jld_types.jl:703; ┌ Warning: type OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}} not present in workspace; reconstructing; └ @ JLD ~/.julia/packages/JLD/1BoSz/src/jld_types.jl:703; Checkpointing: Error During Test at /home/alir/Oceananigans.jl/test/runtests.jl:293; Got exception outside of a @test; MethodError: Cannot `convert` an object of type getfield(JLD, Symbol(""##Oceananigans.FaceFieldX{OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}},Oceananigans.RegularCartesianGrid{Core.Float64,Base.StepRangeLen{Core.Float64,Base.TwicePrecision{Core.Float64},Base.TwicePrecision{Core.Float64}}}}#384"")) to an object of type FaceFieldX; Closest candidates are:; convert(::Type{T}, !Matched::T) where T at essentials.jl:154; Stacktrace:; [1] jlconvert(::Type{VelocityFields}, ::JLD.JldFile, ::Ptr{UInt8}) at /home/alir/.julia/packages/JLD/1BoSz/src/jld_types.jl:434; [2] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:398; [3] read(::JLD.JldDataset) at /home/alir/.j",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/177
https://github.com/CliMA/Oceananigans.jl/issues/177:252,Availability,Checkpoint,Checkpointer,252,"For now the 10 tests affected by this are skipped with `@test_skip` and will show up as ""Broken"". Maybe we just have to define `convert` for Fields with OffsetArrays?. ```; Testing checkpointing...; WARNING: Forcing functions will not be serialized!; [Checkpointer] Serializing model to disk: ./test_model_checkpoint_0.jld; [Checkpointer] Reconstructing FFT plans...; WARNING: Forcing functions will not be serialized!; [Checkpointer] Serializing model to disk: ./test_model_checkpoint_5.jld; [Checkpointer] Reconstructing FFT plans...; Deserializing model from disk: test_model_checkpoint_5.jld; ┌ Warning: type Oceananigans.FaceFieldX{OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}},Oceananigans.RegularCartesianGrid{Core.Float64,Base.StepRangeLen{Core.Float64,Base.TwicePrecision{Core.Float64},Base.TwicePrecision{Core.Float64}}}} not present in workspace; reconstructing; └ @ JLD ~/.julia/packages/JLD/1BoSz/src/jld_types.jl:703; ┌ Warning: type OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}} not present in workspace; reconstructing; └ @ JLD ~/.julia/packages/JLD/1BoSz/src/jld_types.jl:703; Checkpointing: Error During Test at /home/alir/Oceananigans.jl/test/runtests.jl:293; Got exception outside of a @test; MethodError: Cannot `convert` an object of type getfield(JLD, Symbol(""##Oceananigans.FaceFieldX{OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}},Oceananigans.RegularCartesianGrid{Core.Float64,Base.StepRangeLen{Core.Float64,Base.TwicePrecision{Core.Float64},Base.TwicePrecision{Core.Float64}}}}#384"")) to an object of type FaceFieldX; Closest candidates are:; convert(::Type{T}, !Matched::T) where T at essentials.jl:154; Stacktrace:; [1] jlconvert(::Type{VelocityFields}, ::JLD.JldFile, ::Ptr{UInt8}) at /home/alir/.julia/packages/JLD/1BoSz/src/jld_types.jl:434; [2] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:398; [3] read(::JLD.JldDataset) at /home/alir/.j",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/177
https://github.com/CliMA/Oceananigans.jl/issues/177:325,Availability,Checkpoint,Checkpointer,325,"For now the 10 tests affected by this are skipped with `@test_skip` and will show up as ""Broken"". Maybe we just have to define `convert` for Fields with OffsetArrays?. ```; Testing checkpointing...; WARNING: Forcing functions will not be serialized!; [Checkpointer] Serializing model to disk: ./test_model_checkpoint_0.jld; [Checkpointer] Reconstructing FFT plans...; WARNING: Forcing functions will not be serialized!; [Checkpointer] Serializing model to disk: ./test_model_checkpoint_5.jld; [Checkpointer] Reconstructing FFT plans...; Deserializing model from disk: test_model_checkpoint_5.jld; ┌ Warning: type Oceananigans.FaceFieldX{OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}},Oceananigans.RegularCartesianGrid{Core.Float64,Base.StepRangeLen{Core.Float64,Base.TwicePrecision{Core.Float64},Base.TwicePrecision{Core.Float64}}}} not present in workspace; reconstructing; └ @ JLD ~/.julia/packages/JLD/1BoSz/src/jld_types.jl:703; ┌ Warning: type OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}} not present in workspace; reconstructing; └ @ JLD ~/.julia/packages/JLD/1BoSz/src/jld_types.jl:703; Checkpointing: Error During Test at /home/alir/Oceananigans.jl/test/runtests.jl:293; Got exception outside of a @test; MethodError: Cannot `convert` an object of type getfield(JLD, Symbol(""##Oceananigans.FaceFieldX{OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}},Oceananigans.RegularCartesianGrid{Core.Float64,Base.StepRangeLen{Core.Float64,Base.TwicePrecision{Core.Float64},Base.TwicePrecision{Core.Float64}}}}#384"")) to an object of type FaceFieldX; Closest candidates are:; convert(::Type{T}, !Matched::T) where T at essentials.jl:154; Stacktrace:; [1] jlconvert(::Type{VelocityFields}, ::JLD.JldFile, ::Ptr{UInt8}) at /home/alir/.julia/packages/JLD/1BoSz/src/jld_types.jl:434; [2] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:398; [3] read(::JLD.JldDataset) at /home/alir/.j",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/177
https://github.com/CliMA/Oceananigans.jl/issues/177:421,Availability,Checkpoint,Checkpointer,421,"For now the 10 tests affected by this are skipped with `@test_skip` and will show up as ""Broken"". Maybe we just have to define `convert` for Fields with OffsetArrays?. ```; Testing checkpointing...; WARNING: Forcing functions will not be serialized!; [Checkpointer] Serializing model to disk: ./test_model_checkpoint_0.jld; [Checkpointer] Reconstructing FFT plans...; WARNING: Forcing functions will not be serialized!; [Checkpointer] Serializing model to disk: ./test_model_checkpoint_5.jld; [Checkpointer] Reconstructing FFT plans...; Deserializing model from disk: test_model_checkpoint_5.jld; ┌ Warning: type Oceananigans.FaceFieldX{OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}},Oceananigans.RegularCartesianGrid{Core.Float64,Base.StepRangeLen{Core.Float64,Base.TwicePrecision{Core.Float64},Base.TwicePrecision{Core.Float64}}}} not present in workspace; reconstructing; └ @ JLD ~/.julia/packages/JLD/1BoSz/src/jld_types.jl:703; ┌ Warning: type OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}} not present in workspace; reconstructing; └ @ JLD ~/.julia/packages/JLD/1BoSz/src/jld_types.jl:703; Checkpointing: Error During Test at /home/alir/Oceananigans.jl/test/runtests.jl:293; Got exception outside of a @test; MethodError: Cannot `convert` an object of type getfield(JLD, Symbol(""##Oceananigans.FaceFieldX{OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}},Oceananigans.RegularCartesianGrid{Core.Float64,Base.StepRangeLen{Core.Float64,Base.TwicePrecision{Core.Float64},Base.TwicePrecision{Core.Float64}}}}#384"")) to an object of type FaceFieldX; Closest candidates are:; convert(::Type{T}, !Matched::T) where T at essentials.jl:154; Stacktrace:; [1] jlconvert(::Type{VelocityFields}, ::JLD.JldFile, ::Ptr{UInt8}) at /home/alir/.julia/packages/JLD/1BoSz/src/jld_types.jl:434; [2] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:398; [3] read(::JLD.JldDataset) at /home/alir/.j",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/177
https://github.com/CliMA/Oceananigans.jl/issues/177:494,Availability,Checkpoint,Checkpointer,494,"For now the 10 tests affected by this are skipped with `@test_skip` and will show up as ""Broken"". Maybe we just have to define `convert` for Fields with OffsetArrays?. ```; Testing checkpointing...; WARNING: Forcing functions will not be serialized!; [Checkpointer] Serializing model to disk: ./test_model_checkpoint_0.jld; [Checkpointer] Reconstructing FFT plans...; WARNING: Forcing functions will not be serialized!; [Checkpointer] Serializing model to disk: ./test_model_checkpoint_5.jld; [Checkpointer] Reconstructing FFT plans...; Deserializing model from disk: test_model_checkpoint_5.jld; ┌ Warning: type Oceananigans.FaceFieldX{OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}},Oceananigans.RegularCartesianGrid{Core.Float64,Base.StepRangeLen{Core.Float64,Base.TwicePrecision{Core.Float64},Base.TwicePrecision{Core.Float64}}}} not present in workspace; reconstructing; └ @ JLD ~/.julia/packages/JLD/1BoSz/src/jld_types.jl:703; ┌ Warning: type OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}} not present in workspace; reconstructing; └ @ JLD ~/.julia/packages/JLD/1BoSz/src/jld_types.jl:703; Checkpointing: Error During Test at /home/alir/Oceananigans.jl/test/runtests.jl:293; Got exception outside of a @test; MethodError: Cannot `convert` an object of type getfield(JLD, Symbol(""##Oceananigans.FaceFieldX{OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}},Oceananigans.RegularCartesianGrid{Core.Float64,Base.StepRangeLen{Core.Float64,Base.TwicePrecision{Core.Float64},Base.TwicePrecision{Core.Float64}}}}#384"")) to an object of type FaceFieldX; Closest candidates are:; convert(::Type{T}, !Matched::T) where T at essentials.jl:154; Stacktrace:; [1] jlconvert(::Type{VelocityFields}, ::JLD.JldFile, ::Ptr{UInt8}) at /home/alir/.julia/packages/JLD/1BoSz/src/jld_types.jl:434; [2] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:398; [3] read(::JLD.JldDataset) at /home/alir/.j",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/177
https://github.com/CliMA/Oceananigans.jl/issues/177:1138,Availability,Checkpoint,Checkpointing,1138,"s?. ```; Testing checkpointing...; WARNING: Forcing functions will not be serialized!; [Checkpointer] Serializing model to disk: ./test_model_checkpoint_0.jld; [Checkpointer] Reconstructing FFT plans...; WARNING: Forcing functions will not be serialized!; [Checkpointer] Serializing model to disk: ./test_model_checkpoint_5.jld; [Checkpointer] Reconstructing FFT plans...; Deserializing model from disk: test_model_checkpoint_5.jld; ┌ Warning: type Oceananigans.FaceFieldX{OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}},Oceananigans.RegularCartesianGrid{Core.Float64,Base.StepRangeLen{Core.Float64,Base.TwicePrecision{Core.Float64},Base.TwicePrecision{Core.Float64}}}} not present in workspace; reconstructing; └ @ JLD ~/.julia/packages/JLD/1BoSz/src/jld_types.jl:703; ┌ Warning: type OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}} not present in workspace; reconstructing; └ @ JLD ~/.julia/packages/JLD/1BoSz/src/jld_types.jl:703; Checkpointing: Error During Test at /home/alir/Oceananigans.jl/test/runtests.jl:293; Got exception outside of a @test; MethodError: Cannot `convert` an object of type getfield(JLD, Symbol(""##Oceananigans.FaceFieldX{OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}},Oceananigans.RegularCartesianGrid{Core.Float64,Base.StepRangeLen{Core.Float64,Base.TwicePrecision{Core.Float64},Base.TwicePrecision{Core.Float64}}}}#384"")) to an object of type FaceFieldX; Closest candidates are:; convert(::Type{T}, !Matched::T) where T at essentials.jl:154; Stacktrace:; [1] jlconvert(::Type{VelocityFields}, ::JLD.JldFile, ::Ptr{UInt8}) at /home/alir/.julia/packages/JLD/1BoSz/src/jld_types.jl:434; [2] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:398; [3] read(::JLD.JldDataset) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:370; [4] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:502; [5] jlconvert(",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/177
https://github.com/CliMA/Oceananigans.jl/issues/177:1153,Availability,Error,Error,1153,"s?. ```; Testing checkpointing...; WARNING: Forcing functions will not be serialized!; [Checkpointer] Serializing model to disk: ./test_model_checkpoint_0.jld; [Checkpointer] Reconstructing FFT plans...; WARNING: Forcing functions will not be serialized!; [Checkpointer] Serializing model to disk: ./test_model_checkpoint_5.jld; [Checkpointer] Reconstructing FFT plans...; Deserializing model from disk: test_model_checkpoint_5.jld; ┌ Warning: type Oceananigans.FaceFieldX{OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}},Oceananigans.RegularCartesianGrid{Core.Float64,Base.StepRangeLen{Core.Float64,Base.TwicePrecision{Core.Float64},Base.TwicePrecision{Core.Float64}}}} not present in workspace; reconstructing; └ @ JLD ~/.julia/packages/JLD/1BoSz/src/jld_types.jl:703; ┌ Warning: type OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}} not present in workspace; reconstructing; └ @ JLD ~/.julia/packages/JLD/1BoSz/src/jld_types.jl:703; Checkpointing: Error During Test at /home/alir/Oceananigans.jl/test/runtests.jl:293; Got exception outside of a @test; MethodError: Cannot `convert` an object of type getfield(JLD, Symbol(""##Oceananigans.FaceFieldX{OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}},Oceananigans.RegularCartesianGrid{Core.Float64,Base.StepRangeLen{Core.Float64,Base.TwicePrecision{Core.Float64},Base.TwicePrecision{Core.Float64}}}}#384"")) to an object of type FaceFieldX; Closest candidates are:; convert(::Type{T}, !Matched::T) where T at essentials.jl:154; Stacktrace:; [1] jlconvert(::Type{VelocityFields}, ::JLD.JldFile, ::Ptr{UInt8}) at /home/alir/.julia/packages/JLD/1BoSz/src/jld_types.jl:434; [2] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:398; [3] read(::JLD.JldDataset) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:370; [4] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:502; [5] jlconvert(",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/177
https://github.com/CliMA/Oceananigans.jl/issues/177:15,Testability,test,tests,15,"For now the 10 tests affected by this are skipped with `@test_skip` and will show up as ""Broken"". Maybe we just have to define `convert` for Fields with OffsetArrays?. ```; Testing checkpointing...; WARNING: Forcing functions will not be serialized!; [Checkpointer] Serializing model to disk: ./test_model_checkpoint_0.jld; [Checkpointer] Reconstructing FFT plans...; WARNING: Forcing functions will not be serialized!; [Checkpointer] Serializing model to disk: ./test_model_checkpoint_5.jld; [Checkpointer] Reconstructing FFT plans...; Deserializing model from disk: test_model_checkpoint_5.jld; ┌ Warning: type Oceananigans.FaceFieldX{OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}},Oceananigans.RegularCartesianGrid{Core.Float64,Base.StepRangeLen{Core.Float64,Base.TwicePrecision{Core.Float64},Base.TwicePrecision{Core.Float64}}}} not present in workspace; reconstructing; └ @ JLD ~/.julia/packages/JLD/1BoSz/src/jld_types.jl:703; ┌ Warning: type OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}} not present in workspace; reconstructing; └ @ JLD ~/.julia/packages/JLD/1BoSz/src/jld_types.jl:703; Checkpointing: Error During Test at /home/alir/Oceananigans.jl/test/runtests.jl:293; Got exception outside of a @test; MethodError: Cannot `convert` an object of type getfield(JLD, Symbol(""##Oceananigans.FaceFieldX{OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}},Oceananigans.RegularCartesianGrid{Core.Float64,Base.StepRangeLen{Core.Float64,Base.TwicePrecision{Core.Float64},Base.TwicePrecision{Core.Float64}}}}#384"")) to an object of type FaceFieldX; Closest candidates are:; convert(::Type{T}, !Matched::T) where T at essentials.jl:154; Stacktrace:; [1] jlconvert(::Type{VelocityFields}, ::JLD.JldFile, ::Ptr{UInt8}) at /home/alir/.julia/packages/JLD/1BoSz/src/jld_types.jl:434; [2] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:398; [3] read(::JLD.JldDataset) at /home/alir/.j",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/177
https://github.com/CliMA/Oceananigans.jl/issues/177:173,Testability,Test,Testing,173,"For now the 10 tests affected by this are skipped with `@test_skip` and will show up as ""Broken"". Maybe we just have to define `convert` for Fields with OffsetArrays?. ```; Testing checkpointing...; WARNING: Forcing functions will not be serialized!; [Checkpointer] Serializing model to disk: ./test_model_checkpoint_0.jld; [Checkpointer] Reconstructing FFT plans...; WARNING: Forcing functions will not be serialized!; [Checkpointer] Serializing model to disk: ./test_model_checkpoint_5.jld; [Checkpointer] Reconstructing FFT plans...; Deserializing model from disk: test_model_checkpoint_5.jld; ┌ Warning: type Oceananigans.FaceFieldX{OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}},Oceananigans.RegularCartesianGrid{Core.Float64,Base.StepRangeLen{Core.Float64,Base.TwicePrecision{Core.Float64},Base.TwicePrecision{Core.Float64}}}} not present in workspace; reconstructing; └ @ JLD ~/.julia/packages/JLD/1BoSz/src/jld_types.jl:703; ┌ Warning: type OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}} not present in workspace; reconstructing; └ @ JLD ~/.julia/packages/JLD/1BoSz/src/jld_types.jl:703; Checkpointing: Error During Test at /home/alir/Oceananigans.jl/test/runtests.jl:293; Got exception outside of a @test; MethodError: Cannot `convert` an object of type getfield(JLD, Symbol(""##Oceananigans.FaceFieldX{OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}},Oceananigans.RegularCartesianGrid{Core.Float64,Base.StepRangeLen{Core.Float64,Base.TwicePrecision{Core.Float64},Base.TwicePrecision{Core.Float64}}}}#384"")) to an object of type FaceFieldX; Closest candidates are:; convert(::Type{T}, !Matched::T) where T at essentials.jl:154; Stacktrace:; [1] jlconvert(::Type{VelocityFields}, ::JLD.JldFile, ::Ptr{UInt8}) at /home/alir/.julia/packages/JLD/1BoSz/src/jld_types.jl:434; [2] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:398; [3] read(::JLD.JldDataset) at /home/alir/.j",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/177
https://github.com/CliMA/Oceananigans.jl/issues/177:1166,Testability,Test,Test,1166,"s?. ```; Testing checkpointing...; WARNING: Forcing functions will not be serialized!; [Checkpointer] Serializing model to disk: ./test_model_checkpoint_0.jld; [Checkpointer] Reconstructing FFT plans...; WARNING: Forcing functions will not be serialized!; [Checkpointer] Serializing model to disk: ./test_model_checkpoint_5.jld; [Checkpointer] Reconstructing FFT plans...; Deserializing model from disk: test_model_checkpoint_5.jld; ┌ Warning: type Oceananigans.FaceFieldX{OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}},Oceananigans.RegularCartesianGrid{Core.Float64,Base.StepRangeLen{Core.Float64,Base.TwicePrecision{Core.Float64},Base.TwicePrecision{Core.Float64}}}} not present in workspace; reconstructing; └ @ JLD ~/.julia/packages/JLD/1BoSz/src/jld_types.jl:703; ┌ Warning: type OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}} not present in workspace; reconstructing; └ @ JLD ~/.julia/packages/JLD/1BoSz/src/jld_types.jl:703; Checkpointing: Error During Test at /home/alir/Oceananigans.jl/test/runtests.jl:293; Got exception outside of a @test; MethodError: Cannot `convert` an object of type getfield(JLD, Symbol(""##Oceananigans.FaceFieldX{OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}},Oceananigans.RegularCartesianGrid{Core.Float64,Base.StepRangeLen{Core.Float64,Base.TwicePrecision{Core.Float64},Base.TwicePrecision{Core.Float64}}}}#384"")) to an object of type FaceFieldX; Closest candidates are:; convert(::Type{T}, !Matched::T) where T at essentials.jl:154; Stacktrace:; [1] jlconvert(::Type{VelocityFields}, ::JLD.JldFile, ::Ptr{UInt8}) at /home/alir/.julia/packages/JLD/1BoSz/src/jld_types.jl:434; [2] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:398; [3] read(::JLD.JldDataset) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:370; [4] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:502; [5] jlconvert(",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/177
https://github.com/CliMA/Oceananigans.jl/issues/177:1201,Testability,test,test,1201,": Forcing functions will not be serialized!; [Checkpointer] Serializing model to disk: ./test_model_checkpoint_0.jld; [Checkpointer] Reconstructing FFT plans...; WARNING: Forcing functions will not be serialized!; [Checkpointer] Serializing model to disk: ./test_model_checkpoint_5.jld; [Checkpointer] Reconstructing FFT plans...; Deserializing model from disk: test_model_checkpoint_5.jld; ┌ Warning: type Oceananigans.FaceFieldX{OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}},Oceananigans.RegularCartesianGrid{Core.Float64,Base.StepRangeLen{Core.Float64,Base.TwicePrecision{Core.Float64},Base.TwicePrecision{Core.Float64}}}} not present in workspace; reconstructing; └ @ JLD ~/.julia/packages/JLD/1BoSz/src/jld_types.jl:703; ┌ Warning: type OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}} not present in workspace; reconstructing; └ @ JLD ~/.julia/packages/JLD/1BoSz/src/jld_types.jl:703; Checkpointing: Error During Test at /home/alir/Oceananigans.jl/test/runtests.jl:293; Got exception outside of a @test; MethodError: Cannot `convert` an object of type getfield(JLD, Symbol(""##Oceananigans.FaceFieldX{OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}},Oceananigans.RegularCartesianGrid{Core.Float64,Base.StepRangeLen{Core.Float64,Base.TwicePrecision{Core.Float64},Base.TwicePrecision{Core.Float64}}}}#384"")) to an object of type FaceFieldX; Closest candidates are:; convert(::Type{T}, !Matched::T) where T at essentials.jl:154; Stacktrace:; [1] jlconvert(::Type{VelocityFields}, ::JLD.JldFile, ::Ptr{UInt8}) at /home/alir/.julia/packages/JLD/1BoSz/src/jld_types.jl:434; [2] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:398; [3] read(::JLD.JldDataset) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:370; [4] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:502; [5] jlconvert(::Type{Model{CPU}}, ::JLD.JldFile, ::Ptr{UI",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/177
https://github.com/CliMA/Oceananigans.jl/issues/177:1251,Testability,test,test,1251,"model to disk: ./test_model_checkpoint_0.jld; [Checkpointer] Reconstructing FFT plans...; WARNING: Forcing functions will not be serialized!; [Checkpointer] Serializing model to disk: ./test_model_checkpoint_5.jld; [Checkpointer] Reconstructing FFT plans...; Deserializing model from disk: test_model_checkpoint_5.jld; ┌ Warning: type Oceananigans.FaceFieldX{OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}},Oceananigans.RegularCartesianGrid{Core.Float64,Base.StepRangeLen{Core.Float64,Base.TwicePrecision{Core.Float64},Base.TwicePrecision{Core.Float64}}}} not present in workspace; reconstructing; └ @ JLD ~/.julia/packages/JLD/1BoSz/src/jld_types.jl:703; ┌ Warning: type OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}} not present in workspace; reconstructing; └ @ JLD ~/.julia/packages/JLD/1BoSz/src/jld_types.jl:703; Checkpointing: Error During Test at /home/alir/Oceananigans.jl/test/runtests.jl:293; Got exception outside of a @test; MethodError: Cannot `convert` an object of type getfield(JLD, Symbol(""##Oceananigans.FaceFieldX{OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}},Oceananigans.RegularCartesianGrid{Core.Float64,Base.StepRangeLen{Core.Float64,Base.TwicePrecision{Core.Float64},Base.TwicePrecision{Core.Float64}}}}#384"")) to an object of type FaceFieldX; Closest candidates are:; convert(::Type{T}, !Matched::T) where T at essentials.jl:154; Stacktrace:; [1] jlconvert(::Type{VelocityFields}, ::JLD.JldFile, ::Ptr{UInt8}) at /home/alir/.julia/packages/JLD/1BoSz/src/jld_types.jl:434; [2] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:398; [3] read(::JLD.JldDataset) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:370; [4] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:502; [5] jlconvert(::Type{Model{CPU}}, ::JLD.JldFile, ::Ptr{UInt8}) at /home/alir/.julia/packages/JLD/1BoSz/src/jld_types.jl:387; [6] ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/177
https://github.com/CliMA/Oceananigans.jl/issues/177:2736,Testability,test,test,2736,"nGrid{Core.Float64,Base.StepRangeLen{Core.Float64,Base.TwicePrecision{Core.Float64},Base.TwicePrecision{Core.Float64}}}}#384"")) to an object of type FaceFieldX; Closest candidates are:; convert(::Type{T}, !Matched::T) where T at essentials.jl:154; Stacktrace:; [1] jlconvert(::Type{VelocityFields}, ::JLD.JldFile, ::Ptr{UInt8}) at /home/alir/.julia/packages/JLD/1BoSz/src/jld_types.jl:434; [2] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:398; [3] read(::JLD.JldDataset) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:370; [4] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:502; [5] jlconvert(::Type{Model{CPU}}, ::JLD.JldFile, ::Ptr{UInt8}) at /home/alir/.julia/packages/JLD/1BoSz/src/jld_types.jl:387; [6] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:398; [7] read(::JLD.JldDataset) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:370; [8] read(::JLD.JldFile, ::String) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:346; [9] restore_from_checkpoint(::String) at /home/alir/Oceananigans.jl/src/output_writers.jl:94; [10] run_thermal_bubble_checkpointer_tests() at /home/alir/Oceananigans.jl/test/test_output_writers.jl:34; [11] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:295; [12] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [13] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:294; [14] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [15] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:290; [16] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [17] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:14; [18] include(::String) at ./client.jl:403; [19] top-level scope at none:0; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/177
https://github.com/CliMA/Oceananigans.jl/issues/177:2819,Testability,test,test,2819,"nGrid{Core.Float64,Base.StepRangeLen{Core.Float64,Base.TwicePrecision{Core.Float64},Base.TwicePrecision{Core.Float64}}}}#384"")) to an object of type FaceFieldX; Closest candidates are:; convert(::Type{T}, !Matched::T) where T at essentials.jl:154; Stacktrace:; [1] jlconvert(::Type{VelocityFields}, ::JLD.JldFile, ::Ptr{UInt8}) at /home/alir/.julia/packages/JLD/1BoSz/src/jld_types.jl:434; [2] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:398; [3] read(::JLD.JldDataset) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:370; [4] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:502; [5] jlconvert(::Type{Model{CPU}}, ::JLD.JldFile, ::Ptr{UInt8}) at /home/alir/.julia/packages/JLD/1BoSz/src/jld_types.jl:387; [6] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:398; [7] read(::JLD.JldDataset) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:370; [8] read(::JLD.JldFile, ::String) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:346; [9] restore_from_checkpoint(::String) at /home/alir/Oceananigans.jl/src/output_writers.jl:94; [10] run_thermal_bubble_checkpointer_tests() at /home/alir/Oceananigans.jl/test/test_output_writers.jl:34; [11] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:295; [12] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [13] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:294; [14] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [15] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:290; [16] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [17] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:14; [18] include(::String) at ./client.jl:403; [19] top-level scope at none:0; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/177
https://github.com/CliMA/Oceananigans.jl/issues/177:2922,Testability,Test,Test,2922,"nGrid{Core.Float64,Base.StepRangeLen{Core.Float64,Base.TwicePrecision{Core.Float64},Base.TwicePrecision{Core.Float64}}}}#384"")) to an object of type FaceFieldX; Closest candidates are:; convert(::Type{T}, !Matched::T) where T at essentials.jl:154; Stacktrace:; [1] jlconvert(::Type{VelocityFields}, ::JLD.JldFile, ::Ptr{UInt8}) at /home/alir/.julia/packages/JLD/1BoSz/src/jld_types.jl:434; [2] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:398; [3] read(::JLD.JldDataset) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:370; [4] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:502; [5] jlconvert(::Type{Model{CPU}}, ::JLD.JldFile, ::Ptr{UInt8}) at /home/alir/.julia/packages/JLD/1BoSz/src/jld_types.jl:387; [6] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:398; [7] read(::JLD.JldDataset) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:370; [8] read(::JLD.JldFile, ::String) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:346; [9] restore_from_checkpoint(::String) at /home/alir/Oceananigans.jl/src/output_writers.jl:94; [10] run_thermal_bubble_checkpointer_tests() at /home/alir/Oceananigans.jl/test/test_output_writers.jl:34; [11] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:295; [12] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [13] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:294; [14] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [15] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:290; [16] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [17] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:14; [18] include(::String) at ./client.jl:403; [19] top-level scope at none:0; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/177
https://github.com/CliMA/Oceananigans.jl/issues/177:2931,Testability,Test,Test,2931,"nGrid{Core.Float64,Base.StepRangeLen{Core.Float64,Base.TwicePrecision{Core.Float64},Base.TwicePrecision{Core.Float64}}}}#384"")) to an object of type FaceFieldX; Closest candidates are:; convert(::Type{T}, !Matched::T) where T at essentials.jl:154; Stacktrace:; [1] jlconvert(::Type{VelocityFields}, ::JLD.JldFile, ::Ptr{UInt8}) at /home/alir/.julia/packages/JLD/1BoSz/src/jld_types.jl:434; [2] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:398; [3] read(::JLD.JldDataset) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:370; [4] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:502; [5] jlconvert(::Type{Model{CPU}}, ::JLD.JldFile, ::Ptr{UInt8}) at /home/alir/.julia/packages/JLD/1BoSz/src/jld_types.jl:387; [6] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:398; [7] read(::JLD.JldDataset) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:370; [8] read(::JLD.JldFile, ::String) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:346; [9] restore_from_checkpoint(::String) at /home/alir/Oceananigans.jl/src/output_writers.jl:94; [10] run_thermal_bubble_checkpointer_tests() at /home/alir/Oceananigans.jl/test/test_output_writers.jl:34; [11] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:295; [12] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [13] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:294; [14] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [15] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:290; [16] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [17] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:14; [18] include(::String) at ./client.jl:403; [19] top-level scope at none:0; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/177
https://github.com/CliMA/Oceananigans.jl/issues/177:2996,Testability,test,test,2996,"nGrid{Core.Float64,Base.StepRangeLen{Core.Float64,Base.TwicePrecision{Core.Float64},Base.TwicePrecision{Core.Float64}}}}#384"")) to an object of type FaceFieldX; Closest candidates are:; convert(::Type{T}, !Matched::T) where T at essentials.jl:154; Stacktrace:; [1] jlconvert(::Type{VelocityFields}, ::JLD.JldFile, ::Ptr{UInt8}) at /home/alir/.julia/packages/JLD/1BoSz/src/jld_types.jl:434; [2] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:398; [3] read(::JLD.JldDataset) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:370; [4] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:502; [5] jlconvert(::Type{Model{CPU}}, ::JLD.JldFile, ::Ptr{UInt8}) at /home/alir/.julia/packages/JLD/1BoSz/src/jld_types.jl:387; [6] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:398; [7] read(::JLD.JldDataset) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:370; [8] read(::JLD.JldFile, ::String) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:346; [9] restore_from_checkpoint(::String) at /home/alir/Oceananigans.jl/src/output_writers.jl:94; [10] run_thermal_bubble_checkpointer_tests() at /home/alir/Oceananigans.jl/test/test_output_writers.jl:34; [11] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:295; [12] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [13] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:294; [14] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [15] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:290; [16] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [17] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:14; [18] include(::String) at ./client.jl:403; [19] top-level scope at none:0; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/177
https://github.com/CliMA/Oceananigans.jl/issues/177:3099,Testability,Test,Test,3099,"nGrid{Core.Float64,Base.StepRangeLen{Core.Float64,Base.TwicePrecision{Core.Float64},Base.TwicePrecision{Core.Float64}}}}#384"")) to an object of type FaceFieldX; Closest candidates are:; convert(::Type{T}, !Matched::T) where T at essentials.jl:154; Stacktrace:; [1] jlconvert(::Type{VelocityFields}, ::JLD.JldFile, ::Ptr{UInt8}) at /home/alir/.julia/packages/JLD/1BoSz/src/jld_types.jl:434; [2] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:398; [3] read(::JLD.JldDataset) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:370; [4] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:502; [5] jlconvert(::Type{Model{CPU}}, ::JLD.JldFile, ::Ptr{UInt8}) at /home/alir/.julia/packages/JLD/1BoSz/src/jld_types.jl:387; [6] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:398; [7] read(::JLD.JldDataset) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:370; [8] read(::JLD.JldFile, ::String) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:346; [9] restore_from_checkpoint(::String) at /home/alir/Oceananigans.jl/src/output_writers.jl:94; [10] run_thermal_bubble_checkpointer_tests() at /home/alir/Oceananigans.jl/test/test_output_writers.jl:34; [11] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:295; [12] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [13] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:294; [14] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [15] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:290; [16] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [17] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:14; [18] include(::String) at ./client.jl:403; [19] top-level scope at none:0; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/177
https://github.com/CliMA/Oceananigans.jl/issues/177:3108,Testability,Test,Test,3108,"nGrid{Core.Float64,Base.StepRangeLen{Core.Float64,Base.TwicePrecision{Core.Float64},Base.TwicePrecision{Core.Float64}}}}#384"")) to an object of type FaceFieldX; Closest candidates are:; convert(::Type{T}, !Matched::T) where T at essentials.jl:154; Stacktrace:; [1] jlconvert(::Type{VelocityFields}, ::JLD.JldFile, ::Ptr{UInt8}) at /home/alir/.julia/packages/JLD/1BoSz/src/jld_types.jl:434; [2] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:398; [3] read(::JLD.JldDataset) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:370; [4] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:502; [5] jlconvert(::Type{Model{CPU}}, ::JLD.JldFile, ::Ptr{UInt8}) at /home/alir/.julia/packages/JLD/1BoSz/src/jld_types.jl:387; [6] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:398; [7] read(::JLD.JldDataset) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:370; [8] read(::JLD.JldFile, ::String) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:346; [9] restore_from_checkpoint(::String) at /home/alir/Oceananigans.jl/src/output_writers.jl:94; [10] run_thermal_bubble_checkpointer_tests() at /home/alir/Oceananigans.jl/test/test_output_writers.jl:34; [11] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:295; [12] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [13] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:294; [14] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [15] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:290; [16] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [17] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:14; [18] include(::String) at ./client.jl:403; [19] top-level scope at none:0; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/177
https://github.com/CliMA/Oceananigans.jl/issues/177:3173,Testability,test,test,3173,"nGrid{Core.Float64,Base.StepRangeLen{Core.Float64,Base.TwicePrecision{Core.Float64},Base.TwicePrecision{Core.Float64}}}}#384"")) to an object of type FaceFieldX; Closest candidates are:; convert(::Type{T}, !Matched::T) where T at essentials.jl:154; Stacktrace:; [1] jlconvert(::Type{VelocityFields}, ::JLD.JldFile, ::Ptr{UInt8}) at /home/alir/.julia/packages/JLD/1BoSz/src/jld_types.jl:434; [2] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:398; [3] read(::JLD.JldDataset) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:370; [4] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:502; [5] jlconvert(::Type{Model{CPU}}, ::JLD.JldFile, ::Ptr{UInt8}) at /home/alir/.julia/packages/JLD/1BoSz/src/jld_types.jl:387; [6] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:398; [7] read(::JLD.JldDataset) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:370; [8] read(::JLD.JldFile, ::String) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:346; [9] restore_from_checkpoint(::String) at /home/alir/Oceananigans.jl/src/output_writers.jl:94; [10] run_thermal_bubble_checkpointer_tests() at /home/alir/Oceananigans.jl/test/test_output_writers.jl:34; [11] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:295; [12] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [13] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:294; [14] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [15] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:290; [16] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [17] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:14; [18] include(::String) at ./client.jl:403; [19] top-level scope at none:0; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/177
https://github.com/CliMA/Oceananigans.jl/issues/177:3276,Testability,Test,Test,3276,"nGrid{Core.Float64,Base.StepRangeLen{Core.Float64,Base.TwicePrecision{Core.Float64},Base.TwicePrecision{Core.Float64}}}}#384"")) to an object of type FaceFieldX; Closest candidates are:; convert(::Type{T}, !Matched::T) where T at essentials.jl:154; Stacktrace:; [1] jlconvert(::Type{VelocityFields}, ::JLD.JldFile, ::Ptr{UInt8}) at /home/alir/.julia/packages/JLD/1BoSz/src/jld_types.jl:434; [2] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:398; [3] read(::JLD.JldDataset) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:370; [4] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:502; [5] jlconvert(::Type{Model{CPU}}, ::JLD.JldFile, ::Ptr{UInt8}) at /home/alir/.julia/packages/JLD/1BoSz/src/jld_types.jl:387; [6] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:398; [7] read(::JLD.JldDataset) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:370; [8] read(::JLD.JldFile, ::String) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:346; [9] restore_from_checkpoint(::String) at /home/alir/Oceananigans.jl/src/output_writers.jl:94; [10] run_thermal_bubble_checkpointer_tests() at /home/alir/Oceananigans.jl/test/test_output_writers.jl:34; [11] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:295; [12] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [13] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:294; [14] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [15] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:290; [16] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [17] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:14; [18] include(::String) at ./client.jl:403; [19] top-level scope at none:0; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/177
https://github.com/CliMA/Oceananigans.jl/issues/177:3285,Testability,Test,Test,3285,"nGrid{Core.Float64,Base.StepRangeLen{Core.Float64,Base.TwicePrecision{Core.Float64},Base.TwicePrecision{Core.Float64}}}}#384"")) to an object of type FaceFieldX; Closest candidates are:; convert(::Type{T}, !Matched::T) where T at essentials.jl:154; Stacktrace:; [1] jlconvert(::Type{VelocityFields}, ::JLD.JldFile, ::Ptr{UInt8}) at /home/alir/.julia/packages/JLD/1BoSz/src/jld_types.jl:434; [2] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:398; [3] read(::JLD.JldDataset) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:370; [4] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:502; [5] jlconvert(::Type{Model{CPU}}, ::JLD.JldFile, ::Ptr{UInt8}) at /home/alir/.julia/packages/JLD/1BoSz/src/jld_types.jl:387; [6] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:398; [7] read(::JLD.JldDataset) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:370; [8] read(::JLD.JldFile, ::String) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:346; [9] restore_from_checkpoint(::String) at /home/alir/Oceananigans.jl/src/output_writers.jl:94; [10] run_thermal_bubble_checkpointer_tests() at /home/alir/Oceananigans.jl/test/test_output_writers.jl:34; [11] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:295; [12] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [13] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:294; [14] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [15] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:290; [16] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [17] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:14; [18] include(::String) at ./client.jl:403; [19] top-level scope at none:0; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/177
https://github.com/CliMA/Oceananigans.jl/issues/177:3350,Testability,test,test,3350,"nGrid{Core.Float64,Base.StepRangeLen{Core.Float64,Base.TwicePrecision{Core.Float64},Base.TwicePrecision{Core.Float64}}}}#384"")) to an object of type FaceFieldX; Closest candidates are:; convert(::Type{T}, !Matched::T) where T at essentials.jl:154; Stacktrace:; [1] jlconvert(::Type{VelocityFields}, ::JLD.JldFile, ::Ptr{UInt8}) at /home/alir/.julia/packages/JLD/1BoSz/src/jld_types.jl:434; [2] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:398; [3] read(::JLD.JldDataset) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:370; [4] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:502; [5] jlconvert(::Type{Model{CPU}}, ::JLD.JldFile, ::Ptr{UInt8}) at /home/alir/.julia/packages/JLD/1BoSz/src/jld_types.jl:387; [6] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:398; [7] read(::JLD.JldDataset) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:370; [8] read(::JLD.JldFile, ::String) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:346; [9] restore_from_checkpoint(::String) at /home/alir/Oceananigans.jl/src/output_writers.jl:94; [10] run_thermal_bubble_checkpointer_tests() at /home/alir/Oceananigans.jl/test/test_output_writers.jl:34; [11] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:295; [12] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [13] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:294; [14] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [15] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:290; [16] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [17] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:14; [18] include(::String) at ./client.jl:403; [19] top-level scope at none:0; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/177
https://github.com/CliMA/Oceananigans.jl/issues/178:140,Availability,error,error,140,"This would be nice because most people might first install Oceananigans on their laptop without a GPU or CUDA toolkit, and are greeted with error messages that e.g. CUDAdrv failed to build. While harmless errors, they don't look nice and make the package seem unstable. This would also speed up Travis CI and Appveyor builds. ---; Relevant bits from `Pkg.instantiate()`:; ```; ┌ Error: Error building `CUDAdrv`: ; │ Could not find CUDA driver library.; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAnative`: ; │ Dependent package CUDAdrv.jl has not been built successfully.; │ ; │ This is not a fatal error, but GPU functionality will be unavailable.; │ If you expected this to work, please open a thread on; │ https://discourse.julialang.org/c/domain/gpu; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; │ Dependent package CUDAdrv.jl has not been built successfully; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; Building SpecialFunctions → `~/.julia/packages/SpecialFunctions/fvheQ/deps/build.log`; Building LLVM ────────────→ `~/.julia/packages/LLVM/tg8MX/deps/build.log`; Building CUDAnative ──────→ `~/.julia/packages/CUDAnative/B210M/deps/build.log`; Dependent package CUDAdrv.jl has not been built successfully.; This is not a fatal error, but GPU functionality will be unavailable.; If you expected this to work, please open a thread on; https://discourse.julialang.org/c/domain/gpu; ┌ Error: Error buildin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178
https://github.com/CliMA/Oceananigans.jl/issues/178:205,Availability,error,errors,205,"This would be nice because most people might first install Oceananigans on their laptop without a GPU or CUDA toolkit, and are greeted with error messages that e.g. CUDAdrv failed to build. While harmless errors, they don't look nice and make the package seem unstable. This would also speed up Travis CI and Appveyor builds. ---; Relevant bits from `Pkg.instantiate()`:; ```; ┌ Error: Error building `CUDAdrv`: ; │ Could not find CUDA driver library.; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAnative`: ; │ Dependent package CUDAdrv.jl has not been built successfully.; │ ; │ This is not a fatal error, but GPU functionality will be unavailable.; │ If you expected this to work, please open a thread on; │ https://discourse.julialang.org/c/domain/gpu; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; │ Dependent package CUDAdrv.jl has not been built successfully; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; Building SpecialFunctions → `~/.julia/packages/SpecialFunctions/fvheQ/deps/build.log`; Building LLVM ────────────→ `~/.julia/packages/LLVM/tg8MX/deps/build.log`; Building CUDAnative ──────→ `~/.julia/packages/CUDAnative/B210M/deps/build.log`; Dependent package CUDAdrv.jl has not been built successfully.; This is not a fatal error, but GPU functionality will be unavailable.; If you expected this to work, please open a thread on; https://discourse.julialang.org/c/domain/gpu; ┌ Error: Error buildin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178
https://github.com/CliMA/Oceananigans.jl/issues/178:379,Availability,Error,Error,379,"This would be nice because most people might first install Oceananigans on their laptop without a GPU or CUDA toolkit, and are greeted with error messages that e.g. CUDAdrv failed to build. While harmless errors, they don't look nice and make the package seem unstable. This would also speed up Travis CI and Appveyor builds. ---; Relevant bits from `Pkg.instantiate()`:; ```; ┌ Error: Error building `CUDAdrv`: ; │ Could not find CUDA driver library.; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAnative`: ; │ Dependent package CUDAdrv.jl has not been built successfully.; │ ; │ This is not a fatal error, but GPU functionality will be unavailable.; │ If you expected this to work, please open a thread on; │ https://discourse.julialang.org/c/domain/gpu; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; │ Dependent package CUDAdrv.jl has not been built successfully; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; Building SpecialFunctions → `~/.julia/packages/SpecialFunctions/fvheQ/deps/build.log`; Building LLVM ────────────→ `~/.julia/packages/LLVM/tg8MX/deps/build.log`; Building CUDAnative ──────→ `~/.julia/packages/CUDAnative/B210M/deps/build.log`; Dependent package CUDAdrv.jl has not been built successfully.; This is not a fatal error, but GPU functionality will be unavailable.; If you expected this to work, please open a thread on; https://discourse.julialang.org/c/domain/gpu; ┌ Error: Error buildin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178
https://github.com/CliMA/Oceananigans.jl/issues/178:386,Availability,Error,Error,386,"This would be nice because most people might first install Oceananigans on their laptop without a GPU or CUDA toolkit, and are greeted with error messages that e.g. CUDAdrv failed to build. While harmless errors, they don't look nice and make the package seem unstable. This would also speed up Travis CI and Appveyor builds. ---; Relevant bits from `Pkg.instantiate()`:; ```; ┌ Error: Error building `CUDAdrv`: ; │ Could not find CUDA driver library.; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAnative`: ; │ Dependent package CUDAdrv.jl has not been built successfully.; │ ; │ This is not a fatal error, but GPU functionality will be unavailable.; │ If you expected this to work, please open a thread on; │ https://discourse.julialang.org/c/domain/gpu; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; │ Dependent package CUDAdrv.jl has not been built successfully; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; Building SpecialFunctions → `~/.julia/packages/SpecialFunctions/fvheQ/deps/build.log`; Building LLVM ────────────→ `~/.julia/packages/LLVM/tg8MX/deps/build.log`; Building CUDAnative ──────→ `~/.julia/packages/CUDAnative/B210M/deps/build.log`; Dependent package CUDAdrv.jl has not been built successfully.; This is not a fatal error, but GPU functionality will be unavailable.; If you expected this to work, please open a thread on; https://discourse.julialang.org/c/domain/gpu; ┌ Error: Error buildin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178
https://github.com/CliMA/Oceananigans.jl/issues/178:572,Availability,Error,Error,572,"This would be nice because most people might first install Oceananigans on their laptop without a GPU or CUDA toolkit, and are greeted with error messages that e.g. CUDAdrv failed to build. While harmless errors, they don't look nice and make the package seem unstable. This would also speed up Travis CI and Appveyor builds. ---; Relevant bits from `Pkg.instantiate()`:; ```; ┌ Error: Error building `CUDAdrv`: ; │ Could not find CUDA driver library.; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAnative`: ; │ Dependent package CUDAdrv.jl has not been built successfully.; │ ; │ This is not a fatal error, but GPU functionality will be unavailable.; │ If you expected this to work, please open a thread on; │ https://discourse.julialang.org/c/domain/gpu; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; │ Dependent package CUDAdrv.jl has not been built successfully; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; Building SpecialFunctions → `~/.julia/packages/SpecialFunctions/fvheQ/deps/build.log`; Building LLVM ────────────→ `~/.julia/packages/LLVM/tg8MX/deps/build.log`; Building CUDAnative ──────→ `~/.julia/packages/CUDAnative/B210M/deps/build.log`; Dependent package CUDAdrv.jl has not been built successfully.; This is not a fatal error, but GPU functionality will be unavailable.; If you expected this to work, please open a thread on; https://discourse.julialang.org/c/domain/gpu; ┌ Error: Error buildin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178
https://github.com/CliMA/Oceananigans.jl/issues/178:579,Availability,Error,Error,579,"This would be nice because most people might first install Oceananigans on their laptop without a GPU or CUDA toolkit, and are greeted with error messages that e.g. CUDAdrv failed to build. While harmless errors, they don't look nice and make the package seem unstable. This would also speed up Travis CI and Appveyor builds. ---; Relevant bits from `Pkg.instantiate()`:; ```; ┌ Error: Error building `CUDAdrv`: ; │ Could not find CUDA driver library.; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAnative`: ; │ Dependent package CUDAdrv.jl has not been built successfully.; │ ; │ This is not a fatal error, but GPU functionality will be unavailable.; │ If you expected this to work, please open a thread on; │ https://discourse.julialang.org/c/domain/gpu; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; │ Dependent package CUDAdrv.jl has not been built successfully; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; Building SpecialFunctions → `~/.julia/packages/SpecialFunctions/fvheQ/deps/build.log`; Building LLVM ────────────→ `~/.julia/packages/LLVM/tg8MX/deps/build.log`; Building CUDAnative ──────→ `~/.julia/packages/CUDAnative/B210M/deps/build.log`; Dependent package CUDAdrv.jl has not been built successfully.; This is not a fatal error, but GPU functionality will be unavailable.; If you expected this to work, please open a thread on; https://discourse.julialang.org/c/domain/gpu; ┌ Error: Error buildin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178
https://github.com/CliMA/Oceananigans.jl/issues/178:701,Availability,error,error,701,"This would be nice because most people might first install Oceananigans on their laptop without a GPU or CUDA toolkit, and are greeted with error messages that e.g. CUDAdrv failed to build. While harmless errors, they don't look nice and make the package seem unstable. This would also speed up Travis CI and Appveyor builds. ---; Relevant bits from `Pkg.instantiate()`:; ```; ┌ Error: Error building `CUDAdrv`: ; │ Could not find CUDA driver library.; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAnative`: ; │ Dependent package CUDAdrv.jl has not been built successfully.; │ ; │ This is not a fatal error, but GPU functionality will be unavailable.; │ If you expected this to work, please open a thread on; │ https://discourse.julialang.org/c/domain/gpu; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; │ Dependent package CUDAdrv.jl has not been built successfully; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; Building SpecialFunctions → `~/.julia/packages/SpecialFunctions/fvheQ/deps/build.log`; Building LLVM ────────────→ `~/.julia/packages/LLVM/tg8MX/deps/build.log`; Building CUDAnative ──────→ `~/.julia/packages/CUDAnative/B210M/deps/build.log`; Dependent package CUDAdrv.jl has not been built successfully.; This is not a fatal error, but GPU functionality will be unavailable.; If you expected this to work, please open a thread on; https://discourse.julialang.org/c/domain/gpu; ┌ Error: Error buildin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178
https://github.com/CliMA/Oceananigans.jl/issues/178:976,Availability,Error,Error,976,"is would be nice because most people might first install Oceananigans on their laptop without a GPU or CUDA toolkit, and are greeted with error messages that e.g. CUDAdrv failed to build. While harmless errors, they don't look nice and make the package seem unstable. This would also speed up Travis CI and Appveyor builds. ---; Relevant bits from `Pkg.instantiate()`:; ```; ┌ Error: Error building `CUDAdrv`: ; │ Could not find CUDA driver library.; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAnative`: ; │ Dependent package CUDAdrv.jl has not been built successfully.; │ ; │ This is not a fatal error, but GPU functionality will be unavailable.; │ If you expected this to work, please open a thread on; │ https://discourse.julialang.org/c/domain/gpu; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; │ Dependent package CUDAdrv.jl has not been built successfully; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; Building SpecialFunctions → `~/.julia/packages/SpecialFunctions/fvheQ/deps/build.log`; Building LLVM ────────────→ `~/.julia/packages/LLVM/tg8MX/deps/build.log`; Building CUDAnative ──────→ `~/.julia/packages/CUDAnative/B210M/deps/build.log`; Dependent package CUDAdrv.jl has not been built successfully.; This is not a fatal error, but GPU functionality will be unavailable.; If you expected this to work, please open a thread on; https://discourse.julialang.org/c/domain/gpu; ┌ Error: Error building ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178
https://github.com/CliMA/Oceananigans.jl/issues/178:983,Availability,Error,Error,983,"is would be nice because most people might first install Oceananigans on their laptop without a GPU or CUDA toolkit, and are greeted with error messages that e.g. CUDAdrv failed to build. While harmless errors, they don't look nice and make the package seem unstable. This would also speed up Travis CI and Appveyor builds. ---; Relevant bits from `Pkg.instantiate()`:; ```; ┌ Error: Error building `CUDAdrv`: ; │ Could not find CUDA driver library.; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAnative`: ; │ Dependent package CUDAdrv.jl has not been built successfully.; │ ; │ This is not a fatal error, but GPU functionality will be unavailable.; │ If you expected this to work, please open a thread on; │ https://discourse.julialang.org/c/domain/gpu; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; │ Dependent package CUDAdrv.jl has not been built successfully; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; Building SpecialFunctions → `~/.julia/packages/SpecialFunctions/fvheQ/deps/build.log`; Building LLVM ────────────→ `~/.julia/packages/LLVM/tg8MX/deps/build.log`; Building CUDAnative ──────→ `~/.julia/packages/CUDAnative/B210M/deps/build.log`; Dependent package CUDAdrv.jl has not been built successfully.; This is not a fatal error, but GPU functionality will be unavailable.; If you expected this to work, please open a thread on; https://discourse.julialang.org/c/domain/gpu; ┌ Error: Error building ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178
https://github.com/CliMA/Oceananigans.jl/issues/178:1195,Availability,Error,Error,1195,", they don't look nice and make the package seem unstable. This would also speed up Travis CI and Appveyor builds. ---; Relevant bits from `Pkg.instantiate()`:; ```; ┌ Error: Error building `CUDAdrv`: ; │ Could not find CUDA driver library.; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAnative`: ; │ Dependent package CUDAdrv.jl has not been built successfully.; │ ; │ This is not a fatal error, but GPU functionality will be unavailable.; │ If you expected this to work, please open a thread on; │ https://discourse.julialang.org/c/domain/gpu; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; │ Dependent package CUDAdrv.jl has not been built successfully; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; Building SpecialFunctions → `~/.julia/packages/SpecialFunctions/fvheQ/deps/build.log`; Building LLVM ────────────→ `~/.julia/packages/LLVM/tg8MX/deps/build.log`; Building CUDAnative ──────→ `~/.julia/packages/CUDAnative/B210M/deps/build.log`; Dependent package CUDAdrv.jl has not been built successfully.; This is not a fatal error, but GPU functionality will be unavailable.; If you expected this to work, please open a thread on; https://discourse.julialang.org/c/domain/gpu; ┌ Error: Error building `CUDAnative`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; └ @ Pkg.Operations /buildworker/worke",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178
https://github.com/CliMA/Oceananigans.jl/issues/178:1202,Availability,Error,Error,1202,", they don't look nice and make the package seem unstable. This would also speed up Travis CI and Appveyor builds. ---; Relevant bits from `Pkg.instantiate()`:; ```; ┌ Error: Error building `CUDAdrv`: ; │ Could not find CUDA driver library.; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAnative`: ; │ Dependent package CUDAdrv.jl has not been built successfully.; │ ; │ This is not a fatal error, but GPU functionality will be unavailable.; │ If you expected this to work, please open a thread on; │ https://discourse.julialang.org/c/domain/gpu; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; │ Dependent package CUDAdrv.jl has not been built successfully; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; Building SpecialFunctions → `~/.julia/packages/SpecialFunctions/fvheQ/deps/build.log`; Building LLVM ────────────→ `~/.julia/packages/LLVM/tg8MX/deps/build.log`; Building CUDAnative ──────→ `~/.julia/packages/CUDAnative/B210M/deps/build.log`; Dependent package CUDAdrv.jl has not been built successfully.; This is not a fatal error, but GPU functionality will be unavailable.; If you expected this to work, please open a thread on; https://discourse.julialang.org/c/domain/gpu; ┌ Error: Error building `CUDAnative`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; └ @ Pkg.Operations /buildworker/worke",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178
https://github.com/CliMA/Oceananigans.jl/issues/178:1349,Availability,Error,Error,1349,"e()`:; ```; ┌ Error: Error building `CUDAdrv`: ; │ Could not find CUDA driver library.; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAnative`: ; │ Dependent package CUDAdrv.jl has not been built successfully.; │ ; │ This is not a fatal error, but GPU functionality will be unavailable.; │ If you expected this to work, please open a thread on; │ https://discourse.julialang.org/c/domain/gpu; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; │ Dependent package CUDAdrv.jl has not been built successfully; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; Building SpecialFunctions → `~/.julia/packages/SpecialFunctions/fvheQ/deps/build.log`; Building LLVM ────────────→ `~/.julia/packages/LLVM/tg8MX/deps/build.log`; Building CUDAnative ──────→ `~/.julia/packages/CUDAnative/B210M/deps/build.log`; Dependent package CUDAdrv.jl has not been built successfully.; This is not a fatal error, but GPU functionality will be unavailable.; If you expected this to work, please open a thread on; https://discourse.julialang.org/c/domain/gpu; ┌ Error: Error building `CUDAnative`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ERROR: LoadError: LoadError: UndefVarError: CUBLAS not defined; Stacktrace",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178
https://github.com/CliMA/Oceananigans.jl/issues/178:1356,Availability,Error,Error,1356,"e()`:; ```; ┌ Error: Error building `CUDAdrv`: ; │ Could not find CUDA driver library.; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAnative`: ; │ Dependent package CUDAdrv.jl has not been built successfully.; │ ; │ This is not a fatal error, but GPU functionality will be unavailable.; │ If you expected this to work, please open a thread on; │ https://discourse.julialang.org/c/domain/gpu; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; │ Dependent package CUDAdrv.jl has not been built successfully; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; Building SpecialFunctions → `~/.julia/packages/SpecialFunctions/fvheQ/deps/build.log`; Building LLVM ────────────→ `~/.julia/packages/LLVM/tg8MX/deps/build.log`; Building CUDAnative ──────→ `~/.julia/packages/CUDAnative/B210M/deps/build.log`; Dependent package CUDAdrv.jl has not been built successfully.; This is not a fatal error, but GPU functionality will be unavailable.; If you expected this to work, please open a thread on; https://discourse.julialang.org/c/domain/gpu; ┌ Error: Error building `CUDAnative`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ERROR: LoadError: LoadError: UndefVarError: CUBLAS not defined; Stacktrace",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178
https://github.com/CliMA/Oceananigans.jl/issues/178:1827,Availability,error,error,1827,"rg/c/domain/gpu; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; │ Dependent package CUDAdrv.jl has not been built successfully; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; Building SpecialFunctions → `~/.julia/packages/SpecialFunctions/fvheQ/deps/build.log`; Building LLVM ────────────→ `~/.julia/packages/LLVM/tg8MX/deps/build.log`; Building CUDAnative ──────→ `~/.julia/packages/CUDAnative/B210M/deps/build.log`; Dependent package CUDAdrv.jl has not been built successfully.; This is not a fatal error, but GPU functionality will be unavailable.; If you expected this to work, please open a thread on; https://discourse.julialang.org/c/domain/gpu; ┌ Error: Error building `CUDAnative`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ERROR: LoadError: LoadError: UndefVarError: CUBLAS not defined; Stacktrace:; [1] top-level scope at none:0 (repeats 2 times); [2] include at ./boot.jl:326 [inlined]; [3] include_relative(::Module, ::String) at ./loading.jl:1038; [4] include at ./sysimg.jl:29 [inlined]; [5] include(::String) at /home/travis/.julia/packages/CuArrays/qZCAt/src/CuArrays.jl:3; [6] top-level scope at none:0; [7] include at ./boot.jl:326 [inlined]; [8] include_relative(::Module, ::String) at ./loading.jl:1038; [9] include(::Module, ::String) at ./sysimg.jl:29; [10] to",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178
https://github.com/CliMA/Oceananigans.jl/issues/178:1981,Availability,Error,Error,1981,"ing `CuArrays`: ; │ Dependent package CUDAdrv.jl has not been built successfully; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; Building SpecialFunctions → `~/.julia/packages/SpecialFunctions/fvheQ/deps/build.log`; Building LLVM ────────────→ `~/.julia/packages/LLVM/tg8MX/deps/build.log`; Building CUDAnative ──────→ `~/.julia/packages/CUDAnative/B210M/deps/build.log`; Dependent package CUDAdrv.jl has not been built successfully.; This is not a fatal error, but GPU functionality will be unavailable.; If you expected this to work, please open a thread on; https://discourse.julialang.org/c/domain/gpu; ┌ Error: Error building `CUDAnative`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ERROR: LoadError: LoadError: UndefVarError: CUBLAS not defined; Stacktrace:; [1] top-level scope at none:0 (repeats 2 times); [2] include at ./boot.jl:326 [inlined]; [3] include_relative(::Module, ::String) at ./loading.jl:1038; [4] include at ./sysimg.jl:29 [inlined]; [5] include(::String) at /home/travis/.julia/packages/CuArrays/qZCAt/src/CuArrays.jl:3; [6] top-level scope at none:0; [7] include at ./boot.jl:326 [inlined]; [8] include_relative(::Module, ::String) at ./loading.jl:1038; [9] include(::Module, ::String) at ./sysimg.jl:29; [10] top-level scope at none:2; [11] eval at ./boot.jl:328 [inlined]; [12] eval(::Expr) at ./client.jl:404; [13] top-level scope at ./none:3; ```; The cuBLAS er",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178
https://github.com/CliMA/Oceananigans.jl/issues/178:1988,Availability,Error,Error,1988,"ing `CuArrays`: ; │ Dependent package CUDAdrv.jl has not been built successfully; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; Building SpecialFunctions → `~/.julia/packages/SpecialFunctions/fvheQ/deps/build.log`; Building LLVM ────────────→ `~/.julia/packages/LLVM/tg8MX/deps/build.log`; Building CUDAnative ──────→ `~/.julia/packages/CUDAnative/B210M/deps/build.log`; Dependent package CUDAdrv.jl has not been built successfully.; This is not a fatal error, but GPU functionality will be unavailable.; If you expected this to work, please open a thread on; https://discourse.julialang.org/c/domain/gpu; ┌ Error: Error building `CUDAnative`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ERROR: LoadError: LoadError: UndefVarError: CUBLAS not defined; Stacktrace:; [1] top-level scope at none:0 (repeats 2 times); [2] include at ./boot.jl:326 [inlined]; [3] include_relative(::Module, ::String) at ./loading.jl:1038; [4] include at ./sysimg.jl:29 [inlined]; [5] include(::String) at /home/travis/.julia/packages/CuArrays/qZCAt/src/CuArrays.jl:3; [6] top-level scope at none:0; [7] include at ./boot.jl:326 [inlined]; [8] include_relative(::Module, ::String) at ./loading.jl:1038; [9] include(::Module, ::String) at ./sysimg.jl:29; [10] top-level scope at none:2; [11] eval at ./boot.jl:328 [inlined]; [12] eval(::Expr) at ./client.jl:404; [13] top-level scope at ./none:3; ```; The cuBLAS er",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178
https://github.com/CliMA/Oceananigans.jl/issues/178:2138,Availability,Error,Error,2138,"@ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; Building SpecialFunctions → `~/.julia/packages/SpecialFunctions/fvheQ/deps/build.log`; Building LLVM ────────────→ `~/.julia/packages/LLVM/tg8MX/deps/build.log`; Building CUDAnative ──────→ `~/.julia/packages/CUDAnative/B210M/deps/build.log`; Dependent package CUDAdrv.jl has not been built successfully.; This is not a fatal error, but GPU functionality will be unavailable.; If you expected this to work, please open a thread on; https://discourse.julialang.org/c/domain/gpu; ┌ Error: Error building `CUDAnative`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ERROR: LoadError: LoadError: UndefVarError: CUBLAS not defined; Stacktrace:; [1] top-level scope at none:0 (repeats 2 times); [2] include at ./boot.jl:326 [inlined]; [3] include_relative(::Module, ::String) at ./loading.jl:1038; [4] include at ./sysimg.jl:29 [inlined]; [5] include(::String) at /home/travis/.julia/packages/CuArrays/qZCAt/src/CuArrays.jl:3; [6] top-level scope at none:0; [7] include at ./boot.jl:326 [inlined]; [8] include_relative(::Module, ::String) at ./loading.jl:1038; [9] include(::Module, ::String) at ./sysimg.jl:29; [10] top-level scope at none:2; [11] eval at ./boot.jl:328 [inlined]; [12] eval(::Expr) at ./client.jl:404; [13] top-level scope at ./none:3; ```; The cuBLAS error might be related to CuArrays: https://github.com/JuliaGPU/CuArrays.jl/issues/255",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178
https://github.com/CliMA/Oceananigans.jl/issues/178:2145,Availability,Error,Error,2145,"@ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; Building SpecialFunctions → `~/.julia/packages/SpecialFunctions/fvheQ/deps/build.log`; Building LLVM ────────────→ `~/.julia/packages/LLVM/tg8MX/deps/build.log`; Building CUDAnative ──────→ `~/.julia/packages/CUDAnative/B210M/deps/build.log`; Dependent package CUDAdrv.jl has not been built successfully.; This is not a fatal error, but GPU functionality will be unavailable.; If you expected this to work, please open a thread on; https://discourse.julialang.org/c/domain/gpu; ┌ Error: Error building `CUDAnative`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ERROR: LoadError: LoadError: UndefVarError: CUBLAS not defined; Stacktrace:; [1] top-level scope at none:0 (repeats 2 times); [2] include at ./boot.jl:326 [inlined]; [3] include_relative(::Module, ::String) at ./loading.jl:1038; [4] include at ./sysimg.jl:29 [inlined]; [5] include(::String) at /home/travis/.julia/packages/CuArrays/qZCAt/src/CuArrays.jl:3; [6] top-level scope at none:0; [7] include at ./boot.jl:326 [inlined]; [8] include_relative(::Module, ::String) at ./loading.jl:1038; [9] include(::Module, ::String) at ./sysimg.jl:29; [10] top-level scope at none:2; [11] eval at ./boot.jl:328 [inlined]; [12] eval(::Expr) at ./client.jl:404; [13] top-level scope at ./none:3; ```; The cuBLAS error might be related to CuArrays: https://github.com/JuliaGPU/CuArrays.jl/issues/255",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178
https://github.com/CliMA/Oceananigans.jl/issues/178:2291,Availability,ERROR,ERROR,2291,"@ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; Building SpecialFunctions → `~/.julia/packages/SpecialFunctions/fvheQ/deps/build.log`; Building LLVM ────────────→ `~/.julia/packages/LLVM/tg8MX/deps/build.log`; Building CUDAnative ──────→ `~/.julia/packages/CUDAnative/B210M/deps/build.log`; Dependent package CUDAdrv.jl has not been built successfully.; This is not a fatal error, but GPU functionality will be unavailable.; If you expected this to work, please open a thread on; https://discourse.julialang.org/c/domain/gpu; ┌ Error: Error building `CUDAnative`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ERROR: LoadError: LoadError: UndefVarError: CUBLAS not defined; Stacktrace:; [1] top-level scope at none:0 (repeats 2 times); [2] include at ./boot.jl:326 [inlined]; [3] include_relative(::Module, ::String) at ./loading.jl:1038; [4] include at ./sysimg.jl:29 [inlined]; [5] include(::String) at /home/travis/.julia/packages/CuArrays/qZCAt/src/CuArrays.jl:3; [6] top-level scope at none:0; [7] include at ./boot.jl:326 [inlined]; [8] include_relative(::Module, ::String) at ./loading.jl:1038; [9] include(::Module, ::String) at ./sysimg.jl:29; [10] top-level scope at none:2; [11] eval at ./boot.jl:328 [inlined]; [12] eval(::Expr) at ./client.jl:404; [13] top-level scope at ./none:3; ```; The cuBLAS error might be related to CuArrays: https://github.com/JuliaGPU/CuArrays.jl/issues/255",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178
https://github.com/CliMA/Oceananigans.jl/issues/178:2992,Availability,error,error,2992,"@ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; Building SpecialFunctions → `~/.julia/packages/SpecialFunctions/fvheQ/deps/build.log`; Building LLVM ────────────→ `~/.julia/packages/LLVM/tg8MX/deps/build.log`; Building CUDAnative ──────→ `~/.julia/packages/CUDAnative/B210M/deps/build.log`; Dependent package CUDAdrv.jl has not been built successfully.; This is not a fatal error, but GPU functionality will be unavailable.; If you expected this to work, please open a thread on; https://discourse.julialang.org/c/domain/gpu; ┌ Error: Error building `CUDAnative`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ERROR: LoadError: LoadError: UndefVarError: CUBLAS not defined; Stacktrace:; [1] top-level scope at none:0 (repeats 2 times); [2] include at ./boot.jl:326 [inlined]; [3] include_relative(::Module, ::String) at ./loading.jl:1038; [4] include at ./sysimg.jl:29 [inlined]; [5] include(::String) at /home/travis/.julia/packages/CuArrays/qZCAt/src/CuArrays.jl:3; [6] top-level scope at none:0; [7] include at ./boot.jl:326 [inlined]; [8] include_relative(::Module, ::String) at ./loading.jl:1038; [9] include(::Module, ::String) at ./sysimg.jl:29; [10] top-level scope at none:2; [11] eval at ./boot.jl:328 [inlined]; [12] eval(::Expr) at ./client.jl:404; [13] top-level scope at ./none:3; ```; The cuBLAS error might be related to CuArrays: https://github.com/JuliaGPU/CuArrays.jl/issues/255",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178
https://github.com/CliMA/Oceananigans.jl/issues/178:51,Deployability,install,install,51,"This would be nice because most people might first install Oceananigans on their laptop without a GPU or CUDA toolkit, and are greeted with error messages that e.g. CUDAdrv failed to build. While harmless errors, they don't look nice and make the package seem unstable. This would also speed up Travis CI and Appveyor builds. ---; Relevant bits from `Pkg.instantiate()`:; ```; ┌ Error: Error building `CUDAdrv`: ; │ Could not find CUDA driver library.; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAnative`: ; │ Dependent package CUDAdrv.jl has not been built successfully.; │ ; │ This is not a fatal error, but GPU functionality will be unavailable.; │ If you expected this to work, please open a thread on; │ https://discourse.julialang.org/c/domain/gpu; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; │ Dependent package CUDAdrv.jl has not been built successfully; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; Building SpecialFunctions → `~/.julia/packages/SpecialFunctions/fvheQ/deps/build.log`; Building LLVM ────────────→ `~/.julia/packages/LLVM/tg8MX/deps/build.log`; Building CUDAnative ──────→ `~/.julia/packages/CUDAnative/B210M/deps/build.log`; Dependent package CUDAdrv.jl has not been built successfully.; This is not a fatal error, but GPU functionality will be unavailable.; If you expected this to work, please open a thread on; https://discourse.julialang.org/c/domain/gpu; ┌ Error: Error buildin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178
https://github.com/CliMA/Oceananigans.jl/issues/178:146,Integrability,message,messages,146,"This would be nice because most people might first install Oceananigans on their laptop without a GPU or CUDA toolkit, and are greeted with error messages that e.g. CUDAdrv failed to build. While harmless errors, they don't look nice and make the package seem unstable. This would also speed up Travis CI and Appveyor builds. ---; Relevant bits from `Pkg.instantiate()`:; ```; ┌ Error: Error building `CUDAdrv`: ; │ Could not find CUDA driver library.; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAnative`: ; │ Dependent package CUDAdrv.jl has not been built successfully.; │ ; │ This is not a fatal error, but GPU functionality will be unavailable.; │ If you expected this to work, please open a thread on; │ https://discourse.julialang.org/c/domain/gpu; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; │ Dependent package CUDAdrv.jl has not been built successfully; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; Building SpecialFunctions → `~/.julia/packages/SpecialFunctions/fvheQ/deps/build.log`; Building LLVM ────────────→ `~/.julia/packages/LLVM/tg8MX/deps/build.log`; Building CUDAnative ──────→ `~/.julia/packages/CUDAnative/B210M/deps/build.log`; Dependent package CUDAdrv.jl has not been built successfully.; This is not a fatal error, but GPU functionality will be unavailable.; If you expected this to work, please open a thread on; https://discourse.julialang.org/c/domain/gpu; ┌ Error: Error buildin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178
https://github.com/CliMA/Oceananigans.jl/issues/178:612,Integrability,Depend,Dependent,612,"This would be nice because most people might first install Oceananigans on their laptop without a GPU or CUDA toolkit, and are greeted with error messages that e.g. CUDAdrv failed to build. While harmless errors, they don't look nice and make the package seem unstable. This would also speed up Travis CI and Appveyor builds. ---; Relevant bits from `Pkg.instantiate()`:; ```; ┌ Error: Error building `CUDAdrv`: ; │ Could not find CUDA driver library.; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAnative`: ; │ Dependent package CUDAdrv.jl has not been built successfully.; │ ; │ This is not a fatal error, but GPU functionality will be unavailable.; │ If you expected this to work, please open a thread on; │ https://discourse.julialang.org/c/domain/gpu; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; │ Dependent package CUDAdrv.jl has not been built successfully; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; Building SpecialFunctions → `~/.julia/packages/SpecialFunctions/fvheQ/deps/build.log`; Building LLVM ────────────→ `~/.julia/packages/LLVM/tg8MX/deps/build.log`; Building CUDAnative ──────→ `~/.julia/packages/CUDAnative/B210M/deps/build.log`; Dependent package CUDAdrv.jl has not been built successfully.; This is not a fatal error, but GPU functionality will be unavailable.; If you expected this to work, please open a thread on; https://discourse.julialang.org/c/domain/gpu; ┌ Error: Error buildin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178
https://github.com/CliMA/Oceananigans.jl/issues/178:1014,Integrability,Depend,Dependent,1014,"is would be nice because most people might first install Oceananigans on their laptop without a GPU or CUDA toolkit, and are greeted with error messages that e.g. CUDAdrv failed to build. While harmless errors, they don't look nice and make the package seem unstable. This would also speed up Travis CI and Appveyor builds. ---; Relevant bits from `Pkg.instantiate()`:; ```; ┌ Error: Error building `CUDAdrv`: ; │ Could not find CUDA driver library.; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAnative`: ; │ Dependent package CUDAdrv.jl has not been built successfully.; │ ; │ This is not a fatal error, but GPU functionality will be unavailable.; │ If you expected this to work, please open a thread on; │ https://discourse.julialang.org/c/domain/gpu; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; │ Dependent package CUDAdrv.jl has not been built successfully; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; Building SpecialFunctions → `~/.julia/packages/SpecialFunctions/fvheQ/deps/build.log`; Building LLVM ────────────→ `~/.julia/packages/LLVM/tg8MX/deps/build.log`; Building CUDAnative ──────→ `~/.julia/packages/CUDAnative/B210M/deps/build.log`; Dependent package CUDAdrv.jl has not been built successfully.; This is not a fatal error, but GPU functionality will be unavailable.; If you expected this to work, please open a thread on; https://discourse.julialang.org/c/domain/gpu; ┌ Error: Error building ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178
https://github.com/CliMA/Oceananigans.jl/issues/178:1744,Integrability,Depend,Dependent,1744,"If you expected this to work, please open a thread on; │ https://discourse.julialang.org/c/domain/gpu; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; │ Dependent package CUDAdrv.jl has not been built successfully; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; Building SpecialFunctions → `~/.julia/packages/SpecialFunctions/fvheQ/deps/build.log`; Building LLVM ────────────→ `~/.julia/packages/LLVM/tg8MX/deps/build.log`; Building CUDAnative ──────→ `~/.julia/packages/CUDAnative/B210M/deps/build.log`; Dependent package CUDAdrv.jl has not been built successfully.; This is not a fatal error, but GPU functionality will be unavailable.; If you expected this to work, please open a thread on; https://discourse.julialang.org/c/domain/gpu; ┌ Error: Error building `CUDAnative`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ERROR: LoadError: LoadError: UndefVarError: CUBLAS not defined; Stacktrace:; [1] top-level scope at none:0 (repeats 2 times); [2] include at ./boot.jl:326 [inlined]; [3] include_relative(::Module, ::String) at ./loading.jl:1038; [4] include at ./sysimg.jl:29 [inlined]; [5] include(::String) at /home/travis/.julia/packages/CuArrays/qZCAt/src/CuArrays.jl:3; [6] top-level scope at none:0; [7] include at ./boot.jl:326 [inlined]; [8] include_relative(::Module, ::S",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178
https://github.com/CliMA/Oceananigans.jl/issues/178:2298,Performance,Load,LoadError,2298,"@ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; Building SpecialFunctions → `~/.julia/packages/SpecialFunctions/fvheQ/deps/build.log`; Building LLVM ────────────→ `~/.julia/packages/LLVM/tg8MX/deps/build.log`; Building CUDAnative ──────→ `~/.julia/packages/CUDAnative/B210M/deps/build.log`; Dependent package CUDAdrv.jl has not been built successfully.; This is not a fatal error, but GPU functionality will be unavailable.; If you expected this to work, please open a thread on; https://discourse.julialang.org/c/domain/gpu; ┌ Error: Error building `CUDAnative`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ERROR: LoadError: LoadError: UndefVarError: CUBLAS not defined; Stacktrace:; [1] top-level scope at none:0 (repeats 2 times); [2] include at ./boot.jl:326 [inlined]; [3] include_relative(::Module, ::String) at ./loading.jl:1038; [4] include at ./sysimg.jl:29 [inlined]; [5] include(::String) at /home/travis/.julia/packages/CuArrays/qZCAt/src/CuArrays.jl:3; [6] top-level scope at none:0; [7] include at ./boot.jl:326 [inlined]; [8] include_relative(::Module, ::String) at ./loading.jl:1038; [9] include(::Module, ::String) at ./sysimg.jl:29; [10] top-level scope at none:2; [11] eval at ./boot.jl:328 [inlined]; [12] eval(::Expr) at ./client.jl:404; [13] top-level scope at ./none:3; ```; The cuBLAS error might be related to CuArrays: https://github.com/JuliaGPU/CuArrays.jl/issues/255",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178
https://github.com/CliMA/Oceananigans.jl/issues/178:2309,Performance,Load,LoadError,2309,"@ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; Building SpecialFunctions → `~/.julia/packages/SpecialFunctions/fvheQ/deps/build.log`; Building LLVM ────────────→ `~/.julia/packages/LLVM/tg8MX/deps/build.log`; Building CUDAnative ──────→ `~/.julia/packages/CUDAnative/B210M/deps/build.log`; Dependent package CUDAdrv.jl has not been built successfully.; This is not a fatal error, but GPU functionality will be unavailable.; If you expected this to work, please open a thread on; https://discourse.julialang.org/c/domain/gpu; ┌ Error: Error building `CUDAnative`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ERROR: LoadError: LoadError: UndefVarError: CUBLAS not defined; Stacktrace:; [1] top-level scope at none:0 (repeats 2 times); [2] include at ./boot.jl:326 [inlined]; [3] include_relative(::Module, ::String) at ./loading.jl:1038; [4] include at ./sysimg.jl:29 [inlined]; [5] include(::String) at /home/travis/.julia/packages/CuArrays/qZCAt/src/CuArrays.jl:3; [6] top-level scope at none:0; [7] include at ./boot.jl:326 [inlined]; [8] include_relative(::Module, ::String) at ./loading.jl:1038; [9] include(::Module, ::String) at ./sysimg.jl:29; [10] top-level scope at none:2; [11] eval at ./boot.jl:328 [inlined]; [12] eval(::Expr) at ./client.jl:404; [13] top-level scope at ./none:3; ```; The cuBLAS error might be related to CuArrays: https://github.com/JuliaGPU/CuArrays.jl/issues/255",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178
https://github.com/CliMA/Oceananigans.jl/issues/178:2503,Performance,load,loading,2503,"@ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; Building SpecialFunctions → `~/.julia/packages/SpecialFunctions/fvheQ/deps/build.log`; Building LLVM ────────────→ `~/.julia/packages/LLVM/tg8MX/deps/build.log`; Building CUDAnative ──────→ `~/.julia/packages/CUDAnative/B210M/deps/build.log`; Dependent package CUDAdrv.jl has not been built successfully.; This is not a fatal error, but GPU functionality will be unavailable.; If you expected this to work, please open a thread on; https://discourse.julialang.org/c/domain/gpu; ┌ Error: Error building `CUDAnative`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ERROR: LoadError: LoadError: UndefVarError: CUBLAS not defined; Stacktrace:; [1] top-level scope at none:0 (repeats 2 times); [2] include at ./boot.jl:326 [inlined]; [3] include_relative(::Module, ::String) at ./loading.jl:1038; [4] include at ./sysimg.jl:29 [inlined]; [5] include(::String) at /home/travis/.julia/packages/CuArrays/qZCAt/src/CuArrays.jl:3; [6] top-level scope at none:0; [7] include at ./boot.jl:326 [inlined]; [8] include_relative(::Module, ::String) at ./loading.jl:1038; [9] include(::Module, ::String) at ./sysimg.jl:29; [10] top-level scope at none:2; [11] eval at ./boot.jl:328 [inlined]; [12] eval(::Expr) at ./client.jl:404; [13] top-level scope at ./none:3; ```; The cuBLAS error might be related to CuArrays: https://github.com/JuliaGPU/CuArrays.jl/issues/255",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178
https://github.com/CliMA/Oceananigans.jl/issues/178:2766,Performance,load,loading,2766,"@ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; Building SpecialFunctions → `~/.julia/packages/SpecialFunctions/fvheQ/deps/build.log`; Building LLVM ────────────→ `~/.julia/packages/LLVM/tg8MX/deps/build.log`; Building CUDAnative ──────→ `~/.julia/packages/CUDAnative/B210M/deps/build.log`; Dependent package CUDAdrv.jl has not been built successfully.; This is not a fatal error, but GPU functionality will be unavailable.; If you expected this to work, please open a thread on; https://discourse.julialang.org/c/domain/gpu; ┌ Error: Error building `CUDAnative`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ERROR: LoadError: LoadError: UndefVarError: CUBLAS not defined; Stacktrace:; [1] top-level scope at none:0 (repeats 2 times); [2] include at ./boot.jl:326 [inlined]; [3] include_relative(::Module, ::String) at ./loading.jl:1038; [4] include at ./sysimg.jl:29 [inlined]; [5] include(::String) at /home/travis/.julia/packages/CuArrays/qZCAt/src/CuArrays.jl:3; [6] top-level scope at none:0; [7] include at ./boot.jl:326 [inlined]; [8] include_relative(::Module, ::String) at ./loading.jl:1038; [9] include(::Module, ::String) at ./sysimg.jl:29; [10] top-level scope at none:2; [11] eval at ./boot.jl:328 [inlined]; [12] eval(::Expr) at ./client.jl:404; [13] top-level scope at ./none:3; ```; The cuBLAS error might be related to CuArrays: https://github.com/JuliaGPU/CuArrays.jl/issues/255",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178
https://github.com/CliMA/Oceananigans.jl/issues/178:1582,Testability,log,log,1582,"tive`: ; │ Dependent package CUDAdrv.jl has not been built successfully.; │ ; │ This is not a fatal error, but GPU functionality will be unavailable.; │ If you expected this to work, please open a thread on; │ https://discourse.julialang.org/c/domain/gpu; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; │ Dependent package CUDAdrv.jl has not been built successfully; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; Building SpecialFunctions → `~/.julia/packages/SpecialFunctions/fvheQ/deps/build.log`; Building LLVM ────────────→ `~/.julia/packages/LLVM/tg8MX/deps/build.log`; Building CUDAnative ──────→ `~/.julia/packages/CUDAnative/B210M/deps/build.log`; Dependent package CUDAdrv.jl has not been built successfully.; This is not a fatal error, but GPU functionality will be unavailable.; If you expected this to work, please open a thread on; https://discourse.julialang.org/c/domain/gpu; ┌ Error: Error building `CUDAnative`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ERROR: LoadError: LoadError: UndefVarError: CUBLAS not defined; Stacktrace:; [1] top-level scope at none:0 (repeats 2 times); [2] include at ./boot.jl:326 [inlined]; [3] include_relative(::Module, ::String) at ./loading.jl:1038; [4] include at ./sysimg.jl:29 [inlined]; [5] include(::String) at /home/travis/.j",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178
https://github.com/CliMA/Oceananigans.jl/issues/178:1657,Testability,log,log,1657," ; │ This is not a fatal error, but GPU functionality will be unavailable.; │ If you expected this to work, please open a thread on; │ https://discourse.julialang.org/c/domain/gpu; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; │ Dependent package CUDAdrv.jl has not been built successfully; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; Building SpecialFunctions → `~/.julia/packages/SpecialFunctions/fvheQ/deps/build.log`; Building LLVM ────────────→ `~/.julia/packages/LLVM/tg8MX/deps/build.log`; Building CUDAnative ──────→ `~/.julia/packages/CUDAnative/B210M/deps/build.log`; Dependent package CUDAdrv.jl has not been built successfully.; This is not a fatal error, but GPU functionality will be unavailable.; If you expected this to work, please open a thread on; https://discourse.julialang.org/c/domain/gpu; ┌ Error: Error building `CUDAnative`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ERROR: LoadError: LoadError: UndefVarError: CUBLAS not defined; Stacktrace:; [1] top-level scope at none:0 (repeats 2 times); [2] include at ./boot.jl:326 [inlined]; [3] include_relative(::Module, ::String) at ./loading.jl:1038; [4] include at ./sysimg.jl:29 [inlined]; [5] include(::String) at /home/travis/.julia/packages/CuArrays/qZCAt/src/CuArrays.jl:3; [6] top-level scope at none",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178
https://github.com/CliMA/Oceananigans.jl/issues/178:1738,Testability,log,log,1738,"If you expected this to work, please open a thread on; │ https://discourse.julialang.org/c/domain/gpu; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; │ Dependent package CUDAdrv.jl has not been built successfully; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; Building SpecialFunctions → `~/.julia/packages/SpecialFunctions/fvheQ/deps/build.log`; Building LLVM ────────────→ `~/.julia/packages/LLVM/tg8MX/deps/build.log`; Building CUDAnative ──────→ `~/.julia/packages/CUDAnative/B210M/deps/build.log`; Dependent package CUDAdrv.jl has not been built successfully.; This is not a fatal error, but GPU functionality will be unavailable.; If you expected this to work, please open a thread on; https://discourse.julialang.org/c/domain/gpu; ┌ Error: Error building `CUDAnative`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ERROR: LoadError: LoadError: UndefVarError: CUBLAS not defined; Stacktrace:; [1] top-level scope at none:0 (repeats 2 times); [2] include at ./boot.jl:326 [inlined]; [3] include_relative(::Module, ::String) at ./loading.jl:1038; [4] include at ./sysimg.jl:29 [inlined]; [5] include(::String) at /home/travis/.julia/packages/CuArrays/qZCAt/src/CuArrays.jl:3; [6] top-level scope at none:0; [7] include at ./boot.jl:326 [inlined]; [8] include_relative(::Module, ::S",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178
https://github.com/CliMA/Oceananigans.jl/pull/179:153,Testability,test,test,153,A thermal wind example where a vertical velocity profile is set up to exactly balance a horizontal temperature gradient. Eventually supposed to become a test. Initially authored by: @mukund-gupta,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/179
https://github.com/CliMA/Oceananigans.jl/issues/186:116,Energy Efficiency,efficient,efficiently,116,"We may want vertical profiles of many variables, e.g. u, v, w, T. Would be nice to have a diagnostic that does this efficiently, especially if we have very frequent diagnostics. If it's literally every iteration then a CUDA kernel might be the way to go. But if it's like every 20-100+ iterations then it might be faster to copy stuff to the CPU and do a lot of extended on-the-fly analysis there (similar to what we do with asynchronous NetCDF output). Not sure if the same diagnostic can handle products of fields, e.g. _w'T'_. That could be another diagnostic?. cc @sandreza",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/186
https://github.com/CliMA/Oceananigans.jl/issues/186:38,Modifiability,variab,variables,38,"We may want vertical profiles of many variables, e.g. u, v, w, T. Would be nice to have a diagnostic that does this efficiently, especially if we have very frequent diagnostics. If it's literally every iteration then a CUDA kernel might be the way to go. But if it's like every 20-100+ iterations then it might be faster to copy stuff to the CPU and do a lot of extended on-the-fly analysis there (similar to what we do with asynchronous NetCDF output). Not sure if the same diagnostic can handle products of fields, e.g. _w'T'_. That could be another diagnostic?. cc @sandreza",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/186
https://github.com/CliMA/Oceananigans.jl/issues/186:362,Modifiability,extend,extended,362,"We may want vertical profiles of many variables, e.g. u, v, w, T. Would be nice to have a diagnostic that does this efficiently, especially if we have very frequent diagnostics. If it's literally every iteration then a CUDA kernel might be the way to go. But if it's like every 20-100+ iterations then it might be faster to copy stuff to the CPU and do a lot of extended on-the-fly analysis there (similar to what we do with asynchronous NetCDF output). Not sure if the same diagnostic can handle products of fields, e.g. _w'T'_. That could be another diagnostic?. cc @sandreza",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/186
https://github.com/CliMA/Oceananigans.jl/issues/188:624,Availability,down,down,624,"Looking at performance benchmarks, Float32 is slower than Float64 on the CPU. I suspect something is being done wrong somewhere maybe. I have a few ideas:; 1. Those benchmarks were run on Google Cloud where the virtual CPUs aren't very performant so I thought it was maybe just a low-end 64-bit CPU where Float32 operations were emulated via Float64 operations resulting in fewer FLOPS. However, even on my own laptop I found Float32 on a CPU to be a bit slower, but just by 5-10% whereas on Google Cloud it was like 30%+ slower.; 2. It's likely that Float32 is still being mixed with Float64, and maybe this slows the code down due to too many implicit conversions? (Somewhat related to #34).; 3. Unlikely but I wonder if this is a Julia issue... I could perhaps run some simple C code to see if it's a hardware thing or just a weird Julia thing.; 4. I thought it looked fine on the GPU as you do see a ""speedup"" of 10-15% which I took to mean that we were memory bandwidth/latency limited (which is probably true). The V100 GPUs have twice as many FP32 units as they do FP64 units and if FP32 operations are faster, then I expect more than just a 10-15% speedup. So maybe we have similar issues on the GPU, which are preventing us from doing better than 15% speedup. Or maybe the GPU doesn't do implicit conversions and we are actually just memory bandwidth/latency limited. @glwagner has also pointed out these posts:; * Check out these benchmarks for arithmetic cpu operations: http://nicolas.limare.net/pro/notes/2014/12/12_arit_speed/ Conclusion: _usually_ single precision is faster, but is _occasionally_ comparable or slower depending on the processor (check results for x86-64 Intel Ivy Bridge).; * https://stackoverflow.com/questions/3426165/is-using-double-faster-than-float",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/188
https://github.com/CliMA/Oceananigans.jl/issues/188:1634,Integrability,depend,depending,1634,"Looking at performance benchmarks, Float32 is slower than Float64 on the CPU. I suspect something is being done wrong somewhere maybe. I have a few ideas:; 1. Those benchmarks were run on Google Cloud where the virtual CPUs aren't very performant so I thought it was maybe just a low-end 64-bit CPU where Float32 operations were emulated via Float64 operations resulting in fewer FLOPS. However, even on my own laptop I found Float32 on a CPU to be a bit slower, but just by 5-10% whereas on Google Cloud it was like 30%+ slower.; 2. It's likely that Float32 is still being mixed with Float64, and maybe this slows the code down due to too many implicit conversions? (Somewhat related to #34).; 3. Unlikely but I wonder if this is a Julia issue... I could perhaps run some simple C code to see if it's a hardware thing or just a weird Julia thing.; 4. I thought it looked fine on the GPU as you do see a ""speedup"" of 10-15% which I took to mean that we were memory bandwidth/latency limited (which is probably true). The V100 GPUs have twice as many FP32 units as they do FP64 units and if FP32 operations are faster, then I expect more than just a 10-15% speedup. So maybe we have similar issues on the GPU, which are preventing us from doing better than 15% speedup. Or maybe the GPU doesn't do implicit conversions and we are actually just memory bandwidth/latency limited. @glwagner has also pointed out these posts:; * Check out these benchmarks for arithmetic cpu operations: http://nicolas.limare.net/pro/notes/2014/12/12_arit_speed/ Conclusion: _usually_ single precision is faster, but is _occasionally_ comparable or slower depending on the processor (check results for x86-64 Intel Ivy Bridge).; * https://stackoverflow.com/questions/3426165/is-using-double-faster-than-float",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/188
https://github.com/CliMA/Oceananigans.jl/issues/188:1697,Integrability,Bridg,Bridge,1697,"Looking at performance benchmarks, Float32 is slower than Float64 on the CPU. I suspect something is being done wrong somewhere maybe. I have a few ideas:; 1. Those benchmarks were run on Google Cloud where the virtual CPUs aren't very performant so I thought it was maybe just a low-end 64-bit CPU where Float32 operations were emulated via Float64 operations resulting in fewer FLOPS. However, even on my own laptop I found Float32 on a CPU to be a bit slower, but just by 5-10% whereas on Google Cloud it was like 30%+ slower.; 2. It's likely that Float32 is still being mixed with Float64, and maybe this slows the code down due to too many implicit conversions? (Somewhat related to #34).; 3. Unlikely but I wonder if this is a Julia issue... I could perhaps run some simple C code to see if it's a hardware thing or just a weird Julia thing.; 4. I thought it looked fine on the GPU as you do see a ""speedup"" of 10-15% which I took to mean that we were memory bandwidth/latency limited (which is probably true). The V100 GPUs have twice as many FP32 units as they do FP64 units and if FP32 operations are faster, then I expect more than just a 10-15% speedup. So maybe we have similar issues on the GPU, which are preventing us from doing better than 15% speedup. Or maybe the GPU doesn't do implicit conversions and we are actually just memory bandwidth/latency limited. @glwagner has also pointed out these posts:; * Check out these benchmarks for arithmetic cpu operations: http://nicolas.limare.net/pro/notes/2014/12/12_arit_speed/ Conclusion: _usually_ single precision is faster, but is _occasionally_ comparable or slower depending on the processor (check results for x86-64 Intel Ivy Bridge).; * https://stackoverflow.com/questions/3426165/is-using-double-faster-than-float",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/188
https://github.com/CliMA/Oceananigans.jl/issues/188:11,Performance,perform,performance,11,"Looking at performance benchmarks, Float32 is slower than Float64 on the CPU. I suspect something is being done wrong somewhere maybe. I have a few ideas:; 1. Those benchmarks were run on Google Cloud where the virtual CPUs aren't very performant so I thought it was maybe just a low-end 64-bit CPU where Float32 operations were emulated via Float64 operations resulting in fewer FLOPS. However, even on my own laptop I found Float32 on a CPU to be a bit slower, but just by 5-10% whereas on Google Cloud it was like 30%+ slower.; 2. It's likely that Float32 is still being mixed with Float64, and maybe this slows the code down due to too many implicit conversions? (Somewhat related to #34).; 3. Unlikely but I wonder if this is a Julia issue... I could perhaps run some simple C code to see if it's a hardware thing or just a weird Julia thing.; 4. I thought it looked fine on the GPU as you do see a ""speedup"" of 10-15% which I took to mean that we were memory bandwidth/latency limited (which is probably true). The V100 GPUs have twice as many FP32 units as they do FP64 units and if FP32 operations are faster, then I expect more than just a 10-15% speedup. So maybe we have similar issues on the GPU, which are preventing us from doing better than 15% speedup. Or maybe the GPU doesn't do implicit conversions and we are actually just memory bandwidth/latency limited. @glwagner has also pointed out these posts:; * Check out these benchmarks for arithmetic cpu operations: http://nicolas.limare.net/pro/notes/2014/12/12_arit_speed/ Conclusion: _usually_ single precision is faster, but is _occasionally_ comparable or slower depending on the processor (check results for x86-64 Intel Ivy Bridge).; * https://stackoverflow.com/questions/3426165/is-using-double-faster-than-float",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/188
https://github.com/CliMA/Oceananigans.jl/issues/188:236,Performance,perform,performant,236,"Looking at performance benchmarks, Float32 is slower than Float64 on the CPU. I suspect something is being done wrong somewhere maybe. I have a few ideas:; 1. Those benchmarks were run on Google Cloud where the virtual CPUs aren't very performant so I thought it was maybe just a low-end 64-bit CPU where Float32 operations were emulated via Float64 operations resulting in fewer FLOPS. However, even on my own laptop I found Float32 on a CPU to be a bit slower, but just by 5-10% whereas on Google Cloud it was like 30%+ slower.; 2. It's likely that Float32 is still being mixed with Float64, and maybe this slows the code down due to too many implicit conversions? (Somewhat related to #34).; 3. Unlikely but I wonder if this is a Julia issue... I could perhaps run some simple C code to see if it's a hardware thing or just a weird Julia thing.; 4. I thought it looked fine on the GPU as you do see a ""speedup"" of 10-15% which I took to mean that we were memory bandwidth/latency limited (which is probably true). The V100 GPUs have twice as many FP32 units as they do FP64 units and if FP32 operations are faster, then I expect more than just a 10-15% speedup. So maybe we have similar issues on the GPU, which are preventing us from doing better than 15% speedup. Or maybe the GPU doesn't do implicit conversions and we are actually just memory bandwidth/latency limited. @glwagner has also pointed out these posts:; * Check out these benchmarks for arithmetic cpu operations: http://nicolas.limare.net/pro/notes/2014/12/12_arit_speed/ Conclusion: _usually_ single precision is faster, but is _occasionally_ comparable or slower depending on the processor (check results for x86-64 Intel Ivy Bridge).; * https://stackoverflow.com/questions/3426165/is-using-double-faster-than-float",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/188
https://github.com/CliMA/Oceananigans.jl/issues/188:975,Performance,latency,latency,975,"Looking at performance benchmarks, Float32 is slower than Float64 on the CPU. I suspect something is being done wrong somewhere maybe. I have a few ideas:; 1. Those benchmarks were run on Google Cloud where the virtual CPUs aren't very performant so I thought it was maybe just a low-end 64-bit CPU where Float32 operations were emulated via Float64 operations resulting in fewer FLOPS. However, even on my own laptop I found Float32 on a CPU to be a bit slower, but just by 5-10% whereas on Google Cloud it was like 30%+ slower.; 2. It's likely that Float32 is still being mixed with Float64, and maybe this slows the code down due to too many implicit conversions? (Somewhat related to #34).; 3. Unlikely but I wonder if this is a Julia issue... I could perhaps run some simple C code to see if it's a hardware thing or just a weird Julia thing.; 4. I thought it looked fine on the GPU as you do see a ""speedup"" of 10-15% which I took to mean that we were memory bandwidth/latency limited (which is probably true). The V100 GPUs have twice as many FP32 units as they do FP64 units and if FP32 operations are faster, then I expect more than just a 10-15% speedup. So maybe we have similar issues on the GPU, which are preventing us from doing better than 15% speedup. Or maybe the GPU doesn't do implicit conversions and we are actually just memory bandwidth/latency limited. @glwagner has also pointed out these posts:; * Check out these benchmarks for arithmetic cpu operations: http://nicolas.limare.net/pro/notes/2014/12/12_arit_speed/ Conclusion: _usually_ single precision is faster, but is _occasionally_ comparable or slower depending on the processor (check results for x86-64 Intel Ivy Bridge).; * https://stackoverflow.com/questions/3426165/is-using-double-faster-than-float",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/188
https://github.com/CliMA/Oceananigans.jl/issues/188:1360,Performance,latency,latency,1360,"Looking at performance benchmarks, Float32 is slower than Float64 on the CPU. I suspect something is being done wrong somewhere maybe. I have a few ideas:; 1. Those benchmarks were run on Google Cloud where the virtual CPUs aren't very performant so I thought it was maybe just a low-end 64-bit CPU where Float32 operations were emulated via Float64 operations resulting in fewer FLOPS. However, even on my own laptop I found Float32 on a CPU to be a bit slower, but just by 5-10% whereas on Google Cloud it was like 30%+ slower.; 2. It's likely that Float32 is still being mixed with Float64, and maybe this slows the code down due to too many implicit conversions? (Somewhat related to #34).; 3. Unlikely but I wonder if this is a Julia issue... I could perhaps run some simple C code to see if it's a hardware thing or just a weird Julia thing.; 4. I thought it looked fine on the GPU as you do see a ""speedup"" of 10-15% which I took to mean that we were memory bandwidth/latency limited (which is probably true). The V100 GPUs have twice as many FP32 units as they do FP64 units and if FP32 operations are faster, then I expect more than just a 10-15% speedup. So maybe we have similar issues on the GPU, which are preventing us from doing better than 15% speedup. Or maybe the GPU doesn't do implicit conversions and we are actually just memory bandwidth/latency limited. @glwagner has also pointed out these posts:; * Check out these benchmarks for arithmetic cpu operations: http://nicolas.limare.net/pro/notes/2014/12/12_arit_speed/ Conclusion: _usually_ single precision is faster, but is _occasionally_ comparable or slower depending on the processor (check results for x86-64 Intel Ivy Bridge).; * https://stackoverflow.com/questions/3426165/is-using-double-faster-than-float",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/188
https://github.com/CliMA/Oceananigans.jl/issues/188:23,Testability,benchmark,benchmarks,23,"Looking at performance benchmarks, Float32 is slower than Float64 on the CPU. I suspect something is being done wrong somewhere maybe. I have a few ideas:; 1. Those benchmarks were run on Google Cloud where the virtual CPUs aren't very performant so I thought it was maybe just a low-end 64-bit CPU where Float32 operations were emulated via Float64 operations resulting in fewer FLOPS. However, even on my own laptop I found Float32 on a CPU to be a bit slower, but just by 5-10% whereas on Google Cloud it was like 30%+ slower.; 2. It's likely that Float32 is still being mixed with Float64, and maybe this slows the code down due to too many implicit conversions? (Somewhat related to #34).; 3. Unlikely but I wonder if this is a Julia issue... I could perhaps run some simple C code to see if it's a hardware thing or just a weird Julia thing.; 4. I thought it looked fine on the GPU as you do see a ""speedup"" of 10-15% which I took to mean that we were memory bandwidth/latency limited (which is probably true). The V100 GPUs have twice as many FP32 units as they do FP64 units and if FP32 operations are faster, then I expect more than just a 10-15% speedup. So maybe we have similar issues on the GPU, which are preventing us from doing better than 15% speedup. Or maybe the GPU doesn't do implicit conversions and we are actually just memory bandwidth/latency limited. @glwagner has also pointed out these posts:; * Check out these benchmarks for arithmetic cpu operations: http://nicolas.limare.net/pro/notes/2014/12/12_arit_speed/ Conclusion: _usually_ single precision is faster, but is _occasionally_ comparable or slower depending on the processor (check results for x86-64 Intel Ivy Bridge).; * https://stackoverflow.com/questions/3426165/is-using-double-faster-than-float",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/188
https://github.com/CliMA/Oceananigans.jl/issues/188:165,Testability,benchmark,benchmarks,165,"Looking at performance benchmarks, Float32 is slower than Float64 on the CPU. I suspect something is being done wrong somewhere maybe. I have a few ideas:; 1. Those benchmarks were run on Google Cloud where the virtual CPUs aren't very performant so I thought it was maybe just a low-end 64-bit CPU where Float32 operations were emulated via Float64 operations resulting in fewer FLOPS. However, even on my own laptop I found Float32 on a CPU to be a bit slower, but just by 5-10% whereas on Google Cloud it was like 30%+ slower.; 2. It's likely that Float32 is still being mixed with Float64, and maybe this slows the code down due to too many implicit conversions? (Somewhat related to #34).; 3. Unlikely but I wonder if this is a Julia issue... I could perhaps run some simple C code to see if it's a hardware thing or just a weird Julia thing.; 4. I thought it looked fine on the GPU as you do see a ""speedup"" of 10-15% which I took to mean that we were memory bandwidth/latency limited (which is probably true). The V100 GPUs have twice as many FP32 units as they do FP64 units and if FP32 operations are faster, then I expect more than just a 10-15% speedup. So maybe we have similar issues on the GPU, which are preventing us from doing better than 15% speedup. Or maybe the GPU doesn't do implicit conversions and we are actually just memory bandwidth/latency limited. @glwagner has also pointed out these posts:; * Check out these benchmarks for arithmetic cpu operations: http://nicolas.limare.net/pro/notes/2014/12/12_arit_speed/ Conclusion: _usually_ single precision is faster, but is _occasionally_ comparable or slower depending on the processor (check results for x86-64 Intel Ivy Bridge).; * https://stackoverflow.com/questions/3426165/is-using-double-faster-than-float",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/188
https://github.com/CliMA/Oceananigans.jl/issues/188:1440,Testability,benchmark,benchmarks,1440,"Looking at performance benchmarks, Float32 is slower than Float64 on the CPU. I suspect something is being done wrong somewhere maybe. I have a few ideas:; 1. Those benchmarks were run on Google Cloud where the virtual CPUs aren't very performant so I thought it was maybe just a low-end 64-bit CPU where Float32 operations were emulated via Float64 operations resulting in fewer FLOPS. However, even on my own laptop I found Float32 on a CPU to be a bit slower, but just by 5-10% whereas on Google Cloud it was like 30%+ slower.; 2. It's likely that Float32 is still being mixed with Float64, and maybe this slows the code down due to too many implicit conversions? (Somewhat related to #34).; 3. Unlikely but I wonder if this is a Julia issue... I could perhaps run some simple C code to see if it's a hardware thing or just a weird Julia thing.; 4. I thought it looked fine on the GPU as you do see a ""speedup"" of 10-15% which I took to mean that we were memory bandwidth/latency limited (which is probably true). The V100 GPUs have twice as many FP32 units as they do FP64 units and if FP32 operations are faster, then I expect more than just a 10-15% speedup. So maybe we have similar issues on the GPU, which are preventing us from doing better than 15% speedup. Or maybe the GPU doesn't do implicit conversions and we are actually just memory bandwidth/latency limited. @glwagner has also pointed out these posts:; * Check out these benchmarks for arithmetic cpu operations: http://nicolas.limare.net/pro/notes/2014/12/12_arit_speed/ Conclusion: _usually_ single precision is faster, but is _occasionally_ comparable or slower depending on the processor (check results for x86-64 Intel Ivy Bridge).; * https://stackoverflow.com/questions/3426165/is-using-double-faster-than-float",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/188
https://github.com/CliMA/Oceananigans.jl/issues/188:773,Usability,simpl,simple,773,"Looking at performance benchmarks, Float32 is slower than Float64 on the CPU. I suspect something is being done wrong somewhere maybe. I have a few ideas:; 1. Those benchmarks were run on Google Cloud where the virtual CPUs aren't very performant so I thought it was maybe just a low-end 64-bit CPU where Float32 operations were emulated via Float64 operations resulting in fewer FLOPS. However, even on my own laptop I found Float32 on a CPU to be a bit slower, but just by 5-10% whereas on Google Cloud it was like 30%+ slower.; 2. It's likely that Float32 is still being mixed with Float64, and maybe this slows the code down due to too many implicit conversions? (Somewhat related to #34).; 3. Unlikely but I wonder if this is a Julia issue... I could perhaps run some simple C code to see if it's a hardware thing or just a weird Julia thing.; 4. I thought it looked fine on the GPU as you do see a ""speedup"" of 10-15% which I took to mean that we were memory bandwidth/latency limited (which is probably true). The V100 GPUs have twice as many FP32 units as they do FP64 units and if FP32 operations are faster, then I expect more than just a 10-15% speedup. So maybe we have similar issues on the GPU, which are preventing us from doing better than 15% speedup. Or maybe the GPU doesn't do implicit conversions and we are actually just memory bandwidth/latency limited. @glwagner has also pointed out these posts:; * Check out these benchmarks for arithmetic cpu operations: http://nicolas.limare.net/pro/notes/2014/12/12_arit_speed/ Conclusion: _usually_ single precision is faster, but is _occasionally_ comparable or slower depending on the processor (check results for x86-64 Intel Ivy Bridge).; * https://stackoverflow.com/questions/3426165/is-using-double-faster-than-float",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/188
https://github.com/CliMA/Oceananigans.jl/issues/189:29,Energy Efficiency,adapt,adaptive,29,"Might be interesting to give adaptive time-stepping a try. @christophernhill says it didn't work super well last time they tried it in the MITgcm but that might have been a long time ago. I suspect for most MITgcm runs, which act on large horizontal domains, the time step is severely limited by vertical motions which may not be true for all Oceananigans simulations. Not sure if this changes anything. I suspect you just calculate the time step using; ```julia; C = 1 # Maximum Courant number. Probably 1 for our explicit AB2 time-stepping scheme. Δt_x = C*Δx / maximum(abs.(u)); Δt_y = C*Δy / maximum(abs.(v)); Δt_z = C*Δz / maximum(abs.(w)). Δt = min(Δt_x, Δt_y, Δt_z); ```. Even if we don't use adaptive time-stepping, it might be a useful `CFLChecker` diagnostic that prints warnings when CFL is being violated.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/189
https://github.com/CliMA/Oceananigans.jl/issues/189:700,Energy Efficiency,adapt,adaptive,700,"Might be interesting to give adaptive time-stepping a try. @christophernhill says it didn't work super well last time they tried it in the MITgcm but that might have been a long time ago. I suspect for most MITgcm runs, which act on large horizontal domains, the time step is severely limited by vertical motions which may not be true for all Oceananigans simulations. Not sure if this changes anything. I suspect you just calculate the time step using; ```julia; C = 1 # Maximum Courant number. Probably 1 for our explicit AB2 time-stepping scheme. Δt_x = C*Δx / maximum(abs.(u)); Δt_y = C*Δy / maximum(abs.(v)); Δt_z = C*Δz / maximum(abs.(w)). Δt = min(Δt_x, Δt_y, Δt_z); ```. Even if we don't use adaptive time-stepping, it might be a useful `CFLChecker` diagnostic that prints warnings when CFL is being violated.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/189
https://github.com/CliMA/Oceananigans.jl/issues/189:29,Modifiability,adapt,adaptive,29,"Might be interesting to give adaptive time-stepping a try. @christophernhill says it didn't work super well last time they tried it in the MITgcm but that might have been a long time ago. I suspect for most MITgcm runs, which act on large horizontal domains, the time step is severely limited by vertical motions which may not be true for all Oceananigans simulations. Not sure if this changes anything. I suspect you just calculate the time step using; ```julia; C = 1 # Maximum Courant number. Probably 1 for our explicit AB2 time-stepping scheme. Δt_x = C*Δx / maximum(abs.(u)); Δt_y = C*Δy / maximum(abs.(v)); Δt_z = C*Δz / maximum(abs.(w)). Δt = min(Δt_x, Δt_y, Δt_z); ```. Even if we don't use adaptive time-stepping, it might be a useful `CFLChecker` diagnostic that prints warnings when CFL is being violated.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/189
https://github.com/CliMA/Oceananigans.jl/issues/189:700,Modifiability,adapt,adaptive,700,"Might be interesting to give adaptive time-stepping a try. @christophernhill says it didn't work super well last time they tried it in the MITgcm but that might have been a long time ago. I suspect for most MITgcm runs, which act on large horizontal domains, the time step is severely limited by vertical motions which may not be true for all Oceananigans simulations. Not sure if this changes anything. I suspect you just calculate the time step using; ```julia; C = 1 # Maximum Courant number. Probably 1 for our explicit AB2 time-stepping scheme. Δt_x = C*Δx / maximum(abs.(u)); Δt_y = C*Δy / maximum(abs.(v)); Δt_z = C*Δz / maximum(abs.(w)). Δt = min(Δt_x, Δt_y, Δt_z); ```. Even if we don't use adaptive time-stepping, it might be a useful `CFLChecker` diagnostic that prints warnings when CFL is being violated.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/189
https://github.com/CliMA/Oceananigans.jl/issues/193:81,Availability,error,error,81,"As GPUifyLoops.jl relies on Julia 1.1+, so does Oceananigans. We should print an error (there must be some Julia pattern people do here) if someone tries to run Oceananigans with Julia <1.1. Currently it's really bad for usability as Ubuntu repositories are ancient as usual and still on Julia 1.0.3, and Debian is probably even worse. And you get pretty cryptic messages if running Oceananigans from Julia 1.0.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/193
https://github.com/CliMA/Oceananigans.jl/issues/193:363,Integrability,message,messages,363,"As GPUifyLoops.jl relies on Julia 1.1+, so does Oceananigans. We should print an error (there must be some Julia pattern people do here) if someone tries to run Oceananigans with Julia <1.1. Currently it's really bad for usability as Ubuntu repositories are ancient as usual and still on Julia 1.0.3, and Debian is probably even worse. And you get pretty cryptic messages if running Oceananigans from Julia 1.0.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/193
https://github.com/CliMA/Oceananigans.jl/issues/193:221,Usability,usab,usability,221,"As GPUifyLoops.jl relies on Julia 1.1+, so does Oceananigans. We should print an error (there must be some Julia pattern people do here) if someone tries to run Oceananigans with Julia <1.1. Currently it's really bad for usability as Ubuntu repositories are ancient as usual and still on Julia 1.0.3, and Debian is probably even worse. And you get pretty cryptic messages if running Oceananigans from Julia 1.0.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/193
https://github.com/CliMA/Oceananigans.jl/issues/195:100,Deployability,install,install,100,"I don't think we should depend on a heavy package like Plots.jl, but we might want to automatically install and load it when someone runs an example like the rising thermal bubble one on the README. Might be related to #14 so Requires.jl would help but we also want to add/build the package too.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/195
https://github.com/CliMA/Oceananigans.jl/issues/195:24,Integrability,depend,depend,24,"I don't think we should depend on a heavy package like Plots.jl, but we might want to automatically install and load it when someone runs an example like the rising thermal bubble one on the README. Might be related to #14 so Requires.jl would help but we also want to add/build the package too.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/195
https://github.com/CliMA/Oceananigans.jl/issues/195:112,Performance,load,load,112,"I don't think we should depend on a heavy package like Plots.jl, but we might want to automatically install and load it when someone runs an example like the rising thermal bubble one on the README. Might be related to #14 so Requires.jl would help but we also want to add/build the package too.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/195
https://github.com/CliMA/Oceananigans.jl/pull/196:92,Deployability,install,installing,92,This PR improves the GPU example on the README and adds some extra notes and warnings about installing Oceananigans and running the examples. I will also add movies (maybe gifs) of rising thermal bubbles so users can visually check that their movie/output matches what we get.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/196
https://github.com/CliMA/Oceananigans.jl/pull/197:83,Deployability,pipeline,pipelines,83,This is mostly to fix the CUDA dependency issues we're currently getting on the CI pipelines. We will live dangerously on four `#master` dependencies!; ```; ] add CuArrays#master CUDAnative#master CUDAdrv#master NNlib#master; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/197
https://github.com/CliMA/Oceananigans.jl/pull/197:31,Integrability,depend,dependency,31,This is mostly to fix the CUDA dependency issues we're currently getting on the CI pipelines. We will live dangerously on four `#master` dependencies!; ```; ] add CuArrays#master CUDAnative#master CUDAdrv#master NNlib#master; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/197
https://github.com/CliMA/Oceananigans.jl/pull/197:137,Integrability,depend,dependencies,137,This is mostly to fix the CUDA dependency issues we're currently getting on the CI pipelines. We will live dangerously on four `#master` dependencies!; ```; ] add CuArrays#master CUDAnative#master CUDAdrv#master NNlib#master; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/197
https://github.com/CliMA/Oceananigans.jl/issues/200:161,Availability,error,error,161,Kind of scary that we don't have tests for this. I wrote some as part of PR #167 but commented them out as I couldn't get them to work (I kept getting some CUDA error). I should make sure to finish that off.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/200
https://github.com/CliMA/Oceananigans.jl/issues/200:33,Testability,test,tests,33,Kind of scary that we don't have tests for this. I wrote some as part of PR #167 but commented them out as I couldn't get them to work (I kept getting some CUDA error). I should make sure to finish that off.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/200
https://github.com/CliMA/Oceananigans.jl/issues/207:348,Energy Efficiency,Reduce,Reduce,348,"Not supposed to be concrete but just to lay out some goals for big new features and prioritize them based on our needs. Also in case I forgot about them. Most of these can be done independently so the version ordering is mostly for priority. * v0.6: Arbitrary LES closures (Smagorinsky and AMD implemented); * v0.7: Halo regions (PR #167); * v0.8: Reduce memory usage by storing fewer fields.; * v0.9: Machine precision mass conservation; * v0.10: channel and boxed/cubed models, i.e. multiple wall-bounded dimensions (PR #180); * v0.11: True finite volume operators; * v0.12: Variable Δz grid; * v0.13: Higher-order advection schemes (4th order, 3rd order DST, WENO?, Prather??); * v0.14: GPU performance optimization (GPU hackathon); * v0.15: Multi-GPU (and multi-CPU?) distributed parallelism (GPU hackathon); * v0.16: Fuller high-level and API documentation; * v0.17: Fast on-the-fly diagnostics framework (CPU and GPU friendly); * v1.0: Awesome LES model!; * v1.1: Hydrostatic mode; * v1.2: Spherical grid (pole problem)?; * v1.3: Cubed sphere grid?; * ...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/207
https://github.com/CliMA/Oceananigans.jl/issues/207:577,Modifiability,Variab,Variable,577,"Not supposed to be concrete but just to lay out some goals for big new features and prioritize them based on our needs. Also in case I forgot about them. Most of these can be done independently so the version ordering is mostly for priority. * v0.6: Arbitrary LES closures (Smagorinsky and AMD implemented); * v0.7: Halo regions (PR #167); * v0.8: Reduce memory usage by storing fewer fields.; * v0.9: Machine precision mass conservation; * v0.10: channel and boxed/cubed models, i.e. multiple wall-bounded dimensions (PR #180); * v0.11: True finite volume operators; * v0.12: Variable Δz grid; * v0.13: Higher-order advection schemes (4th order, 3rd order DST, WENO?, Prather??); * v0.14: GPU performance optimization (GPU hackathon); * v0.15: Multi-GPU (and multi-CPU?) distributed parallelism (GPU hackathon); * v0.16: Fuller high-level and API documentation; * v0.17: Fast on-the-fly diagnostics framework (CPU and GPU friendly); * v1.0: Awesome LES model!; * v1.1: Hydrostatic mode; * v1.2: Spherical grid (pole problem)?; * v1.3: Cubed sphere grid?; * ...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/207
https://github.com/CliMA/Oceananigans.jl/issues/207:694,Performance,perform,performance,694,"Not supposed to be concrete but just to lay out some goals for big new features and prioritize them based on our needs. Also in case I forgot about them. Most of these can be done independently so the version ordering is mostly for priority. * v0.6: Arbitrary LES closures (Smagorinsky and AMD implemented); * v0.7: Halo regions (PR #167); * v0.8: Reduce memory usage by storing fewer fields.; * v0.9: Machine precision mass conservation; * v0.10: channel and boxed/cubed models, i.e. multiple wall-bounded dimensions (PR #180); * v0.11: True finite volume operators; * v0.12: Variable Δz grid; * v0.13: Higher-order advection schemes (4th order, 3rd order DST, WENO?, Prather??); * v0.14: GPU performance optimization (GPU hackathon); * v0.15: Multi-GPU (and multi-CPU?) distributed parallelism (GPU hackathon); * v0.16: Fuller high-level and API documentation; * v0.17: Fast on-the-fly diagnostics framework (CPU and GPU friendly); * v1.0: Awesome LES model!; * v1.1: Hydrostatic mode; * v1.2: Spherical grid (pole problem)?; * v1.3: Cubed sphere grid?; * ...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/207
https://github.com/CliMA/Oceananigans.jl/issues/207:706,Performance,optimiz,optimization,706,"Not supposed to be concrete but just to lay out some goals for big new features and prioritize them based on our needs. Also in case I forgot about them. Most of these can be done independently so the version ordering is mostly for priority. * v0.6: Arbitrary LES closures (Smagorinsky and AMD implemented); * v0.7: Halo regions (PR #167); * v0.8: Reduce memory usage by storing fewer fields.; * v0.9: Machine precision mass conservation; * v0.10: channel and boxed/cubed models, i.e. multiple wall-bounded dimensions (PR #180); * v0.11: True finite volume operators; * v0.12: Variable Δz grid; * v0.13: Higher-order advection schemes (4th order, 3rd order DST, WENO?, Prather??); * v0.14: GPU performance optimization (GPU hackathon); * v0.15: Multi-GPU (and multi-CPU?) distributed parallelism (GPU hackathon); * v0.16: Fuller high-level and API documentation; * v0.17: Fast on-the-fly diagnostics framework (CPU and GPU friendly); * v1.0: Awesome LES model!; * v1.1: Hydrostatic mode; * v1.2: Spherical grid (pole problem)?; * v1.3: Cubed sphere grid?; * ...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/207
https://github.com/CliMA/Oceananigans.jl/pull/210:110,Testability,test,test,110,This PR adds some convenience functions for interacting with fields that are functions. Unfortunately I can't test it on my mac because I don't have `CUDAnative` (?) and CUDA stuff is broken for some reason on my desktop. . I added an example in `examples/working_with_fields.jl` to demonstrate how to use the abstraction. @ali-ramadhan can you help me debug and test? This PR is small and simple. Addresses #174.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/210
https://github.com/CliMA/Oceananigans.jl/pull/210:363,Testability,test,test,363,This PR adds some convenience functions for interacting with fields that are functions. Unfortunately I can't test it on my mac because I don't have `CUDAnative` (?) and CUDA stuff is broken for some reason on my desktop. . I added an example in `examples/working_with_fields.jl` to demonstrate how to use the abstraction. @ali-ramadhan can you help me debug and test? This PR is small and simple. Addresses #174.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/210
https://github.com/CliMA/Oceananigans.jl/pull/210:390,Usability,simpl,simple,390,This PR adds some convenience functions for interacting with fields that are functions. Unfortunately I can't test it on my mac because I don't have `CUDAnative` (?) and CUDA stuff is broken for some reason on my desktop. . I added an example in `examples/working_with_fields.jl` to demonstrate how to use the abstraction. @ali-ramadhan can you help me debug and test? This PR is small and simple. Addresses #174.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/210
https://github.com/CliMA/Oceananigans.jl/issues/211:100,Energy Efficiency,efficient,efficient,100,"@christophernhill Was wondering if your stretched vertical grid spacing 3D elliptic solver would be efficient enough to use for the case where _Δz_ is constant. If it is, then we can make do with a single solver. And if there are no DCTs, then we can merge the CPU and GPU Poisson solvers! But maybe it's also good to keep the elliptic solver we currently have too. Just had this thought so leaving the issue open to discuss in the future.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/211
https://github.com/CliMA/Oceananigans.jl/issues/217:652,Deployability,configurat,configuration,652,"As discussed with @jm-c, the organization of physical constants and parameters is somewhat confusing. Currently, constants are stored in three places:. 1. `PlanetaryConstants`, which stores a rotation rate, gravitational acceleration, and a Coriolis parameter used in an f-plane approximation; 2. `ModelConfiguration`, which stores anisotropic (potentially turbulent) viscosities and diffusivities; 3. `EquationOfState`, of which there is only one kind: `LinearEquationOfState`, which stores both parameters associated with the equation of state in addition to a reference density. I see a few problems:. * `f` is not a property of a planet.; * 'Model configuration' is an obscure name for turbulent or molecular transport coefficients.; * A reference density is not a parameter in an equation of state. I propose that we consolidate these three types into two, removing the reference density from `EquationOfState` and define a new type containing f, g, ρ0, ν, and κ. I'm not sure what to call the new type. One possibility is `FluidParameters` or `PhysicalParameters` or `PhysicalConstants`. I also propose that we cease support for anisotropic transport coefficients as parameters, defined generally, at least for the moment. We can support constant anisotropic transport coefficients as a type of LES closure in the future.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/217
https://github.com/CliMA/Oceananigans.jl/issues/217:652,Modifiability,config,configuration,652,"As discussed with @jm-c, the organization of physical constants and parameters is somewhat confusing. Currently, constants are stored in three places:. 1. `PlanetaryConstants`, which stores a rotation rate, gravitational acceleration, and a Coriolis parameter used in an f-plane approximation; 2. `ModelConfiguration`, which stores anisotropic (potentially turbulent) viscosities and diffusivities; 3. `EquationOfState`, of which there is only one kind: `LinearEquationOfState`, which stores both parameters associated with the equation of state in addition to a reference density. I see a few problems:. * `f` is not a property of a planet.; * 'Model configuration' is an obscure name for turbulent or molecular transport coefficients.; * A reference density is not a parameter in an equation of state. I propose that we consolidate these three types into two, removing the reference density from `EquationOfState` and define a new type containing f, g, ρ0, ν, and κ. I'm not sure what to call the new type. One possibility is `FluidParameters` or `PhysicalParameters` or `PhysicalConstants`. I also propose that we cease support for anisotropic transport coefficients as parameters, defined generally, at least for the moment. We can support constant anisotropic transport coefficients as a type of LES closure in the future.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/217
https://github.com/CliMA/Oceananigans.jl/pull/218:150,Performance,perform,performance,150,"A preliminary implementation of (constant) smagorinsky.; - temporary arrays to be revisited; - need to improve the way to disable it (without loss of performance); - no attempt to try it on GPU. ; Tested with deep_convection example, running nicely with smag_coeff=3.3e-2 and Prandtl_num=1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/218
https://github.com/CliMA/Oceananigans.jl/pull/218:197,Testability,Test,Tested,197,"A preliminary implementation of (constant) smagorinsky.; - temporary arrays to be revisited; - need to improve the way to disable it (without loss of performance); - no attempt to try it on GPU. ; Tested with deep_convection example, running nicely with smag_coeff=3.3e-2 and Prandtl_num=1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/218
https://github.com/CliMA/Oceananigans.jl/issues/219:60,Testability,test,test,60,Pretty important so we can turn on the second golden master test!,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/219
https://github.com/CliMA/Oceananigans.jl/pull/224:53,Testability,test,tests,53,"Will be useful for pressure solver and time stepping tests, and long running simulations.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/224
https://github.com/CliMA/Oceananigans.jl/pull/226:73,Testability,test,test,73,It will fail right now but should start passing once #161 is fixed (this test will tell us whether we actually fixed it).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/226
https://github.com/CliMA/Oceananigans.jl/pull/227:37,Availability,recover,recover,37,Tests whether the Poisson solver can recover an analytic solution that is a product of sines and cosines. It can!,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/227
https://github.com/CliMA/Oceananigans.jl/pull/227:37,Safety,recover,recover,37,Tests whether the Poisson solver can recover an analytic solution that is a product of sines and cosines. It can!,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/227
https://github.com/CliMA/Oceananigans.jl/pull/227:0,Testability,Test,Tests,0,Tests whether the Poisson solver can recover an analytic solution that is a product of sines and cosines. It can!,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/227
https://github.com/CliMA/Oceananigans.jl/pull/229:87,Testability,test,tests,87,Looks like the velocity field is now fully incompressible over time but we need better tests to show this. Will merge once tests are implemented. Fully resolves #161. cc @sandreza,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/229
https://github.com/CliMA/Oceananigans.jl/pull/229:123,Testability,test,tests,123,Looks like the velocity field is now fully incompressible over time but we need better tests to show this. Will merge once tests are implemented. Fully resolves #161. cc @sandreza,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/229
https://github.com/CliMA/Oceananigans.jl/pull/234:3366,Availability,robust,robust,3366,"proved while I work on docs, and suggest improvements to the doc strings. There are some unit tests included in this PR. Please take a look and suggest new ones. There is significant notation associated with this PR. I don't think we need to finalize the notation here, but comments are welcome. This PR makes a significant contribution to `Oceananigans`' suite of operators: we introduce difference and interpolation operators that act on functions, thereby permitting the *composition* of such operations. The notation for a difference operator denoted by `δ` would be. `δx_caa` or `δx_faa` . where the three letters `caa` denote that differencing is performed at the location ""x cell, any y location, any z location"". The three letter format is an unambiguous specification of the location of a field in three dimensions on a staggered grid. Note that in this PR I have only defined partial derivative operators in this format, rather than difference operators, as we currently only accommodate regular grids. An interpolation operator is denoted by ""blacktriangleright"", so that. `▶x_caa`. denotes the interpolation of a field from `caa` to `faa`. Note that the destination of the operation is implied. Using composition, we also define double interpolations, such as. `▶xy_ffa`,. which interpolates a field located at `ffa` (x face, y face, and any z location) to `cca`. . There are 12 such double interpolation operators and they are essential for specifying eddy diffusivity closures based on strain rate. I think that using composition to its fullest will ultimately reduce the code length, make the code easier to maintain, and will probably make the code more robust by reducing the number of possible bugs. I think these should eventually be moved into `/src/operators/`, but I also think this should wait for a future PR. Ultimately I believe all the operators should be overhauled to match the pattern introduced in this PR. This PR partially partially solves #217 and will replace #218.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/234
https://github.com/CliMA/Oceananigans.jl/pull/234:248,Deployability,integrat,integrating,248,"This PR adds a `TurbulenceClosures` module to `Oceananigans`. At the moment nothing in the `Oceananigans` algorithm is touched --- the module is simply loaded and exported. I suggest that we keep it this way, given the size of this PR, and work on integrating the code into `Oceananigans` in a future PR. A simple incremental test in that future PR will be to replace the diffusive operators with the ones here and ensure that the regression tests still pass. Ultimately `TurbulenceClosures` will provide code for all the different diffusive terms we want to provide for `Oceananigans` users. The current design is that a 'closure' must provide a diffusive flux divergence term for `Oceananigans`. These diffusive flux terms are. * `∇_κ_∇ϕ(i, j, k, grid, ϕ, closure, u, v, w, T, S)` for a scalar `ϕ`; * `∂ⱼ_2ν_Σ₁ⱼ(i, j, k, grid, closure, u, v, w, T, S)` for x momentum; * `∂ⱼ_2ν_Σ₂ⱼ(i, j, k, grid, closure, u, v, w, T, S)` for y momentum; * `∂ⱼ_2ν_Σ₃ⱼ(i, j, k, grid, closure, u, v, w, T, S)` for z momentum. This will have to be generalized if we wish to provide more sophisticated turbulence closures with, for example, backscatter. I am open to changing the name of the diffusive flux divergences. This PR introduces the closures:. * `ConstantSmagorinsky` (with no buoyancy modification --- yet); * `ConstantIsotropicDiffusivity`; * `DirectionalDiffusivity` (with different horizontal and vertical diffusivities --- for lack of a better term). There is also an abstraction --- we have `ScalarDiffusivity`s and `TensorDiffusivity`s. The `DirectionalDiffusivity` is an example of a tensor diffusivity. I would like to add docs before merging. Please review the code and let me know what can be improved while I work on docs, and suggest improvements to the doc strings. There are some unit tests included in this PR. Please take a look and suggest new ones. There is significant notation associated with this PR. I don't think we need to finalize the notation here, but comments are welcome. This PR m",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/234
https://github.com/CliMA/Oceananigans.jl/pull/234:3271,Energy Efficiency,reduce,reduce,3271,"proved while I work on docs, and suggest improvements to the doc strings. There are some unit tests included in this PR. Please take a look and suggest new ones. There is significant notation associated with this PR. I don't think we need to finalize the notation here, but comments are welcome. This PR makes a significant contribution to `Oceananigans`' suite of operators: we introduce difference and interpolation operators that act on functions, thereby permitting the *composition* of such operations. The notation for a difference operator denoted by `δ` would be. `δx_caa` or `δx_faa` . where the three letters `caa` denote that differencing is performed at the location ""x cell, any y location, any z location"". The three letter format is an unambiguous specification of the location of a field in three dimensions on a staggered grid. Note that in this PR I have only defined partial derivative operators in this format, rather than difference operators, as we currently only accommodate regular grids. An interpolation operator is denoted by ""blacktriangleright"", so that. `▶x_caa`. denotes the interpolation of a field from `caa` to `faa`. Note that the destination of the operation is implied. Using composition, we also define double interpolations, such as. `▶xy_ffa`,. which interpolates a field located at `ffa` (x face, y face, and any z location) to `cca`. . There are 12 such double interpolation operators and they are essential for specifying eddy diffusivity closures based on strain rate. I think that using composition to its fullest will ultimately reduce the code length, make the code easier to maintain, and will probably make the code more robust by reducing the number of possible bugs. I think these should eventually be moved into `/src/operators/`, but I also think this should wait for a future PR. Ultimately I believe all the operators should be overhauled to match the pattern introduced in this PR. This PR partially partially solves #217 and will replace #218.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/234
https://github.com/CliMA/Oceananigans.jl/pull/234:248,Integrability,integrat,integrating,248,"This PR adds a `TurbulenceClosures` module to `Oceananigans`. At the moment nothing in the `Oceananigans` algorithm is touched --- the module is simply loaded and exported. I suggest that we keep it this way, given the size of this PR, and work on integrating the code into `Oceananigans` in a future PR. A simple incremental test in that future PR will be to replace the diffusive operators with the ones here and ensure that the regression tests still pass. Ultimately `TurbulenceClosures` will provide code for all the different diffusive terms we want to provide for `Oceananigans` users. The current design is that a 'closure' must provide a diffusive flux divergence term for `Oceananigans`. These diffusive flux terms are. * `∇_κ_∇ϕ(i, j, k, grid, ϕ, closure, u, v, w, T, S)` for a scalar `ϕ`; * `∂ⱼ_2ν_Σ₁ⱼ(i, j, k, grid, closure, u, v, w, T, S)` for x momentum; * `∂ⱼ_2ν_Σ₂ⱼ(i, j, k, grid, closure, u, v, w, T, S)` for y momentum; * `∂ⱼ_2ν_Σ₃ⱼ(i, j, k, grid, closure, u, v, w, T, S)` for z momentum. This will have to be generalized if we wish to provide more sophisticated turbulence closures with, for example, backscatter. I am open to changing the name of the diffusive flux divergences. This PR introduces the closures:. * `ConstantSmagorinsky` (with no buoyancy modification --- yet); * `ConstantIsotropicDiffusivity`; * `DirectionalDiffusivity` (with different horizontal and vertical diffusivities --- for lack of a better term). There is also an abstraction --- we have `ScalarDiffusivity`s and `TensorDiffusivity`s. The `DirectionalDiffusivity` is an example of a tensor diffusivity. I would like to add docs before merging. Please review the code and let me know what can be improved while I work on docs, and suggest improvements to the doc strings. There are some unit tests included in this PR. Please take a look and suggest new ones. There is significant notation associated with this PR. I don't think we need to finalize the notation here, but comments are welcome. This PR m",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/234
https://github.com/CliMA/Oceananigans.jl/pull/234:152,Performance,load,loaded,152,"This PR adds a `TurbulenceClosures` module to `Oceananigans`. At the moment nothing in the `Oceananigans` algorithm is touched --- the module is simply loaded and exported. I suggest that we keep it this way, given the size of this PR, and work on integrating the code into `Oceananigans` in a future PR. A simple incremental test in that future PR will be to replace the diffusive operators with the ones here and ensure that the regression tests still pass. Ultimately `TurbulenceClosures` will provide code for all the different diffusive terms we want to provide for `Oceananigans` users. The current design is that a 'closure' must provide a diffusive flux divergence term for `Oceananigans`. These diffusive flux terms are. * `∇_κ_∇ϕ(i, j, k, grid, ϕ, closure, u, v, w, T, S)` for a scalar `ϕ`; * `∂ⱼ_2ν_Σ₁ⱼ(i, j, k, grid, closure, u, v, w, T, S)` for x momentum; * `∂ⱼ_2ν_Σ₂ⱼ(i, j, k, grid, closure, u, v, w, T, S)` for y momentum; * `∂ⱼ_2ν_Σ₃ⱼ(i, j, k, grid, closure, u, v, w, T, S)` for z momentum. This will have to be generalized if we wish to provide more sophisticated turbulence closures with, for example, backscatter. I am open to changing the name of the diffusive flux divergences. This PR introduces the closures:. * `ConstantSmagorinsky` (with no buoyancy modification --- yet); * `ConstantIsotropicDiffusivity`; * `DirectionalDiffusivity` (with different horizontal and vertical diffusivities --- for lack of a better term). There is also an abstraction --- we have `ScalarDiffusivity`s and `TensorDiffusivity`s. The `DirectionalDiffusivity` is an example of a tensor diffusivity. I would like to add docs before merging. Please review the code and let me know what can be improved while I work on docs, and suggest improvements to the doc strings. There are some unit tests included in this PR. Please take a look and suggest new ones. There is significant notation associated with this PR. I don't think we need to finalize the notation here, but comments are welcome. This PR m",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/234
https://github.com/CliMA/Oceananigans.jl/pull/234:2349,Performance,perform,performed,2349,"ivity` (with different horizontal and vertical diffusivities --- for lack of a better term). There is also an abstraction --- we have `ScalarDiffusivity`s and `TensorDiffusivity`s. The `DirectionalDiffusivity` is an example of a tensor diffusivity. I would like to add docs before merging. Please review the code and let me know what can be improved while I work on docs, and suggest improvements to the doc strings. There are some unit tests included in this PR. Please take a look and suggest new ones. There is significant notation associated with this PR. I don't think we need to finalize the notation here, but comments are welcome. This PR makes a significant contribution to `Oceananigans`' suite of operators: we introduce difference and interpolation operators that act on functions, thereby permitting the *composition* of such operations. The notation for a difference operator denoted by `δ` would be. `δx_caa` or `δx_faa` . where the three letters `caa` denote that differencing is performed at the location ""x cell, any y location, any z location"". The three letter format is an unambiguous specification of the location of a field in three dimensions on a staggered grid. Note that in this PR I have only defined partial derivative operators in this format, rather than difference operators, as we currently only accommodate regular grids. An interpolation operator is denoted by ""blacktriangleright"", so that. `▶x_caa`. denotes the interpolation of a field from `caa` to `faa`. Note that the destination of the operation is implied. Using composition, we also define double interpolations, such as. `▶xy_ffa`,. which interpolates a field located at `ffa` (x face, y face, and any z location) to `cca`. . There are 12 such double interpolation operators and they are essential for specifying eddy diffusivity closures based on strain rate. I think that using composition to its fullest will ultimately reduce the code length, make the code easier to maintain, and will probably make t",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/234
https://github.com/CliMA/Oceananigans.jl/pull/234:326,Testability,test,test,326,"This PR adds a `TurbulenceClosures` module to `Oceananigans`. At the moment nothing in the `Oceananigans` algorithm is touched --- the module is simply loaded and exported. I suggest that we keep it this way, given the size of this PR, and work on integrating the code into `Oceananigans` in a future PR. A simple incremental test in that future PR will be to replace the diffusive operators with the ones here and ensure that the regression tests still pass. Ultimately `TurbulenceClosures` will provide code for all the different diffusive terms we want to provide for `Oceananigans` users. The current design is that a 'closure' must provide a diffusive flux divergence term for `Oceananigans`. These diffusive flux terms are. * `∇_κ_∇ϕ(i, j, k, grid, ϕ, closure, u, v, w, T, S)` for a scalar `ϕ`; * `∂ⱼ_2ν_Σ₁ⱼ(i, j, k, grid, closure, u, v, w, T, S)` for x momentum; * `∂ⱼ_2ν_Σ₂ⱼ(i, j, k, grid, closure, u, v, w, T, S)` for y momentum; * `∂ⱼ_2ν_Σ₃ⱼ(i, j, k, grid, closure, u, v, w, T, S)` for z momentum. This will have to be generalized if we wish to provide more sophisticated turbulence closures with, for example, backscatter. I am open to changing the name of the diffusive flux divergences. This PR introduces the closures:. * `ConstantSmagorinsky` (with no buoyancy modification --- yet); * `ConstantIsotropicDiffusivity`; * `DirectionalDiffusivity` (with different horizontal and vertical diffusivities --- for lack of a better term). There is also an abstraction --- we have `ScalarDiffusivity`s and `TensorDiffusivity`s. The `DirectionalDiffusivity` is an example of a tensor diffusivity. I would like to add docs before merging. Please review the code and let me know what can be improved while I work on docs, and suggest improvements to the doc strings. There are some unit tests included in this PR. Please take a look and suggest new ones. There is significant notation associated with this PR. I don't think we need to finalize the notation here, but comments are welcome. This PR m",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/234
https://github.com/CliMA/Oceananigans.jl/pull/234:442,Testability,test,tests,442,"This PR adds a `TurbulenceClosures` module to `Oceananigans`. At the moment nothing in the `Oceananigans` algorithm is touched --- the module is simply loaded and exported. I suggest that we keep it this way, given the size of this PR, and work on integrating the code into `Oceananigans` in a future PR. A simple incremental test in that future PR will be to replace the diffusive operators with the ones here and ensure that the regression tests still pass. Ultimately `TurbulenceClosures` will provide code for all the different diffusive terms we want to provide for `Oceananigans` users. The current design is that a 'closure' must provide a diffusive flux divergence term for `Oceananigans`. These diffusive flux terms are. * `∇_κ_∇ϕ(i, j, k, grid, ϕ, closure, u, v, w, T, S)` for a scalar `ϕ`; * `∂ⱼ_2ν_Σ₁ⱼ(i, j, k, grid, closure, u, v, w, T, S)` for x momentum; * `∂ⱼ_2ν_Σ₂ⱼ(i, j, k, grid, closure, u, v, w, T, S)` for y momentum; * `∂ⱼ_2ν_Σ₃ⱼ(i, j, k, grid, closure, u, v, w, T, S)` for z momentum. This will have to be generalized if we wish to provide more sophisticated turbulence closures with, for example, backscatter. I am open to changing the name of the diffusive flux divergences. This PR introduces the closures:. * `ConstantSmagorinsky` (with no buoyancy modification --- yet); * `ConstantIsotropicDiffusivity`; * `DirectionalDiffusivity` (with different horizontal and vertical diffusivities --- for lack of a better term). There is also an abstraction --- we have `ScalarDiffusivity`s and `TensorDiffusivity`s. The `DirectionalDiffusivity` is an example of a tensor diffusivity. I would like to add docs before merging. Please review the code and let me know what can be improved while I work on docs, and suggest improvements to the doc strings. There are some unit tests included in this PR. Please take a look and suggest new ones. There is significant notation associated with this PR. I don't think we need to finalize the notation here, but comments are welcome. This PR m",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/234
https://github.com/CliMA/Oceananigans.jl/pull/234:1790,Testability,test,tests,1790,"lar `ϕ`; * `∂ⱼ_2ν_Σ₁ⱼ(i, j, k, grid, closure, u, v, w, T, S)` for x momentum; * `∂ⱼ_2ν_Σ₂ⱼ(i, j, k, grid, closure, u, v, w, T, S)` for y momentum; * `∂ⱼ_2ν_Σ₃ⱼ(i, j, k, grid, closure, u, v, w, T, S)` for z momentum. This will have to be generalized if we wish to provide more sophisticated turbulence closures with, for example, backscatter. I am open to changing the name of the diffusive flux divergences. This PR introduces the closures:. * `ConstantSmagorinsky` (with no buoyancy modification --- yet); * `ConstantIsotropicDiffusivity`; * `DirectionalDiffusivity` (with different horizontal and vertical diffusivities --- for lack of a better term). There is also an abstraction --- we have `ScalarDiffusivity`s and `TensorDiffusivity`s. The `DirectionalDiffusivity` is an example of a tensor diffusivity. I would like to add docs before merging. Please review the code and let me know what can be improved while I work on docs, and suggest improvements to the doc strings. There are some unit tests included in this PR. Please take a look and suggest new ones. There is significant notation associated with this PR. I don't think we need to finalize the notation here, but comments are welcome. This PR makes a significant contribution to `Oceananigans`' suite of operators: we introduce difference and interpolation operators that act on functions, thereby permitting the *composition* of such operations. The notation for a difference operator denoted by `δ` would be. `δx_caa` or `δx_faa` . where the three letters `caa` denote that differencing is performed at the location ""x cell, any y location, any z location"". The three letter format is an unambiguous specification of the location of a field in three dimensions on a staggered grid. Note that in this PR I have only defined partial derivative operators in this format, rather than difference operators, as we currently only accommodate regular grids. An interpolation operator is denoted by ""blacktriangleright"", so that. `▶x_caa`. den",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/234
https://github.com/CliMA/Oceananigans.jl/pull/234:145,Usability,simpl,simply,145,"This PR adds a `TurbulenceClosures` module to `Oceananigans`. At the moment nothing in the `Oceananigans` algorithm is touched --- the module is simply loaded and exported. I suggest that we keep it this way, given the size of this PR, and work on integrating the code into `Oceananigans` in a future PR. A simple incremental test in that future PR will be to replace the diffusive operators with the ones here and ensure that the regression tests still pass. Ultimately `TurbulenceClosures` will provide code for all the different diffusive terms we want to provide for `Oceananigans` users. The current design is that a 'closure' must provide a diffusive flux divergence term for `Oceananigans`. These diffusive flux terms are. * `∇_κ_∇ϕ(i, j, k, grid, ϕ, closure, u, v, w, T, S)` for a scalar `ϕ`; * `∂ⱼ_2ν_Σ₁ⱼ(i, j, k, grid, closure, u, v, w, T, S)` for x momentum; * `∂ⱼ_2ν_Σ₂ⱼ(i, j, k, grid, closure, u, v, w, T, S)` for y momentum; * `∂ⱼ_2ν_Σ₃ⱼ(i, j, k, grid, closure, u, v, w, T, S)` for z momentum. This will have to be generalized if we wish to provide more sophisticated turbulence closures with, for example, backscatter. I am open to changing the name of the diffusive flux divergences. This PR introduces the closures:. * `ConstantSmagorinsky` (with no buoyancy modification --- yet); * `ConstantIsotropicDiffusivity`; * `DirectionalDiffusivity` (with different horizontal and vertical diffusivities --- for lack of a better term). There is also an abstraction --- we have `ScalarDiffusivity`s and `TensorDiffusivity`s. The `DirectionalDiffusivity` is an example of a tensor diffusivity. I would like to add docs before merging. Please review the code and let me know what can be improved while I work on docs, and suggest improvements to the doc strings. There are some unit tests included in this PR. Please take a look and suggest new ones. There is significant notation associated with this PR. I don't think we need to finalize the notation here, but comments are welcome. This PR m",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/234
https://github.com/CliMA/Oceananigans.jl/pull/234:307,Usability,simpl,simple,307,"This PR adds a `TurbulenceClosures` module to `Oceananigans`. At the moment nothing in the `Oceananigans` algorithm is touched --- the module is simply loaded and exported. I suggest that we keep it this way, given the size of this PR, and work on integrating the code into `Oceananigans` in a future PR. A simple incremental test in that future PR will be to replace the diffusive operators with the ones here and ensure that the regression tests still pass. Ultimately `TurbulenceClosures` will provide code for all the different diffusive terms we want to provide for `Oceananigans` users. The current design is that a 'closure' must provide a diffusive flux divergence term for `Oceananigans`. These diffusive flux terms are. * `∇_κ_∇ϕ(i, j, k, grid, ϕ, closure, u, v, w, T, S)` for a scalar `ϕ`; * `∂ⱼ_2ν_Σ₁ⱼ(i, j, k, grid, closure, u, v, w, T, S)` for x momentum; * `∂ⱼ_2ν_Σ₂ⱼ(i, j, k, grid, closure, u, v, w, T, S)` for y momentum; * `∂ⱼ_2ν_Σ₃ⱼ(i, j, k, grid, closure, u, v, w, T, S)` for z momentum. This will have to be generalized if we wish to provide more sophisticated turbulence closures with, for example, backscatter. I am open to changing the name of the diffusive flux divergences. This PR introduces the closures:. * `ConstantSmagorinsky` (with no buoyancy modification --- yet); * `ConstantIsotropicDiffusivity`; * `DirectionalDiffusivity` (with different horizontal and vertical diffusivities --- for lack of a better term). There is also an abstraction --- we have `ScalarDiffusivity`s and `TensorDiffusivity`s. The `DirectionalDiffusivity` is an example of a tensor diffusivity. I would like to add docs before merging. Please review the code and let me know what can be improved while I work on docs, and suggest improvements to the doc strings. There are some unit tests included in this PR. Please take a look and suggest new ones. There is significant notation associated with this PR. I don't think we need to finalize the notation here, but comments are welcome. This PR m",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/234
https://github.com/CliMA/Oceananigans.jl/pull/236:8,Deployability,update,updates,8,"This PR updates the code to use kinematic (density normalized) hydrostatic pressure and buoyancy rather than density perturbation. Using kinematic pressure simplifies the code because the reference density no longer affects the algorithm. Using buoyancy instead of the density perturbation will ultimately simplify the code further because it is needed for turbulence closures (for example). The docs should be updated before merging. Also, the golden master tests should be updated elsewhere; then it can be confirmed here that these changes preserve the functioning of the code (these changes do not affect the outcome of the algorithm). I have also copy/pasted an interpolation operator that will become part of the code once #234 is merged. Prior to this PR, the interpolation of the buoyancy field to z faces was done manually. We need a function to calculate buoyancy for the turbulence closures; so I think we are better off deleting the density perturbation function, ultimately. After this change the reference density ceases to be used in the algorithm. I have also included salinity in the calculation of buoyancy.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/236
https://github.com/CliMA/Oceananigans.jl/pull/236:411,Deployability,update,updated,411,"This PR updates the code to use kinematic (density normalized) hydrostatic pressure and buoyancy rather than density perturbation. Using kinematic pressure simplifies the code because the reference density no longer affects the algorithm. Using buoyancy instead of the density perturbation will ultimately simplify the code further because it is needed for turbulence closures (for example). The docs should be updated before merging. Also, the golden master tests should be updated elsewhere; then it can be confirmed here that these changes preserve the functioning of the code (these changes do not affect the outcome of the algorithm). I have also copy/pasted an interpolation operator that will become part of the code once #234 is merged. Prior to this PR, the interpolation of the buoyancy field to z faces was done manually. We need a function to calculate buoyancy for the turbulence closures; so I think we are better off deleting the density perturbation function, ultimately. After this change the reference density ceases to be used in the algorithm. I have also included salinity in the calculation of buoyancy.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/236
https://github.com/CliMA/Oceananigans.jl/pull/236:475,Deployability,update,updated,475,"This PR updates the code to use kinematic (density normalized) hydrostatic pressure and buoyancy rather than density perturbation. Using kinematic pressure simplifies the code because the reference density no longer affects the algorithm. Using buoyancy instead of the density perturbation will ultimately simplify the code further because it is needed for turbulence closures (for example). The docs should be updated before merging. Also, the golden master tests should be updated elsewhere; then it can be confirmed here that these changes preserve the functioning of the code (these changes do not affect the outcome of the algorithm). I have also copy/pasted an interpolation operator that will become part of the code once #234 is merged. Prior to this PR, the interpolation of the buoyancy field to z faces was done manually. We need a function to calculate buoyancy for the turbulence closures; so I think we are better off deleting the density perturbation function, ultimately. After this change the reference density ceases to be used in the algorithm. I have also included salinity in the calculation of buoyancy.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/236
https://github.com/CliMA/Oceananigans.jl/pull/236:459,Testability,test,tests,459,"This PR updates the code to use kinematic (density normalized) hydrostatic pressure and buoyancy rather than density perturbation. Using kinematic pressure simplifies the code because the reference density no longer affects the algorithm. Using buoyancy instead of the density perturbation will ultimately simplify the code further because it is needed for turbulence closures (for example). The docs should be updated before merging. Also, the golden master tests should be updated elsewhere; then it can be confirmed here that these changes preserve the functioning of the code (these changes do not affect the outcome of the algorithm). I have also copy/pasted an interpolation operator that will become part of the code once #234 is merged. Prior to this PR, the interpolation of the buoyancy field to z faces was done manually. We need a function to calculate buoyancy for the turbulence closures; so I think we are better off deleting the density perturbation function, ultimately. After this change the reference density ceases to be used in the algorithm. I have also included salinity in the calculation of buoyancy.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/236
https://github.com/CliMA/Oceananigans.jl/pull/236:156,Usability,simpl,simplifies,156,"This PR updates the code to use kinematic (density normalized) hydrostatic pressure and buoyancy rather than density perturbation. Using kinematic pressure simplifies the code because the reference density no longer affects the algorithm. Using buoyancy instead of the density perturbation will ultimately simplify the code further because it is needed for turbulence closures (for example). The docs should be updated before merging. Also, the golden master tests should be updated elsewhere; then it can be confirmed here that these changes preserve the functioning of the code (these changes do not affect the outcome of the algorithm). I have also copy/pasted an interpolation operator that will become part of the code once #234 is merged. Prior to this PR, the interpolation of the buoyancy field to z faces was done manually. We need a function to calculate buoyancy for the turbulence closures; so I think we are better off deleting the density perturbation function, ultimately. After this change the reference density ceases to be used in the algorithm. I have also included salinity in the calculation of buoyancy.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/236
https://github.com/CliMA/Oceananigans.jl/pull/236:306,Usability,simpl,simplify,306,"This PR updates the code to use kinematic (density normalized) hydrostatic pressure and buoyancy rather than density perturbation. Using kinematic pressure simplifies the code because the reference density no longer affects the algorithm. Using buoyancy instead of the density perturbation will ultimately simplify the code further because it is needed for turbulence closures (for example). The docs should be updated before merging. Also, the golden master tests should be updated elsewhere; then it can be confirmed here that these changes preserve the functioning of the code (these changes do not affect the outcome of the algorithm). I have also copy/pasted an interpolation operator that will become part of the code once #234 is merged. Prior to this PR, the interpolation of the buoyancy field to z faces was done manually. We need a function to calculate buoyancy for the turbulence closures; so I think we are better off deleting the density perturbation function, ultimately. After this change the reference density ceases to be used in the algorithm. I have also included salinity in the calculation of buoyancy.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/236
https://github.com/CliMA/Oceananigans.jl/pull/237:240,Testability,test,tests,240,"In addition, this PR solves #213: boundary conditions in `z` can now be set by writing. ```julia; model.boundary_conditions.T.z.top = top_bc; model.boundary_conditions.T.z.bottom = bottom_bc; ```. for any field `T`. In a future PR: physics tests that verify the boundary bc is correct.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/237
https://github.com/CliMA/Oceananigans.jl/pull/238:10,Energy Efficiency,adapt,adapts,10,"This ""PR"" adapts one of the CPU Poisson solver tests to the GPU. The test fails. . Hopefully there is a bug in the test. If so, it should be fixed so that we have a valid test for the GPU Poisson solver. I suggest we use just one solver for both the CPU and the GPU --- unifying those could be in the scope of this PR. It'll also be nice to have one function that returns the (real) solution to the Poisson equation, given complex input. . Our algorithm (for Periodic-Periodic-Neumann --- this would not be the case for Periodic-Periodic-Periodic) requires one temporary storage variable (which stores a permuted, complex version of the solution) that should be part of the `PPNPoissonSolver` struct (see what I did there?)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/238
https://github.com/CliMA/Oceananigans.jl/pull/238:10,Modifiability,adapt,adapts,10,"This ""PR"" adapts one of the CPU Poisson solver tests to the GPU. The test fails. . Hopefully there is a bug in the test. If so, it should be fixed so that we have a valid test for the GPU Poisson solver. I suggest we use just one solver for both the CPU and the GPU --- unifying those could be in the scope of this PR. It'll also be nice to have one function that returns the (real) solution to the Poisson equation, given complex input. . Our algorithm (for Periodic-Periodic-Neumann --- this would not be the case for Periodic-Periodic-Periodic) requires one temporary storage variable (which stores a permuted, complex version of the solution) that should be part of the `PPNPoissonSolver` struct (see what I did there?)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/238
https://github.com/CliMA/Oceananigans.jl/pull/238:579,Modifiability,variab,variable,579,"This ""PR"" adapts one of the CPU Poisson solver tests to the GPU. The test fails. . Hopefully there is a bug in the test. If so, it should be fixed so that we have a valid test for the GPU Poisson solver. I suggest we use just one solver for both the CPU and the GPU --- unifying those could be in the scope of this PR. It'll also be nice to have one function that returns the (real) solution to the Poisson equation, given complex input. . Our algorithm (for Periodic-Periodic-Neumann --- this would not be the case for Periodic-Periodic-Periodic) requires one temporary storage variable (which stores a permuted, complex version of the solution) that should be part of the `PPNPoissonSolver` struct (see what I did there?)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/238
https://github.com/CliMA/Oceananigans.jl/pull/238:47,Testability,test,tests,47,"This ""PR"" adapts one of the CPU Poisson solver tests to the GPU. The test fails. . Hopefully there is a bug in the test. If so, it should be fixed so that we have a valid test for the GPU Poisson solver. I suggest we use just one solver for both the CPU and the GPU --- unifying those could be in the scope of this PR. It'll also be nice to have one function that returns the (real) solution to the Poisson equation, given complex input. . Our algorithm (for Periodic-Periodic-Neumann --- this would not be the case for Periodic-Periodic-Periodic) requires one temporary storage variable (which stores a permuted, complex version of the solution) that should be part of the `PPNPoissonSolver` struct (see what I did there?)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/238
https://github.com/CliMA/Oceananigans.jl/pull/238:69,Testability,test,test,69,"This ""PR"" adapts one of the CPU Poisson solver tests to the GPU. The test fails. . Hopefully there is a bug in the test. If so, it should be fixed so that we have a valid test for the GPU Poisson solver. I suggest we use just one solver for both the CPU and the GPU --- unifying those could be in the scope of this PR. It'll also be nice to have one function that returns the (real) solution to the Poisson equation, given complex input. . Our algorithm (for Periodic-Periodic-Neumann --- this would not be the case for Periodic-Periodic-Periodic) requires one temporary storage variable (which stores a permuted, complex version of the solution) that should be part of the `PPNPoissonSolver` struct (see what I did there?)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/238
https://github.com/CliMA/Oceananigans.jl/pull/238:115,Testability,test,test,115,"This ""PR"" adapts one of the CPU Poisson solver tests to the GPU. The test fails. . Hopefully there is a bug in the test. If so, it should be fixed so that we have a valid test for the GPU Poisson solver. I suggest we use just one solver for both the CPU and the GPU --- unifying those could be in the scope of this PR. It'll also be nice to have one function that returns the (real) solution to the Poisson equation, given complex input. . Our algorithm (for Periodic-Periodic-Neumann --- this would not be the case for Periodic-Periodic-Periodic) requires one temporary storage variable (which stores a permuted, complex version of the solution) that should be part of the `PPNPoissonSolver` struct (see what I did there?)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/238
https://github.com/CliMA/Oceananigans.jl/pull/238:171,Testability,test,test,171,"This ""PR"" adapts one of the CPU Poisson solver tests to the GPU. The test fails. . Hopefully there is a bug in the test. If so, it should be fixed so that we have a valid test for the GPU Poisson solver. I suggest we use just one solver for both the CPU and the GPU --- unifying those could be in the scope of this PR. It'll also be nice to have one function that returns the (real) solution to the Poisson equation, given complex input. . Our algorithm (for Periodic-Periodic-Neumann --- this would not be the case for Periodic-Periodic-Periodic) requires one temporary storage variable (which stores a permuted, complex version of the solution) that should be part of the `PPNPoissonSolver` struct (see what I did there?)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/238
https://github.com/CliMA/Oceananigans.jl/pull/239:641,Deployability,integrat,integrate,641,"This PR introduces a new regression test (and renames ""golden master tests"" to ""regression tests"") based on Rayleigh-Benard convection that adds regression tests for `Value` boundary conditions, the forcing implementation and the salinity equation, by using salinity as a passive tracer in the test. The test avoids setting random initial conditions by loading both the initial model state and the comparison state from file. Note that loading the model state from file required writing a new `OutputWriter` that outputs and loads the ""source terms"", `G`. This implementation is included in `test_regression.jl`, but it may be worthwhile to integrate it into `output_writers.jl` at some point. The test runs on the CPU and GPU. However, similar to the thermal bubble tests, this test fails on the GPU. This PR also adds a file to `sandbox` to aid running and exploring solutions to Rayleigh-Benard and also demonstrates the user-specification of a forcing term.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/239
https://github.com/CliMA/Oceananigans.jl/pull/239:641,Integrability,integrat,integrate,641,"This PR introduces a new regression test (and renames ""golden master tests"" to ""regression tests"") based on Rayleigh-Benard convection that adds regression tests for `Value` boundary conditions, the forcing implementation and the salinity equation, by using salinity as a passive tracer in the test. The test avoids setting random initial conditions by loading both the initial model state and the comparison state from file. Note that loading the model state from file required writing a new `OutputWriter` that outputs and loads the ""source terms"", `G`. This implementation is included in `test_regression.jl`, but it may be worthwhile to integrate it into `output_writers.jl` at some point. The test runs on the CPU and GPU. However, similar to the thermal bubble tests, this test fails on the GPU. This PR also adds a file to `sandbox` to aid running and exploring solutions to Rayleigh-Benard and also demonstrates the user-specification of a forcing term.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/239
https://github.com/CliMA/Oceananigans.jl/pull/239:831,Modifiability,sandbox,sandbox,831,"This PR introduces a new regression test (and renames ""golden master tests"" to ""regression tests"") based on Rayleigh-Benard convection that adds regression tests for `Value` boundary conditions, the forcing implementation and the salinity equation, by using salinity as a passive tracer in the test. The test avoids setting random initial conditions by loading both the initial model state and the comparison state from file. Note that loading the model state from file required writing a new `OutputWriter` that outputs and loads the ""source terms"", `G`. This implementation is included in `test_regression.jl`, but it may be worthwhile to integrate it into `output_writers.jl` at some point. The test runs on the CPU and GPU. However, similar to the thermal bubble tests, this test fails on the GPU. This PR also adds a file to `sandbox` to aid running and exploring solutions to Rayleigh-Benard and also demonstrates the user-specification of a forcing term.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/239
https://github.com/CliMA/Oceananigans.jl/pull/239:353,Performance,load,loading,353,"This PR introduces a new regression test (and renames ""golden master tests"" to ""regression tests"") based on Rayleigh-Benard convection that adds regression tests for `Value` boundary conditions, the forcing implementation and the salinity equation, by using salinity as a passive tracer in the test. The test avoids setting random initial conditions by loading both the initial model state and the comparison state from file. Note that loading the model state from file required writing a new `OutputWriter` that outputs and loads the ""source terms"", `G`. This implementation is included in `test_regression.jl`, but it may be worthwhile to integrate it into `output_writers.jl` at some point. The test runs on the CPU and GPU. However, similar to the thermal bubble tests, this test fails on the GPU. This PR also adds a file to `sandbox` to aid running and exploring solutions to Rayleigh-Benard and also demonstrates the user-specification of a forcing term.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/239
https://github.com/CliMA/Oceananigans.jl/pull/239:436,Performance,load,loading,436,"This PR introduces a new regression test (and renames ""golden master tests"" to ""regression tests"") based on Rayleigh-Benard convection that adds regression tests for `Value` boundary conditions, the forcing implementation and the salinity equation, by using salinity as a passive tracer in the test. The test avoids setting random initial conditions by loading both the initial model state and the comparison state from file. Note that loading the model state from file required writing a new `OutputWriter` that outputs and loads the ""source terms"", `G`. This implementation is included in `test_regression.jl`, but it may be worthwhile to integrate it into `output_writers.jl` at some point. The test runs on the CPU and GPU. However, similar to the thermal bubble tests, this test fails on the GPU. This PR also adds a file to `sandbox` to aid running and exploring solutions to Rayleigh-Benard and also demonstrates the user-specification of a forcing term.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/239
https://github.com/CliMA/Oceananigans.jl/pull/239:525,Performance,load,loads,525,"This PR introduces a new regression test (and renames ""golden master tests"" to ""regression tests"") based on Rayleigh-Benard convection that adds regression tests for `Value` boundary conditions, the forcing implementation and the salinity equation, by using salinity as a passive tracer in the test. The test avoids setting random initial conditions by loading both the initial model state and the comparison state from file. Note that loading the model state from file required writing a new `OutputWriter` that outputs and loads the ""source terms"", `G`. This implementation is included in `test_regression.jl`, but it may be worthwhile to integrate it into `output_writers.jl` at some point. The test runs on the CPU and GPU. However, similar to the thermal bubble tests, this test fails on the GPU. This PR also adds a file to `sandbox` to aid running and exploring solutions to Rayleigh-Benard and also demonstrates the user-specification of a forcing term.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/239
https://github.com/CliMA/Oceananigans.jl/pull/239:309,Safety,avoid,avoids,309,"This PR introduces a new regression test (and renames ""golden master tests"" to ""regression tests"") based on Rayleigh-Benard convection that adds regression tests for `Value` boundary conditions, the forcing implementation and the salinity equation, by using salinity as a passive tracer in the test. The test avoids setting random initial conditions by loading both the initial model state and the comparison state from file. Note that loading the model state from file required writing a new `OutputWriter` that outputs and loads the ""source terms"", `G`. This implementation is included in `test_regression.jl`, but it may be worthwhile to integrate it into `output_writers.jl` at some point. The test runs on the CPU and GPU. However, similar to the thermal bubble tests, this test fails on the GPU. This PR also adds a file to `sandbox` to aid running and exploring solutions to Rayleigh-Benard and also demonstrates the user-specification of a forcing term.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/239
https://github.com/CliMA/Oceananigans.jl/pull/239:36,Testability,test,test,36,"This PR introduces a new regression test (and renames ""golden master tests"" to ""regression tests"") based on Rayleigh-Benard convection that adds regression tests for `Value` boundary conditions, the forcing implementation and the salinity equation, by using salinity as a passive tracer in the test. The test avoids setting random initial conditions by loading both the initial model state and the comparison state from file. Note that loading the model state from file required writing a new `OutputWriter` that outputs and loads the ""source terms"", `G`. This implementation is included in `test_regression.jl`, but it may be worthwhile to integrate it into `output_writers.jl` at some point. The test runs on the CPU and GPU. However, similar to the thermal bubble tests, this test fails on the GPU. This PR also adds a file to `sandbox` to aid running and exploring solutions to Rayleigh-Benard and also demonstrates the user-specification of a forcing term.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/239
https://github.com/CliMA/Oceananigans.jl/pull/239:69,Testability,test,tests,69,"This PR introduces a new regression test (and renames ""golden master tests"" to ""regression tests"") based on Rayleigh-Benard convection that adds regression tests for `Value` boundary conditions, the forcing implementation and the salinity equation, by using salinity as a passive tracer in the test. The test avoids setting random initial conditions by loading both the initial model state and the comparison state from file. Note that loading the model state from file required writing a new `OutputWriter` that outputs and loads the ""source terms"", `G`. This implementation is included in `test_regression.jl`, but it may be worthwhile to integrate it into `output_writers.jl` at some point. The test runs on the CPU and GPU. However, similar to the thermal bubble tests, this test fails on the GPU. This PR also adds a file to `sandbox` to aid running and exploring solutions to Rayleigh-Benard and also demonstrates the user-specification of a forcing term.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/239
https://github.com/CliMA/Oceananigans.jl/pull/239:91,Testability,test,tests,91,"This PR introduces a new regression test (and renames ""golden master tests"" to ""regression tests"") based on Rayleigh-Benard convection that adds regression tests for `Value` boundary conditions, the forcing implementation and the salinity equation, by using salinity as a passive tracer in the test. The test avoids setting random initial conditions by loading both the initial model state and the comparison state from file. Note that loading the model state from file required writing a new `OutputWriter` that outputs and loads the ""source terms"", `G`. This implementation is included in `test_regression.jl`, but it may be worthwhile to integrate it into `output_writers.jl` at some point. The test runs on the CPU and GPU. However, similar to the thermal bubble tests, this test fails on the GPU. This PR also adds a file to `sandbox` to aid running and exploring solutions to Rayleigh-Benard and also demonstrates the user-specification of a forcing term.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/239
https://github.com/CliMA/Oceananigans.jl/pull/239:156,Testability,test,tests,156,"This PR introduces a new regression test (and renames ""golden master tests"" to ""regression tests"") based on Rayleigh-Benard convection that adds regression tests for `Value` boundary conditions, the forcing implementation and the salinity equation, by using salinity as a passive tracer in the test. The test avoids setting random initial conditions by loading both the initial model state and the comparison state from file. Note that loading the model state from file required writing a new `OutputWriter` that outputs and loads the ""source terms"", `G`. This implementation is included in `test_regression.jl`, but it may be worthwhile to integrate it into `output_writers.jl` at some point. The test runs on the CPU and GPU. However, similar to the thermal bubble tests, this test fails on the GPU. This PR also adds a file to `sandbox` to aid running and exploring solutions to Rayleigh-Benard and also demonstrates the user-specification of a forcing term.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/239
https://github.com/CliMA/Oceananigans.jl/pull/239:294,Testability,test,test,294,"This PR introduces a new regression test (and renames ""golden master tests"" to ""regression tests"") based on Rayleigh-Benard convection that adds regression tests for `Value` boundary conditions, the forcing implementation and the salinity equation, by using salinity as a passive tracer in the test. The test avoids setting random initial conditions by loading both the initial model state and the comparison state from file. Note that loading the model state from file required writing a new `OutputWriter` that outputs and loads the ""source terms"", `G`. This implementation is included in `test_regression.jl`, but it may be worthwhile to integrate it into `output_writers.jl` at some point. The test runs on the CPU and GPU. However, similar to the thermal bubble tests, this test fails on the GPU. This PR also adds a file to `sandbox` to aid running and exploring solutions to Rayleigh-Benard and also demonstrates the user-specification of a forcing term.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/239
https://github.com/CliMA/Oceananigans.jl/pull/239:304,Testability,test,test,304,"This PR introduces a new regression test (and renames ""golden master tests"" to ""regression tests"") based on Rayleigh-Benard convection that adds regression tests for `Value` boundary conditions, the forcing implementation and the salinity equation, by using salinity as a passive tracer in the test. The test avoids setting random initial conditions by loading both the initial model state and the comparison state from file. Note that loading the model state from file required writing a new `OutputWriter` that outputs and loads the ""source terms"", `G`. This implementation is included in `test_regression.jl`, but it may be worthwhile to integrate it into `output_writers.jl` at some point. The test runs on the CPU and GPU. However, similar to the thermal bubble tests, this test fails on the GPU. This PR also adds a file to `sandbox` to aid running and exploring solutions to Rayleigh-Benard and also demonstrates the user-specification of a forcing term.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/239
https://github.com/CliMA/Oceananigans.jl/pull/239:698,Testability,test,test,698,"This PR introduces a new regression test (and renames ""golden master tests"" to ""regression tests"") based on Rayleigh-Benard convection that adds regression tests for `Value` boundary conditions, the forcing implementation and the salinity equation, by using salinity as a passive tracer in the test. The test avoids setting random initial conditions by loading both the initial model state and the comparison state from file. Note that loading the model state from file required writing a new `OutputWriter` that outputs and loads the ""source terms"", `G`. This implementation is included in `test_regression.jl`, but it may be worthwhile to integrate it into `output_writers.jl` at some point. The test runs on the CPU and GPU. However, similar to the thermal bubble tests, this test fails on the GPU. This PR also adds a file to `sandbox` to aid running and exploring solutions to Rayleigh-Benard and also demonstrates the user-specification of a forcing term.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/239
https://github.com/CliMA/Oceananigans.jl/pull/239:767,Testability,test,tests,767,"This PR introduces a new regression test (and renames ""golden master tests"" to ""regression tests"") based on Rayleigh-Benard convection that adds regression tests for `Value` boundary conditions, the forcing implementation and the salinity equation, by using salinity as a passive tracer in the test. The test avoids setting random initial conditions by loading both the initial model state and the comparison state from file. Note that loading the model state from file required writing a new `OutputWriter` that outputs and loads the ""source terms"", `G`. This implementation is included in `test_regression.jl`, but it may be worthwhile to integrate it into `output_writers.jl` at some point. The test runs on the CPU and GPU. However, similar to the thermal bubble tests, this test fails on the GPU. This PR also adds a file to `sandbox` to aid running and exploring solutions to Rayleigh-Benard and also demonstrates the user-specification of a forcing term.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/239
https://github.com/CliMA/Oceananigans.jl/pull/239:779,Testability,test,test,779,"This PR introduces a new regression test (and renames ""golden master tests"" to ""regression tests"") based on Rayleigh-Benard convection that adds regression tests for `Value` boundary conditions, the forcing implementation and the salinity equation, by using salinity as a passive tracer in the test. The test avoids setting random initial conditions by loading both the initial model state and the comparison state from file. Note that loading the model state from file required writing a new `OutputWriter` that outputs and loads the ""source terms"", `G`. This implementation is included in `test_regression.jl`, but it may be worthwhile to integrate it into `output_writers.jl` at some point. The test runs on the CPU and GPU. However, similar to the thermal bubble tests, this test fails on the GPU. This PR also adds a file to `sandbox` to aid running and exploring solutions to Rayleigh-Benard and also demonstrates the user-specification of a forcing term.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/239
https://github.com/CliMA/Oceananigans.jl/pull/239:831,Testability,sandbox,sandbox,831,"This PR introduces a new regression test (and renames ""golden master tests"" to ""regression tests"") based on Rayleigh-Benard convection that adds regression tests for `Value` boundary conditions, the forcing implementation and the salinity equation, by using salinity as a passive tracer in the test. The test avoids setting random initial conditions by loading both the initial model state and the comparison state from file. Note that loading the model state from file required writing a new `OutputWriter` that outputs and loads the ""source terms"", `G`. This implementation is included in `test_regression.jl`, but it may be worthwhile to integrate it into `output_writers.jl` at some point. The test runs on the CPU and GPU. However, similar to the thermal bubble tests, this test fails on the GPU. This PR also adds a file to `sandbox` to aid running and exploring solutions to Rayleigh-Benard and also demonstrates the user-specification of a forcing term.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/239
https://github.com/CliMA/Oceananigans.jl/issues/242:286,Energy Efficiency,adapt,adapt,286,"I propose that we adopt a policy that all tests contributed to `Oceananigans` must run on both the CPU and the GPU, because currently the GPU functionality is equal or more important than the CPU functionality. To resolve this issue and implement this policy moving forward, we need to adapt existing tests so that all tests run on the GPU.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/242
https://github.com/CliMA/Oceananigans.jl/issues/242:286,Modifiability,adapt,adapt,286,"I propose that we adopt a policy that all tests contributed to `Oceananigans` must run on both the CPU and the GPU, because currently the GPU functionality is equal or more important than the CPU functionality. To resolve this issue and implement this policy moving forward, we need to adapt existing tests so that all tests run on the GPU.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/242
https://github.com/CliMA/Oceananigans.jl/issues/242:42,Testability,test,tests,42,"I propose that we adopt a policy that all tests contributed to `Oceananigans` must run on both the CPU and the GPU, because currently the GPU functionality is equal or more important than the CPU functionality. To resolve this issue and implement this policy moving forward, we need to adapt existing tests so that all tests run on the GPU.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/242
https://github.com/CliMA/Oceananigans.jl/issues/242:301,Testability,test,tests,301,"I propose that we adopt a policy that all tests contributed to `Oceananigans` must run on both the CPU and the GPU, because currently the GPU functionality is equal or more important than the CPU functionality. To resolve this issue and implement this policy moving forward, we need to adapt existing tests so that all tests run on the GPU.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/242
https://github.com/CliMA/Oceananigans.jl/issues/242:319,Testability,test,tests,319,"I propose that we adopt a policy that all tests contributed to `Oceananigans` must run on both the CPU and the GPU, because currently the GPU functionality is equal or more important than the CPU functionality. To resolve this issue and implement this policy moving forward, we need to adapt existing tests so that all tests run on the GPU.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/242
https://github.com/CliMA/Oceananigans.jl/pull/243:26,Testability,test,test,26,"Thermal bubble regression test now works again. Dumb leftover mistake from #228. Inb4 we should have unified the poisson solvers. Love it when you're off by 10^50:. Before:; ```; [ Info: Δu: min=-3.55764e+54, max=3.55764e+54, mean=-2.0648e+35, absmean=6.04154e+52, std=2.66887e+53; [ Info: Δv: min=-3.55764e+54, max=3.55764e+54, mean=2.57926e+35, absmean=6.04154e+52, std=2.66887e+53; [ Info: Δw: min=-8.03359e+54, max=5.86492e+54, mean=-8.09207e+35, absmean=7.70596e+52, std=3.93725e+53; [ Info: ΔT: min=-9.12137e+52, max=3.63655e+52, mean=1.50945e+34, absmean=3.54008e+50, std=3.58814e+51; [ Info: ΔS: min=-3.2411e+53, max=1.29218e+53, mean=2.84495e+34, absmean=1.2579e+51, std=1.27498e+52; ```. After:; ```; [ Info: Δu: min=-1.20346e-17, max=1.11131e-17, mean=-3.21903e-22, absmean=6.46707e-19, std=1.21175e-18; [ Info: Δv: min=-1.8052e-17, max=1.07099e-17, mean=-3.80102e-22, absmean=6.51696e-19, std=1.25463e-18; [ Info: Δw: min=-3.97428e-17, max=3.5345e-17, mean=4.25729e-21, absmean=3.64351e-18, std=5.66798e-18; [ Info: ΔT: min=-1.77636e-15, max=1.77636e-15, mean=-4.77049e-18, absmean=1.95156e-17, std=1.86152e-16; [ Info: ΔS: min=0, max=0, mean=0, absmean=0, std=0; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/243
https://github.com/CliMA/Oceananigans.jl/pull/244:97,Deployability,update,updates,97,"Right now GitLab CI fails on nightly/dev builds because CUDAapi isn't a package anymore. This PR updates the dependencies/packages in Project.toml to the latest version which should also fix this. There was some mix-up about a month ago that forced us to switch to the master branch of a lot of GPU packages, but things seem fine now. Sticking with GPUifyLoops v0.2.3 because of https://github.com/vchuravy/GPUifyLoops.jl/issues/66. Also removes CUDAapi which isn't a package anymore, and NNlib which was never supposed to be a direct dependency.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/244
https://github.com/CliMA/Oceananigans.jl/pull/244:109,Integrability,depend,dependencies,109,"Right now GitLab CI fails on nightly/dev builds because CUDAapi isn't a package anymore. This PR updates the dependencies/packages in Project.toml to the latest version which should also fix this. There was some mix-up about a month ago that forced us to switch to the master branch of a lot of GPU packages, but things seem fine now. Sticking with GPUifyLoops v0.2.3 because of https://github.com/vchuravy/GPUifyLoops.jl/issues/66. Also removes CUDAapi which isn't a package anymore, and NNlib which was never supposed to be a direct dependency.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/244
https://github.com/CliMA/Oceananigans.jl/pull/244:535,Integrability,depend,dependency,535,"Right now GitLab CI fails on nightly/dev builds because CUDAapi isn't a package anymore. This PR updates the dependencies/packages in Project.toml to the latest version which should also fix this. There was some mix-up about a month ago that forced us to switch to the master branch of a lot of GPU packages, but things seem fine now. Sticking with GPUifyLoops v0.2.3 because of https://github.com/vchuravy/GPUifyLoops.jl/issues/66. Also removes CUDAapi which isn't a package anymore, and NNlib which was never supposed to be a direct dependency.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/244
https://github.com/CliMA/Oceananigans.jl/pull/245:8,Deployability,integrat,integrates,8,"This PR integrates the `TurbulenceClosures` module into time stepping and boundary conditions. The need to abstractly deal with anisotropic transport coefficients for arbitrary boundaries introduces considerable complexity. This problem is solved by exporting `NamedTuples` that collect functions to calculate the diagonal components of viscosity and diffusivity at the necessary locations. The consequence of this implementation is viewed in the `apply_bcs!` function. Only the `ConstantAnisotropicDiffusivity`closure (corresponding to the former default) is currently tested. In the future, we should probably make `ConstantIsotropicDiffusivity` the default, and remove the option to set the horizontal and vertical diffusion tensor components in the `Model` constructor.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/245
https://github.com/CliMA/Oceananigans.jl/pull/245:8,Integrability,integrat,integrates,8,"This PR integrates the `TurbulenceClosures` module into time stepping and boundary conditions. The need to abstractly deal with anisotropic transport coefficients for arbitrary boundaries introduces considerable complexity. This problem is solved by exporting `NamedTuples` that collect functions to calculate the diagonal components of viscosity and diffusivity at the necessary locations. The consequence of this implementation is viewed in the `apply_bcs!` function. Only the `ConstantAnisotropicDiffusivity`closure (corresponding to the former default) is currently tested. In the future, we should probably make `ConstantIsotropicDiffusivity` the default, and remove the option to set the horizontal and vertical diffusion tensor components in the `Model` constructor.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/245
https://github.com/CliMA/Oceananigans.jl/pull/245:570,Testability,test,tested,570,"This PR integrates the `TurbulenceClosures` module into time stepping and boundary conditions. The need to abstractly deal with anisotropic transport coefficients for arbitrary boundaries introduces considerable complexity. This problem is solved by exporting `NamedTuples` that collect functions to calculate the diagonal components of viscosity and diffusivity at the necessary locations. The consequence of this implementation is viewed in the `apply_bcs!` function. Only the `ConstantAnisotropicDiffusivity`closure (corresponding to the former default) is currently tested. In the future, we should probably make `ConstantIsotropicDiffusivity` the default, and remove the option to set the horizontal and vertical diffusion tensor components in the `Model` constructor.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/245
https://github.com/CliMA/Oceananigans.jl/pull/246:156,Testability,test,test,156,Until the CPU and GPU Poisson solvers are unified this should give us confidence that the GPU Poisson solver is doing its job. Found it easier to write the test independently so this supersedes PR #238 . Resolves #200,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/246
https://github.com/CliMA/Oceananigans.jl/issues/248:15,Availability,error,error,15,"I'm getting an error when trying to compile constant Smagorinsky:. ```julia; ERROR: LoadError: InvalidIRError: compiling #12(RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Flo; at64},Base.TwicePrecision{Float64}}}, PlanetaryConstants{Float64}, LinearEquationOfState{Float64}, ConstantSmagorinsky{Fl; oat64}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global; }, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CU; DAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnat; ive.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.C; uDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDevi; ceArray{Float64,3,CUDAnative.AS.Global}, Forcing{typeof(Oceananigans.zero_func),typeof(Oceananigans.zero_func),typeof(Oce; ananigans.zero_func),typeof(Oceananigans.zero_func),typeof(Oceananigans.zero_func)}) resulted in invalid LLVM IR; Reason: unsupported call to the Julia runtime (call to jl_f__apply); Stacktrace:; [1] overdub at /data5/glwagner/.julia/packages/Cassette/xggAf/src/context.jl:260; [2] ν_ccc at /data5/glwagner/Projects/Oceananigans.jl/src/closures/constant_smagorinsky.jl:109; [3] ν_Σᵢⱼ at /data5/glwagner/Projects/Oceananigans.jl/src/closures/closure_operators.jl:405; [4] ∂x_faa at /data5/glwagner/Projects/Oceananigans.jl/src/closures/closure_operators.jl:64; [5] ∂x_2ν_Σ₁₁ at /data5/glwagner/Projects/Oceananigans.jl/src/closures/closure_operators.jl:409; [6] ∂ⱼ_2ν_Σ₁ⱼ at /data5/glwagner/Projects/Oceananigans.jl/src/closures/closure_operators.jl:432; [7] calculate_interior_source_terms! at /data5/glwagner/Projects/Oceananigans.jl/src/time_steppers.jl:152; [8] #12 at /data5/glwagner/.julia/packages/GPUifyLoops/hBRid/src/context.jl:136",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/248
https://github.com/CliMA/Oceananigans.jl/issues/248:77,Availability,ERROR,ERROR,77,"I'm getting an error when trying to compile constant Smagorinsky:. ```julia; ERROR: LoadError: InvalidIRError: compiling #12(RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Flo; at64},Base.TwicePrecision{Float64}}}, PlanetaryConstants{Float64}, LinearEquationOfState{Float64}, ConstantSmagorinsky{Fl; oat64}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global; }, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CU; DAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnat; ive.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.C; uDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDevi; ceArray{Float64,3,CUDAnative.AS.Global}, Forcing{typeof(Oceananigans.zero_func),typeof(Oceananigans.zero_func),typeof(Oce; ananigans.zero_func),typeof(Oceananigans.zero_func),typeof(Oceananigans.zero_func)}) resulted in invalid LLVM IR; Reason: unsupported call to the Julia runtime (call to jl_f__apply); Stacktrace:; [1] overdub at /data5/glwagner/.julia/packages/Cassette/xggAf/src/context.jl:260; [2] ν_ccc at /data5/glwagner/Projects/Oceananigans.jl/src/closures/constant_smagorinsky.jl:109; [3] ν_Σᵢⱼ at /data5/glwagner/Projects/Oceananigans.jl/src/closures/closure_operators.jl:405; [4] ∂x_faa at /data5/glwagner/Projects/Oceananigans.jl/src/closures/closure_operators.jl:64; [5] ∂x_2ν_Σ₁₁ at /data5/glwagner/Projects/Oceananigans.jl/src/closures/closure_operators.jl:409; [6] ∂ⱼ_2ν_Σ₁ⱼ at /data5/glwagner/Projects/Oceananigans.jl/src/closures/closure_operators.jl:432; [7] calculate_interior_source_terms! at /data5/glwagner/Projects/Oceananigans.jl/src/time_steppers.jl:152; [8] #12 at /data5/glwagner/.julia/packages/GPUifyLoops/hBRid/src/context.jl:136",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/248
https://github.com/CliMA/Oceananigans.jl/issues/248:2150,Availability,error,error,2150,"ative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CU; DAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnat; ive.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.C; uDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDevi; ceArray{Float64,3,CUDAnative.AS.Global}, Forcing{typeof(Oceananigans.zero_func),typeof(Oceananigans.zero_func),typeof(Oce; ananigans.zero_func),typeof(Oceananigans.zero_func),typeof(Oceananigans.zero_func)}) resulted in invalid LLVM IR; Reason: unsupported call to the Julia runtime (call to jl_f__apply); Stacktrace:; [1] overdub at /data5/glwagner/.julia/packages/Cassette/xggAf/src/context.jl:260; [2] ν_ccc at /data5/glwagner/Projects/Oceananigans.jl/src/closures/constant_smagorinsky.jl:109; [3] ν_Σᵢⱼ at /data5/glwagner/Projects/Oceananigans.jl/src/closures/closure_operators.jl:405; [4] ∂x_faa at /data5/glwagner/Projects/Oceananigans.jl/src/closures/closure_operators.jl:64; [5] ∂x_2ν_Σ₁₁ at /data5/glwagner/Projects/Oceananigans.jl/src/closures/closure_operators.jl:409; [6] ∂ⱼ_2ν_Σ₁ⱼ at /data5/glwagner/Projects/Oceananigans.jl/src/closures/closure_operators.jl:432; [7] calculate_interior_source_terms! at /data5/glwagner/Projects/Oceananigans.jl/src/time_steppers.jl:152; [8] #12 at /data5/glwagner/.julia/packages/GPUifyLoops/hBRid/src/context.jl:136; Reason: unsupported dynamic function invocation (call to Cassette.overdub); ```. I think this is specific to the package upgrades. I also got this error when running the `rayleigh_benard_passive_tracer.jl` script (associated with the function that forces salinity). Mysteriously, it does not throw this error when it runs the tests. Not sure where to raise an issue (if this is an issue)... _Originally posted by @glwagner in https://github.com/climate-machine/Oceananigans.jl/pull/245#issuecomment-496472606_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/248
https://github.com/CliMA/Oceananigans.jl/issues/248:2306,Availability,error,error,2306,"ative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CU; DAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnat; ive.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.C; uDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDevi; ceArray{Float64,3,CUDAnative.AS.Global}, Forcing{typeof(Oceananigans.zero_func),typeof(Oceananigans.zero_func),typeof(Oce; ananigans.zero_func),typeof(Oceananigans.zero_func),typeof(Oceananigans.zero_func)}) resulted in invalid LLVM IR; Reason: unsupported call to the Julia runtime (call to jl_f__apply); Stacktrace:; [1] overdub at /data5/glwagner/.julia/packages/Cassette/xggAf/src/context.jl:260; [2] ν_ccc at /data5/glwagner/Projects/Oceananigans.jl/src/closures/constant_smagorinsky.jl:109; [3] ν_Σᵢⱼ at /data5/glwagner/Projects/Oceananigans.jl/src/closures/closure_operators.jl:405; [4] ∂x_faa at /data5/glwagner/Projects/Oceananigans.jl/src/closures/closure_operators.jl:64; [5] ∂x_2ν_Σ₁₁ at /data5/glwagner/Projects/Oceananigans.jl/src/closures/closure_operators.jl:409; [6] ∂ⱼ_2ν_Σ₁ⱼ at /data5/glwagner/Projects/Oceananigans.jl/src/closures/closure_operators.jl:432; [7] calculate_interior_source_terms! at /data5/glwagner/Projects/Oceananigans.jl/src/time_steppers.jl:152; [8] #12 at /data5/glwagner/.julia/packages/GPUifyLoops/hBRid/src/context.jl:136; Reason: unsupported dynamic function invocation (call to Cassette.overdub); ```. I think this is specific to the package upgrades. I also got this error when running the `rayleigh_benard_passive_tracer.jl` script (associated with the function that forces salinity). Mysteriously, it does not throw this error when it runs the tests. Not sure where to raise an issue (if this is an issue)... _Originally posted by @glwagner in https://github.com/climate-machine/Oceananigans.jl/pull/245#issuecomment-496472606_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/248
https://github.com/CliMA/Oceananigans.jl/issues/248:2124,Deployability,upgrade,upgrades,2124,"ative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CU; DAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnat; ive.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.C; uDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDevi; ceArray{Float64,3,CUDAnative.AS.Global}, Forcing{typeof(Oceananigans.zero_func),typeof(Oceananigans.zero_func),typeof(Oce; ananigans.zero_func),typeof(Oceananigans.zero_func),typeof(Oceananigans.zero_func)}) resulted in invalid LLVM IR; Reason: unsupported call to the Julia runtime (call to jl_f__apply); Stacktrace:; [1] overdub at /data5/glwagner/.julia/packages/Cassette/xggAf/src/context.jl:260; [2] ν_ccc at /data5/glwagner/Projects/Oceananigans.jl/src/closures/constant_smagorinsky.jl:109; [3] ν_Σᵢⱼ at /data5/glwagner/Projects/Oceananigans.jl/src/closures/closure_operators.jl:405; [4] ∂x_faa at /data5/glwagner/Projects/Oceananigans.jl/src/closures/closure_operators.jl:64; [5] ∂x_2ν_Σ₁₁ at /data5/glwagner/Projects/Oceananigans.jl/src/closures/closure_operators.jl:409; [6] ∂ⱼ_2ν_Σ₁ⱼ at /data5/glwagner/Projects/Oceananigans.jl/src/closures/closure_operators.jl:432; [7] calculate_interior_source_terms! at /data5/glwagner/Projects/Oceananigans.jl/src/time_steppers.jl:152; [8] #12 at /data5/glwagner/.julia/packages/GPUifyLoops/hBRid/src/context.jl:136; Reason: unsupported dynamic function invocation (call to Cassette.overdub); ```. I think this is specific to the package upgrades. I also got this error when running the `rayleigh_benard_passive_tracer.jl` script (associated with the function that forces salinity). Mysteriously, it does not throw this error when it runs the tests. Not sure where to raise an issue (if this is an issue)... _Originally posted by @glwagner in https://github.com/climate-machine/Oceananigans.jl/pull/245#issuecomment-496472606_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/248
https://github.com/CliMA/Oceananigans.jl/issues/248:84,Performance,Load,LoadError,84,"I'm getting an error when trying to compile constant Smagorinsky:. ```julia; ERROR: LoadError: InvalidIRError: compiling #12(RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Flo; at64},Base.TwicePrecision{Float64}}}, PlanetaryConstants{Float64}, LinearEquationOfState{Float64}, ConstantSmagorinsky{Fl; oat64}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global; }, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CU; DAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnat; ive.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.C; uDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDevi; ceArray{Float64,3,CUDAnative.AS.Global}, Forcing{typeof(Oceananigans.zero_func),typeof(Oceananigans.zero_func),typeof(Oce; ananigans.zero_func),typeof(Oceananigans.zero_func),typeof(Oceananigans.zero_func)}) resulted in invalid LLVM IR; Reason: unsupported call to the Julia runtime (call to jl_f__apply); Stacktrace:; [1] overdub at /data5/glwagner/.julia/packages/Cassette/xggAf/src/context.jl:260; [2] ν_ccc at /data5/glwagner/Projects/Oceananigans.jl/src/closures/constant_smagorinsky.jl:109; [3] ν_Σᵢⱼ at /data5/glwagner/Projects/Oceananigans.jl/src/closures/closure_operators.jl:405; [4] ∂x_faa at /data5/glwagner/Projects/Oceananigans.jl/src/closures/closure_operators.jl:64; [5] ∂x_2ν_Σ₁₁ at /data5/glwagner/Projects/Oceananigans.jl/src/closures/closure_operators.jl:409; [6] ∂ⱼ_2ν_Σ₁ⱼ at /data5/glwagner/Projects/Oceananigans.jl/src/closures/closure_operators.jl:432; [7] calculate_interior_source_terms! at /data5/glwagner/Projects/Oceananigans.jl/src/time_steppers.jl:152; [8] #12 at /data5/glwagner/.julia/packages/GPUifyLoops/hBRid/src/context.jl:136",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/248
https://github.com/CliMA/Oceananigans.jl/issues/248:2329,Testability,test,tests,2329,"ative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CU; DAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnat; ive.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.C; uDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDevi; ceArray{Float64,3,CUDAnative.AS.Global}, Forcing{typeof(Oceananigans.zero_func),typeof(Oceananigans.zero_func),typeof(Oce; ananigans.zero_func),typeof(Oceananigans.zero_func),typeof(Oceananigans.zero_func)}) resulted in invalid LLVM IR; Reason: unsupported call to the Julia runtime (call to jl_f__apply); Stacktrace:; [1] overdub at /data5/glwagner/.julia/packages/Cassette/xggAf/src/context.jl:260; [2] ν_ccc at /data5/glwagner/Projects/Oceananigans.jl/src/closures/constant_smagorinsky.jl:109; [3] ν_Σᵢⱼ at /data5/glwagner/Projects/Oceananigans.jl/src/closures/closure_operators.jl:405; [4] ∂x_faa at /data5/glwagner/Projects/Oceananigans.jl/src/closures/closure_operators.jl:64; [5] ∂x_2ν_Σ₁₁ at /data5/glwagner/Projects/Oceananigans.jl/src/closures/closure_operators.jl:409; [6] ∂ⱼ_2ν_Σ₁ⱼ at /data5/glwagner/Projects/Oceananigans.jl/src/closures/closure_operators.jl:432; [7] calculate_interior_source_terms! at /data5/glwagner/Projects/Oceananigans.jl/src/time_steppers.jl:152; [8] #12 at /data5/glwagner/.julia/packages/GPUifyLoops/hBRid/src/context.jl:136; Reason: unsupported dynamic function invocation (call to Cassette.overdub); ```. I think this is specific to the package upgrades. I also got this error when running the `rayleigh_benard_passive_tracer.jl` script (associated with the function that forces salinity). Mysteriously, it does not throw this error when it runs the tests. Not sure where to raise an issue (if this is an issue)... _Originally posted by @glwagner in https://github.com/climate-machine/Oceananigans.jl/pull/245#issuecomment-496472606_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/248
https://github.com/CliMA/Oceananigans.jl/pull/250:695,Availability,down,down,695,"This PR is part 1 of _n_ implementing halo regions (originally PR #167). Here I just replace Arrays and CuArrays with OffsetArrays containing an Array or CuArray. . An important change is the introduction of the `data(::Field)` function which returns the data stored by the field, i.e. without halo data. Lots of refactoring had to happen but it was mostly in updating the tests to use the `data` function. The Poisson solver had to be refactored because FFTW and cuFFT won't work properly on an offset array containing halos. The Poisson solver now keeps track of the right-hand-side, Fourier coefficients, and solution using `solver.storage` which is a regular `Array` or `CuArray`. This cuts down memory usage as well. Works on #104. Resolves #45; Resolves #122; Resolves #177",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/250
https://github.com/CliMA/Oceananigans.jl/pull/250:313,Modifiability,refactor,refactoring,313,"This PR is part 1 of _n_ implementing halo regions (originally PR #167). Here I just replace Arrays and CuArrays with OffsetArrays containing an Array or CuArray. . An important change is the introduction of the `data(::Field)` function which returns the data stored by the field, i.e. without halo data. Lots of refactoring had to happen but it was mostly in updating the tests to use the `data` function. The Poisson solver had to be refactored because FFTW and cuFFT won't work properly on an offset array containing halos. The Poisson solver now keeps track of the right-hand-side, Fourier coefficients, and solution using `solver.storage` which is a regular `Array` or `CuArray`. This cuts down memory usage as well. Works on #104. Resolves #45; Resolves #122; Resolves #177",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/250
https://github.com/CliMA/Oceananigans.jl/pull/250:436,Modifiability,refactor,refactored,436,"This PR is part 1 of _n_ implementing halo regions (originally PR #167). Here I just replace Arrays and CuArrays with OffsetArrays containing an Array or CuArray. . An important change is the introduction of the `data(::Field)` function which returns the data stored by the field, i.e. without halo data. Lots of refactoring had to happen but it was mostly in updating the tests to use the `data` function. The Poisson solver had to be refactored because FFTW and cuFFT won't work properly on an offset array containing halos. The Poisson solver now keeps track of the right-hand-side, Fourier coefficients, and solution using `solver.storage` which is a regular `Array` or `CuArray`. This cuts down memory usage as well. Works on #104. Resolves #45; Resolves #122; Resolves #177",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/250
https://github.com/CliMA/Oceananigans.jl/pull/250:373,Testability,test,tests,373,"This PR is part 1 of _n_ implementing halo regions (originally PR #167). Here I just replace Arrays and CuArrays with OffsetArrays containing an Array or CuArray. . An important change is the introduction of the `data(::Field)` function which returns the data stored by the field, i.e. without halo data. Lots of refactoring had to happen but it was mostly in updating the tests to use the `data` function. The Poisson solver had to be refactored because FFTW and cuFFT won't work properly on an offset array containing halos. The Poisson solver now keeps track of the right-hand-side, Fourier coefficients, and solution using `solver.storage` which is a regular `Array` or `CuArray`. This cuts down memory usage as well. Works on #104. Resolves #45; Resolves #122; Resolves #177",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/250
https://github.com/CliMA/Oceananigans.jl/issues/251:249,Performance,optimiz,optimize,249,"Using `Cthulhu` by running the commands. ```julia; using Oceananigans, Cthulhu. model = Model(N=(32, 32, 32), L=(1, 1, 1)) . @descend time_step!(model, 1, 1); ```. and descending into the call to `store_previous_source_terms!` (I did this using the optimize flag and scrolling to invocation `%206`, then using the warn_type flag), reveals (I think) that for some reason julia cannot infer the types of arguments into any of the kernels. For example, the `Cthulhu` output from that exercise yields. ```; @ /Users/gregorywagner/Projects/Oceananigans.jl/src/time_steppers.jl:122 within `store_previous_source_terms!'; 15 ┄ %74 = (GPUifyLoops.isdevice)()::Core.Compiler.Const(false, false); │ %75 = !%74::Core.Compiler.Const(true, true); │ %75; │ %77 = (Base.getproperty)(grid, :Nx)::Any; ```. The type of `grid` is not inferred, and neither is the type of `grid.Nx`. None of the types of the arguments are inferred. I can fix this problem by explicitly typing all of the arguments except for the floating point type. However, I cannot fix the problem even if I specify that most of the arguments are `AbstractArray`. Is this causing performance problems? Is this the source of memory allocation during time-stepping?. @vchuravy @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/251
https://github.com/CliMA/Oceananigans.jl/issues/251:1130,Performance,perform,performance,1130,"Using `Cthulhu` by running the commands. ```julia; using Oceananigans, Cthulhu. model = Model(N=(32, 32, 32), L=(1, 1, 1)) . @descend time_step!(model, 1, 1); ```. and descending into the call to `store_previous_source_terms!` (I did this using the optimize flag and scrolling to invocation `%206`, then using the warn_type flag), reveals (I think) that for some reason julia cannot infer the types of arguments into any of the kernels. For example, the `Cthulhu` output from that exercise yields. ```; @ /Users/gregorywagner/Projects/Oceananigans.jl/src/time_steppers.jl:122 within `store_previous_source_terms!'; 15 ┄ %74 = (GPUifyLoops.isdevice)()::Core.Compiler.Const(false, false); │ %75 = !%74::Core.Compiler.Const(true, true); │ %75; │ %77 = (Base.getproperty)(grid, :Nx)::Any; ```. The type of `grid` is not inferred, and neither is the type of `grid.Nx`. None of the types of the arguments are inferred. I can fix this problem by explicitly typing all of the arguments except for the floating point type. However, I cannot fix the problem even if I specify that most of the arguments are `AbstractArray`. Is this causing performance problems? Is this the source of memory allocation during time-stepping?. @vchuravy @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/251
https://github.com/CliMA/Oceananigans.jl/pull/253:129,Deployability,integrat,integrate,129,"This PR is part 2 of n implementing halo regions (originally PR #167). n = 2 probably. Here I actually start using the halos and integrate them with the code. This involves filling in the halo regions as needed to enforce the periodic boundary conditions. I also rewrite the operators to use `i-1` and `i+1` instead of `decmod1` and `incmod1`. Hopefully this will speed things up a bit, especially on the GPU. I will release v0.6 once this is merged. Resolves #104",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/253
https://github.com/CliMA/Oceananigans.jl/pull/253:417,Deployability,release,release,417,"This PR is part 2 of n implementing halo regions (originally PR #167). n = 2 probably. Here I actually start using the halos and integrate them with the code. This involves filling in the halo regions as needed to enforce the periodic boundary conditions. I also rewrite the operators to use `i-1` and `i+1` instead of `decmod1` and `incmod1`. Hopefully this will speed things up a bit, especially on the GPU. I will release v0.6 once this is merged. Resolves #104",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/253
https://github.com/CliMA/Oceananigans.jl/pull/253:129,Integrability,integrat,integrate,129,"This PR is part 2 of n implementing halo regions (originally PR #167). n = 2 probably. Here I actually start using the halos and integrate them with the code. This involves filling in the halo regions as needed to enforce the periodic boundary conditions. I also rewrite the operators to use `i-1` and `i+1` instead of `decmod1` and `incmod1`. Hopefully this will speed things up a bit, especially on the GPU. I will release v0.6 once this is merged. Resolves #104",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/253
https://github.com/CliMA/Oceananigans.jl/pull/253:263,Modifiability,rewrite,rewrite,263,"This PR is part 2 of n implementing halo regions (originally PR #167). n = 2 probably. Here I actually start using the halos and integrate them with the code. This involves filling in the halo regions as needed to enforce the periodic boundary conditions. I also rewrite the operators to use `i-1` and `i+1` instead of `decmod1` and `incmod1`. Hopefully this will speed things up a bit, especially on the GPU. I will release v0.6 once this is merged. Resolves #104",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/253
https://github.com/CliMA/Oceananigans.jl/issues/254:382,Availability,ERROR,ERROR,382,"Am I doing something wrong?; ```julia; navid:Oceananigans.jl/ (master) $ julia --project [19:00:13]; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.1.0 (2019-01-21); _/ |\__'_|_|_|\__'_| |; |__/ |. julia> include(""examples/internal_wave.jl""); ERROR: LoadError: could not open file /Users/navid/Research/Oceananigans.jl/examples/utils.jl; ...; ```. I guess the problem is the `include(""utils.jl"")` line found in all example .jl scripts. Is this supposed to be `src/utils.jl`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/254
https://github.com/CliMA/Oceananigans.jl/issues/254:389,Performance,Load,LoadError,389,"Am I doing something wrong?; ```julia; navid:Oceananigans.jl/ (master) $ julia --project [19:00:13]; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.1.0 (2019-01-21); _/ |\__'_|_|_|\__'_| |; |__/ |. julia> include(""examples/internal_wave.jl""); ERROR: LoadError: could not open file /Users/navid/Research/Oceananigans.jl/examples/utils.jl; ...; ```. I guess the problem is the `include(""utils.jl"")` line found in all example .jl scripts. Is this supposed to be `src/utils.jl`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/254
https://github.com/CliMA/Oceananigans.jl/pull/257:8,Deployability,update,updates,8,"This PR updates the examples to account for the fact that `field.data` returns the full offset array including all halos so you need to use `data(field)` which returns a view into the interior of the field with no halos. cc @navidcy internal wave example works for me now. Can you try on this branch?. In hindsight, maybe a more sophisticated fields API would avoid issues like this where we're so reliant on the `data(::Field)` function. Maybe things should ""just work"" for the user. Resolves #254",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/257
https://github.com/CliMA/Oceananigans.jl/pull/257:360,Safety,avoid,avoid,360,"This PR updates the examples to account for the fact that `field.data` returns the full offset array including all halos so you need to use `data(field)` which returns a view into the interior of the field with no halos. cc @navidcy internal wave example works for me now. Can you try on this branch?. In hindsight, maybe a more sophisticated fields API would avoid issues like this where we're so reliant on the `data(::Field)` function. Maybe things should ""just work"" for the user. Resolves #254",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/257
https://github.com/CliMA/Oceananigans.jl/issues/258:171,Security,expose,exposes,171,"As a convenience, we can provide constructors for different use cases. For example, we can have an `OceanModel`, which has `ConstantAnisotropicDiffusivity` as default and exposes the anisotropic coefficients directly to the user. This deals with @johncmarshall54's concern about the `ConstantIsotropicDiffusivity` default. This will also help us move some of the body of the `Model` constructor into re-useable functions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/258
https://github.com/CliMA/Oceananigans.jl/issues/259:1329,Availability,down,down,1329," I think we should require that. 1. The memory footprint of our model is no larger than it needs to be for a given problem (no 'extra' allocation of memory for unused tracers, for hydrostatic pressure when running in non hydrostatic mode, etc). 2. We do not perform unnecessary floating-point computations or indexing into arrays (the latter is especially important in GPU code) for unused tracers or hydrostatic pressure fields. 3. Equations are constructed / specified clearly and concisely (both in source code and user scripts). 4. Users can specify arbitrary types of forcing, including numbers, arrays, or functions (solving #110). 5. We can support arbitrary tracers with various features, such as sinking/rising velocities, or reaction systems for biological/chemical tracer systems. When I have talked to various people about this, there was a concern that this system would be 'inelegant' or 'complex'. However I believe an equation abstraction system provides the opposite: with an abstraction system, equations are 'written down' in some logical place (like a file `equations.jl` in the `src` directory where they can be easily read and modified, rather than buried inside a time-stepping loop. Correspondly, our time-stepping code becomes shorter and more concise. Using multiple dispatch correctly, we avoid the `infinite if-statement` problem. This abstraction may also make the code more modular such that we move closer to supporting multiple time-steppers. Below I provide one example of an implementation that would solve some of the problems I listed. However, *this is not the only solution*, and I think we should expend some intellectual effort and have a discussion about what the best solution might be, so that we design something that is nice, easy to extend, performant, and powerful. ## A list of kernel equations in a named tuple. The simplest solution for this abstraction is probably just to add new fields to `Model` (`model.equations.velocities` and `model.equations",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/259
https://github.com/CliMA/Oceananigans.jl/issues/259:2096,Energy Efficiency,power,powerful,2096,"ures, such as sinking/rising velocities, or reaction systems for biological/chemical tracer systems. When I have talked to various people about this, there was a concern that this system would be 'inelegant' or 'complex'. However I believe an equation abstraction system provides the opposite: with an abstraction system, equations are 'written down' in some logical place (like a file `equations.jl` in the `src` directory where they can be easily read and modified, rather than buried inside a time-stepping loop. Correspondly, our time-stepping code becomes shorter and more concise. Using multiple dispatch correctly, we avoid the `infinite if-statement` problem. This abstraction may also make the code more modular such that we move closer to supporting multiple time-steppers. Below I provide one example of an implementation that would solve some of the problems I listed. However, *this is not the only solution*, and I think we should expend some intellectual effort and have a discussion about what the best solution might be, so that we design something that is nice, easy to extend, performant, and powerful. ## A list of kernel equations in a named tuple. The simplest solution for this abstraction is probably just to add new fields to `Model` (`model.equations.velocities` and `model.equations.tracers`) that are named tuples of kernel equations. An example of how this might work while demonstrating hierarchical multiple dispatch is:. ```julia; forcing(i, j, k, grid, F::Function, u, v, w, T, S) = F(grid, u, v, w, T, S, i, j, k); forcing(i, j, k, grid, F::AbstractArray, u, v, w, T, S) = F[i, j, k]. u_eqn(i, j, k, grid, etc...) = (-u∇u(grid, u, v, w, i, j, k); + fv(grid, v, fCor, i, j, k); - δx_c2f(grid, pHY′, i, j, k) / (Δx * ρ₀); + ∂ⱼ_2ν_Σ₁ⱼ(i, j, k, grid, closure, eos, grav, u, v, w, T, S); + forcing(i, j, k, grid, F, u, v, w, T, S); ). # Note omission of pressure term here; u_eqn(i, j, k, grid, pHY::Nothing, etc...) = (-u∇u(grid, u, v, w, i, j, k); + fv(grid, v, fCor, i,",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/259
https://github.com/CliMA/Oceananigans.jl/issues/259:2072,Modifiability,extend,extend,2072,"ures, such as sinking/rising velocities, or reaction systems for biological/chemical tracer systems. When I have talked to various people about this, there was a concern that this system would be 'inelegant' or 'complex'. However I believe an equation abstraction system provides the opposite: with an abstraction system, equations are 'written down' in some logical place (like a file `equations.jl` in the `src` directory where they can be easily read and modified, rather than buried inside a time-stepping loop. Correspondly, our time-stepping code becomes shorter and more concise. Using multiple dispatch correctly, we avoid the `infinite if-statement` problem. This abstraction may also make the code more modular such that we move closer to supporting multiple time-steppers. Below I provide one example of an implementation that would solve some of the problems I listed. However, *this is not the only solution*, and I think we should expend some intellectual effort and have a discussion about what the best solution might be, so that we design something that is nice, easy to extend, performant, and powerful. ## A list of kernel equations in a named tuple. The simplest solution for this abstraction is probably just to add new fields to `Model` (`model.equations.velocities` and `model.equations.tracers`) that are named tuples of kernel equations. An example of how this might work while demonstrating hierarchical multiple dispatch is:. ```julia; forcing(i, j, k, grid, F::Function, u, v, w, T, S) = F(grid, u, v, w, T, S, i, j, k); forcing(i, j, k, grid, F::AbstractArray, u, v, w, T, S) = F[i, j, k]. u_eqn(i, j, k, grid, etc...) = (-u∇u(grid, u, v, w, i, j, k); + fv(grid, v, fCor, i, j, k); - δx_c2f(grid, pHY′, i, j, k) / (Δx * ρ₀); + ∂ⱼ_2ν_Σ₁ⱼ(i, j, k, grid, closure, eos, grav, u, v, w, T, S); + forcing(i, j, k, grid, F, u, v, w, T, S); ). # Note omission of pressure term here; u_eqn(i, j, k, grid, pHY::Nothing, etc...) = (-u∇u(grid, u, v, w, i, j, k); + fv(grid, v, fCor, i,",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/259
https://github.com/CliMA/Oceananigans.jl/issues/259:220,Performance,perform,performant,220,"I'm thinking about the future and hoping to start a discussion about the future of our equation abstraction system. ## The problem. We need an abstraction for the concept of an equation, so that we can make the model as performant and lightweight as possible for a given use case. For example, I think we should require that. 1. The memory footprint of our model is no larger than it needs to be for a given problem (no 'extra' allocation of memory for unused tracers, for hydrostatic pressure when running in non hydrostatic mode, etc). 2. We do not perform unnecessary floating-point computations or indexing into arrays (the latter is especially important in GPU code) for unused tracers or hydrostatic pressure fields. 3. Equations are constructed / specified clearly and concisely (both in source code and user scripts). 4. Users can specify arbitrary types of forcing, including numbers, arrays, or functions (solving #110). 5. We can support arbitrary tracers with various features, such as sinking/rising velocities, or reaction systems for biological/chemical tracer systems. When I have talked to various people about this, there was a concern that this system would be 'inelegant' or 'complex'. However I believe an equation abstraction system provides the opposite: with an abstraction system, equations are 'written down' in some logical place (like a file `equations.jl` in the `src` directory where they can be easily read and modified, rather than buried inside a time-stepping loop. Correspondly, our time-stepping code becomes shorter and more concise. Using multiple dispatch correctly, we avoid the `infinite if-statement` problem. This abstraction may also make the code more modular such that we move closer to supporting multiple time-steppers. Below I provide one example of an implementation that would solve some of the problems I listed. However, *this is not the only solution*, and I think we should expend some intellectual effort and have a discussion about what the bes",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/259
https://github.com/CliMA/Oceananigans.jl/issues/259:551,Performance,perform,perform,551,"I'm thinking about the future and hoping to start a discussion about the future of our equation abstraction system. ## The problem. We need an abstraction for the concept of an equation, so that we can make the model as performant and lightweight as possible for a given use case. For example, I think we should require that. 1. The memory footprint of our model is no larger than it needs to be for a given problem (no 'extra' allocation of memory for unused tracers, for hydrostatic pressure when running in non hydrostatic mode, etc). 2. We do not perform unnecessary floating-point computations or indexing into arrays (the latter is especially important in GPU code) for unused tracers or hydrostatic pressure fields. 3. Equations are constructed / specified clearly and concisely (both in source code and user scripts). 4. Users can specify arbitrary types of forcing, including numbers, arrays, or functions (solving #110). 5. We can support arbitrary tracers with various features, such as sinking/rising velocities, or reaction systems for biological/chemical tracer systems. When I have talked to various people about this, there was a concern that this system would be 'inelegant' or 'complex'. However I believe an equation abstraction system provides the opposite: with an abstraction system, equations are 'written down' in some logical place (like a file `equations.jl` in the `src` directory where they can be easily read and modified, rather than buried inside a time-stepping loop. Correspondly, our time-stepping code becomes shorter and more concise. Using multiple dispatch correctly, we avoid the `infinite if-statement` problem. This abstraction may also make the code more modular such that we move closer to supporting multiple time-steppers. Below I provide one example of an implementation that would solve some of the problems I listed. However, *this is not the only solution*, and I think we should expend some intellectual effort and have a discussion about what the bes",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/259
https://github.com/CliMA/Oceananigans.jl/issues/259:2080,Performance,perform,performant,2080,"ures, such as sinking/rising velocities, or reaction systems for biological/chemical tracer systems. When I have talked to various people about this, there was a concern that this system would be 'inelegant' or 'complex'. However I believe an equation abstraction system provides the opposite: with an abstraction system, equations are 'written down' in some logical place (like a file `equations.jl` in the `src` directory where they can be easily read and modified, rather than buried inside a time-stepping loop. Correspondly, our time-stepping code becomes shorter and more concise. Using multiple dispatch correctly, we avoid the `infinite if-statement` problem. This abstraction may also make the code more modular such that we move closer to supporting multiple time-steppers. Below I provide one example of an implementation that would solve some of the problems I listed. However, *this is not the only solution*, and I think we should expend some intellectual effort and have a discussion about what the best solution might be, so that we design something that is nice, easy to extend, performant, and powerful. ## A list of kernel equations in a named tuple. The simplest solution for this abstraction is probably just to add new fields to `Model` (`model.equations.velocities` and `model.equations.tracers`) that are named tuples of kernel equations. An example of how this might work while demonstrating hierarchical multiple dispatch is:. ```julia; forcing(i, j, k, grid, F::Function, u, v, w, T, S) = F(grid, u, v, w, T, S, i, j, k); forcing(i, j, k, grid, F::AbstractArray, u, v, w, T, S) = F[i, j, k]. u_eqn(i, j, k, grid, etc...) = (-u∇u(grid, u, v, w, i, j, k); + fv(grid, v, fCor, i, j, k); - δx_c2f(grid, pHY′, i, j, k) / (Δx * ρ₀); + ∂ⱼ_2ν_Σ₁ⱼ(i, j, k, grid, closure, eos, grav, u, v, w, T, S); + forcing(i, j, k, grid, F, u, v, w, T, S); ). # Note omission of pressure term here; u_eqn(i, j, k, grid, pHY::Nothing, etc...) = (-u∇u(grid, u, v, w, i, j, k); + fv(grid, v, fCor, i,",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/259
https://github.com/CliMA/Oceananigans.jl/issues/259:1609,Safety,avoid,avoid,1609," into arrays (the latter is especially important in GPU code) for unused tracers or hydrostatic pressure fields. 3. Equations are constructed / specified clearly and concisely (both in source code and user scripts). 4. Users can specify arbitrary types of forcing, including numbers, arrays, or functions (solving #110). 5. We can support arbitrary tracers with various features, such as sinking/rising velocities, or reaction systems for biological/chemical tracer systems. When I have talked to various people about this, there was a concern that this system would be 'inelegant' or 'complex'. However I believe an equation abstraction system provides the opposite: with an abstraction system, equations are 'written down' in some logical place (like a file `equations.jl` in the `src` directory where they can be easily read and modified, rather than buried inside a time-stepping loop. Correspondly, our time-stepping code becomes shorter and more concise. Using multiple dispatch correctly, we avoid the `infinite if-statement` problem. This abstraction may also make the code more modular such that we move closer to supporting multiple time-steppers. Below I provide one example of an implementation that would solve some of the problems I listed. However, *this is not the only solution*, and I think we should expend some intellectual effort and have a discussion about what the best solution might be, so that we design something that is nice, easy to extend, performant, and powerful. ## A list of kernel equations in a named tuple. The simplest solution for this abstraction is probably just to add new fields to `Model` (`model.equations.velocities` and `model.equations.tracers`) that are named tuples of kernel equations. An example of how this might work while demonstrating hierarchical multiple dispatch is:. ```julia; forcing(i, j, k, grid, F::Function, u, v, w, T, S) = F(grid, u, v, w, T, S, i, j, k); forcing(i, j, k, grid, F::AbstractArray, u, v, w, T, S) = F[i, j, k]. u_eqn(i,",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/259
https://github.com/CliMA/Oceananigans.jl/issues/259:4067,Safety,avoid,avoid,4067,"rcing(i, j, k, grid, F::AbstractArray, u, v, w, T, S) = F[i, j, k]. u_eqn(i, j, k, grid, etc...) = (-u∇u(grid, u, v, w, i, j, k); + fv(grid, v, fCor, i, j, k); - δx_c2f(grid, pHY′, i, j, k) / (Δx * ρ₀); + ∂ⱼ_2ν_Σ₁ⱼ(i, j, k, grid, closure, eos, grav, u, v, w, T, S); + forcing(i, j, k, grid, F, u, v, w, T, S); ). # Note omission of pressure term here; u_eqn(i, j, k, grid, pHY::Nothing, etc...) = (-u∇u(grid, u, v, w, i, j, k); + fv(grid, v, fCor, i, j, k); + ∂ⱼ_2ν_Σ₁ⱼ(i, j, k, grid, closure, eos, grav, u, v, w, T, S); + forcing(i, j, k, grid, F, u, v, w T, S); ). linear_u_eqn(i, j, k, grid, etc....) = (fv(grid, v, fCor, i, j, k); - δx_c2f(grid, pHY′, i, j, k) / (Δx * ρ₀); + ∂ⱼ_2ν_Σ₁ⱼ(i, j, k, grid, closure, eos, grav, u, v, w, T, S); + forcing(i, j, k, grid, F, u, v, w T, S); ). v_eqn(...) = ... # in the model constructor:. if eqntype = :linear; velocities_equation = (u=linear_u_eqn, v=linear_v_eqn, w=linear_w_eqn); else; velocities_equation = (u=u_eqn, v=v_eqn, w=w_eqn); end. model.equation = (velocities=velocities_equation, tracers=...). # Inside calculate_interior_source_terms!. G.u[i, j, k] = eqn.velocities.u(i, j, k, grid, etc...). ntuple(Val(length(tracers))) do tr; Gtracer = getfield(G, keys(tracers)[tr]); tracer_equation = eqn.tracers[tr]; Gtracer[i, j, k] = tracer_equation(i, j, k, grid, etc...); end; ```. ## Equations as new types. Even more flexibility / clarity might be provided by a callable `Equation` type implementation with appropriate type parameters (`Linear`, `Hydrostatic`, etc) which would avoid the need for `if` statements as on the last line of the code above. I'm not sure exactly what that would look like. The design problem for a new `Equation` type does seem a bit more difficult and would require care --- thinking about how we would implement a nonlinear biological model might provide a nice use case to help use make our ideas concrete. Hopefully this provides food for thought and also motivates us to think carefully about our design decisions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/259
https://github.com/CliMA/Oceananigans.jl/issues/259:1343,Testability,log,logical,1343," I think we should require that. 1. The memory footprint of our model is no larger than it needs to be for a given problem (no 'extra' allocation of memory for unused tracers, for hydrostatic pressure when running in non hydrostatic mode, etc). 2. We do not perform unnecessary floating-point computations or indexing into arrays (the latter is especially important in GPU code) for unused tracers or hydrostatic pressure fields. 3. Equations are constructed / specified clearly and concisely (both in source code and user scripts). 4. Users can specify arbitrary types of forcing, including numbers, arrays, or functions (solving #110). 5. We can support arbitrary tracers with various features, such as sinking/rising velocities, or reaction systems for biological/chemical tracer systems. When I have talked to various people about this, there was a concern that this system would be 'inelegant' or 'complex'. However I believe an equation abstraction system provides the opposite: with an abstraction system, equations are 'written down' in some logical place (like a file `equations.jl` in the `src` directory where they can be easily read and modified, rather than buried inside a time-stepping loop. Correspondly, our time-stepping code becomes shorter and more concise. Using multiple dispatch correctly, we avoid the `infinite if-statement` problem. This abstraction may also make the code more modular such that we move closer to supporting multiple time-steppers. Below I provide one example of an implementation that would solve some of the problems I listed. However, *this is not the only solution*, and I think we should expend some intellectual effort and have a discussion about what the best solution might be, so that we design something that is nice, easy to extend, performant, and powerful. ## A list of kernel equations in a named tuple. The simplest solution for this abstraction is probably just to add new fields to `Model` (`model.equations.velocities` and `model.equations",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/259
https://github.com/CliMA/Oceananigans.jl/issues/259:764,Usability,clear,clearly,764,"I'm thinking about the future and hoping to start a discussion about the future of our equation abstraction system. ## The problem. We need an abstraction for the concept of an equation, so that we can make the model as performant and lightweight as possible for a given use case. For example, I think we should require that. 1. The memory footprint of our model is no larger than it needs to be for a given problem (no 'extra' allocation of memory for unused tracers, for hydrostatic pressure when running in non hydrostatic mode, etc). 2. We do not perform unnecessary floating-point computations or indexing into arrays (the latter is especially important in GPU code) for unused tracers or hydrostatic pressure fields. 3. Equations are constructed / specified clearly and concisely (both in source code and user scripts). 4. Users can specify arbitrary types of forcing, including numbers, arrays, or functions (solving #110). 5. We can support arbitrary tracers with various features, such as sinking/rising velocities, or reaction systems for biological/chemical tracer systems. When I have talked to various people about this, there was a concern that this system would be 'inelegant' or 'complex'. However I believe an equation abstraction system provides the opposite: with an abstraction system, equations are 'written down' in some logical place (like a file `equations.jl` in the `src` directory where they can be easily read and modified, rather than buried inside a time-stepping loop. Correspondly, our time-stepping code becomes shorter and more concise. Using multiple dispatch correctly, we avoid the `infinite if-statement` problem. This abstraction may also make the code more modular such that we move closer to supporting multiple time-steppers. Below I provide one example of an implementation that would solve some of the problems I listed. However, *this is not the only solution*, and I think we should expend some intellectual effort and have a discussion about what the bes",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/259
https://github.com/CliMA/Oceananigans.jl/issues/259:2158,Usability,simpl,simplest,2158,"x'. However I believe an equation abstraction system provides the opposite: with an abstraction system, equations are 'written down' in some logical place (like a file `equations.jl` in the `src` directory where they can be easily read and modified, rather than buried inside a time-stepping loop. Correspondly, our time-stepping code becomes shorter and more concise. Using multiple dispatch correctly, we avoid the `infinite if-statement` problem. This abstraction may also make the code more modular such that we move closer to supporting multiple time-steppers. Below I provide one example of an implementation that would solve some of the problems I listed. However, *this is not the only solution*, and I think we should expend some intellectual effort and have a discussion about what the best solution might be, so that we design something that is nice, easy to extend, performant, and powerful. ## A list of kernel equations in a named tuple. The simplest solution for this abstraction is probably just to add new fields to `Model` (`model.equations.velocities` and `model.equations.tracers`) that are named tuples of kernel equations. An example of how this might work while demonstrating hierarchical multiple dispatch is:. ```julia; forcing(i, j, k, grid, F::Function, u, v, w, T, S) = F(grid, u, v, w, T, S, i, j, k); forcing(i, j, k, grid, F::AbstractArray, u, v, w, T, S) = F[i, j, k]. u_eqn(i, j, k, grid, etc...) = (-u∇u(grid, u, v, w, i, j, k); + fv(grid, v, fCor, i, j, k); - δx_c2f(grid, pHY′, i, j, k) / (Δx * ρ₀); + ∂ⱼ_2ν_Σ₁ⱼ(i, j, k, grid, closure, eos, grav, u, v, w, T, S); + forcing(i, j, k, grid, F, u, v, w, T, S); ). # Note omission of pressure term here; u_eqn(i, j, k, grid, pHY::Nothing, etc...) = (-u∇u(grid, u, v, w, i, j, k); + fv(grid, v, fCor, i, j, k); + ∂ⱼ_2ν_Σ₁ⱼ(i, j, k, grid, closure, eos, grav, u, v, w, T, S); + forcing(i, j, k, grid, F, u, v, w T, S); ). linear_u_eqn(i, j, k, grid, etc....) = (fv(grid, v, fCor, i, j, k); - δx_c2f(grid, pHY′, i, j, k) / ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/259
https://github.com/CliMA/Oceananigans.jl/issues/260:553,Availability,Error,Error,553,"@jm-c was right about Smagorinsky requiring a larger halo size than the rest of the code. Running `test_smag_divflux_finiteness(T)` causes a `BoundsError` when trying to access index `-1` which suggests we need halos of at least size 2. We do support halos of arbitrary size in all three directions so it would be easy to increase the size of the halos if Smagorinsky is used as a closure. Just wanted to open this issue to see if this is what we wanted to do. For now I'm skipping the test so it's showing up as broken. ```julia; Constant Smagorinsky: Error During Test at /home/alir/Oceananigans.jl/test/runtests.jl:466; Test threw exception; Expression: test_smag_divflux_finiteness(T); BoundsError: attempt to access OffsetArray(::Array{Float32,3}, 0:4, 0:4, 1:3) with eltype Float32 with indices 0:4×0:4×1:3 at index [3, -1, 2]; Stacktrace:; [1] throw_boundserror(::OffsetArray{Float32,3,Array{Float32,3}}, ::Tuple{Int64,Int64,Int64}) at ./abstractarray.jl:484; [2] checkbounds at ./abstractarray.jl:449 [inlined]; [3] getindex at /home/alir/.julia/packages/OffsetArrays/ruvC7/src/OffsetArrays.jl:130 [inlined]; [4] ∂y_afa at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:8 [inlined]; [5] ∂y_u(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::OffsetArray{Float32,3,Array{Float32,3}}) at /home/alir/Oceananigans.jl/src/closures/velocity_gradients.jl:14; [6] Σ₁₂ at /home/alir/Oceananigans.jl/src/closures/velocity_gradients.jl:33 [inlined]; [7] Σ₁₂² at /home/alir/Oceananigans.jl/src/closures/velocity_gradients.jl:44 [inlined]; [8] Σ₁₂² at /home/alir/Oceananigans.jl/src/closures/velocity_gradients.jl:80 [inlined]; [9] ▶x_caa at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:191 [inlined]; [10] ▶y_aca at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:217 [inlined]; [11] ▶xy_cca at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:275 [inlined]; [12] ΣᵢⱼΣᵢⱼ_ccc at /home/alir/Oceananigan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/260
https://github.com/CliMA/Oceananigans.jl/issues/260:170,Security,access,access,170,"@jm-c was right about Smagorinsky requiring a larger halo size than the rest of the code. Running `test_smag_divflux_finiteness(T)` causes a `BoundsError` when trying to access index `-1` which suggests we need halos of at least size 2. We do support halos of arbitrary size in all three directions so it would be easy to increase the size of the halos if Smagorinsky is used as a closure. Just wanted to open this issue to see if this is what we wanted to do. For now I'm skipping the test so it's showing up as broken. ```julia; Constant Smagorinsky: Error During Test at /home/alir/Oceananigans.jl/test/runtests.jl:466; Test threw exception; Expression: test_smag_divflux_finiteness(T); BoundsError: attempt to access OffsetArray(::Array{Float32,3}, 0:4, 0:4, 1:3) with eltype Float32 with indices 0:4×0:4×1:3 at index [3, -1, 2]; Stacktrace:; [1] throw_boundserror(::OffsetArray{Float32,3,Array{Float32,3}}, ::Tuple{Int64,Int64,Int64}) at ./abstractarray.jl:484; [2] checkbounds at ./abstractarray.jl:449 [inlined]; [3] getindex at /home/alir/.julia/packages/OffsetArrays/ruvC7/src/OffsetArrays.jl:130 [inlined]; [4] ∂y_afa at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:8 [inlined]; [5] ∂y_u(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::OffsetArray{Float32,3,Array{Float32,3}}) at /home/alir/Oceananigans.jl/src/closures/velocity_gradients.jl:14; [6] Σ₁₂ at /home/alir/Oceananigans.jl/src/closures/velocity_gradients.jl:33 [inlined]; [7] Σ₁₂² at /home/alir/Oceananigans.jl/src/closures/velocity_gradients.jl:44 [inlined]; [8] Σ₁₂² at /home/alir/Oceananigans.jl/src/closures/velocity_gradients.jl:80 [inlined]; [9] ▶x_caa at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:191 [inlined]; [10] ▶y_aca at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:217 [inlined]; [11] ▶xy_cca at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:275 [inlined]; [12] ΣᵢⱼΣᵢⱼ_ccc at /home/alir/Oceananigan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/260
https://github.com/CliMA/Oceananigans.jl/issues/260:714,Security,access,access,714,"@jm-c was right about Smagorinsky requiring a larger halo size than the rest of the code. Running `test_smag_divflux_finiteness(T)` causes a `BoundsError` when trying to access index `-1` which suggests we need halos of at least size 2. We do support halos of arbitrary size in all three directions so it would be easy to increase the size of the halos if Smagorinsky is used as a closure. Just wanted to open this issue to see if this is what we wanted to do. For now I'm skipping the test so it's showing up as broken. ```julia; Constant Smagorinsky: Error During Test at /home/alir/Oceananigans.jl/test/runtests.jl:466; Test threw exception; Expression: test_smag_divflux_finiteness(T); BoundsError: attempt to access OffsetArray(::Array{Float32,3}, 0:4, 0:4, 1:3) with eltype Float32 with indices 0:4×0:4×1:3 at index [3, -1, 2]; Stacktrace:; [1] throw_boundserror(::OffsetArray{Float32,3,Array{Float32,3}}, ::Tuple{Int64,Int64,Int64}) at ./abstractarray.jl:484; [2] checkbounds at ./abstractarray.jl:449 [inlined]; [3] getindex at /home/alir/.julia/packages/OffsetArrays/ruvC7/src/OffsetArrays.jl:130 [inlined]; [4] ∂y_afa at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:8 [inlined]; [5] ∂y_u(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::OffsetArray{Float32,3,Array{Float32,3}}) at /home/alir/Oceananigans.jl/src/closures/velocity_gradients.jl:14; [6] Σ₁₂ at /home/alir/Oceananigans.jl/src/closures/velocity_gradients.jl:33 [inlined]; [7] Σ₁₂² at /home/alir/Oceananigans.jl/src/closures/velocity_gradients.jl:44 [inlined]; [8] Σ₁₂² at /home/alir/Oceananigans.jl/src/closures/velocity_gradients.jl:80 [inlined]; [9] ▶x_caa at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:191 [inlined]; [10] ▶y_aca at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:217 [inlined]; [11] ▶xy_cca at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:275 [inlined]; [12] ΣᵢⱼΣᵢⱼ_ccc at /home/alir/Oceananigan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/260
https://github.com/CliMA/Oceananigans.jl/issues/260:486,Testability,test,test,486,"@jm-c was right about Smagorinsky requiring a larger halo size than the rest of the code. Running `test_smag_divflux_finiteness(T)` causes a `BoundsError` when trying to access index `-1` which suggests we need halos of at least size 2. We do support halos of arbitrary size in all three directions so it would be easy to increase the size of the halos if Smagorinsky is used as a closure. Just wanted to open this issue to see if this is what we wanted to do. For now I'm skipping the test so it's showing up as broken. ```julia; Constant Smagorinsky: Error During Test at /home/alir/Oceananigans.jl/test/runtests.jl:466; Test threw exception; Expression: test_smag_divflux_finiteness(T); BoundsError: attempt to access OffsetArray(::Array{Float32,3}, 0:4, 0:4, 1:3) with eltype Float32 with indices 0:4×0:4×1:3 at index [3, -1, 2]; Stacktrace:; [1] throw_boundserror(::OffsetArray{Float32,3,Array{Float32,3}}, ::Tuple{Int64,Int64,Int64}) at ./abstractarray.jl:484; [2] checkbounds at ./abstractarray.jl:449 [inlined]; [3] getindex at /home/alir/.julia/packages/OffsetArrays/ruvC7/src/OffsetArrays.jl:130 [inlined]; [4] ∂y_afa at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:8 [inlined]; [5] ∂y_u(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::OffsetArray{Float32,3,Array{Float32,3}}) at /home/alir/Oceananigans.jl/src/closures/velocity_gradients.jl:14; [6] Σ₁₂ at /home/alir/Oceananigans.jl/src/closures/velocity_gradients.jl:33 [inlined]; [7] Σ₁₂² at /home/alir/Oceananigans.jl/src/closures/velocity_gradients.jl:44 [inlined]; [8] Σ₁₂² at /home/alir/Oceananigans.jl/src/closures/velocity_gradients.jl:80 [inlined]; [9] ▶x_caa at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:191 [inlined]; [10] ▶y_aca at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:217 [inlined]; [11] ▶xy_cca at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:275 [inlined]; [12] ΣᵢⱼΣᵢⱼ_ccc at /home/alir/Oceananigan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/260
https://github.com/CliMA/Oceananigans.jl/issues/260:566,Testability,Test,Test,566,"@jm-c was right about Smagorinsky requiring a larger halo size than the rest of the code. Running `test_smag_divflux_finiteness(T)` causes a `BoundsError` when trying to access index `-1` which suggests we need halos of at least size 2. We do support halos of arbitrary size in all three directions so it would be easy to increase the size of the halos if Smagorinsky is used as a closure. Just wanted to open this issue to see if this is what we wanted to do. For now I'm skipping the test so it's showing up as broken. ```julia; Constant Smagorinsky: Error During Test at /home/alir/Oceananigans.jl/test/runtests.jl:466; Test threw exception; Expression: test_smag_divflux_finiteness(T); BoundsError: attempt to access OffsetArray(::Array{Float32,3}, 0:4, 0:4, 1:3) with eltype Float32 with indices 0:4×0:4×1:3 at index [3, -1, 2]; Stacktrace:; [1] throw_boundserror(::OffsetArray{Float32,3,Array{Float32,3}}, ::Tuple{Int64,Int64,Int64}) at ./abstractarray.jl:484; [2] checkbounds at ./abstractarray.jl:449 [inlined]; [3] getindex at /home/alir/.julia/packages/OffsetArrays/ruvC7/src/OffsetArrays.jl:130 [inlined]; [4] ∂y_afa at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:8 [inlined]; [5] ∂y_u(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::OffsetArray{Float32,3,Array{Float32,3}}) at /home/alir/Oceananigans.jl/src/closures/velocity_gradients.jl:14; [6] Σ₁₂ at /home/alir/Oceananigans.jl/src/closures/velocity_gradients.jl:33 [inlined]; [7] Σ₁₂² at /home/alir/Oceananigans.jl/src/closures/velocity_gradients.jl:44 [inlined]; [8] Σ₁₂² at /home/alir/Oceananigans.jl/src/closures/velocity_gradients.jl:80 [inlined]; [9] ▶x_caa at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:191 [inlined]; [10] ▶y_aca at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:217 [inlined]; [11] ▶xy_cca at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:275 [inlined]; [12] ΣᵢⱼΣᵢⱼ_ccc at /home/alir/Oceananigan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/260
https://github.com/CliMA/Oceananigans.jl/issues/260:601,Testability,test,test,601,"@jm-c was right about Smagorinsky requiring a larger halo size than the rest of the code. Running `test_smag_divflux_finiteness(T)` causes a `BoundsError` when trying to access index `-1` which suggests we need halos of at least size 2. We do support halos of arbitrary size in all three directions so it would be easy to increase the size of the halos if Smagorinsky is used as a closure. Just wanted to open this issue to see if this is what we wanted to do. For now I'm skipping the test so it's showing up as broken. ```julia; Constant Smagorinsky: Error During Test at /home/alir/Oceananigans.jl/test/runtests.jl:466; Test threw exception; Expression: test_smag_divflux_finiteness(T); BoundsError: attempt to access OffsetArray(::Array{Float32,3}, 0:4, 0:4, 1:3) with eltype Float32 with indices 0:4×0:4×1:3 at index [3, -1, 2]; Stacktrace:; [1] throw_boundserror(::OffsetArray{Float32,3,Array{Float32,3}}, ::Tuple{Int64,Int64,Int64}) at ./abstractarray.jl:484; [2] checkbounds at ./abstractarray.jl:449 [inlined]; [3] getindex at /home/alir/.julia/packages/OffsetArrays/ruvC7/src/OffsetArrays.jl:130 [inlined]; [4] ∂y_afa at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:8 [inlined]; [5] ∂y_u(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::OffsetArray{Float32,3,Array{Float32,3}}) at /home/alir/Oceananigans.jl/src/closures/velocity_gradients.jl:14; [6] Σ₁₂ at /home/alir/Oceananigans.jl/src/closures/velocity_gradients.jl:33 [inlined]; [7] Σ₁₂² at /home/alir/Oceananigans.jl/src/closures/velocity_gradients.jl:44 [inlined]; [8] Σ₁₂² at /home/alir/Oceananigans.jl/src/closures/velocity_gradients.jl:80 [inlined]; [9] ▶x_caa at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:191 [inlined]; [10] ▶y_aca at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:217 [inlined]; [11] ▶xy_cca at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:275 [inlined]; [12] ΣᵢⱼΣᵢⱼ_ccc at /home/alir/Oceananigan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/260
https://github.com/CliMA/Oceananigans.jl/issues/260:623,Testability,Test,Test,623,"@jm-c was right about Smagorinsky requiring a larger halo size than the rest of the code. Running `test_smag_divflux_finiteness(T)` causes a `BoundsError` when trying to access index `-1` which suggests we need halos of at least size 2. We do support halos of arbitrary size in all three directions so it would be easy to increase the size of the halos if Smagorinsky is used as a closure. Just wanted to open this issue to see if this is what we wanted to do. For now I'm skipping the test so it's showing up as broken. ```julia; Constant Smagorinsky: Error During Test at /home/alir/Oceananigans.jl/test/runtests.jl:466; Test threw exception; Expression: test_smag_divflux_finiteness(T); BoundsError: attempt to access OffsetArray(::Array{Float32,3}, 0:4, 0:4, 1:3) with eltype Float32 with indices 0:4×0:4×1:3 at index [3, -1, 2]; Stacktrace:; [1] throw_boundserror(::OffsetArray{Float32,3,Array{Float32,3}}, ::Tuple{Int64,Int64,Int64}) at ./abstractarray.jl:484; [2] checkbounds at ./abstractarray.jl:449 [inlined]; [3] getindex at /home/alir/.julia/packages/OffsetArrays/ruvC7/src/OffsetArrays.jl:130 [inlined]; [4] ∂y_afa at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:8 [inlined]; [5] ∂y_u(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::OffsetArray{Float32,3,Array{Float32,3}}) at /home/alir/Oceananigans.jl/src/closures/velocity_gradients.jl:14; [6] Σ₁₂ at /home/alir/Oceananigans.jl/src/closures/velocity_gradients.jl:33 [inlined]; [7] Σ₁₂² at /home/alir/Oceananigans.jl/src/closures/velocity_gradients.jl:44 [inlined]; [8] Σ₁₂² at /home/alir/Oceananigans.jl/src/closures/velocity_gradients.jl:80 [inlined]; [9] ▶x_caa at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:191 [inlined]; [10] ▶y_aca at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:217 [inlined]; [11] ▶xy_cca at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:275 [inlined]; [12] ΣᵢⱼΣᵢⱼ_ccc at /home/alir/Oceananigan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/260
https://github.com/CliMA/Oceananigans.jl/issues/260:3746,Testability,test,test,3746,"t32,3,Array{Float32,3}}, ::OffsetArray{Float32,3,Array{Float32,3}}) at /home/alir/Oceananigans.jl/src/closures/constant_smagorinsky.jl:88; [14] ▶y_afa(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::Function, ::ConstantSmagorinsky{Float32}, ::Vararg{Any,N} where N) at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:204; [15] κ_∂y_ϕ(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::OffsetArray{Float32,3,Array{Float32,3}}, ::Function, ::ConstantSmagorinsky{Float32}, ::LinearEquationOfState{Float64}, ::Vararg{Any,N} where N) at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:482; [16] ∂y_aca(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::Function, ::OffsetArray{Float32,3,Array{Float32,3}}, ::Vararg{Any,N} where N) at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:114; [17] ∇_κ_∇ϕ(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::OffsetArray{Float32,3,Array{Float32,3}}, ::ConstantSmagorinsky{Float32}, ::LinearEquationOfState{Float64}, ::Vararg{Any,N} where N) at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:506; [18] test_smag_divflux_finiteness(::Type) at /home/alir/Oceananigans.jl/test/test_turbulence_closures.jl:173; [19] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:466; [20] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [21] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:464; [22] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [23] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:427; [24] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [25] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:20; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/260
https://github.com/CliMA/Oceananigans.jl/issues/260:3835,Testability,test,test,3835,"t32,3,Array{Float32,3}}, ::OffsetArray{Float32,3,Array{Float32,3}}) at /home/alir/Oceananigans.jl/src/closures/constant_smagorinsky.jl:88; [14] ▶y_afa(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::Function, ::ConstantSmagorinsky{Float32}, ::Vararg{Any,N} where N) at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:204; [15] κ_∂y_ϕ(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::OffsetArray{Float32,3,Array{Float32,3}}, ::Function, ::ConstantSmagorinsky{Float32}, ::LinearEquationOfState{Float64}, ::Vararg{Any,N} where N) at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:482; [16] ∂y_aca(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::Function, ::OffsetArray{Float32,3,Array{Float32,3}}, ::Vararg{Any,N} where N) at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:114; [17] ∇_κ_∇ϕ(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::OffsetArray{Float32,3,Array{Float32,3}}, ::ConstantSmagorinsky{Float32}, ::LinearEquationOfState{Float64}, ::Vararg{Any,N} where N) at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:506; [18] test_smag_divflux_finiteness(::Type) at /home/alir/Oceananigans.jl/test/test_turbulence_closures.jl:173; [19] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:466; [20] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [21] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:464; [22] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [23] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:427; [24] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [25] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:20; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/260
https://github.com/CliMA/Oceananigans.jl/issues/260:3938,Testability,Test,Test,3938,"t32,3,Array{Float32,3}}, ::OffsetArray{Float32,3,Array{Float32,3}}) at /home/alir/Oceananigans.jl/src/closures/constant_smagorinsky.jl:88; [14] ▶y_afa(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::Function, ::ConstantSmagorinsky{Float32}, ::Vararg{Any,N} where N) at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:204; [15] κ_∂y_ϕ(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::OffsetArray{Float32,3,Array{Float32,3}}, ::Function, ::ConstantSmagorinsky{Float32}, ::LinearEquationOfState{Float64}, ::Vararg{Any,N} where N) at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:482; [16] ∂y_aca(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::Function, ::OffsetArray{Float32,3,Array{Float32,3}}, ::Vararg{Any,N} where N) at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:114; [17] ∇_κ_∇ϕ(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::OffsetArray{Float32,3,Array{Float32,3}}, ::ConstantSmagorinsky{Float32}, ::LinearEquationOfState{Float64}, ::Vararg{Any,N} where N) at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:506; [18] test_smag_divflux_finiteness(::Type) at /home/alir/Oceananigans.jl/test/test_turbulence_closures.jl:173; [19] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:466; [20] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [21] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:464; [22] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [23] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:427; [24] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [25] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:20; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/260
https://github.com/CliMA/Oceananigans.jl/issues/260:3947,Testability,Test,Test,3947,"t32,3,Array{Float32,3}}, ::OffsetArray{Float32,3,Array{Float32,3}}) at /home/alir/Oceananigans.jl/src/closures/constant_smagorinsky.jl:88; [14] ▶y_afa(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::Function, ::ConstantSmagorinsky{Float32}, ::Vararg{Any,N} where N) at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:204; [15] κ_∂y_ϕ(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::OffsetArray{Float32,3,Array{Float32,3}}, ::Function, ::ConstantSmagorinsky{Float32}, ::LinearEquationOfState{Float64}, ::Vararg{Any,N} where N) at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:482; [16] ∂y_aca(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::Function, ::OffsetArray{Float32,3,Array{Float32,3}}, ::Vararg{Any,N} where N) at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:114; [17] ∇_κ_∇ϕ(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::OffsetArray{Float32,3,Array{Float32,3}}, ::ConstantSmagorinsky{Float32}, ::LinearEquationOfState{Float64}, ::Vararg{Any,N} where N) at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:506; [18] test_smag_divflux_finiteness(::Type) at /home/alir/Oceananigans.jl/test/test_turbulence_closures.jl:173; [19] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:466; [20] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [21] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:464; [22] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [23] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:427; [24] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [25] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:20; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/260
https://github.com/CliMA/Oceananigans.jl/issues/260:4012,Testability,test,test,4012,"t32,3,Array{Float32,3}}, ::OffsetArray{Float32,3,Array{Float32,3}}) at /home/alir/Oceananigans.jl/src/closures/constant_smagorinsky.jl:88; [14] ▶y_afa(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::Function, ::ConstantSmagorinsky{Float32}, ::Vararg{Any,N} where N) at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:204; [15] κ_∂y_ϕ(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::OffsetArray{Float32,3,Array{Float32,3}}, ::Function, ::ConstantSmagorinsky{Float32}, ::LinearEquationOfState{Float64}, ::Vararg{Any,N} where N) at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:482; [16] ∂y_aca(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::Function, ::OffsetArray{Float32,3,Array{Float32,3}}, ::Vararg{Any,N} where N) at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:114; [17] ∇_κ_∇ϕ(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::OffsetArray{Float32,3,Array{Float32,3}}, ::ConstantSmagorinsky{Float32}, ::LinearEquationOfState{Float64}, ::Vararg{Any,N} where N) at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:506; [18] test_smag_divflux_finiteness(::Type) at /home/alir/Oceananigans.jl/test/test_turbulence_closures.jl:173; [19] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:466; [20] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [21] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:464; [22] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [23] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:427; [24] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [25] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:20; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/260
https://github.com/CliMA/Oceananigans.jl/issues/260:4115,Testability,Test,Test,4115,"t32,3,Array{Float32,3}}, ::OffsetArray{Float32,3,Array{Float32,3}}) at /home/alir/Oceananigans.jl/src/closures/constant_smagorinsky.jl:88; [14] ▶y_afa(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::Function, ::ConstantSmagorinsky{Float32}, ::Vararg{Any,N} where N) at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:204; [15] κ_∂y_ϕ(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::OffsetArray{Float32,3,Array{Float32,3}}, ::Function, ::ConstantSmagorinsky{Float32}, ::LinearEquationOfState{Float64}, ::Vararg{Any,N} where N) at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:482; [16] ∂y_aca(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::Function, ::OffsetArray{Float32,3,Array{Float32,3}}, ::Vararg{Any,N} where N) at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:114; [17] ∇_κ_∇ϕ(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::OffsetArray{Float32,3,Array{Float32,3}}, ::ConstantSmagorinsky{Float32}, ::LinearEquationOfState{Float64}, ::Vararg{Any,N} where N) at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:506; [18] test_smag_divflux_finiteness(::Type) at /home/alir/Oceananigans.jl/test/test_turbulence_closures.jl:173; [19] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:466; [20] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [21] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:464; [22] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [23] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:427; [24] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [25] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:20; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/260
https://github.com/CliMA/Oceananigans.jl/issues/260:4124,Testability,Test,Test,4124,"t32,3,Array{Float32,3}}, ::OffsetArray{Float32,3,Array{Float32,3}}) at /home/alir/Oceananigans.jl/src/closures/constant_smagorinsky.jl:88; [14] ▶y_afa(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::Function, ::ConstantSmagorinsky{Float32}, ::Vararg{Any,N} where N) at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:204; [15] κ_∂y_ϕ(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::OffsetArray{Float32,3,Array{Float32,3}}, ::Function, ::ConstantSmagorinsky{Float32}, ::LinearEquationOfState{Float64}, ::Vararg{Any,N} where N) at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:482; [16] ∂y_aca(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::Function, ::OffsetArray{Float32,3,Array{Float32,3}}, ::Vararg{Any,N} where N) at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:114; [17] ∇_κ_∇ϕ(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::OffsetArray{Float32,3,Array{Float32,3}}, ::ConstantSmagorinsky{Float32}, ::LinearEquationOfState{Float64}, ::Vararg{Any,N} where N) at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:506; [18] test_smag_divflux_finiteness(::Type) at /home/alir/Oceananigans.jl/test/test_turbulence_closures.jl:173; [19] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:466; [20] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [21] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:464; [22] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [23] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:427; [24] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [25] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:20; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/260
https://github.com/CliMA/Oceananigans.jl/issues/260:4189,Testability,test,test,4189,"t32,3,Array{Float32,3}}, ::OffsetArray{Float32,3,Array{Float32,3}}) at /home/alir/Oceananigans.jl/src/closures/constant_smagorinsky.jl:88; [14] ▶y_afa(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::Function, ::ConstantSmagorinsky{Float32}, ::Vararg{Any,N} where N) at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:204; [15] κ_∂y_ϕ(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::OffsetArray{Float32,3,Array{Float32,3}}, ::Function, ::ConstantSmagorinsky{Float32}, ::LinearEquationOfState{Float64}, ::Vararg{Any,N} where N) at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:482; [16] ∂y_aca(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::Function, ::OffsetArray{Float32,3,Array{Float32,3}}, ::Vararg{Any,N} where N) at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:114; [17] ∇_κ_∇ϕ(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::OffsetArray{Float32,3,Array{Float32,3}}, ::ConstantSmagorinsky{Float32}, ::LinearEquationOfState{Float64}, ::Vararg{Any,N} where N) at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:506; [18] test_smag_divflux_finiteness(::Type) at /home/alir/Oceananigans.jl/test/test_turbulence_closures.jl:173; [19] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:466; [20] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [21] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:464; [22] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [23] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:427; [24] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [25] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:20; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/260
https://github.com/CliMA/Oceananigans.jl/issues/260:4292,Testability,Test,Test,4292,"t32,3,Array{Float32,3}}, ::OffsetArray{Float32,3,Array{Float32,3}}) at /home/alir/Oceananigans.jl/src/closures/constant_smagorinsky.jl:88; [14] ▶y_afa(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::Function, ::ConstantSmagorinsky{Float32}, ::Vararg{Any,N} where N) at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:204; [15] κ_∂y_ϕ(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::OffsetArray{Float32,3,Array{Float32,3}}, ::Function, ::ConstantSmagorinsky{Float32}, ::LinearEquationOfState{Float64}, ::Vararg{Any,N} where N) at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:482; [16] ∂y_aca(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::Function, ::OffsetArray{Float32,3,Array{Float32,3}}, ::Vararg{Any,N} where N) at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:114; [17] ∇_κ_∇ϕ(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::OffsetArray{Float32,3,Array{Float32,3}}, ::ConstantSmagorinsky{Float32}, ::LinearEquationOfState{Float64}, ::Vararg{Any,N} where N) at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:506; [18] test_smag_divflux_finiteness(::Type) at /home/alir/Oceananigans.jl/test/test_turbulence_closures.jl:173; [19] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:466; [20] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [21] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:464; [22] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [23] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:427; [24] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [25] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:20; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/260
https://github.com/CliMA/Oceananigans.jl/issues/260:4301,Testability,Test,Test,4301,"t32,3,Array{Float32,3}}, ::OffsetArray{Float32,3,Array{Float32,3}}) at /home/alir/Oceananigans.jl/src/closures/constant_smagorinsky.jl:88; [14] ▶y_afa(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::Function, ::ConstantSmagorinsky{Float32}, ::Vararg{Any,N} where N) at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:204; [15] κ_∂y_ϕ(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::OffsetArray{Float32,3,Array{Float32,3}}, ::Function, ::ConstantSmagorinsky{Float32}, ::LinearEquationOfState{Float64}, ::Vararg{Any,N} where N) at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:482; [16] ∂y_aca(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::Function, ::OffsetArray{Float32,3,Array{Float32,3}}, ::Vararg{Any,N} where N) at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:114; [17] ∇_κ_∇ϕ(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::OffsetArray{Float32,3,Array{Float32,3}}, ::ConstantSmagorinsky{Float32}, ::LinearEquationOfState{Float64}, ::Vararg{Any,N} where N) at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:506; [18] test_smag_divflux_finiteness(::Type) at /home/alir/Oceananigans.jl/test/test_turbulence_closures.jl:173; [19] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:466; [20] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [21] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:464; [22] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [23] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:427; [24] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [25] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:20; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/260
https://github.com/CliMA/Oceananigans.jl/issues/260:4366,Testability,test,test,4366,"t32,3,Array{Float32,3}}, ::OffsetArray{Float32,3,Array{Float32,3}}) at /home/alir/Oceananigans.jl/src/closures/constant_smagorinsky.jl:88; [14] ▶y_afa(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::Function, ::ConstantSmagorinsky{Float32}, ::Vararg{Any,N} where N) at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:204; [15] κ_∂y_ϕ(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::OffsetArray{Float32,3,Array{Float32,3}}, ::Function, ::ConstantSmagorinsky{Float32}, ::LinearEquationOfState{Float64}, ::Vararg{Any,N} where N) at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:482; [16] ∂y_aca(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::Function, ::OffsetArray{Float32,3,Array{Float32,3}}, ::Vararg{Any,N} where N) at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:114; [17] ∇_κ_∇ϕ(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::OffsetArray{Float32,3,Array{Float32,3}}, ::ConstantSmagorinsky{Float32}, ::LinearEquationOfState{Float64}, ::Vararg{Any,N} where N) at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:506; [18] test_smag_divflux_finiteness(::Type) at /home/alir/Oceananigans.jl/test/test_turbulence_closures.jl:173; [19] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:466; [20] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [21] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:464; [22] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [23] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:427; [24] top-level scope at /build/julia/src/julia-1.1.0/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083; [25] top-level scope at /home/alir/Oceananigans.jl/test/runtests.jl:20; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/260
https://github.com/CliMA/Oceananigans.jl/pull/263:288,Availability,checkpoint,checkpointing,288,"Builds off @vchuravy's work in #261. Preliminary design of user API for concrete models. Probably most of the time the user will have to specify boundary conditions prior to building the model. We'll have to come up with good syntax for that. What we have is ok, but can be improved. The checkpointing tests currently fail, I think because they attempt to change the types of the some of the model fields.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/263
https://github.com/CliMA/Oceananigans.jl/pull/263:302,Testability,test,tests,302,"Builds off @vchuravy's work in #261. Preliminary design of user API for concrete models. Probably most of the time the user will have to specify boundary conditions prior to building the model. We'll have to come up with good syntax for that. What we have is ok, but can be improved. The checkpointing tests currently fail, I think because they attempt to change the types of the some of the model fields.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/263
https://github.com/CliMA/Oceananigans.jl/issues/267:268,Availability,error,error,268,"The line `model.tracers.T.data .= 282.99 .+ 2 .* reshape(hot_bubble_perturbation, (Nx, Ny, Nz))` in the README should be replaced with `data(model.tracers.T) .= model.eos.T₀ .- 0.01 .+ 2 .* reshape(hot_bubble_perturbation, (Nx, Ny, Nz))`. The former gives a broadcast error. The latter is used in the `rising_thermal_bubble_2d.jl` example and seems to produce the expected bubble.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/267
https://github.com/CliMA/Oceananigans.jl/pull/268:60,Safety,avoid,avoid,60,This PR directly indexes the underlying Array or CuArray to avoid the issue that broadcasting over an `OffsetArray{CuArray}` is extremely inefficient. cc @sandreza,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/268
https://github.com/CliMA/Oceananigans.jl/pull/272:1469,Availability,ERROR,ERROR,1469,"tPass where T<:Union{Nothing, Cassette.Tag{N, X, E} where E where X where N<:Cassette.AbstractContextName} where M where N<:Cassette.AbstractContextName, Any...) in module Cassette at /home/alir_mit_edu/.julia/packages/Cassette/xggAf/src/overdub.jl:508 overwritten in module GPUifyLoops at /home/alir_mit_edu/.julia/packages/Cassette/xggAf/src/overdub.jl:508.; WARNING: Method definition recurse(Cassette.Context{N, M, T, P, B, H} where H<:Union{Cassette.DisableHooks, Nothing} where B<:Union{Nothing, Base.IdDict{Module, Base.Dict{Symbol, Cassette.BindingMeta}}} where P<:Cassette.AbstractPass where T<:Union{Nothing, Cassette.Tag{N, X, E} where E where X where N<:Cassette.AbstractContextName} where M where N<:Cassette.AbstractContextName, Any...) in module Cassette at /home/alir_mit_edu/.julia/packages/Cassette/xggAf/src/overdub.jl:521 overwritten in module GPUifyLoops at /home/alir_mit_edu/.julia/packages/Cassette/xggAf/src/overdub.jl:521.; CUDA-enabled GPU(s) detected:; CuDevice(0): Tesla V100-SXM2-16GB; ERROR: LoadError: TypeError: in setfield!, expected BoundaryCondition{Default,Nothing}, got BoundaryCondition{Flux,Float64}; Stacktrace:; [1] setbc!(::Oceananigans.CoordinateBoundaryConditions{BoundaryCondition{Default,Nothing},BoundaryCondition{Default,Nothing}}, ::Val{:left}, ::BoundaryCondition{Flux,Float64}) at /home/alir_mit_edu/Oceananigans.jl/src/boundary_conditions.jl:85; [2] setproperty!(::Oceananigans.CoordinateBoundaryConditions{BoundaryCondition{Default,Nothing},BoundaryCondition{Default,Nothing}}, ::Symbol, ::BoundaryCondition{Flux,Float64}) at /home/alir_mit_edu/Oceananigans.jl/src/boundary_conditions.jl:84; [3] top-level scope at none:0; [4] include at ./boot.jl:326 [inlined]; [5] include_relative(::Module, ::String) at ./loading.jl:1038; [6] include(::Module, ::String) at ./sysimg.jl:29; [7] exec_options(::Base.JLOptions) at ./client.jl:267; [8] _start() at ./client.jl:436; in expression starting at /home/alir_mit_edu/Oceananigans.jl/newscript.jl:53; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/272
https://github.com/CliMA/Oceananigans.jl/pull/272:1476,Performance,Load,LoadError,1476,"tPass where T<:Union{Nothing, Cassette.Tag{N, X, E} where E where X where N<:Cassette.AbstractContextName} where M where N<:Cassette.AbstractContextName, Any...) in module Cassette at /home/alir_mit_edu/.julia/packages/Cassette/xggAf/src/overdub.jl:508 overwritten in module GPUifyLoops at /home/alir_mit_edu/.julia/packages/Cassette/xggAf/src/overdub.jl:508.; WARNING: Method definition recurse(Cassette.Context{N, M, T, P, B, H} where H<:Union{Cassette.DisableHooks, Nothing} where B<:Union{Nothing, Base.IdDict{Module, Base.Dict{Symbol, Cassette.BindingMeta}}} where P<:Cassette.AbstractPass where T<:Union{Nothing, Cassette.Tag{N, X, E} where E where X where N<:Cassette.AbstractContextName} where M where N<:Cassette.AbstractContextName, Any...) in module Cassette at /home/alir_mit_edu/.julia/packages/Cassette/xggAf/src/overdub.jl:521 overwritten in module GPUifyLoops at /home/alir_mit_edu/.julia/packages/Cassette/xggAf/src/overdub.jl:521.; CUDA-enabled GPU(s) detected:; CuDevice(0): Tesla V100-SXM2-16GB; ERROR: LoadError: TypeError: in setfield!, expected BoundaryCondition{Default,Nothing}, got BoundaryCondition{Flux,Float64}; Stacktrace:; [1] setbc!(::Oceananigans.CoordinateBoundaryConditions{BoundaryCondition{Default,Nothing},BoundaryCondition{Default,Nothing}}, ::Val{:left}, ::BoundaryCondition{Flux,Float64}) at /home/alir_mit_edu/Oceananigans.jl/src/boundary_conditions.jl:85; [2] setproperty!(::Oceananigans.CoordinateBoundaryConditions{BoundaryCondition{Default,Nothing},BoundaryCondition{Default,Nothing}}, ::Symbol, ::BoundaryCondition{Flux,Float64}) at /home/alir_mit_edu/Oceananigans.jl/src/boundary_conditions.jl:84; [3] top-level scope at none:0; [4] include at ./boot.jl:326 [inlined]; [5] include_relative(::Module, ::String) at ./loading.jl:1038; [6] include(::Module, ::String) at ./sysimg.jl:29; [7] exec_options(::Base.JLOptions) at ./client.jl:267; [8] _start() at ./client.jl:436; in expression starting at /home/alir_mit_edu/Oceananigans.jl/newscript.jl:53; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/272
https://github.com/CliMA/Oceananigans.jl/pull/272:2216,Performance,load,loading,2216,"tPass where T<:Union{Nothing, Cassette.Tag{N, X, E} where E where X where N<:Cassette.AbstractContextName} where M where N<:Cassette.AbstractContextName, Any...) in module Cassette at /home/alir_mit_edu/.julia/packages/Cassette/xggAf/src/overdub.jl:508 overwritten in module GPUifyLoops at /home/alir_mit_edu/.julia/packages/Cassette/xggAf/src/overdub.jl:508.; WARNING: Method definition recurse(Cassette.Context{N, M, T, P, B, H} where H<:Union{Cassette.DisableHooks, Nothing} where B<:Union{Nothing, Base.IdDict{Module, Base.Dict{Symbol, Cassette.BindingMeta}}} where P<:Cassette.AbstractPass where T<:Union{Nothing, Cassette.Tag{N, X, E} where E where X where N<:Cassette.AbstractContextName} where M where N<:Cassette.AbstractContextName, Any...) in module Cassette at /home/alir_mit_edu/.julia/packages/Cassette/xggAf/src/overdub.jl:521 overwritten in module GPUifyLoops at /home/alir_mit_edu/.julia/packages/Cassette/xggAf/src/overdub.jl:521.; CUDA-enabled GPU(s) detected:; CuDevice(0): Tesla V100-SXM2-16GB; ERROR: LoadError: TypeError: in setfield!, expected BoundaryCondition{Default,Nothing}, got BoundaryCondition{Flux,Float64}; Stacktrace:; [1] setbc!(::Oceananigans.CoordinateBoundaryConditions{BoundaryCondition{Default,Nothing},BoundaryCondition{Default,Nothing}}, ::Val{:left}, ::BoundaryCondition{Flux,Float64}) at /home/alir_mit_edu/Oceananigans.jl/src/boundary_conditions.jl:85; [2] setproperty!(::Oceananigans.CoordinateBoundaryConditions{BoundaryCondition{Default,Nothing},BoundaryCondition{Default,Nothing}}, ::Symbol, ::BoundaryCondition{Flux,Float64}) at /home/alir_mit_edu/Oceananigans.jl/src/boundary_conditions.jl:84; [3] top-level scope at none:0; [4] include at ./boot.jl:326 [inlined]; [5] include_relative(::Module, ::String) at ./loading.jl:1038; [6] include(::Module, ::String) at ./sysimg.jl:29; [7] exec_options(::Base.JLOptions) at ./client.jl:267; [8] _start() at ./client.jl:436; in expression starting at /home/alir_mit_edu/Oceananigans.jl/newscript.jl:53; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/272
https://github.com/CliMA/Oceananigans.jl/pull/272:1423,Safety,detect,detected,1423,"tPass where T<:Union{Nothing, Cassette.Tag{N, X, E} where E where X where N<:Cassette.AbstractContextName} where M where N<:Cassette.AbstractContextName, Any...) in module Cassette at /home/alir_mit_edu/.julia/packages/Cassette/xggAf/src/overdub.jl:508 overwritten in module GPUifyLoops at /home/alir_mit_edu/.julia/packages/Cassette/xggAf/src/overdub.jl:508.; WARNING: Method definition recurse(Cassette.Context{N, M, T, P, B, H} where H<:Union{Cassette.DisableHooks, Nothing} where B<:Union{Nothing, Base.IdDict{Module, Base.Dict{Symbol, Cassette.BindingMeta}}} where P<:Cassette.AbstractPass where T<:Union{Nothing, Cassette.Tag{N, X, E} where E where X where N<:Cassette.AbstractContextName} where M where N<:Cassette.AbstractContextName, Any...) in module Cassette at /home/alir_mit_edu/.julia/packages/Cassette/xggAf/src/overdub.jl:521 overwritten in module GPUifyLoops at /home/alir_mit_edu/.julia/packages/Cassette/xggAf/src/overdub.jl:521.; CUDA-enabled GPU(s) detected:; CuDevice(0): Tesla V100-SXM2-16GB; ERROR: LoadError: TypeError: in setfield!, expected BoundaryCondition{Default,Nothing}, got BoundaryCondition{Flux,Float64}; Stacktrace:; [1] setbc!(::Oceananigans.CoordinateBoundaryConditions{BoundaryCondition{Default,Nothing},BoundaryCondition{Default,Nothing}}, ::Val{:left}, ::BoundaryCondition{Flux,Float64}) at /home/alir_mit_edu/Oceananigans.jl/src/boundary_conditions.jl:85; [2] setproperty!(::Oceananigans.CoordinateBoundaryConditions{BoundaryCondition{Default,Nothing},BoundaryCondition{Default,Nothing}}, ::Symbol, ::BoundaryCondition{Flux,Float64}) at /home/alir_mit_edu/Oceananigans.jl/src/boundary_conditions.jl:84; [3] top-level scope at none:0; [4] include at ./boot.jl:326 [inlined]; [5] include_relative(::Module, ::String) at ./loading.jl:1038; [6] include(::Module, ::String) at ./sysimg.jl:29; [7] exec_options(::Base.JLOptions) at ./client.jl:267; [8] _start() at ./client.jl:436; in expression starting at /home/alir_mit_edu/Oceananigans.jl/newscript.jl:53; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/272
https://github.com/CliMA/Oceananigans.jl/pull/272:98,Testability,test,tests,98,"Reverts climate-machine/Oceananigans.jl#263 because boundary conditions API broke. Seems that the tests did not catch this maybe?. ```; (base) alir_mit_edu@oceananigans-debug:~/Oceananigans.jl$ julia --project newscript.jl ; WARNING: Method definition overdub(Cassette.Context{N, M, T, P, B, H} where H<:Union{Cassette.DisableHooks, Nothing} where B<:Union{Nothing, Base.IdDict{Module, Base.Dict{Symbol, Cassette.BindingMeta}}} where P<:Cassette.AbstractPass where T<:Union{Nothing, Cassette.Tag{N, X, E} where E where X where N<:Cassette.AbstractContextName} where M where N<:Cassette.AbstractContextName, Any...) in module Cassette at /home/alir_mit_edu/.julia/packages/Cassette/xggAf/src/overdub.jl:508 overwritten in module GPUifyLoops at /home/alir_mit_edu/.julia/packages/Cassette/xggAf/src/overdub.jl:508.; WARNING: Method definition recurse(Cassette.Context{N, M, T, P, B, H} where H<:Union{Cassette.DisableHooks, Nothing} where B<:Union{Nothing, Base.IdDict{Module, Base.Dict{Symbol, Cassette.BindingMeta}}} where P<:Cassette.AbstractPass where T<:Union{Nothing, Cassette.Tag{N, X, E} where E where X where N<:Cassette.AbstractContextName} where M where N<:Cassette.AbstractContextName, Any...) in module Cassette at /home/alir_mit_edu/.julia/packages/Cassette/xggAf/src/overdub.jl:521 overwritten in module GPUifyLoops at /home/alir_mit_edu/.julia/packages/Cassette/xggAf/src/overdub.jl:521.; CUDA-enabled GPU(s) detected:; CuDevice(0): Tesla V100-SXM2-16GB; ERROR: LoadError: TypeError: in setfield!, expected BoundaryCondition{Default,Nothing}, got BoundaryCondition{Flux,Float64}; Stacktrace:; [1] setbc!(::Oceananigans.CoordinateBoundaryConditions{BoundaryCondition{Default,Nothing},BoundaryCondition{Default,Nothing}}, ::Val{:left}, ::BoundaryCondition{Flux,Float64}) at /home/alir_mit_edu/Oceananigans.jl/src/boundary_conditions.jl:85; [2] setproperty!(::Oceananigans.CoordinateBoundaryConditions{BoundaryCondition{Default,Nothing},BoundaryCondition{Default,Nothing}}, ::Symbol, ::Boun",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/272
https://github.com/CliMA/Oceananigans.jl/pull/273:1392,Safety,detect,detected,1392,"Cassette.AbstractPass where T<:Union{Nothing, Cassette.Tag{N, X, E} where E where X where N<:Cassette.AbstractContextName} where M where N<:Cassette.AbstractContextName, Any...) in module Cassette at /home/alir_mit_edu/.julia/packages/Cassette/xggAf/src/overdub.jl:508 overwritten in module GPUifyLoops at /home/alir_mit_edu/.julia/packages/Cassette/xggAf/src/overdub.jl:508.; WARNING: Method definition recurse(Cassette.Context{N, M, T, P, B, H} where H<:Union{Cassette.DisableHooks, Nothing} where B<:Union{Nothing, Base.IdDict{Module, Base.Dict{Symbol, Cassette.BindingMeta}}} where P<:Cassette.AbstractPass where T<:Union{Nothing, Cassette.Tag{N, X, E} where E where X where N<:Cassette.AbstractContextName} where M where N<:Cassette.AbstractContextName, Any...) in module Cassette at /home/alir_mit_edu/.julia/packages/Cassette/xggAf/src/overdub.jl:521 overwritten in module GPUifyLoops at /home/alir_mit_edu/.julia/packages/Cassette/xggAf/src/overdub.jl:521.; CUDA-enabled GPU(s) detected:; CuDevice(0): Tesla V100-SXM2-16GB; [000.00%] Time: 0.0 / 604800.0... average wall clock time per iteration: 283.890 ms; [000.05%] Time: 300.0 / 604800.0... average wall clock time per iteration: 39.199 ms; [000.10%] Time: 600.0 / 604800.0... average wall clock time per iteration: 39.270 ms; [000.15%] Time: 900.0 / 604800.0... average wall clock time per iteration: 39.172 ms; [000.20%] Time: 1200.0 / 604800.0... average wall clock time per iteration: 39.167 ms; [000.25%] Time: 1500.0 / 604800.0... average wall clock time per iteration: 39.245 ms; [000.30%] Time: 1800.0 / 604800.0... average wall clock time per iteration: 39.119 ms; [000.35%] Time: 2100.0 / 604800.0... average wall clock time per iteration: 39.181 ms; [000.40%] Time: 2400.0 / 604800.0... average wall clock time per iteration: 39.246 ms; [000.45%] Time: 2700.0 / 604800.0... average wall clock time per iteration: 45.696 ms; [000.50%] Time: 3000.0 / 604800.0... average wall clock time per iteration: 40.170 ms; [000.55%] Time: 3",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/273
https://github.com/CliMA/Oceananigans.jl/pull/279:104,Testability,test,testing,104,This should speed up Appveyor builds which currently take forever. Also not sure how much we get out of testing x86/32-bit Windows... Helps with #89,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/279
https://github.com/CliMA/Oceananigans.jl/pull/280:51,Performance,perform,performance,51,"Right now only 1 benchmark job is run to check for performance regression, which is important seeing as sometimes we introduce rogue bugs that kill performance. cc @simonbyrne will this work with the Slurm CI/CliMA bot framework you've set up? Will be awesome to start using it. No MPI stuff yet but will probably add some soon.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/280
https://github.com/CliMA/Oceananigans.jl/pull/280:148,Performance,perform,performance,148,"Right now only 1 benchmark job is run to check for performance regression, which is important seeing as sometimes we introduce rogue bugs that kill performance. cc @simonbyrne will this work with the Slurm CI/CliMA bot framework you've set up? Will be awesome to start using it. No MPI stuff yet but will probably add some soon.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/280
https://github.com/CliMA/Oceananigans.jl/pull/280:17,Testability,benchmark,benchmark,17,"Right now only 1 benchmark job is run to check for performance regression, which is important seeing as sometimes we introduce rogue bugs that kill performance. cc @simonbyrne will this work with the Slurm CI/CliMA bot framework you've set up? Will be awesome to start using it. No MPI stuff yet but will probably add some soon.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/280
https://github.com/CliMA/Oceananigans.jl/pull/282:167,Modifiability,refactor,refactor,167,"Reopening a PR based on #261 and #263 which I reverted as it broke some of the examples we usually run, e.g. free convection. Before merging we should probably either refactor the examples to use the new boundary conditions API or come up with this `BoundaryConditionsWizard` that does everything for us.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/282
https://github.com/CliMA/Oceananigans.jl/pull/283:917,Deployability,release,release,917,"Strange that we don't have this already but this PR refactors the operators to be truly finite volume. By using multiple dispatch we only have one operator rather than having a different operator for each grid. The beautiful ϊ (`\iota\ddot`) now denotes interpolation. Thanks @sandreza!. Need to switch to using the `caa`, `afa`, etc. notation and introduce some composite operators from `closure_operators.jl`. Just opening this PR early so people can see what the new operators look like, get some feedback, etc. Once this PR is merged, implementing a vertically stretched grid will be easy, and implementing wall bounded directions should be as simple as defining something like; ```julia; Ay(i, j, k, grid) = ifelse(j == 0, 0, Δx(i, j, k, grid) * Δz(i, j, k, grid)); ```; but still thinking about the best way to dispatch on e.g. `DoublyPeriodicDomain`, `ChannelDomain`, `TriplyPeriodicDomain`, etc. I will also release v0.7.0 once this PR is merged. Resolves #115; Resolves #146 ; Resolves #469",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/283
https://github.com/CliMA/Oceananigans.jl/pull/283:52,Modifiability,refactor,refactors,52,"Strange that we don't have this already but this PR refactors the operators to be truly finite volume. By using multiple dispatch we only have one operator rather than having a different operator for each grid. The beautiful ϊ (`\iota\ddot`) now denotes interpolation. Thanks @sandreza!. Need to switch to using the `caa`, `afa`, etc. notation and introduce some composite operators from `closure_operators.jl`. Just opening this PR early so people can see what the new operators look like, get some feedback, etc. Once this PR is merged, implementing a vertically stretched grid will be easy, and implementing wall bounded directions should be as simple as defining something like; ```julia; Ay(i, j, k, grid) = ifelse(j == 0, 0, Δx(i, j, k, grid) * Δz(i, j, k, grid)); ```; but still thinking about the best way to dispatch on e.g. `DoublyPeriodicDomain`, `ChannelDomain`, `TriplyPeriodicDomain`, etc. I will also release v0.7.0 once this PR is merged. Resolves #115; Resolves #146 ; Resolves #469",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/283
https://github.com/CliMA/Oceananigans.jl/pull/283:501,Usability,feedback,feedback,501,"Strange that we don't have this already but this PR refactors the operators to be truly finite volume. By using multiple dispatch we only have one operator rather than having a different operator for each grid. The beautiful ϊ (`\iota\ddot`) now denotes interpolation. Thanks @sandreza!. Need to switch to using the `caa`, `afa`, etc. notation and introduce some composite operators from `closure_operators.jl`. Just opening this PR early so people can see what the new operators look like, get some feedback, etc. Once this PR is merged, implementing a vertically stretched grid will be easy, and implementing wall bounded directions should be as simple as defining something like; ```julia; Ay(i, j, k, grid) = ifelse(j == 0, 0, Δx(i, j, k, grid) * Δz(i, j, k, grid)); ```; but still thinking about the best way to dispatch on e.g. `DoublyPeriodicDomain`, `ChannelDomain`, `TriplyPeriodicDomain`, etc. I will also release v0.7.0 once this PR is merged. Resolves #115; Resolves #146 ; Resolves #469",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/283
https://github.com/CliMA/Oceananigans.jl/pull/283:649,Usability,simpl,simple,649,"Strange that we don't have this already but this PR refactors the operators to be truly finite volume. By using multiple dispatch we only have one operator rather than having a different operator for each grid. The beautiful ϊ (`\iota\ddot`) now denotes interpolation. Thanks @sandreza!. Need to switch to using the `caa`, `afa`, etc. notation and introduce some composite operators from `closure_operators.jl`. Just opening this PR early so people can see what the new operators look like, get some feedback, etc. Once this PR is merged, implementing a vertically stretched grid will be easy, and implementing wall bounded directions should be as simple as defining something like; ```julia; Ay(i, j, k, grid) = ifelse(j == 0, 0, Δx(i, j, k, grid) * Δz(i, j, k, grid)); ```; but still thinking about the best way to dispatch on e.g. `DoublyPeriodicDomain`, `ChannelDomain`, `TriplyPeriodicDomain`, etc. I will also release v0.7.0 once this PR is merged. Resolves #115; Resolves #146 ; Resolves #469",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/283
https://github.com/CliMA/Oceananigans.jl/issues/284:36,Deployability,install,install,36,"Today @qingli411 and I attempted to install `Oceananigans` on his laptop, but ran into a problem when the HDF5 compilation (through julia) stalled for something like 15 minutes. We were only able to proceed by completely removing the dependency of `Oceananigans` on HDF5 and NetCDF (after which we got the code to run!). I think we should consider moving heavy dependencies like HDF5 and NetCDF into separate packages (say, `OceananigansOutput.jl`) to make a simple barebones installation of `Oceananigans` quick, easy, and painless.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/284
https://github.com/CliMA/Oceananigans.jl/issues/284:476,Deployability,install,installation,476,"Today @qingli411 and I attempted to install `Oceananigans` on his laptop, but ran into a problem when the HDF5 compilation (through julia) stalled for something like 15 minutes. We were only able to proceed by completely removing the dependency of `Oceananigans` on HDF5 and NetCDF (after which we got the code to run!). I think we should consider moving heavy dependencies like HDF5 and NetCDF into separate packages (say, `OceananigansOutput.jl`) to make a simple barebones installation of `Oceananigans` quick, easy, and painless.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/284
https://github.com/CliMA/Oceananigans.jl/issues/284:234,Integrability,depend,dependency,234,"Today @qingli411 and I attempted to install `Oceananigans` on his laptop, but ran into a problem when the HDF5 compilation (through julia) stalled for something like 15 minutes. We were only able to proceed by completely removing the dependency of `Oceananigans` on HDF5 and NetCDF (after which we got the code to run!). I think we should consider moving heavy dependencies like HDF5 and NetCDF into separate packages (say, `OceananigansOutput.jl`) to make a simple barebones installation of `Oceananigans` quick, easy, and painless.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/284
https://github.com/CliMA/Oceananigans.jl/issues/284:361,Integrability,depend,dependencies,361,"Today @qingli411 and I attempted to install `Oceananigans` on his laptop, but ran into a problem when the HDF5 compilation (through julia) stalled for something like 15 minutes. We were only able to proceed by completely removing the dependency of `Oceananigans` on HDF5 and NetCDF (after which we got the code to run!). I think we should consider moving heavy dependencies like HDF5 and NetCDF into separate packages (say, `OceananigansOutput.jl`) to make a simple barebones installation of `Oceananigans` quick, easy, and painless.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/284
https://github.com/CliMA/Oceananigans.jl/issues/284:459,Usability,simpl,simple,459,"Today @qingli411 and I attempted to install `Oceananigans` on his laptop, but ran into a problem when the HDF5 compilation (through julia) stalled for something like 15 minutes. We were only able to proceed by completely removing the dependency of `Oceananigans` on HDF5 and NetCDF (after which we got the code to run!). I think we should consider moving heavy dependencies like HDF5 and NetCDF into separate packages (say, `OceananigansOutput.jl`) to make a simple barebones installation of `Oceananigans` quick, easy, and painless.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/284
https://github.com/CliMA/Oceananigans.jl/issues/285:297,Energy Efficiency,reduce,reduce,297,"The calls to `convert` here:. https://github.com/climate-machine/Oceananigans.jl/blob/40dbd96fd45a30867063c476b3eecbe13db1fb5c/src/grids.jl#L98. are unnecessary, because `convert` is called anyways due to the fact that the `eltype` of `RegularCartesianGrid` is specified a few lines below. We can reduce code noise by getting rid of them.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/285
https://github.com/CliMA/Oceananigans.jl/pull/289:43,Testability,benchmark,benchmarking,43,This PR just merges in @glwagner's closure benchmarking script. Should be useful in investigating how much shared memory can speed up the model while running constant Smagorinsky.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/289
https://github.com/CliMA/Oceananigans.jl/pull/290:725,Availability,mask,masks,725,"This PR introduces a new reentrant channel model type, the `ChannelModel`, which is periodic in x, has walls in the y-direction, and has the usual rigid lid at the top. It's just a regular `Model` but with no-flux boundary conditions in the y-direction on all fields. The halo regions are filled in appropriately to apply the free-slip boundary conditions. This is nice as we get a channel without having to change the operators or time-stepping at all. @jm-c has pointed out that things could get complicated with this approach when we get to implementing e.g. positivity-preserving advection schemes with having to fill the halo regions very frequently, but we agreed to cross that bridge when we get there. At that point, masks may turn out to be a better approach. It would be nice to have a solid physics test before merging this. Perhaps https://github.com/climate-machine/Oceananigans.jl/issues/100#issuecomment-483255199 would work, although we've had some issues setting up a flow in thermal wind balance (see PR #179). It might still work as an eyeball test. I will release a new minor version once this PR is merged. Resolves #100. Helps with #242 ; Helps with #258",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/290
https://github.com/CliMA/Oceananigans.jl/pull/290:1076,Deployability,release,release,1076,"This PR introduces a new reentrant channel model type, the `ChannelModel`, which is periodic in x, has walls in the y-direction, and has the usual rigid lid at the top. It's just a regular `Model` but with no-flux boundary conditions in the y-direction on all fields. The halo regions are filled in appropriately to apply the free-slip boundary conditions. This is nice as we get a channel without having to change the operators or time-stepping at all. @jm-c has pointed out that things could get complicated with this approach when we get to implementing e.g. positivity-preserving advection schemes with having to fill the halo regions very frequently, but we agreed to cross that bridge when we get there. At that point, masks may turn out to be a better approach. It would be nice to have a solid physics test before merging this. Perhaps https://github.com/climate-machine/Oceananigans.jl/issues/100#issuecomment-483255199 would work, although we've had some issues setting up a flow in thermal wind balance (see PR #179). It might still work as an eyeball test. I will release a new minor version once this PR is merged. Resolves #100. Helps with #242 ; Helps with #258",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/290
https://github.com/CliMA/Oceananigans.jl/pull/290:684,Integrability,bridg,bridge,684,"This PR introduces a new reentrant channel model type, the `ChannelModel`, which is periodic in x, has walls in the y-direction, and has the usual rigid lid at the top. It's just a regular `Model` but with no-flux boundary conditions in the y-direction on all fields. The halo regions are filled in appropriately to apply the free-slip boundary conditions. This is nice as we get a channel without having to change the operators or time-stepping at all. @jm-c has pointed out that things could get complicated with this approach when we get to implementing e.g. positivity-preserving advection schemes with having to fill the halo regions very frequently, but we agreed to cross that bridge when we get there. At that point, masks may turn out to be a better approach. It would be nice to have a solid physics test before merging this. Perhaps https://github.com/climate-machine/Oceananigans.jl/issues/100#issuecomment-483255199 would work, although we've had some issues setting up a flow in thermal wind balance (see PR #179). It might still work as an eyeball test. I will release a new minor version once this PR is merged. Resolves #100. Helps with #242 ; Helps with #258",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/290
https://github.com/CliMA/Oceananigans.jl/pull/290:810,Testability,test,test,810,"This PR introduces a new reentrant channel model type, the `ChannelModel`, which is periodic in x, has walls in the y-direction, and has the usual rigid lid at the top. It's just a regular `Model` but with no-flux boundary conditions in the y-direction on all fields. The halo regions are filled in appropriately to apply the free-slip boundary conditions. This is nice as we get a channel without having to change the operators or time-stepping at all. @jm-c has pointed out that things could get complicated with this approach when we get to implementing e.g. positivity-preserving advection schemes with having to fill the halo regions very frequently, but we agreed to cross that bridge when we get there. At that point, masks may turn out to be a better approach. It would be nice to have a solid physics test before merging this. Perhaps https://github.com/climate-machine/Oceananigans.jl/issues/100#issuecomment-483255199 would work, although we've had some issues setting up a flow in thermal wind balance (see PR #179). It might still work as an eyeball test. I will release a new minor version once this PR is merged. Resolves #100. Helps with #242 ; Helps with #258",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/290
https://github.com/CliMA/Oceananigans.jl/pull/290:1063,Testability,test,test,1063,"This PR introduces a new reentrant channel model type, the `ChannelModel`, which is periodic in x, has walls in the y-direction, and has the usual rigid lid at the top. It's just a regular `Model` but with no-flux boundary conditions in the y-direction on all fields. The halo regions are filled in appropriately to apply the free-slip boundary conditions. This is nice as we get a channel without having to change the operators or time-stepping at all. @jm-c has pointed out that things could get complicated with this approach when we get to implementing e.g. positivity-preserving advection schemes with having to fill the halo regions very frequently, but we agreed to cross that bridge when we get there. At that point, masks may turn out to be a better approach. It would be nice to have a solid physics test before merging this. Perhaps https://github.com/climate-machine/Oceananigans.jl/issues/100#issuecomment-483255199 would work, although we've had some issues setting up a flow in thermal wind balance (see PR #179). It might still work as an eyeball test. I will release a new minor version once this PR is merged. Resolves #100. Helps with #242 ; Helps with #258",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/290
https://github.com/CliMA/Oceananigans.jl/pull/291:582,Testability,test,test,582,"This PR implements a sponge layer to dampen waves at the bottom layer of the model, needed for seasonal cycle mixed layer simulations following the re-stratification process which seems to generate internal waves that grow unphysically large in amplitude (from PR #292). It's implemented by appending wave damping terms to the existing forcing functions. Not sure if this will work, but it's the ideal implementation I think. For now it's just a prototype. But the point is that if you want a sponge layer, you just call `add_sponge_layer!(model; damping_timescale)`. Still needs a test. cc @sandreza",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/291
https://github.com/CliMA/Oceananigans.jl/pull/293:163,Performance,perform,performance,163,Might not end up being merged but testing if using shared memory for the `calculate_interior_source_terms` kernel via GPUifyLoop's `@stencil` abstraction improves performance for register-heavy kernels. We can use #289 to benchmark. Reliant on https://github.com/vchuravy/GPUifyLoops.jl/issues/85.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/293
https://github.com/CliMA/Oceananigans.jl/pull/293:34,Testability,test,testing,34,Might not end up being merged but testing if using shared memory for the `calculate_interior_source_terms` kernel via GPUifyLoop's `@stencil` abstraction improves performance for register-heavy kernels. We can use #289 to benchmark. Reliant on https://github.com/vchuravy/GPUifyLoops.jl/issues/85.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/293
https://github.com/CliMA/Oceananigans.jl/pull/293:222,Testability,benchmark,benchmark,222,Might not end up being merged but testing if using shared memory for the `calculate_interior_source_terms` kernel via GPUifyLoop's `@stencil` abstraction improves performance for register-heavy kernels. We can use #289 to benchmark. Reliant on https://github.com/vchuravy/GPUifyLoops.jl/issues/85.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/293
https://github.com/CliMA/Oceananigans.jl/pull/294:100,Energy Efficiency,power,powerful,100,"Protoyping how we might dynamically append arbitrary forcing functions. This could provide a really powerful and concise API for configuring the model. Adding a sponge layer can be done in ~5 lines. I highly doubt this will be performant as is, especially as I'm appending closures with an arbitrary number of arguments. I'm not even sure if it's even possible to make this run fast and work on a GPU... We might have to compile something every time a new forcing function is created to move it away from `Main` and make it inline-able?. Initially the forcing is zero so Julia sees `Oceananigans.zero_func` which it presumably knows how to optimize away. But after adding an `add_ones(args...) = 1.0` forcing function it sees `(::getfield(Main, Symbol(""#new_Fu#3"")){typeof(add_ones),typeof(Oceananigans.zero_func)})` which lives in `Main`...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/294
https://github.com/CliMA/Oceananigans.jl/pull/294:129,Modifiability,config,configuring,129,"Protoyping how we might dynamically append arbitrary forcing functions. This could provide a really powerful and concise API for configuring the model. Adding a sponge layer can be done in ~5 lines. I highly doubt this will be performant as is, especially as I'm appending closures with an arbitrary number of arguments. I'm not even sure if it's even possible to make this run fast and work on a GPU... We might have to compile something every time a new forcing function is created to move it away from `Main` and make it inline-able?. Initially the forcing is zero so Julia sees `Oceananigans.zero_func` which it presumably knows how to optimize away. But after adding an `add_ones(args...) = 1.0` forcing function it sees `(::getfield(Main, Symbol(""#new_Fu#3"")){typeof(add_ones),typeof(Oceananigans.zero_func)})` which lives in `Main`...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/294
https://github.com/CliMA/Oceananigans.jl/pull/294:227,Performance,perform,performant,227,"Protoyping how we might dynamically append arbitrary forcing functions. This could provide a really powerful and concise API for configuring the model. Adding a sponge layer can be done in ~5 lines. I highly doubt this will be performant as is, especially as I'm appending closures with an arbitrary number of arguments. I'm not even sure if it's even possible to make this run fast and work on a GPU... We might have to compile something every time a new forcing function is created to move it away from `Main` and make it inline-able?. Initially the forcing is zero so Julia sees `Oceananigans.zero_func` which it presumably knows how to optimize away. But after adding an `add_ones(args...) = 1.0` forcing function it sees `(::getfield(Main, Symbol(""#new_Fu#3"")){typeof(add_ones),typeof(Oceananigans.zero_func)})` which lives in `Main`...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/294
https://github.com/CliMA/Oceananigans.jl/pull/294:640,Performance,optimiz,optimize,640,"Protoyping how we might dynamically append arbitrary forcing functions. This could provide a really powerful and concise API for configuring the model. Adding a sponge layer can be done in ~5 lines. I highly doubt this will be performant as is, especially as I'm appending closures with an arbitrary number of arguments. I'm not even sure if it's even possible to make this run fast and work on a GPU... We might have to compile something every time a new forcing function is created to move it away from `Main` and make it inline-able?. Initially the forcing is zero so Julia sees `Oceananigans.zero_func` which it presumably knows how to optimize away. But after adding an `add_ones(args...) = 1.0` forcing function it sees `(::getfield(Main, Symbol(""#new_Fu#3"")){typeof(add_ones),typeof(Oceananigans.zero_func)})` which lives in `Main`...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/294
https://github.com/CliMA/Oceananigans.jl/issues/295:147,Availability,ERROR,ERROR,147,"this line:. https://github.com/climate-machine/Oceananigans.jl/blob/8dacd119c2638d7034f8cb64a9ca56d721b9a7d7/src/models.jl#L57. throws . ```julia; ERROR: LoadError: ArgumentError: Cannot create a GPU model. No CUDA-enabled GPU was detected!; ```. when `HAVE_CUDA` is false. However, `HAVE_CUDA` is not really false when a device is 'not detected' (as far as I can tell), but rather throws an error when one of `CUDAdrv, CUDAnative, CuArrays` fails to load when `Oceananigans.jl` is built. A better error message might simply say that . ""One of `CUDAdrv, CUDAnative, CuArrays` threw an error at the time that `Oceananigans.jl` was built. If cuda is currently available, try running Pkg.build()."" . If that is, after all, the cause of the error. The issue is that its possible to have a device but not cuda, or to have a device but also some other issue with cuda libraries or julia packages that causes this error, or that cuda was not found *at some point in the past* when Oceananigans was built. We aren't actually detecting any device upon model instantiation, nor are we rechecking (however that would be done...) as far as I can tell.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/295
https://github.com/CliMA/Oceananigans.jl/issues/295:392,Availability,error,error,392,"this line:. https://github.com/climate-machine/Oceananigans.jl/blob/8dacd119c2638d7034f8cb64a9ca56d721b9a7d7/src/models.jl#L57. throws . ```julia; ERROR: LoadError: ArgumentError: Cannot create a GPU model. No CUDA-enabled GPU was detected!; ```. when `HAVE_CUDA` is false. However, `HAVE_CUDA` is not really false when a device is 'not detected' (as far as I can tell), but rather throws an error when one of `CUDAdrv, CUDAnative, CuArrays` fails to load when `Oceananigans.jl` is built. A better error message might simply say that . ""One of `CUDAdrv, CUDAnative, CuArrays` threw an error at the time that `Oceananigans.jl` was built. If cuda is currently available, try running Pkg.build()."" . If that is, after all, the cause of the error. The issue is that its possible to have a device but not cuda, or to have a device but also some other issue with cuda libraries or julia packages that causes this error, or that cuda was not found *at some point in the past* when Oceananigans was built. We aren't actually detecting any device upon model instantiation, nor are we rechecking (however that would be done...) as far as I can tell.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/295
https://github.com/CliMA/Oceananigans.jl/issues/295:498,Availability,error,error,498,"this line:. https://github.com/climate-machine/Oceananigans.jl/blob/8dacd119c2638d7034f8cb64a9ca56d721b9a7d7/src/models.jl#L57. throws . ```julia; ERROR: LoadError: ArgumentError: Cannot create a GPU model. No CUDA-enabled GPU was detected!; ```. when `HAVE_CUDA` is false. However, `HAVE_CUDA` is not really false when a device is 'not detected' (as far as I can tell), but rather throws an error when one of `CUDAdrv, CUDAnative, CuArrays` fails to load when `Oceananigans.jl` is built. A better error message might simply say that . ""One of `CUDAdrv, CUDAnative, CuArrays` threw an error at the time that `Oceananigans.jl` was built. If cuda is currently available, try running Pkg.build()."" . If that is, after all, the cause of the error. The issue is that its possible to have a device but not cuda, or to have a device but also some other issue with cuda libraries or julia packages that causes this error, or that cuda was not found *at some point in the past* when Oceananigans was built. We aren't actually detecting any device upon model instantiation, nor are we rechecking (however that would be done...) as far as I can tell.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/295
https://github.com/CliMA/Oceananigans.jl/issues/295:585,Availability,error,error,585,"this line:. https://github.com/climate-machine/Oceananigans.jl/blob/8dacd119c2638d7034f8cb64a9ca56d721b9a7d7/src/models.jl#L57. throws . ```julia; ERROR: LoadError: ArgumentError: Cannot create a GPU model. No CUDA-enabled GPU was detected!; ```. when `HAVE_CUDA` is false. However, `HAVE_CUDA` is not really false when a device is 'not detected' (as far as I can tell), but rather throws an error when one of `CUDAdrv, CUDAnative, CuArrays` fails to load when `Oceananigans.jl` is built. A better error message might simply say that . ""One of `CUDAdrv, CUDAnative, CuArrays` threw an error at the time that `Oceananigans.jl` was built. If cuda is currently available, try running Pkg.build()."" . If that is, after all, the cause of the error. The issue is that its possible to have a device but not cuda, or to have a device but also some other issue with cuda libraries or julia packages that causes this error, or that cuda was not found *at some point in the past* when Oceananigans was built. We aren't actually detecting any device upon model instantiation, nor are we rechecking (however that would be done...) as far as I can tell.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/295
https://github.com/CliMA/Oceananigans.jl/issues/295:658,Availability,avail,available,658,"this line:. https://github.com/climate-machine/Oceananigans.jl/blob/8dacd119c2638d7034f8cb64a9ca56d721b9a7d7/src/models.jl#L57. throws . ```julia; ERROR: LoadError: ArgumentError: Cannot create a GPU model. No CUDA-enabled GPU was detected!; ```. when `HAVE_CUDA` is false. However, `HAVE_CUDA` is not really false when a device is 'not detected' (as far as I can tell), but rather throws an error when one of `CUDAdrv, CUDAnative, CuArrays` fails to load when `Oceananigans.jl` is built. A better error message might simply say that . ""One of `CUDAdrv, CUDAnative, CuArrays` threw an error at the time that `Oceananigans.jl` was built. If cuda is currently available, try running Pkg.build()."" . If that is, after all, the cause of the error. The issue is that its possible to have a device but not cuda, or to have a device but also some other issue with cuda libraries or julia packages that causes this error, or that cuda was not found *at some point in the past* when Oceananigans was built. We aren't actually detecting any device upon model instantiation, nor are we rechecking (however that would be done...) as far as I can tell.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/295
https://github.com/CliMA/Oceananigans.jl/issues/295:737,Availability,error,error,737,"this line:. https://github.com/climate-machine/Oceananigans.jl/blob/8dacd119c2638d7034f8cb64a9ca56d721b9a7d7/src/models.jl#L57. throws . ```julia; ERROR: LoadError: ArgumentError: Cannot create a GPU model. No CUDA-enabled GPU was detected!; ```. when `HAVE_CUDA` is false. However, `HAVE_CUDA` is not really false when a device is 'not detected' (as far as I can tell), but rather throws an error when one of `CUDAdrv, CUDAnative, CuArrays` fails to load when `Oceananigans.jl` is built. A better error message might simply say that . ""One of `CUDAdrv, CUDAnative, CuArrays` threw an error at the time that `Oceananigans.jl` was built. If cuda is currently available, try running Pkg.build()."" . If that is, after all, the cause of the error. The issue is that its possible to have a device but not cuda, or to have a device but also some other issue with cuda libraries or julia packages that causes this error, or that cuda was not found *at some point in the past* when Oceananigans was built. We aren't actually detecting any device upon model instantiation, nor are we rechecking (however that would be done...) as far as I can tell.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/295
https://github.com/CliMA/Oceananigans.jl/issues/295:907,Availability,error,error,907,"this line:. https://github.com/climate-machine/Oceananigans.jl/blob/8dacd119c2638d7034f8cb64a9ca56d721b9a7d7/src/models.jl#L57. throws . ```julia; ERROR: LoadError: ArgumentError: Cannot create a GPU model. No CUDA-enabled GPU was detected!; ```. when `HAVE_CUDA` is false. However, `HAVE_CUDA` is not really false when a device is 'not detected' (as far as I can tell), but rather throws an error when one of `CUDAdrv, CUDAnative, CuArrays` fails to load when `Oceananigans.jl` is built. A better error message might simply say that . ""One of `CUDAdrv, CUDAnative, CuArrays` threw an error at the time that `Oceananigans.jl` was built. If cuda is currently available, try running Pkg.build()."" . If that is, after all, the cause of the error. The issue is that its possible to have a device but not cuda, or to have a device but also some other issue with cuda libraries or julia packages that causes this error, or that cuda was not found *at some point in the past* when Oceananigans was built. We aren't actually detecting any device upon model instantiation, nor are we rechecking (however that would be done...) as far as I can tell.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/295
https://github.com/CliMA/Oceananigans.jl/issues/295:504,Integrability,message,message,504,"this line:. https://github.com/climate-machine/Oceananigans.jl/blob/8dacd119c2638d7034f8cb64a9ca56d721b9a7d7/src/models.jl#L57. throws . ```julia; ERROR: LoadError: ArgumentError: Cannot create a GPU model. No CUDA-enabled GPU was detected!; ```. when `HAVE_CUDA` is false. However, `HAVE_CUDA` is not really false when a device is 'not detected' (as far as I can tell), but rather throws an error when one of `CUDAdrv, CUDAnative, CuArrays` fails to load when `Oceananigans.jl` is built. A better error message might simply say that . ""One of `CUDAdrv, CUDAnative, CuArrays` threw an error at the time that `Oceananigans.jl` was built. If cuda is currently available, try running Pkg.build()."" . If that is, after all, the cause of the error. The issue is that its possible to have a device but not cuda, or to have a device but also some other issue with cuda libraries or julia packages that causes this error, or that cuda was not found *at some point in the past* when Oceananigans was built. We aren't actually detecting any device upon model instantiation, nor are we rechecking (however that would be done...) as far as I can tell.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/295
https://github.com/CliMA/Oceananigans.jl/issues/295:154,Performance,Load,LoadError,154,"this line:. https://github.com/climate-machine/Oceananigans.jl/blob/8dacd119c2638d7034f8cb64a9ca56d721b9a7d7/src/models.jl#L57. throws . ```julia; ERROR: LoadError: ArgumentError: Cannot create a GPU model. No CUDA-enabled GPU was detected!; ```. when `HAVE_CUDA` is false. However, `HAVE_CUDA` is not really false when a device is 'not detected' (as far as I can tell), but rather throws an error when one of `CUDAdrv, CUDAnative, CuArrays` fails to load when `Oceananigans.jl` is built. A better error message might simply say that . ""One of `CUDAdrv, CUDAnative, CuArrays` threw an error at the time that `Oceananigans.jl` was built. If cuda is currently available, try running Pkg.build()."" . If that is, after all, the cause of the error. The issue is that its possible to have a device but not cuda, or to have a device but also some other issue with cuda libraries or julia packages that causes this error, or that cuda was not found *at some point in the past* when Oceananigans was built. We aren't actually detecting any device upon model instantiation, nor are we rechecking (however that would be done...) as far as I can tell.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/295
https://github.com/CliMA/Oceananigans.jl/issues/295:451,Performance,load,load,451,"this line:. https://github.com/climate-machine/Oceananigans.jl/blob/8dacd119c2638d7034f8cb64a9ca56d721b9a7d7/src/models.jl#L57. throws . ```julia; ERROR: LoadError: ArgumentError: Cannot create a GPU model. No CUDA-enabled GPU was detected!; ```. when `HAVE_CUDA` is false. However, `HAVE_CUDA` is not really false when a device is 'not detected' (as far as I can tell), but rather throws an error when one of `CUDAdrv, CUDAnative, CuArrays` fails to load when `Oceananigans.jl` is built. A better error message might simply say that . ""One of `CUDAdrv, CUDAnative, CuArrays` threw an error at the time that `Oceananigans.jl` was built. If cuda is currently available, try running Pkg.build()."" . If that is, after all, the cause of the error. The issue is that its possible to have a device but not cuda, or to have a device but also some other issue with cuda libraries or julia packages that causes this error, or that cuda was not found *at some point in the past* when Oceananigans was built. We aren't actually detecting any device upon model instantiation, nor are we rechecking (however that would be done...) as far as I can tell.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/295
https://github.com/CliMA/Oceananigans.jl/issues/295:231,Safety,detect,detected,231,"this line:. https://github.com/climate-machine/Oceananigans.jl/blob/8dacd119c2638d7034f8cb64a9ca56d721b9a7d7/src/models.jl#L57. throws . ```julia; ERROR: LoadError: ArgumentError: Cannot create a GPU model. No CUDA-enabled GPU was detected!; ```. when `HAVE_CUDA` is false. However, `HAVE_CUDA` is not really false when a device is 'not detected' (as far as I can tell), but rather throws an error when one of `CUDAdrv, CUDAnative, CuArrays` fails to load when `Oceananigans.jl` is built. A better error message might simply say that . ""One of `CUDAdrv, CUDAnative, CuArrays` threw an error at the time that `Oceananigans.jl` was built. If cuda is currently available, try running Pkg.build()."" . If that is, after all, the cause of the error. The issue is that its possible to have a device but not cuda, or to have a device but also some other issue with cuda libraries or julia packages that causes this error, or that cuda was not found *at some point in the past* when Oceananigans was built. We aren't actually detecting any device upon model instantiation, nor are we rechecking (however that would be done...) as far as I can tell.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/295
https://github.com/CliMA/Oceananigans.jl/issues/295:337,Safety,detect,detected,337,"this line:. https://github.com/climate-machine/Oceananigans.jl/blob/8dacd119c2638d7034f8cb64a9ca56d721b9a7d7/src/models.jl#L57. throws . ```julia; ERROR: LoadError: ArgumentError: Cannot create a GPU model. No CUDA-enabled GPU was detected!; ```. when `HAVE_CUDA` is false. However, `HAVE_CUDA` is not really false when a device is 'not detected' (as far as I can tell), but rather throws an error when one of `CUDAdrv, CUDAnative, CuArrays` fails to load when `Oceananigans.jl` is built. A better error message might simply say that . ""One of `CUDAdrv, CUDAnative, CuArrays` threw an error at the time that `Oceananigans.jl` was built. If cuda is currently available, try running Pkg.build()."" . If that is, after all, the cause of the error. The issue is that its possible to have a device but not cuda, or to have a device but also some other issue with cuda libraries or julia packages that causes this error, or that cuda was not found *at some point in the past* when Oceananigans was built. We aren't actually detecting any device upon model instantiation, nor are we rechecking (however that would be done...) as far as I can tell.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/295
https://github.com/CliMA/Oceananigans.jl/issues/295:1017,Safety,detect,detecting,1017,"this line:. https://github.com/climate-machine/Oceananigans.jl/blob/8dacd119c2638d7034f8cb64a9ca56d721b9a7d7/src/models.jl#L57. throws . ```julia; ERROR: LoadError: ArgumentError: Cannot create a GPU model. No CUDA-enabled GPU was detected!; ```. when `HAVE_CUDA` is false. However, `HAVE_CUDA` is not really false when a device is 'not detected' (as far as I can tell), but rather throws an error when one of `CUDAdrv, CUDAnative, CuArrays` fails to load when `Oceananigans.jl` is built. A better error message might simply say that . ""One of `CUDAdrv, CUDAnative, CuArrays` threw an error at the time that `Oceananigans.jl` was built. If cuda is currently available, try running Pkg.build()."" . If that is, after all, the cause of the error. The issue is that its possible to have a device but not cuda, or to have a device but also some other issue with cuda libraries or julia packages that causes this error, or that cuda was not found *at some point in the past* when Oceananigans was built. We aren't actually detecting any device upon model instantiation, nor are we rechecking (however that would be done...) as far as I can tell.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/295
https://github.com/CliMA/Oceananigans.jl/issues/295:518,Usability,simpl,simply,518,"this line:. https://github.com/climate-machine/Oceananigans.jl/blob/8dacd119c2638d7034f8cb64a9ca56d721b9a7d7/src/models.jl#L57. throws . ```julia; ERROR: LoadError: ArgumentError: Cannot create a GPU model. No CUDA-enabled GPU was detected!; ```. when `HAVE_CUDA` is false. However, `HAVE_CUDA` is not really false when a device is 'not detected' (as far as I can tell), but rather throws an error when one of `CUDAdrv, CUDAnative, CuArrays` fails to load when `Oceananigans.jl` is built. A better error message might simply say that . ""One of `CUDAdrv, CUDAnative, CuArrays` threw an error at the time that `Oceananigans.jl` was built. If cuda is currently available, try running Pkg.build()."" . If that is, after all, the cause of the error. The issue is that its possible to have a device but not cuda, or to have a device but also some other issue with cuda libraries or julia packages that causes this error, or that cuda was not found *at some point in the past* when Oceananigans was built. We aren't actually detecting any device upon model instantiation, nor are we rechecking (however that would be done...) as far as I can tell.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/295
https://github.com/CliMA/Oceananigans.jl/pull/297:36,Energy Efficiency,Adapt,Adaptive,36,"Copy pasting from @glwagner's fork. Adaptive time stepping with a `TimeStepWizard` that computes time steps for you. I just need to modify `time_step!` with a flag like `first_step_Euler=true` to take forward Euler steps at first iteration and when changing the time step, but with the ability to turn it off for tests where we actually don't want to do this. . I'll add some more docstrings and a couple of tests. cc @sandreza . Resolves #189",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/297
https://github.com/CliMA/Oceananigans.jl/pull/297:36,Modifiability,Adapt,Adaptive,36,"Copy pasting from @glwagner's fork. Adaptive time stepping with a `TimeStepWizard` that computes time steps for you. I just need to modify `time_step!` with a flag like `first_step_Euler=true` to take forward Euler steps at first iteration and when changing the time step, but with the ability to turn it off for tests where we actually don't want to do this. . I'll add some more docstrings and a couple of tests. cc @sandreza . Resolves #189",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/297
https://github.com/CliMA/Oceananigans.jl/pull/297:313,Testability,test,tests,313,"Copy pasting from @glwagner's fork. Adaptive time stepping with a `TimeStepWizard` that computes time steps for you. I just need to modify `time_step!` with a flag like `first_step_Euler=true` to take forward Euler steps at first iteration and when changing the time step, but with the ability to turn it off for tests where we actually don't want to do this. . I'll add some more docstrings and a couple of tests. cc @sandreza . Resolves #189",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/297
https://github.com/CliMA/Oceananigans.jl/pull/297:408,Testability,test,tests,408,"Copy pasting from @glwagner's fork. Adaptive time stepping with a `TimeStepWizard` that computes time steps for you. I just need to modify `time_step!` with a flag like `first_step_Euler=true` to take forward Euler steps at first iteration and when changing the time step, but with the ability to turn it off for tests where we actually don't want to do this. . I'll add some more docstrings and a couple of tests. cc @sandreza . Resolves #189",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/297
https://github.com/CliMA/Oceananigans.jl/pull/301:18,Testability,test,test,18,"Partly an eyeball test for the channel, partly a source of new movies!. ![channel_plot_300000_cropped](https://user-images.githubusercontent.com/20099589/60388805-7b822c80-9a84-11e9-9fb6-05aca5a268b8.png). Doesn't look horrible but probably needs higher more grid points, lower grid cell aspect ratio, better advection scheme, and/or LES closure.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/301
https://github.com/CliMA/Oceananigans.jl/pull/302:8,Deployability,integrat,integrates,8,"This PR integrates Tim's changes from the GPU hackathon. By using dynamic launch configurations and splitting up the interior source term calculation kernel (+ https://github.com/JuliaGPU/CUDAnative.jl/pull/417) we get a pretty sweet ~25% overall speedup (so the most expensive kernel which was a bottleneck is sped up by ~40%). Needs https://github.com/vchuravy/GPUifyLoops.jl/pull/90 to work for now. cc @maleadt Sorry it took so long for me to merge these improvements. Actually resolves #64 . ```; ──────────────────────────────────────────────────────────────────────────────────────; Oceananigans.jl static ocean bench... Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 409s / 28.8% 15.0GiB / 0.50% . Section ncalls time %tot avg alloc %tot avg; ─────────────────────────────────────────────────────────────────────────────────────; 256×256×256 (CPU, Float64) 10 56.0s 47.7% 5.60s 292KiB 0.37% 29.2KiB; 256×256×256 (CPU, Float32) 10 47.2s 40.2% 4.72s 227KiB 0.29% 22.7KiB; 128×128×128 (CPU, Float32) 10 5.91s 5.03% 591ms 227KiB 0.29% 22.7KiB; 128×128×128 (CPU, Float64) 10 5.87s 5.00% 587ms 292KiB 0.37% 29.2KiB; 64× 64× 64 (CPU, Float64) 10 803ms 0.68% 80.3ms 292KiB 0.37% 29.2KiB; 64× 64× 64 (CPU, Float32) 10 724ms 0.62% 72.4ms 227KiB 0.29% 22.7KiB; 256×256×256 (GPU, Float64) 10 309ms 0.26% 30.9ms 9.83MiB 12.9% 0.98MiB; 256×256×256 (GPU, Float32) 10 239ms 0.20% 23.9ms 8.70MiB 11.4% 891KiB; 32× 32× 32 (CPU, Float64) 10 86.6ms 0.07% 8.66ms 292KiB 0.37% 29.2KiB; 32× 32× 32 (CPU, Float32) 10 61.0ms 0.05% 6.10ms 227KiB 0.29% 22.7KiB; 32× 32× 32 (GPU, Float64) 10 50.7ms 0.04% 5.07ms 9.83MiB 12.9% 0.98MiB; 64× 64× 64 (GPU, Float64) 10 49.7ms 0.04% 4.97ms 9.83MiB 12.9% 0.98MiB; 128×128×128 (GPU, Float64) 10 46.9ms 0.04% 4.69ms 9.83MiB 12.9% 0.98MiB; 32× 32× 32 (GPU, Float32) 10 44.8ms 0.04% 4.48ms 8.70MiB 11.4% 891KiB; 128×128×128 (GPU, Float32) 10 40.6ms 0.03% 4.06ms 8.70MiB 11.4% 891KiB; 64× 64× 64 (GPU, Float32) 10 32.6ms 0.03% 3.26ms 8.70MiB 11.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/302
https://github.com/CliMA/Oceananigans.jl/pull/302:81,Deployability,configurat,configurations,81,"This PR integrates Tim's changes from the GPU hackathon. By using dynamic launch configurations and splitting up the interior source term calculation kernel (+ https://github.com/JuliaGPU/CUDAnative.jl/pull/417) we get a pretty sweet ~25% overall speedup (so the most expensive kernel which was a bottleneck is sped up by ~40%). Needs https://github.com/vchuravy/GPUifyLoops.jl/pull/90 to work for now. cc @maleadt Sorry it took so long for me to merge these improvements. Actually resolves #64 . ```; ──────────────────────────────────────────────────────────────────────────────────────; Oceananigans.jl static ocean bench... Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 409s / 28.8% 15.0GiB / 0.50% . Section ncalls time %tot avg alloc %tot avg; ─────────────────────────────────────────────────────────────────────────────────────; 256×256×256 (CPU, Float64) 10 56.0s 47.7% 5.60s 292KiB 0.37% 29.2KiB; 256×256×256 (CPU, Float32) 10 47.2s 40.2% 4.72s 227KiB 0.29% 22.7KiB; 128×128×128 (CPU, Float32) 10 5.91s 5.03% 591ms 227KiB 0.29% 22.7KiB; 128×128×128 (CPU, Float64) 10 5.87s 5.00% 587ms 292KiB 0.37% 29.2KiB; 64× 64× 64 (CPU, Float64) 10 803ms 0.68% 80.3ms 292KiB 0.37% 29.2KiB; 64× 64× 64 (CPU, Float32) 10 724ms 0.62% 72.4ms 227KiB 0.29% 22.7KiB; 256×256×256 (GPU, Float64) 10 309ms 0.26% 30.9ms 9.83MiB 12.9% 0.98MiB; 256×256×256 (GPU, Float32) 10 239ms 0.20% 23.9ms 8.70MiB 11.4% 891KiB; 32× 32× 32 (CPU, Float64) 10 86.6ms 0.07% 8.66ms 292KiB 0.37% 29.2KiB; 32× 32× 32 (CPU, Float32) 10 61.0ms 0.05% 6.10ms 227KiB 0.29% 22.7KiB; 32× 32× 32 (GPU, Float64) 10 50.7ms 0.04% 5.07ms 9.83MiB 12.9% 0.98MiB; 64× 64× 64 (GPU, Float64) 10 49.7ms 0.04% 4.97ms 9.83MiB 12.9% 0.98MiB; 128×128×128 (GPU, Float64) 10 46.9ms 0.04% 4.69ms 9.83MiB 12.9% 0.98MiB; 32× 32× 32 (GPU, Float32) 10 44.8ms 0.04% 4.48ms 8.70MiB 11.4% 891KiB; 128×128×128 (GPU, Float32) 10 40.6ms 0.03% 4.06ms 8.70MiB 11.4% 891KiB; 64× 64× 64 (GPU, Float32) 10 32.6ms 0.03% 3.26ms 8.70MiB 11.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/302
https://github.com/CliMA/Oceananigans.jl/pull/302:8,Integrability,integrat,integrates,8,"This PR integrates Tim's changes from the GPU hackathon. By using dynamic launch configurations and splitting up the interior source term calculation kernel (+ https://github.com/JuliaGPU/CUDAnative.jl/pull/417) we get a pretty sweet ~25% overall speedup (so the most expensive kernel which was a bottleneck is sped up by ~40%). Needs https://github.com/vchuravy/GPUifyLoops.jl/pull/90 to work for now. cc @maleadt Sorry it took so long for me to merge these improvements. Actually resolves #64 . ```; ──────────────────────────────────────────────────────────────────────────────────────; Oceananigans.jl static ocean bench... Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 409s / 28.8% 15.0GiB / 0.50% . Section ncalls time %tot avg alloc %tot avg; ─────────────────────────────────────────────────────────────────────────────────────; 256×256×256 (CPU, Float64) 10 56.0s 47.7% 5.60s 292KiB 0.37% 29.2KiB; 256×256×256 (CPU, Float32) 10 47.2s 40.2% 4.72s 227KiB 0.29% 22.7KiB; 128×128×128 (CPU, Float32) 10 5.91s 5.03% 591ms 227KiB 0.29% 22.7KiB; 128×128×128 (CPU, Float64) 10 5.87s 5.00% 587ms 292KiB 0.37% 29.2KiB; 64× 64× 64 (CPU, Float64) 10 803ms 0.68% 80.3ms 292KiB 0.37% 29.2KiB; 64× 64× 64 (CPU, Float32) 10 724ms 0.62% 72.4ms 227KiB 0.29% 22.7KiB; 256×256×256 (GPU, Float64) 10 309ms 0.26% 30.9ms 9.83MiB 12.9% 0.98MiB; 256×256×256 (GPU, Float32) 10 239ms 0.20% 23.9ms 8.70MiB 11.4% 891KiB; 32× 32× 32 (CPU, Float64) 10 86.6ms 0.07% 8.66ms 292KiB 0.37% 29.2KiB; 32× 32× 32 (CPU, Float32) 10 61.0ms 0.05% 6.10ms 227KiB 0.29% 22.7KiB; 32× 32× 32 (GPU, Float64) 10 50.7ms 0.04% 5.07ms 9.83MiB 12.9% 0.98MiB; 64× 64× 64 (GPU, Float64) 10 49.7ms 0.04% 4.97ms 9.83MiB 12.9% 0.98MiB; 128×128×128 (GPU, Float64) 10 46.9ms 0.04% 4.69ms 9.83MiB 12.9% 0.98MiB; 32× 32× 32 (GPU, Float32) 10 44.8ms 0.04% 4.48ms 8.70MiB 11.4% 891KiB; 128×128×128 (GPU, Float32) 10 40.6ms 0.03% 4.06ms 8.70MiB 11.4% 891KiB; 64× 64× 64 (GPU, Float32) 10 32.6ms 0.03% 3.26ms 8.70MiB 11.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/302
https://github.com/CliMA/Oceananigans.jl/pull/302:81,Modifiability,config,configurations,81,"This PR integrates Tim's changes from the GPU hackathon. By using dynamic launch configurations and splitting up the interior source term calculation kernel (+ https://github.com/JuliaGPU/CUDAnative.jl/pull/417) we get a pretty sweet ~25% overall speedup (so the most expensive kernel which was a bottleneck is sped up by ~40%). Needs https://github.com/vchuravy/GPUifyLoops.jl/pull/90 to work for now. cc @maleadt Sorry it took so long for me to merge these improvements. Actually resolves #64 . ```; ──────────────────────────────────────────────────────────────────────────────────────; Oceananigans.jl static ocean bench... Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 409s / 28.8% 15.0GiB / 0.50% . Section ncalls time %tot avg alloc %tot avg; ─────────────────────────────────────────────────────────────────────────────────────; 256×256×256 (CPU, Float64) 10 56.0s 47.7% 5.60s 292KiB 0.37% 29.2KiB; 256×256×256 (CPU, Float32) 10 47.2s 40.2% 4.72s 227KiB 0.29% 22.7KiB; 128×128×128 (CPU, Float32) 10 5.91s 5.03% 591ms 227KiB 0.29% 22.7KiB; 128×128×128 (CPU, Float64) 10 5.87s 5.00% 587ms 292KiB 0.37% 29.2KiB; 64× 64× 64 (CPU, Float64) 10 803ms 0.68% 80.3ms 292KiB 0.37% 29.2KiB; 64× 64× 64 (CPU, Float32) 10 724ms 0.62% 72.4ms 227KiB 0.29% 22.7KiB; 256×256×256 (GPU, Float64) 10 309ms 0.26% 30.9ms 9.83MiB 12.9% 0.98MiB; 256×256×256 (GPU, Float32) 10 239ms 0.20% 23.9ms 8.70MiB 11.4% 891KiB; 32× 32× 32 (CPU, Float64) 10 86.6ms 0.07% 8.66ms 292KiB 0.37% 29.2KiB; 32× 32× 32 (CPU, Float32) 10 61.0ms 0.05% 6.10ms 227KiB 0.29% 22.7KiB; 32× 32× 32 (GPU, Float64) 10 50.7ms 0.04% 5.07ms 9.83MiB 12.9% 0.98MiB; 64× 64× 64 (GPU, Float64) 10 49.7ms 0.04% 4.97ms 9.83MiB 12.9% 0.98MiB; 128×128×128 (GPU, Float64) 10 46.9ms 0.04% 4.69ms 9.83MiB 12.9% 0.98MiB; 32× 32× 32 (GPU, Float32) 10 44.8ms 0.04% 4.48ms 8.70MiB 11.4% 891KiB; 128×128×128 (GPU, Float32) 10 40.6ms 0.03% 4.06ms 8.70MiB 11.4% 891KiB; 64× 64× 64 (GPU, Float32) 10 32.6ms 0.03% 3.26ms 8.70MiB 11.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/302
https://github.com/CliMA/Oceananigans.jl/pull/302:297,Performance,bottleneck,bottleneck,297,"This PR integrates Tim's changes from the GPU hackathon. By using dynamic launch configurations and splitting up the interior source term calculation kernel (+ https://github.com/JuliaGPU/CUDAnative.jl/pull/417) we get a pretty sweet ~25% overall speedup (so the most expensive kernel which was a bottleneck is sped up by ~40%). Needs https://github.com/vchuravy/GPUifyLoops.jl/pull/90 to work for now. cc @maleadt Sorry it took so long for me to merge these improvements. Actually resolves #64 . ```; ──────────────────────────────────────────────────────────────────────────────────────; Oceananigans.jl static ocean bench... Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 409s / 28.8% 15.0GiB / 0.50% . Section ncalls time %tot avg alloc %tot avg; ─────────────────────────────────────────────────────────────────────────────────────; 256×256×256 (CPU, Float64) 10 56.0s 47.7% 5.60s 292KiB 0.37% 29.2KiB; 256×256×256 (CPU, Float32) 10 47.2s 40.2% 4.72s 227KiB 0.29% 22.7KiB; 128×128×128 (CPU, Float32) 10 5.91s 5.03% 591ms 227KiB 0.29% 22.7KiB; 128×128×128 (CPU, Float64) 10 5.87s 5.00% 587ms 292KiB 0.37% 29.2KiB; 64× 64× 64 (CPU, Float64) 10 803ms 0.68% 80.3ms 292KiB 0.37% 29.2KiB; 64× 64× 64 (CPU, Float32) 10 724ms 0.62% 72.4ms 227KiB 0.29% 22.7KiB; 256×256×256 (GPU, Float64) 10 309ms 0.26% 30.9ms 9.83MiB 12.9% 0.98MiB; 256×256×256 (GPU, Float32) 10 239ms 0.20% 23.9ms 8.70MiB 11.4% 891KiB; 32× 32× 32 (CPU, Float64) 10 86.6ms 0.07% 8.66ms 292KiB 0.37% 29.2KiB; 32× 32× 32 (CPU, Float32) 10 61.0ms 0.05% 6.10ms 227KiB 0.29% 22.7KiB; 32× 32× 32 (GPU, Float64) 10 50.7ms 0.04% 5.07ms 9.83MiB 12.9% 0.98MiB; 64× 64× 64 (GPU, Float64) 10 49.7ms 0.04% 4.97ms 9.83MiB 12.9% 0.98MiB; 128×128×128 (GPU, Float64) 10 46.9ms 0.04% 4.69ms 9.83MiB 12.9% 0.98MiB; 32× 32× 32 (GPU, Float32) 10 44.8ms 0.04% 4.48ms 8.70MiB 11.4% 891KiB; 128×128×128 (GPU, Float32) 10 40.6ms 0.03% 4.06ms 8.70MiB 11.4% 891KiB; 64× 64× 64 (GPU, Float32) 10 32.6ms 0.03% 3.26ms 8.70MiB 11.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/302
https://github.com/CliMA/Oceananigans.jl/pull/306:30,Deployability,integrat,integrate,30,"This PR aims to introduce and integrate Poisson solvers for vertically stretched grids developed by @christophernhill and @maleadt. Once this is merged alongside with PR #283 we should be able to support vertically stretched grid. For PPN boundary conditions, the system is solved for by eigenvalue-eigenvector factorization via FFTs in the horizontal and we end up with `Nx*Ny` tridiagonal systems, one for each column so they can be solved in parallel. We might be able to speed up the already fast tridiagonal solve via cyclic reduction. For PNN boundary conditions, it should work if we use an FFT in the x and a DCT in the y. So far I have a working 1D solver. The two tricks that had to be made were:; 1. @christophernhill figured out that we need to stop the algorithm once a zero eigenvalue is reached. This should only occur at the last element for our tridiagonal systems.; 2. There are `Nz+1` faces in the vertical but we only keep track of the first `Nz`. The tridiagonal system needs to explicitly account for all `Nz+1` faces. Thus we impose the staggered Neumann boundary conditions at `k=Nz+1` and the (Nz+1)th entry of right-hand-side is zero. (Chris probably told me this but I forgot...) Previously, the DCT did this for us as all the eigenfunctions satisfied the boundary condition anyways. I tested it against our existing solver but it doesn't work for variable dz yet. Not sure if it's because of my implementation of the Laplacian in PR #283 or because I discretized the vertical derivative incorrectly here. Just opening this PR early so everyone's in the loop. I'm not 100% sure whether we will be able to utilize cyclic reduction:; * I think you need a symmetric tridiagonal system (or at least block-symmetric) which we don't have when the grid is vertically stretched. Maybe this is a sign that I discretized things wrong?; * It can be modified for Neumann boundary conditions (which break the symmetry on the first and last rows) but in this case it seems cyclic reductio",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/306
https://github.com/CliMA/Oceananigans.jl/pull/306:2382,Energy Efficiency,power,powers,2382,"ur existing solver but it doesn't work for variable dz yet. Not sure if it's because of my implementation of the Laplacian in PR #283 or because I discretized the vertical derivative incorrectly here. Just opening this PR early so everyone's in the loop. I'm not 100% sure whether we will be able to utilize cyclic reduction:; * I think you need a symmetric tridiagonal system (or at least block-symmetric) which we don't have when the grid is vertically stretched. Maybe this is a sign that I discretized things wrong?; * It can be modified for Neumann boundary conditions (which break the symmetry on the first and last rows) but in this case it seems cyclic reduction must be applied recursively `m+1` times for a system of size `Nz = 2^m + 1`. The optimal number of cyclic reductions is `log2(log2(Nz))` so it's possible that we don't gain much. There may also be numerical accuracy issues with taking too many cyclic reduction steps. Some thoughts:; * The batched cyclic reduction solver @maleadt developed only works for systems sizes that are powers of 2. As we need to solve a system of `Nz+1` equations, this means models with `2^m - 1` vertical levels will be the most efficient. If we can use it here, then we might need a non-cyclic reduction solver for models without `2^m - 1` vertical levels.; * Probably not within this scope of this PR, but this solver should work on CPUs and GPUs and will eliminate the need for two different solvers, so we can probably unify solvers. We may still want to use cyclic reduction wherever we can. We should be able to use it for uniform vertical spacing and `Nz = 2^m - 1`. @maleadt's implementation was ~3x faster than the cuSPARSE implementation and ~22x faster than the serial implementation, so it would be a huge speedup. cc @sandreza as I might ask you questions about this. This work is based off:; https://gist.github.com/christophernhill/8952075d6e95df28adf36f5dff64115a; https://gist.github.com/christophernhill/a43317694c6d65ecd27758c1bdcd",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/306
https://github.com/CliMA/Oceananigans.jl/pull/306:2511,Energy Efficiency,efficient,efficient,2511,"acian in PR #283 or because I discretized the vertical derivative incorrectly here. Just opening this PR early so everyone's in the loop. I'm not 100% sure whether we will be able to utilize cyclic reduction:; * I think you need a symmetric tridiagonal system (or at least block-symmetric) which we don't have when the grid is vertically stretched. Maybe this is a sign that I discretized things wrong?; * It can be modified for Neumann boundary conditions (which break the symmetry on the first and last rows) but in this case it seems cyclic reduction must be applied recursively `m+1` times for a system of size `Nz = 2^m + 1`. The optimal number of cyclic reductions is `log2(log2(Nz))` so it's possible that we don't gain much. There may also be numerical accuracy issues with taking too many cyclic reduction steps. Some thoughts:; * The batched cyclic reduction solver @maleadt developed only works for systems sizes that are powers of 2. As we need to solve a system of `Nz+1` equations, this means models with `2^m - 1` vertical levels will be the most efficient. If we can use it here, then we might need a non-cyclic reduction solver for models without `2^m - 1` vertical levels.; * Probably not within this scope of this PR, but this solver should work on CPUs and GPUs and will eliminate the need for two different solvers, so we can probably unify solvers. We may still want to use cyclic reduction wherever we can. We should be able to use it for uniform vertical spacing and `Nz = 2^m - 1`. @maleadt's implementation was ~3x faster than the cuSPARSE implementation and ~22x faster than the serial implementation, so it would be a huge speedup. cc @sandreza as I might ask you questions about this. This work is based off:; https://gist.github.com/christophernhill/8952075d6e95df28adf36f5dff64115a; https://gist.github.com/christophernhill/a43317694c6d65ecd27758c1bdcdf3f1; https://gist.github.com/maleadt/1ec91b3b12ede9898958c95596cabe8b. Resolves #46; Helps with #47; Helps with #211",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/306
https://github.com/CliMA/Oceananigans.jl/pull/306:30,Integrability,integrat,integrate,30,"This PR aims to introduce and integrate Poisson solvers for vertically stretched grids developed by @christophernhill and @maleadt. Once this is merged alongside with PR #283 we should be able to support vertically stretched grid. For PPN boundary conditions, the system is solved for by eigenvalue-eigenvector factorization via FFTs in the horizontal and we end up with `Nx*Ny` tridiagonal systems, one for each column so they can be solved in parallel. We might be able to speed up the already fast tridiagonal solve via cyclic reduction. For PNN boundary conditions, it should work if we use an FFT in the x and a DCT in the y. So far I have a working 1D solver. The two tricks that had to be made were:; 1. @christophernhill figured out that we need to stop the algorithm once a zero eigenvalue is reached. This should only occur at the last element for our tridiagonal systems.; 2. There are `Nz+1` faces in the vertical but we only keep track of the first `Nz`. The tridiagonal system needs to explicitly account for all `Nz+1` faces. Thus we impose the staggered Neumann boundary conditions at `k=Nz+1` and the (Nz+1)th entry of right-hand-side is zero. (Chris probably told me this but I forgot...) Previously, the DCT did this for us as all the eigenfunctions satisfied the boundary condition anyways. I tested it against our existing solver but it doesn't work for variable dz yet. Not sure if it's because of my implementation of the Laplacian in PR #283 or because I discretized the vertical derivative incorrectly here. Just opening this PR early so everyone's in the loop. I'm not 100% sure whether we will be able to utilize cyclic reduction:; * I think you need a symmetric tridiagonal system (or at least block-symmetric) which we don't have when the grid is vertically stretched. Maybe this is a sign that I discretized things wrong?; * It can be modified for Neumann boundary conditions (which break the symmetry on the first and last rows) but in this case it seems cyclic reductio",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/306
https://github.com/CliMA/Oceananigans.jl/pull/306:1375,Modifiability,variab,variable,1375,"l and we end up with `Nx*Ny` tridiagonal systems, one for each column so they can be solved in parallel. We might be able to speed up the already fast tridiagonal solve via cyclic reduction. For PNN boundary conditions, it should work if we use an FFT in the x and a DCT in the y. So far I have a working 1D solver. The two tricks that had to be made were:; 1. @christophernhill figured out that we need to stop the algorithm once a zero eigenvalue is reached. This should only occur at the last element for our tridiagonal systems.; 2. There are `Nz+1` faces in the vertical but we only keep track of the first `Nz`. The tridiagonal system needs to explicitly account for all `Nz+1` faces. Thus we impose the staggered Neumann boundary conditions at `k=Nz+1` and the (Nz+1)th entry of right-hand-side is zero. (Chris probably told me this but I forgot...) Previously, the DCT did this for us as all the eigenfunctions satisfied the boundary condition anyways. I tested it against our existing solver but it doesn't work for variable dz yet. Not sure if it's because of my implementation of the Laplacian in PR #283 or because I discretized the vertical derivative incorrectly here. Just opening this PR early so everyone's in the loop. I'm not 100% sure whether we will be able to utilize cyclic reduction:; * I think you need a symmetric tridiagonal system (or at least block-symmetric) which we don't have when the grid is vertically stretched. Maybe this is a sign that I discretized things wrong?; * It can be modified for Neumann boundary conditions (which break the symmetry on the first and last rows) but in this case it seems cyclic reduction must be applied recursively `m+1` times for a system of size `Nz = 2^m + 1`. The optimal number of cyclic reductions is `log2(log2(Nz))` so it's possible that we don't gain much. There may also be numerical accuracy issues with taking too many cyclic reduction steps. Some thoughts:; * The batched cyclic reduction solver @maleadt developed only wo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/306
https://github.com/CliMA/Oceananigans.jl/pull/306:1313,Testability,test,tested,1313,"l and we end up with `Nx*Ny` tridiagonal systems, one for each column so they can be solved in parallel. We might be able to speed up the already fast tridiagonal solve via cyclic reduction. For PNN boundary conditions, it should work if we use an FFT in the x and a DCT in the y. So far I have a working 1D solver. The two tricks that had to be made were:; 1. @christophernhill figured out that we need to stop the algorithm once a zero eigenvalue is reached. This should only occur at the last element for our tridiagonal systems.; 2. There are `Nz+1` faces in the vertical but we only keep track of the first `Nz`. The tridiagonal system needs to explicitly account for all `Nz+1` faces. Thus we impose the staggered Neumann boundary conditions at `k=Nz+1` and the (Nz+1)th entry of right-hand-side is zero. (Chris probably told me this but I forgot...) Previously, the DCT did this for us as all the eigenfunctions satisfied the boundary condition anyways. I tested it against our existing solver but it doesn't work for variable dz yet. Not sure if it's because of my implementation of the Laplacian in PR #283 or because I discretized the vertical derivative incorrectly here. Just opening this PR early so everyone's in the loop. I'm not 100% sure whether we will be able to utilize cyclic reduction:; * I think you need a symmetric tridiagonal system (or at least block-symmetric) which we don't have when the grid is vertically stretched. Maybe this is a sign that I discretized things wrong?; * It can be modified for Neumann boundary conditions (which break the symmetry on the first and last rows) but in this case it seems cyclic reduction must be applied recursively `m+1` times for a system of size `Nz = 2^m + 1`. The optimal number of cyclic reductions is `log2(log2(Nz))` so it's possible that we don't gain much. There may also be numerical accuracy issues with taking too many cyclic reduction steps. Some thoughts:; * The batched cyclic reduction solver @maleadt developed only wo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/306
https://github.com/CliMA/Oceananigans.jl/pull/308:107,Availability,down,down,107,"Forgot to use dynamic launch configs for the `calculate_G*` kernels. But, hmmm, this actually slows things down a bit... ```; ─────────────────────────────────────────────────────────────────────────────────────; Oceananigans.jl static ocean bench... Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 247s / 29.9% 14.9GiB / 0.56% . Section ncalls time %tot avg alloc %tot avg; ─────────────────────────────────────────────────────────────────────────────────────; 256×256×256 (CPU, Float64) 10 34.0s 46.1% 3.40s 292KiB 0.34% 29.2KiB; 256×256×256 (CPU, Float32) 10 30.5s 41.4% 3.05s 227KiB 0.26% 22.7KiB; 128×128×128 (CPU, Float64) 10 3.94s 5.35% 394ms 292KiB 0.34% 29.2KiB; 128×128×128 (CPU, Float32) 10 3.54s 4.80% 354ms 227KiB 0.26% 22.7KiB; 64× 64× 64 (CPU, Float64) 10 417ms 0.57% 41.7ms 292KiB 0.34% 29.2KiB; 64× 64× 64 (CPU, Float32) 10 406ms 0.55% 40.6ms 227KiB 0.26% 22.7KiB; 256×256×256 (GPU, Float64) 10 337ms 0.46% 33.7ms 11.0MiB 13.0% 1.10MiB; 256×256×256 (GPU, Float32) 10 254ms 0.34% 25.4ms 9.62MiB 11.4% 0.96MiB; 32× 32× 32 (CPU, Float64) 10 52.6ms 0.07% 5.26ms 292KiB 0.34% 29.2KiB; 128×128×128 (GPU, Float64) 10 47.3ms 0.06% 4.73ms 11.0MiB 13.0% 1.10MiB; 32× 32× 32 (CPU, Float32) 10 46.9ms 0.06% 4.69ms 227KiB 0.26% 22.7KiB; 128×128×128 (GPU, Float32) 10 36.4ms 0.05% 3.64ms 9.62MiB 11.4% 0.96MiB; 32× 32× 32 (GPU, Float64) 10 26.6ms 0.04% 2.66ms 11.0MiB 13.0% 1.10MiB; 32× 32× 32 (GPU, Float32) 10 24.6ms 0.03% 2.46ms 9.61MiB 11.4% 0.96MiB; 64× 64× 64 (GPU, Float64) 10 24.6ms 0.03% 2.46ms 11.0MiB 13.0% 1.10MiB; 64× 64× 64 (GPU, Float32) 10 22.6ms 0.03% 2.26ms 9.62MiB 11.4% 0.96MiB; ─────────────────────────────────────────────────────────────────────────────────────. CPU Float64 -> Float32 speedup:; 32× 32× 32: 1.122; 64× 64× 64: 1.027; 128×128×128: 1.114; 256×256×256: 1.114. GPU Float64 -> Float32 speedup:; 32× 32× 32: 1.081; 64× 64× 64: 1.086; 128×128×128: 1.301; 256×256×256: 1.326. CPU -> GPU speedup:; 32× 32× 32 (Float32): 1.903; 32×",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/308
https://github.com/CliMA/Oceananigans.jl/pull/308:29,Modifiability,config,configs,29,"Forgot to use dynamic launch configs for the `calculate_G*` kernels. But, hmmm, this actually slows things down a bit... ```; ─────────────────────────────────────────────────────────────────────────────────────; Oceananigans.jl static ocean bench... Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 247s / 29.9% 14.9GiB / 0.56% . Section ncalls time %tot avg alloc %tot avg; ─────────────────────────────────────────────────────────────────────────────────────; 256×256×256 (CPU, Float64) 10 34.0s 46.1% 3.40s 292KiB 0.34% 29.2KiB; 256×256×256 (CPU, Float32) 10 30.5s 41.4% 3.05s 227KiB 0.26% 22.7KiB; 128×128×128 (CPU, Float64) 10 3.94s 5.35% 394ms 292KiB 0.34% 29.2KiB; 128×128×128 (CPU, Float32) 10 3.54s 4.80% 354ms 227KiB 0.26% 22.7KiB; 64× 64× 64 (CPU, Float64) 10 417ms 0.57% 41.7ms 292KiB 0.34% 29.2KiB; 64× 64× 64 (CPU, Float32) 10 406ms 0.55% 40.6ms 227KiB 0.26% 22.7KiB; 256×256×256 (GPU, Float64) 10 337ms 0.46% 33.7ms 11.0MiB 13.0% 1.10MiB; 256×256×256 (GPU, Float32) 10 254ms 0.34% 25.4ms 9.62MiB 11.4% 0.96MiB; 32× 32× 32 (CPU, Float64) 10 52.6ms 0.07% 5.26ms 292KiB 0.34% 29.2KiB; 128×128×128 (GPU, Float64) 10 47.3ms 0.06% 4.73ms 11.0MiB 13.0% 1.10MiB; 32× 32× 32 (CPU, Float32) 10 46.9ms 0.06% 4.69ms 227KiB 0.26% 22.7KiB; 128×128×128 (GPU, Float32) 10 36.4ms 0.05% 3.64ms 9.62MiB 11.4% 0.96MiB; 32× 32× 32 (GPU, Float64) 10 26.6ms 0.04% 2.66ms 11.0MiB 13.0% 1.10MiB; 32× 32× 32 (GPU, Float32) 10 24.6ms 0.03% 2.46ms 9.61MiB 11.4% 0.96MiB; 64× 64× 64 (GPU, Float64) 10 24.6ms 0.03% 2.46ms 11.0MiB 13.0% 1.10MiB; 64× 64× 64 (GPU, Float32) 10 22.6ms 0.03% 2.26ms 9.62MiB 11.4% 0.96MiB; ─────────────────────────────────────────────────────────────────────────────────────. CPU Float64 -> Float32 speedup:; 32× 32× 32: 1.122; 64× 64× 64: 1.027; 128×128×128: 1.114; 256×256×256: 1.114. GPU Float64 -> Float32 speedup:; 32× 32× 32: 1.081; 64× 64× 64: 1.086; 128×128×128: 1.301; 256×256×256: 1.326. CPU -> GPU speedup:; 32× 32× 32 (Float32): 1.903; 32×",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/308
https://github.com/CliMA/Oceananigans.jl/pull/309:32,Deployability,integrat,integrating,32,This PR starts the processes of integrating LES functionality from glwagner/pass-tests into Oceananigans master. It is very much WIP at the moment.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/309
https://github.com/CliMA/Oceananigans.jl/pull/309:32,Integrability,integrat,integrating,32,This PR starts the processes of integrating LES functionality from glwagner/pass-tests into Oceananigans master. It is very much WIP at the moment.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/309
https://github.com/CliMA/Oceananigans.jl/pull/309:81,Testability,test,tests,81,This PR starts the processes of integrating LES functionality from glwagner/pass-tests into Oceananigans master. It is very much WIP at the moment.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/309
https://github.com/CliMA/Oceananigans.jl/issues/310:669,Integrability,depend,depending,669,"We agreed that stratified plane Couette flow could be a test case against which we can verify the implementation of AMD in PR #309, although the published results [Vreugdenhil & Taylor (2018)] use a slightly modified version of AMD. They report a number of LES runs, and since we don't have a vertically stretched grid, it might be easiest to try and reproduce the Pr = 0.7 case which they do with (Nx, Ny, Nz) = (64, 49, 64) grid points [for Ri=0 or 0.01, for Ri = 0.04 it's (64, 65, 64)]. I might suggest focusing on the Ri = 0 case as they also run a resolved DNS with (Nx, Ny, Nz) = (256, 129, 256) against which we might be able to compare (might not be possible, depending on vertical grid stretching). Unfortunately, I don't think we can reproduce their results without a vertically stretched grid... If I understand the paper correctly, the grid is stretched according to; ```; y_j = h*tanh(Sf*(2*(j-1)/(Ny-1))) / tanh(Sf); ```; so for h=1 you get grid spacings of Δy ~ 0.125 away from the wall and Δy ~ 0.0000035 adjacent to the wall. So a faithful reproduction would need 285,000+ vertical levels lol. I don't fully understand how they got their values for the vertical grid cell size adjacent to the wall `∆y_w^+`, but it seems like if h = 100,000 then our values agree (they get a spacing of Δy ~ 0.35 adjacent to the wall). Either way, the ratio between the thickest and thinnest spacings is ~35,000. Not sure if there's still a way we could compare results in this case without a vertically stretched grid... Absolute worst case scenario, I've been working on an implementation of a vertically stretched grid (see PRs #283 and #306) but it's a work in progress and might not be the best use of our efforts right now. Reference: Catherine A. Vreugdenhil and John R. Taylor, [Large-eddy simulations of stratified plane Couette flow using the anisotropic minimum-dissipation model](https://aip.scitation.org/doi/abs/10.1063/1.5037039), Physics of Fluids 30, 085104 (2018). cc @glwagner @raf",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/310
https://github.com/CliMA/Oceananigans.jl/issues/310:56,Testability,test,test,56,"We agreed that stratified plane Couette flow could be a test case against which we can verify the implementation of AMD in PR #309, although the published results [Vreugdenhil & Taylor (2018)] use a slightly modified version of AMD. They report a number of LES runs, and since we don't have a vertically stretched grid, it might be easiest to try and reproduce the Pr = 0.7 case which they do with (Nx, Ny, Nz) = (64, 49, 64) grid points [for Ri=0 or 0.01, for Ri = 0.04 it's (64, 65, 64)]. I might suggest focusing on the Ri = 0 case as they also run a resolved DNS with (Nx, Ny, Nz) = (256, 129, 256) against which we might be able to compare (might not be possible, depending on vertical grid stretching). Unfortunately, I don't think we can reproduce their results without a vertically stretched grid... If I understand the paper correctly, the grid is stretched according to; ```; y_j = h*tanh(Sf*(2*(j-1)/(Ny-1))) / tanh(Sf); ```; so for h=1 you get grid spacings of Δy ~ 0.125 away from the wall and Δy ~ 0.0000035 adjacent to the wall. So a faithful reproduction would need 285,000+ vertical levels lol. I don't fully understand how they got their values for the vertical grid cell size adjacent to the wall `∆y_w^+`, but it seems like if h = 100,000 then our values agree (they get a spacing of Δy ~ 0.35 adjacent to the wall). Either way, the ratio between the thickest and thinnest spacings is ~35,000. Not sure if there's still a way we could compare results in this case without a vertically stretched grid... Absolute worst case scenario, I've been working on an implementation of a vertically stretched grid (see PRs #283 and #306) but it's a work in progress and might not be the best use of our efforts right now. Reference: Catherine A. Vreugdenhil and John R. Taylor, [Large-eddy simulations of stratified plane Couette flow using the anisotropic minimum-dissipation model](https://aip.scitation.org/doi/abs/10.1063/1.5037039), Physics of Fluids 30, 085104 (2018). cc @glwagner @raf",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/310
https://github.com/CliMA/Oceananigans.jl/issues/311:147,Availability,redundant,redundant,147,"The `PoissonBCs`:. https://github.com/climate-machine/Oceananigans.jl/blob/c961d3904700e73b1a4aebb71ebcc3f518693014/src/poisson_solvers.jl#L4. are redundant with the boundary conditions on the velocity fields. In other words, the pressure boundary conditions *depend* on the boundary conditions applied to the velocity field. There should not, therefore, be separate boundary condition types for the pressure solver. In particular, periodic boundary conditions on the velocity fields imply periodic boundary conditions on the pressure solver, while non-periodic boundary conditions on the velocity fields imply Neumann boundary conditions for the pressure solver. The redundant implementation of boundary condition complicates model instantiation (the boundary conditions on the Poisson solver should be *inferred* from the boundary conditions on the velocity field, rather than specified independently), and is a source of fragility (because a physically invalid combination of boundary conditions on the velocity field and pressure solver can be specified).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/311
https://github.com/CliMA/Oceananigans.jl/issues/311:668,Availability,redundant,redundant,668,"The `PoissonBCs`:. https://github.com/climate-machine/Oceananigans.jl/blob/c961d3904700e73b1a4aebb71ebcc3f518693014/src/poisson_solvers.jl#L4. are redundant with the boundary conditions on the velocity fields. In other words, the pressure boundary conditions *depend* on the boundary conditions applied to the velocity field. There should not, therefore, be separate boundary condition types for the pressure solver. In particular, periodic boundary conditions on the velocity fields imply periodic boundary conditions on the pressure solver, while non-periodic boundary conditions on the velocity fields imply Neumann boundary conditions for the pressure solver. The redundant implementation of boundary condition complicates model instantiation (the boundary conditions on the Poisson solver should be *inferred* from the boundary conditions on the velocity field, rather than specified independently), and is a source of fragility (because a physically invalid combination of boundary conditions on the velocity field and pressure solver can be specified).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/311
https://github.com/CliMA/Oceananigans.jl/issues/311:260,Integrability,depend,depend,260,"The `PoissonBCs`:. https://github.com/climate-machine/Oceananigans.jl/blob/c961d3904700e73b1a4aebb71ebcc3f518693014/src/poisson_solvers.jl#L4. are redundant with the boundary conditions on the velocity fields. In other words, the pressure boundary conditions *depend* on the boundary conditions applied to the velocity field. There should not, therefore, be separate boundary condition types for the pressure solver. In particular, periodic boundary conditions on the velocity fields imply periodic boundary conditions on the pressure solver, while non-periodic boundary conditions on the velocity fields imply Neumann boundary conditions for the pressure solver. The redundant implementation of boundary condition complicates model instantiation (the boundary conditions on the Poisson solver should be *inferred* from the boundary conditions on the velocity field, rather than specified independently), and is a source of fragility (because a physically invalid combination of boundary conditions on the velocity field and pressure solver can be specified).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/311
https://github.com/CliMA/Oceananigans.jl/issues/311:147,Safety,redund,redundant,147,"The `PoissonBCs`:. https://github.com/climate-machine/Oceananigans.jl/blob/c961d3904700e73b1a4aebb71ebcc3f518693014/src/poisson_solvers.jl#L4. are redundant with the boundary conditions on the velocity fields. In other words, the pressure boundary conditions *depend* on the boundary conditions applied to the velocity field. There should not, therefore, be separate boundary condition types for the pressure solver. In particular, periodic boundary conditions on the velocity fields imply periodic boundary conditions on the pressure solver, while non-periodic boundary conditions on the velocity fields imply Neumann boundary conditions for the pressure solver. The redundant implementation of boundary condition complicates model instantiation (the boundary conditions on the Poisson solver should be *inferred* from the boundary conditions on the velocity field, rather than specified independently), and is a source of fragility (because a physically invalid combination of boundary conditions on the velocity field and pressure solver can be specified).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/311
https://github.com/CliMA/Oceananigans.jl/issues/311:668,Safety,redund,redundant,668,"The `PoissonBCs`:. https://github.com/climate-machine/Oceananigans.jl/blob/c961d3904700e73b1a4aebb71ebcc3f518693014/src/poisson_solvers.jl#L4. are redundant with the boundary conditions on the velocity fields. In other words, the pressure boundary conditions *depend* on the boundary conditions applied to the velocity field. There should not, therefore, be separate boundary condition types for the pressure solver. In particular, periodic boundary conditions on the velocity fields imply periodic boundary conditions on the pressure solver, while non-periodic boundary conditions on the velocity fields imply Neumann boundary conditions for the pressure solver. The redundant implementation of boundary condition complicates model instantiation (the boundary conditions on the Poisson solver should be *inferred* from the boundary conditions on the velocity field, rather than specified independently), and is a source of fragility (because a physically invalid combination of boundary conditions on the velocity field and pressure solver can be specified).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/311
https://github.com/CliMA/Oceananigans.jl/pull/312:110,Performance,perform,performs,110,This PR (will) implement(s) pre-computed nonlinear turbulent diffusivities for large eddy simulation. It also performs some minor clean-up for the model constructor to prevent boiler plate proliferation.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/312
https://github.com/CliMA/Oceananigans.jl/issues/314:1036,Availability,ERROR,ERROR,1036," simulation which is failing now. This was working a few days ago.; ```; # Set up the model and use an artificially high viscosity ν and diffusivity κ.; model = Model(N=(Nx, Ny, Nz), L=(Lx, Ly, Lz), arch=GPU(),; ν=1e-4, κ=1e-4). # Get location of the cell centers in x, y, z and reshape them to easily; # broadcast over them when calculating hot_bubble_perturbation.; xC, yC, zC = model.grid.xC, model.grid.yC, model.grid.zC; xC, yC, zC = reshape(xC, (Nx, 1, 1)), reshape(yC, (1, Ny, 1)), reshape(zC, (1, 1, Nz)). # Set heating flux at the bottom.; Q = 9200 # W/m^2; Rp = 50 # plume radius [m]. r = @. sqrt((xC - Lx/2)^2 + (yC - Ly/2)^2). bottom_flux = zeros(Nx, Ny, 1); bottom_flux[r .< Rp] .= g * ɑ * Q / (ρ₀ * cₚ); bottom_flux = CuArray(bottom_flux). model.boundary_conditions.T.z.right = BoundaryCondition(Flux, bottom_flux); ```. This now fails with:; ```; ERROR: LoadError: TypeError: in setfield!, expected BoundaryCondition{Flux,Int64}, got BoundaryCondition{Flux,CuArray{Float64,3}}; Stacktrace:; [1] setbc!(::CoordinateBoundaryConditions{BoundaryCondition{Flux,Int64},BoundaryCondition{Flux,Int64}}, ::Val{:right}, ::BoundaryCondition{Flux,CuArray{Float64,3}}) at /home/betaeffect/.julia/packages/Oceananigans/wiEvh/src/boundary_conditions.jl:81; [2] setproperty!(::CoordinateBoundaryConditions{BoundaryCondition{Flux,Int64},BoundaryCondition{Flux,Int64}}, ::Symbol, ::BoundaryCondition{Flux,CuArray{Float64,3}}) at /home/betaeffect/.julia/packages/Oceananigans/wiEvh/src/boundary_conditions.jl:80; [3] top-level scope at none:0; [4] include at ./boot.jl:326 [inlined]; [5] include_relative(::Module, ::String) at ./loading.jl:1038; [6] include(::Module, ::String) at ./sysimg.jl:29; [7] include(::String) at ./client.jl:403; [8] top-level scope at none:0; in expression starting at /home/betaeffect/oceananigans/hydrothermal_plume/nukappa1em4/plume.jl:37; ```. I am not fully proficient in Julia yet, so wasn't able to figure out from the code how to fix this issue. Is there a simple fix?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/314
https://github.com/CliMA/Oceananigans.jl/issues/314:1043,Performance,Load,LoadError,1043," simulation which is failing now. This was working a few days ago.; ```; # Set up the model and use an artificially high viscosity ν and diffusivity κ.; model = Model(N=(Nx, Ny, Nz), L=(Lx, Ly, Lz), arch=GPU(),; ν=1e-4, κ=1e-4). # Get location of the cell centers in x, y, z and reshape them to easily; # broadcast over them when calculating hot_bubble_perturbation.; xC, yC, zC = model.grid.xC, model.grid.yC, model.grid.zC; xC, yC, zC = reshape(xC, (Nx, 1, 1)), reshape(yC, (1, Ny, 1)), reshape(zC, (1, 1, Nz)). # Set heating flux at the bottom.; Q = 9200 # W/m^2; Rp = 50 # plume radius [m]. r = @. sqrt((xC - Lx/2)^2 + (yC - Ly/2)^2). bottom_flux = zeros(Nx, Ny, 1); bottom_flux[r .< Rp] .= g * ɑ * Q / (ρ₀ * cₚ); bottom_flux = CuArray(bottom_flux). model.boundary_conditions.T.z.right = BoundaryCondition(Flux, bottom_flux); ```. This now fails with:; ```; ERROR: LoadError: TypeError: in setfield!, expected BoundaryCondition{Flux,Int64}, got BoundaryCondition{Flux,CuArray{Float64,3}}; Stacktrace:; [1] setbc!(::CoordinateBoundaryConditions{BoundaryCondition{Flux,Int64},BoundaryCondition{Flux,Int64}}, ::Val{:right}, ::BoundaryCondition{Flux,CuArray{Float64,3}}) at /home/betaeffect/.julia/packages/Oceananigans/wiEvh/src/boundary_conditions.jl:81; [2] setproperty!(::CoordinateBoundaryConditions{BoundaryCondition{Flux,Int64},BoundaryCondition{Flux,Int64}}, ::Symbol, ::BoundaryCondition{Flux,CuArray{Float64,3}}) at /home/betaeffect/.julia/packages/Oceananigans/wiEvh/src/boundary_conditions.jl:80; [3] top-level scope at none:0; [4] include at ./boot.jl:326 [inlined]; [5] include_relative(::Module, ::String) at ./loading.jl:1038; [6] include(::Module, ::String) at ./sysimg.jl:29; [7] include(::String) at ./client.jl:403; [8] top-level scope at none:0; in expression starting at /home/betaeffect/oceananigans/hydrothermal_plume/nukappa1em4/plume.jl:37; ```. I am not fully proficient in Julia yet, so wasn't able to figure out from the code how to fix this issue. Is there a simple fix?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/314
https://github.com/CliMA/Oceananigans.jl/issues/314:1800,Performance,load,loading,1800," simulation which is failing now. This was working a few days ago.; ```; # Set up the model and use an artificially high viscosity ν and diffusivity κ.; model = Model(N=(Nx, Ny, Nz), L=(Lx, Ly, Lz), arch=GPU(),; ν=1e-4, κ=1e-4). # Get location of the cell centers in x, y, z and reshape them to easily; # broadcast over them when calculating hot_bubble_perturbation.; xC, yC, zC = model.grid.xC, model.grid.yC, model.grid.zC; xC, yC, zC = reshape(xC, (Nx, 1, 1)), reshape(yC, (1, Ny, 1)), reshape(zC, (1, 1, Nz)). # Set heating flux at the bottom.; Q = 9200 # W/m^2; Rp = 50 # plume radius [m]. r = @. sqrt((xC - Lx/2)^2 + (yC - Ly/2)^2). bottom_flux = zeros(Nx, Ny, 1); bottom_flux[r .< Rp] .= g * ɑ * Q / (ρ₀ * cₚ); bottom_flux = CuArray(bottom_flux). model.boundary_conditions.T.z.right = BoundaryCondition(Flux, bottom_flux); ```. This now fails with:; ```; ERROR: LoadError: TypeError: in setfield!, expected BoundaryCondition{Flux,Int64}, got BoundaryCondition{Flux,CuArray{Float64,3}}; Stacktrace:; [1] setbc!(::CoordinateBoundaryConditions{BoundaryCondition{Flux,Int64},BoundaryCondition{Flux,Int64}}, ::Val{:right}, ::BoundaryCondition{Flux,CuArray{Float64,3}}) at /home/betaeffect/.julia/packages/Oceananigans/wiEvh/src/boundary_conditions.jl:81; [2] setproperty!(::CoordinateBoundaryConditions{BoundaryCondition{Flux,Int64},BoundaryCondition{Flux,Int64}}, ::Symbol, ::BoundaryCondition{Flux,CuArray{Float64,3}}) at /home/betaeffect/.julia/packages/Oceananigans/wiEvh/src/boundary_conditions.jl:80; [3] top-level scope at none:0; [4] include at ./boot.jl:326 [inlined]; [5] include_relative(::Module, ::String) at ./loading.jl:1038; [6] include(::Module, ::String) at ./sysimg.jl:29; [7] include(::String) at ./client.jl:403; [8] top-level scope at none:0; in expression starting at /home/betaeffect/oceananigans/hydrothermal_plume/nukappa1em4/plume.jl:37; ```. I am not fully proficient in Julia yet, so wasn't able to figure out from the code how to fix this issue. Is there a simple fix?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/314
https://github.com/CliMA/Oceananigans.jl/issues/314:2163,Usability,simpl,simple,2163," simulation which is failing now. This was working a few days ago.; ```; # Set up the model and use an artificially high viscosity ν and diffusivity κ.; model = Model(N=(Nx, Ny, Nz), L=(Lx, Ly, Lz), arch=GPU(),; ν=1e-4, κ=1e-4). # Get location of the cell centers in x, y, z and reshape them to easily; # broadcast over them when calculating hot_bubble_perturbation.; xC, yC, zC = model.grid.xC, model.grid.yC, model.grid.zC; xC, yC, zC = reshape(xC, (Nx, 1, 1)), reshape(yC, (1, Ny, 1)), reshape(zC, (1, 1, Nz)). # Set heating flux at the bottom.; Q = 9200 # W/m^2; Rp = 50 # plume radius [m]. r = @. sqrt((xC - Lx/2)^2 + (yC - Ly/2)^2). bottom_flux = zeros(Nx, Ny, 1); bottom_flux[r .< Rp] .= g * ɑ * Q / (ρ₀ * cₚ); bottom_flux = CuArray(bottom_flux). model.boundary_conditions.T.z.right = BoundaryCondition(Flux, bottom_flux); ```. This now fails with:; ```; ERROR: LoadError: TypeError: in setfield!, expected BoundaryCondition{Flux,Int64}, got BoundaryCondition{Flux,CuArray{Float64,3}}; Stacktrace:; [1] setbc!(::CoordinateBoundaryConditions{BoundaryCondition{Flux,Int64},BoundaryCondition{Flux,Int64}}, ::Val{:right}, ::BoundaryCondition{Flux,CuArray{Float64,3}}) at /home/betaeffect/.julia/packages/Oceananigans/wiEvh/src/boundary_conditions.jl:81; [2] setproperty!(::CoordinateBoundaryConditions{BoundaryCondition{Flux,Int64},BoundaryCondition{Flux,Int64}}, ::Symbol, ::BoundaryCondition{Flux,CuArray{Float64,3}}) at /home/betaeffect/.julia/packages/Oceananigans/wiEvh/src/boundary_conditions.jl:80; [3] top-level scope at none:0; [4] include at ./boot.jl:326 [inlined]; [5] include_relative(::Module, ::String) at ./loading.jl:1038; [6] include(::Module, ::String) at ./sysimg.jl:29; [7] include(::String) at ./client.jl:403; [8] top-level scope at none:0; in expression starting at /home/betaeffect/oceananigans/hydrothermal_plume/nukappa1em4/plume.jl:37; ```. I am not fully proficient in Julia yet, so wasn't able to figure out from the code how to fix this issue. Is there a simple fix?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/314
https://github.com/CliMA/Oceananigans.jl/pull/315:70,Modifiability,sandbox,sandbox,70,"(and better boundary conditions API). This PR adds two scripts to the sandbox for performing large eddy simulation of:. - [ ] a 'simple flux' scenario of a ~100 m square ocean forced by constant surface fluxes, and; - [ ] stratified Couette flow. We may also want to add an example based on one of these scripts. Addresses #310.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/315
https://github.com/CliMA/Oceananigans.jl/pull/315:82,Performance,perform,performing,82,"(and better boundary conditions API). This PR adds two scripts to the sandbox for performing large eddy simulation of:. - [ ] a 'simple flux' scenario of a ~100 m square ocean forced by constant surface fluxes, and; - [ ] stratified Couette flow. We may also want to add an example based on one of these scripts. Addresses #310.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/315
https://github.com/CliMA/Oceananigans.jl/pull/315:70,Testability,sandbox,sandbox,70,"(and better boundary conditions API). This PR adds two scripts to the sandbox for performing large eddy simulation of:. - [ ] a 'simple flux' scenario of a ~100 m square ocean forced by constant surface fluxes, and; - [ ] stratified Couette flow. We may also want to add an example based on one of these scripts. Addresses #310.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/315
https://github.com/CliMA/Oceananigans.jl/pull/315:129,Usability,simpl,simple,129,"(and better boundary conditions API). This PR adds two scripts to the sandbox for performing large eddy simulation of:. - [ ] a 'simple flux' scenario of a ~100 m square ocean forced by constant surface fluxes, and; - [ ] stratified Couette flow. We may also want to add an example based on one of these scripts. Addresses #310.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/315
https://github.com/CliMA/Oceananigans.jl/pull/316:199,Availability,down,downloaded,199,"Simple Dockerfile to build a Docker image with Oceananigans installed, precompiled, and with dependencies built. Should be useful for debugging and maybe speeding up CI. Image can be built then just downloaded by CI server, but usually testing is done before Docker image is built... We also have a Dockerhub repository where images will be published: https://cloud.docker.com/repository/docker/aliramadhan/oceananigans. We can look into automated builds: https://docs.docker.com/docker-hub/builds/. For GPU-accelerated container we can look into: https://github.com/NVIDIA/nvidia-docker. cc @christophernhill we're finally in the 21st century!. Resolves #151",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/316
https://github.com/CliMA/Oceananigans.jl/pull/316:60,Deployability,install,installed,60,"Simple Dockerfile to build a Docker image with Oceananigans installed, precompiled, and with dependencies built. Should be useful for debugging and maybe speeding up CI. Image can be built then just downloaded by CI server, but usually testing is done before Docker image is built... We also have a Dockerhub repository where images will be published: https://cloud.docker.com/repository/docker/aliramadhan/oceananigans. We can look into automated builds: https://docs.docker.com/docker-hub/builds/. For GPU-accelerated container we can look into: https://github.com/NVIDIA/nvidia-docker. cc @christophernhill we're finally in the 21st century!. Resolves #151",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/316
https://github.com/CliMA/Oceananigans.jl/pull/316:93,Integrability,depend,dependencies,93,"Simple Dockerfile to build a Docker image with Oceananigans installed, precompiled, and with dependencies built. Should be useful for debugging and maybe speeding up CI. Image can be built then just downloaded by CI server, but usually testing is done before Docker image is built... We also have a Dockerhub repository where images will be published: https://cloud.docker.com/repository/docker/aliramadhan/oceananigans. We can look into automated builds: https://docs.docker.com/docker-hub/builds/. For GPU-accelerated container we can look into: https://github.com/NVIDIA/nvidia-docker. cc @christophernhill we're finally in the 21st century!. Resolves #151",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/316
https://github.com/CliMA/Oceananigans.jl/pull/316:236,Testability,test,testing,236,"Simple Dockerfile to build a Docker image with Oceananigans installed, precompiled, and with dependencies built. Should be useful for debugging and maybe speeding up CI. Image can be built then just downloaded by CI server, but usually testing is done before Docker image is built... We also have a Dockerhub repository where images will be published: https://cloud.docker.com/repository/docker/aliramadhan/oceananigans. We can look into automated builds: https://docs.docker.com/docker-hub/builds/. For GPU-accelerated container we can look into: https://github.com/NVIDIA/nvidia-docker. cc @christophernhill we're finally in the 21st century!. Resolves #151",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/316
https://github.com/CliMA/Oceananigans.jl/pull/316:0,Usability,Simpl,Simple,0,"Simple Dockerfile to build a Docker image with Oceananigans installed, precompiled, and with dependencies built. Should be useful for debugging and maybe speeding up CI. Image can be built then just downloaded by CI server, but usually testing is done before Docker image is built... We also have a Dockerhub repository where images will be published: https://cloud.docker.com/repository/docker/aliramadhan/oceananigans. We can look into automated builds: https://docs.docker.com/docker-hub/builds/. For GPU-accelerated container we can look into: https://github.com/NVIDIA/nvidia-docker. cc @christophernhill we're finally in the 21st century!. Resolves #151",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/316
https://github.com/CliMA/Oceananigans.jl/pull/322:89,Testability,test,tests,89,Should be `Δz^2` instead of `Δz`. But this cannot be merged as is because it breaks some tests: the Rayleigh–Bénard tracer regression test uses Value boundary conditions and so the regression data would have to be regenerated.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/322
https://github.com/CliMA/Oceananigans.jl/pull/322:134,Testability,test,test,134,Should be `Δz^2` instead of `Δz`. But this cannot be merged as is because it breaks some tests: the Rayleigh–Bénard tracer regression test uses Value boundary conditions and so the regression data would have to be regenerated.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/322
https://github.com/CliMA/Oceananigans.jl/issues/324:21,Availability,checkpoint,checkpointing,21,"We currently have no checkpointing anymore. We need a barebones checkpointer that only checkpoints and saves the essentials. Should be more transparent than serializing the `Model` to disk, which also comes with multiple issues. Should also be useful for long runs (e.g. seasonal cycle simulations) and more rigorous regression tests that actually test the dynamics.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/324
https://github.com/CliMA/Oceananigans.jl/issues/324:64,Availability,checkpoint,checkpointer,64,"We currently have no checkpointing anymore. We need a barebones checkpointer that only checkpoints and saves the essentials. Should be more transparent than serializing the `Model` to disk, which also comes with multiple issues. Should also be useful for long runs (e.g. seasonal cycle simulations) and more rigorous regression tests that actually test the dynamics.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/324
https://github.com/CliMA/Oceananigans.jl/issues/324:87,Availability,checkpoint,checkpoints,87,"We currently have no checkpointing anymore. We need a barebones checkpointer that only checkpoints and saves the essentials. Should be more transparent than serializing the `Model` to disk, which also comes with multiple issues. Should also be useful for long runs (e.g. seasonal cycle simulations) and more rigorous regression tests that actually test the dynamics.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/324
https://github.com/CliMA/Oceananigans.jl/issues/324:328,Testability,test,tests,328,"We currently have no checkpointing anymore. We need a barebones checkpointer that only checkpoints and saves the essentials. Should be more transparent than serializing the `Model` to disk, which also comes with multiple issues. Should also be useful for long runs (e.g. seasonal cycle simulations) and more rigorous regression tests that actually test the dynamics.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/324
https://github.com/CliMA/Oceananigans.jl/issues/324:348,Testability,test,test,348,"We currently have no checkpointing anymore. We need a barebones checkpointer that only checkpoints and saves the essentials. Should be more transparent than serializing the `Model` to disk, which also comes with multiple issues. Should also be useful for long runs (e.g. seasonal cycle simulations) and more rigorous regression tests that actually test the dynamics.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/324
https://github.com/CliMA/Oceananigans.jl/pull/325:39,Energy Efficiency,reduce,reduce,39,"This PR does some minor refactoring to reduce code length. It also introduces an `AdamsBashforthTimestepper` type which will be useful in the future if new timesteppers are implemented. @ali-ramadhan, can you check to see that GPU tests pass? I had some trouble on my local machine.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/325
https://github.com/CliMA/Oceananigans.jl/pull/325:24,Modifiability,refactor,refactoring,24,"This PR does some minor refactoring to reduce code length. It also introduces an `AdamsBashforthTimestepper` type which will be useful in the future if new timesteppers are implemented. @ali-ramadhan, can you check to see that GPU tests pass? I had some trouble on my local machine.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/325
https://github.com/CliMA/Oceananigans.jl/pull/325:231,Testability,test,tests,231,"This PR does some minor refactoring to reduce code length. It also introduces an `AdamsBashforthTimestepper` type which will be useful in the future if new timesteppers are implemented. @ali-ramadhan, can you check to see that GPU tests pass? I had some trouble on my local machine.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/325
https://github.com/CliMA/Oceananigans.jl/pull/326:21,Availability,checkpoint,checkpointing,21,"This PR reintroduces checkpointing. This time the checkpointer saves the bare essentials to a JLD2 file. Checkpointer will not save forcing functions as before (see #141). Need to test GPU checkpointing, checkpointing with LES closures (I assumed `model.diffusivities` does not need to be checkpointed), and checkpointing with fancier boundary conditions. A major issue with this checkpointer is that it can't restore the largest models because it creates a `Model` and then copies the data from the checkpoint file into the model fields. But if the model is using up all memory, then there's no room for reading data from disk to memory. It should feed the data directly through the Model constructor, but this would require refactoring some of the model and field code. This can be addressed in this PR or in a future PR, although it's kind of useless because checkpointing becomes more important the larger the model/simulation... Resolves #324",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/326
https://github.com/CliMA/Oceananigans.jl/pull/326:50,Availability,checkpoint,checkpointer,50,"This PR reintroduces checkpointing. This time the checkpointer saves the bare essentials to a JLD2 file. Checkpointer will not save forcing functions as before (see #141). Need to test GPU checkpointing, checkpointing with LES closures (I assumed `model.diffusivities` does not need to be checkpointed), and checkpointing with fancier boundary conditions. A major issue with this checkpointer is that it can't restore the largest models because it creates a `Model` and then copies the data from the checkpoint file into the model fields. But if the model is using up all memory, then there's no room for reading data from disk to memory. It should feed the data directly through the Model constructor, but this would require refactoring some of the model and field code. This can be addressed in this PR or in a future PR, although it's kind of useless because checkpointing becomes more important the larger the model/simulation... Resolves #324",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/326
https://github.com/CliMA/Oceananigans.jl/pull/326:105,Availability,Checkpoint,Checkpointer,105,"This PR reintroduces checkpointing. This time the checkpointer saves the bare essentials to a JLD2 file. Checkpointer will not save forcing functions as before (see #141). Need to test GPU checkpointing, checkpointing with LES closures (I assumed `model.diffusivities` does not need to be checkpointed), and checkpointing with fancier boundary conditions. A major issue with this checkpointer is that it can't restore the largest models because it creates a `Model` and then copies the data from the checkpoint file into the model fields. But if the model is using up all memory, then there's no room for reading data from disk to memory. It should feed the data directly through the Model constructor, but this would require refactoring some of the model and field code. This can be addressed in this PR or in a future PR, although it's kind of useless because checkpointing becomes more important the larger the model/simulation... Resolves #324",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/326
https://github.com/CliMA/Oceananigans.jl/pull/326:189,Availability,checkpoint,checkpointing,189,"This PR reintroduces checkpointing. This time the checkpointer saves the bare essentials to a JLD2 file. Checkpointer will not save forcing functions as before (see #141). Need to test GPU checkpointing, checkpointing with LES closures (I assumed `model.diffusivities` does not need to be checkpointed), and checkpointing with fancier boundary conditions. A major issue with this checkpointer is that it can't restore the largest models because it creates a `Model` and then copies the data from the checkpoint file into the model fields. But if the model is using up all memory, then there's no room for reading data from disk to memory. It should feed the data directly through the Model constructor, but this would require refactoring some of the model and field code. This can be addressed in this PR or in a future PR, although it's kind of useless because checkpointing becomes more important the larger the model/simulation... Resolves #324",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/326
https://github.com/CliMA/Oceananigans.jl/pull/326:204,Availability,checkpoint,checkpointing,204,"This PR reintroduces checkpointing. This time the checkpointer saves the bare essentials to a JLD2 file. Checkpointer will not save forcing functions as before (see #141). Need to test GPU checkpointing, checkpointing with LES closures (I assumed `model.diffusivities` does not need to be checkpointed), and checkpointing with fancier boundary conditions. A major issue with this checkpointer is that it can't restore the largest models because it creates a `Model` and then copies the data from the checkpoint file into the model fields. But if the model is using up all memory, then there's no room for reading data from disk to memory. It should feed the data directly through the Model constructor, but this would require refactoring some of the model and field code. This can be addressed in this PR or in a future PR, although it's kind of useless because checkpointing becomes more important the larger the model/simulation... Resolves #324",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/326
https://github.com/CliMA/Oceananigans.jl/pull/326:289,Availability,checkpoint,checkpointed,289,"This PR reintroduces checkpointing. This time the checkpointer saves the bare essentials to a JLD2 file. Checkpointer will not save forcing functions as before (see #141). Need to test GPU checkpointing, checkpointing with LES closures (I assumed `model.diffusivities` does not need to be checkpointed), and checkpointing with fancier boundary conditions. A major issue with this checkpointer is that it can't restore the largest models because it creates a `Model` and then copies the data from the checkpoint file into the model fields. But if the model is using up all memory, then there's no room for reading data from disk to memory. It should feed the data directly through the Model constructor, but this would require refactoring some of the model and field code. This can be addressed in this PR or in a future PR, although it's kind of useless because checkpointing becomes more important the larger the model/simulation... Resolves #324",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/326
https://github.com/CliMA/Oceananigans.jl/pull/326:308,Availability,checkpoint,checkpointing,308,"This PR reintroduces checkpointing. This time the checkpointer saves the bare essentials to a JLD2 file. Checkpointer will not save forcing functions as before (see #141). Need to test GPU checkpointing, checkpointing with LES closures (I assumed `model.diffusivities` does not need to be checkpointed), and checkpointing with fancier boundary conditions. A major issue with this checkpointer is that it can't restore the largest models because it creates a `Model` and then copies the data from the checkpoint file into the model fields. But if the model is using up all memory, then there's no room for reading data from disk to memory. It should feed the data directly through the Model constructor, but this would require refactoring some of the model and field code. This can be addressed in this PR or in a future PR, although it's kind of useless because checkpointing becomes more important the larger the model/simulation... Resolves #324",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/326
https://github.com/CliMA/Oceananigans.jl/pull/326:380,Availability,checkpoint,checkpointer,380,"This PR reintroduces checkpointing. This time the checkpointer saves the bare essentials to a JLD2 file. Checkpointer will not save forcing functions as before (see #141). Need to test GPU checkpointing, checkpointing with LES closures (I assumed `model.diffusivities` does not need to be checkpointed), and checkpointing with fancier boundary conditions. A major issue with this checkpointer is that it can't restore the largest models because it creates a `Model` and then copies the data from the checkpoint file into the model fields. But if the model is using up all memory, then there's no room for reading data from disk to memory. It should feed the data directly through the Model constructor, but this would require refactoring some of the model and field code. This can be addressed in this PR or in a future PR, although it's kind of useless because checkpointing becomes more important the larger the model/simulation... Resolves #324",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/326
https://github.com/CliMA/Oceananigans.jl/pull/326:500,Availability,checkpoint,checkpoint,500,"This PR reintroduces checkpointing. This time the checkpointer saves the bare essentials to a JLD2 file. Checkpointer will not save forcing functions as before (see #141). Need to test GPU checkpointing, checkpointing with LES closures (I assumed `model.diffusivities` does not need to be checkpointed), and checkpointing with fancier boundary conditions. A major issue with this checkpointer is that it can't restore the largest models because it creates a `Model` and then copies the data from the checkpoint file into the model fields. But if the model is using up all memory, then there's no room for reading data from disk to memory. It should feed the data directly through the Model constructor, but this would require refactoring some of the model and field code. This can be addressed in this PR or in a future PR, although it's kind of useless because checkpointing becomes more important the larger the model/simulation... Resolves #324",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/326
https://github.com/CliMA/Oceananigans.jl/pull/326:862,Availability,checkpoint,checkpointing,862,"This PR reintroduces checkpointing. This time the checkpointer saves the bare essentials to a JLD2 file. Checkpointer will not save forcing functions as before (see #141). Need to test GPU checkpointing, checkpointing with LES closures (I assumed `model.diffusivities` does not need to be checkpointed), and checkpointing with fancier boundary conditions. A major issue with this checkpointer is that it can't restore the largest models because it creates a `Model` and then copies the data from the checkpoint file into the model fields. But if the model is using up all memory, then there's no room for reading data from disk to memory. It should feed the data directly through the Model constructor, but this would require refactoring some of the model and field code. This can be addressed in this PR or in a future PR, although it's kind of useless because checkpointing becomes more important the larger the model/simulation... Resolves #324",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/326
https://github.com/CliMA/Oceananigans.jl/pull/326:726,Modifiability,refactor,refactoring,726,"This PR reintroduces checkpointing. This time the checkpointer saves the bare essentials to a JLD2 file. Checkpointer will not save forcing functions as before (see #141). Need to test GPU checkpointing, checkpointing with LES closures (I assumed `model.diffusivities` does not need to be checkpointed), and checkpointing with fancier boundary conditions. A major issue with this checkpointer is that it can't restore the largest models because it creates a `Model` and then copies the data from the checkpoint file into the model fields. But if the model is using up all memory, then there's no room for reading data from disk to memory. It should feed the data directly through the Model constructor, but this would require refactoring some of the model and field code. This can be addressed in this PR or in a future PR, although it's kind of useless because checkpointing becomes more important the larger the model/simulation... Resolves #324",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/326
https://github.com/CliMA/Oceananigans.jl/pull/326:180,Testability,test,test,180,"This PR reintroduces checkpointing. This time the checkpointer saves the bare essentials to a JLD2 file. Checkpointer will not save forcing functions as before (see #141). Need to test GPU checkpointing, checkpointing with LES closures (I assumed `model.diffusivities` does not need to be checkpointed), and checkpointing with fancier boundary conditions. A major issue with this checkpointer is that it can't restore the largest models because it creates a `Model` and then copies the data from the checkpoint file into the model fields. But if the model is using up all memory, then there's no room for reading data from disk to memory. It should feed the data directly through the Model constructor, but this would require refactoring some of the model and field code. This can be addressed in this PR or in a future PR, although it's kind of useless because checkpointing becomes more important the larger the model/simulation... Resolves #324",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/326
https://github.com/CliMA/Oceananigans.jl/issues/327:728,Usability,undo,undocumented,728,"To improve our documentation before submitting something to JOSS I'd like to actually document more of the numerical methods we use. It would also be good to document everything here in one place (as opposed to merely citing papers) as some of these methods have very little modern documentation online. The only way to understand them is to wade through the original papers which can be frustrating and time consuming. I already have lots of notes on these in my notebook, just need to typeset it into documentation:; * Direct solution of Poisson's equation on a staggered grid using FFTs [Schumann & Sweet (1988)].; * How a fast discrete cosine transform is computed on the GPU [Makhoul (1980)]. The 2D fast DCT is especially undocumented anywhere but the paper and was frustrating to implement.; * Operator splitting, how we enforce incompressibility, and how we treat pressure boundary conditions [Orszag, Israeli, & Deville (1986) will be helpful here].; * How Dirchlet, Neumann, and flux boundary conditions are enforced. Upcoming features that will need to be document. I already have a lot of notes on these:; * Finite volume operators. Will be especially useful to document exactly how the ""implicit"" no-flux boundary conditions are enforced and which fluxes are zeroed out. This would apply to the rigid lid and channel walls.; * Solving Poisson's equation on a vertically stretched grid with the Fourier analysis cyclic reduction (FACR) algorithm.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/327
https://github.com/CliMA/Oceananigans.jl/issues/330:1005,Availability,redundant,redundant,1005,"I see a few things to improve with the grid right now. 1. We need to add some kind of type information that indicates whether a given dimension is 'flat'. One way to do this could simply be to add the grid sizes in each dimension as parameters in the abstract type `Grid`, aka:. ```julia; abstract type Grid{T, Nx, Ny, Nz} end. struct RegularCartesianGrid{T, R, Nx, Ny, Nz} <: Grid{T, Nx, Ny, Nz}; ...; end; ```. Functions can then dispatch when one of `Nx`, etc is `1` (including halo-filling functions, which I think may fail when the size of the halo is 0). Another option is to use flags for each dimension rather than the actual size of the grid. In my opinion using the size makes the most sense. Using the actual size could have future advantages; for example, if some optimizations are possible when `Nz=2`. It is also nice to see the size of the grid from the type signature. A disadvantage is that we then could not have `mutable` grid types, but I'm not sure we want that. 2. There is a lot of redundant information in the `RegularCartesianGrid` struct: cell areas, volumes, total number of grid points, etc. I think it would be better --- meaning that our code would be shorter, easier to read, easier to maintain, easier to reason about (since storing them implies they *cannot* be computed, which is incorrect) and more computationally efficient --- to add functions that compute these quantities on the fly, rather than storing them in memory. Related: #287.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/330
https://github.com/CliMA/Oceananigans.jl/issues/330:1350,Energy Efficiency,efficient,efficient,1350,"I see a few things to improve with the grid right now. 1. We need to add some kind of type information that indicates whether a given dimension is 'flat'. One way to do this could simply be to add the grid sizes in each dimension as parameters in the abstract type `Grid`, aka:. ```julia; abstract type Grid{T, Nx, Ny, Nz} end. struct RegularCartesianGrid{T, R, Nx, Ny, Nz} <: Grid{T, Nx, Ny, Nz}; ...; end; ```. Functions can then dispatch when one of `Nx`, etc is `1` (including halo-filling functions, which I think may fail when the size of the halo is 0). Another option is to use flags for each dimension rather than the actual size of the grid. In my opinion using the size makes the most sense. Using the actual size could have future advantages; for example, if some optimizations are possible when `Nz=2`. It is also nice to see the size of the grid from the type signature. A disadvantage is that we then could not have `mutable` grid types, but I'm not sure we want that. 2. There is a lot of redundant information in the `RegularCartesianGrid` struct: cell areas, volumes, total number of grid points, etc. I think it would be better --- meaning that our code would be shorter, easier to read, easier to maintain, easier to reason about (since storing them implies they *cannot* be computed, which is incorrect) and more computationally efficient --- to add functions that compute these quantities on the fly, rather than storing them in memory. Related: #287.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/330
https://github.com/CliMA/Oceananigans.jl/issues/330:776,Performance,optimiz,optimizations,776,"I see a few things to improve with the grid right now. 1. We need to add some kind of type information that indicates whether a given dimension is 'flat'. One way to do this could simply be to add the grid sizes in each dimension as parameters in the abstract type `Grid`, aka:. ```julia; abstract type Grid{T, Nx, Ny, Nz} end. struct RegularCartesianGrid{T, R, Nx, Ny, Nz} <: Grid{T, Nx, Ny, Nz}; ...; end; ```. Functions can then dispatch when one of `Nx`, etc is `1` (including halo-filling functions, which I think may fail when the size of the halo is 0). Another option is to use flags for each dimension rather than the actual size of the grid. In my opinion using the size makes the most sense. Using the actual size could have future advantages; for example, if some optimizations are possible when `Nz=2`. It is also nice to see the size of the grid from the type signature. A disadvantage is that we then could not have `mutable` grid types, but I'm not sure we want that. 2. There is a lot of redundant information in the `RegularCartesianGrid` struct: cell areas, volumes, total number of grid points, etc. I think it would be better --- meaning that our code would be shorter, easier to read, easier to maintain, easier to reason about (since storing them implies they *cannot* be computed, which is incorrect) and more computationally efficient --- to add functions that compute these quantities on the fly, rather than storing them in memory. Related: #287.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/330
https://github.com/CliMA/Oceananigans.jl/issues/330:1005,Safety,redund,redundant,1005,"I see a few things to improve with the grid right now. 1. We need to add some kind of type information that indicates whether a given dimension is 'flat'. One way to do this could simply be to add the grid sizes in each dimension as parameters in the abstract type `Grid`, aka:. ```julia; abstract type Grid{T, Nx, Ny, Nz} end. struct RegularCartesianGrid{T, R, Nx, Ny, Nz} <: Grid{T, Nx, Ny, Nz}; ...; end; ```. Functions can then dispatch when one of `Nx`, etc is `1` (including halo-filling functions, which I think may fail when the size of the halo is 0). Another option is to use flags for each dimension rather than the actual size of the grid. In my opinion using the size makes the most sense. Using the actual size could have future advantages; for example, if some optimizations are possible when `Nz=2`. It is also nice to see the size of the grid from the type signature. A disadvantage is that we then could not have `mutable` grid types, but I'm not sure we want that. 2. There is a lot of redundant information in the `RegularCartesianGrid` struct: cell areas, volumes, total number of grid points, etc. I think it would be better --- meaning that our code would be shorter, easier to read, easier to maintain, easier to reason about (since storing them implies they *cannot* be computed, which is incorrect) and more computationally efficient --- to add functions that compute these quantities on the fly, rather than storing them in memory. Related: #287.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/330
https://github.com/CliMA/Oceananigans.jl/issues/330:180,Usability,simpl,simply,180,"I see a few things to improve with the grid right now. 1. We need to add some kind of type information that indicates whether a given dimension is 'flat'. One way to do this could simply be to add the grid sizes in each dimension as parameters in the abstract type `Grid`, aka:. ```julia; abstract type Grid{T, Nx, Ny, Nz} end. struct RegularCartesianGrid{T, R, Nx, Ny, Nz} <: Grid{T, Nx, Ny, Nz}; ...; end; ```. Functions can then dispatch when one of `Nx`, etc is `1` (including halo-filling functions, which I think may fail when the size of the halo is 0). Another option is to use flags for each dimension rather than the actual size of the grid. In my opinion using the size makes the most sense. Using the actual size could have future advantages; for example, if some optimizations are possible when `Nz=2`. It is also nice to see the size of the grid from the type signature. A disadvantage is that we then could not have `mutable` grid types, but I'm not sure we want that. 2. There is a lot of redundant information in the `RegularCartesianGrid` struct: cell areas, volumes, total number of grid points, etc. I think it would be better --- meaning that our code would be shorter, easier to read, easier to maintain, easier to reason about (since storing them implies they *cannot* be computed, which is incorrect) and more computationally efficient --- to add functions that compute these quantities on the fly, rather than storing them in memory. Related: #287.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/330
https://github.com/CliMA/Oceananigans.jl/issues/331:83,Deployability,patch,patch,83,@JuliaRegistrator register(). Bug fix #322 was pretty important so releasing a new patch.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/331
https://github.com/CliMA/Oceananigans.jl/pull/336:207,Availability,Error,Error,207,"PR co-authored with @sandreza . This PR tests Oceananigans with the Pearson vortex test from p. 310 of ""Nodal Discontinuous Galerkin Methods: Algorithms, Analysis, and Application"" by Hesthaven & Warburton. Error after 100 time steps:; ```julia; i: 100, t: 0.008, Δu: (avg=0.000224, max=0.000224), Δw: (avg=0.000224, max=0.000224); ```; which compares well with the DG error (considering our low-order numerics). We discovered that recomputing w from continuity breaks this test because du/dx = 0 and dv/dy = 0 by construction so w = 0 even though this is wrong. This is probably because we need to impose Neumann boundary condition on w, but recomputing w from continuity requires us to assume the value of `w[i, j, :]`, which we take to be 0 since we usually run with a rigid lid. So we switched to explicitly time stepping w which means this PR is ""DO NOT MERGE"" is its current state. Note: Before the test is merged, more comments are needed in the pearson vortex test.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/336
https://github.com/CliMA/Oceananigans.jl/pull/336:369,Availability,error,error,369,"PR co-authored with @sandreza . This PR tests Oceananigans with the Pearson vortex test from p. 310 of ""Nodal Discontinuous Galerkin Methods: Algorithms, Analysis, and Application"" by Hesthaven & Warburton. Error after 100 time steps:; ```julia; i: 100, t: 0.008, Δu: (avg=0.000224, max=0.000224), Δw: (avg=0.000224, max=0.000224); ```; which compares well with the DG error (considering our low-order numerics). We discovered that recomputing w from continuity breaks this test because du/dx = 0 and dv/dy = 0 by construction so w = 0 even though this is wrong. This is probably because we need to impose Neumann boundary condition on w, but recomputing w from continuity requires us to assume the value of `w[i, j, :]`, which we take to be 0 since we usually run with a rigid lid. So we switched to explicitly time stepping w which means this PR is ""DO NOT MERGE"" is its current state. Note: Before the test is merged, more comments are needed in the pearson vortex test.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/336
https://github.com/CliMA/Oceananigans.jl/pull/336:40,Testability,test,tests,40,"PR co-authored with @sandreza . This PR tests Oceananigans with the Pearson vortex test from p. 310 of ""Nodal Discontinuous Galerkin Methods: Algorithms, Analysis, and Application"" by Hesthaven & Warburton. Error after 100 time steps:; ```julia; i: 100, t: 0.008, Δu: (avg=0.000224, max=0.000224), Δw: (avg=0.000224, max=0.000224); ```; which compares well with the DG error (considering our low-order numerics). We discovered that recomputing w from continuity breaks this test because du/dx = 0 and dv/dy = 0 by construction so w = 0 even though this is wrong. This is probably because we need to impose Neumann boundary condition on w, but recomputing w from continuity requires us to assume the value of `w[i, j, :]`, which we take to be 0 since we usually run with a rigid lid. So we switched to explicitly time stepping w which means this PR is ""DO NOT MERGE"" is its current state. Note: Before the test is merged, more comments are needed in the pearson vortex test.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/336
https://github.com/CliMA/Oceananigans.jl/pull/336:83,Testability,test,test,83,"PR co-authored with @sandreza . This PR tests Oceananigans with the Pearson vortex test from p. 310 of ""Nodal Discontinuous Galerkin Methods: Algorithms, Analysis, and Application"" by Hesthaven & Warburton. Error after 100 time steps:; ```julia; i: 100, t: 0.008, Δu: (avg=0.000224, max=0.000224), Δw: (avg=0.000224, max=0.000224); ```; which compares well with the DG error (considering our low-order numerics). We discovered that recomputing w from continuity breaks this test because du/dx = 0 and dv/dy = 0 by construction so w = 0 even though this is wrong. This is probably because we need to impose Neumann boundary condition on w, but recomputing w from continuity requires us to assume the value of `w[i, j, :]`, which we take to be 0 since we usually run with a rigid lid. So we switched to explicitly time stepping w which means this PR is ""DO NOT MERGE"" is its current state. Note: Before the test is merged, more comments are needed in the pearson vortex test.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/336
https://github.com/CliMA/Oceananigans.jl/pull/336:474,Testability,test,test,474,"PR co-authored with @sandreza . This PR tests Oceananigans with the Pearson vortex test from p. 310 of ""Nodal Discontinuous Galerkin Methods: Algorithms, Analysis, and Application"" by Hesthaven & Warburton. Error after 100 time steps:; ```julia; i: 100, t: 0.008, Δu: (avg=0.000224, max=0.000224), Δw: (avg=0.000224, max=0.000224); ```; which compares well with the DG error (considering our low-order numerics). We discovered that recomputing w from continuity breaks this test because du/dx = 0 and dv/dy = 0 by construction so w = 0 even though this is wrong. This is probably because we need to impose Neumann boundary condition on w, but recomputing w from continuity requires us to assume the value of `w[i, j, :]`, which we take to be 0 since we usually run with a rigid lid. So we switched to explicitly time stepping w which means this PR is ""DO NOT MERGE"" is its current state. Note: Before the test is merged, more comments are needed in the pearson vortex test.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/336
https://github.com/CliMA/Oceananigans.jl/pull/336:905,Testability,test,test,905,"PR co-authored with @sandreza . This PR tests Oceananigans with the Pearson vortex test from p. 310 of ""Nodal Discontinuous Galerkin Methods: Algorithms, Analysis, and Application"" by Hesthaven & Warburton. Error after 100 time steps:; ```julia; i: 100, t: 0.008, Δu: (avg=0.000224, max=0.000224), Δw: (avg=0.000224, max=0.000224); ```; which compares well with the DG error (considering our low-order numerics). We discovered that recomputing w from continuity breaks this test because du/dx = 0 and dv/dy = 0 by construction so w = 0 even though this is wrong. This is probably because we need to impose Neumann boundary condition on w, but recomputing w from continuity requires us to assume the value of `w[i, j, :]`, which we take to be 0 since we usually run with a rigid lid. So we switched to explicitly time stepping w which means this PR is ""DO NOT MERGE"" is its current state. Note: Before the test is merged, more comments are needed in the pearson vortex test.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/336
https://github.com/CliMA/Oceananigans.jl/pull/336:968,Testability,test,test,968,"PR co-authored with @sandreza . This PR tests Oceananigans with the Pearson vortex test from p. 310 of ""Nodal Discontinuous Galerkin Methods: Algorithms, Analysis, and Application"" by Hesthaven & Warburton. Error after 100 time steps:; ```julia; i: 100, t: 0.008, Δu: (avg=0.000224, max=0.000224), Δw: (avg=0.000224, max=0.000224); ```; which compares well with the DG error (considering our low-order numerics). We discovered that recomputing w from continuity breaks this test because du/dx = 0 and dv/dy = 0 by construction so w = 0 even though this is wrong. This is probably because we need to impose Neumann boundary condition on w, but recomputing w from continuity requires us to assume the value of `w[i, j, :]`, which we take to be 0 since we usually run with a rigid lid. So we switched to explicitly time stepping w which means this PR is ""DO NOT MERGE"" is its current state. Note: Before the test is merged, more comments are needed in the pearson vortex test.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/336
https://github.com/CliMA/Oceananigans.jl/issues/338:131,Testability,test,tests,131,Found out int PR #336 that we can explicitly time-step w which will be nice as it'll work for simulations without a rigid lid. All tests passed when I made the change so should be a quick change.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/338
https://github.com/CliMA/Oceananigans.jl/issues/339:99,Deployability,patch,patch,99,@JuliaRegistrator register(). Bug fix in PR #337 is important for GPU usability so releasing a new patch.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/339
https://github.com/CliMA/Oceananigans.jl/issues/339:70,Usability,usab,usability,70,@JuliaRegistrator register(). Bug fix in PR #337 is important for GPU usability so releasing a new patch.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/339
https://github.com/CliMA/Oceananigans.jl/pull/340:106,Testability,test,testing,106,Don't need JLD or HDF5 since PR #329 removed the last use of a JLD output writer. This should speed up CI testing by quite a bit.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/340
https://github.com/CliMA/Oceananigans.jl/pull/341:113,Availability,avail,available,113,"This PR follows up on PR #337 . Should help with adding noise to initial conditions as `rand` and `randn` aren't available in CUDAnative.jl. So we can use arrays to initialize with noise. @glwagner you had issues with generating random numbers on the GPU in the past?. Looks like a ridiculously simple kernel lol but it means you just supply an` Nx*Ny*Nz` sized array and not have to worry about halos, or broadcasting over views of non-contiguous views (which results is slow CuArray scalar operations).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/341
https://github.com/CliMA/Oceananigans.jl/pull/341:295,Usability,simpl,simple,295,"This PR follows up on PR #337 . Should help with adding noise to initial conditions as `rand` and `randn` aren't available in CUDAnative.jl. So we can use arrays to initialize with noise. @glwagner you had issues with generating random numbers on the GPU in the past?. Looks like a ridiculously simple kernel lol but it means you just supply an` Nx*Ny*Nz` sized array and not have to worry about halos, or broadcasting over views of non-contiguous views (which results is slow CuArray scalar operations).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/341
https://github.com/CliMA/Oceananigans.jl/pull/343:270,Availability,avail,available,270,"Just combining my commits from PRs #337 and #341. Idea is to make life more comfortable by getting `set!` to work out of the box for CPU and GPU fields, and for setting them with functions or arrays. The functions should be evaluated on the CPU as not every function is available through CUDAnative (notably `rand` and `randn` are missing). Will switch to using `copyto!`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/343
https://github.com/CliMA/Oceananigans.jl/issues/344:326,Availability,error,errors,326,Would be good to have a feature that splits JLD2 files by size (e.g. maximum file size of 50 GiB or 100 outputs per file). Running large simulations right now is risky because the JLD2 files keeps getting appended to so it keeps growing in size (especially since JLD2 does not compress by default) and if the simulation stops/errors/is killed during IO the JLD2 file and all output is corrupted. We should probably also add an `info=false` flag to `JLD2OutputWriter` that is `false` by default in case a user does not want any JLD2 timings/statistics.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/344
https://github.com/CliMA/Oceananigans.jl/issues/344:162,Safety,risk,risky,162,Would be good to have a feature that splits JLD2 files by size (e.g. maximum file size of 50 GiB or 100 outputs per file). Running large simulations right now is risky because the JLD2 files keeps getting appended to so it keeps growing in size (especially since JLD2 does not compress by default) and if the simulation stops/errors/is killed during IO the JLD2 file and all output is corrupted. We should probably also add an `info=false` flag to `JLD2OutputWriter` that is `false` by default in case a user does not want any JLD2 timings/statistics.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/344
https://github.com/CliMA/Oceananigans.jl/issues/345:132,Deployability,patch,patch,132,@JuliaRegistrator register(). The sophisticated `set!` function introduced in PR #343 is important for usability so releasing a new patch that incorporates it.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/345
https://github.com/CliMA/Oceananigans.jl/issues/345:103,Usability,usab,usability,103,@JuliaRegistrator register(). The sophisticated `set!` function introduced in PR #343 is important for usability so releasing a new patch that incorporates it.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/345
https://github.com/CliMA/Oceananigans.jl/issues/346:317,Energy Efficiency,Green,Green,317,"Just throwing these in here to document what we've discussed. 1. Rayleigh–Bénard convection (DNS, LES?). @glwagner ; 2. Stratified Couette flow (DNS + LES). @ali-ramadhan ; 3. Homogenous cooling in a stratified flow. @glwagner ; 4. Idealized deep convection (compare with MITgcm). @ali-ramadhan and @jm-c ; 5. Taylor-Green vortex. @sandreza and @ali-ramadhan (Done in PR #336). ![unnamed](https://user-images.githubusercontent.com/20099589/62747395-3c9bab00-ba22-11e9-9f08-95a0f91dbc6c.jpg). Photo credit: @christophernhill",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/346
https://github.com/CliMA/Oceananigans.jl/issues/347:394,Deployability,pipeline,pipeline,394,Following the discussion on testing infrastructure from a long time ago (PR #139) it would be good to convert any verification tests that result from #346 into an actual end-to-end test of the model. Not sure how the comparison with MITgcm would be implemented but maybe the others are good enough. `test/verification/` might be a good directory for them?. They can be run separately (separate pipeline) so they don't have to run quickly and can take a while so they can be comprehensive.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/347
https://github.com/CliMA/Oceananigans.jl/issues/347:28,Testability,test,testing,28,Following the discussion on testing infrastructure from a long time ago (PR #139) it would be good to convert any verification tests that result from #346 into an actual end-to-end test of the model. Not sure how the comparison with MITgcm would be implemented but maybe the others are good enough. `test/verification/` might be a good directory for them?. They can be run separately (separate pipeline) so they don't have to run quickly and can take a while so they can be comprehensive.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/347
https://github.com/CliMA/Oceananigans.jl/issues/347:127,Testability,test,tests,127,Following the discussion on testing infrastructure from a long time ago (PR #139) it would be good to convert any verification tests that result from #346 into an actual end-to-end test of the model. Not sure how the comparison with MITgcm would be implemented but maybe the others are good enough. `test/verification/` might be a good directory for them?. They can be run separately (separate pipeline) so they don't have to run quickly and can take a while so they can be comprehensive.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/347
https://github.com/CliMA/Oceananigans.jl/issues/347:181,Testability,test,test,181,Following the discussion on testing infrastructure from a long time ago (PR #139) it would be good to convert any verification tests that result from #346 into an actual end-to-end test of the model. Not sure how the comparison with MITgcm would be implemented but maybe the others are good enough. `test/verification/` might be a good directory for them?. They can be run separately (separate pipeline) so they don't have to run quickly and can take a while so they can be comprehensive.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/347
https://github.com/CliMA/Oceananigans.jl/issues/347:300,Testability,test,test,300,Following the discussion on testing infrastructure from a long time ago (PR #139) it would be good to convert any verification tests that result from #346 into an actual end-to-end test of the model. Not sure how the comparison with MITgcm would be implemented but maybe the others are good enough. `test/verification/` might be a good directory for them?. They can be run separately (separate pipeline) so they don't have to run quickly and can take a while so they can be comprehensive.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/347
https://github.com/CliMA/Oceananigans.jl/pull/350:8,Modifiability,extend,extends,8,"This PR extends the `JLD2OutputWriter` with two new options: `verbose` and `max_filesize`. When `verbose=true` the `JLD2OutputWriter` logs what it is doing, how long it takes to copy/compute output and write output, and the file size of the output (current and delta). When `max_filesize=true`, the `JLD2OutputWriter` will stop writing to the output file once the file size exceeds `max_filesize`, and write to a new one with a consistent naming scheme. In action:; ```julia; using Oceananigans; model = Model(N=(64, 64, 64), L=(1, 1, 1)). u(model) = model.velocities.u.data.parent; fields = Dict(:u => u); ow = JLD2OutputWriter(model, fields; prefix=""test"", frequency=5, max_filesize=10MiB, force=true, verbose=true); push!(model.output_writers, ow). time_step!(model, 50, 1); ```; ```; [ Info: Calculating JLD2 output Symbol[:u]...; [ Info: Calculation time: 4.608 μs; [ Info: Writing JLD2 output Symbol[:u]...; [ Info: Writing done: time=3.822 s, size=2.2 MiB, Δsize=2.2 MiB; [ Info: Calculating JLD2 output Symbol[:u]...; [ Info: Calculation time: 2.891 μs; [ Info: Writing JLD2 output Symbol[:u]...; [ Info: Writing done: time=22.262 ms, size=4.4 MiB, Δsize=2.2 MiB; [ Info: Calculating JLD2 output Symbol[:u]...; [ Info: Calculation time: 3.118 μs; [ Info: Writing JLD2 output Symbol[:u]...; [ Info: Writing done: time=22.564 ms, size=6.6 MiB, Δsize=2.2 MiB; [ Info: Calculating JLD2 output Symbol[:u]...; [ Info: Calculation time: 2.479 μs; [ Info: Writing JLD2 output Symbol[:u]...; [ Info: Writing done: time=18.126 ms, size=8.8 MiB, Δsize=2.2 MiB; [ Info: Calculating JLD2 output Symbol[:u]...; [ Info: Calculation time: 3.421 μs; [ Info: Writing JLD2 output Symbol[:u]...; [ Info: Writing done: time=23.091 ms, size=11.0 MiB, Δsize=2.2 MiB; [ Info: Calculating JLD2 output Symbol[:u]...; [ Info: Calculation time: 2.627 μs; [ Info: Filesize 11.0 MiB has exceeded maximum file size 10.0 MiB.; [ Info: Renaming first part: ./test.jld2 -> ./test_part1.jld2; [ Info: Now writing to: ./test_part",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/350
https://github.com/CliMA/Oceananigans.jl/pull/350:134,Testability,log,logs,134,"This PR extends the `JLD2OutputWriter` with two new options: `verbose` and `max_filesize`. When `verbose=true` the `JLD2OutputWriter` logs what it is doing, how long it takes to copy/compute output and write output, and the file size of the output (current and delta). When `max_filesize=true`, the `JLD2OutputWriter` will stop writing to the output file once the file size exceeds `max_filesize`, and write to a new one with a consistent naming scheme. In action:; ```julia; using Oceananigans; model = Model(N=(64, 64, 64), L=(1, 1, 1)). u(model) = model.velocities.u.data.parent; fields = Dict(:u => u); ow = JLD2OutputWriter(model, fields; prefix=""test"", frequency=5, max_filesize=10MiB, force=true, verbose=true); push!(model.output_writers, ow). time_step!(model, 50, 1); ```; ```; [ Info: Calculating JLD2 output Symbol[:u]...; [ Info: Calculation time: 4.608 μs; [ Info: Writing JLD2 output Symbol[:u]...; [ Info: Writing done: time=3.822 s, size=2.2 MiB, Δsize=2.2 MiB; [ Info: Calculating JLD2 output Symbol[:u]...; [ Info: Calculation time: 2.891 μs; [ Info: Writing JLD2 output Symbol[:u]...; [ Info: Writing done: time=22.262 ms, size=4.4 MiB, Δsize=2.2 MiB; [ Info: Calculating JLD2 output Symbol[:u]...; [ Info: Calculation time: 3.118 μs; [ Info: Writing JLD2 output Symbol[:u]...; [ Info: Writing done: time=22.564 ms, size=6.6 MiB, Δsize=2.2 MiB; [ Info: Calculating JLD2 output Symbol[:u]...; [ Info: Calculation time: 2.479 μs; [ Info: Writing JLD2 output Symbol[:u]...; [ Info: Writing done: time=18.126 ms, size=8.8 MiB, Δsize=2.2 MiB; [ Info: Calculating JLD2 output Symbol[:u]...; [ Info: Calculation time: 3.421 μs; [ Info: Writing JLD2 output Symbol[:u]...; [ Info: Writing done: time=23.091 ms, size=11.0 MiB, Δsize=2.2 MiB; [ Info: Calculating JLD2 output Symbol[:u]...; [ Info: Calculation time: 2.627 μs; [ Info: Filesize 11.0 MiB has exceeded maximum file size 10.0 MiB.; [ Info: Renaming first part: ./test.jld2 -> ./test_part1.jld2; [ Info: Now writing to: ./test_part",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/350
https://github.com/CliMA/Oceananigans.jl/pull/350:652,Testability,test,test,652,"This PR extends the `JLD2OutputWriter` with two new options: `verbose` and `max_filesize`. When `verbose=true` the `JLD2OutputWriter` logs what it is doing, how long it takes to copy/compute output and write output, and the file size of the output (current and delta). When `max_filesize=true`, the `JLD2OutputWriter` will stop writing to the output file once the file size exceeds `max_filesize`, and write to a new one with a consistent naming scheme. In action:; ```julia; using Oceananigans; model = Model(N=(64, 64, 64), L=(1, 1, 1)). u(model) = model.velocities.u.data.parent; fields = Dict(:u => u); ow = JLD2OutputWriter(model, fields; prefix=""test"", frequency=5, max_filesize=10MiB, force=true, verbose=true); push!(model.output_writers, ow). time_step!(model, 50, 1); ```; ```; [ Info: Calculating JLD2 output Symbol[:u]...; [ Info: Calculation time: 4.608 μs; [ Info: Writing JLD2 output Symbol[:u]...; [ Info: Writing done: time=3.822 s, size=2.2 MiB, Δsize=2.2 MiB; [ Info: Calculating JLD2 output Symbol[:u]...; [ Info: Calculation time: 2.891 μs; [ Info: Writing JLD2 output Symbol[:u]...; [ Info: Writing done: time=22.262 ms, size=4.4 MiB, Δsize=2.2 MiB; [ Info: Calculating JLD2 output Symbol[:u]...; [ Info: Calculation time: 3.118 μs; [ Info: Writing JLD2 output Symbol[:u]...; [ Info: Writing done: time=22.564 ms, size=6.6 MiB, Δsize=2.2 MiB; [ Info: Calculating JLD2 output Symbol[:u]...; [ Info: Calculation time: 2.479 μs; [ Info: Writing JLD2 output Symbol[:u]...; [ Info: Writing done: time=18.126 ms, size=8.8 MiB, Δsize=2.2 MiB; [ Info: Calculating JLD2 output Symbol[:u]...; [ Info: Calculation time: 3.421 μs; [ Info: Writing JLD2 output Symbol[:u]...; [ Info: Writing done: time=23.091 ms, size=11.0 MiB, Δsize=2.2 MiB; [ Info: Calculating JLD2 output Symbol[:u]...; [ Info: Calculation time: 2.627 μs; [ Info: Filesize 11.0 MiB has exceeded maximum file size 10.0 MiB.; [ Info: Renaming first part: ./test.jld2 -> ./test_part1.jld2; [ Info: Now writing to: ./test_part",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/350
https://github.com/CliMA/Oceananigans.jl/pull/350:1934,Testability,test,test,1934,"ies.u.data.parent; fields = Dict(:u => u); ow = JLD2OutputWriter(model, fields; prefix=""test"", frequency=5, max_filesize=10MiB, force=true, verbose=true); push!(model.output_writers, ow). time_step!(model, 50, 1); ```; ```; [ Info: Calculating JLD2 output Symbol[:u]...; [ Info: Calculation time: 4.608 μs; [ Info: Writing JLD2 output Symbol[:u]...; [ Info: Writing done: time=3.822 s, size=2.2 MiB, Δsize=2.2 MiB; [ Info: Calculating JLD2 output Symbol[:u]...; [ Info: Calculation time: 2.891 μs; [ Info: Writing JLD2 output Symbol[:u]...; [ Info: Writing done: time=22.262 ms, size=4.4 MiB, Δsize=2.2 MiB; [ Info: Calculating JLD2 output Symbol[:u]...; [ Info: Calculation time: 3.118 μs; [ Info: Writing JLD2 output Symbol[:u]...; [ Info: Writing done: time=22.564 ms, size=6.6 MiB, Δsize=2.2 MiB; [ Info: Calculating JLD2 output Symbol[:u]...; [ Info: Calculation time: 2.479 μs; [ Info: Writing JLD2 output Symbol[:u]...; [ Info: Writing done: time=18.126 ms, size=8.8 MiB, Δsize=2.2 MiB; [ Info: Calculating JLD2 output Symbol[:u]...; [ Info: Calculation time: 3.421 μs; [ Info: Writing JLD2 output Symbol[:u]...; [ Info: Writing done: time=23.091 ms, size=11.0 MiB, Δsize=2.2 MiB; [ Info: Calculating JLD2 output Symbol[:u]...; [ Info: Calculation time: 2.627 μs; [ Info: Filesize 11.0 MiB has exceeded maximum file size 10.0 MiB.; [ Info: Renaming first part: ./test.jld2 -> ./test_part1.jld2; [ Info: Now writing to: ./test_part2.jld2; [ Info: Writing JLD2 output Symbol[:u]...; [ Info: Writing done: time=19.754 ms, size=2.2 MiB, Δsize=2.2 MiB; [ Info: Calculating JLD2 output Symbol[:u]...; [ Info: Calculation time: 3.320 μs; [ Info: Writing JLD2 output Symbol[:u]...; [ Info: Writing done: time=13.866 ms, size=4.4 MiB, Δsize=2.2 MiB; ...; ..; .; .; .; ```. At the end:; ```; Permissions Size User Date Modified Name; .rw-r--r-- 11M alir 10 Aug 10:20 test_part1.jld2; .rw-r--r-- 11M alir 10 Aug 10:20 test_part2.jld2; .rw-r--r-- 2.3M alir 10 Aug 10:20 test_part3.jld2; ```. Resolves #344",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/350
https://github.com/CliMA/Oceananigans.jl/issues/351:233,Safety,avoid,avoid,233,"Starting to get tests failing because of conflicting qualifiers, e.g. both `Base` and `CUDAdrv` define `@elapsed`. Would be good to revise our existing `using` and `import` statements so that we only bring in exactly what we need to avoid these kinds of issues. And I believe it's good practice anyways.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/351
https://github.com/CliMA/Oceananigans.jl/issues/351:16,Testability,test,tests,16,"Starting to get tests failing because of conflicting qualifiers, e.g. both `Base` and `CUDAdrv` define `@elapsed`. Would be good to revise our existing `using` and `import` statements so that we only bring in exactly what we need to avoid these kinds of issues. And I believe it's good practice anyways.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/351
https://github.com/CliMA/Oceananigans.jl/pull/352:131,Energy Efficiency,efficient,efficiently,131,"This PR reorganizes the diagnostics structs and introduces a new `VerticalProfile` diagnostic that can calculate vertical profiles efficiently on-the-fly on CPUs and GPUs. Product profiles and velocity covariance profiles are built on top of it. `HorizontallyAveragedVerticalProfile` would be a more accurate name, but is much longer. So I'm sticking with the ""convention"" that a profile is implied to be horizontally averaged. The `profile` can be passed to an output writer which can write it to disk. The horizontal averaging currently relies on a parallel reduction prefix sum algorithm that I hacked over a CUDAnative.jl example, although I do have a test for the diagnostic so it does work. The algorithm can be more efficient (see https://github.com/JuliaGPU/CuArrays.jl/issues/68). It allocates very minimal amounts of memory (less than `mean`) and benchmarks show that it is ~20x faster than what we were doing before (copying to CPU and calculating there) which is great but it's ~5x slower than optimal performance. As it does not allocate memory, we can now calculate vertical profiles even when running large models that fill up memory. Although I should mention that an intermediate array with a size of at least `1*Ny*Nz` is required for the parallel reduction step (so I'm using `poisson_solvers.storage` because it's a vanilla CuArray that can be overwritten). ```julia; N, H = 512, 1; T = N + 2H. a = rand(T, T, T) |> CuArray; h = zeros(N) |> CuArray; ```. What we were doing before:; ```julia; @benchmark CuArrays.@sync mean(Array(view(a, H:N+H, H:N+H, H:N+H)), dims=[1, 2]). BenchmarkTools.Trial: ; memory estimate: 1.01 GiB; allocs estimate: 250; --------------; minimum time: 684.013 ms (2.29% GC); median time: 712.570 ms (6.28% GC); mean time: 732.480 ms (8.79% GC); maximum time: 807.437 ms (16.95% GC); --------------; samples: 7; evals/sample: 1; ```. What this PR does:; ```julia; Nx, Ny, Nz = 512, 512, 512; C = rand(Nx, Ny, Nz) |> CuArray; Rx = zeros(Float64, 1, Ny, Nz) ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/352
https://github.com/CliMA/Oceananigans.jl/pull/352:723,Energy Efficiency,efficient,efficient,723,"This PR reorganizes the diagnostics structs and introduces a new `VerticalProfile` diagnostic that can calculate vertical profiles efficiently on-the-fly on CPUs and GPUs. Product profiles and velocity covariance profiles are built on top of it. `HorizontallyAveragedVerticalProfile` would be a more accurate name, but is much longer. So I'm sticking with the ""convention"" that a profile is implied to be horizontally averaged. The `profile` can be passed to an output writer which can write it to disk. The horizontal averaging currently relies on a parallel reduction prefix sum algorithm that I hacked over a CUDAnative.jl example, although I do have a test for the diagnostic so it does work. The algorithm can be more efficient (see https://github.com/JuliaGPU/CuArrays.jl/issues/68). It allocates very minimal amounts of memory (less than `mean`) and benchmarks show that it is ~20x faster than what we were doing before (copying to CPU and calculating there) which is great but it's ~5x slower than optimal performance. As it does not allocate memory, we can now calculate vertical profiles even when running large models that fill up memory. Although I should mention that an intermediate array with a size of at least `1*Ny*Nz` is required for the parallel reduction step (so I'm using `poisson_solvers.storage` because it's a vanilla CuArray that can be overwritten). ```julia; N, H = 512, 1; T = N + 2H. a = rand(T, T, T) |> CuArray; h = zeros(N) |> CuArray; ```. What we were doing before:; ```julia; @benchmark CuArrays.@sync mean(Array(view(a, H:N+H, H:N+H, H:N+H)), dims=[1, 2]). BenchmarkTools.Trial: ; memory estimate: 1.01 GiB; allocs estimate: 250; --------------; minimum time: 684.013 ms (2.29% GC); median time: 712.570 ms (6.28% GC); mean time: 732.480 ms (8.79% GC); maximum time: 807.437 ms (16.95% GC); --------------; samples: 7; evals/sample: 1; ```. What this PR does:; ```julia; Nx, Ny, Nz = 512, 512, 512; C = rand(Nx, Ny, Nz) |> CuArray; Rx = zeros(Float64, 1, Ny, Nz) ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/352
https://github.com/CliMA/Oceananigans.jl/pull/352:793,Energy Efficiency,allocate,allocates,793,"This PR reorganizes the diagnostics structs and introduces a new `VerticalProfile` diagnostic that can calculate vertical profiles efficiently on-the-fly on CPUs and GPUs. Product profiles and velocity covariance profiles are built on top of it. `HorizontallyAveragedVerticalProfile` would be a more accurate name, but is much longer. So I'm sticking with the ""convention"" that a profile is implied to be horizontally averaged. The `profile` can be passed to an output writer which can write it to disk. The horizontal averaging currently relies on a parallel reduction prefix sum algorithm that I hacked over a CUDAnative.jl example, although I do have a test for the diagnostic so it does work. The algorithm can be more efficient (see https://github.com/JuliaGPU/CuArrays.jl/issues/68). It allocates very minimal amounts of memory (less than `mean`) and benchmarks show that it is ~20x faster than what we were doing before (copying to CPU and calculating there) which is great but it's ~5x slower than optimal performance. As it does not allocate memory, we can now calculate vertical profiles even when running large models that fill up memory. Although I should mention that an intermediate array with a size of at least `1*Ny*Nz` is required for the parallel reduction step (so I'm using `poisson_solvers.storage` because it's a vanilla CuArray that can be overwritten). ```julia; N, H = 512, 1; T = N + 2H. a = rand(T, T, T) |> CuArray; h = zeros(N) |> CuArray; ```. What we were doing before:; ```julia; @benchmark CuArrays.@sync mean(Array(view(a, H:N+H, H:N+H, H:N+H)), dims=[1, 2]). BenchmarkTools.Trial: ; memory estimate: 1.01 GiB; allocs estimate: 250; --------------; minimum time: 684.013 ms (2.29% GC); median time: 712.570 ms (6.28% GC); mean time: 732.480 ms (8.79% GC); maximum time: 807.437 ms (16.95% GC); --------------; samples: 7; evals/sample: 1; ```. What this PR does:; ```julia; Nx, Ny, Nz = 512, 512, 512; C = rand(Nx, Ny, Nz) |> CuArray; Rx = zeros(Float64, 1, Ny, Nz) ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/352
https://github.com/CliMA/Oceananigans.jl/pull/352:1042,Energy Efficiency,allocate,allocate,1042,"nostic that can calculate vertical profiles efficiently on-the-fly on CPUs and GPUs. Product profiles and velocity covariance profiles are built on top of it. `HorizontallyAveragedVerticalProfile` would be a more accurate name, but is much longer. So I'm sticking with the ""convention"" that a profile is implied to be horizontally averaged. The `profile` can be passed to an output writer which can write it to disk. The horizontal averaging currently relies on a parallel reduction prefix sum algorithm that I hacked over a CUDAnative.jl example, although I do have a test for the diagnostic so it does work. The algorithm can be more efficient (see https://github.com/JuliaGPU/CuArrays.jl/issues/68). It allocates very minimal amounts of memory (less than `mean`) and benchmarks show that it is ~20x faster than what we were doing before (copying to CPU and calculating there) which is great but it's ~5x slower than optimal performance. As it does not allocate memory, we can now calculate vertical profiles even when running large models that fill up memory. Although I should mention that an intermediate array with a size of at least `1*Ny*Nz` is required for the parallel reduction step (so I'm using `poisson_solvers.storage` because it's a vanilla CuArray that can be overwritten). ```julia; N, H = 512, 1; T = N + 2H. a = rand(T, T, T) |> CuArray; h = zeros(N) |> CuArray; ```. What we were doing before:; ```julia; @benchmark CuArrays.@sync mean(Array(view(a, H:N+H, H:N+H, H:N+H)), dims=[1, 2]). BenchmarkTools.Trial: ; memory estimate: 1.01 GiB; allocs estimate: 250; --------------; minimum time: 684.013 ms (2.29% GC); median time: 712.570 ms (6.28% GC); mean time: 732.480 ms (8.79% GC); maximum time: 807.437 ms (16.95% GC); --------------; samples: 7; evals/sample: 1; ```. What this PR does:; ```julia; Nx, Ny, Nz = 512, 512, 512; C = rand(Nx, Ny, Nz) |> CuArray; Rx = zeros(Float64, 1, Ny, Nz) |> CuArray; Rxy = zeros(Float64, 1, 1, Nz) |> CuArray. @benchmark CuArrays.@sync @cuda ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/352
https://github.com/CliMA/Oceananigans.jl/pull/352:1014,Performance,perform,performance,1014,"This PR reorganizes the diagnostics structs and introduces a new `VerticalProfile` diagnostic that can calculate vertical profiles efficiently on-the-fly on CPUs and GPUs. Product profiles and velocity covariance profiles are built on top of it. `HorizontallyAveragedVerticalProfile` would be a more accurate name, but is much longer. So I'm sticking with the ""convention"" that a profile is implied to be horizontally averaged. The `profile` can be passed to an output writer which can write it to disk. The horizontal averaging currently relies on a parallel reduction prefix sum algorithm that I hacked over a CUDAnative.jl example, although I do have a test for the diagnostic so it does work. The algorithm can be more efficient (see https://github.com/JuliaGPU/CuArrays.jl/issues/68). It allocates very minimal amounts of memory (less than `mean`) and benchmarks show that it is ~20x faster than what we were doing before (copying to CPU and calculating there) which is great but it's ~5x slower than optimal performance. As it does not allocate memory, we can now calculate vertical profiles even when running large models that fill up memory. Although I should mention that an intermediate array with a size of at least `1*Ny*Nz` is required for the parallel reduction step (so I'm using `poisson_solvers.storage` because it's a vanilla CuArray that can be overwritten). ```julia; N, H = 512, 1; T = N + 2H. a = rand(T, T, T) |> CuArray; h = zeros(N) |> CuArray; ```. What we were doing before:; ```julia; @benchmark CuArrays.@sync mean(Array(view(a, H:N+H, H:N+H, H:N+H)), dims=[1, 2]). BenchmarkTools.Trial: ; memory estimate: 1.01 GiB; allocs estimate: 250; --------------; minimum time: 684.013 ms (2.29% GC); median time: 712.570 ms (6.28% GC); mean time: 732.480 ms (8.79% GC); maximum time: 807.437 ms (16.95% GC); --------------; samples: 7; evals/sample: 1; ```. What this PR does:; ```julia; Nx, Ny, Nz = 512, 512, 512; C = rand(Nx, Ny, Nz) |> CuArray; Rx = zeros(Float64, 1, Ny, Nz) ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/352
https://github.com/CliMA/Oceananigans.jl/pull/352:2476,Performance,perform,performance,2476,"s than `mean`) and benchmarks show that it is ~20x faster than what we were doing before (copying to CPU and calculating there) which is great but it's ~5x slower than optimal performance. As it does not allocate memory, we can now calculate vertical profiles even when running large models that fill up memory. Although I should mention that an intermediate array with a size of at least `1*Ny*Nz` is required for the parallel reduction step (so I'm using `poisson_solvers.storage` because it's a vanilla CuArray that can be overwritten). ```julia; N, H = 512, 1; T = N + 2H. a = rand(T, T, T) |> CuArray; h = zeros(N) |> CuArray; ```. What we were doing before:; ```julia; @benchmark CuArrays.@sync mean(Array(view(a, H:N+H, H:N+H, H:N+H)), dims=[1, 2]). BenchmarkTools.Trial: ; memory estimate: 1.01 GiB; allocs estimate: 250; --------------; minimum time: 684.013 ms (2.29% GC); median time: 712.570 ms (6.28% GC); mean time: 732.480 ms (8.79% GC); maximum time: 807.437 ms (16.95% GC); --------------; samples: 7; evals/sample: 1; ```. What this PR does:; ```julia; Nx, Ny, Nz = 512, 512, 512; C = rand(Nx, Ny, Nz) |> CuArray; Rx = zeros(Float64, 1, Ny, Nz) |> CuArray; Rxy = zeros(Float64, 1, 1, Nz) |> CuArray. @benchmark CuArrays.@sync @cuda threads=Nx blocks=(Ny, Nz) shmem=2*Nx*sizeof(eltype(C)) gpu_accumulate_xy!(Rxy, Rx, C, +). BenchmarkTools.Trial: ; memory estimate: 2.88 KiB; allocs estimate: 64; --------------; minimum time: 39.129 ms (0.00% GC); median time: 39.245 ms (0.00% GC); mean time: 39.248 ms (0.00% GC); maximum time: 39.374 ms (0.00% GC); --------------; samples: 128; evals/sample: 1; ```. Probably optimal performance:; ```julia; @benchmark CuArrays.@sync mean(a, dims=[1, 2]). BenchmarkTools.Trial: ; memory estimate: 8.56 KiB; allocs estimate: 220; --------------; minimum time: 7.426 ms (0.00% GC); median time: 7.526 ms (0.00% GC); mean time: 7.527 ms (0.00% GC); maximum time: 8.817 ms (0.00% GC); --------------; samples: 663; evals/sample: 1; ```. Resolves #186",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/352
https://github.com/CliMA/Oceananigans.jl/pull/352:656,Testability,test,test,656,"This PR reorganizes the diagnostics structs and introduces a new `VerticalProfile` diagnostic that can calculate vertical profiles efficiently on-the-fly on CPUs and GPUs. Product profiles and velocity covariance profiles are built on top of it. `HorizontallyAveragedVerticalProfile` would be a more accurate name, but is much longer. So I'm sticking with the ""convention"" that a profile is implied to be horizontally averaged. The `profile` can be passed to an output writer which can write it to disk. The horizontal averaging currently relies on a parallel reduction prefix sum algorithm that I hacked over a CUDAnative.jl example, although I do have a test for the diagnostic so it does work. The algorithm can be more efficient (see https://github.com/JuliaGPU/CuArrays.jl/issues/68). It allocates very minimal amounts of memory (less than `mean`) and benchmarks show that it is ~20x faster than what we were doing before (copying to CPU and calculating there) which is great but it's ~5x slower than optimal performance. As it does not allocate memory, we can now calculate vertical profiles even when running large models that fill up memory. Although I should mention that an intermediate array with a size of at least `1*Ny*Nz` is required for the parallel reduction step (so I'm using `poisson_solvers.storage` because it's a vanilla CuArray that can be overwritten). ```julia; N, H = 512, 1; T = N + 2H. a = rand(T, T, T) |> CuArray; h = zeros(N) |> CuArray; ```. What we were doing before:; ```julia; @benchmark CuArrays.@sync mean(Array(view(a, H:N+H, H:N+H, H:N+H)), dims=[1, 2]). BenchmarkTools.Trial: ; memory estimate: 1.01 GiB; allocs estimate: 250; --------------; minimum time: 684.013 ms (2.29% GC); median time: 712.570 ms (6.28% GC); mean time: 732.480 ms (8.79% GC); maximum time: 807.437 ms (16.95% GC); --------------; samples: 7; evals/sample: 1; ```. What this PR does:; ```julia; Nx, Ny, Nz = 512, 512, 512; C = rand(Nx, Ny, Nz) |> CuArray; Rx = zeros(Float64, 1, Ny, Nz) ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/352
https://github.com/CliMA/Oceananigans.jl/pull/352:857,Testability,benchmark,benchmarks,857,"This PR reorganizes the diagnostics structs and introduces a new `VerticalProfile` diagnostic that can calculate vertical profiles efficiently on-the-fly on CPUs and GPUs. Product profiles and velocity covariance profiles are built on top of it. `HorizontallyAveragedVerticalProfile` would be a more accurate name, but is much longer. So I'm sticking with the ""convention"" that a profile is implied to be horizontally averaged. The `profile` can be passed to an output writer which can write it to disk. The horizontal averaging currently relies on a parallel reduction prefix sum algorithm that I hacked over a CUDAnative.jl example, although I do have a test for the diagnostic so it does work. The algorithm can be more efficient (see https://github.com/JuliaGPU/CuArrays.jl/issues/68). It allocates very minimal amounts of memory (less than `mean`) and benchmarks show that it is ~20x faster than what we were doing before (copying to CPU and calculating there) which is great but it's ~5x slower than optimal performance. As it does not allocate memory, we can now calculate vertical profiles even when running large models that fill up memory. Although I should mention that an intermediate array with a size of at least `1*Ny*Nz` is required for the parallel reduction step (so I'm using `poisson_solvers.storage` because it's a vanilla CuArray that can be overwritten). ```julia; N, H = 512, 1; T = N + 2H. a = rand(T, T, T) |> CuArray; h = zeros(N) |> CuArray; ```. What we were doing before:; ```julia; @benchmark CuArrays.@sync mean(Array(view(a, H:N+H, H:N+H, H:N+H)), dims=[1, 2]). BenchmarkTools.Trial: ; memory estimate: 1.01 GiB; allocs estimate: 250; --------------; minimum time: 684.013 ms (2.29% GC); median time: 712.570 ms (6.28% GC); mean time: 732.480 ms (8.79% GC); maximum time: 807.437 ms (16.95% GC); --------------; samples: 7; evals/sample: 1; ```. What this PR does:; ```julia; Nx, Ny, Nz = 512, 512, 512; C = rand(Nx, Ny, Nz) |> CuArray; Rx = zeros(Float64, 1, Ny, Nz) ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/352
https://github.com/CliMA/Oceananigans.jl/pull/352:1514,Testability,benchmark,benchmark,1514," The horizontal averaging currently relies on a parallel reduction prefix sum algorithm that I hacked over a CUDAnative.jl example, although I do have a test for the diagnostic so it does work. The algorithm can be more efficient (see https://github.com/JuliaGPU/CuArrays.jl/issues/68). It allocates very minimal amounts of memory (less than `mean`) and benchmarks show that it is ~20x faster than what we were doing before (copying to CPU and calculating there) which is great but it's ~5x slower than optimal performance. As it does not allocate memory, we can now calculate vertical profiles even when running large models that fill up memory. Although I should mention that an intermediate array with a size of at least `1*Ny*Nz` is required for the parallel reduction step (so I'm using `poisson_solvers.storage` because it's a vanilla CuArray that can be overwritten). ```julia; N, H = 512, 1; T = N + 2H. a = rand(T, T, T) |> CuArray; h = zeros(N) |> CuArray; ```. What we were doing before:; ```julia; @benchmark CuArrays.@sync mean(Array(view(a, H:N+H, H:N+H, H:N+H)), dims=[1, 2]). BenchmarkTools.Trial: ; memory estimate: 1.01 GiB; allocs estimate: 250; --------------; minimum time: 684.013 ms (2.29% GC); median time: 712.570 ms (6.28% GC); mean time: 732.480 ms (8.79% GC); maximum time: 807.437 ms (16.95% GC); --------------; samples: 7; evals/sample: 1; ```. What this PR does:; ```julia; Nx, Ny, Nz = 512, 512, 512; C = rand(Nx, Ny, Nz) |> CuArray; Rx = zeros(Float64, 1, Ny, Nz) |> CuArray; Rxy = zeros(Float64, 1, 1, Nz) |> CuArray. @benchmark CuArrays.@sync @cuda threads=Nx blocks=(Ny, Nz) shmem=2*Nx*sizeof(eltype(C)) gpu_accumulate_xy!(Rxy, Rx, C, +). BenchmarkTools.Trial: ; memory estimate: 2.88 KiB; allocs estimate: 64; --------------; minimum time: 39.129 ms (0.00% GC); median time: 39.245 ms (0.00% GC); mean time: 39.248 ms (0.00% GC); maximum time: 39.374 ms (0.00% GC); --------------; samples: 128; evals/sample: 1; ```. Probably optimal performance:; ```julia; @ben",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/352
https://github.com/CliMA/Oceananigans.jl/pull/352:1595,Testability,Benchmark,BenchmarkTools,1595,"ed over a CUDAnative.jl example, although I do have a test for the diagnostic so it does work. The algorithm can be more efficient (see https://github.com/JuliaGPU/CuArrays.jl/issues/68). It allocates very minimal amounts of memory (less than `mean`) and benchmarks show that it is ~20x faster than what we were doing before (copying to CPU and calculating there) which is great but it's ~5x slower than optimal performance. As it does not allocate memory, we can now calculate vertical profiles even when running large models that fill up memory. Although I should mention that an intermediate array with a size of at least `1*Ny*Nz` is required for the parallel reduction step (so I'm using `poisson_solvers.storage` because it's a vanilla CuArray that can be overwritten). ```julia; N, H = 512, 1; T = N + 2H. a = rand(T, T, T) |> CuArray; h = zeros(N) |> CuArray; ```. What we were doing before:; ```julia; @benchmark CuArrays.@sync mean(Array(view(a, H:N+H, H:N+H, H:N+H)), dims=[1, 2]). BenchmarkTools.Trial: ; memory estimate: 1.01 GiB; allocs estimate: 250; --------------; minimum time: 684.013 ms (2.29% GC); median time: 712.570 ms (6.28% GC); mean time: 732.480 ms (8.79% GC); maximum time: 807.437 ms (16.95% GC); --------------; samples: 7; evals/sample: 1; ```. What this PR does:; ```julia; Nx, Ny, Nz = 512, 512, 512; C = rand(Nx, Ny, Nz) |> CuArray; Rx = zeros(Float64, 1, Ny, Nz) |> CuArray; Rxy = zeros(Float64, 1, 1, Nz) |> CuArray. @benchmark CuArrays.@sync @cuda threads=Nx blocks=(Ny, Nz) shmem=2*Nx*sizeof(eltype(C)) gpu_accumulate_xy!(Rxy, Rx, C, +). BenchmarkTools.Trial: ; memory estimate: 2.88 KiB; allocs estimate: 64; --------------; minimum time: 39.129 ms (0.00% GC); median time: 39.245 ms (0.00% GC); mean time: 39.248 ms (0.00% GC); maximum time: 39.374 ms (0.00% GC); --------------; samples: 128; evals/sample: 1; ```. Probably optimal performance:; ```julia; @benchmark CuArrays.@sync mean(a, dims=[1, 2]). BenchmarkTools.Trial: ; memory estimate: 8.56 KiB; all",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/352
https://github.com/CliMA/Oceananigans.jl/pull/352:2057,Testability,benchmark,benchmark,2057,"s than `mean`) and benchmarks show that it is ~20x faster than what we were doing before (copying to CPU and calculating there) which is great but it's ~5x slower than optimal performance. As it does not allocate memory, we can now calculate vertical profiles even when running large models that fill up memory. Although I should mention that an intermediate array with a size of at least `1*Ny*Nz` is required for the parallel reduction step (so I'm using `poisson_solvers.storage` because it's a vanilla CuArray that can be overwritten). ```julia; N, H = 512, 1; T = N + 2H. a = rand(T, T, T) |> CuArray; h = zeros(N) |> CuArray; ```. What we were doing before:; ```julia; @benchmark CuArrays.@sync mean(Array(view(a, H:N+H, H:N+H, H:N+H)), dims=[1, 2]). BenchmarkTools.Trial: ; memory estimate: 1.01 GiB; allocs estimate: 250; --------------; minimum time: 684.013 ms (2.29% GC); median time: 712.570 ms (6.28% GC); mean time: 732.480 ms (8.79% GC); maximum time: 807.437 ms (16.95% GC); --------------; samples: 7; evals/sample: 1; ```. What this PR does:; ```julia; Nx, Ny, Nz = 512, 512, 512; C = rand(Nx, Ny, Nz) |> CuArray; Rx = zeros(Float64, 1, Ny, Nz) |> CuArray; Rxy = zeros(Float64, 1, 1, Nz) |> CuArray. @benchmark CuArrays.@sync @cuda threads=Nx blocks=(Ny, Nz) shmem=2*Nx*sizeof(eltype(C)) gpu_accumulate_xy!(Rxy, Rx, C, +). BenchmarkTools.Trial: ; memory estimate: 2.88 KiB; allocs estimate: 64; --------------; minimum time: 39.129 ms (0.00% GC); median time: 39.245 ms (0.00% GC); mean time: 39.248 ms (0.00% GC); maximum time: 39.374 ms (0.00% GC); --------------; samples: 128; evals/sample: 1; ```. Probably optimal performance:; ```julia; @benchmark CuArrays.@sync mean(a, dims=[1, 2]). BenchmarkTools.Trial: ; memory estimate: 8.56 KiB; allocs estimate: 220; --------------; minimum time: 7.426 ms (0.00% GC); median time: 7.526 ms (0.00% GC); mean time: 7.527 ms (0.00% GC); maximum time: 8.817 ms (0.00% GC); --------------; samples: 663; evals/sample: 1; ```. Resolves #186",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/352
https://github.com/CliMA/Oceananigans.jl/pull/352:2179,Testability,Benchmark,BenchmarkTools,2179,"s than `mean`) and benchmarks show that it is ~20x faster than what we were doing before (copying to CPU and calculating there) which is great but it's ~5x slower than optimal performance. As it does not allocate memory, we can now calculate vertical profiles even when running large models that fill up memory. Although I should mention that an intermediate array with a size of at least `1*Ny*Nz` is required for the parallel reduction step (so I'm using `poisson_solvers.storage` because it's a vanilla CuArray that can be overwritten). ```julia; N, H = 512, 1; T = N + 2H. a = rand(T, T, T) |> CuArray; h = zeros(N) |> CuArray; ```. What we were doing before:; ```julia; @benchmark CuArrays.@sync mean(Array(view(a, H:N+H, H:N+H, H:N+H)), dims=[1, 2]). BenchmarkTools.Trial: ; memory estimate: 1.01 GiB; allocs estimate: 250; --------------; minimum time: 684.013 ms (2.29% GC); median time: 712.570 ms (6.28% GC); mean time: 732.480 ms (8.79% GC); maximum time: 807.437 ms (16.95% GC); --------------; samples: 7; evals/sample: 1; ```. What this PR does:; ```julia; Nx, Ny, Nz = 512, 512, 512; C = rand(Nx, Ny, Nz) |> CuArray; Rx = zeros(Float64, 1, Ny, Nz) |> CuArray; Rxy = zeros(Float64, 1, 1, Nz) |> CuArray. @benchmark CuArrays.@sync @cuda threads=Nx blocks=(Ny, Nz) shmem=2*Nx*sizeof(eltype(C)) gpu_accumulate_xy!(Rxy, Rx, C, +). BenchmarkTools.Trial: ; memory estimate: 2.88 KiB; allocs estimate: 64; --------------; minimum time: 39.129 ms (0.00% GC); median time: 39.245 ms (0.00% GC); mean time: 39.248 ms (0.00% GC); maximum time: 39.374 ms (0.00% GC); --------------; samples: 128; evals/sample: 1; ```. Probably optimal performance:; ```julia; @benchmark CuArrays.@sync mean(a, dims=[1, 2]). BenchmarkTools.Trial: ; memory estimate: 8.56 KiB; allocs estimate: 220; --------------; minimum time: 7.426 ms (0.00% GC); median time: 7.526 ms (0.00% GC); mean time: 7.527 ms (0.00% GC); maximum time: 8.817 ms (0.00% GC); --------------; samples: 663; evals/sample: 1; ```. Resolves #186",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/352
https://github.com/CliMA/Oceananigans.jl/pull/352:2501,Testability,benchmark,benchmark,2501,"s than `mean`) and benchmarks show that it is ~20x faster than what we were doing before (copying to CPU and calculating there) which is great but it's ~5x slower than optimal performance. As it does not allocate memory, we can now calculate vertical profiles even when running large models that fill up memory. Although I should mention that an intermediate array with a size of at least `1*Ny*Nz` is required for the parallel reduction step (so I'm using `poisson_solvers.storage` because it's a vanilla CuArray that can be overwritten). ```julia; N, H = 512, 1; T = N + 2H. a = rand(T, T, T) |> CuArray; h = zeros(N) |> CuArray; ```. What we were doing before:; ```julia; @benchmark CuArrays.@sync mean(Array(view(a, H:N+H, H:N+H, H:N+H)), dims=[1, 2]). BenchmarkTools.Trial: ; memory estimate: 1.01 GiB; allocs estimate: 250; --------------; minimum time: 684.013 ms (2.29% GC); median time: 712.570 ms (6.28% GC); mean time: 732.480 ms (8.79% GC); maximum time: 807.437 ms (16.95% GC); --------------; samples: 7; evals/sample: 1; ```. What this PR does:; ```julia; Nx, Ny, Nz = 512, 512, 512; C = rand(Nx, Ny, Nz) |> CuArray; Rx = zeros(Float64, 1, Ny, Nz) |> CuArray; Rxy = zeros(Float64, 1, 1, Nz) |> CuArray. @benchmark CuArrays.@sync @cuda threads=Nx blocks=(Ny, Nz) shmem=2*Nx*sizeof(eltype(C)) gpu_accumulate_xy!(Rxy, Rx, C, +). BenchmarkTools.Trial: ; memory estimate: 2.88 KiB; allocs estimate: 64; --------------; minimum time: 39.129 ms (0.00% GC); median time: 39.245 ms (0.00% GC); mean time: 39.248 ms (0.00% GC); maximum time: 39.374 ms (0.00% GC); --------------; samples: 128; evals/sample: 1; ```. Probably optimal performance:; ```julia; @benchmark CuArrays.@sync mean(a, dims=[1, 2]). BenchmarkTools.Trial: ; memory estimate: 8.56 KiB; allocs estimate: 220; --------------; minimum time: 7.426 ms (0.00% GC); median time: 7.526 ms (0.00% GC); mean time: 7.527 ms (0.00% GC); maximum time: 8.817 ms (0.00% GC); --------------; samples: 663; evals/sample: 1; ```. Resolves #186",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/352
https://github.com/CliMA/Oceananigans.jl/pull/352:2548,Testability,Benchmark,BenchmarkTools,2548,"s than `mean`) and benchmarks show that it is ~20x faster than what we were doing before (copying to CPU and calculating there) which is great but it's ~5x slower than optimal performance. As it does not allocate memory, we can now calculate vertical profiles even when running large models that fill up memory. Although I should mention that an intermediate array with a size of at least `1*Ny*Nz` is required for the parallel reduction step (so I'm using `poisson_solvers.storage` because it's a vanilla CuArray that can be overwritten). ```julia; N, H = 512, 1; T = N + 2H. a = rand(T, T, T) |> CuArray; h = zeros(N) |> CuArray; ```. What we were doing before:; ```julia; @benchmark CuArrays.@sync mean(Array(view(a, H:N+H, H:N+H, H:N+H)), dims=[1, 2]). BenchmarkTools.Trial: ; memory estimate: 1.01 GiB; allocs estimate: 250; --------------; minimum time: 684.013 ms (2.29% GC); median time: 712.570 ms (6.28% GC); mean time: 732.480 ms (8.79% GC); maximum time: 807.437 ms (16.95% GC); --------------; samples: 7; evals/sample: 1; ```. What this PR does:; ```julia; Nx, Ny, Nz = 512, 512, 512; C = rand(Nx, Ny, Nz) |> CuArray; Rx = zeros(Float64, 1, Ny, Nz) |> CuArray; Rxy = zeros(Float64, 1, 1, Nz) |> CuArray. @benchmark CuArrays.@sync @cuda threads=Nx blocks=(Ny, Nz) shmem=2*Nx*sizeof(eltype(C)) gpu_accumulate_xy!(Rxy, Rx, C, +). BenchmarkTools.Trial: ; memory estimate: 2.88 KiB; allocs estimate: 64; --------------; minimum time: 39.129 ms (0.00% GC); median time: 39.245 ms (0.00% GC); mean time: 39.248 ms (0.00% GC); maximum time: 39.374 ms (0.00% GC); --------------; samples: 128; evals/sample: 1; ```. Probably optimal performance:; ```julia; @benchmark CuArrays.@sync mean(a, dims=[1, 2]). BenchmarkTools.Trial: ; memory estimate: 8.56 KiB; allocs estimate: 220; --------------; minimum time: 7.426 ms (0.00% GC); median time: 7.526 ms (0.00% GC); mean time: 7.527 ms (0.00% GC); maximum time: 8.817 ms (0.00% GC); --------------; samples: 663; evals/sample: 1; ```. Resolves #186",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/352
https://github.com/CliMA/Oceananigans.jl/issues/353:114,Energy Efficiency,adapt,adaptive,114,"For the ""model setup"" section of the documentation where we'll describe how to use the `TimeStepWizard` to choose adaptive time steps, I was thinking it would be good to recommend some CFL values. I think with 2nd-order Adams Bashforth we're limited to CFL < 0.5, so I'm thinking of recommending to start with CFL = 0.3 then decrease if issues are encountered. I usually run with 0.15 < CFL < 0.3. @glwagner What do you usually run with?. @jm-c @christophernhill Any wisdom from MITgcm?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/353
https://github.com/CliMA/Oceananigans.jl/issues/353:114,Modifiability,adapt,adaptive,114,"For the ""model setup"" section of the documentation where we'll describe how to use the `TimeStepWizard` to choose adaptive time steps, I was thinking it would be good to recommend some CFL values. I think with 2nd-order Adams Bashforth we're limited to CFL < 0.5, so I'm thinking of recommending to start with CFL = 0.3 then decrease if issues are encountered. I usually run with 0.15 < CFL < 0.3. @glwagner What do you usually run with?. @jm-c @christophernhill Any wisdom from MITgcm?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/353
https://github.com/CliMA/Oceananigans.jl/issues/363:195,Deployability,configurat,configuration,195,"Kind of a leftover relic I forgot to cleanup, but boundary condition API kernels still use the old `Tx, Ty` and `Bx, By, Bz` values to launch kernels. We should switch them to use dynamic launch configuration like all the other time stepping kernels.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/363
https://github.com/CliMA/Oceananigans.jl/issues/363:195,Modifiability,config,configuration,195,"Kind of a leftover relic I forgot to cleanup, but boundary condition API kernels still use the old `Tx, Ty` and `Bx, By, Bz` values to launch kernels. We should switch them to use dynamic launch configuration like all the other time stepping kernels.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/363
https://github.com/CliMA/Oceananigans.jl/issues/364:222,Security,access,access,222,I've been meaning to raise this issue for a while. I think we export too many names. We should figure out which names truly need to be dumped into users namespaces' when `using Oceananigans` is written. . Users can easily access non-exported names via `Oceananigans.name` or `using Oceananigans: name`. This does not affect functionality; it's mainly a good-scripting-practice issue.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/364
https://github.com/CliMA/Oceananigans.jl/issues/365:67,Availability,down,down,67,"Apparently defining a forcing in this way actually slows the model down by a lot. It's ~2x slower with just this one forcing function which seems a little excessive. ```julia; @inline FT(grid, U, Φ, i, j, k) = ifelse(k == 1, -1e-4 * (Φ.T[i, j, 1] - 0), 0); forcing = Forcing(FT=FT); ```. Seems that maybe the exact way the forcing function is defined could have a huge impact on performance.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/365
https://github.com/CliMA/Oceananigans.jl/issues/365:379,Performance,perform,performance,379,"Apparently defining a forcing in this way actually slows the model down by a lot. It's ~2x slower with just this one forcing function which seems a little excessive. ```julia; @inline FT(grid, U, Φ, i, j, k) = ifelse(k == 1, -1e-4 * (Φ.T[i, j, 1] - 0), 0); forcing = Forcing(FT=FT); ```. Seems that maybe the exact way the forcing function is defined could have a huge impact on performance.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/365
https://github.com/CliMA/Oceananigans.jl/issues/366:1511,Availability,ERROR,ERROR,1511,"be good to suppress them somehow. This package might help: https://github.com/JuliaIO/Suppressor.jl. What I see on a CPU:; ```; WARNING: Method definition recurse(Cassette.Context{N, M, T, P, B, H} where H<:Union{Cassette.DisableHooks, Nothing} where B<:Union{Nothing, Base.IdDict{Module, Base.Dict{Symbol, Cassette.BindingMeta}}} where P<:Cassette.AbstractPass where T<:Union{Nothing, Cassette.Tag{N, X, E} where E where X where N<:Cassette.AbstractContextName} where M where N<:Cassette.AbstractContextName, Any...) in module Cassette at /home/alir/.julia/packages/Cassette/IwsFs/src/overdub.jl:550 overwritten in module GPUifyLoops at /home/alir/.julia/packages/Cassette/IwsFs/src/overdub.jl:550.; WARNING: Method definition overdub(Cassette.Context{N, M, T, P, B, H} where H<:Union{Cassette.DisableHooks, Nothing} where B<:Union{Nothing, Base.IdDict{Module, Base.Dict{Symbol, Cassette.BindingMeta}}} where P<:Cassette.AbstractPass where T<:Union{Nothing, Cassette.Tag{N, X, E} where E where X where N<:Cassette.AbstractContextName} where M where N<:Cassette.AbstractContextName, Any...) in module Cassette at /home/alir/.julia/packages/Cassette/IwsFs/src/overdub.jl:537 overwritten in module GPUifyLoops at /home/alir/.julia/packages/Cassette/IwsFs/src/overdub.jl:537.; ERROR: LoadError: Could not find CUDA driver library; Stacktrace:; [1] top-level scope at /home/alir/.julia/packages/CUDAdrv/ADRHQ/src/CUDAdrv.jl:33; [2] top-level scope at none:2; in expression starting at /home/alir/.julia/packages/CUDAdrv/ADRHQ/src/CUDAdrv.jl:27; ┌ Warning: Replacing docs for `Core.nothing :: Union{}` in module `Oceananigans`; └ @ Base.Docs docs/Docs.jl:223; ┌ Warning: Replacing docs for `Core.nothing :: Union{}` in module `Oceananigans`; └ @ Base.Docs docs/Docs.jl:223; ┌ Warning: Replacing docs for `Core.nothing :: Union{}` in module `Oceananigans`; └ @ Base.Docs docs/Docs.jl:223; ┌ Warning: Replacing docs for `Core.nothing :: Union{}` in module `Oceananigans`; └ @ Base.Docs docs/Docs.jl:223; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/366
https://github.com/CliMA/Oceananigans.jl/issues/366:1518,Performance,Load,LoadError,1518,"be good to suppress them somehow. This package might help: https://github.com/JuliaIO/Suppressor.jl. What I see on a CPU:; ```; WARNING: Method definition recurse(Cassette.Context{N, M, T, P, B, H} where H<:Union{Cassette.DisableHooks, Nothing} where B<:Union{Nothing, Base.IdDict{Module, Base.Dict{Symbol, Cassette.BindingMeta}}} where P<:Cassette.AbstractPass where T<:Union{Nothing, Cassette.Tag{N, X, E} where E where X where N<:Cassette.AbstractContextName} where M where N<:Cassette.AbstractContextName, Any...) in module Cassette at /home/alir/.julia/packages/Cassette/IwsFs/src/overdub.jl:550 overwritten in module GPUifyLoops at /home/alir/.julia/packages/Cassette/IwsFs/src/overdub.jl:550.; WARNING: Method definition overdub(Cassette.Context{N, M, T, P, B, H} where H<:Union{Cassette.DisableHooks, Nothing} where B<:Union{Nothing, Base.IdDict{Module, Base.Dict{Symbol, Cassette.BindingMeta}}} where P<:Cassette.AbstractPass where T<:Union{Nothing, Cassette.Tag{N, X, E} where E where X where N<:Cassette.AbstractContextName} where M where N<:Cassette.AbstractContextName, Any...) in module Cassette at /home/alir/.julia/packages/Cassette/IwsFs/src/overdub.jl:537 overwritten in module GPUifyLoops at /home/alir/.julia/packages/Cassette/IwsFs/src/overdub.jl:537.; ERROR: LoadError: Could not find CUDA driver library; Stacktrace:; [1] top-level scope at /home/alir/.julia/packages/CUDAdrv/ADRHQ/src/CUDAdrv.jl:33; [2] top-level scope at none:2; in expression starting at /home/alir/.julia/packages/CUDAdrv/ADRHQ/src/CUDAdrv.jl:27; ┌ Warning: Replacing docs for `Core.nothing :: Union{}` in module `Oceananigans`; └ @ Base.Docs docs/Docs.jl:223; ┌ Warning: Replacing docs for `Core.nothing :: Union{}` in module `Oceananigans`; └ @ Base.Docs docs/Docs.jl:223; ┌ Warning: Replacing docs for `Core.nothing :: Union{}` in module `Oceananigans`; └ @ Base.Docs docs/Docs.jl:223; ┌ Warning: Replacing docs for `Core.nothing :: Union{}` in module `Oceananigans`; └ @ Base.Docs docs/Docs.jl:223; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/366
https://github.com/CliMA/Oceananigans.jl/pull/367:12,Modifiability,sandbox,sandbox,12,Most of the sandbox scripts are very stale and could be misleading so I'm nuking them. Simulation scripts should go in respective repositories at this point. Sandbox scripts that are worth making into examples can go into `examples/`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/367
https://github.com/CliMA/Oceananigans.jl/pull/367:158,Modifiability,Sandbox,Sandbox,158,Most of the sandbox scripts are very stale and could be misleading so I'm nuking them. Simulation scripts should go in respective repositories at this point. Sandbox scripts that are worth making into examples can go into `examples/`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/367
https://github.com/CliMA/Oceananigans.jl/pull/367:12,Testability,sandbox,sandbox,12,Most of the sandbox scripts are very stale and could be misleading so I'm nuking them. Simulation scripts should go in respective repositories at this point. Sandbox scripts that are worth making into examples can go into `examples/`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/367
https://github.com/CliMA/Oceananigans.jl/pull/367:158,Testability,Sandbox,Sandbox,158,Most of the sandbox scripts are very stale and could be misleading so I'm nuking them. Simulation scripts should go in respective repositories at this point. Sandbox scripts that are worth making into examples can go into `examples/`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/367
https://github.com/CliMA/Oceananigans.jl/pull/368:34,Testability,test,tests,34,"This PR nukes the last two broken tests: deep convection which has been stale and broken for months, and the example test which was never working anyways. Now that we're back to having no broken tests, would be nice to keep it that way.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/368
https://github.com/CliMA/Oceananigans.jl/pull/368:117,Testability,test,test,117,"This PR nukes the last two broken tests: deep convection which has been stale and broken for months, and the example test which was never working anyways. Now that we're back to having no broken tests, would be nice to keep it that way.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/368
https://github.com/CliMA/Oceananigans.jl/pull/368:195,Testability,test,tests,195,"This PR nukes the last two broken tests: deep convection which has been stale and broken for months, and the example test which was never working anyways. Now that we're back to having no broken tests, would be nice to keep it that way.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/368
https://github.com/CliMA/Oceananigans.jl/issues/369:104,Modifiability,flexible,flexible,104,"Dear Oceananigans team,. this looks like a really exciting and useful project. As an external user, how flexible is this package to add, e.g. , additional (passive) tracers to a model? I see that there is a generalised array of tracers, but temperature and salinity are hardcoded into the model initialiser. Would it be possible to add more tracers? I am asking because eventually it would be super cool to use a tool like this as the ocean circulation component in other Earth System Models. I am currently using [cGenie](https://github.com/derpycode/cgenie.muffin) which internally uses this ocean model : https://www.geosci-model-dev.net/4/957/2011/ ...; What is the general scope to do something like this? ; Sorry for asking user-level questions in the Issues, but I think you are still working on some more detailed documentation ... Many thanks! Heiko",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/369
https://github.com/CliMA/Oceananigans.jl/pull/370:44,Energy Efficiency,efficient,efficient,44,This should help us figure out how to write efficient forcing functions. Important as they're used by the Europa and seasonal cycle simulations to implement relaxation terms at the boundaries. X-ref: #365,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/370
https://github.com/CliMA/Oceananigans.jl/issues/371:719,Integrability,depend,depend,719,"Idea: . * continue to use `calculate_boundary_source_terms` to add fluxes specified via `Flux` boundary conditions (and also via potential new future boundary condition types), *but*; * use halo filling + interior source term calculation, rather than `calculate_boundary_source_terms`, to enforce `Value` and `Gradient` boundary conditions. Advantages:. * this change eliminates the need for diffusivities to be known by `calculate_boundary_source_terms` --- diffusivities are only needed if enforcing `Flux` boundary conditions via halos, or to enforce `Value`/`Gradient` boundary conditions via `calculate_boundary_source_terms`; both of these situations are avoided with this change;; * nonlinear diffusivities that depend on gradients at the boundary can be calculated correctly for `Value` and `Gradient` boundary conditions; * gradient information is now included in output for `Value` and `Gradient` boundary conditions and can be used in post-processing; * the `calculate_boundary_source_terms` function remains a part of the algorithm for `Flux` boundary conditions, or more complicated boundary conditions (like those associated with irregular bathymetry). Previously, we were operating under the assumption that we should either fill halos for all inhomogeneous boundary condition types, or use `calculate_boundary_source_terms`. For some reason, we did not consider that our method of enforcing inhomogeneous boundary conditions could (and perhaps should) depend on the *type* of the boundary condition. . Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/371
https://github.com/CliMA/Oceananigans.jl/issues/371:1468,Integrability,depend,depend,1468,"Idea: . * continue to use `calculate_boundary_source_terms` to add fluxes specified via `Flux` boundary conditions (and also via potential new future boundary condition types), *but*; * use halo filling + interior source term calculation, rather than `calculate_boundary_source_terms`, to enforce `Value` and `Gradient` boundary conditions. Advantages:. * this change eliminates the need for diffusivities to be known by `calculate_boundary_source_terms` --- diffusivities are only needed if enforcing `Flux` boundary conditions via halos, or to enforce `Value`/`Gradient` boundary conditions via `calculate_boundary_source_terms`; both of these situations are avoided with this change;; * nonlinear diffusivities that depend on gradients at the boundary can be calculated correctly for `Value` and `Gradient` boundary conditions; * gradient information is now included in output for `Value` and `Gradient` boundary conditions and can be used in post-processing; * the `calculate_boundary_source_terms` function remains a part of the algorithm for `Flux` boundary conditions, or more complicated boundary conditions (like those associated with irregular bathymetry). Previously, we were operating under the assumption that we should either fill halos for all inhomogeneous boundary condition types, or use `calculate_boundary_source_terms`. For some reason, we did not consider that our method of enforcing inhomogeneous boundary conditions could (and perhaps should) depend on the *type* of the boundary condition. . Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/371
https://github.com/CliMA/Oceananigans.jl/issues/371:661,Safety,avoid,avoided,661,"Idea: . * continue to use `calculate_boundary_source_terms` to add fluxes specified via `Flux` boundary conditions (and also via potential new future boundary condition types), *but*; * use halo filling + interior source term calculation, rather than `calculate_boundary_source_terms`, to enforce `Value` and `Gradient` boundary conditions. Advantages:. * this change eliminates the need for diffusivities to be known by `calculate_boundary_source_terms` --- diffusivities are only needed if enforcing `Flux` boundary conditions via halos, or to enforce `Value`/`Gradient` boundary conditions via `calculate_boundary_source_terms`; both of these situations are avoided with this change;; * nonlinear diffusivities that depend on gradients at the boundary can be calculated correctly for `Value` and `Gradient` boundary conditions; * gradient information is now included in output for `Value` and `Gradient` boundary conditions and can be used in post-processing; * the `calculate_boundary_source_terms` function remains a part of the algorithm for `Flux` boundary conditions, or more complicated boundary conditions (like those associated with irregular bathymetry). Previously, we were operating under the assumption that we should either fill halos for all inhomogeneous boundary condition types, or use `calculate_boundary_source_terms`. For some reason, we did not consider that our method of enforcing inhomogeneous boundary conditions could (and perhaps should) depend on the *type* of the boundary condition. . Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/371
https://github.com/CliMA/Oceananigans.jl/issues/372:10,Availability,checkpoint,checkpoint,10,"To enable checkpoint restoration for large models, we need to revise the model constructor so that `velocities` and `tracers` can be passed as keyword arguments. In addition, I think it might make sense to remove `N`, `L`, and the viscosities from keyword arguments, so that all of the constructor arguments in the *base* model constructor correspond to subfields of `Model`. At the same time and for user convenience, we should add new constructors (perhaps something like `SimpleModel` or `BasicModel`) that *do* have keyword arguments for `N`, `L`, etc. . Through this method we can provide both convenience for users looking for simple and basic functionality while also cleaning up the *base* model constructor for the purpose of checkpointing, code cleanliness, and easier usage for advanced users. We will probably want to remove `N` and `L` from the model constructor anyways when we have more than one type of grid for a user to choose.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/372
https://github.com/CliMA/Oceananigans.jl/issues/372:735,Availability,checkpoint,checkpointing,735,"To enable checkpoint restoration for large models, we need to revise the model constructor so that `velocities` and `tracers` can be passed as keyword arguments. In addition, I think it might make sense to remove `N`, `L`, and the viscosities from keyword arguments, so that all of the constructor arguments in the *base* model constructor correspond to subfields of `Model`. At the same time and for user convenience, we should add new constructors (perhaps something like `SimpleModel` or `BasicModel`) that *do* have keyword arguments for `N`, `L`, etc. . Through this method we can provide both convenience for users looking for simple and basic functionality while also cleaning up the *base* model constructor for the purpose of checkpointing, code cleanliness, and easier usage for advanced users. We will probably want to remove `N` and `L` from the model constructor anyways when we have more than one type of grid for a user to choose.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/372
https://github.com/CliMA/Oceananigans.jl/issues/372:475,Usability,Simpl,SimpleModel,475,"To enable checkpoint restoration for large models, we need to revise the model constructor so that `velocities` and `tracers` can be passed as keyword arguments. In addition, I think it might make sense to remove `N`, `L`, and the viscosities from keyword arguments, so that all of the constructor arguments in the *base* model constructor correspond to subfields of `Model`. At the same time and for user convenience, we should add new constructors (perhaps something like `SimpleModel` or `BasicModel`) that *do* have keyword arguments for `N`, `L`, etc. . Through this method we can provide both convenience for users looking for simple and basic functionality while also cleaning up the *base* model constructor for the purpose of checkpointing, code cleanliness, and easier usage for advanced users. We will probably want to remove `N` and `L` from the model constructor anyways when we have more than one type of grid for a user to choose.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/372
https://github.com/CliMA/Oceananigans.jl/issues/372:633,Usability,simpl,simple,633,"To enable checkpoint restoration for large models, we need to revise the model constructor so that `velocities` and `tracers` can be passed as keyword arguments. In addition, I think it might make sense to remove `N`, `L`, and the viscosities from keyword arguments, so that all of the constructor arguments in the *base* model constructor correspond to subfields of `Model`. At the same time and for user convenience, we should add new constructors (perhaps something like `SimpleModel` or `BasicModel`) that *do* have keyword arguments for `N`, `L`, etc. . Through this method we can provide both convenience for users looking for simple and basic functionality while also cleaning up the *base* model constructor for the purpose of checkpointing, code cleanliness, and easier usage for advanced users. We will probably want to remove `N` and `L` from the model constructor anyways when we have more than one type of grid for a user to choose.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/372
https://github.com/CliMA/Oceananigans.jl/issues/376:82,Performance,load,loading,82,See: https://discourse.julialang.org/t/cuarrays-cudanative-psa-simplified-package-loading/27897,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/376
https://github.com/CliMA/Oceananigans.jl/issues/376:63,Usability,simpl,simplified-package-loading,63,See: https://discourse.julialang.org/t/cuarrays-cudanative-psa-simplified-package-loading/27897,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/376
https://github.com/CliMA/Oceananigans.jl/pull/380:153,Availability,down,down,153,Would be good to set this up with Slurm CI (PR #280) and start doing continuous performance testing to ensure we don't make mistakes that slow the model down.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/380
https://github.com/CliMA/Oceananigans.jl/pull/380:69,Deployability,continuous,continuous,69,Would be good to set this up with Slurm CI (PR #280) and start doing continuous performance testing to ensure we don't make mistakes that slow the model down.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/380
https://github.com/CliMA/Oceananigans.jl/pull/380:80,Performance,perform,performance,80,Would be good to set this up with Slurm CI (PR #280) and start doing continuous performance testing to ensure we don't make mistakes that slow the model down.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/380
https://github.com/CliMA/Oceananigans.jl/pull/380:92,Testability,test,testing,92,Would be good to set this up with Slurm CI (PR #280) and start doing continuous performance testing to ensure we don't make mistakes that slow the model down.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/380
https://github.com/CliMA/Oceananigans.jl/pull/381:324,Testability,test,test,324,"This PR introduces a script for simulating Stratified Couette flow with the aim of reproducing the LES results of Vreugdenhil & Taylor (2018). See https://github.com/climate-machine/Oceananigans.jl/issues/310 for more details. When the verification is completely successfully, I will ensure the script is maintained in the `test/verification/` subdirectory so that the verification can be reproduced at any time. I will also convert it to a regression test. See #347. Resolves #310 ; Resolves #415; Contributes to #346 and #347",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/381
https://github.com/CliMA/Oceananigans.jl/pull/381:452,Testability,test,test,452,"This PR introduces a script for simulating Stratified Couette flow with the aim of reproducing the LES results of Vreugdenhil & Taylor (2018). See https://github.com/climate-machine/Oceananigans.jl/issues/310 for more details. When the verification is completely successfully, I will ensure the script is maintained in the `test/verification/` subdirectory so that the verification can be reproduced at any time. I will also convert it to a regression test. See #347. Resolves #310 ; Resolves #415; Contributes to #346 and #347",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/381
https://github.com/CliMA/Oceananigans.jl/pull/383:782,Security,access,accessed,782,"This PR makes a few major contributions:. * Fixes a bug in Anisotropic Minimum Dissipation (AMD) type closures that led to (very) wrong subgrid-scale diffusivities.; * Adds a new flavor of AMD proposed by [Verstappen (2018)](https://www.sciencedirect.com/science/article/abs/pii/S0045793016304005) and described in detail by [Vreugdenhil and Taylor (2018)](https://aip.scitation.org/doi/abs/10.1063/1.5037039). This new flavor of AMD, dubbed the ""Verstappen"" AMD, is now the default name bound to `AnisotropicMinimumDissipation`; * The closure formerly known as `AnisotropicMinimumDissipation` is now called `RozemaAnisotropicMinimumDissipation` (it was first described by [Rozema et al. (2015)](https://aip.scitation.org/doi/abs/10.1063/1.4928700)). It is not exported, but can be accessed via `Oceananigans.RozemaAnisotropicMinimumDissipation`.; * There is new Smagorinsky closure variant called `BlasiusSmagorinsky` which is untested and unexported. It can be accessed via `Oceananigans.BlasiusSmagorinsky`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/383
https://github.com/CliMA/Oceananigans.jl/pull/383:963,Security,access,accessed,963,"This PR makes a few major contributions:. * Fixes a bug in Anisotropic Minimum Dissipation (AMD) type closures that led to (very) wrong subgrid-scale diffusivities.; * Adds a new flavor of AMD proposed by [Verstappen (2018)](https://www.sciencedirect.com/science/article/abs/pii/S0045793016304005) and described in detail by [Vreugdenhil and Taylor (2018)](https://aip.scitation.org/doi/abs/10.1063/1.5037039). This new flavor of AMD, dubbed the ""Verstappen"" AMD, is now the default name bound to `AnisotropicMinimumDissipation`; * The closure formerly known as `AnisotropicMinimumDissipation` is now called `RozemaAnisotropicMinimumDissipation` (it was first described by [Rozema et al. (2015)](https://aip.scitation.org/doi/abs/10.1063/1.4928700)). It is not exported, but can be accessed via `Oceananigans.RozemaAnisotropicMinimumDissipation`.; * There is new Smagorinsky closure variant called `BlasiusSmagorinsky` which is untested and unexported. It can be accessed via `Oceananigans.BlasiusSmagorinsky`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/383
https://github.com/CliMA/Oceananigans.jl/pull/385:105,Availability,robust,robustly,105,"This fixes a bug in which halo regions were not filled for subgrid-scale LES diffusivities. . To do this robustly for various diffusivity structures with different nesting hierarchies, a recursive halo region filling functionality is implemented that dispatches on `bcs::NamedTuple{(:x, :y:, :z)}`, corresponding to a `FieldBoundaryCondition`. Thus, when `fill_halo_regions!(fields, bcs, grid)` is called with matching tuples for *both* `fields` and `bcs`, a simultaneous loop is done over the members of the two tuples. However, when `fill_halo_regions!(fields, bcs, grid)` is called and `bcs` is a `FieldBoundaryCondition`, a loop is performed over the members of `fields` *only*, and `bcs` is reused for every member of `fields`. Thus halo regions for fields embedded in nested structures (like diffusivities in `AnisotropicMinimumDissipation`) are all filled with a single call to `fill_halo_regions!`. For now, the code uses temperature boundary conditions to determine the diffusivity boundary conditions. This will work until we implement the changes proposed in #371.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/385
https://github.com/CliMA/Oceananigans.jl/pull/385:636,Performance,perform,performed,636,"This fixes a bug in which halo regions were not filled for subgrid-scale LES diffusivities. . To do this robustly for various diffusivity structures with different nesting hierarchies, a recursive halo region filling functionality is implemented that dispatches on `bcs::NamedTuple{(:x, :y:, :z)}`, corresponding to a `FieldBoundaryCondition`. Thus, when `fill_halo_regions!(fields, bcs, grid)` is called with matching tuples for *both* `fields` and `bcs`, a simultaneous loop is done over the members of the two tuples. However, when `fill_halo_regions!(fields, bcs, grid)` is called and `bcs` is a `FieldBoundaryCondition`, a loop is performed over the members of `fields` *only*, and `bcs` is reused for every member of `fields`. Thus halo regions for fields embedded in nested structures (like diffusivities in `AnisotropicMinimumDissipation`) are all filled with a single call to `fill_halo_regions!`. For now, the code uses temperature boundary conditions to determine the diffusivity boundary conditions. This will work until we implement the changes proposed in #371.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/385
https://github.com/CliMA/Oceananigans.jl/pull/386:94,Modifiability,refactor,refactors,94,"This PR improves the `HorizontalAverage` utility to allow users to specify a return type, and refactors the code a bit to dispatch on the length of `fields`. This will be useful in the future when more sophisticated functions for computing horizontal averages (which, for example, interpolate fields to a common location) are implemented. It also refactors the time to write function and eliminates some boilerplate.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/386
https://github.com/CliMA/Oceananigans.jl/pull/386:347,Modifiability,refactor,refactors,347,"This PR improves the `HorizontalAverage` utility to allow users to specify a return type, and refactors the code a bit to dispatch on the length of `fields`. This will be useful in the future when more sophisticated functions for computing horizontal averages (which, for example, interpolate fields to a common location) are implemented. It also refactors the time to write function and eliminates some boilerplate.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/386
https://github.com/CliMA/Oceananigans.jl/pull/388:50,Availability,error,errors,50,The main point of upgrading is to get rid of CUDA errors on the CPU and use `CUDAapi.has_cuda()` which replaces the `HAVE_CUDA` variable we've been using. This was originally in PR https://github.com/climate-machine/Oceananigans.jl/pull/378 (this PR is mostly cherry picked commits) but when it was merged @glwagner reported issues with forcing functions on the GPU. So now I've added a test that makes sure that forcing functions don't crash when used in a CPU or GPU model (one with and one without `const`).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/388
https://github.com/CliMA/Oceananigans.jl/pull/388:128,Modifiability,variab,variable,128,The main point of upgrading is to get rid of CUDA errors on the CPU and use `CUDAapi.has_cuda()` which replaces the `HAVE_CUDA` variable we've been using. This was originally in PR https://github.com/climate-machine/Oceananigans.jl/pull/378 (this PR is mostly cherry picked commits) but when it was merged @glwagner reported issues with forcing functions on the GPU. So now I've added a test that makes sure that forcing functions don't crash when used in a CPU or GPU model (one with and one without `const`).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/388
https://github.com/CliMA/Oceananigans.jl/pull/388:387,Testability,test,test,387,The main point of upgrading is to get rid of CUDA errors on the CPU and use `CUDAapi.has_cuda()` which replaces the `HAVE_CUDA` variable we've been using. This was originally in PR https://github.com/climate-machine/Oceananigans.jl/pull/378 (this PR is mostly cherry picked commits) but when it was merged @glwagner reported issues with forcing functions on the GPU. So now I've added a test that makes sure that forcing functions don't crash when used in a CPU or GPU model (one with and one without `const`).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/388
https://github.com/CliMA/Oceananigans.jl/pull/389:1839,Availability,checkpoint,checkpointer,1839,"s); * the gradient between the interior node of a field and the associated boundary where the boundary condition is prescribed (for `Value` boundary conditions). `calculate_boundary_source_terms!` is still a part of the algorithm and is used to enforce `Flux` boundary conditions. This function may also prove useful in the future for more sophisticated boundary conditions and for enforcing boundary conditions associated with irregular boundaries. This algorithm permits the gradients of fields to be computed accurately on the boundary both in time stepping and post processing (which is useful, for example, for computing nonlinear diffusivities on the boundary when `Value` or `Gradient` boundary conditions are prescribed), and the code is more mathematically correct as a result. It also means that diffusivities are never involved in enforcing boundary conditions, which is an important simplification. Previously, the diffusivity of a field (or some proxy for diffusivity) on the boundary was used to add the flux associated with a `Value` or `Gradient` boundary condition. . This PR also adds special boundary conditions for tendency terms (sometimes called 'source terms' in the code), and for the pressure field. Finally, we introduce the boundary condition `BoundaryCondition{Flux, Nothing}` as a synonym for a no-flux boundary condition that does not require the calculation of boundary source terms, to save a few accesses to global memory. Right now there is a bit left to do:. - [x] adapt the checkpointer for the new `timestepper` structure (checkpointer tests currently fail); - [ ] decide whether pressure boundary conditions should be precomputed and stored in `poisson_solver` (currently they are computed at the beginning of a time-stepping cycle inside `time_step!`). If we add pressure boundary conditions to `poisson_solver`, we can also get rid of the special `PoissonBCs` types, since the pressure fields now have explicit bcs associated with them. But this is not urgent.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/389
https://github.com/CliMA/Oceananigans.jl/pull/389:1889,Availability,checkpoint,checkpointer,1889,"s); * the gradient between the interior node of a field and the associated boundary where the boundary condition is prescribed (for `Value` boundary conditions). `calculate_boundary_source_terms!` is still a part of the algorithm and is used to enforce `Flux` boundary conditions. This function may also prove useful in the future for more sophisticated boundary conditions and for enforcing boundary conditions associated with irregular boundaries. This algorithm permits the gradients of fields to be computed accurately on the boundary both in time stepping and post processing (which is useful, for example, for computing nonlinear diffusivities on the boundary when `Value` or `Gradient` boundary conditions are prescribed), and the code is more mathematically correct as a result. It also means that diffusivities are never involved in enforcing boundary conditions, which is an important simplification. Previously, the diffusivity of a field (or some proxy for diffusivity) on the boundary was used to add the flux associated with a `Value` or `Gradient` boundary condition. . This PR also adds special boundary conditions for tendency terms (sometimes called 'source terms' in the code), and for the pressure field. Finally, we introduce the boundary condition `BoundaryCondition{Flux, Nothing}` as a synonym for a no-flux boundary condition that does not require the calculation of boundary source terms, to save a few accesses to global memory. Right now there is a bit left to do:. - [x] adapt the checkpointer for the new `timestepper` structure (checkpointer tests currently fail); - [ ] decide whether pressure boundary conditions should be precomputed and stored in `poisson_solver` (currently they are computed at the beginning of a time-stepping cycle inside `time_step!`). If we add pressure boundary conditions to `poisson_solver`, we can also get rid of the special `PoissonBCs` types, since the pressure fields now have explicit bcs associated with them. But this is not urgent.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/389
https://github.com/CliMA/Oceananigans.jl/pull/389:1829,Energy Efficiency,adapt,adapt,1829,"s); * the gradient between the interior node of a field and the associated boundary where the boundary condition is prescribed (for `Value` boundary conditions). `calculate_boundary_source_terms!` is still a part of the algorithm and is used to enforce `Flux` boundary conditions. This function may also prove useful in the future for more sophisticated boundary conditions and for enforcing boundary conditions associated with irregular boundaries. This algorithm permits the gradients of fields to be computed accurately on the boundary both in time stepping and post processing (which is useful, for example, for computing nonlinear diffusivities on the boundary when `Value` or `Gradient` boundary conditions are prescribed), and the code is more mathematically correct as a result. It also means that diffusivities are never involved in enforcing boundary conditions, which is an important simplification. Previously, the diffusivity of a field (or some proxy for diffusivity) on the boundary was used to add the flux associated with a `Value` or `Gradient` boundary condition. . This PR also adds special boundary conditions for tendency terms (sometimes called 'source terms' in the code), and for the pressure field. Finally, we introduce the boundary condition `BoundaryCondition{Flux, Nothing}` as a synonym for a no-flux boundary condition that does not require the calculation of boundary source terms, to save a few accesses to global memory. Right now there is a bit left to do:. - [x] adapt the checkpointer for the new `timestepper` structure (checkpointer tests currently fail); - [ ] decide whether pressure boundary conditions should be precomputed and stored in `poisson_solver` (currently they are computed at the beginning of a time-stepping cycle inside `time_step!`). If we add pressure boundary conditions to `poisson_solver`, we can also get rid of the special `PoissonBCs` types, since the pressure fields now have explicit bcs associated with them. But this is not urgent.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/389
https://github.com/CliMA/Oceananigans.jl/pull/389:1829,Modifiability,adapt,adapt,1829,"s); * the gradient between the interior node of a field and the associated boundary where the boundary condition is prescribed (for `Value` boundary conditions). `calculate_boundary_source_terms!` is still a part of the algorithm and is used to enforce `Flux` boundary conditions. This function may also prove useful in the future for more sophisticated boundary conditions and for enforcing boundary conditions associated with irregular boundaries. This algorithm permits the gradients of fields to be computed accurately on the boundary both in time stepping and post processing (which is useful, for example, for computing nonlinear diffusivities on the boundary when `Value` or `Gradient` boundary conditions are prescribed), and the code is more mathematically correct as a result. It also means that diffusivities are never involved in enforcing boundary conditions, which is an important simplification. Previously, the diffusivity of a field (or some proxy for diffusivity) on the boundary was used to add the flux associated with a `Value` or `Gradient` boundary condition. . This PR also adds special boundary conditions for tendency terms (sometimes called 'source terms' in the code), and for the pressure field. Finally, we introduce the boundary condition `BoundaryCondition{Flux, Nothing}` as a synonym for a no-flux boundary condition that does not require the calculation of boundary source terms, to save a few accesses to global memory. Right now there is a bit left to do:. - [x] adapt the checkpointer for the new `timestepper` structure (checkpointer tests currently fail); - [ ] decide whether pressure boundary conditions should be precomputed and stored in `poisson_solver` (currently they are computed at the beginning of a time-stepping cycle inside `time_step!`). If we add pressure boundary conditions to `poisson_solver`, we can also get rid of the special `PoissonBCs` types, since the pressure fields now have explicit bcs associated with them. But this is not urgent.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/389
https://github.com/CliMA/Oceananigans.jl/pull/389:1758,Security,access,accesses,1758,"s); * the gradient between the interior node of a field and the associated boundary where the boundary condition is prescribed (for `Value` boundary conditions). `calculate_boundary_source_terms!` is still a part of the algorithm and is used to enforce `Flux` boundary conditions. This function may also prove useful in the future for more sophisticated boundary conditions and for enforcing boundary conditions associated with irregular boundaries. This algorithm permits the gradients of fields to be computed accurately on the boundary both in time stepping and post processing (which is useful, for example, for computing nonlinear diffusivities on the boundary when `Value` or `Gradient` boundary conditions are prescribed), and the code is more mathematically correct as a result. It also means that diffusivities are never involved in enforcing boundary conditions, which is an important simplification. Previously, the diffusivity of a field (or some proxy for diffusivity) on the boundary was used to add the flux associated with a `Value` or `Gradient` boundary condition. . This PR also adds special boundary conditions for tendency terms (sometimes called 'source terms' in the code), and for the pressure field. Finally, we introduce the boundary condition `BoundaryCondition{Flux, Nothing}` as a synonym for a no-flux boundary condition that does not require the calculation of boundary source terms, to save a few accesses to global memory. Right now there is a bit left to do:. - [x] adapt the checkpointer for the new `timestepper` structure (checkpointer tests currently fail); - [ ] decide whether pressure boundary conditions should be precomputed and stored in `poisson_solver` (currently they are computed at the beginning of a time-stepping cycle inside `time_step!`). If we add pressure boundary conditions to `poisson_solver`, we can also get rid of the special `PoissonBCs` types, since the pressure fields now have explicit bcs associated with them. But this is not urgent.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/389
https://github.com/CliMA/Oceananigans.jl/pull/389:1902,Testability,test,tests,1902,"s); * the gradient between the interior node of a field and the associated boundary where the boundary condition is prescribed (for `Value` boundary conditions). `calculate_boundary_source_terms!` is still a part of the algorithm and is used to enforce `Flux` boundary conditions. This function may also prove useful in the future for more sophisticated boundary conditions and for enforcing boundary conditions associated with irregular boundaries. This algorithm permits the gradients of fields to be computed accurately on the boundary both in time stepping and post processing (which is useful, for example, for computing nonlinear diffusivities on the boundary when `Value` or `Gradient` boundary conditions are prescribed), and the code is more mathematically correct as a result. It also means that diffusivities are never involved in enforcing boundary conditions, which is an important simplification. Previously, the diffusivity of a field (or some proxy for diffusivity) on the boundary was used to add the flux associated with a `Value` or `Gradient` boundary condition. . This PR also adds special boundary conditions for tendency terms (sometimes called 'source terms' in the code), and for the pressure field. Finally, we introduce the boundary condition `BoundaryCondition{Flux, Nothing}` as a synonym for a no-flux boundary condition that does not require the calculation of boundary source terms, to save a few accesses to global memory. Right now there is a bit left to do:. - [x] adapt the checkpointer for the new `timestepper` structure (checkpointer tests currently fail); - [ ] decide whether pressure boundary conditions should be precomputed and stored in `poisson_solver` (currently they are computed at the beginning of a time-stepping cycle inside `time_step!`). If we add pressure boundary conditions to `poisson_solver`, we can also get rid of the special `PoissonBCs` types, since the pressure fields now have explicit bcs associated with them. But this is not urgent.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/389
https://github.com/CliMA/Oceananigans.jl/pull/389:1224,Usability,simpl,simplification,1224,"y linearly extrapolating the interior field across the boundary into the halo region, using. * the specified gradient (for `Gradient` boundary conditions); * the gradient between the interior node of a field and the associated boundary where the boundary condition is prescribed (for `Value` boundary conditions). `calculate_boundary_source_terms!` is still a part of the algorithm and is used to enforce `Flux` boundary conditions. This function may also prove useful in the future for more sophisticated boundary conditions and for enforcing boundary conditions associated with irregular boundaries. This algorithm permits the gradients of fields to be computed accurately on the boundary both in time stepping and post processing (which is useful, for example, for computing nonlinear diffusivities on the boundary when `Value` or `Gradient` boundary conditions are prescribed), and the code is more mathematically correct as a result. It also means that diffusivities are never involved in enforcing boundary conditions, which is an important simplification. Previously, the diffusivity of a field (or some proxy for diffusivity) on the boundary was used to add the flux associated with a `Value` or `Gradient` boundary condition. . This PR also adds special boundary conditions for tendency terms (sometimes called 'source terms' in the code), and for the pressure field. Finally, we introduce the boundary condition `BoundaryCondition{Flux, Nothing}` as a synonym for a no-flux boundary condition that does not require the calculation of boundary source terms, to save a few accesses to global memory. Right now there is a bit left to do:. - [x] adapt the checkpointer for the new `timestepper` structure (checkpointer tests currently fail); - [ ] decide whether pressure boundary conditions should be precomputed and stored in `poisson_solver` (currently they are computed at the beginning of a time-stepping cycle inside `time_step!`). If we add pressure boundary conditions to `poisson_solve",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/389
https://github.com/CliMA/Oceananigans.jl/issues/390:1161,Modifiability,refactor,refactoring,1161,"Currently, user-defined forcing functions (say, `F`) have the signature. ```julia; F(grid, U, Φ, i, j, k) = ...; ```. per. https://github.com/climate-machine/Oceananigans.jl/blob/3ab93222717271de194ade9e9b073c1c09f571e8/src/time_steppers.jl#L135. However, I think that we should reorganize this so that the most ""important"" arguments are first. I think perhaps a better ordering would be . ```julia; F(i, j, k, grid, time, velocities, tracers) = ...; ```. The idea is that `grid` is unlikely to be used without indices; however indices can be used without `grid`. This pattern also resembles the pattern we have developed for kernels (and thus could be used in the future to develop ""differentiated"" and ""interpolated"" user-defined forcing functions, for example). This also adds time as an argument, which I think is a good idea as this is needed for lots of elementary things like, eg, the tidal forcing functions desired by #212. Adding time as an argument will require some minor modifications to `calculate_interior_source_terms!`. We should also change over all of our kernel functions to having `(i, j, k, grid)` first, but we don't have to address that refactoring immediately. Note that changing the forcing function signature is a significant change as it affects the user API.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/390
https://github.com/CliMA/Oceananigans.jl/issues/391:336,Performance,perform,performance,336,"I looked through the package and it seems like things are already in CuArrays then. https://github.com/climate-machine/Oceananigans.jl/blob/master/src/time_steppers.jl#L42-L78. this should quite readily port over to using DifferentialEquations.jl. It looks like you're using an IMEXEuler scheme? I think there would be some pretty good performance gains, and it would be interesting to start being able to use this entire package as a benchmark.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/391
https://github.com/CliMA/Oceananigans.jl/issues/391:435,Testability,benchmark,benchmark,435,"I looked through the package and it seems like things are already in CuArrays then. https://github.com/climate-machine/Oceananigans.jl/blob/master/src/time_steppers.jl#L42-L78. this should quite readily port over to using DifferentialEquations.jl. It looks like you're using an IMEXEuler scheme? I think there would be some pretty good performance gains, and it would be interesting to start being able to use this entire package as a benchmark.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/391
https://github.com/CliMA/Oceananigans.jl/issues/394:1226,Availability,down,down,1226,"I wonder if it may be a good idea to add a generic, user-definable 'parameters' field in `Model`. . The main purpose of this field would be to provide the user with more flexibility for boundary condition and forcing functions. Consider the implementation of a simple sponge layer in a script:. ```julia; const dTdz = 0.01; const μ₀ = 0.02. @inline μ(z, Lz) = μ₀ * exp(-(z + Lz) / 0.05Lz); @inline T₀(z) = dTdz * z. @inline FT(grid, U, Φ, i, j, k) = @inbounds -μ(grid.zC[k], grid.Lz) * (Φ.T[i, j, k] - T₀(grid.zC[k])). model = Model(forcing=Forcing(FT=FT), ...); ```. This works, of course. However, it requires the global `const`s `dTdz` and `μ₀` in order to compile on the GPU. This prevents users from, for example, defining a function of the form `create_and_run_model(μ₀, dTdz, other_parameters...)`. The only way to set `μ₀` or `dTdz` is by defining them as global `const`s; therefore a new script (or argument parsing via `ArgParse` and bash scripting) is required for each new run. I feel this is a potentially major limitation to current and future automation and we should attempt to find a solution to address the problem. One partial solution is to add a field `parameters` to the model. This field is then passed down into `calculate_interior_source_terms!` and the boundary condition algorithm to be used, if desired, within a user-defined functions. In this case, the above pattern could become:. ```julia; @inline μ(z, Lz, μ₀) = μ₀ * exp(-(z + Lz) / 0.05Lz); @inline T₀(z, dTdz) = dTdz * z. @inline FT(grid, U, Φ, i, j, k, params) = @inbounds -μ(grid.zC[k], grid.Lz, params.μ₀) * (Φ.T[i, j, k] - T₀(grid.zC[k], params.dTdz)). model = Model(forcing = Forcing(FT=FT), parameters=(μ₀=0.02, dTdz=0.01), ...); ```. We need not restrict the type of the field `parameters`; we can simply add. ```julia; mutable struct Model{P, ...}; ...; parameters :: P; end; ```. And set it to `nothing` by default in the `Model` constructor. The user may provide any kind of `parameters` they wish.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/394
https://github.com/CliMA/Oceananigans.jl/issues/394:261,Usability,simpl,simple,261,"I wonder if it may be a good idea to add a generic, user-definable 'parameters' field in `Model`. . The main purpose of this field would be to provide the user with more flexibility for boundary condition and forcing functions. Consider the implementation of a simple sponge layer in a script:. ```julia; const dTdz = 0.01; const μ₀ = 0.02. @inline μ(z, Lz) = μ₀ * exp(-(z + Lz) / 0.05Lz); @inline T₀(z) = dTdz * z. @inline FT(grid, U, Φ, i, j, k) = @inbounds -μ(grid.zC[k], grid.Lz) * (Φ.T[i, j, k] - T₀(grid.zC[k])). model = Model(forcing=Forcing(FT=FT), ...); ```. This works, of course. However, it requires the global `const`s `dTdz` and `μ₀` in order to compile on the GPU. This prevents users from, for example, defining a function of the form `create_and_run_model(μ₀, dTdz, other_parameters...)`. The only way to set `μ₀` or `dTdz` is by defining them as global `const`s; therefore a new script (or argument parsing via `ArgParse` and bash scripting) is required for each new run. I feel this is a potentially major limitation to current and future automation and we should attempt to find a solution to address the problem. One partial solution is to add a field `parameters` to the model. This field is then passed down into `calculate_interior_source_terms!` and the boundary condition algorithm to be used, if desired, within a user-defined functions. In this case, the above pattern could become:. ```julia; @inline μ(z, Lz, μ₀) = μ₀ * exp(-(z + Lz) / 0.05Lz); @inline T₀(z, dTdz) = dTdz * z. @inline FT(grid, U, Φ, i, j, k, params) = @inbounds -μ(grid.zC[k], grid.Lz, params.μ₀) * (Φ.T[i, j, k] - T₀(grid.zC[k], params.dTdz)). model = Model(forcing = Forcing(FT=FT), parameters=(μ₀=0.02, dTdz=0.01), ...); ```. We need not restrict the type of the field `parameters`; we can simply add. ```julia; mutable struct Model{P, ...}; ...; parameters :: P; end; ```. And set it to `nothing` by default in the `Model` constructor. The user may provide any kind of `parameters` they wish.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/394
https://github.com/CliMA/Oceananigans.jl/issues/394:1790,Usability,simpl,simply,1790,"I wonder if it may be a good idea to add a generic, user-definable 'parameters' field in `Model`. . The main purpose of this field would be to provide the user with more flexibility for boundary condition and forcing functions. Consider the implementation of a simple sponge layer in a script:. ```julia; const dTdz = 0.01; const μ₀ = 0.02. @inline μ(z, Lz) = μ₀ * exp(-(z + Lz) / 0.05Lz); @inline T₀(z) = dTdz * z. @inline FT(grid, U, Φ, i, j, k) = @inbounds -μ(grid.zC[k], grid.Lz) * (Φ.T[i, j, k] - T₀(grid.zC[k])). model = Model(forcing=Forcing(FT=FT), ...); ```. This works, of course. However, it requires the global `const`s `dTdz` and `μ₀` in order to compile on the GPU. This prevents users from, for example, defining a function of the form `create_and_run_model(μ₀, dTdz, other_parameters...)`. The only way to set `μ₀` or `dTdz` is by defining them as global `const`s; therefore a new script (or argument parsing via `ArgParse` and bash scripting) is required for each new run. I feel this is a potentially major limitation to current and future automation and we should attempt to find a solution to address the problem. One partial solution is to add a field `parameters` to the model. This field is then passed down into `calculate_interior_source_terms!` and the boundary condition algorithm to be used, if desired, within a user-defined functions. In this case, the above pattern could become:. ```julia; @inline μ(z, Lz, μ₀) = μ₀ * exp(-(z + Lz) / 0.05Lz); @inline T₀(z, dTdz) = dTdz * z. @inline FT(grid, U, Φ, i, j, k, params) = @inbounds -μ(grid.zC[k], grid.Lz, params.μ₀) * (Φ.T[i, j, k] - T₀(grid.zC[k], params.dTdz)). model = Model(forcing = Forcing(FT=FT), parameters=(μ₀=0.02, dTdz=0.01), ...); ```. We need not restrict the type of the field `parameters`; we can simply add. ```julia; mutable struct Model{P, ...}; ...; parameters :: P; end; ```. And set it to `nothing` by default in the `Model` constructor. The user may provide any kind of `parameters` they wish.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/394
https://github.com/CliMA/Oceananigans.jl/issues/397:23,Performance,perform,performance,23,"There seems to be some performance regression as we now perform tons of little memory allocations somewhere. Model still time steps as fast as it should so we probably haven't noticed it as we run large model sizes where this allocations are kind of hidden. Seems like mainly a CPU issue. CPU: ; ```; julia> using Oceananigans. julia> model = Model(N=(128, 128, 128), L=(1, 1, 1));. julia> @time time_step!(model, 1, 1); 16.614982 seconds (34.03 M allocations: 1.775 GiB, 6.86% gc time). julia> @time time_step!(model, 1, 1); 0.738576 seconds (1.31 M allocations: 264.089 MiB, 3.97% gc time); ```. GPU:; ```; julia> using Oceananigans. julia> model = Model(N=(256, 256, 256), L=(1, 1, 1), arch=GPU());. julia> @time time_step!(model, 1, 1);; 28.425740 seconds (71.04 M allocations: 3.383 GiB, 10.72% gc time). julia> @time time_step!(model, 1, 1);; 0.025893 seconds (8.90 k allocations: 978.531 KiB); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/397
https://github.com/CliMA/Oceananigans.jl/issues/397:56,Performance,perform,perform,56,"There seems to be some performance regression as we now perform tons of little memory allocations somewhere. Model still time steps as fast as it should so we probably haven't noticed it as we run large model sizes where this allocations are kind of hidden. Seems like mainly a CPU issue. CPU: ; ```; julia> using Oceananigans. julia> model = Model(N=(128, 128, 128), L=(1, 1, 1));. julia> @time time_step!(model, 1, 1); 16.614982 seconds (34.03 M allocations: 1.775 GiB, 6.86% gc time). julia> @time time_step!(model, 1, 1); 0.738576 seconds (1.31 M allocations: 264.089 MiB, 3.97% gc time); ```. GPU:; ```; julia> using Oceananigans. julia> model = Model(N=(256, 256, 256), L=(1, 1, 1), arch=GPU());. julia> @time time_step!(model, 1, 1);; 28.425740 seconds (71.04 M allocations: 3.383 GiB, 10.72% gc time). julia> @time time_step!(model, 1, 1);; 0.025893 seconds (8.90 k allocations: 978.531 KiB); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/397
https://github.com/CliMA/Oceananigans.jl/pull/399:8,Modifiability,rewrite,rewrites,8,This PR rewrites the top-level `export` statement for `Oceananigans.jl`. Mainly it omits many names from the `export` statement that we do not intend to be part of the user API. Resolves #364.; Resolves #313.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/399
https://github.com/CliMA/Oceananigans.jl/pull/400:42,Availability,toler,tolerance,42,This test occasionally fails as I set the tolerance a little low.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/400
https://github.com/CliMA/Oceananigans.jl/pull/400:5,Testability,test,test,5,This test occasionally fails as I set the tolerance a little low.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/400
https://github.com/CliMA/Oceananigans.jl/pull/401:317,Availability,checkpoint,checkpointing,317,"This PR simplifies and generalizes the model constructor, which is a major change to the API. Except for `initialize_tracers` and `float_type`, all of the keyword arguments to `Model` now correspond semantically to the fields of model. In addition to clarifying the arguments of the model constructor, this will make checkpointing easier. . In addition, model fields that contain arrays, and thus are involved with large amounts of memory allocation, can be initialized through the model constructor. This should enable upgrades to the checkpointer that make it possible to checkpoint very large models that fill GPU memory. Finally, we add three new convenience constructors that retain the legacy behavior of model, and provide convenient ways to initialize particular models: `BasicModel`, `BasicChannelModel`, and `NonDimensionalModel`. `BasicModel` and `BasicChannelModel` closely resembles the original model constructor, while `NonDimensionalModel` allow parameters to be set by specifying non-dimensional numbers, rather than dimensional constants. Resolves #372.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/401
https://github.com/CliMA/Oceananigans.jl/pull/401:536,Availability,checkpoint,checkpointer,536,"This PR simplifies and generalizes the model constructor, which is a major change to the API. Except for `initialize_tracers` and `float_type`, all of the keyword arguments to `Model` now correspond semantically to the fields of model. In addition to clarifying the arguments of the model constructor, this will make checkpointing easier. . In addition, model fields that contain arrays, and thus are involved with large amounts of memory allocation, can be initialized through the model constructor. This should enable upgrades to the checkpointer that make it possible to checkpoint very large models that fill GPU memory. Finally, we add three new convenience constructors that retain the legacy behavior of model, and provide convenient ways to initialize particular models: `BasicModel`, `BasicChannelModel`, and `NonDimensionalModel`. `BasicModel` and `BasicChannelModel` closely resembles the original model constructor, while `NonDimensionalModel` allow parameters to be set by specifying non-dimensional numbers, rather than dimensional constants. Resolves #372.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/401
https://github.com/CliMA/Oceananigans.jl/pull/401:574,Availability,checkpoint,checkpoint,574,"This PR simplifies and generalizes the model constructor, which is a major change to the API. Except for `initialize_tracers` and `float_type`, all of the keyword arguments to `Model` now correspond semantically to the fields of model. In addition to clarifying the arguments of the model constructor, this will make checkpointing easier. . In addition, model fields that contain arrays, and thus are involved with large amounts of memory allocation, can be initialized through the model constructor. This should enable upgrades to the checkpointer that make it possible to checkpoint very large models that fill GPU memory. Finally, we add three new convenience constructors that retain the legacy behavior of model, and provide convenient ways to initialize particular models: `BasicModel`, `BasicChannelModel`, and `NonDimensionalModel`. `BasicModel` and `BasicChannelModel` closely resembles the original model constructor, while `NonDimensionalModel` allow parameters to be set by specifying non-dimensional numbers, rather than dimensional constants. Resolves #372.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/401
https://github.com/CliMA/Oceananigans.jl/pull/401:520,Deployability,upgrade,upgrades,520,"This PR simplifies and generalizes the model constructor, which is a major change to the API. Except for `initialize_tracers` and `float_type`, all of the keyword arguments to `Model` now correspond semantically to the fields of model. In addition to clarifying the arguments of the model constructor, this will make checkpointing easier. . In addition, model fields that contain arrays, and thus are involved with large amounts of memory allocation, can be initialized through the model constructor. This should enable upgrades to the checkpointer that make it possible to checkpoint very large models that fill GPU memory. Finally, we add three new convenience constructors that retain the legacy behavior of model, and provide convenient ways to initialize particular models: `BasicModel`, `BasicChannelModel`, and `NonDimensionalModel`. `BasicModel` and `BasicChannelModel` closely resembles the original model constructor, while `NonDimensionalModel` allow parameters to be set by specifying non-dimensional numbers, rather than dimensional constants. Resolves #372.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/401
https://github.com/CliMA/Oceananigans.jl/pull/401:8,Usability,simpl,simplifies,8,"This PR simplifies and generalizes the model constructor, which is a major change to the API. Except for `initialize_tracers` and `float_type`, all of the keyword arguments to `Model` now correspond semantically to the fields of model. In addition to clarifying the arguments of the model constructor, this will make checkpointing easier. . In addition, model fields that contain arrays, and thus are involved with large amounts of memory allocation, can be initialized through the model constructor. This should enable upgrades to the checkpointer that make it possible to checkpoint very large models that fill GPU memory. Finally, we add three new convenience constructors that retain the legacy behavior of model, and provide convenient ways to initialize particular models: `BasicModel`, `BasicChannelModel`, and `NonDimensionalModel`. `BasicModel` and `BasicChannelModel` closely resembles the original model constructor, while `NonDimensionalModel` allow parameters to be set by specifying non-dimensional numbers, rather than dimensional constants. Resolves #372.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/401
https://github.com/CliMA/Oceananigans.jl/pull/402:27,Performance,perform,performance,27,"This PR implements a minor performance optimization that changes the 'default' boundary condition type to `BoundaryCondition{Flux, Nothing}`. Using this type elides the adding of 0's in the case of zero flux boundary conditions. The functionality for eliding computation in this case was already implemented; however it was not used by default. . This may address #397, but @ali-ramadhan we need to benchmark.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/402
https://github.com/CliMA/Oceananigans.jl/pull/402:39,Performance,optimiz,optimization,39,"This PR implements a minor performance optimization that changes the 'default' boundary condition type to `BoundaryCondition{Flux, Nothing}`. Using this type elides the adding of 0's in the case of zero flux boundary conditions. The functionality for eliding computation in this case was already implemented; however it was not used by default. . This may address #397, but @ali-ramadhan we need to benchmark.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/402
https://github.com/CliMA/Oceananigans.jl/pull/402:399,Testability,benchmark,benchmark,399,"This PR implements a minor performance optimization that changes the 'default' boundary condition type to `BoundaryCondition{Flux, Nothing}`. Using this type elides the adding of 0's in the case of zero flux boundary conditions. The functionality for eliding computation in this case was already implemented; however it was not used by default. . This may address #397, but @ali-ramadhan we need to benchmark.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/402
https://github.com/CliMA/Oceananigans.jl/issues/403:169,Integrability,wrap,wrapping,169,"We need to revise our abstraction for the equation of state. At the same time, considering changes to how we abstract model rotation (see #217), we may want to consider wrapping changes to the equation of state abstraction with changes to how we deal with buoyancy in general. This is important for stabilizing the API, ensuring that our pressure fields have the same dimensionality (important for post-processing and analysis), and for ensuring an extensible design permitting the smooth implementation of future desired features, like arbitrary tracer fields. I propose that we adopt a hierarchical approach to abstracting buoyancy and the equation of state. . Consider first that gravitational acceleration (""`g`"") is solely associated with 'buoyancy', and is only a required parameter when buoyancy is determined via density (gravitational acceleration therefore should not be a parameter of `Model` when running with no tracers, or when running with buoyancy as a tracer itself). Thus I think that we should have a type associated with the model representation of ""buoyancy"" that, in the general case, contains information both about gravitational acceleration and about the equation of state that relates tracer composition (and perhaps the pressure field) to density. Our current tracer set can be associated with the type ""`SeawaterBuoyancy`"", which might look something like. ```julia; struct SeawaterBuoyancy{T, E} <: AbstractBuoyancy; gravitational_acceleration :: T; equation_of_state :: E; end; ```. In the future, we may also have the structs `TemperatureBuoyancy` (when only temperature is used), and `TracerBuoyancy` (when buoyancy itself is a tracer). In addition, we can dispatch on the case that `buoyancy = nothing` when the user wishes to omit buoyancy forces. The equation of state will provide the functionality that `EquationOfState` provides currently. However, I propose that we remove all parameters that are unused in the model so that it becomes. ```julia; struct LinearEq",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/403
https://github.com/CliMA/Oceananigans.jl/issues/403:2134,Integrability,contract,contraction,2134,"ains information both about gravitational acceleration and about the equation of state that relates tracer composition (and perhaps the pressure field) to density. Our current tracer set can be associated with the type ""`SeawaterBuoyancy`"", which might look something like. ```julia; struct SeawaterBuoyancy{T, E} <: AbstractBuoyancy; gravitational_acceleration :: T; equation_of_state :: E; end; ```. In the future, we may also have the structs `TemperatureBuoyancy` (when only temperature is used), and `TracerBuoyancy` (when buoyancy itself is a tracer). In addition, we can dispatch on the case that `buoyancy = nothing` when the user wishes to omit buoyancy forces. The equation of state will provide the functionality that `EquationOfState` provides currently. However, I propose that we remove all parameters that are unused in the model so that it becomes. ```julia; struct LinearEquationOfState{T} <: EquationOfState; α :: T ; β :: T; end; ```. where `α` is the thermal expansion coefficient and `β` is the haline contraction coefficient.; Including only parameters that are explicitly used is important for avoiding problems and confusion in the future with the addition of new types, features and functionality. Finally, we must discuss the functions that are associated with buoyancy. Previously, it was proposed that we use a function called `buoyancy`. However, this was rejected. I believe the reason (please clarify if I am wrong) was that these semantics do not generalize properly to the case of a nonlinear equation of state and may lead to bugs and confusion in the future. To solve the aforementioned issues, I propose that we require each buoyancy type to define (at least) three functions:. 1) `buoyancy_perturbation(i, j, k, grid, buoyancy, C)`, or perhaps just `b′`, which computes the perturbation from a (possibly compression-related and z-dependent) background given the tracers `C`. In the case of `TracerBuoyancy`, this simply returns `C.b[i, j, k]`. In the case of `buo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/403
https://github.com/CliMA/Oceananigans.jl/issues/403:2978,Integrability,depend,dependent,2978,"ers that are unused in the model so that it becomes. ```julia; struct LinearEquationOfState{T} <: EquationOfState; α :: T ; β :: T; end; ```. where `α` is the thermal expansion coefficient and `β` is the haline contraction coefficient.; Including only parameters that are explicitly used is important for avoiding problems and confusion in the future with the addition of new types, features and functionality. Finally, we must discuss the functions that are associated with buoyancy. Previously, it was proposed that we use a function called `buoyancy`. However, this was rejected. I believe the reason (please clarify if I am wrong) was that these semantics do not generalize properly to the case of a nonlinear equation of state and may lead to bugs and confusion in the future. To solve the aforementioned issues, I propose that we require each buoyancy type to define (at least) three functions:. 1) `buoyancy_perturbation(i, j, k, grid, buoyancy, C)`, or perhaps just `b′`, which computes the perturbation from a (possibly compression-related and z-dependent) background given the tracers `C`. In the case of `TracerBuoyancy`, this simply returns `C.b[i, j, k]`. In the case of `buoyancy::Nothing`, this returns `0`. In the case of a linear equation of state for seawater, we might have . ```julia; function buoyancy_perturbation(i, j, k, grid, buoyancy, C); return buoyancy.gravitational_acceleration * (; buoyancy.equation_of_state.α * C.T[i, j, k]; - buoyancy.equation_of_state.β * C.S[i, j, k] ); end; ```. for example. @jm-c @christophernhill @johncmarshall54 @rafferrari please advise that this concept will work with our algorithm as it stands, and that it generalizes to nonlinear equations of state (for example, do we need the pressure field as well?). 2) `total_buoyancy(i, j, k, grid, buoyancy, C)`, which returns the total buoyancy, perturbation plus background (is this needed?). 3) `total_buoyancy_gradient` and `perturbation_buoyancy_gradient` which returns the buoyancy gradien",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/403
https://github.com/CliMA/Oceananigans.jl/issues/403:2228,Safety,avoid,avoiding,2228,"e pressure field) to density. Our current tracer set can be associated with the type ""`SeawaterBuoyancy`"", which might look something like. ```julia; struct SeawaterBuoyancy{T, E} <: AbstractBuoyancy; gravitational_acceleration :: T; equation_of_state :: E; end; ```. In the future, we may also have the structs `TemperatureBuoyancy` (when only temperature is used), and `TracerBuoyancy` (when buoyancy itself is a tracer). In addition, we can dispatch on the case that `buoyancy = nothing` when the user wishes to omit buoyancy forces. The equation of state will provide the functionality that `EquationOfState` provides currently. However, I propose that we remove all parameters that are unused in the model so that it becomes. ```julia; struct LinearEquationOfState{T} <: EquationOfState; α :: T ; β :: T; end; ```. where `α` is the thermal expansion coefficient and `β` is the haline contraction coefficient.; Including only parameters that are explicitly used is important for avoiding problems and confusion in the future with the addition of new types, features and functionality. Finally, we must discuss the functions that are associated with buoyancy. Previously, it was proposed that we use a function called `buoyancy`. However, this was rejected. I believe the reason (please clarify if I am wrong) was that these semantics do not generalize properly to the case of a nonlinear equation of state and may lead to bugs and confusion in the future. To solve the aforementioned issues, I propose that we require each buoyancy type to define (at least) three functions:. 1) `buoyancy_perturbation(i, j, k, grid, buoyancy, C)`, or perhaps just `b′`, which computes the perturbation from a (possibly compression-related and z-dependent) background given the tracers `C`. In the case of `TracerBuoyancy`, this simply returns `C.b[i, j, k]`. In the case of `buoyancy::Nothing`, this returns `0`. In the case of a linear equation of state for seawater, we might have . ```julia; function buoyancy_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/403
https://github.com/CliMA/Oceananigans.jl/issues/403:3061,Usability,simpl,simply,3061,": T; end; ```. where `α` is the thermal expansion coefficient and `β` is the haline contraction coefficient.; Including only parameters that are explicitly used is important for avoiding problems and confusion in the future with the addition of new types, features and functionality. Finally, we must discuss the functions that are associated with buoyancy. Previously, it was proposed that we use a function called `buoyancy`. However, this was rejected. I believe the reason (please clarify if I am wrong) was that these semantics do not generalize properly to the case of a nonlinear equation of state and may lead to bugs and confusion in the future. To solve the aforementioned issues, I propose that we require each buoyancy type to define (at least) three functions:. 1) `buoyancy_perturbation(i, j, k, grid, buoyancy, C)`, or perhaps just `b′`, which computes the perturbation from a (possibly compression-related and z-dependent) background given the tracers `C`. In the case of `TracerBuoyancy`, this simply returns `C.b[i, j, k]`. In the case of `buoyancy::Nothing`, this returns `0`. In the case of a linear equation of state for seawater, we might have . ```julia; function buoyancy_perturbation(i, j, k, grid, buoyancy, C); return buoyancy.gravitational_acceleration * (; buoyancy.equation_of_state.α * C.T[i, j, k]; - buoyancy.equation_of_state.β * C.S[i, j, k] ); end; ```. for example. @jm-c @christophernhill @johncmarshall54 @rafferrari please advise that this concept will work with our algorithm as it stands, and that it generalizes to nonlinear equations of state (for example, do we need the pressure field as well?). 2) `total_buoyancy(i, j, k, grid, buoyancy, C)`, which returns the total buoyancy, perturbation plus background (is this needed?). 3) `total_buoyancy_gradient` and `perturbation_buoyancy_gradient` which returns the buoyancy gradients needed for turbulence closures, parameters, and such. @jm-c @christophernhill @johncmarshall54 @rafferrari, please advise if ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/403
https://github.com/CliMA/Oceananigans.jl/pull/404:22,Deployability,update,updated,22,Good to keep packages updated to avoid abrupt changes in dependencies.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/404
https://github.com/CliMA/Oceananigans.jl/pull/404:57,Integrability,depend,dependencies,57,Good to keep packages updated to avoid abrupt changes in dependencies.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/404
https://github.com/CliMA/Oceananigans.jl/pull/404:33,Safety,avoid,avoid,33,Good to keep packages updated to avoid abrupt changes in dependencies.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/404
https://github.com/CliMA/Oceananigans.jl/pull/405:751,Availability,checkpoint,checkpointing,751,"This PR refactors the boundary conditions container to reflect the fact that there are three boundary conditions: a tuple of `FieldBoundaryConditions` for the `solution`, a tuple of `FieldBoundaryConditions` for the `tendencies`, and a single `FieldBoundaryConditions` for the `pressures` (which is also used to set boundary conditions on `diffusivities`. To reflect these facts, this model creates a new tuple called `SolutionBoundaryConditions` to hold the boundary conditions for solution. `ModelBoundaryConditions` then becomes a named tuple with fields `solution`, `tendency`, and `pressure`. The model constructor may be passed either a `SolutionBoundaryConditions` (preserving existing behavior), or a `ModelBoundaryConditions` (convenient for checkpointing). Ditto for `PoissonBCs` --- though technically we don't need `PoissonBCs` anymore; we simply need to dispatch on the type of `model.boundary_conditions.pressure` (work for the future). Previously, a new instance of boundary conditions for pressure was created every time-step. This PR avoids that unnecessary cost / allocation. It also moves boundary conditions out of `timestepper`, slightly changing the time stepper struct. @ali-ramadhan, the tests pass so I think the checkpointer works, but it'd be worth thinking about whether its doing the right thing now.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/405
https://github.com/CliMA/Oceananigans.jl/pull/405:1238,Availability,checkpoint,checkpointer,1238,"This PR refactors the boundary conditions container to reflect the fact that there are three boundary conditions: a tuple of `FieldBoundaryConditions` for the `solution`, a tuple of `FieldBoundaryConditions` for the `tendencies`, and a single `FieldBoundaryConditions` for the `pressures` (which is also used to set boundary conditions on `diffusivities`. To reflect these facts, this model creates a new tuple called `SolutionBoundaryConditions` to hold the boundary conditions for solution. `ModelBoundaryConditions` then becomes a named tuple with fields `solution`, `tendency`, and `pressure`. The model constructor may be passed either a `SolutionBoundaryConditions` (preserving existing behavior), or a `ModelBoundaryConditions` (convenient for checkpointing). Ditto for `PoissonBCs` --- though technically we don't need `PoissonBCs` anymore; we simply need to dispatch on the type of `model.boundary_conditions.pressure` (work for the future). Previously, a new instance of boundary conditions for pressure was created every time-step. This PR avoids that unnecessary cost / allocation. It also moves boundary conditions out of `timestepper`, slightly changing the time stepper struct. @ali-ramadhan, the tests pass so I think the checkpointer works, but it'd be worth thinking about whether its doing the right thing now.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/405
https://github.com/CliMA/Oceananigans.jl/pull/405:8,Modifiability,refactor,refactors,8,"This PR refactors the boundary conditions container to reflect the fact that there are three boundary conditions: a tuple of `FieldBoundaryConditions` for the `solution`, a tuple of `FieldBoundaryConditions` for the `tendencies`, and a single `FieldBoundaryConditions` for the `pressures` (which is also used to set boundary conditions on `diffusivities`. To reflect these facts, this model creates a new tuple called `SolutionBoundaryConditions` to hold the boundary conditions for solution. `ModelBoundaryConditions` then becomes a named tuple with fields `solution`, `tendency`, and `pressure`. The model constructor may be passed either a `SolutionBoundaryConditions` (preserving existing behavior), or a `ModelBoundaryConditions` (convenient for checkpointing). Ditto for `PoissonBCs` --- though technically we don't need `PoissonBCs` anymore; we simply need to dispatch on the type of `model.boundary_conditions.pressure` (work for the future). Previously, a new instance of boundary conditions for pressure was created every time-step. This PR avoids that unnecessary cost / allocation. It also moves boundary conditions out of `timestepper`, slightly changing the time stepper struct. @ali-ramadhan, the tests pass so I think the checkpointer works, but it'd be worth thinking about whether its doing the right thing now.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/405
https://github.com/CliMA/Oceananigans.jl/pull/405:1051,Safety,avoid,avoids,1051,"This PR refactors the boundary conditions container to reflect the fact that there are three boundary conditions: a tuple of `FieldBoundaryConditions` for the `solution`, a tuple of `FieldBoundaryConditions` for the `tendencies`, and a single `FieldBoundaryConditions` for the `pressures` (which is also used to set boundary conditions on `diffusivities`. To reflect these facts, this model creates a new tuple called `SolutionBoundaryConditions` to hold the boundary conditions for solution. `ModelBoundaryConditions` then becomes a named tuple with fields `solution`, `tendency`, and `pressure`. The model constructor may be passed either a `SolutionBoundaryConditions` (preserving existing behavior), or a `ModelBoundaryConditions` (convenient for checkpointing). Ditto for `PoissonBCs` --- though technically we don't need `PoissonBCs` anymore; we simply need to dispatch on the type of `model.boundary_conditions.pressure` (work for the future). Previously, a new instance of boundary conditions for pressure was created every time-step. This PR avoids that unnecessary cost / allocation. It also moves boundary conditions out of `timestepper`, slightly changing the time stepper struct. @ali-ramadhan, the tests pass so I think the checkpointer works, but it'd be worth thinking about whether its doing the right thing now.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/405
https://github.com/CliMA/Oceananigans.jl/pull/405:1212,Testability,test,tests,1212,"This PR refactors the boundary conditions container to reflect the fact that there are three boundary conditions: a tuple of `FieldBoundaryConditions` for the `solution`, a tuple of `FieldBoundaryConditions` for the `tendencies`, and a single `FieldBoundaryConditions` for the `pressures` (which is also used to set boundary conditions on `diffusivities`. To reflect these facts, this model creates a new tuple called `SolutionBoundaryConditions` to hold the boundary conditions for solution. `ModelBoundaryConditions` then becomes a named tuple with fields `solution`, `tendency`, and `pressure`. The model constructor may be passed either a `SolutionBoundaryConditions` (preserving existing behavior), or a `ModelBoundaryConditions` (convenient for checkpointing). Ditto for `PoissonBCs` --- though technically we don't need `PoissonBCs` anymore; we simply need to dispatch on the type of `model.boundary_conditions.pressure` (work for the future). Previously, a new instance of boundary conditions for pressure was created every time-step. This PR avoids that unnecessary cost / allocation. It also moves boundary conditions out of `timestepper`, slightly changing the time stepper struct. @ali-ramadhan, the tests pass so I think the checkpointer works, but it'd be worth thinking about whether its doing the right thing now.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/405
https://github.com/CliMA/Oceananigans.jl/pull/405:852,Usability,simpl,simply,852,"This PR refactors the boundary conditions container to reflect the fact that there are three boundary conditions: a tuple of `FieldBoundaryConditions` for the `solution`, a tuple of `FieldBoundaryConditions` for the `tendencies`, and a single `FieldBoundaryConditions` for the `pressures` (which is also used to set boundary conditions on `diffusivities`. To reflect these facts, this model creates a new tuple called `SolutionBoundaryConditions` to hold the boundary conditions for solution. `ModelBoundaryConditions` then becomes a named tuple with fields `solution`, `tendency`, and `pressure`. The model constructor may be passed either a `SolutionBoundaryConditions` (preserving existing behavior), or a `ModelBoundaryConditions` (convenient for checkpointing). Ditto for `PoissonBCs` --- though technically we don't need `PoissonBCs` anymore; we simply need to dispatch on the type of `model.boundary_conditions.pressure` (work for the future). Previously, a new instance of boundary conditions for pressure was created every time-step. This PR avoids that unnecessary cost / allocation. It also moves boundary conditions out of `timestepper`, slightly changing the time stepper struct. @ali-ramadhan, the tests pass so I think the checkpointer works, but it'd be worth thinking about whether its doing the right thing now.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/405
https://github.com/CliMA/Oceananigans.jl/pull/406:446,Availability,redundant,redundant,446,"Started to write documentation and docstrings but some parts of the code were a little too messy to be documented easily, so I ended up doing some cleanup that seems to deserve its own PR. I mainly renamed all the abstract types to have the `Abstract` prefix (following the Julia style guide) and simplified `LinearEquationOfState`, `PlanetaryConstants`, and `RegularCartesianGrid` where I removed properties that weren't being used or that were redundant/useless. Resolves #190 (because the constants in question have been removed); Resolves #285",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/406
https://github.com/CliMA/Oceananigans.jl/pull/406:446,Safety,redund,redundant,446,"Started to write documentation and docstrings but some parts of the code were a little too messy to be documented easily, so I ended up doing some cleanup that seems to deserve its own PR. I mainly renamed all the abstract types to have the `Abstract` prefix (following the Julia style guide) and simplified `LinearEquationOfState`, `PlanetaryConstants`, and `RegularCartesianGrid` where I removed properties that weren't being used or that were redundant/useless. Resolves #190 (because the constants in question have been removed); Resolves #285",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/406
https://github.com/CliMA/Oceananigans.jl/pull/406:286,Usability,guid,guide,286,"Started to write documentation and docstrings but some parts of the code were a little too messy to be documented easily, so I ended up doing some cleanup that seems to deserve its own PR. I mainly renamed all the abstract types to have the `Abstract` prefix (following the Julia style guide) and simplified `LinearEquationOfState`, `PlanetaryConstants`, and `RegularCartesianGrid` where I removed properties that weren't being used or that were redundant/useless. Resolves #190 (because the constants in question have been removed); Resolves #285",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/406
https://github.com/CliMA/Oceananigans.jl/pull/406:297,Usability,simpl,simplified,297,"Started to write documentation and docstrings but some parts of the code were a little too messy to be documented easily, so I ended up doing some cleanup that seems to deserve its own PR. I mainly renamed all the abstract types to have the `Abstract` prefix (following the Julia style guide) and simplified `LinearEquationOfState`, `PlanetaryConstants`, and `RegularCartesianGrid` where I removed properties that weren't being used or that were redundant/useless. Resolves #190 (because the constants in question have been removed); Resolves #285",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/406
https://github.com/CliMA/Oceananigans.jl/pull/407:601,Testability,test,tests,601,"This PR adds a new `Diagnostic` type called `Timeseries`, which takes a function or callable object of model (anything that has a method of the form `obj(model)`), and stores the result in `data` vector and the time-of-collection in a `time` vector. It also adds an object called `CFL` which computes the Courant-Freidrichs-Lewy number. `CFL` associates with a function `timescale`, which is used to provide convenience constructors `AdvectiveCFL` and `DiffusiveCFL`. We also add an object for computing `maximum(f, field.data.parent)` for `field`s, for an element wise operation `f`. The PR includes tests and docstrings for this functionality.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/407
https://github.com/CliMA/Oceananigans.jl/pull/408:47,Testability,test,tests,47,"This PR is ready for merger when approved, and tests pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/408
https://github.com/CliMA/Oceananigans.jl/pull/409:8,Modifiability,refactor,refactors,8,"This PR refactors the implementation of the Field abstraction. There is now only one type of `Field`, with the type signature . ```julia; Field{Lx, Ly, Lz, A, G}; ```. where `Lx, Ly, Lz` denote the 'locations' of the field within a cell. For example, a `CellField` is now defined via. ```julia; const CellField = Field{Cell, Cell, Cell}; ```. Let's consider this PR carefully and ensure that it makes sense. Resolves #298.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/409
https://github.com/CliMA/Oceananigans.jl/pull/410:916,Energy Efficiency,reduce,reduce,916,"This PR adds docstrings for all exported functions (i.e. functions that will be part of the public API) so users can actually look up what functions do. In the next PR I will make sure all the necessary docstrings get compiled to documentation. I followed the guidelines on https://docs.julialang.org/en/v1.0.2/manual/documentation/ and limited docstrings to 92 character lines. I ended up documenting abstract types because although they aren't exported, they show up in the docstrings of many functions, so it's reasonable to expect that users may want to look them up. One thing I noticed is how often we use this pattern where we define extra constructors like; ```julia; thing(T=Float64; kwargs) = thing{T}(kwargs); ```; when it seems like we should just be using `thing{T}(kwargs)` which will help declutter the public user API a bit. I also noticed that using the prefix `Abstract` for all abstract types may reduce code readability (and isn't followed in Julia Base: see the abstract types `AbstractFloat`, `Number`, `Real`). So we might have to judge a little bit: `AbstractGrid` is probably a good idea but `AbstractBoundaryConditionType` is going a little far and `AbstractTensorDiffusivity` seems a little verbose. Not sure of the best guideline to stick to. Some things that still need to be done:; 1. Not sure of the proper citation(s) to use for `DeardorffSmagorinsky`. @glwagner; 2. Will wait for PR #409 before I write docstrings for `fields.jl`.; 3. While not part of the public user API, I'll write docstrings for the time stepping kernels as I think they'll prove to be valuable.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/410
https://github.com/CliMA/Oceananigans.jl/pull/410:260,Usability,guid,guidelines,260,"This PR adds docstrings for all exported functions (i.e. functions that will be part of the public API) so users can actually look up what functions do. In the next PR I will make sure all the necessary docstrings get compiled to documentation. I followed the guidelines on https://docs.julialang.org/en/v1.0.2/manual/documentation/ and limited docstrings to 92 character lines. I ended up documenting abstract types because although they aren't exported, they show up in the docstrings of many functions, so it's reasonable to expect that users may want to look them up. One thing I noticed is how often we use this pattern where we define extra constructors like; ```julia; thing(T=Float64; kwargs) = thing{T}(kwargs); ```; when it seems like we should just be using `thing{T}(kwargs)` which will help declutter the public user API a bit. I also noticed that using the prefix `Abstract` for all abstract types may reduce code readability (and isn't followed in Julia Base: see the abstract types `AbstractFloat`, `Number`, `Real`). So we might have to judge a little bit: `AbstractGrid` is probably a good idea but `AbstractBoundaryConditionType` is going a little far and `AbstractTensorDiffusivity` seems a little verbose. Not sure of the best guideline to stick to. Some things that still need to be done:; 1. Not sure of the proper citation(s) to use for `DeardorffSmagorinsky`. @glwagner; 2. Will wait for PR #409 before I write docstrings for `fields.jl`.; 3. While not part of the public user API, I'll write docstrings for the time stepping kernels as I think they'll prove to be valuable.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/410
https://github.com/CliMA/Oceananigans.jl/pull/410:1248,Usability,guid,guideline,1248,"This PR adds docstrings for all exported functions (i.e. functions that will be part of the public API) so users can actually look up what functions do. In the next PR I will make sure all the necessary docstrings get compiled to documentation. I followed the guidelines on https://docs.julialang.org/en/v1.0.2/manual/documentation/ and limited docstrings to 92 character lines. I ended up documenting abstract types because although they aren't exported, they show up in the docstrings of many functions, so it's reasonable to expect that users may want to look them up. One thing I noticed is how often we use this pattern where we define extra constructors like; ```julia; thing(T=Float64; kwargs) = thing{T}(kwargs); ```; when it seems like we should just be using `thing{T}(kwargs)` which will help declutter the public user API a bit. I also noticed that using the prefix `Abstract` for all abstract types may reduce code readability (and isn't followed in Julia Base: see the abstract types `AbstractFloat`, `Number`, `Real`). So we might have to judge a little bit: `AbstractGrid` is probably a good idea but `AbstractBoundaryConditionType` is going a little far and `AbstractTensorDiffusivity` seems a little verbose. Not sure of the best guideline to stick to. Some things that still need to be done:; 1. Not sure of the proper citation(s) to use for `DeardorffSmagorinsky`. @glwagner; 2. Will wait for PR #409 before I write docstrings for `fields.jl`.; 3. While not part of the public user API, I'll write docstrings for the time stepping kernels as I think they'll prove to be valuable.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/410
https://github.com/CliMA/Oceananigans.jl/pull/411:836,Modifiability,extend,extends,836,"This PR makes `model.diagnostics` and `model.output_writers` into `OrderedDict`s by default. In addition, we add functionality that preserves the existing behavior: when the user calls `push!(model.diagnostics, new_diagnostic)`, the diagnostic `new_diagnostic` is given a default name (something like `:diag1`). In addition, the diagnostics can be accessed by index (an integer) or by name (assumed to be a `Symbol`, though in principle anything except an integer might be used). Giving names to diagnostics should prove useful for saving `Timeseries` diagnostics, or accessing the value of a diagnostic for logging / other purposes. We use `OrderedDict` so that the diagnostics and output writers are executed in the order they were inserted, which is a potentially useful feature for interdependent diagnostics. We also add code that extends the functionality of `Timeseries` so that the user may pass a `NamedTuple` of timeseries, eg:. ```julia; cfl_timeseries = Timeseries((adv=AdvectiveCFL(dt), diff=DiffusiveCFL(dt)), frequency=1); model.diagnostics[:timeseries] = cfl_timeseries; ```. The sampled values would then be stored in `cfl_timeseries.data.adv` and `cfl_timeseries.data.diff`. By extending `getproperty`, we also provide syntax such that. ```julia; cfl_timeseries.adv; ```. returns the array `cfl_timeseries.data.adv`, for user convenience. As for ""non-tupled"" diagnostics, the samples in `cfl_timeseries.data.adv` can be plotted alongside `cfl_timeseries.time`. Resolves #362.; Resolves #361.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/411
https://github.com/CliMA/Oceananigans.jl/pull/411:1196,Modifiability,extend,extending,1196,"This PR makes `model.diagnostics` and `model.output_writers` into `OrderedDict`s by default. In addition, we add functionality that preserves the existing behavior: when the user calls `push!(model.diagnostics, new_diagnostic)`, the diagnostic `new_diagnostic` is given a default name (something like `:diag1`). In addition, the diagnostics can be accessed by index (an integer) or by name (assumed to be a `Symbol`, though in principle anything except an integer might be used). Giving names to diagnostics should prove useful for saving `Timeseries` diagnostics, or accessing the value of a diagnostic for logging / other purposes. We use `OrderedDict` so that the diagnostics and output writers are executed in the order they were inserted, which is a potentially useful feature for interdependent diagnostics. We also add code that extends the functionality of `Timeseries` so that the user may pass a `NamedTuple` of timeseries, eg:. ```julia; cfl_timeseries = Timeseries((adv=AdvectiveCFL(dt), diff=DiffusiveCFL(dt)), frequency=1); model.diagnostics[:timeseries] = cfl_timeseries; ```. The sampled values would then be stored in `cfl_timeseries.data.adv` and `cfl_timeseries.data.diff`. By extending `getproperty`, we also provide syntax such that. ```julia; cfl_timeseries.adv; ```. returns the array `cfl_timeseries.data.adv`, for user convenience. As for ""non-tupled"" diagnostics, the samples in `cfl_timeseries.data.adv` can be plotted alongside `cfl_timeseries.time`. Resolves #362.; Resolves #361.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/411
https://github.com/CliMA/Oceananigans.jl/pull/411:348,Security,access,accessed,348,"This PR makes `model.diagnostics` and `model.output_writers` into `OrderedDict`s by default. In addition, we add functionality that preserves the existing behavior: when the user calls `push!(model.diagnostics, new_diagnostic)`, the diagnostic `new_diagnostic` is given a default name (something like `:diag1`). In addition, the diagnostics can be accessed by index (an integer) or by name (assumed to be a `Symbol`, though in principle anything except an integer might be used). Giving names to diagnostics should prove useful for saving `Timeseries` diagnostics, or accessing the value of a diagnostic for logging / other purposes. We use `OrderedDict` so that the diagnostics and output writers are executed in the order they were inserted, which is a potentially useful feature for interdependent diagnostics. We also add code that extends the functionality of `Timeseries` so that the user may pass a `NamedTuple` of timeseries, eg:. ```julia; cfl_timeseries = Timeseries((adv=AdvectiveCFL(dt), diff=DiffusiveCFL(dt)), frequency=1); model.diagnostics[:timeseries] = cfl_timeseries; ```. The sampled values would then be stored in `cfl_timeseries.data.adv` and `cfl_timeseries.data.diff`. By extending `getproperty`, we also provide syntax such that. ```julia; cfl_timeseries.adv; ```. returns the array `cfl_timeseries.data.adv`, for user convenience. As for ""non-tupled"" diagnostics, the samples in `cfl_timeseries.data.adv` can be plotted alongside `cfl_timeseries.time`. Resolves #362.; Resolves #361.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/411
https://github.com/CliMA/Oceananigans.jl/pull/411:568,Security,access,accessing,568,"This PR makes `model.diagnostics` and `model.output_writers` into `OrderedDict`s by default. In addition, we add functionality that preserves the existing behavior: when the user calls `push!(model.diagnostics, new_diagnostic)`, the diagnostic `new_diagnostic` is given a default name (something like `:diag1`). In addition, the diagnostics can be accessed by index (an integer) or by name (assumed to be a `Symbol`, though in principle anything except an integer might be used). Giving names to diagnostics should prove useful for saving `Timeseries` diagnostics, or accessing the value of a diagnostic for logging / other purposes. We use `OrderedDict` so that the diagnostics and output writers are executed in the order they were inserted, which is a potentially useful feature for interdependent diagnostics. We also add code that extends the functionality of `Timeseries` so that the user may pass a `NamedTuple` of timeseries, eg:. ```julia; cfl_timeseries = Timeseries((adv=AdvectiveCFL(dt), diff=DiffusiveCFL(dt)), frequency=1); model.diagnostics[:timeseries] = cfl_timeseries; ```. The sampled values would then be stored in `cfl_timeseries.data.adv` and `cfl_timeseries.data.diff`. By extending `getproperty`, we also provide syntax such that. ```julia; cfl_timeseries.adv; ```. returns the array `cfl_timeseries.data.adv`, for user convenience. As for ""non-tupled"" diagnostics, the samples in `cfl_timeseries.data.adv` can be plotted alongside `cfl_timeseries.time`. Resolves #362.; Resolves #361.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/411
https://github.com/CliMA/Oceananigans.jl/pull/411:608,Testability,log,logging,608,"This PR makes `model.diagnostics` and `model.output_writers` into `OrderedDict`s by default. In addition, we add functionality that preserves the existing behavior: when the user calls `push!(model.diagnostics, new_diagnostic)`, the diagnostic `new_diagnostic` is given a default name (something like `:diag1`). In addition, the diagnostics can be accessed by index (an integer) or by name (assumed to be a `Symbol`, though in principle anything except an integer might be used). Giving names to diagnostics should prove useful for saving `Timeseries` diagnostics, or accessing the value of a diagnostic for logging / other purposes. We use `OrderedDict` so that the diagnostics and output writers are executed in the order they were inserted, which is a potentially useful feature for interdependent diagnostics. We also add code that extends the functionality of `Timeseries` so that the user may pass a `NamedTuple` of timeseries, eg:. ```julia; cfl_timeseries = Timeseries((adv=AdvectiveCFL(dt), diff=DiffusiveCFL(dt)), frequency=1); model.diagnostics[:timeseries] = cfl_timeseries; ```. The sampled values would then be stored in `cfl_timeseries.data.adv` and `cfl_timeseries.data.diff`. By extending `getproperty`, we also provide syntax such that. ```julia; cfl_timeseries.adv; ```. returns the array `cfl_timeseries.data.adv`, for user convenience. As for ""non-tupled"" diagnostics, the samples in `cfl_timeseries.data.adv` can be plotted alongside `cfl_timeseries.time`. Resolves #362.; Resolves #361.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/411
https://github.com/CliMA/Oceananigans.jl/pull/412:26,Integrability,interface,interface,26,"This PR rewrites the user interface for specifying rotation rates and buoyancy parameters, such as gravitational acceleration, and the relationship between tracers and density via an equation of state. The main purpose of this PR is to move towards a more logical, functionality-driven encapsulation of parameters. . For rotation, this PR defines a new type called `AbstractRotation` whose subtypes are intended to describe parameters related to the background rotation rate of the model. At the moment there is only one such type: `VerticalRotationAxis`, or `FPlane`. In the future we expect to have `BetaPlane` and `TiltedRotationAxis` or `FullCoriolis`. The `AbstractRotation` types are uniquely associated with a function that computes the x, y, and z components of ""f X U"", associated with the background vorticity `f`. For density, equations of state, and buoyancy, a new abstract type `AbstractBuoyancy` is defined. This type is intended to encapsulate both a gravitational acceleration parameter (when applicable), and an equation of state that contains parameters associated with the relationship between tracer values and density. The advantage of this design is that parameters logically associated with certain terms in the equation of motion are now associated with a particular abstract type. This permits an easy extension of the rotational of buoyancy/equation of state models currently contained in the code; for example in the future we hope to support a `TracerBuoyancy` type for the case that buoyancy is itself a tracer and gravitational acceleration is no longer a parameter, and perhaps a `TemperatureBuoyancy` type for the case that only temperature contributes to buoyancy, rather than both temperature and salinity as is currently the case. In addition, our hydrostatic and non-hydrostatic pressure fields now have the same units and can be directly summed to obtain the total pressure. Resolves #191.; Resolves #217.; Resolves #403.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/412
https://github.com/CliMA/Oceananigans.jl/pull/412:8,Modifiability,rewrite,rewrites,8,"This PR rewrites the user interface for specifying rotation rates and buoyancy parameters, such as gravitational acceleration, and the relationship between tracers and density via an equation of state. The main purpose of this PR is to move towards a more logical, functionality-driven encapsulation of parameters. . For rotation, this PR defines a new type called `AbstractRotation` whose subtypes are intended to describe parameters related to the background rotation rate of the model. At the moment there is only one such type: `VerticalRotationAxis`, or `FPlane`. In the future we expect to have `BetaPlane` and `TiltedRotationAxis` or `FullCoriolis`. The `AbstractRotation` types are uniquely associated with a function that computes the x, y, and z components of ""f X U"", associated with the background vorticity `f`. For density, equations of state, and buoyancy, a new abstract type `AbstractBuoyancy` is defined. This type is intended to encapsulate both a gravitational acceleration parameter (when applicable), and an equation of state that contains parameters associated with the relationship between tracer values and density. The advantage of this design is that parameters logically associated with certain terms in the equation of motion are now associated with a particular abstract type. This permits an easy extension of the rotational of buoyancy/equation of state models currently contained in the code; for example in the future we hope to support a `TracerBuoyancy` type for the case that buoyancy is itself a tracer and gravitational acceleration is no longer a parameter, and perhaps a `TemperatureBuoyancy` type for the case that only temperature contributes to buoyancy, rather than both temperature and salinity as is currently the case. In addition, our hydrostatic and non-hydrostatic pressure fields now have the same units and can be directly summed to obtain the total pressure. Resolves #191.; Resolves #217.; Resolves #403.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/412
https://github.com/CliMA/Oceananigans.jl/pull/412:256,Testability,log,logical,256,"This PR rewrites the user interface for specifying rotation rates and buoyancy parameters, such as gravitational acceleration, and the relationship between tracers and density via an equation of state. The main purpose of this PR is to move towards a more logical, functionality-driven encapsulation of parameters. . For rotation, this PR defines a new type called `AbstractRotation` whose subtypes are intended to describe parameters related to the background rotation rate of the model. At the moment there is only one such type: `VerticalRotationAxis`, or `FPlane`. In the future we expect to have `BetaPlane` and `TiltedRotationAxis` or `FullCoriolis`. The `AbstractRotation` types are uniquely associated with a function that computes the x, y, and z components of ""f X U"", associated with the background vorticity `f`. For density, equations of state, and buoyancy, a new abstract type `AbstractBuoyancy` is defined. This type is intended to encapsulate both a gravitational acceleration parameter (when applicable), and an equation of state that contains parameters associated with the relationship between tracer values and density. The advantage of this design is that parameters logically associated with certain terms in the equation of motion are now associated with a particular abstract type. This permits an easy extension of the rotational of buoyancy/equation of state models currently contained in the code; for example in the future we hope to support a `TracerBuoyancy` type for the case that buoyancy is itself a tracer and gravitational acceleration is no longer a parameter, and perhaps a `TemperatureBuoyancy` type for the case that only temperature contributes to buoyancy, rather than both temperature and salinity as is currently the case. In addition, our hydrostatic and non-hydrostatic pressure fields now have the same units and can be directly summed to obtain the total pressure. Resolves #191.; Resolves #217.; Resolves #403.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/412
https://github.com/CliMA/Oceananigans.jl/pull/412:1189,Testability,log,logically,1189,"This PR rewrites the user interface for specifying rotation rates and buoyancy parameters, such as gravitational acceleration, and the relationship between tracers and density via an equation of state. The main purpose of this PR is to move towards a more logical, functionality-driven encapsulation of parameters. . For rotation, this PR defines a new type called `AbstractRotation` whose subtypes are intended to describe parameters related to the background rotation rate of the model. At the moment there is only one such type: `VerticalRotationAxis`, or `FPlane`. In the future we expect to have `BetaPlane` and `TiltedRotationAxis` or `FullCoriolis`. The `AbstractRotation` types are uniquely associated with a function that computes the x, y, and z components of ""f X U"", associated with the background vorticity `f`. For density, equations of state, and buoyancy, a new abstract type `AbstractBuoyancy` is defined. This type is intended to encapsulate both a gravitational acceleration parameter (when applicable), and an equation of state that contains parameters associated with the relationship between tracer values and density. The advantage of this design is that parameters logically associated with certain terms in the equation of motion are now associated with a particular abstract type. This permits an easy extension of the rotational of buoyancy/equation of state models currently contained in the code; for example in the future we hope to support a `TracerBuoyancy` type for the case that buoyancy is itself a tracer and gravitational acceleration is no longer a parameter, and perhaps a `TemperatureBuoyancy` type for the case that only temperature contributes to buoyancy, rather than both temperature and salinity as is currently the case. In addition, our hydrostatic and non-hydrostatic pressure fields now have the same units and can be directly summed to obtain the total pressure. Resolves #191.; Resolves #217.; Resolves #403.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/412
https://github.com/CliMA/Oceananigans.jl/issues/416:7,Energy Efficiency,allocate,allocate,7,(Don't allocate more GPU memory than needed.),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/416
https://github.com/CliMA/Oceananigans.jl/issues/417:15,Availability,Checkpoint,Checkpointer,15,"Right now the `Checkpointer docstring says. ```; Note that extra model `properties` can be safely specified, but removing; crucial properties such as `:velocities` will make restoring from the; checkpoint impossible.; ```. Would be good to print a warning if something crucial is missing from `properties`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/417
https://github.com/CliMA/Oceananigans.jl/issues/417:194,Availability,checkpoint,checkpoint,194,"Right now the `Checkpointer docstring says. ```; Note that extra model `properties` can be safely specified, but removing; crucial properties such as `:velocities` will make restoring from the; checkpoint impossible.; ```. Would be good to print a warning if something crucial is missing from `properties`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/417
https://github.com/CliMA/Oceananigans.jl/issues/417:91,Safety,safe,safely,91,"Right now the `Checkpointer docstring says. ```; Note that extra model `properties` can be safely specified, but removing; crucial properties such as `:velocities` will make restoring from the; checkpoint impossible.; ```. Would be good to print a warning if something crucial is missing from `properties`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/417
https://github.com/CliMA/Oceananigans.jl/issues/420:10,Availability,ERROR,ERROR,10,```julia; ERROR: LoadError: cannot write a pointer to JLD file; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/420
https://github.com/CliMA/Oceananigans.jl/issues/420:17,Performance,Load,LoadError,17,```julia; ERROR: LoadError: cannot write a pointer to JLD file; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/420
https://github.com/CliMA/Oceananigans.jl/pull/424:224,Modifiability,variab,variable,224,"Cherry picked some commits from PR #381 to fix the example test. One thing that's going to be annoying about testing example scripts is that they evaluate in global scope when including them, so it's going to be easy to get variable name conflicts... Not sure how to get around this as we agreed not to use functions for examples.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/424
https://github.com/CliMA/Oceananigans.jl/pull/424:59,Testability,test,test,59,"Cherry picked some commits from PR #381 to fix the example test. One thing that's going to be annoying about testing example scripts is that they evaluate in global scope when including them, so it's going to be easy to get variable name conflicts... Not sure how to get around this as we agreed not to use functions for examples.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/424
https://github.com/CliMA/Oceananigans.jl/pull/424:109,Testability,test,testing,109,"Cherry picked some commits from PR #381 to fix the example test. One thing that's going to be annoying about testing example scripts is that they evaluate in global scope when including them, so it's going to be easy to get variable name conflicts... Not sure how to get around this as we agreed not to use functions for examples.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/424
https://github.com/CliMA/Oceananigans.jl/pull/425:34,Testability,test,tests,34,"This PR adds a bunch of examples, tests them, and writes them so that `Literate.jl` can be used to generate markdown files from them. . In the future, we can add these markdown files to the documentation. Examples that might be good to add to ~~this~~ a future PR:. - 2D convection into a stratified fluid with ""phytoplankton-like"" tracer: demonstrates forcing functions, nice boundary conditions, etc; - 2D Kelvin-Helmholtz instability: just a simple but interesting stratified example; - Stratified Couette flow example: nice 3D example with `Value` boundary conditions. Also: . - [x] Clean up and simplify deepening mixed layer example: should become a good 3D example; perhaps merge into single 'case' including forcing by both wind and unstable buoyancy forcing",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/425
https://github.com/CliMA/Oceananigans.jl/pull/425:445,Usability,simpl,simple,445,"This PR adds a bunch of examples, tests them, and writes them so that `Literate.jl` can be used to generate markdown files from them. . In the future, we can add these markdown files to the documentation. Examples that might be good to add to ~~this~~ a future PR:. - 2D convection into a stratified fluid with ""phytoplankton-like"" tracer: demonstrates forcing functions, nice boundary conditions, etc; - 2D Kelvin-Helmholtz instability: just a simple but interesting stratified example; - Stratified Couette flow example: nice 3D example with `Value` boundary conditions. Also: . - [x] Clean up and simplify deepening mixed layer example: should become a good 3D example; perhaps merge into single 'case' including forcing by both wind and unstable buoyancy forcing",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/425
https://github.com/CliMA/Oceananigans.jl/pull/425:600,Usability,simpl,simplify,600,"This PR adds a bunch of examples, tests them, and writes them so that `Literate.jl` can be used to generate markdown files from them. . In the future, we can add these markdown files to the documentation. Examples that might be good to add to ~~this~~ a future PR:. - 2D convection into a stratified fluid with ""phytoplankton-like"" tracer: demonstrates forcing functions, nice boundary conditions, etc; - 2D Kelvin-Helmholtz instability: just a simple but interesting stratified example; - Stratified Couette flow example: nice 3D example with `Value` boundary conditions. Also: . - [x] Clean up and simplify deepening mixed layer example: should become a good 3D example; perhaps merge into single 'case' including forcing by both wind and unstable buoyancy forcing",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/425
https://github.com/CliMA/Oceananigans.jl/issues/428:250,Deployability,integrat,integrate,250,"We need a diagnostic to compute the horizontal average of terms like `K * dT/dz` which can't be done with the existing `HorizontalAverage` diagnostic. I have an implementation that needs to be polished up, and may take a bit of thought if we want to integrate it with the existing diagnostics:; https://github.com/ali-ramadhan/seasonal-cycle-mixed-layers/blob/6e9834000561bdbbbcb9812e87f8dbdd876e48b0/simulation/deepening_mixed_layer.jl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/428
https://github.com/CliMA/Oceananigans.jl/issues/428:250,Integrability,integrat,integrate,250,"We need a diagnostic to compute the horizontal average of terms like `K * dT/dz` which can't be done with the existing `HorizontalAverage` diagnostic. I have an implementation that needs to be polished up, and may take a bit of thought if we want to integrate it with the existing diagnostics:; https://github.com/ali-ramadhan/seasonal-cycle-mixed-layers/blob/6e9834000561bdbbbcb9812e87f8dbdd876e48b0/simulation/deepening_mixed_layer.jl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/428
https://github.com/CliMA/Oceananigans.jl/issues/428:348,Modifiability,layers,layers,348,"We need a diagnostic to compute the horizontal average of terms like `K * dT/dz` which can't be done with the existing `HorizontalAverage` diagnostic. I have an implementation that needs to be polished up, and may take a bit of thought if we want to integrate it with the existing diagnostics:; https://github.com/ali-ramadhan/seasonal-cycle-mixed-layers/blob/6e9834000561bdbbbcb9812e87f8dbdd876e48b0/simulation/deepening_mixed_layer.jl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/428
https://github.com/CliMA/Oceananigans.jl/issues/429:214,Modifiability,refactor,refactoring,214,"I think we need a PR focused on cleaning up some of the legacy constructors out there before the code gets used by others. In particular I'd like to work on #413 (currently on the `grid-xyz` branch) which involves refactoring the `RegularCartesianGrid` constructor and I'd rather not leave behind three legacy constructors. Also, I'm not a fan of the `BasicModel` constructor. I understand it was introduced to avoid refactoring all the `Model` constructors, but would be nice to get rid of it.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/429
https://github.com/CliMA/Oceananigans.jl/issues/429:417,Modifiability,refactor,refactoring,417,"I think we need a PR focused on cleaning up some of the legacy constructors out there before the code gets used by others. In particular I'd like to work on #413 (currently on the `grid-xyz` branch) which involves refactoring the `RegularCartesianGrid` constructor and I'd rather not leave behind three legacy constructors. Also, I'm not a fan of the `BasicModel` constructor. I understand it was introduced to avoid refactoring all the `Model` constructors, but would be nice to get rid of it.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/429
https://github.com/CliMA/Oceananigans.jl/issues/429:411,Safety,avoid,avoid,411,"I think we need a PR focused on cleaning up some of the legacy constructors out there before the code gets used by others. In particular I'd like to work on #413 (currently on the `grid-xyz` branch) which involves refactoring the `RegularCartesianGrid` constructor and I'd rather not leave behind three legacy constructors. Also, I'm not a fan of the `BasicModel` constructor. I understand it was introduced to avoid refactoring all the `Model` constructors, but would be nice to get rid of it.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/429
https://github.com/CliMA/Oceananigans.jl/issues/432:480,Deployability,update,updates,480,"Instead of having us manually print a progress statement in a `while` loop, maybe we can pass a `progress_message(model)` function to `time_step!` that does this. This should help clean up the scripts a lot, and we could provide a couple of reasonable defaults instead of setting up this functionality in every script. Eventually the `progress_message(model)` function can be made fancy as we wish with unicode plots, a curses interface for complex progress output, or even email updates.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/432
https://github.com/CliMA/Oceananigans.jl/issues/432:427,Integrability,interface,interface,427,"Instead of having us manually print a progress statement in a `while` loop, maybe we can pass a `progress_message(model)` function to `time_step!` that does this. This should help clean up the scripts a lot, and we could provide a couple of reasonable defaults instead of setting up this functionality in every script. Eventually the `progress_message(model)` function can be made fancy as we wish with unicode plots, a curses interface for complex progress output, or even email updates.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/432
https://github.com/CliMA/Oceananigans.jl/pull/433:320,Modifiability,variab,variable,320,- Uses NCDatasets.jl; - Allows slicing; - Should be fast because a new file is not created for every output time-step (I guess the previous netcdf writer was slow because it created a new file for every output time-step which added a lot of overhead); - See example for usage (it works on CPU!). TODO:; - Global and per variable attributes. Edit:; - Needs to be tested; - We need to discuss halo regions (the dimension lengths are not consistent with the array sizes thanks to halo regions),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/433
https://github.com/CliMA/Oceananigans.jl/pull/433:362,Testability,test,tested,362,- Uses NCDatasets.jl; - Allows slicing; - Should be fast because a new file is not created for every output time-step (I guess the previous netcdf writer was slow because it created a new file for every output time-step which added a lot of overhead); - See example for usage (it works on CPU!). TODO:; - Global and per variable attributes. Edit:; - Needs to be tested; - We need to discuss halo regions (the dimension lengths are not consistent with the array sizes thanks to halo regions),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/433
https://github.com/CliMA/Oceananigans.jl/pull/436:162,Usability,guid,guide,162,"For JOSS we need to have a helpful `CONTRIBUTING.md` file, and I thought it would be good to put one up for Hacktoberfest. I'm a big fan of MetPy's contributor's guide so I heavily based it on theirs, I don't think I could have done a better job. MetPy uses a [BSD-3-Clause](https://tldrlegal.com/license/bsd-3-clause-license-(revised)) license so I think this means we'd have to license our `CONTRIBUTING.md` file under BSD-3-Clause? @christophernhill is this an issue?. cc MetPy devs @dopplershift @jrleeman: Your MetPy contributor's guide is really excellent! I hope you don't mind if I borrowed heavily from it.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/436
https://github.com/CliMA/Oceananigans.jl/pull/436:536,Usability,guid,guide,536,"For JOSS we need to have a helpful `CONTRIBUTING.md` file, and I thought it would be good to put one up for Hacktoberfest. I'm a big fan of MetPy's contributor's guide so I heavily based it on theirs, I don't think I could have done a better job. MetPy uses a [BSD-3-Clause](https://tldrlegal.com/license/bsd-3-clause-license-(revised)) license so I think this means we'd have to license our `CONTRIBUTING.md` file under BSD-3-Clause? @christophernhill is this an issue?. cc MetPy devs @dopplershift @jrleeman: Your MetPy contributor's guide is really excellent! I hope you don't mind if I borrowed heavily from it.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/436
https://github.com/CliMA/Oceananigans.jl/issues/439:596,Integrability,contract,contraction,596,"@jm-c suggested that we want a function that returns the density perturbation associated with scalar values of temperature and salinity. Right now we only have a function that returns the density perturbation for 3D arrays of temperature and salinity, eg:. https://github.com/climate-machine/Oceananigans.jl/blob/d32cf2035184f2320b27f270aee90e4688cf290f/src/buoyancy.jl#L228. @jm-c also recommends calculating the buoyancy frequency directly from the buoyancy distribution. This is different than the recommendation by Roquet et al (Ocean Modelling, 2015) to use the thermal expansion and haline contraction coefficients.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/439
https://github.com/CliMA/Oceananigans.jl/issues/441:11,Modifiability,extend,extend,11,"We need to extend our verification tests for the AMD closure to compare results for all turbulence closures we have implemented. As of now, the only turbulence closure implemented is `SmagorinskyLilly`. When #440 is resolved we can compare to the Vreman closure as well. This applies to . * Stratified Couette flow verification; * free convection verification; * Kato-Phillips verification. ref #81 and #381 . cc @tapios",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/441
https://github.com/CliMA/Oceananigans.jl/issues/441:35,Testability,test,tests,35,"We need to extend our verification tests for the AMD closure to compare results for all turbulence closures we have implemented. As of now, the only turbulence closure implemented is `SmagorinskyLilly`. When #440 is resolved we can compare to the Vreman closure as well. This applies to . * Stratified Couette flow verification; * free convection verification; * Kato-Phillips verification. ref #81 and #381 . cc @tapios",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/441
https://github.com/CliMA/Oceananigans.jl/issues/442:207,Energy Efficiency,reduce,reduce,207,"At the GPU hackathon way back in June we learned that the `calculate_interior_source_terms` kernel was a bottleneck as each thread required a lot of registers. It could benefit greatly from shared memory to reduce register pressure and allow more threads to run at a time. Some preliminary work has been done in PR https://github.com/climate-machine/Oceananigans.jl/pull/293. @vchuravy has an `@stencil` abstraction in development at https://github.com/vchuravy/GPUifyLoops.jl/pull/81. But would be good to implement plain shared memory without an abstraction and see how much of a performance boost we get, especially with LES closures.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/442
https://github.com/CliMA/Oceananigans.jl/issues/442:105,Performance,bottleneck,bottleneck,105,"At the GPU hackathon way back in June we learned that the `calculate_interior_source_terms` kernel was a bottleneck as each thread required a lot of registers. It could benefit greatly from shared memory to reduce register pressure and allow more threads to run at a time. Some preliminary work has been done in PR https://github.com/climate-machine/Oceananigans.jl/pull/293. @vchuravy has an `@stencil` abstraction in development at https://github.com/vchuravy/GPUifyLoops.jl/pull/81. But would be good to implement plain shared memory without an abstraction and see how much of a performance boost we get, especially with LES closures.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/442
https://github.com/CliMA/Oceananigans.jl/issues/442:582,Performance,perform,performance,582,"At the GPU hackathon way back in June we learned that the `calculate_interior_source_terms` kernel was a bottleneck as each thread required a lot of registers. It could benefit greatly from shared memory to reduce register pressure and allow more threads to run at a time. Some preliminary work has been done in PR https://github.com/climate-machine/Oceananigans.jl/pull/293. @vchuravy has an `@stencil` abstraction in development at https://github.com/vchuravy/GPUifyLoops.jl/pull/81. But would be good to implement plain shared memory without an abstraction and see how much of a performance boost we get, especially with LES closures.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/442
https://github.com/CliMA/Oceananigans.jl/issues/442:41,Usability,learn,learned,41,"At the GPU hackathon way back in June we learned that the `calculate_interior_source_terms` kernel was a bottleneck as each thread required a lot of registers. It could benefit greatly from shared memory to reduce register pressure and allow more threads to run at a time. Some preliminary work has been done in PR https://github.com/climate-machine/Oceananigans.jl/pull/293. @vchuravy has an `@stencil` abstraction in development at https://github.com/vchuravy/GPUifyLoops.jl/pull/81. But would be good to implement plain shared memory without an abstraction and see how much of a performance boost we get, especially with LES closures.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/442
https://github.com/CliMA/Oceananigans.jl/issues/443:1239,Energy Efficiency,energy,energy,1239,"eraged' effects of surface waves on near-surface motions. I propose that we use the Lagrangian-mean interpretation for our velocity field in adding this term, rather than an Eulerian-mean interpretation. The Lagrangian-mean interpretation has the advantage of . 1. Avoiding ""accidental"" initialization of large near-inertial oscillations due to initial conditions that are out of equilibrium with the surface wave field (eg the initial conditions in [McWilliams et al 1997](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/langmuir-turbulence-in-the-ocean/638FD0E368140E5972144348DB930A38));. 2. Requiring the least modification of physics, since we have to only introduce two terms (or just one for steady surface wave fields) to the momentum equations (as opposed to two terms in the momentum equations and one term in the tracer equations in the Eulerian-mean formulation);. 3. Arguably using the Lagrangian-mean interpretation means we can avoid modifying our subgrid turbulence closure, since surface wave terms do not affect the turbulent kinetic energy balance;. 4. The pressure field retains its original interpretation. The surface wave field interacts with interior dynamics through its Stokes drift field, which is generally prescribed to boundary layer LES. To implement the surface wave term in the Lagrangian-mean formulation, we require gradients of the Stokes drift velocity associated with the surface wave field. To start the best way to implement this, at least to start, is through functions. This might look something like. ```julia; u_stokes(x, y, z, t) = U * exp(2*k*z). model = Model(stokes_drift=StokesDrift(u=u_stokes), ... ); ```. In this pattern, we have to take gradients of the function `u_stokes` either numerically or analytically (?) . Alternatively, we can ask users to supply the gradients of the Stokes drift of the surface wave field, though this is a bit more complicated and requires more inputs if the Stokes drift varies along coordin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/443
https://github.com/CliMA/Oceananigans.jl/issues/443:425,Safety,Avoid,Avoiding,425,"Eventually, we will need to represent the effects of surface waves in `Oceananigans.jl`. The best way to do that is to introduce a term that models the 'wave-averaged' effects of surface waves on near-surface motions. I propose that we use the Lagrangian-mean interpretation for our velocity field in adding this term, rather than an Eulerian-mean interpretation. The Lagrangian-mean interpretation has the advantage of . 1. Avoiding ""accidental"" initialization of large near-inertial oscillations due to initial conditions that are out of equilibrium with the surface wave field (eg the initial conditions in [McWilliams et al 1997](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/langmuir-turbulence-in-the-ocean/638FD0E368140E5972144348DB930A38));. 2. Requiring the least modification of physics, since we have to only introduce two terms (or just one for steady surface wave fields) to the momentum equations (as opposed to two terms in the momentum equations and one term in the tracer equations in the Eulerian-mean formulation);. 3. Arguably using the Lagrangian-mean interpretation means we can avoid modifying our subgrid turbulence closure, since surface wave terms do not affect the turbulent kinetic energy balance;. 4. The pressure field retains its original interpretation. The surface wave field interacts with interior dynamics through its Stokes drift field, which is generally prescribed to boundary layer LES. To implement the surface wave term in the Lagrangian-mean formulation, we require gradients of the Stokes drift velocity associated with the surface wave field. To start the best way to implement this, at least to start, is through functions. This might look something like. ```julia; u_stokes(x, y, z, t) = U * exp(2*k*z). model = Model(stokes_drift=StokesDrift(u=u_stokes), ... ); ```. In this pattern, we have to take gradients of the function `u_stokes` either numerically or analytically (?) . Alternatively, we can ask users to supply the ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/443
https://github.com/CliMA/Oceananigans.jl/issues/443:1130,Safety,avoid,avoid,1130,"eraged' effects of surface waves on near-surface motions. I propose that we use the Lagrangian-mean interpretation for our velocity field in adding this term, rather than an Eulerian-mean interpretation. The Lagrangian-mean interpretation has the advantage of . 1. Avoiding ""accidental"" initialization of large near-inertial oscillations due to initial conditions that are out of equilibrium with the surface wave field (eg the initial conditions in [McWilliams et al 1997](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/langmuir-turbulence-in-the-ocean/638FD0E368140E5972144348DB930A38));. 2. Requiring the least modification of physics, since we have to only introduce two terms (or just one for steady surface wave fields) to the momentum equations (as opposed to two terms in the momentum equations and one term in the tracer equations in the Eulerian-mean formulation);. 3. Arguably using the Lagrangian-mean interpretation means we can avoid modifying our subgrid turbulence closure, since surface wave terms do not affect the turbulent kinetic energy balance;. 4. The pressure field retains its original interpretation. The surface wave field interacts with interior dynamics through its Stokes drift field, which is generally prescribed to boundary layer LES. To implement the surface wave term in the Lagrangian-mean formulation, we require gradients of the Stokes drift velocity associated with the surface wave field. To start the best way to implement this, at least to start, is through functions. This might look something like. ```julia; u_stokes(x, y, z, t) = U * exp(2*k*z). model = Model(stokes_drift=StokesDrift(u=u_stokes), ... ); ```. In this pattern, we have to take gradients of the function `u_stokes` either numerically or analytically (?) . Alternatively, we can ask users to supply the gradients of the Stokes drift of the surface wave field, though this is a bit more complicated and requires more inputs if the Stokes drift varies along coordin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/443
https://github.com/CliMA/Oceananigans.jl/issues/443:2269,Security,validat,validate,2269,"cs, since we have to only introduce two terms (or just one for steady surface wave fields) to the momentum equations (as opposed to two terms in the momentum equations and one term in the tracer equations in the Eulerian-mean formulation);. 3. Arguably using the Lagrangian-mean interpretation means we can avoid modifying our subgrid turbulence closure, since surface wave terms do not affect the turbulent kinetic energy balance;. 4. The pressure field retains its original interpretation. The surface wave field interacts with interior dynamics through its Stokes drift field, which is generally prescribed to boundary layer LES. To implement the surface wave term in the Lagrangian-mean formulation, we require gradients of the Stokes drift velocity associated with the surface wave field. To start the best way to implement this, at least to start, is through functions. This might look something like. ```julia; u_stokes(x, y, z, t) = U * exp(2*k*z). model = Model(stokes_drift=StokesDrift(u=u_stokes), ... ); ```. In this pattern, we have to take gradients of the function `u_stokes` either numerically or analytically (?) . Alternatively, we can ask users to supply the gradients of the Stokes drift of the surface wave field, though this is a bit more complicated and requires more inputs if the Stokes drift varies along coordinates other than `z`. We can either call the new field `model.stokes_drift` or `model.surface_waves`. We can validate our implementation by reproducing results in [McWilliams et al (1997)](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/langmuir-turbulence-in-the-ocean/638FD0E368140E5972144348DB930A38), [Polton and Belcher (2007)](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2007JC004205), and [Skyllingstad and Denbo (1995)](https://agupubs.onlinelibrary.wiley.com/doi/abs/10.1029/94JC03202?casa_token=EqggenV30loAAAAA:Qu8czM4PvMqLP486Ma1BUZen0CPIuGZgyVDXrIoYnopbmOUDzbwwmH1BiftvEvIpzuV1_l9J6LgXkGE). cc @johncmarshall54",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/443
https://github.com/CliMA/Oceananigans.jl/pull/444:546,Security,validat,validating,546,"This PR changes the name of the `Forcing` constructor to `ModelForcing` to clarify the difference between constructors for forcing objects on single fields, and constructors for the `NamedTuple` of forcing objects for all model fields. It also conventionalizes the name of the fields in `ModelForcing`, so that . ```julia; forcing = ModelForcing(u=u_forcing); ```. is used to apply the forcing function `u_forcing` to `u`. . In addition it adds a new type ""`SimpleForcing`"", which permits users to pass functions of `x`, `y`, `z`, and `t`. A few validating lines in the `ModelForcing` constructor ensure that forcing functions for `u`, `v`, and `w` are applied at the correct locations. For example, we can now write. ```julia; T_forcing = SimpleForcing((x, y, z, t) -> exp(z) * cos(t)). model = Model(forcing=ModelForcing(T=T_forcing)); ```; To create a forcing on temperature that decays exponentially in z and oscillates in time. To test this functionality, this PR introduces an example ""`ocean_convection_with_plankton`"" that uses `SimpleForcing` to model the growth and decay of a plankton-like tracer.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/444
https://github.com/CliMA/Oceananigans.jl/pull/444:936,Testability,test,test,936,"This PR changes the name of the `Forcing` constructor to `ModelForcing` to clarify the difference between constructors for forcing objects on single fields, and constructors for the `NamedTuple` of forcing objects for all model fields. It also conventionalizes the name of the fields in `ModelForcing`, so that . ```julia; forcing = ModelForcing(u=u_forcing); ```. is used to apply the forcing function `u_forcing` to `u`. . In addition it adds a new type ""`SimpleForcing`"", which permits users to pass functions of `x`, `y`, `z`, and `t`. A few validating lines in the `ModelForcing` constructor ensure that forcing functions for `u`, `v`, and `w` are applied at the correct locations. For example, we can now write. ```julia; T_forcing = SimpleForcing((x, y, z, t) -> exp(z) * cos(t)). model = Model(forcing=ModelForcing(T=T_forcing)); ```; To create a forcing on temperature that decays exponentially in z and oscillates in time. To test this functionality, this PR introduces an example ""`ocean_convection_with_plankton`"" that uses `SimpleForcing` to model the growth and decay of a plankton-like tracer.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/444
https://github.com/CliMA/Oceananigans.jl/pull/444:458,Usability,Simpl,SimpleForcing,458,"This PR changes the name of the `Forcing` constructor to `ModelForcing` to clarify the difference between constructors for forcing objects on single fields, and constructors for the `NamedTuple` of forcing objects for all model fields. It also conventionalizes the name of the fields in `ModelForcing`, so that . ```julia; forcing = ModelForcing(u=u_forcing); ```. is used to apply the forcing function `u_forcing` to `u`. . In addition it adds a new type ""`SimpleForcing`"", which permits users to pass functions of `x`, `y`, `z`, and `t`. A few validating lines in the `ModelForcing` constructor ensure that forcing functions for `u`, `v`, and `w` are applied at the correct locations. For example, we can now write. ```julia; T_forcing = SimpleForcing((x, y, z, t) -> exp(z) * cos(t)). model = Model(forcing=ModelForcing(T=T_forcing)); ```; To create a forcing on temperature that decays exponentially in z and oscillates in time. To test this functionality, this PR introduces an example ""`ocean_convection_with_plankton`"" that uses `SimpleForcing` to model the growth and decay of a plankton-like tracer.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/444
https://github.com/CliMA/Oceananigans.jl/pull/444:740,Usability,Simpl,SimpleForcing,740,"This PR changes the name of the `Forcing` constructor to `ModelForcing` to clarify the difference between constructors for forcing objects on single fields, and constructors for the `NamedTuple` of forcing objects for all model fields. It also conventionalizes the name of the fields in `ModelForcing`, so that . ```julia; forcing = ModelForcing(u=u_forcing); ```. is used to apply the forcing function `u_forcing` to `u`. . In addition it adds a new type ""`SimpleForcing`"", which permits users to pass functions of `x`, `y`, `z`, and `t`. A few validating lines in the `ModelForcing` constructor ensure that forcing functions for `u`, `v`, and `w` are applied at the correct locations. For example, we can now write. ```julia; T_forcing = SimpleForcing((x, y, z, t) -> exp(z) * cos(t)). model = Model(forcing=ModelForcing(T=T_forcing)); ```; To create a forcing on temperature that decays exponentially in z and oscillates in time. To test this functionality, this PR introduces an example ""`ocean_convection_with_plankton`"" that uses `SimpleForcing` to model the growth and decay of a plankton-like tracer.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/444
https://github.com/CliMA/Oceananigans.jl/pull/444:1037,Usability,Simpl,SimpleForcing,1037,"This PR changes the name of the `Forcing` constructor to `ModelForcing` to clarify the difference between constructors for forcing objects on single fields, and constructors for the `NamedTuple` of forcing objects for all model fields. It also conventionalizes the name of the fields in `ModelForcing`, so that . ```julia; forcing = ModelForcing(u=u_forcing); ```. is used to apply the forcing function `u_forcing` to `u`. . In addition it adds a new type ""`SimpleForcing`"", which permits users to pass functions of `x`, `y`, `z`, and `t`. A few validating lines in the `ModelForcing` constructor ensure that forcing functions for `u`, `v`, and `w` are applied at the correct locations. For example, we can now write. ```julia; T_forcing = SimpleForcing((x, y, z, t) -> exp(z) * cos(t)). model = Model(forcing=ModelForcing(T=T_forcing)); ```; To create a forcing on temperature that decays exponentially in z and oscillates in time. To test this functionality, this PR introduces an example ""`ocean_convection_with_plankton`"" that uses `SimpleForcing` to model the growth and decay of a plankton-like tracer.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/444
https://github.com/CliMA/Oceananigans.jl/issues/447:952,Energy Efficiency,monitor,monitoring,952,"It could be nice to have a type for managing time stepping --- eg, `Simulation` --- rather than requiring the writing of explicit loops as in . https://github.com/climate-machine/Oceananigans.jl/blob/4b7e5bced1019b1a6804d3797cfe0ed41fda4a51/examples/ocean_wind_mixing_and_convection.jl#L190. `Simulation` could look like. ```julia; struct Simulation; model; Δt; simulation_stop_time; wall_time_limit; simulation_stop_iteration; progress; end; ```. Or something along those lines. The field `progress` could either be a function or callable object, or tuple / list of functions or callable objects. The field `Δt` could either be a constant time-step or a `TimeStepWizard`. We might also need a new type called `ProgressMessage` for managing logging / emitting progress messages for simulations. Then we can give it a `frequency` (and `interval`) of emission and support some other nice behaviors like a default format and auto-emission of diagnostic / monitoring results. xref: #432 #431",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/447
https://github.com/CliMA/Oceananigans.jl/issues/447:769,Integrability,message,messages,769,"It could be nice to have a type for managing time stepping --- eg, `Simulation` --- rather than requiring the writing of explicit loops as in . https://github.com/climate-machine/Oceananigans.jl/blob/4b7e5bced1019b1a6804d3797cfe0ed41fda4a51/examples/ocean_wind_mixing_and_convection.jl#L190. `Simulation` could look like. ```julia; struct Simulation; model; Δt; simulation_stop_time; wall_time_limit; simulation_stop_iteration; progress; end; ```. Or something along those lines. The field `progress` could either be a function or callable object, or tuple / list of functions or callable objects. The field `Δt` could either be a constant time-step or a `TimeStepWizard`. We might also need a new type called `ProgressMessage` for managing logging / emitting progress messages for simulations. Then we can give it a `frequency` (and `interval`) of emission and support some other nice behaviors like a default format and auto-emission of diagnostic / monitoring results. xref: #432 #431",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/447
https://github.com/CliMA/Oceananigans.jl/issues/447:741,Testability,log,logging,741,"It could be nice to have a type for managing time stepping --- eg, `Simulation` --- rather than requiring the writing of explicit loops as in . https://github.com/climate-machine/Oceananigans.jl/blob/4b7e5bced1019b1a6804d3797cfe0ed41fda4a51/examples/ocean_wind_mixing_and_convection.jl#L190. `Simulation` could look like. ```julia; struct Simulation; model; Δt; simulation_stop_time; wall_time_limit; simulation_stop_iteration; progress; end; ```. Or something along those lines. The field `progress` could either be a function or callable object, or tuple / list of functions or callable objects. The field `Δt` could either be a constant time-step or a `TimeStepWizard`. We might also need a new type called `ProgressMessage` for managing logging / emitting progress messages for simulations. Then we can give it a `frequency` (and `interval`) of emission and support some other nice behaviors like a default format and auto-emission of diagnostic / monitoring results. xref: #432 #431",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/447
https://github.com/CliMA/Oceananigans.jl/issues/448:407,Usability,guid,guide,407,"Our time-stepping functions / kernels in `time_steppers.jl` are a bit chaotic with long argument lists, etc. To bring order to this world, it might be a good idea to adopt some kind of convention / preferred ordering to the function arguments. . Almost all of the functions are mutating, so I think the first argument(s) should be the objects that are mutated by the function. This follows the [julia style guide recommendation](https://docs.julialang.org/en/v1/manual/style-guide/index.html#Write-functions-with-argument-ordering-similar-to-Julia-Base-1). After that, the style guide doesn't offer guidance though it could make sense to put important objects for dispatch first (mostly `arch`). . The rest of the objects fall into a few categories (I think):. * grid; * parameter structs; * `NamedTuple`s of fields / arrays / boundary conditions; * scalars. Perhaps we can use an ordering along the lines of. 1. object being mutated; 2. architecture (if used); 3. grid (if used); 4. scalars; 5. parameter structs; 6. `NamedTuple`s of stuff. I'm open to other patterns too.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/448
https://github.com/CliMA/Oceananigans.jl/issues/448:475,Usability,guid,guide,475,"Our time-stepping functions / kernels in `time_steppers.jl` are a bit chaotic with long argument lists, etc. To bring order to this world, it might be a good idea to adopt some kind of convention / preferred ordering to the function arguments. . Almost all of the functions are mutating, so I think the first argument(s) should be the objects that are mutated by the function. This follows the [julia style guide recommendation](https://docs.julialang.org/en/v1/manual/style-guide/index.html#Write-functions-with-argument-ordering-similar-to-Julia-Base-1). After that, the style guide doesn't offer guidance though it could make sense to put important objects for dispatch first (mostly `arch`). . The rest of the objects fall into a few categories (I think):. * grid; * parameter structs; * `NamedTuple`s of fields / arrays / boundary conditions; * scalars. Perhaps we can use an ordering along the lines of. 1. object being mutated; 2. architecture (if used); 3. grid (if used); 4. scalars; 5. parameter structs; 6. `NamedTuple`s of stuff. I'm open to other patterns too.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/448
https://github.com/CliMA/Oceananigans.jl/issues/448:579,Usability,guid,guide,579,"Our time-stepping functions / kernels in `time_steppers.jl` are a bit chaotic with long argument lists, etc. To bring order to this world, it might be a good idea to adopt some kind of convention / preferred ordering to the function arguments. . Almost all of the functions are mutating, so I think the first argument(s) should be the objects that are mutated by the function. This follows the [julia style guide recommendation](https://docs.julialang.org/en/v1/manual/style-guide/index.html#Write-functions-with-argument-ordering-similar-to-Julia-Base-1). After that, the style guide doesn't offer guidance though it could make sense to put important objects for dispatch first (mostly `arch`). . The rest of the objects fall into a few categories (I think):. * grid; * parameter structs; * `NamedTuple`s of fields / arrays / boundary conditions; * scalars. Perhaps we can use an ordering along the lines of. 1. object being mutated; 2. architecture (if used); 3. grid (if used); 4. scalars; 5. parameter structs; 6. `NamedTuple`s of stuff. I'm open to other patterns too.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/448
https://github.com/CliMA/Oceananigans.jl/issues/448:599,Usability,guid,guidance,599,"Our time-stepping functions / kernels in `time_steppers.jl` are a bit chaotic with long argument lists, etc. To bring order to this world, it might be a good idea to adopt some kind of convention / preferred ordering to the function arguments. . Almost all of the functions are mutating, so I think the first argument(s) should be the objects that are mutated by the function. This follows the [julia style guide recommendation](https://docs.julialang.org/en/v1/manual/style-guide/index.html#Write-functions-with-argument-ordering-similar-to-Julia-Base-1). After that, the style guide doesn't offer guidance though it could make sense to put important objects for dispatch first (mostly `arch`). . The rest of the objects fall into a few categories (I think):. * grid; * parameter structs; * `NamedTuple`s of fields / arrays / boundary conditions; * scalars. Perhaps we can use an ordering along the lines of. 1. object being mutated; 2. architecture (if used); 3. grid (if used); 4. scalars; 5. parameter structs; 6. `NamedTuple`s of stuff. I'm open to other patterns too.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/448
https://github.com/CliMA/Oceananigans.jl/issues/449:83,Availability,error,error,83,"I may be missing something, but in the first example of the documentation I get an error when creating the model. The prior example (the still ocean without anything) runs fine. Based on the docs I think at some point you changed the keyword from `arch` to `architecture` in the `Model` function and didn't change the documentation, but since I'm not familiar with Oceananigans I decided to post here instead of making a pull request. Cheers. Also, quick edit: the link to `rising_thermal_bubble_2d.jl` in the front page is broken.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/449
https://github.com/CliMA/Oceananigans.jl/issues/451:75,Availability,error,error,75,"I'm trying to run the hot bubble example but using a GPU. However I get an error when defining the model that I cannot understand (the caveat here being that I have zero experience working with GPUs). The minimum code to reproduce this is. ```; using Oceananigans; model = BasicModel(N=(256, 1, 256), L=(2000, 1, 2000), architecture=GPU(), ν=4e-2, κ=4e-2); ```. This is the error that I get:. ```; ERROR: LoadError: Device capability v2.1.0 not supported by available toolchain; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] supported_capability(::CUDAdrv.CuDevice) at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/utils.jl:7; [3] macro expansion at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/execution.jl:388 [inlined]; [4] #cufunction#176(::Nothing, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(CUDAnative.cufunction), ::getfield(GPUArrays, Symbol(""##23#24"")), ::Type{Tuple{CuArrays.CuKernelState,CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global},Base.Broadcast.Broadcasted{Nothing,Tuple{Base.OneTo{Int64},Base.OneTo{Int64},Base.OneTo{Int64}},typeof(identity),Tuple{Int64}}}}) at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/execution.jl:357; [5] cufunction(::Function, ::Type) at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/execution.jl:357; [6] macro expansion at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/execution.jl:174 [inlined]; [7] macro expansion at ./gcutils.jl:87 [inlined]; [8] macro expansion at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/execution.jl:171 [inlined]; [9] _gpu_call(::CuArrays.CuArrayBackend, ::Function, ::CuArrays.CuArray{Float64,3}, ::Tuple{CuArrays.CuArray{Float64,3},Base.Broadcast.Broadcasted{Nothing,Tuple{Base.OneTo{Int64},Base.OneTo{Int64},Base.OneTo{Int64}},typeof(identity),Tuple{Int64}}}, ::Tuple{Tuple{Int64},Tuple{Int64}}) at /home/tomaschor/.julia/packages/CuArrays/wXQp8/src/gpuarray_interface.jl:60; [10] gpu_call(::Function, ::CuArrays.CuArray{Fl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/451
https://github.com/CliMA/Oceananigans.jl/issues/451:374,Availability,error,error,374,"I'm trying to run the hot bubble example but using a GPU. However I get an error when defining the model that I cannot understand (the caveat here being that I have zero experience working with GPUs). The minimum code to reproduce this is. ```; using Oceananigans; model = BasicModel(N=(256, 1, 256), L=(2000, 1, 2000), architecture=GPU(), ν=4e-2, κ=4e-2); ```. This is the error that I get:. ```; ERROR: LoadError: Device capability v2.1.0 not supported by available toolchain; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] supported_capability(::CUDAdrv.CuDevice) at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/utils.jl:7; [3] macro expansion at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/execution.jl:388 [inlined]; [4] #cufunction#176(::Nothing, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(CUDAnative.cufunction), ::getfield(GPUArrays, Symbol(""##23#24"")), ::Type{Tuple{CuArrays.CuKernelState,CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global},Base.Broadcast.Broadcasted{Nothing,Tuple{Base.OneTo{Int64},Base.OneTo{Int64},Base.OneTo{Int64}},typeof(identity),Tuple{Int64}}}}) at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/execution.jl:357; [5] cufunction(::Function, ::Type) at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/execution.jl:357; [6] macro expansion at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/execution.jl:174 [inlined]; [7] macro expansion at ./gcutils.jl:87 [inlined]; [8] macro expansion at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/execution.jl:171 [inlined]; [9] _gpu_call(::CuArrays.CuArrayBackend, ::Function, ::CuArrays.CuArray{Float64,3}, ::Tuple{CuArrays.CuArray{Float64,3},Base.Broadcast.Broadcasted{Nothing,Tuple{Base.OneTo{Int64},Base.OneTo{Int64},Base.OneTo{Int64}},typeof(identity),Tuple{Int64}}}, ::Tuple{Tuple{Int64},Tuple{Int64}}) at /home/tomaschor/.julia/packages/CuArrays/wXQp8/src/gpuarray_interface.jl:60; [10] gpu_call(::Function, ::CuArrays.CuArray{Fl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/451
https://github.com/CliMA/Oceananigans.jl/issues/451:398,Availability,ERROR,ERROR,398,"I'm trying to run the hot bubble example but using a GPU. However I get an error when defining the model that I cannot understand (the caveat here being that I have zero experience working with GPUs). The minimum code to reproduce this is. ```; using Oceananigans; model = BasicModel(N=(256, 1, 256), L=(2000, 1, 2000), architecture=GPU(), ν=4e-2, κ=4e-2); ```. This is the error that I get:. ```; ERROR: LoadError: Device capability v2.1.0 not supported by available toolchain; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] supported_capability(::CUDAdrv.CuDevice) at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/utils.jl:7; [3] macro expansion at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/execution.jl:388 [inlined]; [4] #cufunction#176(::Nothing, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(CUDAnative.cufunction), ::getfield(GPUArrays, Symbol(""##23#24"")), ::Type{Tuple{CuArrays.CuKernelState,CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global},Base.Broadcast.Broadcasted{Nothing,Tuple{Base.OneTo{Int64},Base.OneTo{Int64},Base.OneTo{Int64}},typeof(identity),Tuple{Int64}}}}) at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/execution.jl:357; [5] cufunction(::Function, ::Type) at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/execution.jl:357; [6] macro expansion at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/execution.jl:174 [inlined]; [7] macro expansion at ./gcutils.jl:87 [inlined]; [8] macro expansion at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/execution.jl:171 [inlined]; [9] _gpu_call(::CuArrays.CuArrayBackend, ::Function, ::CuArrays.CuArray{Float64,3}, ::Tuple{CuArrays.CuArray{Float64,3},Base.Broadcast.Broadcasted{Nothing,Tuple{Base.OneTo{Int64},Base.OneTo{Int64},Base.OneTo{Int64}},typeof(identity),Tuple{Int64}}}, ::Tuple{Tuple{Int64},Tuple{Int64}}) at /home/tomaschor/.julia/packages/CuArrays/wXQp8/src/gpuarray_interface.jl:60; [10] gpu_call(::Function, ::CuArrays.CuArray{Fl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/451
https://github.com/CliMA/Oceananigans.jl/issues/451:458,Availability,avail,available,458,"I'm trying to run the hot bubble example but using a GPU. However I get an error when defining the model that I cannot understand (the caveat here being that I have zero experience working with GPUs). The minimum code to reproduce this is. ```; using Oceananigans; model = BasicModel(N=(256, 1, 256), L=(2000, 1, 2000), architecture=GPU(), ν=4e-2, κ=4e-2); ```. This is the error that I get:. ```; ERROR: LoadError: Device capability v2.1.0 not supported by available toolchain; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] supported_capability(::CUDAdrv.CuDevice) at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/utils.jl:7; [3] macro expansion at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/execution.jl:388 [inlined]; [4] #cufunction#176(::Nothing, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(CUDAnative.cufunction), ::getfield(GPUArrays, Symbol(""##23#24"")), ::Type{Tuple{CuArrays.CuKernelState,CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global},Base.Broadcast.Broadcasted{Nothing,Tuple{Base.OneTo{Int64},Base.OneTo{Int64},Base.OneTo{Int64}},typeof(identity),Tuple{Int64}}}}) at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/execution.jl:357; [5] cufunction(::Function, ::Type) at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/execution.jl:357; [6] macro expansion at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/execution.jl:174 [inlined]; [7] macro expansion at ./gcutils.jl:87 [inlined]; [8] macro expansion at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/execution.jl:171 [inlined]; [9] _gpu_call(::CuArrays.CuArrayBackend, ::Function, ::CuArrays.CuArray{Float64,3}, ::Tuple{CuArrays.CuArray{Float64,3},Base.Broadcast.Broadcasted{Nothing,Tuple{Base.OneTo{Int64},Base.OneTo{Int64},Base.OneTo{Int64}},typeof(identity),Tuple{Int64}}}, ::Tuple{Tuple{Int64},Tuple{Int64}}) at /home/tomaschor/.julia/packages/CuArrays/wXQp8/src/gpuarray_interface.jl:60; [10] gpu_call(::Function, ::CuArrays.CuArray{Fl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/451
https://github.com/CliMA/Oceananigans.jl/issues/451:496,Availability,error,error,496,"I'm trying to run the hot bubble example but using a GPU. However I get an error when defining the model that I cannot understand (the caveat here being that I have zero experience working with GPUs). The minimum code to reproduce this is. ```; using Oceananigans; model = BasicModel(N=(256, 1, 256), L=(2000, 1, 2000), architecture=GPU(), ν=4e-2, κ=4e-2); ```. This is the error that I get:. ```; ERROR: LoadError: Device capability v2.1.0 not supported by available toolchain; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] supported_capability(::CUDAdrv.CuDevice) at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/utils.jl:7; [3] macro expansion at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/execution.jl:388 [inlined]; [4] #cufunction#176(::Nothing, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(CUDAnative.cufunction), ::getfield(GPUArrays, Symbol(""##23#24"")), ::Type{Tuple{CuArrays.CuKernelState,CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global},Base.Broadcast.Broadcasted{Nothing,Tuple{Base.OneTo{Int64},Base.OneTo{Int64},Base.OneTo{Int64}},typeof(identity),Tuple{Int64}}}}) at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/execution.jl:357; [5] cufunction(::Function, ::Type) at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/execution.jl:357; [6] macro expansion at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/execution.jl:174 [inlined]; [7] macro expansion at ./gcutils.jl:87 [inlined]; [8] macro expansion at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/execution.jl:171 [inlined]; [9] _gpu_call(::CuArrays.CuArrayBackend, ::Function, ::CuArrays.CuArray{Float64,3}, ::Tuple{CuArrays.CuArray{Float64,3},Base.Broadcast.Broadcasted{Nothing,Tuple{Base.OneTo{Int64},Base.OneTo{Int64},Base.OneTo{Int64}},typeof(identity),Tuple{Int64}}}, ::Tuple{Tuple{Int64},Tuple{Int64}}) at /home/tomaschor/.julia/packages/CuArrays/wXQp8/src/gpuarray_interface.jl:60; [10] gpu_call(::Function, ::CuArrays.CuArray{Fl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/451
https://github.com/CliMA/Oceananigans.jl/issues/451:517,Availability,error,error,517,"I'm trying to run the hot bubble example but using a GPU. However I get an error when defining the model that I cannot understand (the caveat here being that I have zero experience working with GPUs). The minimum code to reproduce this is. ```; using Oceananigans; model = BasicModel(N=(256, 1, 256), L=(2000, 1, 2000), architecture=GPU(), ν=4e-2, κ=4e-2); ```. This is the error that I get:. ```; ERROR: LoadError: Device capability v2.1.0 not supported by available toolchain; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] supported_capability(::CUDAdrv.CuDevice) at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/utils.jl:7; [3] macro expansion at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/execution.jl:388 [inlined]; [4] #cufunction#176(::Nothing, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(CUDAnative.cufunction), ::getfield(GPUArrays, Symbol(""##23#24"")), ::Type{Tuple{CuArrays.CuKernelState,CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global},Base.Broadcast.Broadcasted{Nothing,Tuple{Base.OneTo{Int64},Base.OneTo{Int64},Base.OneTo{Int64}},typeof(identity),Tuple{Int64}}}}) at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/execution.jl:357; [5] cufunction(::Function, ::Type) at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/execution.jl:357; [6] macro expansion at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/execution.jl:174 [inlined]; [7] macro expansion at ./gcutils.jl:87 [inlined]; [8] macro expansion at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/execution.jl:171 [inlined]; [9] _gpu_call(::CuArrays.CuArrayBackend, ::Function, ::CuArrays.CuArray{Float64,3}, ::Tuple{CuArrays.CuArray{Float64,3},Base.Broadcast.Broadcasted{Nothing,Tuple{Base.OneTo{Int64},Base.OneTo{Int64},Base.OneTo{Int64}},typeof(identity),Tuple{Int64}}}, ::Tuple{Tuple{Int64},Tuple{Int64}}) at /home/tomaschor/.julia/packages/CuArrays/wXQp8/src/gpuarray_interface.jl:60; [10] gpu_call(::Function, ::CuArrays.CuArray{Fl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/451
https://github.com/CliMA/Oceananigans.jl/issues/451:5685,Deployability,install,installed,5685,"s/Oceananigans/s0kF6/src/models.jl:125; [23] (::getfield(Oceananigans, Symbol(""#kw##BasicModel"")))(::NamedTuple{(:N, :L, :architecture, :ν, :κ),Tuple{Tuple{Int64,Int64,Int64},Tuple{Int64,Int64,Int64},GPU,Float64,Float64}}, ::typeof(BasicModel)) at ./none:0; [24] top-level scope at /home/tomaschor/oceantest/test1.jl:5; [25] include at ./boot.jl:328 [inlined]; [26] include_relative(::Module, ::String) at ./loading.jl:1094; [27] include(::Module, ::String) at ./Base.jl:31; [28] include(::String) at ./client.jl:431; [29] top-level scope at REPL[1]:1; in expression starting at /home/tomaschor/oceantest/test1.jl:5; ```. Here's the output of `nvidia-smi`:; ```; +-----------------------------------------------------------------------------+; | NVIDIA-SMI 390.129 Driver Version: 390.129 |; |-------------------------------+----------------------+----------------------+; | GPU Name Persistence-M| Bus-Id Disp.A | Volatile Uncorr. ECC |; | Fan Temp Perf Pwr:Usage/Cap| Memory-Usage | GPU-Util Compute M. |; |===============================+======================+======================|; | 0 NVS 310 Off | 00000000:03:00.0 N/A | N/A |; | 30% 40C P8 N/A / N/A | 634MiB / 962MiB | N/A Default |; +-------------------------------+----------------------+----------------------+; ; +-----------------------------------------------------------------------------+; | Processes: GPU Memory |; | GPU PID Type Process name Usage |; |=============================================================================|; | 0 Not Supported |; +-----------------------------------------------------------------------------+; ```. I'm using the most recent version of both Julia and Oceananigans, and I have installed the CUDA toolkit with `sudo apt-get install nvidia-cuda-toolkit`. I'm running this on Linux Mint. The only relevant info I could find was [this issue](https://github.com/JuliaGPU/CuArrays.jl/issues/248), but my limited knowledge of GPUs makes it hard for me to take much useful from it. . Any thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/451
https://github.com/CliMA/Oceananigans.jl/issues/451:5731,Deployability,install,install,5731,"s/Oceananigans/s0kF6/src/models.jl:125; [23] (::getfield(Oceananigans, Symbol(""#kw##BasicModel"")))(::NamedTuple{(:N, :L, :architecture, :ν, :κ),Tuple{Tuple{Int64,Int64,Int64},Tuple{Int64,Int64,Int64},GPU,Float64,Float64}}, ::typeof(BasicModel)) at ./none:0; [24] top-level scope at /home/tomaschor/oceantest/test1.jl:5; [25] include at ./boot.jl:328 [inlined]; [26] include_relative(::Module, ::String) at ./loading.jl:1094; [27] include(::Module, ::String) at ./Base.jl:31; [28] include(::String) at ./client.jl:431; [29] top-level scope at REPL[1]:1; in expression starting at /home/tomaschor/oceantest/test1.jl:5; ```. Here's the output of `nvidia-smi`:; ```; +-----------------------------------------------------------------------------+; | NVIDIA-SMI 390.129 Driver Version: 390.129 |; |-------------------------------+----------------------+----------------------+; | GPU Name Persistence-M| Bus-Id Disp.A | Volatile Uncorr. ECC |; | Fan Temp Perf Pwr:Usage/Cap| Memory-Usage | GPU-Util Compute M. |; |===============================+======================+======================|; | 0 NVS 310 Off | 00000000:03:00.0 N/A | N/A |; | 30% 40C P8 N/A / N/A | 634MiB / 962MiB | N/A Default |; +-------------------------------+----------------------+----------------------+; ; +-----------------------------------------------------------------------------+; | Processes: GPU Memory |; | GPU PID Type Process name Usage |; |=============================================================================|; | 0 Not Supported |; +-----------------------------------------------------------------------------+; ```. I'm using the most recent version of both Julia and Oceananigans, and I have installed the CUDA toolkit with `sudo apt-get install nvidia-cuda-toolkit`. I'm running this on Linux Mint. The only relevant info I could find was [this issue](https://github.com/JuliaGPU/CuArrays.jl/issues/248), but my limited knowledge of GPUs makes it hard for me to take much useful from it. . Any thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/451
https://github.com/CliMA/Oceananigans.jl/issues/451:405,Performance,Load,LoadError,405,"I'm trying to run the hot bubble example but using a GPU. However I get an error when defining the model that I cannot understand (the caveat here being that I have zero experience working with GPUs). The minimum code to reproduce this is. ```; using Oceananigans; model = BasicModel(N=(256, 1, 256), L=(2000, 1, 2000), architecture=GPU(), ν=4e-2, κ=4e-2); ```. This is the error that I get:. ```; ERROR: LoadError: Device capability v2.1.0 not supported by available toolchain; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] supported_capability(::CUDAdrv.CuDevice) at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/utils.jl:7; [3] macro expansion at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/execution.jl:388 [inlined]; [4] #cufunction#176(::Nothing, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(CUDAnative.cufunction), ::getfield(GPUArrays, Symbol(""##23#24"")), ::Type{Tuple{CuArrays.CuKernelState,CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global},Base.Broadcast.Broadcasted{Nothing,Tuple{Base.OneTo{Int64},Base.OneTo{Int64},Base.OneTo{Int64}},typeof(identity),Tuple{Int64}}}}) at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/execution.jl:357; [5] cufunction(::Function, ::Type) at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/execution.jl:357; [6] macro expansion at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/execution.jl:174 [inlined]; [7] macro expansion at ./gcutils.jl:87 [inlined]; [8] macro expansion at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/execution.jl:171 [inlined]; [9] _gpu_call(::CuArrays.CuArrayBackend, ::Function, ::CuArrays.CuArray{Float64,3}, ::Tuple{CuArrays.CuArray{Float64,3},Base.Broadcast.Broadcasted{Nothing,Tuple{Base.OneTo{Int64},Base.OneTo{Int64},Base.OneTo{Int64}},typeof(identity),Tuple{Int64}}}, ::Tuple{Tuple{Int64},Tuple{Int64}}) at /home/tomaschor/.julia/packages/CuArrays/wXQp8/src/gpuarray_interface.jl:60; [10] gpu_call(::Function, ::CuArrays.CuArray{Fl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/451
https://github.com/CliMA/Oceananigans.jl/issues/451:4405,Performance,load,loading,4405,"ceananigans/s0kF6/src/models.jl:186; [21] (::getfield(Core, Symbol(""#kw#Type"")))(::NamedTuple{(:float_type, :grid, :closure, :architecture),Tuple{DataType,RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},ConstantIsotropicDiffusivity{Float64},GPU}}, ::Type{Model}) at ./none:0; [22] #BasicModel#23(::Tuple{Int64,Int64,Int64}, ::Tuple{Int64,Int64,Int64}, ::Float64, ::Float64, ::Type, ::Base.Iterators.Pairs{Symbol,GPU,Tuple{Symbol},NamedTuple{(:architecture,),Tuple{GPU}}}, ::typeof(BasicModel)) at /home/tomaschor/.julia/packages/Oceananigans/s0kF6/src/models.jl:125; [23] (::getfield(Oceananigans, Symbol(""#kw##BasicModel"")))(::NamedTuple{(:N, :L, :architecture, :ν, :κ),Tuple{Tuple{Int64,Int64,Int64},Tuple{Int64,Int64,Int64},GPU,Float64,Float64}}, ::typeof(BasicModel)) at ./none:0; [24] top-level scope at /home/tomaschor/oceantest/test1.jl:5; [25] include at ./boot.jl:328 [inlined]; [26] include_relative(::Module, ::String) at ./loading.jl:1094; [27] include(::Module, ::String) at ./Base.jl:31; [28] include(::String) at ./client.jl:431; [29] top-level scope at REPL[1]:1; in expression starting at /home/tomaschor/oceantest/test1.jl:5; ```. Here's the output of `nvidia-smi`:; ```; +-----------------------------------------------------------------------------+; | NVIDIA-SMI 390.129 Driver Version: 390.129 |; |-------------------------------+----------------------+----------------------+; | GPU Name Persistence-M| Bus-Id Disp.A | Volatile Uncorr. ECC |; | Fan Temp Perf Pwr:Usage/Cap| Memory-Usage | GPU-Util Compute M. |; |===============================+======================+======================|; | 0 NVS 310 Off | 00000000:03:00.0 N/A | N/A |; | 30% 40C P8 N/A / N/A | 634MiB / 962MiB | N/A Default |; +-------------------------------+----------------------+----------------------+; ; +-----------------------------------------------------------------------------+; | Processes: GPU Memory |; | GPU PID Type Process nam",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/451
https://github.com/CliMA/Oceananigans.jl/pull/452:1066,Availability,error,error,1066,"' functionality to Oceananigans. With this PR, the user is now able to specify which tracers they would like to include in their simulation via the `Model` constructor:. ```julia; model = Model(..., tracers=(:b, :c1, :c2), ...); ```. ## User-facing considerations. 1. The specified tracers must be consistent with the specified buoyancy model. This consistency is ensured by `validate_buoyancy` in the `Model` constructor. For `BuoyancyTracer`, the user must specify a tracer named `:b`. For `SeawaterBuoyancy`, the user must specify tracers named `:T` and `:S`. (In the future, we could also allow the names of these buoyancy, temperature, and salinity tracers to be specified in the constructor for the respective buoyancy models, eg `SeawaterBuoyancy(temperature=:T, salinity=:S)`.). 2. The constructor for `ModelForcing` (which will have to be merged with #444 when it is approved) now allows the user to specify forcing for any of the tracer fields. If the user specifies a forcing for a tracer field that does not exist, an error is thrown. If a user does not specify a forcing for some tracer field, a default zero forcing is applied. 3. The same logic for `ModelForcing` applies to `BoundaryConditions` / `SolutionBoundaryConditions`. When boundary conditions for a tracer field are unspecified, a default tracer boundary condition is inferred from the x-velocity field: tracers either inherit `Periodic` boundary conditions, or are given a `Flux, Nothing` boundary condition for all other cases. 4. For closures, all tracer-diffusivity-related fields permit users to specify either:. * a constant (applied to all tracers), or ; * a `NamedTuple` with fields for *every* tracer. . In the future, we could possibly implement some mixed behavior where the user specifies both a default *and* particular values for tracer diffusivity. This would be useful in the (possibly rare) use-case of a large number of tracers with the same diffusivity, but where one or two of them require a special, diff",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/452
https://github.com/CliMA/Oceananigans.jl/pull/452:2735,Deployability,update,update,2735,"er. . In the future, we could possibly implement some mixed behavior where the user specifies both a default *and* particular values for tracer diffusivity. This would be useful in the (possibly rare) use-case of a large number of tracers with the same diffusivity, but where one or two of them require a special, different diffusivity. I am not sure this API is necessary so I left it for future work. Diffusivity-like fields include:. * `κ` (constant component of tracer diffusivity) for `ConstantIsotropicDiffusivity`, `AnisotropicMinimumDissipation`, and `ConstantSmagorinsky`; * `Pr` (turbulent Prandtl number) for `ConstantSmagorinsky`; * `κh` and `κv` for `ConstantAnisotropicDiffusivity`. ## Internal algorithmic considerations. This implementation includes a major refactor of the time-stepping algorithm. In particular, kernels are launched for *each* tracer for all operations that involve tracers. This differs from the previous pattern, in which a single kernel was called in some cases (for example, to update the velocity and tracer fields, or to store previous source terms). The reason for this change is because I ran into some issues (dynamic function invocations) using `ntuple` to unroll a loop over tracers inside the kernel. In addition, I think that with a large number of tracers the kernels may become too large and their performance could degrade (but I'm not sure). This refactoring of the algorithm means we need to . - [ ] benchmark the changes in this PR to see if there are any significant changes in model performance. . @ali-ramadhan, can you help with this?. If there are changes in model performance, we can work on unrolling loops over the tracer fields *inside* our kernels. This is probably possible; it just requires some debugging. We would probably also want to make sure that this doesn't lead to poor performance for up to O(10) tracers. If any of this PR is not satisfactory, I'm happy to work on it and iterate until the PR is in mergeable shape. Resolve",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/452
https://github.com/CliMA/Oceananigans.jl/pull/452:1430,Modifiability,inherit,inherit,1430,"y `validate_buoyancy` in the `Model` constructor. For `BuoyancyTracer`, the user must specify a tracer named `:b`. For `SeawaterBuoyancy`, the user must specify tracers named `:T` and `:S`. (In the future, we could also allow the names of these buoyancy, temperature, and salinity tracers to be specified in the constructor for the respective buoyancy models, eg `SeawaterBuoyancy(temperature=:T, salinity=:S)`.). 2. The constructor for `ModelForcing` (which will have to be merged with #444 when it is approved) now allows the user to specify forcing for any of the tracer fields. If the user specifies a forcing for a tracer field that does not exist, an error is thrown. If a user does not specify a forcing for some tracer field, a default zero forcing is applied. 3. The same logic for `ModelForcing` applies to `BoundaryConditions` / `SolutionBoundaryConditions`. When boundary conditions for a tracer field are unspecified, a default tracer boundary condition is inferred from the x-velocity field: tracers either inherit `Periodic` boundary conditions, or are given a `Flux, Nothing` boundary condition for all other cases. 4. For closures, all tracer-diffusivity-related fields permit users to specify either:. * a constant (applied to all tracers), or ; * a `NamedTuple` with fields for *every* tracer. . In the future, we could possibly implement some mixed behavior where the user specifies both a default *and* particular values for tracer diffusivity. This would be useful in the (possibly rare) use-case of a large number of tracers with the same diffusivity, but where one or two of them require a special, different diffusivity. I am not sure this API is necessary so I left it for future work. Diffusivity-like fields include:. * `κ` (constant component of tracer diffusivity) for `ConstantIsotropicDiffusivity`, `AnisotropicMinimumDissipation`, and `ConstantSmagorinsky`; * `Pr` (turbulent Prandtl number) for `ConstantSmagorinsky`; * `κh` and `κv` for `ConstantAnisotropicDiffusiv",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/452
https://github.com/CliMA/Oceananigans.jl/pull/452:2492,Modifiability,refactor,refactor,2492,"othing` boundary condition for all other cases. 4. For closures, all tracer-diffusivity-related fields permit users to specify either:. * a constant (applied to all tracers), or ; * a `NamedTuple` with fields for *every* tracer. . In the future, we could possibly implement some mixed behavior where the user specifies both a default *and* particular values for tracer diffusivity. This would be useful in the (possibly rare) use-case of a large number of tracers with the same diffusivity, but where one or two of them require a special, different diffusivity. I am not sure this API is necessary so I left it for future work. Diffusivity-like fields include:. * `κ` (constant component of tracer diffusivity) for `ConstantIsotropicDiffusivity`, `AnisotropicMinimumDissipation`, and `ConstantSmagorinsky`; * `Pr` (turbulent Prandtl number) for `ConstantSmagorinsky`; * `κh` and `κv` for `ConstantAnisotropicDiffusivity`. ## Internal algorithmic considerations. This implementation includes a major refactor of the time-stepping algorithm. In particular, kernels are launched for *each* tracer for all operations that involve tracers. This differs from the previous pattern, in which a single kernel was called in some cases (for example, to update the velocity and tracer fields, or to store previous source terms). The reason for this change is because I ran into some issues (dynamic function invocations) using `ntuple` to unroll a loop over tracers inside the kernel. In addition, I think that with a large number of tracers the kernels may become too large and their performance could degrade (but I'm not sure). This refactoring of the algorithm means we need to . - [ ] benchmark the changes in this PR to see if there are any significant changes in model performance. . @ali-ramadhan, can you help with this?. If there are changes in model performance, we can work on unrolling loops over the tracer fields *inside* our kernels. This is probably possible; it just requires some debugging. We",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/452
https://github.com/CliMA/Oceananigans.jl/pull/452:3117,Modifiability,refactor,refactoring,3117," some mixed behavior where the user specifies both a default *and* particular values for tracer diffusivity. This would be useful in the (possibly rare) use-case of a large number of tracers with the same diffusivity, but where one or two of them require a special, different diffusivity. I am not sure this API is necessary so I left it for future work. Diffusivity-like fields include:. * `κ` (constant component of tracer diffusivity) for `ConstantIsotropicDiffusivity`, `AnisotropicMinimumDissipation`, and `ConstantSmagorinsky`; * `Pr` (turbulent Prandtl number) for `ConstantSmagorinsky`; * `κh` and `κv` for `ConstantAnisotropicDiffusivity`. ## Internal algorithmic considerations. This implementation includes a major refactor of the time-stepping algorithm. In particular, kernels are launched for *each* tracer for all operations that involve tracers. This differs from the previous pattern, in which a single kernel was called in some cases (for example, to update the velocity and tracer fields, or to store previous source terms). The reason for this change is because I ran into some issues (dynamic function invocations) using `ntuple` to unroll a loop over tracers inside the kernel. In addition, I think that with a large number of tracers the kernels may become too large and their performance could degrade (but I'm not sure). This refactoring of the algorithm means we need to . - [ ] benchmark the changes in this PR to see if there are any significant changes in model performance. . @ali-ramadhan, can you help with this?. If there are changes in model performance, we can work on unrolling loops over the tracer fields *inside* our kernels. This is probably possible; it just requires some debugging. We would probably also want to make sure that this doesn't lead to poor performance for up to O(10) tracers. If any of this PR is not satisfactory, I'm happy to work on it and iterate until the PR is in mergeable shape. Resolves #25 ; Resolves #430 ; Partially addresses #448",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/452
https://github.com/CliMA/Oceananigans.jl/pull/452:3066,Performance,perform,performance,3066," some mixed behavior where the user specifies both a default *and* particular values for tracer diffusivity. This would be useful in the (possibly rare) use-case of a large number of tracers with the same diffusivity, but where one or two of them require a special, different diffusivity. I am not sure this API is necessary so I left it for future work. Diffusivity-like fields include:. * `κ` (constant component of tracer diffusivity) for `ConstantIsotropicDiffusivity`, `AnisotropicMinimumDissipation`, and `ConstantSmagorinsky`; * `Pr` (turbulent Prandtl number) for `ConstantSmagorinsky`; * `κh` and `κv` for `ConstantAnisotropicDiffusivity`. ## Internal algorithmic considerations. This implementation includes a major refactor of the time-stepping algorithm. In particular, kernels are launched for *each* tracer for all operations that involve tracers. This differs from the previous pattern, in which a single kernel was called in some cases (for example, to update the velocity and tracer fields, or to store previous source terms). The reason for this change is because I ran into some issues (dynamic function invocations) using `ntuple` to unroll a loop over tracers inside the kernel. In addition, I think that with a large number of tracers the kernels may become too large and their performance could degrade (but I'm not sure). This refactoring of the algorithm means we need to . - [ ] benchmark the changes in this PR to see if there are any significant changes in model performance. . @ali-ramadhan, can you help with this?. If there are changes in model performance, we can work on unrolling loops over the tracer fields *inside* our kernels. This is probably possible; it just requires some debugging. We would probably also want to make sure that this doesn't lead to poor performance for up to O(10) tracers. If any of this PR is not satisfactory, I'm happy to work on it and iterate until the PR is in mergeable shape. Resolves #25 ; Resolves #430 ; Partially addresses #448",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/452
https://github.com/CliMA/Oceananigans.jl/pull/452:3257,Performance,perform,performance,3257," some mixed behavior where the user specifies both a default *and* particular values for tracer diffusivity. This would be useful in the (possibly rare) use-case of a large number of tracers with the same diffusivity, but where one or two of them require a special, different diffusivity. I am not sure this API is necessary so I left it for future work. Diffusivity-like fields include:. * `κ` (constant component of tracer diffusivity) for `ConstantIsotropicDiffusivity`, `AnisotropicMinimumDissipation`, and `ConstantSmagorinsky`; * `Pr` (turbulent Prandtl number) for `ConstantSmagorinsky`; * `κh` and `κv` for `ConstantAnisotropicDiffusivity`. ## Internal algorithmic considerations. This implementation includes a major refactor of the time-stepping algorithm. In particular, kernels are launched for *each* tracer for all operations that involve tracers. This differs from the previous pattern, in which a single kernel was called in some cases (for example, to update the velocity and tracer fields, or to store previous source terms). The reason for this change is because I ran into some issues (dynamic function invocations) using `ntuple` to unroll a loop over tracers inside the kernel. In addition, I think that with a large number of tracers the kernels may become too large and their performance could degrade (but I'm not sure). This refactoring of the algorithm means we need to . - [ ] benchmark the changes in this PR to see if there are any significant changes in model performance. . @ali-ramadhan, can you help with this?. If there are changes in model performance, we can work on unrolling loops over the tracer fields *inside* our kernels. This is probably possible; it just requires some debugging. We would probably also want to make sure that this doesn't lead to poor performance for up to O(10) tracers. If any of this PR is not satisfactory, I'm happy to work on it and iterate until the PR is in mergeable shape. Resolves #25 ; Resolves #430 ; Partially addresses #448",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/452
https://github.com/CliMA/Oceananigans.jl/pull/452:3342,Performance,perform,performance,3342," some mixed behavior where the user specifies both a default *and* particular values for tracer diffusivity. This would be useful in the (possibly rare) use-case of a large number of tracers with the same diffusivity, but where one or two of them require a special, different diffusivity. I am not sure this API is necessary so I left it for future work. Diffusivity-like fields include:. * `κ` (constant component of tracer diffusivity) for `ConstantIsotropicDiffusivity`, `AnisotropicMinimumDissipation`, and `ConstantSmagorinsky`; * `Pr` (turbulent Prandtl number) for `ConstantSmagorinsky`; * `κh` and `κv` for `ConstantAnisotropicDiffusivity`. ## Internal algorithmic considerations. This implementation includes a major refactor of the time-stepping algorithm. In particular, kernels are launched for *each* tracer for all operations that involve tracers. This differs from the previous pattern, in which a single kernel was called in some cases (for example, to update the velocity and tracer fields, or to store previous source terms). The reason for this change is because I ran into some issues (dynamic function invocations) using `ntuple` to unroll a loop over tracers inside the kernel. In addition, I think that with a large number of tracers the kernels may become too large and their performance could degrade (but I'm not sure). This refactoring of the algorithm means we need to . - [ ] benchmark the changes in this PR to see if there are any significant changes in model performance. . @ali-ramadhan, can you help with this?. If there are changes in model performance, we can work on unrolling loops over the tracer fields *inside* our kernels. This is probably possible; it just requires some debugging. We would probably also want to make sure that this doesn't lead to poor performance for up to O(10) tracers. If any of this PR is not satisfactory, I'm happy to work on it and iterate until the PR is in mergeable shape. Resolves #25 ; Resolves #430 ; Partially addresses #448",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/452
https://github.com/CliMA/Oceananigans.jl/pull/452:3563,Performance,perform,performance,3563," some mixed behavior where the user specifies both a default *and* particular values for tracer diffusivity. This would be useful in the (possibly rare) use-case of a large number of tracers with the same diffusivity, but where one or two of them require a special, different diffusivity. I am not sure this API is necessary so I left it for future work. Diffusivity-like fields include:. * `κ` (constant component of tracer diffusivity) for `ConstantIsotropicDiffusivity`, `AnisotropicMinimumDissipation`, and `ConstantSmagorinsky`; * `Pr` (turbulent Prandtl number) for `ConstantSmagorinsky`; * `κh` and `κv` for `ConstantAnisotropicDiffusivity`. ## Internal algorithmic considerations. This implementation includes a major refactor of the time-stepping algorithm. In particular, kernels are launched for *each* tracer for all operations that involve tracers. This differs from the previous pattern, in which a single kernel was called in some cases (for example, to update the velocity and tracer fields, or to store previous source terms). The reason for this change is because I ran into some issues (dynamic function invocations) using `ntuple` to unroll a loop over tracers inside the kernel. In addition, I think that with a large number of tracers the kernels may become too large and their performance could degrade (but I'm not sure). This refactoring of the algorithm means we need to . - [ ] benchmark the changes in this PR to see if there are any significant changes in model performance. . @ali-ramadhan, can you help with this?. If there are changes in model performance, we can work on unrolling loops over the tracer fields *inside* our kernels. This is probably possible; it just requires some debugging. We would probably also want to make sure that this doesn't lead to poor performance for up to O(10) tracers. If any of this PR is not satisfactory, I'm happy to work on it and iterate until the PR is in mergeable shape. Resolves #25 ; Resolves #430 ; Partially addresses #448",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/452
https://github.com/CliMA/Oceananigans.jl/pull/452:1190,Testability,log,logic,1190,"(..., tracers=(:b, :c1, :c2), ...); ```. ## User-facing considerations. 1. The specified tracers must be consistent with the specified buoyancy model. This consistency is ensured by `validate_buoyancy` in the `Model` constructor. For `BuoyancyTracer`, the user must specify a tracer named `:b`. For `SeawaterBuoyancy`, the user must specify tracers named `:T` and `:S`. (In the future, we could also allow the names of these buoyancy, temperature, and salinity tracers to be specified in the constructor for the respective buoyancy models, eg `SeawaterBuoyancy(temperature=:T, salinity=:S)`.). 2. The constructor for `ModelForcing` (which will have to be merged with #444 when it is approved) now allows the user to specify forcing for any of the tracer fields. If the user specifies a forcing for a tracer field that does not exist, an error is thrown. If a user does not specify a forcing for some tracer field, a default zero forcing is applied. 3. The same logic for `ModelForcing` applies to `BoundaryConditions` / `SolutionBoundaryConditions`. When boundary conditions for a tracer field are unspecified, a default tracer boundary condition is inferred from the x-velocity field: tracers either inherit `Periodic` boundary conditions, or are given a `Flux, Nothing` boundary condition for all other cases. 4. For closures, all tracer-diffusivity-related fields permit users to specify either:. * a constant (applied to all tracers), or ; * a `NamedTuple` with fields for *every* tracer. . In the future, we could possibly implement some mixed behavior where the user specifies both a default *and* particular values for tracer diffusivity. This would be useful in the (possibly rare) use-case of a large number of tracers with the same diffusivity, but where one or two of them require a special, different diffusivity. I am not sure this API is necessary so I left it for future work. Diffusivity-like fields include:. * `κ` (constant component of tracer diffusivity) for `ConstantIsotropicDif",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/452
https://github.com/CliMA/Oceananigans.jl/pull/452:3171,Testability,benchmark,benchmark,3171," some mixed behavior where the user specifies both a default *and* particular values for tracer diffusivity. This would be useful in the (possibly rare) use-case of a large number of tracers with the same diffusivity, but where one or two of them require a special, different diffusivity. I am not sure this API is necessary so I left it for future work. Diffusivity-like fields include:. * `κ` (constant component of tracer diffusivity) for `ConstantIsotropicDiffusivity`, `AnisotropicMinimumDissipation`, and `ConstantSmagorinsky`; * `Pr` (turbulent Prandtl number) for `ConstantSmagorinsky`; * `κh` and `κv` for `ConstantAnisotropicDiffusivity`. ## Internal algorithmic considerations. This implementation includes a major refactor of the time-stepping algorithm. In particular, kernels are launched for *each* tracer for all operations that involve tracers. This differs from the previous pattern, in which a single kernel was called in some cases (for example, to update the velocity and tracer fields, or to store previous source terms). The reason for this change is because I ran into some issues (dynamic function invocations) using `ntuple` to unroll a loop over tracers inside the kernel. In addition, I think that with a large number of tracers the kernels may become too large and their performance could degrade (but I'm not sure). This refactoring of the algorithm means we need to . - [ ] benchmark the changes in this PR to see if there are any significant changes in model performance. . @ali-ramadhan, can you help with this?. If there are changes in model performance, we can work on unrolling loops over the tracer fields *inside* our kernels. This is probably possible; it just requires some debugging. We would probably also want to make sure that this doesn't lead to poor performance for up to O(10) tracers. If any of this PR is not satisfactory, I'm happy to work on it and iterate until the PR is in mergeable shape. Resolves #25 ; Resolves #430 ; Partially addresses #448",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/452
https://github.com/CliMA/Oceananigans.jl/issues/453:73,Integrability,contract,contraction,73,"Rather than using `α` and `β` to denote the thermal expansion and saline contraction coefficients, we should probably just use `thermal_expansion` and `haline_contraction`. The syntax would then be. ```julia; eos = LinearEquationOfState(thermal_expansion=α, haline_contraction=β); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/453
https://github.com/CliMA/Oceananigans.jl/issues/455:795,Availability,down,downsides,795,"Currently we use a convention for fields wherein the ""halo points"" of a field stored on faces actually includes locations that are on the boundary of our domain. Is this strange? What I am saying, in other words, is that for the field `u = Field{Face, Cell, Cell}(arch, grid)`, the point. ```julia; u[grid.Nx+1, 1, 1]; ```. is defined as a ""halo point"", even though it is located *on* the right `x` boundary (it is inside the physical domain, not outside it). I think this is potentially odd and we should *consider* adopting the convention that `Face` fields include their boundary points by default. This would not change the algorithm; it only changes the user API. The reason why I recommend considering / discussing this change rather than immediately adopting it is because there are some downsides. One is a slight increase in memory allocation that is not needed. This is minor for large 3D problems but could be annoying for small 1D or 2D problems with ""flat"" dimensions. This last problem can potentially be solved by invoking special behavior for the ""flat"" dimensions of a grid (see #330).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/455
https://github.com/CliMA/Oceananigans.jl/issues/456:334,Usability,clear,clearer,334,"We may want to consider modularizing our code a bit more; for example we could have a `Diagnostics` module, an `OutputWriters` module, etc, with folders that correspond to the module name, and with module functionality split into multiple files. . This may make the source code more navigable and also create some opportunities for a clearer API, since we can selectively export different functionality from `Oceananigans` than from `Oceananigans.Diagnostics` (for example). In other words, we could write the API so that `using Oceananigans` brings only bare-bones diagnostics functionality into scope for users, while `using Oceananigans.Diagnostics` brings a full-fledged suite of diagnostics functionality into scope if that is desired.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/456
https://github.com/CliMA/Oceananigans.jl/issues/457:198,Performance,load,loading,198,"Our `Field` type may benefit from subtyping one of the many array types with named/dimensional axes out there in the julia ecosystem. This will permit some desirable behaviors for the manipulation, loading, output, and plotting of fields and slices of fields, and perhaps will also enable some nice behavior for online diagnostics. A good option could be `AbstractDimensionalArray` defined by. https://github.com/rafaqz/DimensionalData.jl. We'll have to figure out what functions and such we'd have to define to complete such an implementation.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/457
https://github.com/CliMA/Oceananigans.jl/issues/458:20,Safety,avoid,avoid,20,"We might be able to avoid the need for users to call the function `data` by dispatching on `Colon`:. ```julia; xindex(f, i) = i; xindex(f, ::Colon) = 1:f.grid.Nx. yindex(f, i) = i; yindex(f, ::Colon) = 1:f.grid.Ny. zindex(f, i) = i; zindex(f, ::Colon) = 1:f.grid.Nz. @inline getindex(f::Field, i, j, k) = getindex(f.data, xindex(f, i), yindex(f, j), zindex(f, k)); ```. Then things like. ```julia; imshow(model.velocities.u[:, 1, :]); ```. Will plot only the interior points of `u`, avoiding the need to write `imshow(data(model.velocities.u)[:, 1, :])`. Perhaps this is desirable? Or too surprising that indexing into a field is different from indexing into its `data`? I'm not sure how much we want users to be explicitly aware / interactive with halo regions. Note that in the future, we may also want to borrow the `Colon` type to mean ""all interior points"" for specifying things like slices --- or, come up with a different meaningful shorthand.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/458
https://github.com/CliMA/Oceananigans.jl/issues/458:483,Safety,avoid,avoiding,483,"We might be able to avoid the need for users to call the function `data` by dispatching on `Colon`:. ```julia; xindex(f, i) = i; xindex(f, ::Colon) = 1:f.grid.Nx. yindex(f, i) = i; yindex(f, ::Colon) = 1:f.grid.Ny. zindex(f, i) = i; zindex(f, ::Colon) = 1:f.grid.Nz. @inline getindex(f::Field, i, j, k) = getindex(f.data, xindex(f, i), yindex(f, j), zindex(f, k)); ```. Then things like. ```julia; imshow(model.velocities.u[:, 1, :]); ```. Will plot only the interior points of `u`, avoiding the need to write `imshow(data(model.velocities.u)[:, 1, :])`. Perhaps this is desirable? Or too surprising that indexing into a field is different from indexing into its `data`? I'm not sure how much we want users to be explicitly aware / interactive with halo regions. Note that in the future, we may also want to borrow the `Colon` type to mean ""all interior points"" for specifying things like slices --- or, come up with a different meaningful shorthand.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/458
https://github.com/CliMA/Oceananigans.jl/issues/459:220,Usability,simpl,simple,220,"@johncmarshall54 suggested it might be a bit dangerous to assume default boundary conditions, so they should always be specified. Worth discussing as this might apply to other model properties too. A common question for simple model setups is ""what are the boundary conditions?"".",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/459
https://github.com/CliMA/Oceananigans.jl/pull/462:87,Testability,test,tests,87,"This PR finally reverses the `k` index although it's still a work in progress as a few tests fail. In particular, it seems that incompressibility is not satisfied even though I managed to get the ""recomputing w from continuity"" test to pass. Need to think about this some more. Resolves #90; Resolves #468 ; Resolves #480",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/462
https://github.com/CliMA/Oceananigans.jl/pull/462:228,Testability,test,test,228,"This PR finally reverses the `k` index although it's still a work in progress as a few tests fail. In particular, it seems that incompressibility is not satisfied even though I managed to get the ""recomputing w from continuity"" test to pass. Need to think about this some more. Resolves #90; Resolves #468 ; Resolves #480",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/462
https://github.com/CliMA/Oceananigans.jl/pull/463:2767,Availability,down,down,2767,"irst* field involved. . This submodule also exports a macro `@at` for specifying the location of an operation. Therefore we can write. ```julia; julia> kinetic_energy = @at (Cell, Cell, Cell) (u^2 + v^2 + w^2) / 2;. julia> Oceananigans.location(kinetic_energy); (Cell, Cell, Cell); ```. `kinetic_enegy` has a deep nested structure that is difficult to interrogate. Therefore one speculative possible item to add to this PR is to write a. - [x] better `show` method for `Operations`, using some kind of tree visualization?; ; For the purposes of this PR description, we hack together a visualization of the structure of `kinetic_energy`:. ```julia; julia> (kinetic_energy.op, typeof(kinetic_energy.a).name.wrapper, kinetic_energy.b); (/, Oceananigans.AbstractOperations.PolynaryOperation, 2); ```. We see that `kinetic_energy`, at the top level, is ` BinaryOperation` between a `PolynaryOperation` and an integer (2), involving division `/` (which is indeed, what we wrote). Delving into the `PolynaryOperation` one level down, . ```julia; julia> kinetic_energy.a.op; + (generic function with 185 methods). julia> names = [typeof(a).name.wrapper for a in kinetic_energy.a.args]; 3-element Array{UnionAll,1}:; Oceananigans.AbstractOperations.BinaryOperation; Oceananigans.AbstractOperations.BinaryOperation; Oceananigans.AbstractOperations.BinaryOperation; ```. we find that it consists of a sum of three `BinaryOperations`. Finally, we see that each `BinaryOperation`,. ```; julia> names = [(a.op, typeof(a.a).name.wrapper, a.b) for a in kinetic_energy.a.args]; 3-element Array{Tuple{typeof(^),UnionAll,Int64},1}:; (^, OffsetArrays.OffsetArray, 2); (^, OffsetArrays.OffsetArray, 2); (^, OffsetArrays.OffsetArray, 2); ```. involves taking an `OffsetArray` (each of which holds the underlying data in `u, v, w`) to the power 2. Still, we index into it in the same way we index into other fields to obtain its data:. ```julia; julia> noise(x, y, z) = rand(). julia> [set!(ϕ, noise) for ϕ in (u, v, w)];. j",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463
https://github.com/CliMA/Oceananigans.jl/pull/463:3562,Energy Efficiency,power,power,3562,"ynaryOperation, 2); ```. We see that `kinetic_energy`, at the top level, is ` BinaryOperation` between a `PolynaryOperation` and an integer (2), involving division `/` (which is indeed, what we wrote). Delving into the `PolynaryOperation` one level down, . ```julia; julia> kinetic_energy.a.op; + (generic function with 185 methods). julia> names = [typeof(a).name.wrapper for a in kinetic_energy.a.args]; 3-element Array{UnionAll,1}:; Oceananigans.AbstractOperations.BinaryOperation; Oceananigans.AbstractOperations.BinaryOperation; Oceananigans.AbstractOperations.BinaryOperation; ```. we find that it consists of a sum of three `BinaryOperations`. Finally, we see that each `BinaryOperation`,. ```; julia> names = [(a.op, typeof(a.a).name.wrapper, a.b) for a in kinetic_energy.a.args]; 3-element Array{Tuple{typeof(^),UnionAll,Int64},1}:; (^, OffsetArrays.OffsetArray, 2); (^, OffsetArrays.OffsetArray, 2); (^, OffsetArrays.OffsetArray, 2); ```. involves taking an `OffsetArray` (each of which holds the underlying data in `u, v, w`) to the power 2. Still, we index into it in the same way we index into other fields to obtain its data:. ```julia; julia> noise(x, y, z) = rand(). julia> [set!(ϕ, noise) for ϕ in (u, v, w)];. julia> kinetic_energy[8, 8, 8]; 0.789860912635921; ```. # Special considerations. There are a few special rules to how operations are handled:. * A `BinaryOperation` between two fields at the same location is always performed at their common location;. * a `BinaryOperation` between a field and a number always takes place at the location of the field. These special rules override the specification of operator location via `@at`. Thus, for example, in the operation. ```julia; uv = @at (Cell, Cell, Cell) u * v + v^2; ```. the product `u*v` is computed at the cell center, while `v^2` is computed at the `v`-point `Cell, Face, Cell`, and afterwards interpolated to cell centers. This functionality is achieved by endowing `BinaryOperation` with three interpolation opera",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463
https://github.com/CliMA/Oceananigans.jl/pull/463:7321,Energy Efficiency,adapt,adapts,7321,"the original purpose of `data`. * This PR depends on the arbitrary tracers PR. The arbitrary tracers PR should be merged before this one. * To permit mixing `Function`s in with `Field`s and `Number`s in `AbstractOperations`, we also define a `FunctionField` type that acts like a field, but invokes a function to compute values at its location under the hood. This type probably needs more tests. We should also investigate whether this type can be used to specify things like background fields. A `FunctionField` can either be time-dependent and a function of `x, y, z, t` (achieved by allowing it to possess a reference to `clock`), or a static function of `x, y, z`. * This PR changes the result of a horizontal average to `HorizontalAverage.result` to provide a common terminology with `Computation`, as well as future reductions along other dimensions (previously the result of a horizontal average was called `profile`). * This PR adapts `Field` to work on the GPU (after the hard work of adapting all the `AbstractOperation`s to work on the GPU, this seemed trivial). That this works now should be tested. If it does indeed work and there is no loss of performance, we can eliminate a lot of cruft from our `time_step!`, and also use fields directly in `AbstractOperation`s (right now we extract the underlying `OffsetArray` instead). # In summary. Miraculously, tests pass on the GPU. However, this framework is quite general and powerful, so we need to . - [x] think carefully about the tests we need (and don't need). . And certainly before merging we also need. - [x] docstrings... . Also, it'd be nice to. - [x] use `AbstractOperation` to define useful output in an example. Some discussion may be warranted about what's exported from `AbstractOperations`; we almost always want to have `Face` and `Cell`, for example. Ultimately, I think it'd be nice to write `using Oceananigans.Fields, Oceananigans.AbstractOperators` to get what's needed for this purpose. But that's yet another futur",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463
https://github.com/CliMA/Oceananigans.jl/pull/463:7379,Energy Efficiency,adapt,adapting,7379,"the original purpose of `data`. * This PR depends on the arbitrary tracers PR. The arbitrary tracers PR should be merged before this one. * To permit mixing `Function`s in with `Field`s and `Number`s in `AbstractOperations`, we also define a `FunctionField` type that acts like a field, but invokes a function to compute values at its location under the hood. This type probably needs more tests. We should also investigate whether this type can be used to specify things like background fields. A `FunctionField` can either be time-dependent and a function of `x, y, z, t` (achieved by allowing it to possess a reference to `clock`), or a static function of `x, y, z`. * This PR changes the result of a horizontal average to `HorizontalAverage.result` to provide a common terminology with `Computation`, as well as future reductions along other dimensions (previously the result of a horizontal average was called `profile`). * This PR adapts `Field` to work on the GPU (after the hard work of adapting all the `AbstractOperation`s to work on the GPU, this seemed trivial). That this works now should be tested. If it does indeed work and there is no loss of performance, we can eliminate a lot of cruft from our `time_step!`, and also use fields directly in `AbstractOperation`s (right now we extract the underlying `OffsetArray` instead). # In summary. Miraculously, tests pass on the GPU. However, this framework is quite general and powerful, so we need to . - [x] think carefully about the tests we need (and don't need). . And certainly before merging we also need. - [x] docstrings... . Also, it'd be nice to. - [x] use `AbstractOperation` to define useful output in an example. Some discussion may be warranted about what's exported from `AbstractOperations`; we almost always want to have `Face` and `Cell`, for example. Ultimately, I think it'd be nice to write `using Oceananigans.Fields, Oceananigans.AbstractOperators` to get what's needed for this purpose. But that's yet another futur",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463
https://github.com/CliMA/Oceananigans.jl/pull/463:7822,Energy Efficiency,power,powerful,7822,"th `Field`s and `Number`s in `AbstractOperations`, we also define a `FunctionField` type that acts like a field, but invokes a function to compute values at its location under the hood. This type probably needs more tests. We should also investigate whether this type can be used to specify things like background fields. A `FunctionField` can either be time-dependent and a function of `x, y, z, t` (achieved by allowing it to possess a reference to `clock`), or a static function of `x, y, z`. * This PR changes the result of a horizontal average to `HorizontalAverage.result` to provide a common terminology with `Computation`, as well as future reductions along other dimensions (previously the result of a horizontal average was called `profile`). * This PR adapts `Field` to work on the GPU (after the hard work of adapting all the `AbstractOperation`s to work on the GPU, this seemed trivial). That this works now should be tested. If it does indeed work and there is no loss of performance, we can eliminate a lot of cruft from our `time_step!`, and also use fields directly in `AbstractOperation`s (right now we extract the underlying `OffsetArray` instead). # In summary. Miraculously, tests pass on the GPU. However, this framework is quite general and powerful, so we need to . - [x] think carefully about the tests we need (and don't need). . And certainly before merging we also need. - [x] docstrings... . Also, it'd be nice to. - [x] use `AbstractOperation` to define useful output in an example. Some discussion may be warranted about what's exported from `AbstractOperations`; we almost always want to have `Face` and `Cell`, for example. Ultimately, I think it'd be nice to write `using Oceananigans.Fields, Oceananigans.AbstractOperators` to get what's needed for this purpose. But that's yet another future PR. I hope this sparks some discussion about the future of the `Field` abstraction as well. I think it has the potential to be quite powerful. Resolves #454 ; Resolves #428",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463
https://github.com/CliMA/Oceananigans.jl/pull/463:8519,Energy Efficiency,power,powerful,8519,"th `Field`s and `Number`s in `AbstractOperations`, we also define a `FunctionField` type that acts like a field, but invokes a function to compute values at its location under the hood. This type probably needs more tests. We should also investigate whether this type can be used to specify things like background fields. A `FunctionField` can either be time-dependent and a function of `x, y, z, t` (achieved by allowing it to possess a reference to `clock`), or a static function of `x, y, z`. * This PR changes the result of a horizontal average to `HorizontalAverage.result` to provide a common terminology with `Computation`, as well as future reductions along other dimensions (previously the result of a horizontal average was called `profile`). * This PR adapts `Field` to work on the GPU (after the hard work of adapting all the `AbstractOperation`s to work on the GPU, this seemed trivial). That this works now should be tested. If it does indeed work and there is no loss of performance, we can eliminate a lot of cruft from our `time_step!`, and also use fields directly in `AbstractOperation`s (right now we extract the underlying `OffsetArray` instead). # In summary. Miraculously, tests pass on the GPU. However, this framework is quite general and powerful, so we need to . - [x] think carefully about the tests we need (and don't need). . And certainly before merging we also need. - [x] docstrings... . Also, it'd be nice to. - [x] use `AbstractOperation` to define useful output in an example. Some discussion may be warranted about what's exported from `AbstractOperations`; we almost always want to have `Face` and `Cell`, for example. Ultimately, I think it'd be nice to write `using Oceananigans.Fields, Oceananigans.AbstractOperators` to get what's needed for this purpose. But that's yet another future PR. I hope this sparks some discussion about the future of the `Field` abstraction as well. I think it has the potential to be quite powerful. Resolves #454 ; Resolves #428",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463
https://github.com/CliMA/Oceananigans.jl/pull/463:1011,Integrability,wrap,wrapper,1011,"R introduces `AbstractOperation`s for constructing 3D expressions with a friendly syntax (eg, not writing kernels), which can then be evaluated online during a simulation for diagnostics / output purposes. This PR introduces four kinds of `AbstractOperation`s:. 1. `Derivative` (things like `∂x`, `∂y`); 2. `BinaryOperation` (things like `a-b`, `a^b`); 3. `UnaryOperation` (things like `sqrt`, `sin`, `cos`); 4. `PolynaryOperation` (things like `a + b + c + d` or `a * b * c * d`). All of these act on combinations of `Field`, `Function`, and `Number`. `. `AbstractOperation`s arise from what appears to be ordinary arithmetic and calculus performed on `Field`s. Consider this example:. ```julia; julia> using Oceananigans; using Oceananigans: Face, Cell; using Oceananigans.AbstractOperations. grid = RegularCartesianGrid((16, 16, 16), (16, 16, 16));; a = Field(Cell, Cell, Cell, CPU(), grid);; b = Field(Cell, Cell, Cell, CPU(), grid);; a_times_b = a * b;. julia> typeof(a_times_b).name.wrapper; Oceananigans.AbstractOperations.BinaryOperation; ```. Here, the object `a_times_b` is of the type `BinaryOperation`. `a_times_b` can be indexed into like an array or field, however:. ```julia; julia> a_times_b[8, 8, 8]; 0.0. set!(a, rand(size(grid)...)); set!(b, rand(size(grid)...)). julia> a_times_b[8, 8, 8]; 0.5342645056606357; ```. # Staggered grids, interpolation, and operation ""location"". Operations can also be defined between fields at different locations in the staggered grid:. ```julia; julia> u, v, w = Oceananigans.VelocityFields(CPU(), grid);. julia> u_times_v = u * v;. julia> Oceananigans.location(u_times_v); (Face, Cell, Cell); ```. Note that the location of an operation defaults to the location of the *first* field involved. . This submodule also exports a macro `@at` for specifying the location of an operation. Therefore we can write. ```julia; julia> kinetic_energy = @at (Cell, Cell, Cell) (u^2 + v^2 + w^2) / 2;. julia> Oceananigans.location(kinetic_energy); (Cell, Cell, C",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463
https://github.com/CliMA/Oceananigans.jl/pull/463:2451,Integrability,wrap,wrapper,2451,"at different locations in the staggered grid:. ```julia; julia> u, v, w = Oceananigans.VelocityFields(CPU(), grid);. julia> u_times_v = u * v;. julia> Oceananigans.location(u_times_v); (Face, Cell, Cell); ```. Note that the location of an operation defaults to the location of the *first* field involved. . This submodule also exports a macro `@at` for specifying the location of an operation. Therefore we can write. ```julia; julia> kinetic_energy = @at (Cell, Cell, Cell) (u^2 + v^2 + w^2) / 2;. julia> Oceananigans.location(kinetic_energy); (Cell, Cell, Cell); ```. `kinetic_enegy` has a deep nested structure that is difficult to interrogate. Therefore one speculative possible item to add to this PR is to write a. - [x] better `show` method for `Operations`, using some kind of tree visualization?; ; For the purposes of this PR description, we hack together a visualization of the structure of `kinetic_energy`:. ```julia; julia> (kinetic_energy.op, typeof(kinetic_energy.a).name.wrapper, kinetic_energy.b); (/, Oceananigans.AbstractOperations.PolynaryOperation, 2); ```. We see that `kinetic_energy`, at the top level, is ` BinaryOperation` between a `PolynaryOperation` and an integer (2), involving division `/` (which is indeed, what we wrote). Delving into the `PolynaryOperation` one level down, . ```julia; julia> kinetic_energy.a.op; + (generic function with 185 methods). julia> names = [typeof(a).name.wrapper for a in kinetic_energy.a.args]; 3-element Array{UnionAll,1}:; Oceananigans.AbstractOperations.BinaryOperation; Oceananigans.AbstractOperations.BinaryOperation; Oceananigans.AbstractOperations.BinaryOperation; ```. we find that it consists of a sum of three `BinaryOperations`. Finally, we see that each `BinaryOperation`,. ```; julia> names = [(a.op, typeof(a.a).name.wrapper, a.b) for a in kinetic_energy.a.args]; 3-element Array{Tuple{typeof(^),UnionAll,Int64},1}:; (^, OffsetArrays.OffsetArray, 2); (^, OffsetArrays.OffsetArray, 2); (^, OffsetArrays.OffsetArray, 2); `",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463
https://github.com/CliMA/Oceananigans.jl/pull/463:2883,Integrability,wrap,wrapper,2883,"inetic_energy = @at (Cell, Cell, Cell) (u^2 + v^2 + w^2) / 2;. julia> Oceananigans.location(kinetic_energy); (Cell, Cell, Cell); ```. `kinetic_enegy` has a deep nested structure that is difficult to interrogate. Therefore one speculative possible item to add to this PR is to write a. - [x] better `show` method for `Operations`, using some kind of tree visualization?; ; For the purposes of this PR description, we hack together a visualization of the structure of `kinetic_energy`:. ```julia; julia> (kinetic_energy.op, typeof(kinetic_energy.a).name.wrapper, kinetic_energy.b); (/, Oceananigans.AbstractOperations.PolynaryOperation, 2); ```. We see that `kinetic_energy`, at the top level, is ` BinaryOperation` between a `PolynaryOperation` and an integer (2), involving division `/` (which is indeed, what we wrote). Delving into the `PolynaryOperation` one level down, . ```julia; julia> kinetic_energy.a.op; + (generic function with 185 methods). julia> names = [typeof(a).name.wrapper for a in kinetic_energy.a.args]; 3-element Array{UnionAll,1}:; Oceananigans.AbstractOperations.BinaryOperation; Oceananigans.AbstractOperations.BinaryOperation; Oceananigans.AbstractOperations.BinaryOperation; ```. we find that it consists of a sum of three `BinaryOperations`. Finally, we see that each `BinaryOperation`,. ```; julia> names = [(a.op, typeof(a.a).name.wrapper, a.b) for a in kinetic_energy.a.args]; 3-element Array{Tuple{typeof(^),UnionAll,Int64},1}:; (^, OffsetArrays.OffsetArray, 2); (^, OffsetArrays.OffsetArray, 2); (^, OffsetArrays.OffsetArray, 2); ```. involves taking an `OffsetArray` (each of which holds the underlying data in `u, v, w`) to the power 2. Still, we index into it in the same way we index into other fields to obtain its data:. ```julia; julia> noise(x, y, z) = rand(). julia> [set!(ϕ, noise) for ϕ in (u, v, w)];. julia> kinetic_energy[8, 8, 8]; 0.789860912635921; ```. # Special considerations. There are a few special rules to how operations are handled:. * A `Bina",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463
https://github.com/CliMA/Oceananigans.jl/pull/463:3260,Integrability,wrap,wrapper,3260,"n?; ; For the purposes of this PR description, we hack together a visualization of the structure of `kinetic_energy`:. ```julia; julia> (kinetic_energy.op, typeof(kinetic_energy.a).name.wrapper, kinetic_energy.b); (/, Oceananigans.AbstractOperations.PolynaryOperation, 2); ```. We see that `kinetic_energy`, at the top level, is ` BinaryOperation` between a `PolynaryOperation` and an integer (2), involving division `/` (which is indeed, what we wrote). Delving into the `PolynaryOperation` one level down, . ```julia; julia> kinetic_energy.a.op; + (generic function with 185 methods). julia> names = [typeof(a).name.wrapper for a in kinetic_energy.a.args]; 3-element Array{UnionAll,1}:; Oceananigans.AbstractOperations.BinaryOperation; Oceananigans.AbstractOperations.BinaryOperation; Oceananigans.AbstractOperations.BinaryOperation; ```. we find that it consists of a sum of three `BinaryOperations`. Finally, we see that each `BinaryOperation`,. ```; julia> names = [(a.op, typeof(a.a).name.wrapper, a.b) for a in kinetic_energy.a.args]; 3-element Array{Tuple{typeof(^),UnionAll,Int64},1}:; (^, OffsetArrays.OffsetArray, 2); (^, OffsetArrays.OffsetArray, 2); (^, OffsetArrays.OffsetArray, 2); ```. involves taking an `OffsetArray` (each of which holds the underlying data in `u, v, w`) to the power 2. Still, we index into it in the same way we index into other fields to obtain its data:. ```julia; julia> noise(x, y, z) = rand(). julia> [set!(ϕ, noise) for ϕ in (u, v, w)];. julia> kinetic_energy[8, 8, 8]; 0.789860912635921; ```. # Special considerations. There are a few special rules to how operations are handled:. * A `BinaryOperation` between two fields at the same location is always performed at their common location;. * a `BinaryOperation` between a field and a number always takes place at the location of the field. These special rules override the specification of operator location via `@at`. Thus, for example, in the operation. ```julia; uv = @at (Cell, Cell, Cell) u * v + v^2; ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463
https://github.com/CliMA/Oceananigans.jl/pull/463:5080,Integrability,wrap,wrapper,5080," field. These special rules override the specification of operator location via `@at`. Thus, for example, in the operation. ```julia; uv = @at (Cell, Cell, Cell) u * v + v^2; ```. the product `u*v` is computed at the cell center, while `v^2` is computed at the `v`-point `Cell, Face, Cell`, and afterwards interpolated to cell centers. This functionality is achieved by endowing `BinaryOperation` with three interpolation operators: two interpolation operators applied to each field prior to interpolation, and an interpolation operator that is applied to the result. Special cases can then be handled by defining operators for cases in which a computation should be performed at the location of one or both of the fields. Furthermore, we do not provide `PolynaryOperation`s with default locations. In other words, a `PolynaryOperation` only arises when location is specified, eg:. ```julia; julia> op1 = u + v + w;. julia> op2 = @at (Cell, Cell, Cell) u + v + w;. julia> typeof(op1).name.wrapper; Oceananigans.AbstractOperations.BinaryOperation. julia> typeof(op2).name.wrapper; Oceananigans.AbstractOperations.PolynaryOperation; ```. This also means that all fields in a `PolynaryOperation` are interpolated *prior* to computation. # Computations. This PR also adds a type for making ""computations"" with an `AbstractOperation`. We call this a `Computation`. From the tests:. ```julia; T, S = model.tracers; computation = Computation(S + T, model.pressures.pHY′); compute!(computation); ```. which launches a 3D kernel to compute the result of an `AbstractOperation` at every grid point, storing the result in `computation.result` (which here has been defined as `model.pressures.pHY′`). We also extend `HorizontalAverage` to work with `Computation`, (and add a constructor that constructs a `Computation` from an `AbstractOperation` and `Model`), eg. ```julia; T, S = model.tracers; ST = HorizontalAverage(S + T, model); computed_profile = ST(model); ```. Calling `run_diagnostic` for `HorizontalAv",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463
https://github.com/CliMA/Oceananigans.jl/pull/463:5162,Integrability,wrap,wrapper,5162,"at`. Thus, for example, in the operation. ```julia; uv = @at (Cell, Cell, Cell) u * v + v^2; ```. the product `u*v` is computed at the cell center, while `v^2` is computed at the `v`-point `Cell, Face, Cell`, and afterwards interpolated to cell centers. This functionality is achieved by endowing `BinaryOperation` with three interpolation operators: two interpolation operators applied to each field prior to interpolation, and an interpolation operator that is applied to the result. Special cases can then be handled by defining operators for cases in which a computation should be performed at the location of one or both of the fields. Furthermore, we do not provide `PolynaryOperation`s with default locations. In other words, a `PolynaryOperation` only arises when location is specified, eg:. ```julia; julia> op1 = u + v + w;. julia> op2 = @at (Cell, Cell, Cell) u + v + w;. julia> typeof(op1).name.wrapper; Oceananigans.AbstractOperations.BinaryOperation. julia> typeof(op2).name.wrapper; Oceananigans.AbstractOperations.PolynaryOperation; ```. This also means that all fields in a `PolynaryOperation` are interpolated *prior* to computation. # Computations. This PR also adds a type for making ""computations"" with an `AbstractOperation`. We call this a `Computation`. From the tests:. ```julia; T, S = model.tracers; computation = Computation(S + T, model.pressures.pHY′); compute!(computation); ```. which launches a 3D kernel to compute the result of an `AbstractOperation` at every grid point, storing the result in `computation.result` (which here has been defined as `model.pressures.pHY′`). We also extend `HorizontalAverage` to work with `Computation`, (and add a constructor that constructs a `Computation` from an `AbstractOperation` and `Model`), eg. ```julia; T, S = model.tracers; ST = HorizontalAverage(S + T, model); computed_profile = ST(model); ```. Calling `run_diagnostic` for `HorizontalAverage{<:Computation}` first calls `compute!(computation)`, and then compute the ho",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463
https://github.com/CliMA/Oceananigans.jl/pull/463:6426,Integrability,depend,depends,6426,"omputation`. From the tests:. ```julia; T, S = model.tracers; computation = Computation(S + T, model.pressures.pHY′); compute!(computation); ```. which launches a 3D kernel to compute the result of an `AbstractOperation` at every grid point, storing the result in `computation.result` (which here has been defined as `model.pressures.pHY′`). We also extend `HorizontalAverage` to work with `Computation`, (and add a constructor that constructs a `Computation` from an `AbstractOperation` and `Model`), eg. ```julia; T, S = model.tracers; ST = HorizontalAverage(S + T, model); computed_profile = ST(model); ```. Calling `run_diagnostic` for `HorizontalAverage{<:Computation}` first calls `compute!(computation)`, and then compute the horizontal average of `computation.result`. # Some important details. * This PR changes the meaning of `data`, which is used extensively in forming operations. This resolves #454. A new function `interior` serves the original purpose of `data`. * This PR depends on the arbitrary tracers PR. The arbitrary tracers PR should be merged before this one. * To permit mixing `Function`s in with `Field`s and `Number`s in `AbstractOperations`, we also define a `FunctionField` type that acts like a field, but invokes a function to compute values at its location under the hood. This type probably needs more tests. We should also investigate whether this type can be used to specify things like background fields. A `FunctionField` can either be time-dependent and a function of `x, y, z, t` (achieved by allowing it to possess a reference to `clock`), or a static function of `x, y, z`. * This PR changes the result of a horizontal average to `HorizontalAverage.result` to provide a common terminology with `Computation`, as well as future reductions along other dimensions (previously the result of a horizontal average was called `profile`). * This PR adapts `Field` to work on the GPU (after the hard work of adapting all the `AbstractOperation`s to work on the GPU, th",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463
https://github.com/CliMA/Oceananigans.jl/pull/463:6917,Integrability,depend,dependent,6917,".tracers; ST = HorizontalAverage(S + T, model); computed_profile = ST(model); ```. Calling `run_diagnostic` for `HorizontalAverage{<:Computation}` first calls `compute!(computation)`, and then compute the horizontal average of `computation.result`. # Some important details. * This PR changes the meaning of `data`, which is used extensively in forming operations. This resolves #454. A new function `interior` serves the original purpose of `data`. * This PR depends on the arbitrary tracers PR. The arbitrary tracers PR should be merged before this one. * To permit mixing `Function`s in with `Field`s and `Number`s in `AbstractOperations`, we also define a `FunctionField` type that acts like a field, but invokes a function to compute values at its location under the hood. This type probably needs more tests. We should also investigate whether this type can be used to specify things like background fields. A `FunctionField` can either be time-dependent and a function of `x, y, z, t` (achieved by allowing it to possess a reference to `clock`), or a static function of `x, y, z`. * This PR changes the result of a horizontal average to `HorizontalAverage.result` to provide a common terminology with `Computation`, as well as future reductions along other dimensions (previously the result of a horizontal average was called `profile`). * This PR adapts `Field` to work on the GPU (after the hard work of adapting all the `AbstractOperation`s to work on the GPU, this seemed trivial). That this works now should be tested. If it does indeed work and there is no loss of performance, we can eliminate a lot of cruft from our `time_step!`, and also use fields directly in `AbstractOperation`s (right now we extract the underlying `OffsetArray` instead). # In summary. Miraculously, tests pass on the GPU. However, this framework is quite general and powerful, so we need to . - [x] think carefully about the tests we need (and don't need). . And certainly before merging we also need. - [x] doc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463
https://github.com/CliMA/Oceananigans.jl/pull/463:5788,Modifiability,extend,extend,5788,"on`s with default locations. In other words, a `PolynaryOperation` only arises when location is specified, eg:. ```julia; julia> op1 = u + v + w;. julia> op2 = @at (Cell, Cell, Cell) u + v + w;. julia> typeof(op1).name.wrapper; Oceananigans.AbstractOperations.BinaryOperation. julia> typeof(op2).name.wrapper; Oceananigans.AbstractOperations.PolynaryOperation; ```. This also means that all fields in a `PolynaryOperation` are interpolated *prior* to computation. # Computations. This PR also adds a type for making ""computations"" with an `AbstractOperation`. We call this a `Computation`. From the tests:. ```julia; T, S = model.tracers; computation = Computation(S + T, model.pressures.pHY′); compute!(computation); ```. which launches a 3D kernel to compute the result of an `AbstractOperation` at every grid point, storing the result in `computation.result` (which here has been defined as `model.pressures.pHY′`). We also extend `HorizontalAverage` to work with `Computation`, (and add a constructor that constructs a `Computation` from an `AbstractOperation` and `Model`), eg. ```julia; T, S = model.tracers; ST = HorizontalAverage(S + T, model); computed_profile = ST(model); ```. Calling `run_diagnostic` for `HorizontalAverage{<:Computation}` first calls `compute!(computation)`, and then compute the horizontal average of `computation.result`. # Some important details. * This PR changes the meaning of `data`, which is used extensively in forming operations. This resolves #454. A new function `interior` serves the original purpose of `data`. * This PR depends on the arbitrary tracers PR. The arbitrary tracers PR should be merged before this one. * To permit mixing `Function`s in with `Field`s and `Number`s in `AbstractOperations`, we also define a `FunctionField` type that acts like a field, but invokes a function to compute values at its location under the hood. This type probably needs more tests. We should also investigate whether this type can be used to specify things like ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463
https://github.com/CliMA/Oceananigans.jl/pull/463:7321,Modifiability,adapt,adapts,7321,"the original purpose of `data`. * This PR depends on the arbitrary tracers PR. The arbitrary tracers PR should be merged before this one. * To permit mixing `Function`s in with `Field`s and `Number`s in `AbstractOperations`, we also define a `FunctionField` type that acts like a field, but invokes a function to compute values at its location under the hood. This type probably needs more tests. We should also investigate whether this type can be used to specify things like background fields. A `FunctionField` can either be time-dependent and a function of `x, y, z, t` (achieved by allowing it to possess a reference to `clock`), or a static function of `x, y, z`. * This PR changes the result of a horizontal average to `HorizontalAverage.result` to provide a common terminology with `Computation`, as well as future reductions along other dimensions (previously the result of a horizontal average was called `profile`). * This PR adapts `Field` to work on the GPU (after the hard work of adapting all the `AbstractOperation`s to work on the GPU, this seemed trivial). That this works now should be tested. If it does indeed work and there is no loss of performance, we can eliminate a lot of cruft from our `time_step!`, and also use fields directly in `AbstractOperation`s (right now we extract the underlying `OffsetArray` instead). # In summary. Miraculously, tests pass on the GPU. However, this framework is quite general and powerful, so we need to . - [x] think carefully about the tests we need (and don't need). . And certainly before merging we also need. - [x] docstrings... . Also, it'd be nice to. - [x] use `AbstractOperation` to define useful output in an example. Some discussion may be warranted about what's exported from `AbstractOperations`; we almost always want to have `Face` and `Cell`, for example. Ultimately, I think it'd be nice to write `using Oceananigans.Fields, Oceananigans.AbstractOperators` to get what's needed for this purpose. But that's yet another futur",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463
https://github.com/CliMA/Oceananigans.jl/pull/463:7379,Modifiability,adapt,adapting,7379,"the original purpose of `data`. * This PR depends on the arbitrary tracers PR. The arbitrary tracers PR should be merged before this one. * To permit mixing `Function`s in with `Field`s and `Number`s in `AbstractOperations`, we also define a `FunctionField` type that acts like a field, but invokes a function to compute values at its location under the hood. This type probably needs more tests. We should also investigate whether this type can be used to specify things like background fields. A `FunctionField` can either be time-dependent and a function of `x, y, z, t` (achieved by allowing it to possess a reference to `clock`), or a static function of `x, y, z`. * This PR changes the result of a horizontal average to `HorizontalAverage.result` to provide a common terminology with `Computation`, as well as future reductions along other dimensions (previously the result of a horizontal average was called `profile`). * This PR adapts `Field` to work on the GPU (after the hard work of adapting all the `AbstractOperation`s to work on the GPU, this seemed trivial). That this works now should be tested. If it does indeed work and there is no loss of performance, we can eliminate a lot of cruft from our `time_step!`, and also use fields directly in `AbstractOperation`s (right now we extract the underlying `OffsetArray` instead). # In summary. Miraculously, tests pass on the GPU. However, this framework is quite general and powerful, so we need to . - [x] think carefully about the tests we need (and don't need). . And certainly before merging we also need. - [x] docstrings... . Also, it'd be nice to. - [x] use `AbstractOperation` to define useful output in an example. Some discussion may be warranted about what's exported from `AbstractOperations`; we almost always want to have `Face` and `Cell`, for example. Ultimately, I think it'd be nice to write `using Oceananigans.Fields, Oceananigans.AbstractOperators` to get what's needed for this purpose. But that's yet another futur",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463
https://github.com/CliMA/Oceananigans.jl/pull/463:662,Performance,perform,performed,662,"# Introduction. This PR introduces `AbstractOperation`s for constructing 3D expressions with a friendly syntax (eg, not writing kernels), which can then be evaluated online during a simulation for diagnostics / output purposes. This PR introduces four kinds of `AbstractOperation`s:. 1. `Derivative` (things like `∂x`, `∂y`); 2. `BinaryOperation` (things like `a-b`, `a^b`); 3. `UnaryOperation` (things like `sqrt`, `sin`, `cos`); 4. `PolynaryOperation` (things like `a + b + c + d` or `a * b * c * d`). All of these act on combinations of `Field`, `Function`, and `Number`. `. `AbstractOperation`s arise from what appears to be ordinary arithmetic and calculus performed on `Field`s. Consider this example:. ```julia; julia> using Oceananigans; using Oceananigans: Face, Cell; using Oceananigans.AbstractOperations. grid = RegularCartesianGrid((16, 16, 16), (16, 16, 16));; a = Field(Cell, Cell, Cell, CPU(), grid);; b = Field(Cell, Cell, Cell, CPU(), grid);; a_times_b = a * b;. julia> typeof(a_times_b).name.wrapper; Oceananigans.AbstractOperations.BinaryOperation; ```. Here, the object `a_times_b` is of the type `BinaryOperation`. `a_times_b` can be indexed into like an array or field, however:. ```julia; julia> a_times_b[8, 8, 8]; 0.0. set!(a, rand(size(grid)...)); set!(b, rand(size(grid)...)). julia> a_times_b[8, 8, 8]; 0.5342645056606357; ```. # Staggered grids, interpolation, and operation ""location"". Operations can also be defined between fields at different locations in the staggered grid:. ```julia; julia> u, v, w = Oceananigans.VelocityFields(CPU(), grid);. julia> u_times_v = u * v;. julia> Oceananigans.location(u_times_v); (Face, Cell, Cell); ```. Note that the location of an operation defaults to the location of the *first* field involved. . This submodule also exports a macro `@at` for specifying the location of an operation. Therefore we can write. ```julia; julia> kinetic_energy = @at (Cell, Cell, Cell) (u^2 + v^2 + w^2) / 2;. julia> Oceananigans.location(kinetic_en",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463
https://github.com/CliMA/Oceananigans.jl/pull/463:3962,Performance,perform,performed,3962,"onAll,1}:; Oceananigans.AbstractOperations.BinaryOperation; Oceananigans.AbstractOperations.BinaryOperation; Oceananigans.AbstractOperations.BinaryOperation; ```. we find that it consists of a sum of three `BinaryOperations`. Finally, we see that each `BinaryOperation`,. ```; julia> names = [(a.op, typeof(a.a).name.wrapper, a.b) for a in kinetic_energy.a.args]; 3-element Array{Tuple{typeof(^),UnionAll,Int64},1}:; (^, OffsetArrays.OffsetArray, 2); (^, OffsetArrays.OffsetArray, 2); (^, OffsetArrays.OffsetArray, 2); ```. involves taking an `OffsetArray` (each of which holds the underlying data in `u, v, w`) to the power 2. Still, we index into it in the same way we index into other fields to obtain its data:. ```julia; julia> noise(x, y, z) = rand(). julia> [set!(ϕ, noise) for ϕ in (u, v, w)];. julia> kinetic_energy[8, 8, 8]; 0.789860912635921; ```. # Special considerations. There are a few special rules to how operations are handled:. * A `BinaryOperation` between two fields at the same location is always performed at their common location;. * a `BinaryOperation` between a field and a number always takes place at the location of the field. These special rules override the specification of operator location via `@at`. Thus, for example, in the operation. ```julia; uv = @at (Cell, Cell, Cell) u * v + v^2; ```. the product `u*v` is computed at the cell center, while `v^2` is computed at the `v`-point `Cell, Face, Cell`, and afterwards interpolated to cell centers. This functionality is achieved by endowing `BinaryOperation` with three interpolation operators: two interpolation operators applied to each field prior to interpolation, and an interpolation operator that is applied to the result. Special cases can then be handled by defining operators for cases in which a computation should be performed at the location of one or both of the fields. Furthermore, we do not provide `PolynaryOperation`s with default locations. In other words, a `PolynaryOperation` only arises when",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463
https://github.com/CliMA/Oceananigans.jl/pull/463:4758,Performance,perform,performed,4758,", v, w)];. julia> kinetic_energy[8, 8, 8]; 0.789860912635921; ```. # Special considerations. There are a few special rules to how operations are handled:. * A `BinaryOperation` between two fields at the same location is always performed at their common location;. * a `BinaryOperation` between a field and a number always takes place at the location of the field. These special rules override the specification of operator location via `@at`. Thus, for example, in the operation. ```julia; uv = @at (Cell, Cell, Cell) u * v + v^2; ```. the product `u*v` is computed at the cell center, while `v^2` is computed at the `v`-point `Cell, Face, Cell`, and afterwards interpolated to cell centers. This functionality is achieved by endowing `BinaryOperation` with three interpolation operators: two interpolation operators applied to each field prior to interpolation, and an interpolation operator that is applied to the result. Special cases can then be handled by defining operators for cases in which a computation should be performed at the location of one or both of the fields. Furthermore, we do not provide `PolynaryOperation`s with default locations. In other words, a `PolynaryOperation` only arises when location is specified, eg:. ```julia; julia> op1 = u + v + w;. julia> op2 = @at (Cell, Cell, Cell) u + v + w;. julia> typeof(op1).name.wrapper; Oceananigans.AbstractOperations.BinaryOperation. julia> typeof(op2).name.wrapper; Oceananigans.AbstractOperations.PolynaryOperation; ```. This also means that all fields in a `PolynaryOperation` are interpolated *prior* to computation. # Computations. This PR also adds a type for making ""computations"" with an `AbstractOperation`. We call this a `Computation`. From the tests:. ```julia; T, S = model.tracers; computation = Computation(S + T, model.pressures.pHY′); compute!(computation); ```. which launches a 3D kernel to compute the result of an `AbstractOperation` at every grid point, storing the result in `computation.result` (which here h",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463
https://github.com/CliMA/Oceananigans.jl/pull/463:7544,Performance,perform,performance,7544,"th `Field`s and `Number`s in `AbstractOperations`, we also define a `FunctionField` type that acts like a field, but invokes a function to compute values at its location under the hood. This type probably needs more tests. We should also investigate whether this type can be used to specify things like background fields. A `FunctionField` can either be time-dependent and a function of `x, y, z, t` (achieved by allowing it to possess a reference to `clock`), or a static function of `x, y, z`. * This PR changes the result of a horizontal average to `HorizontalAverage.result` to provide a common terminology with `Computation`, as well as future reductions along other dimensions (previously the result of a horizontal average was called `profile`). * This PR adapts `Field` to work on the GPU (after the hard work of adapting all the `AbstractOperation`s to work on the GPU, this seemed trivial). That this works now should be tested. If it does indeed work and there is no loss of performance, we can eliminate a lot of cruft from our `time_step!`, and also use fields directly in `AbstractOperation`s (right now we extract the underlying `OffsetArray` instead). # In summary. Miraculously, tests pass on the GPU. However, this framework is quite general and powerful, so we need to . - [x] think carefully about the tests we need (and don't need). . And certainly before merging we also need. - [x] docstrings... . Also, it'd be nice to. - [x] use `AbstractOperation` to define useful output in an example. Some discussion may be warranted about what's exported from `AbstractOperations`; we almost always want to have `Face` and `Cell`, for example. Ultimately, I think it'd be nice to write `using Oceananigans.Fields, Oceananigans.AbstractOperators` to get what's needed for this purpose. But that's yet another future PR. I hope this sparks some discussion about the future of the `Field` abstraction as well. I think it has the potential to be quite powerful. Resolves #454 ; Resolves #428",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463
https://github.com/CliMA/Oceananigans.jl/pull/463:5460,Testability,test,tests,5460,"by endowing `BinaryOperation` with three interpolation operators: two interpolation operators applied to each field prior to interpolation, and an interpolation operator that is applied to the result. Special cases can then be handled by defining operators for cases in which a computation should be performed at the location of one or both of the fields. Furthermore, we do not provide `PolynaryOperation`s with default locations. In other words, a `PolynaryOperation` only arises when location is specified, eg:. ```julia; julia> op1 = u + v + w;. julia> op2 = @at (Cell, Cell, Cell) u + v + w;. julia> typeof(op1).name.wrapper; Oceananigans.AbstractOperations.BinaryOperation. julia> typeof(op2).name.wrapper; Oceananigans.AbstractOperations.PolynaryOperation; ```. This also means that all fields in a `PolynaryOperation` are interpolated *prior* to computation. # Computations. This PR also adds a type for making ""computations"" with an `AbstractOperation`. We call this a `Computation`. From the tests:. ```julia; T, S = model.tracers; computation = Computation(S + T, model.pressures.pHY′); compute!(computation); ```. which launches a 3D kernel to compute the result of an `AbstractOperation` at every grid point, storing the result in `computation.result` (which here has been defined as `model.pressures.pHY′`). We also extend `HorizontalAverage` to work with `Computation`, (and add a constructor that constructs a `Computation` from an `AbstractOperation` and `Model`), eg. ```julia; T, S = model.tracers; ST = HorizontalAverage(S + T, model); computed_profile = ST(model); ```. Calling `run_diagnostic` for `HorizontalAverage{<:Computation}` first calls `compute!(computation)`, and then compute the horizontal average of `computation.result`. # Some important details. * This PR changes the meaning of `data`, which is used extensively in forming operations. This resolves #454. A new function `interior` serves the original purpose of `data`. * This PR depends on the arbitrary tracers ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463
https://github.com/CliMA/Oceananigans.jl/pull/463:6774,Testability,test,tests,6774,".pressures.pHY′`). We also extend `HorizontalAverage` to work with `Computation`, (and add a constructor that constructs a `Computation` from an `AbstractOperation` and `Model`), eg. ```julia; T, S = model.tracers; ST = HorizontalAverage(S + T, model); computed_profile = ST(model); ```. Calling `run_diagnostic` for `HorizontalAverage{<:Computation}` first calls `compute!(computation)`, and then compute the horizontal average of `computation.result`. # Some important details. * This PR changes the meaning of `data`, which is used extensively in forming operations. This resolves #454. A new function `interior` serves the original purpose of `data`. * This PR depends on the arbitrary tracers PR. The arbitrary tracers PR should be merged before this one. * To permit mixing `Function`s in with `Field`s and `Number`s in `AbstractOperations`, we also define a `FunctionField` type that acts like a field, but invokes a function to compute values at its location under the hood. This type probably needs more tests. We should also investigate whether this type can be used to specify things like background fields. A `FunctionField` can either be time-dependent and a function of `x, y, z, t` (achieved by allowing it to possess a reference to `clock`), or a static function of `x, y, z`. * This PR changes the result of a horizontal average to `HorizontalAverage.result` to provide a common terminology with `Computation`, as well as future reductions along other dimensions (previously the result of a horizontal average was called `profile`). * This PR adapts `Field` to work on the GPU (after the hard work of adapting all the `AbstractOperation`s to work on the GPU, this seemed trivial). That this works now should be tested. If it does indeed work and there is no loss of performance, we can eliminate a lot of cruft from our `time_step!`, and also use fields directly in `AbstractOperation`s (right now we extract the underlying `OffsetArray` instead). # In summary. Miraculously, tests pa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463
https://github.com/CliMA/Oceananigans.jl/pull/463:7489,Testability,test,tested,7489,"tracers PR should be merged before this one. * To permit mixing `Function`s in with `Field`s and `Number`s in `AbstractOperations`, we also define a `FunctionField` type that acts like a field, but invokes a function to compute values at its location under the hood. This type probably needs more tests. We should also investigate whether this type can be used to specify things like background fields. A `FunctionField` can either be time-dependent and a function of `x, y, z, t` (achieved by allowing it to possess a reference to `clock`), or a static function of `x, y, z`. * This PR changes the result of a horizontal average to `HorizontalAverage.result` to provide a common terminology with `Computation`, as well as future reductions along other dimensions (previously the result of a horizontal average was called `profile`). * This PR adapts `Field` to work on the GPU (after the hard work of adapting all the `AbstractOperation`s to work on the GPU, this seemed trivial). That this works now should be tested. If it does indeed work and there is no loss of performance, we can eliminate a lot of cruft from our `time_step!`, and also use fields directly in `AbstractOperation`s (right now we extract the underlying `OffsetArray` instead). # In summary. Miraculously, tests pass on the GPU. However, this framework is quite general and powerful, so we need to . - [x] think carefully about the tests we need (and don't need). . And certainly before merging we also need. - [x] docstrings... . Also, it'd be nice to. - [x] use `AbstractOperation` to define useful output in an example. Some discussion may be warranted about what's exported from `AbstractOperations`; we almost always want to have `Face` and `Cell`, for example. Ultimately, I think it'd be nice to write `using Oceananigans.Fields, Oceananigans.AbstractOperators` to get what's needed for this purpose. But that's yet another future PR. I hope this sparks some discussion about the future of the `Field` abstraction as well.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463
https://github.com/CliMA/Oceananigans.jl/pull/463:7754,Testability,test,tests,7754,"th `Field`s and `Number`s in `AbstractOperations`, we also define a `FunctionField` type that acts like a field, but invokes a function to compute values at its location under the hood. This type probably needs more tests. We should also investigate whether this type can be used to specify things like background fields. A `FunctionField` can either be time-dependent and a function of `x, y, z, t` (achieved by allowing it to possess a reference to `clock`), or a static function of `x, y, z`. * This PR changes the result of a horizontal average to `HorizontalAverage.result` to provide a common terminology with `Computation`, as well as future reductions along other dimensions (previously the result of a horizontal average was called `profile`). * This PR adapts `Field` to work on the GPU (after the hard work of adapting all the `AbstractOperation`s to work on the GPU, this seemed trivial). That this works now should be tested. If it does indeed work and there is no loss of performance, we can eliminate a lot of cruft from our `time_step!`, and also use fields directly in `AbstractOperation`s (right now we extract the underlying `OffsetArray` instead). # In summary. Miraculously, tests pass on the GPU. However, this framework is quite general and powerful, so we need to . - [x] think carefully about the tests we need (and don't need). . And certainly before merging we also need. - [x] docstrings... . Also, it'd be nice to. - [x] use `AbstractOperation` to define useful output in an example. Some discussion may be warranted about what's exported from `AbstractOperations`; we almost always want to have `Face` and `Cell`, for example. Ultimately, I think it'd be nice to write `using Oceananigans.Fields, Oceananigans.AbstractOperators` to get what's needed for this purpose. But that's yet another future PR. I hope this sparks some discussion about the future of the `Field` abstraction as well. I think it has the potential to be quite powerful. Resolves #454 ; Resolves #428",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463
https://github.com/CliMA/Oceananigans.jl/pull/463:7880,Testability,test,tests,7880,"th `Field`s and `Number`s in `AbstractOperations`, we also define a `FunctionField` type that acts like a field, but invokes a function to compute values at its location under the hood. This type probably needs more tests. We should also investigate whether this type can be used to specify things like background fields. A `FunctionField` can either be time-dependent and a function of `x, y, z, t` (achieved by allowing it to possess a reference to `clock`), or a static function of `x, y, z`. * This PR changes the result of a horizontal average to `HorizontalAverage.result` to provide a common terminology with `Computation`, as well as future reductions along other dimensions (previously the result of a horizontal average was called `profile`). * This PR adapts `Field` to work on the GPU (after the hard work of adapting all the `AbstractOperation`s to work on the GPU, this seemed trivial). That this works now should be tested. If it does indeed work and there is no loss of performance, we can eliminate a lot of cruft from our `time_step!`, and also use fields directly in `AbstractOperation`s (right now we extract the underlying `OffsetArray` instead). # In summary. Miraculously, tests pass on the GPU. However, this framework is quite general and powerful, so we need to . - [x] think carefully about the tests we need (and don't need). . And certainly before merging we also need. - [x] docstrings... . Also, it'd be nice to. - [x] use `AbstractOperation` to define useful output in an example. Some discussion may be warranted about what's exported from `AbstractOperations`; we almost always want to have `Face` and `Cell`, for example. Ultimately, I think it'd be nice to write `using Oceananigans.Fields, Oceananigans.AbstractOperators` to get what's needed for this purpose. But that's yet another future PR. I hope this sparks some discussion about the future of the `Field` abstraction as well. I think it has the potential to be quite powerful. Resolves #454 ; Resolves #428",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463
https://github.com/CliMA/Oceananigans.jl/pull/464:376,Usability,learn,learned,376,"So now we can specify the domain using; ```julia; RegularCartesianGrid(Float64; N=(10, 10, 10), x=(-5, 5), y=(-π, π), z=(0, 1)); ```; but if we only care about the length of each dimension then you can still use; ```julia; RegularCartesianGrid((32, 32, 32), (1, 1, 1)); ```. This is nice for a lot of problems where the domain isn't `x=(0, Lx), y=(0, Ly), z=(-Lz, 0)`. I also learned that keyword arguments do not participate in dispatch so you can't have both `RegularCartesianGrid(T; N, L)` and `RegularCartesianGrid(T; x, y, z)` :( Apparently it's a pretty old Julia issue: https://github.com/JuliaLang/julia/issues/9498. Resolves #413",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/464
https://github.com/CliMA/Oceananigans.jl/issues/465:143,Availability,error,error,143,"Easy mistake to make if you're new to Julia or unfamiliar with the package. Would be easy to do some input validation and throw an informative error. Examples:. Should be `CPU()` instead of `CPU` here:; ```julia; julia> model = Model(architecture=CPU, grid=RegularCartesianGrid(N=(64, 64, 64), L=(1, 1, 1)));. ERROR: MethodError: no method matching Field(::Tuple{DataType,DataType,DataType}, ::Type{CPU}, ::RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}); Closest candidates are:; Field(::Any, ::Any, ::Any, ::Any, ::Any) at /home/alir/Oceananigans.jl/src/fields.jl:50; Field(::Tuple, ::Oceananigans.AbstractArchitecture, ::Any) at /home/alir/Oceananigans.jl/src/fields.jl:32; Field(::Tuple, ::AbstractArray, ::Any) at /home/alir/Oceananigans.jl/src/fields.jl:42; Stacktrace:; [1] Field(::Type, ::Type, ::Type, ::Type, ::RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}) at /home/alir/Oceananigans.jl/src/fields.jl:50; [2] Field{Oceananigans.Face,Oceananigans.Cell,Oceananigans.Cell,A,G} where G where A(::Type, ::RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}) at /home/alir/Oceananigans.jl/src/fields.jl:109; [3] VelocityFields(::Type, ::RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}) at /home/alir/Oceananigans.jl/src/models.jl:177; [4] (::getfield(Core, Symbol(""#kw#Type"")))(::NamedTuple{(:architecture, :grid, :buoyancy, :tracers),Tuple{DataType,RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},DataType,Symbol}}, ::Type{Model}) at ./none:0; [5] top-level scope at REPL[7]:1; ```. Should be `BuoyancyTracer()` instead of `BuoyancyTracer` here:; ```julia; julia> model = Model(architecture=CPU(), grid=RegularCartesianGrid(N=(64, 64, 64), L=(1, 1, 1)), buoyancy=BuoyancyTracer, tracers",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/465
https://github.com/CliMA/Oceananigans.jl/issues/465:310,Availability,ERROR,ERROR,310,"Easy mistake to make if you're new to Julia or unfamiliar with the package. Would be easy to do some input validation and throw an informative error. Examples:. Should be `CPU()` instead of `CPU` here:; ```julia; julia> model = Model(architecture=CPU, grid=RegularCartesianGrid(N=(64, 64, 64), L=(1, 1, 1)));. ERROR: MethodError: no method matching Field(::Tuple{DataType,DataType,DataType}, ::Type{CPU}, ::RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}); Closest candidates are:; Field(::Any, ::Any, ::Any, ::Any, ::Any) at /home/alir/Oceananigans.jl/src/fields.jl:50; Field(::Tuple, ::Oceananigans.AbstractArchitecture, ::Any) at /home/alir/Oceananigans.jl/src/fields.jl:32; Field(::Tuple, ::AbstractArray, ::Any) at /home/alir/Oceananigans.jl/src/fields.jl:42; Stacktrace:; [1] Field(::Type, ::Type, ::Type, ::Type, ::RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}) at /home/alir/Oceananigans.jl/src/fields.jl:50; [2] Field{Oceananigans.Face,Oceananigans.Cell,Oceananigans.Cell,A,G} where G where A(::Type, ::RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}) at /home/alir/Oceananigans.jl/src/fields.jl:109; [3] VelocityFields(::Type, ::RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}) at /home/alir/Oceananigans.jl/src/models.jl:177; [4] (::getfield(Core, Symbol(""#kw#Type"")))(::NamedTuple{(:architecture, :grid, :buoyancy, :tracers),Tuple{DataType,RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},DataType,Symbol}}, ::Type{Model}) at ./none:0; [5] top-level scope at REPL[7]:1; ```. Should be `BuoyancyTracer()` instead of `BuoyancyTracer` here:; ```julia; julia> model = Model(architecture=CPU(), grid=RegularCartesianGrid(N=(64, 64, 64), L=(1, 1, 1)), buoyancy=BuoyancyTracer, tracers",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/465
https://github.com/CliMA/Oceananigans.jl/issues/465:2040,Availability,ERROR,ERROR,2040,"igans.Cell,A,G} where G where A(::Type, ::RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}) at /home/alir/Oceananigans.jl/src/fields.jl:109; [3] VelocityFields(::Type, ::RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}) at /home/alir/Oceananigans.jl/src/models.jl:177; [4] (::getfield(Core, Symbol(""#kw#Type"")))(::NamedTuple{(:architecture, :grid, :buoyancy, :tracers),Tuple{DataType,RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},DataType,Symbol}}, ::Type{Model}) at ./none:0; [5] top-level scope at REPL[7]:1; ```. Should be `BuoyancyTracer()` instead of `BuoyancyTracer` here:; ```julia; julia> model = Model(architecture=CPU(), grid=RegularCartesianGrid(N=(64, 64, 64), L=(1, 1, 1)), buoyancy=BuoyancyTracer, tracers=:b);. julia> time_step!(model, 1, 1); ERROR: MethodError: no method matching buoyancy_perturbation(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}, ::Type{BuoyancyTracer}, ::NamedTuple{(:b,),Tuple{OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}}}) ; Closest candidates are:; buoyancy_perturbation(::Any, ::Any, ::Any, ::Oceananigans.AbstractGrid{FT}, ::Nothing, ::Any) where FT at /home/alir/Oceananigans.jl/src/buoyancy.jl:30; buoyancy_perturbation(::Any, ::Any, ::Any, ::Any, ::BuoyancyTracer, ::Any) at /home/alir/Oceananigans.jl/src/buoyancy.jl:46; buoyancy_perturbation(::Any, ::Any, ::Any, ::Any, ::SeawaterBuoyancy{FT,#s70} where #s70<:LinearEquationOfState where FT, ::Any) at /home/alir/Oceananigans.jl/src/buoyancy.jl:127; ...; Stacktrace:; [1] ▶z_aaf at /home/alir/Oceananigans.jl/src/TurbulenceClosures/closure_operators.jl:199 [inlined]; [2] update_hydrostatic_pressure!(::OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, ::RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.T",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/465
https://github.com/CliMA/Oceananigans.jl/issues/465:107,Security,validat,validation,107,"Easy mistake to make if you're new to Julia or unfamiliar with the package. Would be easy to do some input validation and throw an informative error. Examples:. Should be `CPU()` instead of `CPU` here:; ```julia; julia> model = Model(architecture=CPU, grid=RegularCartesianGrid(N=(64, 64, 64), L=(1, 1, 1)));. ERROR: MethodError: no method matching Field(::Tuple{DataType,DataType,DataType}, ::Type{CPU}, ::RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}); Closest candidates are:; Field(::Any, ::Any, ::Any, ::Any, ::Any) at /home/alir/Oceananigans.jl/src/fields.jl:50; Field(::Tuple, ::Oceananigans.AbstractArchitecture, ::Any) at /home/alir/Oceananigans.jl/src/fields.jl:32; Field(::Tuple, ::AbstractArray, ::Any) at /home/alir/Oceananigans.jl/src/fields.jl:42; Stacktrace:; [1] Field(::Type, ::Type, ::Type, ::Type, ::RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}) at /home/alir/Oceananigans.jl/src/fields.jl:50; [2] Field{Oceananigans.Face,Oceananigans.Cell,Oceananigans.Cell,A,G} where G where A(::Type, ::RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}) at /home/alir/Oceananigans.jl/src/fields.jl:109; [3] VelocityFields(::Type, ::RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}) at /home/alir/Oceananigans.jl/src/models.jl:177; [4] (::getfield(Core, Symbol(""#kw#Type"")))(::NamedTuple{(:architecture, :grid, :buoyancy, :tracers),Tuple{DataType,RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},DataType,Symbol}}, ::Type{Model}) at ./none:0; [5] top-level scope at REPL[7]:1; ```. Should be `BuoyancyTracer()` instead of `BuoyancyTracer` here:; ```julia; julia> model = Model(architecture=CPU(), grid=RegularCartesianGrid(N=(64, 64, 64), L=(1, 1, 1)), buoyancy=BuoyancyTracer, tracers",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/465
https://github.com/CliMA/Oceananigans.jl/issues/466:42,Testability,benchmark,benchmarks,42,"Would be helpful in giving content to any benchmarks produced. Probably also useful to include Julia `versioninfo()`, CUDA version maybe, other systems specs, MPI version, etc.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/466
https://github.com/CliMA/Oceananigans.jl/pull/467:150,Availability,failure,failures,150,Until we figure out why v1.3 and DEV jobs time out on GitLab CI we can just allow v1.3 to fail. v1.3 hasn't been released yet so makes sense to allow failures anyways.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/467
https://github.com/CliMA/Oceananigans.jl/pull/467:113,Deployability,release,released,113,Until we figure out why v1.3 and DEV jobs time out on GitLab CI we can just allow v1.3 to fail. v1.3 hasn't been released yet so makes sense to allow failures anyways.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/467
https://github.com/CliMA/Oceananigans.jl/issues/468:98,Testability,test,testing,98,Overleaf documentation reflects this but not the code itself. This is the analytic solution we're testing against: https://en.wikipedia.org/wiki/Taylor%E2%80%93Green_vortex#Taylor%E2%80%93Green_vortex_solution,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/468
https://github.com/CliMA/Oceananigans.jl/issues/469:911,Availability,avail,avail,911,"We should pick a symbol to denote interpolation that we're all happy with. This is proving to be quite difficult unfortunately... So right now `Oceananigans.Operators` uses `avg_` to denote an interpolation operator which will be wrong once #283 is merged, but is also too verbose. `closure_operators.jl` uses `▶` (`\blacktriangleright`) which @glwagner likes but @christophernhill does not. I also don't really like it as it takes a while to type, and is actually quite hard to figure out and remember `\blacktriangleright`. I also think it's too much bold and sticks out too much when reading through the code. In PR #283 I went with `ϊ` (`\iota\ddot`) which I now agree isn't great, so @thabbott and @RaphaelRR suggested `ι` (`\iota`) for interpolation, which I quite like. But @glwagner isn't a huge fan. I've spent a lot of time looking through the unicode tables to try and find something else but to no avail. My favorite find is `↪` (`\hookrightarrow`) but it's reserved for binary operations. Apologies to anyone who thinks this is the most pedantic issue.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/469
https://github.com/CliMA/Oceananigans.jl/issues/470:506,Availability,down,downward,506,"I think for Oceananigans it may not matter much, but it seems to matter a lot for the atmosphere so maybe it would be good to match up with the atmosphere so we can share operators. Here's @thabbott's argument for making z the fast index for an atmospheric LES model (taken from https://github.com/thabbott/JULES.jl/pull/16):; > I think that there are three strong argument to be made in favor of making ``z`` the fast index for this model:; >; > 1. Radiative transfer operates in columns; > 2. Rain falls downward relative to the air it's embedded in; > 3. Vertical momentum is solved implicitly within columns on the acoustic time step; > ; > This means that these three calculations can operate completely independently over different columns and (at least for calculations using a CPU) it's more efficient to store variables in the same column close to each other in memory. I don't think we have to change the function signatures relative to Oceananigans to make ``z`` the fast index, though---we just have to change the indexing order in ``differences.jl`` and ``interpolation.jl``. I think @vchuravy said that this might change with GPUs and/or shared memory, so maybe it's not super clear whether the change is worth making. Although for CPUs it will probably help a lot.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/470
https://github.com/CliMA/Oceananigans.jl/issues/470:800,Energy Efficiency,efficient,efficient,800,"I think for Oceananigans it may not matter much, but it seems to matter a lot for the atmosphere so maybe it would be good to match up with the atmosphere so we can share operators. Here's @thabbott's argument for making z the fast index for an atmospheric LES model (taken from https://github.com/thabbott/JULES.jl/pull/16):; > I think that there are three strong argument to be made in favor of making ``z`` the fast index for this model:; >; > 1. Radiative transfer operates in columns; > 2. Rain falls downward relative to the air it's embedded in; > 3. Vertical momentum is solved implicitly within columns on the acoustic time step; > ; > This means that these three calculations can operate completely independently over different columns and (at least for calculations using a CPU) it's more efficient to store variables in the same column close to each other in memory. I don't think we have to change the function signatures relative to Oceananigans to make ``z`` the fast index, though---we just have to change the indexing order in ``differences.jl`` and ``interpolation.jl``. I think @vchuravy said that this might change with GPUs and/or shared memory, so maybe it's not super clear whether the change is worth making. Although for CPUs it will probably help a lot.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/470
https://github.com/CliMA/Oceananigans.jl/issues/470:819,Modifiability,variab,variables,819,"I think for Oceananigans it may not matter much, but it seems to matter a lot for the atmosphere so maybe it would be good to match up with the atmosphere so we can share operators. Here's @thabbott's argument for making z the fast index for an atmospheric LES model (taken from https://github.com/thabbott/JULES.jl/pull/16):; > I think that there are three strong argument to be made in favor of making ``z`` the fast index for this model:; >; > 1. Radiative transfer operates in columns; > 2. Rain falls downward relative to the air it's embedded in; > 3. Vertical momentum is solved implicitly within columns on the acoustic time step; > ; > This means that these three calculations can operate completely independently over different columns and (at least for calculations using a CPU) it's more efficient to store variables in the same column close to each other in memory. I don't think we have to change the function signatures relative to Oceananigans to make ``z`` the fast index, though---we just have to change the indexing order in ``differences.jl`` and ``interpolation.jl``. I think @vchuravy said that this might change with GPUs and/or shared memory, so maybe it's not super clear whether the change is worth making. Although for CPUs it will probably help a lot.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/470
https://github.com/CliMA/Oceananigans.jl/issues/470:1191,Usability,clear,clear,1191,"I think for Oceananigans it may not matter much, but it seems to matter a lot for the atmosphere so maybe it would be good to match up with the atmosphere so we can share operators. Here's @thabbott's argument for making z the fast index for an atmospheric LES model (taken from https://github.com/thabbott/JULES.jl/pull/16):; > I think that there are three strong argument to be made in favor of making ``z`` the fast index for this model:; >; > 1. Radiative transfer operates in columns; > 2. Rain falls downward relative to the air it's embedded in; > 3. Vertical momentum is solved implicitly within columns on the acoustic time step; > ; > This means that these three calculations can operate completely independently over different columns and (at least for calculations using a CPU) it's more efficient to store variables in the same column close to each other in memory. I don't think we have to change the function signatures relative to Oceananigans to make ``z`` the fast index, though---we just have to change the indexing order in ``differences.jl`` and ``interpolation.jl``. I think @vchuravy said that this might change with GPUs and/or shared memory, so maybe it's not super clear whether the change is worth making. Although for CPUs it will probably help a lot.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/470
https://github.com/CliMA/Oceananigans.jl/issues/471:987,Availability,down,down,987,"'ve figured out how to do the 3D pressure solve on a stretched grid following Chris' notes so I think we have all the pieces we need to implement vertically stretched grids, we just have to put it all together. I'm thinking about how to go about fully incorporating a vertically stretched grid, true finite volume operators, and the new FFT+tridiagonal Poisson solvers needed to solve for the pressure on a stretched grid. Seems like a good idea to split it up into steps with one pull request per step:; 1. Reverse the `k` index. Currently PR #462.; 2. Revise the `RegularCartesianGrid` struct so we're happy with it. Currently PR #464.; 3. Add finite volume operators as a separate piece of code. Technically they won't be tested in this PR and could have mistakes. Currently PR #283; 4. Nuke the old operators and start using the same set of finite volume operators for both `Oceananigans.Operators` and `closure_operators.jl`. This will test that the finite volume operators reduce down to the operators that currently work, but doesn't test them on a stretched grid.; 5. Implement a `VerticallyStretchedCartesianGrid`. Might have to iterate bit to figure out what we need, e.g. I think we'll want `ΔzC` to include the distance between the first cell center and the halo cell center, etc.; 6. Implement CPU and GPU pressure solvers for vertically stretched grids with tests. There will be two: one for horizontally periodic domains and another for channel models. I've figured most of this stuff out in Jupyter notebooks.; 7. Ensure that models with vertically stretched grids pass basic tests: e.g. incompressibility, tracer conservation, etc. This will test the finite volume operators.; 8. Run a model with a `VerticallyStretchedCartesianGrid` but with uniform grid spacing and make sure it produces the same numbers as a model with `RegularCartesianGrid`. This is a sanity check.; 9. Run additional tests for vertically stretched grids: e.g. vertical diffusion, internal wave, etc. This will a",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/471
https://github.com/CliMA/Oceananigans.jl/issues/471:980,Energy Efficiency,reduce,reduce,980,"'ve figured out how to do the 3D pressure solve on a stretched grid following Chris' notes so I think we have all the pieces we need to implement vertically stretched grids, we just have to put it all together. I'm thinking about how to go about fully incorporating a vertically stretched grid, true finite volume operators, and the new FFT+tridiagonal Poisson solvers needed to solve for the pressure on a stretched grid. Seems like a good idea to split it up into steps with one pull request per step:; 1. Reverse the `k` index. Currently PR #462.; 2. Revise the `RegularCartesianGrid` struct so we're happy with it. Currently PR #464.; 3. Add finite volume operators as a separate piece of code. Technically they won't be tested in this PR and could have mistakes. Currently PR #283; 4. Nuke the old operators and start using the same set of finite volume operators for both `Oceananigans.Operators` and `closure_operators.jl`. This will test that the finite volume operators reduce down to the operators that currently work, but doesn't test them on a stretched grid.; 5. Implement a `VerticallyStretchedCartesianGrid`. Might have to iterate bit to figure out what we need, e.g. I think we'll want `ΔzC` to include the distance between the first cell center and the halo cell center, etc.; 6. Implement CPU and GPU pressure solvers for vertically stretched grids with tests. There will be two: one for horizontally periodic domains and another for channel models. I've figured most of this stuff out in Jupyter notebooks.; 7. Ensure that models with vertically stretched grids pass basic tests: e.g. incompressibility, tracer conservation, etc. This will test the finite volume operators.; 8. Run a model with a `VerticallyStretchedCartesianGrid` but with uniform grid spacing and make sure it produces the same numbers as a model with `RegularCartesianGrid`. This is a sanity check.; 9. Run additional tests for vertically stretched grids: e.g. vertical diffusion, internal wave, etc. This will a",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/471
https://github.com/CliMA/Oceananigans.jl/issues/471:1875,Safety,sanity check,sanity check,1875,", true finite volume operators, and the new FFT+tridiagonal Poisson solvers needed to solve for the pressure on a stretched grid. Seems like a good idea to split it up into steps with one pull request per step:; 1. Reverse the `k` index. Currently PR #462.; 2. Revise the `RegularCartesianGrid` struct so we're happy with it. Currently PR #464.; 3. Add finite volume operators as a separate piece of code. Technically they won't be tested in this PR and could have mistakes. Currently PR #283; 4. Nuke the old operators and start using the same set of finite volume operators for both `Oceananigans.Operators` and `closure_operators.jl`. This will test that the finite volume operators reduce down to the operators that currently work, but doesn't test them on a stretched grid.; 5. Implement a `VerticallyStretchedCartesianGrid`. Might have to iterate bit to figure out what we need, e.g. I think we'll want `ΔzC` to include the distance between the first cell center and the halo cell center, etc.; 6. Implement CPU and GPU pressure solvers for vertically stretched grids with tests. There will be two: one for horizontally periodic domains and another for channel models. I've figured most of this stuff out in Jupyter notebooks.; 7. Ensure that models with vertically stretched grids pass basic tests: e.g. incompressibility, tracer conservation, etc. This will test the finite volume operators.; 8. Run a model with a `VerticallyStretchedCartesianGrid` but with uniform grid spacing and make sure it produces the same numbers as a model with `RegularCartesianGrid`. This is a sanity check.; 9. Run additional tests for vertically stretched grids: e.g. vertical diffusion, internal wave, etc. This will also test boundary conditions with stretched grids.; 10. Rerun the stratified Couette flow verification experiment but with a stretching factor matching Vreugdenhil & Taylor (2018). This will test the AMD closure on stretched grids. Let me know if anyone has any thoughts. cc @jm-c @rafferrari",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/471
https://github.com/CliMA/Oceananigans.jl/issues/471:726,Testability,test,tested,726,"I've figured out how to do the 3D pressure solve on a stretched grid following Chris' notes so I think we have all the pieces we need to implement vertically stretched grids, we just have to put it all together. I'm thinking about how to go about fully incorporating a vertically stretched grid, true finite volume operators, and the new FFT+tridiagonal Poisson solvers needed to solve for the pressure on a stretched grid. Seems like a good idea to split it up into steps with one pull request per step:; 1. Reverse the `k` index. Currently PR #462.; 2. Revise the `RegularCartesianGrid` struct so we're happy with it. Currently PR #464.; 3. Add finite volume operators as a separate piece of code. Technically they won't be tested in this PR and could have mistakes. Currently PR #283; 4. Nuke the old operators and start using the same set of finite volume operators for both `Oceananigans.Operators` and `closure_operators.jl`. This will test that the finite volume operators reduce down to the operators that currently work, but doesn't test them on a stretched grid.; 5. Implement a `VerticallyStretchedCartesianGrid`. Might have to iterate bit to figure out what we need, e.g. I think we'll want `ΔzC` to include the distance between the first cell center and the halo cell center, etc.; 6. Implement CPU and GPU pressure solvers for vertically stretched grids with tests. There will be two: one for horizontally periodic domains and another for channel models. I've figured most of this stuff out in Jupyter notebooks.; 7. Ensure that models with vertically stretched grids pass basic tests: e.g. incompressibility, tracer conservation, etc. This will test the finite volume operators.; 8. Run a model with a `VerticallyStretchedCartesianGrid` but with uniform grid spacing and make sure it produces the same numbers as a model with `RegularCartesianGrid`. This is a sanity check.; 9. Run additional tests for vertically stretched grids: e.g. vertical diffusion, internal wave, etc. This will ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/471
https://github.com/CliMA/Oceananigans.jl/issues/471:942,Testability,test,test,942,"'ve figured out how to do the 3D pressure solve on a stretched grid following Chris' notes so I think we have all the pieces we need to implement vertically stretched grids, we just have to put it all together. I'm thinking about how to go about fully incorporating a vertically stretched grid, true finite volume operators, and the new FFT+tridiagonal Poisson solvers needed to solve for the pressure on a stretched grid. Seems like a good idea to split it up into steps with one pull request per step:; 1. Reverse the `k` index. Currently PR #462.; 2. Revise the `RegularCartesianGrid` struct so we're happy with it. Currently PR #464.; 3. Add finite volume operators as a separate piece of code. Technically they won't be tested in this PR and could have mistakes. Currently PR #283; 4. Nuke the old operators and start using the same set of finite volume operators for both `Oceananigans.Operators` and `closure_operators.jl`. This will test that the finite volume operators reduce down to the operators that currently work, but doesn't test them on a stretched grid.; 5. Implement a `VerticallyStretchedCartesianGrid`. Might have to iterate bit to figure out what we need, e.g. I think we'll want `ΔzC` to include the distance between the first cell center and the halo cell center, etc.; 6. Implement CPU and GPU pressure solvers for vertically stretched grids with tests. There will be two: one for horizontally periodic domains and another for channel models. I've figured most of this stuff out in Jupyter notebooks.; 7. Ensure that models with vertically stretched grids pass basic tests: e.g. incompressibility, tracer conservation, etc. This will test the finite volume operators.; 8. Run a model with a `VerticallyStretchedCartesianGrid` but with uniform grid spacing and make sure it produces the same numbers as a model with `RegularCartesianGrid`. This is a sanity check.; 9. Run additional tests for vertically stretched grids: e.g. vertical diffusion, internal wave, etc. This will a",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/471
https://github.com/CliMA/Oceananigans.jl/issues/471:1042,Testability,test,test,1042,"'ve figured out how to do the 3D pressure solve on a stretched grid following Chris' notes so I think we have all the pieces we need to implement vertically stretched grids, we just have to put it all together. I'm thinking about how to go about fully incorporating a vertically stretched grid, true finite volume operators, and the new FFT+tridiagonal Poisson solvers needed to solve for the pressure on a stretched grid. Seems like a good idea to split it up into steps with one pull request per step:; 1. Reverse the `k` index. Currently PR #462.; 2. Revise the `RegularCartesianGrid` struct so we're happy with it. Currently PR #464.; 3. Add finite volume operators as a separate piece of code. Technically they won't be tested in this PR and could have mistakes. Currently PR #283; 4. Nuke the old operators and start using the same set of finite volume operators for both `Oceananigans.Operators` and `closure_operators.jl`. This will test that the finite volume operators reduce down to the operators that currently work, but doesn't test them on a stretched grid.; 5. Implement a `VerticallyStretchedCartesianGrid`. Might have to iterate bit to figure out what we need, e.g. I think we'll want `ΔzC` to include the distance between the first cell center and the halo cell center, etc.; 6. Implement CPU and GPU pressure solvers for vertically stretched grids with tests. There will be two: one for horizontally periodic domains and another for channel models. I've figured most of this stuff out in Jupyter notebooks.; 7. Ensure that models with vertically stretched grids pass basic tests: e.g. incompressibility, tracer conservation, etc. This will test the finite volume operators.; 8. Run a model with a `VerticallyStretchedCartesianGrid` but with uniform grid spacing and make sure it produces the same numbers as a model with `RegularCartesianGrid`. This is a sanity check.; 9. Run additional tests for vertically stretched grids: e.g. vertical diffusion, internal wave, etc. This will a",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/471
https://github.com/CliMA/Oceananigans.jl/issues/471:1373,Testability,test,tests,1373,", true finite volume operators, and the new FFT+tridiagonal Poisson solvers needed to solve for the pressure on a stretched grid. Seems like a good idea to split it up into steps with one pull request per step:; 1. Reverse the `k` index. Currently PR #462.; 2. Revise the `RegularCartesianGrid` struct so we're happy with it. Currently PR #464.; 3. Add finite volume operators as a separate piece of code. Technically they won't be tested in this PR and could have mistakes. Currently PR #283; 4. Nuke the old operators and start using the same set of finite volume operators for both `Oceananigans.Operators` and `closure_operators.jl`. This will test that the finite volume operators reduce down to the operators that currently work, but doesn't test them on a stretched grid.; 5. Implement a `VerticallyStretchedCartesianGrid`. Might have to iterate bit to figure out what we need, e.g. I think we'll want `ΔzC` to include the distance between the first cell center and the halo cell center, etc.; 6. Implement CPU and GPU pressure solvers for vertically stretched grids with tests. There will be two: one for horizontally periodic domains and another for channel models. I've figured most of this stuff out in Jupyter notebooks.; 7. Ensure that models with vertically stretched grids pass basic tests: e.g. incompressibility, tracer conservation, etc. This will test the finite volume operators.; 8. Run a model with a `VerticallyStretchedCartesianGrid` but with uniform grid spacing and make sure it produces the same numbers as a model with `RegularCartesianGrid`. This is a sanity check.; 9. Run additional tests for vertically stretched grids: e.g. vertical diffusion, internal wave, etc. This will also test boundary conditions with stretched grids.; 10. Rerun the stratified Couette flow verification experiment but with a stretching factor matching Vreugdenhil & Taylor (2018). This will test the AMD closure on stretched grids. Let me know if anyone has any thoughts. cc @jm-c @rafferrari",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/471
https://github.com/CliMA/Oceananigans.jl/issues/471:1593,Testability,test,tests,1593,", true finite volume operators, and the new FFT+tridiagonal Poisson solvers needed to solve for the pressure on a stretched grid. Seems like a good idea to split it up into steps with one pull request per step:; 1. Reverse the `k` index. Currently PR #462.; 2. Revise the `RegularCartesianGrid` struct so we're happy with it. Currently PR #464.; 3. Add finite volume operators as a separate piece of code. Technically they won't be tested in this PR and could have mistakes. Currently PR #283; 4. Nuke the old operators and start using the same set of finite volume operators for both `Oceananigans.Operators` and `closure_operators.jl`. This will test that the finite volume operators reduce down to the operators that currently work, but doesn't test them on a stretched grid.; 5. Implement a `VerticallyStretchedCartesianGrid`. Might have to iterate bit to figure out what we need, e.g. I think we'll want `ΔzC` to include the distance between the first cell center and the halo cell center, etc.; 6. Implement CPU and GPU pressure solvers for vertically stretched grids with tests. There will be two: one for horizontally periodic domains and another for channel models. I've figured most of this stuff out in Jupyter notebooks.; 7. Ensure that models with vertically stretched grids pass basic tests: e.g. incompressibility, tracer conservation, etc. This will test the finite volume operators.; 8. Run a model with a `VerticallyStretchedCartesianGrid` but with uniform grid spacing and make sure it produces the same numbers as a model with `RegularCartesianGrid`. This is a sanity check.; 9. Run additional tests for vertically stretched grids: e.g. vertical diffusion, internal wave, etc. This will also test boundary conditions with stretched grids.; 10. Rerun the stratified Couette flow verification experiment but with a stretching factor matching Vreugdenhil & Taylor (2018). This will test the AMD closure on stretched grids. Let me know if anyone has any thoughts. cc @jm-c @rafferrari",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/471
https://github.com/CliMA/Oceananigans.jl/issues/471:1660,Testability,test,test,1660,", true finite volume operators, and the new FFT+tridiagonal Poisson solvers needed to solve for the pressure on a stretched grid. Seems like a good idea to split it up into steps with one pull request per step:; 1. Reverse the `k` index. Currently PR #462.; 2. Revise the `RegularCartesianGrid` struct so we're happy with it. Currently PR #464.; 3. Add finite volume operators as a separate piece of code. Technically they won't be tested in this PR and could have mistakes. Currently PR #283; 4. Nuke the old operators and start using the same set of finite volume operators for both `Oceananigans.Operators` and `closure_operators.jl`. This will test that the finite volume operators reduce down to the operators that currently work, but doesn't test them on a stretched grid.; 5. Implement a `VerticallyStretchedCartesianGrid`. Might have to iterate bit to figure out what we need, e.g. I think we'll want `ΔzC` to include the distance between the first cell center and the halo cell center, etc.; 6. Implement CPU and GPU pressure solvers for vertically stretched grids with tests. There will be two: one for horizontally periodic domains and another for channel models. I've figured most of this stuff out in Jupyter notebooks.; 7. Ensure that models with vertically stretched grids pass basic tests: e.g. incompressibility, tracer conservation, etc. This will test the finite volume operators.; 8. Run a model with a `VerticallyStretchedCartesianGrid` but with uniform grid spacing and make sure it produces the same numbers as a model with `RegularCartesianGrid`. This is a sanity check.; 9. Run additional tests for vertically stretched grids: e.g. vertical diffusion, internal wave, etc. This will also test boundary conditions with stretched grids.; 10. Rerun the stratified Couette flow verification experiment but with a stretching factor matching Vreugdenhil & Taylor (2018). This will test the AMD closure on stretched grids. Let me know if anyone has any thoughts. cc @jm-c @rafferrari",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/471
https://github.com/CliMA/Oceananigans.jl/issues/471:1908,Testability,test,tests,1908,", true finite volume operators, and the new FFT+tridiagonal Poisson solvers needed to solve for the pressure on a stretched grid. Seems like a good idea to split it up into steps with one pull request per step:; 1. Reverse the `k` index. Currently PR #462.; 2. Revise the `RegularCartesianGrid` struct so we're happy with it. Currently PR #464.; 3. Add finite volume operators as a separate piece of code. Technically they won't be tested in this PR and could have mistakes. Currently PR #283; 4. Nuke the old operators and start using the same set of finite volume operators for both `Oceananigans.Operators` and `closure_operators.jl`. This will test that the finite volume operators reduce down to the operators that currently work, but doesn't test them on a stretched grid.; 5. Implement a `VerticallyStretchedCartesianGrid`. Might have to iterate bit to figure out what we need, e.g. I think we'll want `ΔzC` to include the distance between the first cell center and the halo cell center, etc.; 6. Implement CPU and GPU pressure solvers for vertically stretched grids with tests. There will be two: one for horizontally periodic domains and another for channel models. I've figured most of this stuff out in Jupyter notebooks.; 7. Ensure that models with vertically stretched grids pass basic tests: e.g. incompressibility, tracer conservation, etc. This will test the finite volume operators.; 8. Run a model with a `VerticallyStretchedCartesianGrid` but with uniform grid spacing and make sure it produces the same numbers as a model with `RegularCartesianGrid`. This is a sanity check.; 9. Run additional tests for vertically stretched grids: e.g. vertical diffusion, internal wave, etc. This will also test boundary conditions with stretched grids.; 10. Rerun the stratified Couette flow verification experiment but with a stretching factor matching Vreugdenhil & Taylor (2018). This will test the AMD closure on stretched grids. Let me know if anyone has any thoughts. cc @jm-c @rafferrari",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/471
https://github.com/CliMA/Oceananigans.jl/issues/471:2006,Testability,test,test,2006,", true finite volume operators, and the new FFT+tridiagonal Poisson solvers needed to solve for the pressure on a stretched grid. Seems like a good idea to split it up into steps with one pull request per step:; 1. Reverse the `k` index. Currently PR #462.; 2. Revise the `RegularCartesianGrid` struct so we're happy with it. Currently PR #464.; 3. Add finite volume operators as a separate piece of code. Technically they won't be tested in this PR and could have mistakes. Currently PR #283; 4. Nuke the old operators and start using the same set of finite volume operators for both `Oceananigans.Operators` and `closure_operators.jl`. This will test that the finite volume operators reduce down to the operators that currently work, but doesn't test them on a stretched grid.; 5. Implement a `VerticallyStretchedCartesianGrid`. Might have to iterate bit to figure out what we need, e.g. I think we'll want `ΔzC` to include the distance between the first cell center and the halo cell center, etc.; 6. Implement CPU and GPU pressure solvers for vertically stretched grids with tests. There will be two: one for horizontally periodic domains and another for channel models. I've figured most of this stuff out in Jupyter notebooks.; 7. Ensure that models with vertically stretched grids pass basic tests: e.g. incompressibility, tracer conservation, etc. This will test the finite volume operators.; 8. Run a model with a `VerticallyStretchedCartesianGrid` but with uniform grid spacing and make sure it produces the same numbers as a model with `RegularCartesianGrid`. This is a sanity check.; 9. Run additional tests for vertically stretched grids: e.g. vertical diffusion, internal wave, etc. This will also test boundary conditions with stretched grids.; 10. Rerun the stratified Couette flow verification experiment but with a stretching factor matching Vreugdenhil & Taylor (2018). This will test the AMD closure on stretched grids. Let me know if anyone has any thoughts. cc @jm-c @rafferrari",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/471
https://github.com/CliMA/Oceananigans.jl/issues/471:2193,Testability,test,test,2193,", true finite volume operators, and the new FFT+tridiagonal Poisson solvers needed to solve for the pressure on a stretched grid. Seems like a good idea to split it up into steps with one pull request per step:; 1. Reverse the `k` index. Currently PR #462.; 2. Revise the `RegularCartesianGrid` struct so we're happy with it. Currently PR #464.; 3. Add finite volume operators as a separate piece of code. Technically they won't be tested in this PR and could have mistakes. Currently PR #283; 4. Nuke the old operators and start using the same set of finite volume operators for both `Oceananigans.Operators` and `closure_operators.jl`. This will test that the finite volume operators reduce down to the operators that currently work, but doesn't test them on a stretched grid.; 5. Implement a `VerticallyStretchedCartesianGrid`. Might have to iterate bit to figure out what we need, e.g. I think we'll want `ΔzC` to include the distance between the first cell center and the halo cell center, etc.; 6. Implement CPU and GPU pressure solvers for vertically stretched grids with tests. There will be two: one for horizontally periodic domains and another for channel models. I've figured most of this stuff out in Jupyter notebooks.; 7. Ensure that models with vertically stretched grids pass basic tests: e.g. incompressibility, tracer conservation, etc. This will test the finite volume operators.; 8. Run a model with a `VerticallyStretchedCartesianGrid` but with uniform grid spacing and make sure it produces the same numbers as a model with `RegularCartesianGrid`. This is a sanity check.; 9. Run additional tests for vertically stretched grids: e.g. vertical diffusion, internal wave, etc. This will also test boundary conditions with stretched grids.; 10. Rerun the stratified Couette flow verification experiment but with a stretching factor matching Vreugdenhil & Taylor (2018). This will test the AMD closure on stretched grids. Let me know if anyone has any thoughts. cc @jm-c @rafferrari",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/471
https://github.com/CliMA/Oceananigans.jl/pull/472:71,Availability,failure,failures,71,Not sure if this will fix the failing coverage job so I've also allows failures on coverage. Coverage will be reported from v1.2,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/472
https://github.com/CliMA/Oceananigans.jl/issues/473:49,Testability,test,test,49,Seems like a good idea to have an LES regression test for big PRs that modify the `TurbulenceClosures` module such as PR #452. I guess we can use a coarse stratified Couette flow or free convection simulation in steady state to check for this.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/473
https://github.com/CliMA/Oceananigans.jl/pull/474:128,Deployability,continuous,continuous,128,"This will be one big PR that merges in; 1. code/interface documentation from docstrings,; 2. high-level documentation about the continuous equations and numerical methods employed,; 3. documentation about the verification experiments, and; 4. generated Markdown tutorials from the Literate.jl examples. Once we're happy with the documentation, we'll be ready to submit an entry to the *Journal of Open Source Software*. High-level documentation can be found at: https://www.overleaf.com/project/5d73051a46be42000164d1ef. ## Documentation contents; 1. Documentation home page (+ package description); 2. Continuous equations; 3. Numerical methods; 	1. Overview of time-stepping algorithm; 	2. Finite volume method; 	3. Staggered grid; 	4. Fractional step method; 5. Time stepping; 6. Spatial operators; 7. Poisson solvers; 8. Boundary conditions; 9. Turbulence closures; 10. Large eddy simulation; 4. Model setup (description of all the options); 5. Examples; 	1. Simple diffusion; 2. Two-dimensional turbulence; 3. Ocean wind mixing and convection; 4. Ocean convection with plankton; 5. Internal wave; 6. Thermal rising bubble?; 7. Lid-driven cavity?; 8. Eddying channel?; 6. Verification experiments; 1. Taylor-Green vortex; 2. Lid-driven cavity?; 3. Stratified Couette flow; 4. Free convection (Split into ocean and Kato & Phillips?); 7. Gallery (movies!); 8. Performance benchmarks; 9. Documentation of public (+ private?) user interface; 10. References section (if we want to store them all on one page). ## References in the docs; Unfortunately there is no support for bibtex citations/references in Documenter.jl and we have a lot of them =/ This has been brought up by @simonbyrne and @charleskawczynski: https://github.com/climate-machine/CLIMA/issues/152. For now I've just copy pasted stuff from the LaTeX document and left in the `\citet` and `\citep` commands. But we have a few options:; 1. Painstakingly format all the citations and references by hand using Markdown footnotes.; 2. Cite ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/474
https://github.com/CliMA/Oceananigans.jl/pull/474:603,Deployability,Continuous,Continuous,603,"This will be one big PR that merges in; 1. code/interface documentation from docstrings,; 2. high-level documentation about the continuous equations and numerical methods employed,; 3. documentation about the verification experiments, and; 4. generated Markdown tutorials from the Literate.jl examples. Once we're happy with the documentation, we'll be ready to submit an entry to the *Journal of Open Source Software*. High-level documentation can be found at: https://www.overleaf.com/project/5d73051a46be42000164d1ef. ## Documentation contents; 1. Documentation home page (+ package description); 2. Continuous equations; 3. Numerical methods; 	1. Overview of time-stepping algorithm; 	2. Finite volume method; 	3. Staggered grid; 	4. Fractional step method; 5. Time stepping; 6. Spatial operators; 7. Poisson solvers; 8. Boundary conditions; 9. Turbulence closures; 10. Large eddy simulation; 4. Model setup (description of all the options); 5. Examples; 	1. Simple diffusion; 2. Two-dimensional turbulence; 3. Ocean wind mixing and convection; 4. Ocean convection with plankton; 5. Internal wave; 6. Thermal rising bubble?; 7. Lid-driven cavity?; 8. Eddying channel?; 6. Verification experiments; 1. Taylor-Green vortex; 2. Lid-driven cavity?; 3. Stratified Couette flow; 4. Free convection (Split into ocean and Kato & Phillips?); 7. Gallery (movies!); 8. Performance benchmarks; 9. Documentation of public (+ private?) user interface; 10. References section (if we want to store them all on one page). ## References in the docs; Unfortunately there is no support for bibtex citations/references in Documenter.jl and we have a lot of them =/ This has been brought up by @simonbyrne and @charleskawczynski: https://github.com/climate-machine/CLIMA/issues/152. For now I've just copy pasted stuff from the LaTeX document and left in the `\citet` and `\citep` commands. But we have a few options:; 1. Painstakingly format all the citations and references by hand using Markdown footnotes.; 2. Cite ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/474
https://github.com/CliMA/Oceananigans.jl/pull/474:2105,Deployability,integrat,integrates,2105,"6. Thermal rising bubble?; 7. Lid-driven cavity?; 8. Eddying channel?; 6. Verification experiments; 1. Taylor-Green vortex; 2. Lid-driven cavity?; 3. Stratified Couette flow; 4. Free convection (Split into ocean and Kato & Phillips?); 7. Gallery (movies!); 8. Performance benchmarks; 9. Documentation of public (+ private?) user interface; 10. References section (if we want to store them all on one page). ## References in the docs; Unfortunately there is no support for bibtex citations/references in Documenter.jl and we have a lot of them =/ This has been brought up by @simonbyrne and @charleskawczynski: https://github.com/climate-machine/CLIMA/issues/152. For now I've just copy pasted stuff from the LaTeX document and left in the `\citet` and `\citep` commands. But we have a few options:; 1. Painstakingly format all the citations and references by hand using Markdown footnotes.; 2. Cite judiciously so we don't have to manually format as many references.; 3. Work on a general solution that integrates with Documenter. I'm leaning towards option 2. EDIT: @johncmarshall54 argues in favor of option 1, which I'm now leaning towards as well. ## Examples. Thanks @glwagner for writing all the examples, they generate beautiful tutorials that we can directly embed in the documentation!. 1. I had to modify the examples slightly as Documenter.jl will only show plots returned using `gcf()`.; 2. We should define a `show` function for `Model` as the current output pollutes all the examples.; 3. The two ocean convection examples take forever to compile to docs because they generate movies and Documenter might be trying to embed each frame as a separate image or something. It might be worth discussing whether we should just make all the examples Documenter/tutorial friendly, which means switching from movies to plotting a few frames. ## Some comments; 0. Unfortunately if we want to look at the docs, we have to build it locally for now =/; 1. Documenter uses KaTeX to render math, which",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/474
https://github.com/CliMA/Oceananigans.jl/pull/474:1212,Energy Efficiency,Green,Green,1212,"ation experiments, and; 4. generated Markdown tutorials from the Literate.jl examples. Once we're happy with the documentation, we'll be ready to submit an entry to the *Journal of Open Source Software*. High-level documentation can be found at: https://www.overleaf.com/project/5d73051a46be42000164d1ef. ## Documentation contents; 1. Documentation home page (+ package description); 2. Continuous equations; 3. Numerical methods; 	1. Overview of time-stepping algorithm; 	2. Finite volume method; 	3. Staggered grid; 	4. Fractional step method; 5. Time stepping; 6. Spatial operators; 7. Poisson solvers; 8. Boundary conditions; 9. Turbulence closures; 10. Large eddy simulation; 4. Model setup (description of all the options); 5. Examples; 	1. Simple diffusion; 2. Two-dimensional turbulence; 3. Ocean wind mixing and convection; 4. Ocean convection with plankton; 5. Internal wave; 6. Thermal rising bubble?; 7. Lid-driven cavity?; 8. Eddying channel?; 6. Verification experiments; 1. Taylor-Green vortex; 2. Lid-driven cavity?; 3. Stratified Couette flow; 4. Free convection (Split into ocean and Kato & Phillips?); 7. Gallery (movies!); 8. Performance benchmarks; 9. Documentation of public (+ private?) user interface; 10. References section (if we want to store them all on one page). ## References in the docs; Unfortunately there is no support for bibtex citations/references in Documenter.jl and we have a lot of them =/ This has been brought up by @simonbyrne and @charleskawczynski: https://github.com/climate-machine/CLIMA/issues/152. For now I've just copy pasted stuff from the LaTeX document and left in the `\citet` and `\citep` commands. But we have a few options:; 1. Painstakingly format all the citations and references by hand using Markdown footnotes.; 2. Cite judiciously so we don't have to manually format as many references.; 3. Work on a general solution that integrates with Documenter. I'm leaning towards option 2. EDIT: @johncmarshall54 argues in favor of option 1, w",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/474
https://github.com/CliMA/Oceananigans.jl/pull/474:48,Integrability,interface,interface,48,"This will be one big PR that merges in; 1. code/interface documentation from docstrings,; 2. high-level documentation about the continuous equations and numerical methods employed,; 3. documentation about the verification experiments, and; 4. generated Markdown tutorials from the Literate.jl examples. Once we're happy with the documentation, we'll be ready to submit an entry to the *Journal of Open Source Software*. High-level documentation can be found at: https://www.overleaf.com/project/5d73051a46be42000164d1ef. ## Documentation contents; 1. Documentation home page (+ package description); 2. Continuous equations; 3. Numerical methods; 	1. Overview of time-stepping algorithm; 	2. Finite volume method; 	3. Staggered grid; 	4. Fractional step method; 5. Time stepping; 6. Spatial operators; 7. Poisson solvers; 8. Boundary conditions; 9. Turbulence closures; 10. Large eddy simulation; 4. Model setup (description of all the options); 5. Examples; 	1. Simple diffusion; 2. Two-dimensional turbulence; 3. Ocean wind mixing and convection; 4. Ocean convection with plankton; 5. Internal wave; 6. Thermal rising bubble?; 7. Lid-driven cavity?; 8. Eddying channel?; 6. Verification experiments; 1. Taylor-Green vortex; 2. Lid-driven cavity?; 3. Stratified Couette flow; 4. Free convection (Split into ocean and Kato & Phillips?); 7. Gallery (movies!); 8. Performance benchmarks; 9. Documentation of public (+ private?) user interface; 10. References section (if we want to store them all on one page). ## References in the docs; Unfortunately there is no support for bibtex citations/references in Documenter.jl and we have a lot of them =/ This has been brought up by @simonbyrne and @charleskawczynski: https://github.com/climate-machine/CLIMA/issues/152. For now I've just copy pasted stuff from the LaTeX document and left in the `\citet` and `\citep` commands. But we have a few options:; 1. Painstakingly format all the citations and references by hand using Markdown footnotes.; 2. Cite ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/474
https://github.com/CliMA/Oceananigans.jl/pull/474:1431,Integrability,interface,interface,1431,"e*. High-level documentation can be found at: https://www.overleaf.com/project/5d73051a46be42000164d1ef. ## Documentation contents; 1. Documentation home page (+ package description); 2. Continuous equations; 3. Numerical methods; 	1. Overview of time-stepping algorithm; 	2. Finite volume method; 	3. Staggered grid; 	4. Fractional step method; 5. Time stepping; 6. Spatial operators; 7. Poisson solvers; 8. Boundary conditions; 9. Turbulence closures; 10. Large eddy simulation; 4. Model setup (description of all the options); 5. Examples; 	1. Simple diffusion; 2. Two-dimensional turbulence; 3. Ocean wind mixing and convection; 4. Ocean convection with plankton; 5. Internal wave; 6. Thermal rising bubble?; 7. Lid-driven cavity?; 8. Eddying channel?; 6. Verification experiments; 1. Taylor-Green vortex; 2. Lid-driven cavity?; 3. Stratified Couette flow; 4. Free convection (Split into ocean and Kato & Phillips?); 7. Gallery (movies!); 8. Performance benchmarks; 9. Documentation of public (+ private?) user interface; 10. References section (if we want to store them all on one page). ## References in the docs; Unfortunately there is no support for bibtex citations/references in Documenter.jl and we have a lot of them =/ This has been brought up by @simonbyrne and @charleskawczynski: https://github.com/climate-machine/CLIMA/issues/152. For now I've just copy pasted stuff from the LaTeX document and left in the `\citet` and `\citep` commands. But we have a few options:; 1. Painstakingly format all the citations and references by hand using Markdown footnotes.; 2. Cite judiciously so we don't have to manually format as many references.; 3. Work on a general solution that integrates with Documenter. I'm leaning towards option 2. EDIT: @johncmarshall54 argues in favor of option 1, which I'm now leaning towards as well. ## Examples. Thanks @glwagner for writing all the examples, they generate beautiful tutorials that we can directly embed in the documentation!. 1. I had to modify ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/474
https://github.com/CliMA/Oceananigans.jl/pull/474:2105,Integrability,integrat,integrates,2105,"6. Thermal rising bubble?; 7. Lid-driven cavity?; 8. Eddying channel?; 6. Verification experiments; 1. Taylor-Green vortex; 2. Lid-driven cavity?; 3. Stratified Couette flow; 4. Free convection (Split into ocean and Kato & Phillips?); 7. Gallery (movies!); 8. Performance benchmarks; 9. Documentation of public (+ private?) user interface; 10. References section (if we want to store them all on one page). ## References in the docs; Unfortunately there is no support for bibtex citations/references in Documenter.jl and we have a lot of them =/ This has been brought up by @simonbyrne and @charleskawczynski: https://github.com/climate-machine/CLIMA/issues/152. For now I've just copy pasted stuff from the LaTeX document and left in the `\citet` and `\citep` commands. But we have a few options:; 1. Painstakingly format all the citations and references by hand using Markdown footnotes.; 2. Cite judiciously so we don't have to manually format as many references.; 3. Work on a general solution that integrates with Documenter. I'm leaning towards option 2. EDIT: @johncmarshall54 argues in favor of option 1, which I'm now leaning towards as well. ## Examples. Thanks @glwagner for writing all the examples, they generate beautiful tutorials that we can directly embed in the documentation!. 1. I had to modify the examples slightly as Documenter.jl will only show plots returned using `gcf()`.; 2. We should define a `show` function for `Model` as the current output pollutes all the examples.; 3. The two ocean convection examples take forever to compile to docs because they generate movies and Documenter might be trying to embed each frame as a separate image or something. It might be worth discussing whether we should just make all the examples Documenter/tutorial friendly, which means switching from movies to plotting a few frames. ## Some comments; 0. Unfortunately if we want to look at the docs, we have to build it locally for now =/; 1. Documenter uses KaTeX to render math, which",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/474
https://github.com/CliMA/Oceananigans.jl/pull/474:3235,Integrability,depend,depending,3235,"rences in the docs; Unfortunately there is no support for bibtex citations/references in Documenter.jl and we have a lot of them =/ This has been brought up by @simonbyrne and @charleskawczynski: https://github.com/climate-machine/CLIMA/issues/152. For now I've just copy pasted stuff from the LaTeX document and left in the `\citet` and `\citep` commands. But we have a few options:; 1. Painstakingly format all the citations and references by hand using Markdown footnotes.; 2. Cite judiciously so we don't have to manually format as many references.; 3. Work on a general solution that integrates with Documenter. I'm leaning towards option 2. EDIT: @johncmarshall54 argues in favor of option 1, which I'm now leaning towards as well. ## Examples. Thanks @glwagner for writing all the examples, they generate beautiful tutorials that we can directly embed in the documentation!. 1. I had to modify the examples slightly as Documenter.jl will only show plots returned using `gcf()`.; 2. We should define a `show` function for `Model` as the current output pollutes all the examples.; 3. The two ocean convection examples take forever to compile to docs because they generate movies and Documenter might be trying to embed each frame as a separate image or something. It might be worth discussing whether we should just make all the examples Documenter/tutorial friendly, which means switching from movies to plotting a few frames. ## Some comments; 0. Unfortunately if we want to look at the docs, we have to build it locally for now =/; 1. Documenter uses KaTeX to render math, which is quite nice, but you have to modify the original LaTeX and avoid using fancy packages. But it has `\bm` which is awesome!; 2. I'm depending on `Documenter#master` as the upcoming v0.24 has an awesome new layout and dark mode.; 3. Documentation building on Travis is failing so gotta figure this out as well. Resolves #102; Resolves #222; Resolves #240; Resolves #327; Resolves #332; Resolves #353; Resolves #354",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/474
https://github.com/CliMA/Oceananigans.jl/pull/474:1362,Performance,Perform,Performance,1362,"try to the *Journal of Open Source Software*. High-level documentation can be found at: https://www.overleaf.com/project/5d73051a46be42000164d1ef. ## Documentation contents; 1. Documentation home page (+ package description); 2. Continuous equations; 3. Numerical methods; 	1. Overview of time-stepping algorithm; 	2. Finite volume method; 	3. Staggered grid; 	4. Fractional step method; 5. Time stepping; 6. Spatial operators; 7. Poisson solvers; 8. Boundary conditions; 9. Turbulence closures; 10. Large eddy simulation; 4. Model setup (description of all the options); 5. Examples; 	1. Simple diffusion; 2. Two-dimensional turbulence; 3. Ocean wind mixing and convection; 4. Ocean convection with plankton; 5. Internal wave; 6. Thermal rising bubble?; 7. Lid-driven cavity?; 8. Eddying channel?; 6. Verification experiments; 1. Taylor-Green vortex; 2. Lid-driven cavity?; 3. Stratified Couette flow; 4. Free convection (Split into ocean and Kato & Phillips?); 7. Gallery (movies!); 8. Performance benchmarks; 9. Documentation of public (+ private?) user interface; 10. References section (if we want to store them all on one page). ## References in the docs; Unfortunately there is no support for bibtex citations/references in Documenter.jl and we have a lot of them =/ This has been brought up by @simonbyrne and @charleskawczynski: https://github.com/climate-machine/CLIMA/issues/152. For now I've just copy pasted stuff from the LaTeX document and left in the `\citet` and `\citep` commands. But we have a few options:; 1. Painstakingly format all the citations and references by hand using Markdown footnotes.; 2. Cite judiciously so we don't have to manually format as many references.; 3. Work on a general solution that integrates with Documenter. I'm leaning towards option 2. EDIT: @johncmarshall54 argues in favor of option 1, which I'm now leaning towards as well. ## Examples. Thanks @glwagner for writing all the examples, they generate beautiful tutorials that we can directly embed ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/474
https://github.com/CliMA/Oceananigans.jl/pull/474:3164,Safety,avoid,avoid,3164,"rences in the docs; Unfortunately there is no support for bibtex citations/references in Documenter.jl and we have a lot of them =/ This has been brought up by @simonbyrne and @charleskawczynski: https://github.com/climate-machine/CLIMA/issues/152. For now I've just copy pasted stuff from the LaTeX document and left in the `\citet` and `\citep` commands. But we have a few options:; 1. Painstakingly format all the citations and references by hand using Markdown footnotes.; 2. Cite judiciously so we don't have to manually format as many references.; 3. Work on a general solution that integrates with Documenter. I'm leaning towards option 2. EDIT: @johncmarshall54 argues in favor of option 1, which I'm now leaning towards as well. ## Examples. Thanks @glwagner for writing all the examples, they generate beautiful tutorials that we can directly embed in the documentation!. 1. I had to modify the examples slightly as Documenter.jl will only show plots returned using `gcf()`.; 2. We should define a `show` function for `Model` as the current output pollutes all the examples.; 3. The two ocean convection examples take forever to compile to docs because they generate movies and Documenter might be trying to embed each frame as a separate image or something. It might be worth discussing whether we should just make all the examples Documenter/tutorial friendly, which means switching from movies to plotting a few frames. ## Some comments; 0. Unfortunately if we want to look at the docs, we have to build it locally for now =/; 1. Documenter uses KaTeX to render math, which is quite nice, but you have to modify the original LaTeX and avoid using fancy packages. But it has `\bm` which is awesome!; 2. I'm depending on `Documenter#master` as the upcoming v0.24 has an awesome new layout and dark mode.; 3. Documentation building on Travis is failing so gotta figure this out as well. Resolves #102; Resolves #222; Resolves #240; Resolves #327; Resolves #332; Resolves #353; Resolves #354",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/474
https://github.com/CliMA/Oceananigans.jl/pull/474:1374,Testability,benchmark,benchmarks,1374,"try to the *Journal of Open Source Software*. High-level documentation can be found at: https://www.overleaf.com/project/5d73051a46be42000164d1ef. ## Documentation contents; 1. Documentation home page (+ package description); 2. Continuous equations; 3. Numerical methods; 	1. Overview of time-stepping algorithm; 	2. Finite volume method; 	3. Staggered grid; 	4. Fractional step method; 5. Time stepping; 6. Spatial operators; 7. Poisson solvers; 8. Boundary conditions; 9. Turbulence closures; 10. Large eddy simulation; 4. Model setup (description of all the options); 5. Examples; 	1. Simple diffusion; 2. Two-dimensional turbulence; 3. Ocean wind mixing and convection; 4. Ocean convection with plankton; 5. Internal wave; 6. Thermal rising bubble?; 7. Lid-driven cavity?; 8. Eddying channel?; 6. Verification experiments; 1. Taylor-Green vortex; 2. Lid-driven cavity?; 3. Stratified Couette flow; 4. Free convection (Split into ocean and Kato & Phillips?); 7. Gallery (movies!); 8. Performance benchmarks; 9. Documentation of public (+ private?) user interface; 10. References section (if we want to store them all on one page). ## References in the docs; Unfortunately there is no support for bibtex citations/references in Documenter.jl and we have a lot of them =/ This has been brought up by @simonbyrne and @charleskawczynski: https://github.com/climate-machine/CLIMA/issues/152. For now I've just copy pasted stuff from the LaTeX document and left in the `\citet` and `\citep` commands. But we have a few options:; 1. Painstakingly format all the citations and references by hand using Markdown footnotes.; 2. Cite judiciously so we don't have to manually format as many references.; 3. Work on a general solution that integrates with Documenter. I'm leaning towards option 2. EDIT: @johncmarshall54 argues in favor of option 1, which I'm now leaning towards as well. ## Examples. Thanks @glwagner for writing all the examples, they generate beautiful tutorials that we can directly embed ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/474
https://github.com/CliMA/Oceananigans.jl/pull/474:963,Usability,Simpl,Simple,963,"This will be one big PR that merges in; 1. code/interface documentation from docstrings,; 2. high-level documentation about the continuous equations and numerical methods employed,; 3. documentation about the verification experiments, and; 4. generated Markdown tutorials from the Literate.jl examples. Once we're happy with the documentation, we'll be ready to submit an entry to the *Journal of Open Source Software*. High-level documentation can be found at: https://www.overleaf.com/project/5d73051a46be42000164d1ef. ## Documentation contents; 1. Documentation home page (+ package description); 2. Continuous equations; 3. Numerical methods; 	1. Overview of time-stepping algorithm; 	2. Finite volume method; 	3. Staggered grid; 	4. Fractional step method; 5. Time stepping; 6. Spatial operators; 7. Poisson solvers; 8. Boundary conditions; 9. Turbulence closures; 10. Large eddy simulation; 4. Model setup (description of all the options); 5. Examples; 	1. Simple diffusion; 2. Two-dimensional turbulence; 3. Ocean wind mixing and convection; 4. Ocean convection with plankton; 5. Internal wave; 6. Thermal rising bubble?; 7. Lid-driven cavity?; 8. Eddying channel?; 6. Verification experiments; 1. Taylor-Green vortex; 2. Lid-driven cavity?; 3. Stratified Couette flow; 4. Free convection (Split into ocean and Kato & Phillips?); 7. Gallery (movies!); 8. Performance benchmarks; 9. Documentation of public (+ private?) user interface; 10. References section (if we want to store them all on one page). ## References in the docs; Unfortunately there is no support for bibtex citations/references in Documenter.jl and we have a lot of them =/ This has been brought up by @simonbyrne and @charleskawczynski: https://github.com/climate-machine/CLIMA/issues/152. For now I've just copy pasted stuff from the LaTeX document and left in the `\citet` and `\citep` commands. But we have a few options:; 1. Painstakingly format all the citations and references by hand using Markdown footnotes.; 2. Cite ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/474
https://github.com/CliMA/Oceananigans.jl/pull/475:106,Performance,perform,performance,106,With this PR we can now apply boundary conditions on `x` and `y`. I still need to add tests and benchmark performance (nothing should change). One discussion point: Should we even add support for `x` boundary conditions seeing as we only support `Periodic` boundary conditions in the `x` direction?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/475
https://github.com/CliMA/Oceananigans.jl/pull/475:86,Testability,test,tests,86,With this PR we can now apply boundary conditions on `x` and `y`. I still need to add tests and benchmark performance (nothing should change). One discussion point: Should we even add support for `x` boundary conditions seeing as we only support `Periodic` boundary conditions in the `x` direction?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/475
https://github.com/CliMA/Oceananigans.jl/pull/475:96,Testability,benchmark,benchmark,96,With this PR we can now apply boundary conditions on `x` and `y`. I still need to add tests and benchmark performance (nothing should change). One discussion point: Should we even add support for `x` boundary conditions seeing as we only support `Periodic` boundary conditions in the `x` direction?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/475
https://github.com/CliMA/Oceananigans.jl/pull/476:102,Testability,test,test,102,"This PR adds a work-in-progress lid-driven cavity verification experiment. It also somewhat acts as a test for PR #475. It's a very classic test case and makes for a nice simple example: https://www.cfd-online.com/Wiki/Lid-driven_cavity_problem. I will compare point-wise velocity values along vertical and horizontal lines through the geometric center of the cavity at a resolution of 128x128 for various Reynolds numbers from Re=100 to Re=10,000. The values are reported in Tables 1 and 2 of [Ghia et al. (1982)](https://doi.org/10.1016/0021-9991(82)90058-4). Basically doing what this YouTube video is doing: https://www.youtube.com/watch?v=gkg3nG_qU7g. Helps with #332 and #346",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/476
https://github.com/CliMA/Oceananigans.jl/pull/476:140,Testability,test,test,140,"This PR adds a work-in-progress lid-driven cavity verification experiment. It also somewhat acts as a test for PR #475. It's a very classic test case and makes for a nice simple example: https://www.cfd-online.com/Wiki/Lid-driven_cavity_problem. I will compare point-wise velocity values along vertical and horizontal lines through the geometric center of the cavity at a resolution of 128x128 for various Reynolds numbers from Re=100 to Re=10,000. The values are reported in Tables 1 and 2 of [Ghia et al. (1982)](https://doi.org/10.1016/0021-9991(82)90058-4). Basically doing what this YouTube video is doing: https://www.youtube.com/watch?v=gkg3nG_qU7g. Helps with #332 and #346",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/476
https://github.com/CliMA/Oceananigans.jl/pull/476:171,Usability,simpl,simple,171,"This PR adds a work-in-progress lid-driven cavity verification experiment. It also somewhat acts as a test for PR #475. It's a very classic test case and makes for a nice simple example: https://www.cfd-online.com/Wiki/Lid-driven_cavity_problem. I will compare point-wise velocity values along vertical and horizontal lines through the geometric center of the cavity at a resolution of 128x128 for various Reynolds numbers from Re=100 to Re=10,000. The values are reported in Tables 1 and 2 of [Ghia et al. (1982)](https://doi.org/10.1016/0021-9991(82)90058-4). Basically doing what this YouTube video is doing: https://www.youtube.com/watch?v=gkg3nG_qU7g. Helps with #332 and #346",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/476
https://github.com/CliMA/Oceananigans.jl/pull/477:9,Deployability,release,release,9,"Going to release a new version as quite a bit has been merged since v0.11.0, and arbitrary tracers (PR #452) will probably be the focus of v0.12.0.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/477
https://github.com/CliMA/Oceananigans.jl/pull/478:233,Integrability,message,message,233,I'd like to define a custom logger for the logging the progress of models (ModelLogger). It's based on `Logging.SimpleLogger` and currently attempts to format `@info` calls as:; `[dd/mm/yyyy HH:MM:SS] module source_file:line_number: message`. Once that is in place I'd like to define some custom LogStates and have ModelLogger handle those as well. Chiefly `@diagnostic`. . I wired up one of the examples to use ModelLogger rather than printf.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/478
https://github.com/CliMA/Oceananigans.jl/pull/478:28,Testability,log,logger,28,I'd like to define a custom logger for the logging the progress of models (ModelLogger). It's based on `Logging.SimpleLogger` and currently attempts to format `@info` calls as:; `[dd/mm/yyyy HH:MM:SS] module source_file:line_number: message`. Once that is in place I'd like to define some custom LogStates and have ModelLogger handle those as well. Chiefly `@diagnostic`. . I wired up one of the examples to use ModelLogger rather than printf.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/478
https://github.com/CliMA/Oceananigans.jl/pull/478:43,Testability,log,logging,43,I'd like to define a custom logger for the logging the progress of models (ModelLogger). It's based on `Logging.SimpleLogger` and currently attempts to format `@info` calls as:; `[dd/mm/yyyy HH:MM:SS] module source_file:line_number: message`. Once that is in place I'd like to define some custom LogStates and have ModelLogger handle those as well. Chiefly `@diagnostic`. . I wired up one of the examples to use ModelLogger rather than printf.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/478
https://github.com/CliMA/Oceananigans.jl/pull/478:104,Testability,Log,Logging,104,I'd like to define a custom logger for the logging the progress of models (ModelLogger). It's based on `Logging.SimpleLogger` and currently attempts to format `@info` calls as:; `[dd/mm/yyyy HH:MM:SS] module source_file:line_number: message`. Once that is in place I'd like to define some custom LogStates and have ModelLogger handle those as well. Chiefly `@diagnostic`. . I wired up one of the examples to use ModelLogger rather than printf.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/478
https://github.com/CliMA/Oceananigans.jl/pull/478:296,Testability,Log,LogStates,296,I'd like to define a custom logger for the logging the progress of models (ModelLogger). It's based on `Logging.SimpleLogger` and currently attempts to format `@info` calls as:; `[dd/mm/yyyy HH:MM:SS] module source_file:line_number: message`. Once that is in place I'd like to define some custom LogStates and have ModelLogger handle those as well. Chiefly `@diagnostic`. . I wired up one of the examples to use ModelLogger rather than printf.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/478
https://github.com/CliMA/Oceananigans.jl/pull/478:112,Usability,Simpl,SimpleLogger,112,I'd like to define a custom logger for the logging the progress of models (ModelLogger). It's based on `Logging.SimpleLogger` and currently attempts to format `@info` calls as:; `[dd/mm/yyyy HH:MM:SS] module source_file:line_number: message`. Once that is in place I'd like to define some custom LogStates and have ModelLogger handle those as well. Chiefly `@diagnostic`. . I wired up one of the examples to use ModelLogger rather than printf.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/478
https://github.com/CliMA/Oceananigans.jl/pull/479:28,Testability,test,tests,28,This PR adds two regression tests for models that use the `ConstantSmagorinsky` closure and the `AnisotropicMinimumDissipation` closure. It also organizes the regression tests into a separate directory. Resolves #473,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/479
https://github.com/CliMA/Oceananigans.jl/pull/479:170,Testability,test,tests,170,This PR adds two regression tests for models that use the `ConstantSmagorinsky` closure and the `AnisotropicMinimumDissipation` closure. It also organizes the regression tests into a separate directory. Resolves #473,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/479
https://github.com/CliMA/Oceananigans.jl/issues/480:571,Availability,error,error,571,Noticed this because `test_diffusion_cosine` was failing in PR #462. We should have that `length(zC) == Nz` but; ```julia; julia> Nz = 16; Lz = π/2; Δz = Lz / Nz; zC = -Lz+Δz/2:Δz:-Δz/2; length(zC); 16. julia> Nz = 32; Lz = π/2; Δz = Lz / Nz; zC = -Lz+Δz/2:Δz:-Δz/2; length(zC); 32. julia> Nz = 64; Lz = π/2; Δz = Lz / Nz; zC = -Lz+Δz/2:Δz:-Δz/2; length(zC); 63. julia> Nz = 128; Lz = π/2; Δz = Lz / Nz; zC = -Lz+Δz/2:Δz:-Δz/2; length(zC); 127. julia> Nz = 256; Lz = π/2; Δz = Lz / Nz; zC = -Lz+Δz/2:Δz:-Δz/2; length(zC); 255; ```. Looks like a scary effect of round-off error to me. I'll make the switch to using the `range` function with a fixed `length` and add a test to check for this.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/480
https://github.com/CliMA/Oceananigans.jl/issues/480:667,Testability,test,test,667,Noticed this because `test_diffusion_cosine` was failing in PR #462. We should have that `length(zC) == Nz` but; ```julia; julia> Nz = 16; Lz = π/2; Δz = Lz / Nz; zC = -Lz+Δz/2:Δz:-Δz/2; length(zC); 16. julia> Nz = 32; Lz = π/2; Δz = Lz / Nz; zC = -Lz+Δz/2:Δz:-Δz/2; length(zC); 32. julia> Nz = 64; Lz = π/2; Δz = Lz / Nz; zC = -Lz+Δz/2:Δz:-Δz/2; length(zC); 63. julia> Nz = 128; Lz = π/2; Δz = Lz / Nz; zC = -Lz+Δz/2:Δz:-Δz/2; length(zC); 127. julia> Nz = 256; Lz = π/2; Δz = Lz / Nz; zC = -Lz+Δz/2:Δz:-Δz/2; length(zC); 255; ```. Looks like a scary effect of round-off error to me. I'll make the switch to using the `range` function with a fixed `length` and add a test to check for this.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/480
https://github.com/CliMA/Oceananigans.jl/issues/481:52,Testability,test,test,52,If anyone is interested in setting up an example or test for advection: you set up a 2D model with a square or Gaussian initial condition for temperature and a constant background velocity that advects the square around the domain. We can use it to test our numerical methods and any advection schemes we implement in the future. It would be something like this: https://www.youtube.com/watch?v=NkSVHpZV-xU,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/481
https://github.com/CliMA/Oceananigans.jl/issues/481:249,Testability,test,test,249,If anyone is interested in setting up an example or test for advection: you set up a 2D model with a square or Gaussian initial condition for temperature and a constant background velocity that advects the square around the domain. We can use it to test our numerical methods and any advection schemes we implement in the future. It would be something like this: https://www.youtube.com/watch?v=NkSVHpZV-xU,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/481
https://github.com/CliMA/Oceananigans.jl/issues/483:62,Deployability,install,installing,62,"We should give some basic info, e.g. link to instructions for installing CUDA, how to check that your GPU is compatible, etc.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/483
https://github.com/CliMA/Oceananigans.jl/pull/484:88,Testability,test,tests,88,This PR picks up from where PR #479 left off. From #479:. > This PR adds two regression tests for models that use the ConstantSmagorinsky closure and the AnisotropicMinimumDissipation closure. It also organizes the regression tests into a separate directory. Resolves #473,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/484
https://github.com/CliMA/Oceananigans.jl/pull/484:226,Testability,test,tests,226,This PR picks up from where PR #479 left off. From #479:. > This PR adds two regression tests for models that use the ConstantSmagorinsky closure and the AnisotropicMinimumDissipation closure. It also organizes the regression tests into a separate directory. Resolves #473,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/484
https://github.com/CliMA/Oceananigans.jl/issues/487:45,Testability,test,test,45,"Seems like the `Float32` tracer conservation test is actually running with `Float64`... ```; [ Info: Tracer conservation after 10 time steps (CPU(), Float32): ⟨T⟩-T₀=-7.105427357601002e-14 °C; [ Info: Tracer conservation after 10 time steps (CPU(), Float64): ⟨T⟩-T₀=4.618527782440651e-14 °C; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/487
https://github.com/CliMA/Oceananigans.jl/pull/488:159,Deployability,update,updates,159,"This PR rewrites much of the docs, adds a show function for `Model` and various boundary conditions structures (which fixes very long output in the docs), and updates many of the examples to be docs-friendly. The docs are still very much preliminary even after the updates in this PR. Once this PR is merged, I will open an issue to define a roadmap for getting the docs to the place we need them to be.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/488
https://github.com/CliMA/Oceananigans.jl/pull/488:265,Deployability,update,updates,265,"This PR rewrites much of the docs, adds a show function for `Model` and various boundary conditions structures (which fixes very long output in the docs), and updates many of the examples to be docs-friendly. The docs are still very much preliminary even after the updates in this PR. Once this PR is merged, I will open an issue to define a roadmap for getting the docs to the place we need them to be.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/488
https://github.com/CliMA/Oceananigans.jl/pull/488:8,Modifiability,rewrite,rewrites,8,"This PR rewrites much of the docs, adds a show function for `Model` and various boundary conditions structures (which fixes very long output in the docs), and updates many of the examples to be docs-friendly. The docs are still very much preliminary even after the updates in this PR. Once this PR is merged, I will open an issue to define a roadmap for getting the docs to the place we need them to be.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/488
https://github.com/CliMA/Oceananigans.jl/pull/490:144,Testability,test,test,144,"This PR introduces a Beta Plane option for Coriolis. If merged, it will replace #438. We should consider introducing an example (and regression test based on that example) that runs a model on a beta plane, and in a channel to demonstrate / test some currently undemonstrated features. Co-authored with @suyashbire1.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/490
https://github.com/CliMA/Oceananigans.jl/pull/490:241,Testability,test,test,241,"This PR introduces a Beta Plane option for Coriolis. If merged, it will replace #438. We should consider introducing an example (and regression test based on that example) that runs a model on a beta plane, and in a channel to demonstrate / test some currently undemonstrated features. Co-authored with @suyashbire1.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/490
https://github.com/CliMA/Oceananigans.jl/issues/491:800,Usability,simpl,simplify,800,"Title sounds ridiculous but @jm-c mentioned that for stretched grids, models (e.g. WRF) usually place the cell center halfway between the two cell faces, but apparently this choice can be relaxed so that you can specify cell centers to be slightly offset from the true center. I guess they won't be ""cell centers"" anymore, but just opening an issue in case there's anything to discuss. Without assuming cell centers are halfway between the two faces then interpolation operators are a bit more complicated; ```julia; @inline ℑz_aac(i, j, k, grid::VerticallyStretchedCartesianGrid, f) =; @inbounds ((grid.zC[k] - grid.zF[k]) * f[k, j, i] + (grid.zF[k+1] - grid.zC[k]) * f[k+1, j, i]) / grid.ΔzF[k]; ```; and if we assume e.g. `grid.zC[k] - grid.zF[k] = grid.ΔzF[k]/2` then the interpolation operators simplify. So it seems maybe we should just assume that the cell centers are exactly halfway between the faces, unless there's a good reason or important use case for having custom/offset cell center locations.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/491
https://github.com/CliMA/Oceananigans.jl/issues/493:10,Testability,test,test,10,We should test our docs:. https://juliadocs.github.io/Documenter.jl/stable/man/doctests/index.html,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/493
https://github.com/CliMA/Oceananigans.jl/pull/494:25,Deployability,release,release,25,This is an important tag/release because the model now has `k=1` at the bottom which effects post-processing and plotting scripts.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/494
https://github.com/CliMA/Oceananigans.jl/issues/495:190,Testability,log,logical,190,"Probably makes sense to split `output_writers.jl`, `diagnostics.jl`, and `poisson_solvers.jl` into submodules. They're turning into megafiles that will benefit from being split into smaller logical chunks. And this will probably only get worse with time.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/495
https://github.com/CliMA/Oceananigans.jl/pull/496:53,Safety,avoid,avoid,53,This PR nukes the `BasicModel` legacy constructor to avoid potential confusion. I also made the `NonDimensionalModel` constructor act more like the `Model` constructor. Also fixed a typo there and added a test. Resolves #429,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/496
https://github.com/CliMA/Oceananigans.jl/pull/496:205,Testability,test,test,205,This PR nukes the `BasicModel` legacy constructor to avoid potential confusion. I also made the `NonDimensionalModel` constructor act more like the `Model` constructor. Also fixed a typo there and added a test. Resolves #429,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/496
https://github.com/CliMA/Oceananigans.jl/issues/497:427,Usability,clear,clearer,427,"There are a couple of files (e.g. `Oceananigans.jl` and `runtests.jl`) that have these mega import statements where a lot of things are imported. I find it hard to understand why certain things are being imported and where they are being used, so I'm thinking it might be better if we import things at the top of the file where they are being used. This means using more local import statements which I'm thinking will make it clearer where and why things are being imported and used. @glwagner @suyashbire1: What do you guys think?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/497
https://github.com/CliMA/Oceananigans.jl/pull/498:8,Modifiability,refactor,refactors,8,This PR refactors `diagnostics.jl` and `output_writers.jl` into their own submodules. We might want to discuss #497 as we refactor things into submodules as it increases the number of cross-module import statements. Helps with #456 and #495,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/498
https://github.com/CliMA/Oceananigans.jl/pull/498:122,Modifiability,refactor,refactor,122,This PR refactors `diagnostics.jl` and `output_writers.jl` into their own submodules. We might want to discuss #497 as we refactor things into submodules as it increases the number of cross-module import statements. Helps with #456 and #495,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/498
https://github.com/CliMA/Oceananigans.jl/issues/501:1547,Integrability,interface,interface,1547,"We need an abstraction for calculating moving averages. We could call this `TimeAverage`, `MovingTimeAverage`, or maybe `AveragedTimeSeries` --- or something else sensible. (Also, should `Timeseries` actually be `TimeSeries`?). To do this I think we should build something that shares a lot of syntax with `TimeSeries`, which is defined via. ```julia; struct TimeSeries{D, Ω, I, T, TT} <: AbstractDiagnostic; diagnostic :: D; frequency :: Ω; interval :: I; data :: T; time :: Vector{TT}; end; ```. The main challenge is designing syntax that isn't confusing. In `TimeSeries`, the `frequency` field refers to the frequency at which the time series is recorded. However, an `AveragedTimeSeries` diagnostic has two frequencies --- the frequency with which the raw data is acquired, and the frequency / interval at which the time-average is calculated. Thus we want something more like. ```julia; mutable struct AveragedTimeseries{D, Ω, I, X, T, TT} <: AbstractDiagnostic; diagnostic :: D; timeseries_frequency :: Ω # good name?; averaging_interval :: I; # other needed fields; integrand :: X # something to store accumulated timeseries output; data :: T # an ""averaged timeseries"", or a timeseries with moving average applied ; time :: Vector{TT}; end; ```. The reason the user might want to change the `timeseries_frequency` is if the object they are averaging is expensive to compute. . Thoughts?. A related issue is how to output time series that are collected via diagnostics (obviously they can be saved brute force, but it'd be nice to have an interface). I'll open another issue to address this.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/501
https://github.com/CliMA/Oceananigans.jl/issues/502:1013,Availability,down,downside,1013,"We currently have a `Timeseries` diagnostic which accumulates the output of `some_function(model)` in a vector `data`. . It'd be nice to have a simple way to save a timeseries to file. The problem is that we don't want to duplicate data; eg we want to periodically append data to an array that was previously saved in a file. . Note that it is not possible to, for example, delete data within a `JLD2` file and replace it with something else:. https://github.com/JuliaIO/JLD2.jl/issues/38. @ali-ramadhan @suyashbire1 is this possible in NetCDF / `NCDatasets.jl`?. There are two other possibilities. One is to ""unspool"" the time series into a `group` within a `JLD2` file and write the data from each time stamp individually in the file. This allows new data to be appended to the group easily. I'm not sure how performant this would be, but perhaps its fine. The second is to simply delete the old file and replace it with a new one with the updated time series. This is the hack that I've been using so far. The downside is that we have to save each timeseries in their own file. Curious to hear if there are any other ideas for solving this problem.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/502
https://github.com/CliMA/Oceananigans.jl/issues/502:942,Deployability,update,updated,942,"We currently have a `Timeseries` diagnostic which accumulates the output of `some_function(model)` in a vector `data`. . It'd be nice to have a simple way to save a timeseries to file. The problem is that we don't want to duplicate data; eg we want to periodically append data to an array that was previously saved in a file. . Note that it is not possible to, for example, delete data within a `JLD2` file and replace it with something else:. https://github.com/JuliaIO/JLD2.jl/issues/38. @ali-ramadhan @suyashbire1 is this possible in NetCDF / `NCDatasets.jl`?. There are two other possibilities. One is to ""unspool"" the time series into a `group` within a `JLD2` file and write the data from each time stamp individually in the file. This allows new data to be appended to the group easily. I'm not sure how performant this would be, but perhaps its fine. The second is to simply delete the old file and replace it with a new one with the updated time series. This is the hack that I've been using so far. The downside is that we have to save each timeseries in their own file. Curious to hear if there are any other ideas for solving this problem.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/502
https://github.com/CliMA/Oceananigans.jl/issues/502:811,Performance,perform,performant,811,"We currently have a `Timeseries` diagnostic which accumulates the output of `some_function(model)` in a vector `data`. . It'd be nice to have a simple way to save a timeseries to file. The problem is that we don't want to duplicate data; eg we want to periodically append data to an array that was previously saved in a file. . Note that it is not possible to, for example, delete data within a `JLD2` file and replace it with something else:. https://github.com/JuliaIO/JLD2.jl/issues/38. @ali-ramadhan @suyashbire1 is this possible in NetCDF / `NCDatasets.jl`?. There are two other possibilities. One is to ""unspool"" the time series into a `group` within a `JLD2` file and write the data from each time stamp individually in the file. This allows new data to be appended to the group easily. I'm not sure how performant this would be, but perhaps its fine. The second is to simply delete the old file and replace it with a new one with the updated time series. This is the hack that I've been using so far. The downside is that we have to save each timeseries in their own file. Curious to hear if there are any other ideas for solving this problem.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/502
https://github.com/CliMA/Oceananigans.jl/issues/502:144,Usability,simpl,simple,144,"We currently have a `Timeseries` diagnostic which accumulates the output of `some_function(model)` in a vector `data`. . It'd be nice to have a simple way to save a timeseries to file. The problem is that we don't want to duplicate data; eg we want to periodically append data to an array that was previously saved in a file. . Note that it is not possible to, for example, delete data within a `JLD2` file and replace it with something else:. https://github.com/JuliaIO/JLD2.jl/issues/38. @ali-ramadhan @suyashbire1 is this possible in NetCDF / `NCDatasets.jl`?. There are two other possibilities. One is to ""unspool"" the time series into a `group` within a `JLD2` file and write the data from each time stamp individually in the file. This allows new data to be appended to the group easily. I'm not sure how performant this would be, but perhaps its fine. The second is to simply delete the old file and replace it with a new one with the updated time series. This is the hack that I've been using so far. The downside is that we have to save each timeseries in their own file. Curious to hear if there are any other ideas for solving this problem.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/502
https://github.com/CliMA/Oceananigans.jl/issues/502:876,Usability,simpl,simply,876,"We currently have a `Timeseries` diagnostic which accumulates the output of `some_function(model)` in a vector `data`. . It'd be nice to have a simple way to save a timeseries to file. The problem is that we don't want to duplicate data; eg we want to periodically append data to an array that was previously saved in a file. . Note that it is not possible to, for example, delete data within a `JLD2` file and replace it with something else:. https://github.com/JuliaIO/JLD2.jl/issues/38. @ali-ramadhan @suyashbire1 is this possible in NetCDF / `NCDatasets.jl`?. There are two other possibilities. One is to ""unspool"" the time series into a `group` within a `JLD2` file and write the data from each time stamp individually in the file. This allows new data to be appended to the group easily. I'm not sure how performant this would be, but perhaps its fine. The second is to simply delete the old file and replace it with a new one with the updated time series. This is the hack that I've been using so far. The downside is that we have to save each timeseries in their own file. Curious to hear if there are any other ideas for solving this problem.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/502
https://github.com/CliMA/Oceananigans.jl/pull/505:64,Modifiability,refactor,refactors,64,"This PR moves the time stepping functionality into a module and refactors and orthogonalizes the time-stepping algorithm to make it easier to implement new time steppers. . It also introduces a macro `@loop_xyz` that copy-pastes code to specify a 3D loop, reducing a lot of boiler plate. There is also a new function `compute_w_from_continuity!(model)` that a user might employ to ensure their initial velocity field is non-divergent. . Resolves #485 ; Resolves #461 ; Probably resolves #448",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/505
https://github.com/CliMA/Oceananigans.jl/issues/506:289,Deployability,integrat,integrate,289,"We need to implement a forward Euler time-stepping scheme, which is useful for testing if for nothing else. We need also better and more stable time-steppers. One option is to implement by hand a 3rd-order low storage Runge Kutta scheme. Another interesting avenue is to figure out how to integrate with `DifferentialEquations.jl`, which would give us access to a large number of new time-steppers (issue #391). However, we are unsure how this would couple with the our incoming GPU tridiagonal solvers for implicit time-stepping.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/506
https://github.com/CliMA/Oceananigans.jl/issues/506:289,Integrability,integrat,integrate,289,"We need to implement a forward Euler time-stepping scheme, which is useful for testing if for nothing else. We need also better and more stable time-steppers. One option is to implement by hand a 3rd-order low storage Runge Kutta scheme. Another interesting avenue is to figure out how to integrate with `DifferentialEquations.jl`, which would give us access to a large number of new time-steppers (issue #391). However, we are unsure how this would couple with the our incoming GPU tridiagonal solvers for implicit time-stepping.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/506
https://github.com/CliMA/Oceananigans.jl/issues/506:352,Security,access,access,352,"We need to implement a forward Euler time-stepping scheme, which is useful for testing if for nothing else. We need also better and more stable time-steppers. One option is to implement by hand a 3rd-order low storage Runge Kutta scheme. Another interesting avenue is to figure out how to integrate with `DifferentialEquations.jl`, which would give us access to a large number of new time-steppers (issue #391). However, we are unsure how this would couple with the our incoming GPU tridiagonal solvers for implicit time-stepping.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/506
https://github.com/CliMA/Oceananigans.jl/issues/506:79,Testability,test,testing,79,"We need to implement a forward Euler time-stepping scheme, which is useful for testing if for nothing else. We need also better and more stable time-steppers. One option is to implement by hand a 3rd-order low storage Runge Kutta scheme. Another interesting avenue is to figure out how to integrate with `DifferentialEquations.jl`, which would give us access to a large number of new time-steppers (issue #391). However, we are unsure how this would couple with the our incoming GPU tridiagonal solvers for implicit time-stepping.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/506
https://github.com/CliMA/Oceananigans.jl/pull/508:27,Security,validat,validation,27,"Plus some cleanup of input validation, and a test.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/508
https://github.com/CliMA/Oceananigans.jl/pull/508:45,Testability,test,test,45,"Plus some cleanup of input validation, and a test.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/508
https://github.com/CliMA/Oceananigans.jl/issues/509:454,Testability,test,test,454,"I noticed that our git repo has ballooned in size some time in the past week. Someone, possibly me, committed a 52 MiB `ocean_wind_mixing_and_convection.jld2` file, possibly generated by running the example? But `docs/src/generated` is in `.gitignore` so not sure how it made it in. Either way, I think we should scrub it because the repo size has increased by an order of magnitude... ---. Here's a list of files over 500 KiB:; ```; d277a4e5393b 650KiB test/regression_tests/data/data_rayleigh_benard_regression.jld2; b125bc6f8e9d 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; f5c1a7736324 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; 0b493fa7dd14 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; ad020f12370b 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 0ee7298c84ad 731KiB test/thermal_bubble_golden_master_model_checkpoint_10.jld; eeeca1f2b394 2.4MiB test/deep_convection_golden_master_model_checkpoint_10.jld; 4eb0499aa289 52MiB dev/generated/ocean_wind_mixing_and_convection.jld2; 5b613ce426d5 52MiB v0.14.1/generated/ocean_wind_mixing_and_convection.jld2; 7fddefca8cc0 52MiB dev/generated/ocean_wind_mixing_and_convection.jld2; b5c2ca7312e5 52MiB dev/generated/ocean_wind_mixing_and_convection.jld2; d1ee57ba2365 52MiB dev/generated/ocean_wind_mixing_and_convection.jld2; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/509
https://github.com/CliMA/Oceananigans.jl/issues/509:539,Testability,test,test,539,"I noticed that our git repo has ballooned in size some time in the past week. Someone, possibly me, committed a 52 MiB `ocean_wind_mixing_and_convection.jld2` file, possibly generated by running the example? But `docs/src/generated` is in `.gitignore` so not sure how it made it in. Either way, I think we should scrub it because the repo size has increased by an order of magnitude... ---. Here's a list of files over 500 KiB:; ```; d277a4e5393b 650KiB test/regression_tests/data/data_rayleigh_benard_regression.jld2; b125bc6f8e9d 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; f5c1a7736324 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; 0b493fa7dd14 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; ad020f12370b 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 0ee7298c84ad 731KiB test/thermal_bubble_golden_master_model_checkpoint_10.jld; eeeca1f2b394 2.4MiB test/deep_convection_golden_master_model_checkpoint_10.jld; 4eb0499aa289 52MiB dev/generated/ocean_wind_mixing_and_convection.jld2; 5b613ce426d5 52MiB v0.14.1/generated/ocean_wind_mixing_and_convection.jld2; 7fddefca8cc0 52MiB dev/generated/ocean_wind_mixing_and_convection.jld2; b5c2ca7312e5 52MiB dev/generated/ocean_wind_mixing_and_convection.jld2; d1ee57ba2365 52MiB dev/generated/ocean_wind_mixing_and_convection.jld2; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/509
https://github.com/CliMA/Oceananigans.jl/issues/509:666,Testability,test,test,666,"I noticed that our git repo has ballooned in size some time in the past week. Someone, possibly me, committed a 52 MiB `ocean_wind_mixing_and_convection.jld2` file, possibly generated by running the example? But `docs/src/generated` is in `.gitignore` so not sure how it made it in. Either way, I think we should scrub it because the repo size has increased by an order of magnitude... ---. Here's a list of files over 500 KiB:; ```; d277a4e5393b 650KiB test/regression_tests/data/data_rayleigh_benard_regression.jld2; b125bc6f8e9d 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; f5c1a7736324 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; 0b493fa7dd14 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; ad020f12370b 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 0ee7298c84ad 731KiB test/thermal_bubble_golden_master_model_checkpoint_10.jld; eeeca1f2b394 2.4MiB test/deep_convection_golden_master_model_checkpoint_10.jld; 4eb0499aa289 52MiB dev/generated/ocean_wind_mixing_and_convection.jld2; 5b613ce426d5 52MiB v0.14.1/generated/ocean_wind_mixing_and_convection.jld2; 7fddefca8cc0 52MiB dev/generated/ocean_wind_mixing_and_convection.jld2; b5c2ca7312e5 52MiB dev/generated/ocean_wind_mixing_and_convection.jld2; d1ee57ba2365 52MiB dev/generated/ocean_wind_mixing_and_convection.jld2; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/509
https://github.com/CliMA/Oceananigans.jl/issues/509:793,Testability,test,test,793,"I noticed that our git repo has ballooned in size some time in the past week. Someone, possibly me, committed a 52 MiB `ocean_wind_mixing_and_convection.jld2` file, possibly generated by running the example? But `docs/src/generated` is in `.gitignore` so not sure how it made it in. Either way, I think we should scrub it because the repo size has increased by an order of magnitude... ---. Here's a list of files over 500 KiB:; ```; d277a4e5393b 650KiB test/regression_tests/data/data_rayleigh_benard_regression.jld2; b125bc6f8e9d 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; f5c1a7736324 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; 0b493fa7dd14 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; ad020f12370b 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 0ee7298c84ad 731KiB test/thermal_bubble_golden_master_model_checkpoint_10.jld; eeeca1f2b394 2.4MiB test/deep_convection_golden_master_model_checkpoint_10.jld; 4eb0499aa289 52MiB dev/generated/ocean_wind_mixing_and_convection.jld2; 5b613ce426d5 52MiB v0.14.1/generated/ocean_wind_mixing_and_convection.jld2; 7fddefca8cc0 52MiB dev/generated/ocean_wind_mixing_and_convection.jld2; b5c2ca7312e5 52MiB dev/generated/ocean_wind_mixing_and_convection.jld2; d1ee57ba2365 52MiB dev/generated/ocean_wind_mixing_and_convection.jld2; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/509
https://github.com/CliMA/Oceananigans.jl/issues/509:897,Testability,test,test,897,"I noticed that our git repo has ballooned in size some time in the past week. Someone, possibly me, committed a 52 MiB `ocean_wind_mixing_and_convection.jld2` file, possibly generated by running the example? But `docs/src/generated` is in `.gitignore` so not sure how it made it in. Either way, I think we should scrub it because the repo size has increased by an order of magnitude... ---. Here's a list of files over 500 KiB:; ```; d277a4e5393b 650KiB test/regression_tests/data/data_rayleigh_benard_regression.jld2; b125bc6f8e9d 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; f5c1a7736324 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; 0b493fa7dd14 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; ad020f12370b 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 0ee7298c84ad 731KiB test/thermal_bubble_golden_master_model_checkpoint_10.jld; eeeca1f2b394 2.4MiB test/deep_convection_golden_master_model_checkpoint_10.jld; 4eb0499aa289 52MiB dev/generated/ocean_wind_mixing_and_convection.jld2; 5b613ce426d5 52MiB v0.14.1/generated/ocean_wind_mixing_and_convection.jld2; 7fddefca8cc0 52MiB dev/generated/ocean_wind_mixing_and_convection.jld2; b5c2ca7312e5 52MiB dev/generated/ocean_wind_mixing_and_convection.jld2; d1ee57ba2365 52MiB dev/generated/ocean_wind_mixing_and_convection.jld2; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/509
https://github.com/CliMA/Oceananigans.jl/issues/509:1001,Testability,test,test,1001,"I noticed that our git repo has ballooned in size some time in the past week. Someone, possibly me, committed a 52 MiB `ocean_wind_mixing_and_convection.jld2` file, possibly generated by running the example? But `docs/src/generated` is in `.gitignore` so not sure how it made it in. Either way, I think we should scrub it because the repo size has increased by an order of magnitude... ---. Here's a list of files over 500 KiB:; ```; d277a4e5393b 650KiB test/regression_tests/data/data_rayleigh_benard_regression.jld2; b125bc6f8e9d 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; f5c1a7736324 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; 0b493fa7dd14 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; ad020f12370b 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 0ee7298c84ad 731KiB test/thermal_bubble_golden_master_model_checkpoint_10.jld; eeeca1f2b394 2.4MiB test/deep_convection_golden_master_model_checkpoint_10.jld; 4eb0499aa289 52MiB dev/generated/ocean_wind_mixing_and_convection.jld2; 5b613ce426d5 52MiB v0.14.1/generated/ocean_wind_mixing_and_convection.jld2; 7fddefca8cc0 52MiB dev/generated/ocean_wind_mixing_and_convection.jld2; b5c2ca7312e5 52MiB dev/generated/ocean_wind_mixing_and_convection.jld2; d1ee57ba2365 52MiB dev/generated/ocean_wind_mixing_and_convection.jld2; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/509
https://github.com/CliMA/Oceananigans.jl/issues/509:1080,Testability,test,test,1080,"I noticed that our git repo has ballooned in size some time in the past week. Someone, possibly me, committed a 52 MiB `ocean_wind_mixing_and_convection.jld2` file, possibly generated by running the example? But `docs/src/generated` is in `.gitignore` so not sure how it made it in. Either way, I think we should scrub it because the repo size has increased by an order of magnitude... ---. Here's a list of files over 500 KiB:; ```; d277a4e5393b 650KiB test/regression_tests/data/data_rayleigh_benard_regression.jld2; b125bc6f8e9d 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; f5c1a7736324 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; 0b493fa7dd14 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; ad020f12370b 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 0ee7298c84ad 731KiB test/thermal_bubble_golden_master_model_checkpoint_10.jld; eeeca1f2b394 2.4MiB test/deep_convection_golden_master_model_checkpoint_10.jld; 4eb0499aa289 52MiB dev/generated/ocean_wind_mixing_and_convection.jld2; 5b613ce426d5 52MiB v0.14.1/generated/ocean_wind_mixing_and_convection.jld2; 7fddefca8cc0 52MiB dev/generated/ocean_wind_mixing_and_convection.jld2; b5c2ca7312e5 52MiB dev/generated/ocean_wind_mixing_and_convection.jld2; d1ee57ba2365 52MiB dev/generated/ocean_wind_mixing_and_convection.jld2; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/509
https://github.com/CliMA/Oceananigans.jl/pull/512:8,Modifiability,refactor,refactors,8,"This PR refactors each of `grids.jl`, `poisson_solvers.jl`, `diagnostics.jl` and `output_writers.jl` into their own submodules. Moving stuff into modules is a pretty disruptive change that introduces tough merge conflicts into other PRs so I also created a Grids and a Solvers submodule in preparation for the vertically stretched grid as I didn't want to include them with vertically stretched PRs that could sit open for days. The whole code still feels a bit messy to me but I think working on #497 will help a lot. Helps with #456 and #495",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/512
https://github.com/CliMA/Oceananigans.jl/pull/513:15,Integrability,wrap,wrapper,15,"This PR adds a wrapper for boundary-conditions-as-functions called `BoundaryFunction`. From the docstring:. ```julia; """""" ; BoundaryFunction{B, X1, X2}(func). A wrapper for user-defined boundary condition functions on the; boundary specified by symbol `B` and at location `(X1, X2)`. Example; =======; julia> using Oceananigans: BoundaryCondition, BoundaryFunction, Flux, Cell. julia> top_tracer_flux = BoundaryFunction{:z, Cell, Cell}((x, y, t) -> cos(2π*x) * cos(t)); (::BoundaryFunction{:z,Cell,Cell,getfield(Main, Symbol(""##7#8""))}) (generic function with 1 method). julia> top_tracer_bc = BoundaryCondition(Flux, top_tracer_flux);; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/513
https://github.com/CliMA/Oceananigans.jl/pull/513:161,Integrability,wrap,wrapper,161,"This PR adds a wrapper for boundary-conditions-as-functions called `BoundaryFunction`. From the docstring:. ```julia; """""" ; BoundaryFunction{B, X1, X2}(func). A wrapper for user-defined boundary condition functions on the; boundary specified by symbol `B` and at location `(X1, X2)`. Example; =======; julia> using Oceananigans: BoundaryCondition, BoundaryFunction, Flux, Cell. julia> top_tracer_flux = BoundaryFunction{:z, Cell, Cell}((x, y, t) -> cos(2π*x) * cos(t)); (::BoundaryFunction{:z,Cell,Cell,getfield(Main, Symbol(""##7#8""))}) (generic function with 1 method). julia> top_tracer_bc = BoundaryCondition(Flux, top_tracer_flux);; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/513
https://github.com/CliMA/Oceananigans.jl/pull/515:8,Modifiability,refactor,refactors,8,This PR refactors the kernels for turbulence closures to pave the way for new closures that require knowledge of buoyancy and buoyancy gradients. It also performs some minor cleanup in `closure_operators.jl` and moves the turbulence closure implementations into a separate folder so that it is clear from the source structure which turbulence closures are implemented.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/515
https://github.com/CliMA/Oceananigans.jl/pull/515:154,Performance,perform,performs,154,This PR refactors the kernels for turbulence closures to pave the way for new closures that require knowledge of buoyancy and buoyancy gradients. It also performs some minor cleanup in `closure_operators.jl` and moves the turbulence closure implementations into a separate folder so that it is clear from the source structure which turbulence closures are implemented.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/515
https://github.com/CliMA/Oceananigans.jl/pull/515:294,Usability,clear,clear,294,This PR refactors the kernels for turbulence closures to pave the way for new closures that require knowledge of buoyancy and buoyancy gradients. It also performs some minor cleanup in `closure_operators.jl` and moves the turbulence closure implementations into a separate folder so that it is clear from the source structure which turbulence closures are implemented.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/515
https://github.com/CliMA/Oceananigans.jl/pull/517:217,Availability,avail,available,217,"This PR implements closure functions that permit the user to specify a tuple of two closures, rather than a single closure. I attempted to do the arbitrary `N`-closure case, but had issues in getting the tuple length available at compile time on the GPU. This may be a problem with Cassette, or some other issue. For now, we have an implementation for 2-tuples, and we can easily add 3-tuples if we need to (though I suspect 2-tuples of closures is as far as most users will need to go until we have more sophisticated closures to choose from). This PR should be merged after #515.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/517
https://github.com/CliMA/Oceananigans.jl/pull/519:504,Testability,test,test,504,"This PR implements Craik-Leibovich terms in Oceananigans, so that users may model the effect of surface waves. We use the Lagrangian-mean interpretation for the velocity field when surface waves are included, which requires much less modification of the governing equations than the Eulerian-mean interpretation. For example, the tracer equation (and particle advection equation) is unchanged in the Lagrangian-mean interpretation. This PR adds docs that describe the Lagrangian-mean equations, a simple test for instantiation, and an example that runs a very coarse version of the simulation in [McWilliams et al, ""Langmuir turbulence in the ocean,"" Journal of Fluid Mechanics (1997)](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/langmuir-turbulence-in-the-ocean/638FD0E368140E5972144348DB930A38). The surface wave terms are added to a module in `SurfaceWaves.jl`. As discussed previously, this may not be the source code organization we want. We should discuss.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/519
https://github.com/CliMA/Oceananigans.jl/pull/519:497,Usability,simpl,simple,497,"This PR implements Craik-Leibovich terms in Oceananigans, so that users may model the effect of surface waves. We use the Lagrangian-mean interpretation for the velocity field when surface waves are included, which requires much less modification of the governing equations than the Eulerian-mean interpretation. For example, the tracer equation (and particle advection equation) is unchanged in the Lagrangian-mean interpretation. This PR adds docs that describe the Lagrangian-mean equations, a simple test for instantiation, and an example that runs a very coarse version of the simulation in [McWilliams et al, ""Langmuir turbulence in the ocean,"" Journal of Fluid Mechanics (1997)](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/langmuir-turbulence-in-the-ocean/638FD0E368140E5972144348DB930A38). The surface wave terms are added to a module in `SurfaceWaves.jl`. As discussed previously, this may not be the source code organization we want. We should discuss.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/519
https://github.com/CliMA/Oceananigans.jl/issues/525:165,Deployability,integrat,integration,165,"We need a generic type that represents a reduction operation over a field that can be used both by the user to compute arbitrary reductions on the fly, and also for integration into `AbstractOperations`. One way to accomplish this is to define a new field that looks something like. ```julia; struct ReducedField{X, Y, Z, A, G, O, D, I} <: AbstractLocatedField{X, Y, Z, G}; data :: A; grid :: G; reduction! :: O; dims :: D; input :: I; end; ```. here `data` and `grid` are an array and grid similar to an ordinary `Field`, except that `data` is reduced along the tuple of dimensions in `dims`. The `input` is the 3D field / OffsetArray on which the reduction is performed. The function `reduction` performs the reduction; eg. ```julia; U = ReducedField(mean, model.velocities.u, dims=(1, 2)); ```. Returns an object `U` that represents the average of `model.velocities.u` over dims `(1, 2)` (x and y). We can also write wrappers / translators that allow dimensions to be referenced by name rather than number (integration with DimensionalData.jl would help in this respect). . Computing a reduction would look something like. ```julia; function compute!(reduced); zero_halo_regions!(parent(reduced.data), model.grid); reduced.reduction!(parent(reduced.data), parent(reduced.input), dims=reduced.dims); return nothing; end; ```. Note that `mean` requires a special implementation since we have to use `sum!` followed by normalization. But this is not too onerous; we can dispatch on that scenario, and other scenarios that require special implementation not covered by the generic version above. We can then integrate `ReducedField`s into abstract operations so we can calculate things like. ```julia; u, v, w = model.velocities. U = ReducedField(mean, u, dims=(1, 2)); V = ReducedField(mean, v, dims=(1, 2)). turbulent_kinetic_energy = @at (Cell, Cell, Cell) ( (u - U)^2 + (v - V)^2 + w^2 ) / 2; ```. This is a little tricky and requires the analysis of an operation tree to deduce which operations mu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/525
https://github.com/CliMA/Oceananigans.jl/issues/525:1010,Deployability,integrat,integration,1010,"We need a generic type that represents a reduction operation over a field that can be used both by the user to compute arbitrary reductions on the fly, and also for integration into `AbstractOperations`. One way to accomplish this is to define a new field that looks something like. ```julia; struct ReducedField{X, Y, Z, A, G, O, D, I} <: AbstractLocatedField{X, Y, Z, G}; data :: A; grid :: G; reduction! :: O; dims :: D; input :: I; end; ```. here `data` and `grid` are an array and grid similar to an ordinary `Field`, except that `data` is reduced along the tuple of dimensions in `dims`. The `input` is the 3D field / OffsetArray on which the reduction is performed. The function `reduction` performs the reduction; eg. ```julia; U = ReducedField(mean, model.velocities.u, dims=(1, 2)); ```. Returns an object `U` that represents the average of `model.velocities.u` over dims `(1, 2)` (x and y). We can also write wrappers / translators that allow dimensions to be referenced by name rather than number (integration with DimensionalData.jl would help in this respect). . Computing a reduction would look something like. ```julia; function compute!(reduced); zero_halo_regions!(parent(reduced.data), model.grid); reduced.reduction!(parent(reduced.data), parent(reduced.input), dims=reduced.dims); return nothing; end; ```. Note that `mean` requires a special implementation since we have to use `sum!` followed by normalization. But this is not too onerous; we can dispatch on that scenario, and other scenarios that require special implementation not covered by the generic version above. We can then integrate `ReducedField`s into abstract operations so we can calculate things like. ```julia; u, v, w = model.velocities. U = ReducedField(mean, u, dims=(1, 2)); V = ReducedField(mean, v, dims=(1, 2)). turbulent_kinetic_energy = @at (Cell, Cell, Cell) ( (u - U)^2 + (v - V)^2 + w^2 ) / 2; ```. This is a little tricky and requires the analysis of an operation tree to deduce which operations mu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/525
https://github.com/CliMA/Oceananigans.jl/issues/525:1607,Deployability,integrat,integrate,1607,"ly, and also for integration into `AbstractOperations`. One way to accomplish this is to define a new field that looks something like. ```julia; struct ReducedField{X, Y, Z, A, G, O, D, I} <: AbstractLocatedField{X, Y, Z, G}; data :: A; grid :: G; reduction! :: O; dims :: D; input :: I; end; ```. here `data` and `grid` are an array and grid similar to an ordinary `Field`, except that `data` is reduced along the tuple of dimensions in `dims`. The `input` is the 3D field / OffsetArray on which the reduction is performed. The function `reduction` performs the reduction; eg. ```julia; U = ReducedField(mean, model.velocities.u, dims=(1, 2)); ```. Returns an object `U` that represents the average of `model.velocities.u` over dims `(1, 2)` (x and y). We can also write wrappers / translators that allow dimensions to be referenced by name rather than number (integration with DimensionalData.jl would help in this respect). . Computing a reduction would look something like. ```julia; function compute!(reduced); zero_halo_regions!(parent(reduced.data), model.grid); reduced.reduction!(parent(reduced.data), parent(reduced.input), dims=reduced.dims); return nothing; end; ```. Note that `mean` requires a special implementation since we have to use `sum!` followed by normalization. But this is not too onerous; we can dispatch on that scenario, and other scenarios that require special implementation not covered by the generic version above. We can then integrate `ReducedField`s into abstract operations so we can calculate things like. ```julia; u, v, w = model.velocities. U = ReducedField(mean, u, dims=(1, 2)); V = ReducedField(mean, v, dims=(1, 2)). turbulent_kinetic_energy = @at (Cell, Cell, Cell) ( (u - U)^2 + (v - V)^2 + w^2 ) / 2; ```. This is a little tricky and requires the analysis of an operation tree to deduce which operations must be pre-computed. But this can be done in the constructor for `Computation` and is probably not too difficult (also, the topic of another issue).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/525
https://github.com/CliMA/Oceananigans.jl/issues/525:300,Energy Efficiency,Reduce,ReducedField,300,"We need a generic type that represents a reduction operation over a field that can be used both by the user to compute arbitrary reductions on the fly, and also for integration into `AbstractOperations`. One way to accomplish this is to define a new field that looks something like. ```julia; struct ReducedField{X, Y, Z, A, G, O, D, I} <: AbstractLocatedField{X, Y, Z, G}; data :: A; grid :: G; reduction! :: O; dims :: D; input :: I; end; ```. here `data` and `grid` are an array and grid similar to an ordinary `Field`, except that `data` is reduced along the tuple of dimensions in `dims`. The `input` is the 3D field / OffsetArray on which the reduction is performed. The function `reduction` performs the reduction; eg. ```julia; U = ReducedField(mean, model.velocities.u, dims=(1, 2)); ```. Returns an object `U` that represents the average of `model.velocities.u` over dims `(1, 2)` (x and y). We can also write wrappers / translators that allow dimensions to be referenced by name rather than number (integration with DimensionalData.jl would help in this respect). . Computing a reduction would look something like. ```julia; function compute!(reduced); zero_halo_regions!(parent(reduced.data), model.grid); reduced.reduction!(parent(reduced.data), parent(reduced.input), dims=reduced.dims); return nothing; end; ```. Note that `mean` requires a special implementation since we have to use `sum!` followed by normalization. But this is not too onerous; we can dispatch on that scenario, and other scenarios that require special implementation not covered by the generic version above. We can then integrate `ReducedField`s into abstract operations so we can calculate things like. ```julia; u, v, w = model.velocities. U = ReducedField(mean, u, dims=(1, 2)); V = ReducedField(mean, v, dims=(1, 2)). turbulent_kinetic_energy = @at (Cell, Cell, Cell) ( (u - U)^2 + (v - V)^2 + w^2 ) / 2; ```. This is a little tricky and requires the analysis of an operation tree to deduce which operations mu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/525
https://github.com/CliMA/Oceananigans.jl/issues/525:545,Energy Efficiency,reduce,reduced,545,"We need a generic type that represents a reduction operation over a field that can be used both by the user to compute arbitrary reductions on the fly, and also for integration into `AbstractOperations`. One way to accomplish this is to define a new field that looks something like. ```julia; struct ReducedField{X, Y, Z, A, G, O, D, I} <: AbstractLocatedField{X, Y, Z, G}; data :: A; grid :: G; reduction! :: O; dims :: D; input :: I; end; ```. here `data` and `grid` are an array and grid similar to an ordinary `Field`, except that `data` is reduced along the tuple of dimensions in `dims`. The `input` is the 3D field / OffsetArray on which the reduction is performed. The function `reduction` performs the reduction; eg. ```julia; U = ReducedField(mean, model.velocities.u, dims=(1, 2)); ```. Returns an object `U` that represents the average of `model.velocities.u` over dims `(1, 2)` (x and y). We can also write wrappers / translators that allow dimensions to be referenced by name rather than number (integration with DimensionalData.jl would help in this respect). . Computing a reduction would look something like. ```julia; function compute!(reduced); zero_halo_regions!(parent(reduced.data), model.grid); reduced.reduction!(parent(reduced.data), parent(reduced.input), dims=reduced.dims); return nothing; end; ```. Note that `mean` requires a special implementation since we have to use `sum!` followed by normalization. But this is not too onerous; we can dispatch on that scenario, and other scenarios that require special implementation not covered by the generic version above. We can then integrate `ReducedField`s into abstract operations so we can calculate things like. ```julia; u, v, w = model.velocities. U = ReducedField(mean, u, dims=(1, 2)); V = ReducedField(mean, v, dims=(1, 2)). turbulent_kinetic_energy = @at (Cell, Cell, Cell) ( (u - U)^2 + (v - V)^2 + w^2 ) / 2; ```. This is a little tricky and requires the analysis of an operation tree to deduce which operations mu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/525
https://github.com/CliMA/Oceananigans.jl/issues/525:740,Energy Efficiency,Reduce,ReducedField,740,"We need a generic type that represents a reduction operation over a field that can be used both by the user to compute arbitrary reductions on the fly, and also for integration into `AbstractOperations`. One way to accomplish this is to define a new field that looks something like. ```julia; struct ReducedField{X, Y, Z, A, G, O, D, I} <: AbstractLocatedField{X, Y, Z, G}; data :: A; grid :: G; reduction! :: O; dims :: D; input :: I; end; ```. here `data` and `grid` are an array and grid similar to an ordinary `Field`, except that `data` is reduced along the tuple of dimensions in `dims`. The `input` is the 3D field / OffsetArray on which the reduction is performed. The function `reduction` performs the reduction; eg. ```julia; U = ReducedField(mean, model.velocities.u, dims=(1, 2)); ```. Returns an object `U` that represents the average of `model.velocities.u` over dims `(1, 2)` (x and y). We can also write wrappers / translators that allow dimensions to be referenced by name rather than number (integration with DimensionalData.jl would help in this respect). . Computing a reduction would look something like. ```julia; function compute!(reduced); zero_halo_regions!(parent(reduced.data), model.grid); reduced.reduction!(parent(reduced.data), parent(reduced.input), dims=reduced.dims); return nothing; end; ```. Note that `mean` requires a special implementation since we have to use `sum!` followed by normalization. But this is not too onerous; we can dispatch on that scenario, and other scenarios that require special implementation not covered by the generic version above. We can then integrate `ReducedField`s into abstract operations so we can calculate things like. ```julia; u, v, w = model.velocities. U = ReducedField(mean, u, dims=(1, 2)); V = ReducedField(mean, v, dims=(1, 2)). turbulent_kinetic_energy = @at (Cell, Cell, Cell) ( (u - U)^2 + (v - V)^2 + w^2 ) / 2; ```. This is a little tricky and requires the analysis of an operation tree to deduce which operations mu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/525
https://github.com/CliMA/Oceananigans.jl/issues/525:1154,Energy Efficiency,reduce,reduced,1154,"ly, and also for integration into `AbstractOperations`. One way to accomplish this is to define a new field that looks something like. ```julia; struct ReducedField{X, Y, Z, A, G, O, D, I} <: AbstractLocatedField{X, Y, Z, G}; data :: A; grid :: G; reduction! :: O; dims :: D; input :: I; end; ```. here `data` and `grid` are an array and grid similar to an ordinary `Field`, except that `data` is reduced along the tuple of dimensions in `dims`. The `input` is the 3D field / OffsetArray on which the reduction is performed. The function `reduction` performs the reduction; eg. ```julia; U = ReducedField(mean, model.velocities.u, dims=(1, 2)); ```. Returns an object `U` that represents the average of `model.velocities.u` over dims `(1, 2)` (x and y). We can also write wrappers / translators that allow dimensions to be referenced by name rather than number (integration with DimensionalData.jl would help in this respect). . Computing a reduction would look something like. ```julia; function compute!(reduced); zero_halo_regions!(parent(reduced.data), model.grid); reduced.reduction!(parent(reduced.data), parent(reduced.input), dims=reduced.dims); return nothing; end; ```. Note that `mean` requires a special implementation since we have to use `sum!` followed by normalization. But this is not too onerous; we can dispatch on that scenario, and other scenarios that require special implementation not covered by the generic version above. We can then integrate `ReducedField`s into abstract operations so we can calculate things like. ```julia; u, v, w = model.velocities. U = ReducedField(mean, u, dims=(1, 2)); V = ReducedField(mean, v, dims=(1, 2)). turbulent_kinetic_energy = @at (Cell, Cell, Cell) ( (u - U)^2 + (v - V)^2 + w^2 ) / 2; ```. This is a little tricky and requires the analysis of an operation tree to deduce which operations must be pre-computed. But this can be done in the constructor for `Computation` and is probably not too difficult (also, the topic of another issue).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/525
https://github.com/CliMA/Oceananigans.jl/issues/525:1190,Energy Efficiency,reduce,reduced,1190,"ly, and also for integration into `AbstractOperations`. One way to accomplish this is to define a new field that looks something like. ```julia; struct ReducedField{X, Y, Z, A, G, O, D, I} <: AbstractLocatedField{X, Y, Z, G}; data :: A; grid :: G; reduction! :: O; dims :: D; input :: I; end; ```. here `data` and `grid` are an array and grid similar to an ordinary `Field`, except that `data` is reduced along the tuple of dimensions in `dims`. The `input` is the 3D field / OffsetArray on which the reduction is performed. The function `reduction` performs the reduction; eg. ```julia; U = ReducedField(mean, model.velocities.u, dims=(1, 2)); ```. Returns an object `U` that represents the average of `model.velocities.u` over dims `(1, 2)` (x and y). We can also write wrappers / translators that allow dimensions to be referenced by name rather than number (integration with DimensionalData.jl would help in this respect). . Computing a reduction would look something like. ```julia; function compute!(reduced); zero_halo_regions!(parent(reduced.data), model.grid); reduced.reduction!(parent(reduced.data), parent(reduced.input), dims=reduced.dims); return nothing; end; ```. Note that `mean` requires a special implementation since we have to use `sum!` followed by normalization. But this is not too onerous; we can dispatch on that scenario, and other scenarios that require special implementation not covered by the generic version above. We can then integrate `ReducedField`s into abstract operations so we can calculate things like. ```julia; u, v, w = model.velocities. U = ReducedField(mean, u, dims=(1, 2)); V = ReducedField(mean, v, dims=(1, 2)). turbulent_kinetic_energy = @at (Cell, Cell, Cell) ( (u - U)^2 + (v - V)^2 + w^2 ) / 2; ```. This is a little tricky and requires the analysis of an operation tree to deduce which operations must be pre-computed. But this can be done in the constructor for `Computation` and is probably not too difficult (also, the topic of another issue).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/525
https://github.com/CliMA/Oceananigans.jl/issues/525:1218,Energy Efficiency,reduce,reduced,1218,"ly, and also for integration into `AbstractOperations`. One way to accomplish this is to define a new field that looks something like. ```julia; struct ReducedField{X, Y, Z, A, G, O, D, I} <: AbstractLocatedField{X, Y, Z, G}; data :: A; grid :: G; reduction! :: O; dims :: D; input :: I; end; ```. here `data` and `grid` are an array and grid similar to an ordinary `Field`, except that `data` is reduced along the tuple of dimensions in `dims`. The `input` is the 3D field / OffsetArray on which the reduction is performed. The function `reduction` performs the reduction; eg. ```julia; U = ReducedField(mean, model.velocities.u, dims=(1, 2)); ```. Returns an object `U` that represents the average of `model.velocities.u` over dims `(1, 2)` (x and y). We can also write wrappers / translators that allow dimensions to be referenced by name rather than number (integration with DimensionalData.jl would help in this respect). . Computing a reduction would look something like. ```julia; function compute!(reduced); zero_halo_regions!(parent(reduced.data), model.grid); reduced.reduction!(parent(reduced.data), parent(reduced.input), dims=reduced.dims); return nothing; end; ```. Note that `mean` requires a special implementation since we have to use `sum!` followed by normalization. But this is not too onerous; we can dispatch on that scenario, and other scenarios that require special implementation not covered by the generic version above. We can then integrate `ReducedField`s into abstract operations so we can calculate things like. ```julia; u, v, w = model.velocities. U = ReducedField(mean, u, dims=(1, 2)); V = ReducedField(mean, v, dims=(1, 2)). turbulent_kinetic_energy = @at (Cell, Cell, Cell) ( (u - U)^2 + (v - V)^2 + w^2 ) / 2; ```. This is a little tricky and requires the analysis of an operation tree to deduce which operations must be pre-computed. But this can be done in the constructor for `Computation` and is probably not too difficult (also, the topic of another issue).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/525
https://github.com/CliMA/Oceananigans.jl/issues/525:1244,Energy Efficiency,reduce,reduced,1244,"ly, and also for integration into `AbstractOperations`. One way to accomplish this is to define a new field that looks something like. ```julia; struct ReducedField{X, Y, Z, A, G, O, D, I} <: AbstractLocatedField{X, Y, Z, G}; data :: A; grid :: G; reduction! :: O; dims :: D; input :: I; end; ```. here `data` and `grid` are an array and grid similar to an ordinary `Field`, except that `data` is reduced along the tuple of dimensions in `dims`. The `input` is the 3D field / OffsetArray on which the reduction is performed. The function `reduction` performs the reduction; eg. ```julia; U = ReducedField(mean, model.velocities.u, dims=(1, 2)); ```. Returns an object `U` that represents the average of `model.velocities.u` over dims `(1, 2)` (x and y). We can also write wrappers / translators that allow dimensions to be referenced by name rather than number (integration with DimensionalData.jl would help in this respect). . Computing a reduction would look something like. ```julia; function compute!(reduced); zero_halo_regions!(parent(reduced.data), model.grid); reduced.reduction!(parent(reduced.data), parent(reduced.input), dims=reduced.dims); return nothing; end; ```. Note that `mean` requires a special implementation since we have to use `sum!` followed by normalization. But this is not too onerous; we can dispatch on that scenario, and other scenarios that require special implementation not covered by the generic version above. We can then integrate `ReducedField`s into abstract operations so we can calculate things like. ```julia; u, v, w = model.velocities. U = ReducedField(mean, u, dims=(1, 2)); V = ReducedField(mean, v, dims=(1, 2)). turbulent_kinetic_energy = @at (Cell, Cell, Cell) ( (u - U)^2 + (v - V)^2 + w^2 ) / 2; ```. This is a little tricky and requires the analysis of an operation tree to deduce which operations must be pre-computed. But this can be done in the constructor for `Computation` and is probably not too difficult (also, the topic of another issue).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/525
https://github.com/CliMA/Oceananigans.jl/issues/525:1266,Energy Efficiency,reduce,reduced,1266,"ly, and also for integration into `AbstractOperations`. One way to accomplish this is to define a new field that looks something like. ```julia; struct ReducedField{X, Y, Z, A, G, O, D, I} <: AbstractLocatedField{X, Y, Z, G}; data :: A; grid :: G; reduction! :: O; dims :: D; input :: I; end; ```. here `data` and `grid` are an array and grid similar to an ordinary `Field`, except that `data` is reduced along the tuple of dimensions in `dims`. The `input` is the 3D field / OffsetArray on which the reduction is performed. The function `reduction` performs the reduction; eg. ```julia; U = ReducedField(mean, model.velocities.u, dims=(1, 2)); ```. Returns an object `U` that represents the average of `model.velocities.u` over dims `(1, 2)` (x and y). We can also write wrappers / translators that allow dimensions to be referenced by name rather than number (integration with DimensionalData.jl would help in this respect). . Computing a reduction would look something like. ```julia; function compute!(reduced); zero_halo_regions!(parent(reduced.data), model.grid); reduced.reduction!(parent(reduced.data), parent(reduced.input), dims=reduced.dims); return nothing; end; ```. Note that `mean` requires a special implementation since we have to use `sum!` followed by normalization. But this is not too onerous; we can dispatch on that scenario, and other scenarios that require special implementation not covered by the generic version above. We can then integrate `ReducedField`s into abstract operations so we can calculate things like. ```julia; u, v, w = model.velocities. U = ReducedField(mean, u, dims=(1, 2)); V = ReducedField(mean, v, dims=(1, 2)). turbulent_kinetic_energy = @at (Cell, Cell, Cell) ( (u - U)^2 + (v - V)^2 + w^2 ) / 2; ```. This is a little tricky and requires the analysis of an operation tree to deduce which operations must be pre-computed. But this can be done in the constructor for `Computation` and is probably not too difficult (also, the topic of another issue).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/525
https://github.com/CliMA/Oceananigans.jl/issues/525:1287,Energy Efficiency,reduce,reduced,1287,"ly, and also for integration into `AbstractOperations`. One way to accomplish this is to define a new field that looks something like. ```julia; struct ReducedField{X, Y, Z, A, G, O, D, I} <: AbstractLocatedField{X, Y, Z, G}; data :: A; grid :: G; reduction! :: O; dims :: D; input :: I; end; ```. here `data` and `grid` are an array and grid similar to an ordinary `Field`, except that `data` is reduced along the tuple of dimensions in `dims`. The `input` is the 3D field / OffsetArray on which the reduction is performed. The function `reduction` performs the reduction; eg. ```julia; U = ReducedField(mean, model.velocities.u, dims=(1, 2)); ```. Returns an object `U` that represents the average of `model.velocities.u` over dims `(1, 2)` (x and y). We can also write wrappers / translators that allow dimensions to be referenced by name rather than number (integration with DimensionalData.jl would help in this respect). . Computing a reduction would look something like. ```julia; function compute!(reduced); zero_halo_regions!(parent(reduced.data), model.grid); reduced.reduction!(parent(reduced.data), parent(reduced.input), dims=reduced.dims); return nothing; end; ```. Note that `mean` requires a special implementation since we have to use `sum!` followed by normalization. But this is not too onerous; we can dispatch on that scenario, and other scenarios that require special implementation not covered by the generic version above. We can then integrate `ReducedField`s into abstract operations so we can calculate things like. ```julia; u, v, w = model.velocities. U = ReducedField(mean, u, dims=(1, 2)); V = ReducedField(mean, v, dims=(1, 2)). turbulent_kinetic_energy = @at (Cell, Cell, Cell) ( (u - U)^2 + (v - V)^2 + w^2 ) / 2; ```. This is a little tricky and requires the analysis of an operation tree to deduce which operations must be pre-computed. But this can be done in the constructor for `Computation` and is probably not too difficult (also, the topic of another issue).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/525
https://github.com/CliMA/Oceananigans.jl/issues/525:1618,Energy Efficiency,Reduce,ReducedField,1618,"ly, and also for integration into `AbstractOperations`. One way to accomplish this is to define a new field that looks something like. ```julia; struct ReducedField{X, Y, Z, A, G, O, D, I} <: AbstractLocatedField{X, Y, Z, G}; data :: A; grid :: G; reduction! :: O; dims :: D; input :: I; end; ```. here `data` and `grid` are an array and grid similar to an ordinary `Field`, except that `data` is reduced along the tuple of dimensions in `dims`. The `input` is the 3D field / OffsetArray on which the reduction is performed. The function `reduction` performs the reduction; eg. ```julia; U = ReducedField(mean, model.velocities.u, dims=(1, 2)); ```. Returns an object `U` that represents the average of `model.velocities.u` over dims `(1, 2)` (x and y). We can also write wrappers / translators that allow dimensions to be referenced by name rather than number (integration with DimensionalData.jl would help in this respect). . Computing a reduction would look something like. ```julia; function compute!(reduced); zero_halo_regions!(parent(reduced.data), model.grid); reduced.reduction!(parent(reduced.data), parent(reduced.input), dims=reduced.dims); return nothing; end; ```. Note that `mean` requires a special implementation since we have to use `sum!` followed by normalization. But this is not too onerous; we can dispatch on that scenario, and other scenarios that require special implementation not covered by the generic version above. We can then integrate `ReducedField`s into abstract operations so we can calculate things like. ```julia; u, v, w = model.velocities. U = ReducedField(mean, u, dims=(1, 2)); V = ReducedField(mean, v, dims=(1, 2)). turbulent_kinetic_energy = @at (Cell, Cell, Cell) ( (u - U)^2 + (v - V)^2 + w^2 ) / 2; ```. This is a little tricky and requires the analysis of an operation tree to deduce which operations must be pre-computed. But this can be done in the constructor for `Computation` and is probably not too difficult (also, the topic of another issue).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/525
https://github.com/CliMA/Oceananigans.jl/issues/525:1733,Energy Efficiency,Reduce,ReducedField,1733,"ly, and also for integration into `AbstractOperations`. One way to accomplish this is to define a new field that looks something like. ```julia; struct ReducedField{X, Y, Z, A, G, O, D, I} <: AbstractLocatedField{X, Y, Z, G}; data :: A; grid :: G; reduction! :: O; dims :: D; input :: I; end; ```. here `data` and `grid` are an array and grid similar to an ordinary `Field`, except that `data` is reduced along the tuple of dimensions in `dims`. The `input` is the 3D field / OffsetArray on which the reduction is performed. The function `reduction` performs the reduction; eg. ```julia; U = ReducedField(mean, model.velocities.u, dims=(1, 2)); ```. Returns an object `U` that represents the average of `model.velocities.u` over dims `(1, 2)` (x and y). We can also write wrappers / translators that allow dimensions to be referenced by name rather than number (integration with DimensionalData.jl would help in this respect). . Computing a reduction would look something like. ```julia; function compute!(reduced); zero_halo_regions!(parent(reduced.data), model.grid); reduced.reduction!(parent(reduced.data), parent(reduced.input), dims=reduced.dims); return nothing; end; ```. Note that `mean` requires a special implementation since we have to use `sum!` followed by normalization. But this is not too onerous; we can dispatch on that scenario, and other scenarios that require special implementation not covered by the generic version above. We can then integrate `ReducedField`s into abstract operations so we can calculate things like. ```julia; u, v, w = model.velocities. U = ReducedField(mean, u, dims=(1, 2)); V = ReducedField(mean, v, dims=(1, 2)). turbulent_kinetic_energy = @at (Cell, Cell, Cell) ( (u - U)^2 + (v - V)^2 + w^2 ) / 2; ```. This is a little tricky and requires the analysis of an operation tree to deduce which operations must be pre-computed. But this can be done in the constructor for `Computation` and is probably not too difficult (also, the topic of another issue).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/525
https://github.com/CliMA/Oceananigans.jl/issues/525:1773,Energy Efficiency,Reduce,ReducedField,1773,"ly, and also for integration into `AbstractOperations`. One way to accomplish this is to define a new field that looks something like. ```julia; struct ReducedField{X, Y, Z, A, G, O, D, I} <: AbstractLocatedField{X, Y, Z, G}; data :: A; grid :: G; reduction! :: O; dims :: D; input :: I; end; ```. here `data` and `grid` are an array and grid similar to an ordinary `Field`, except that `data` is reduced along the tuple of dimensions in `dims`. The `input` is the 3D field / OffsetArray on which the reduction is performed. The function `reduction` performs the reduction; eg. ```julia; U = ReducedField(mean, model.velocities.u, dims=(1, 2)); ```. Returns an object `U` that represents the average of `model.velocities.u` over dims `(1, 2)` (x and y). We can also write wrappers / translators that allow dimensions to be referenced by name rather than number (integration with DimensionalData.jl would help in this respect). . Computing a reduction would look something like. ```julia; function compute!(reduced); zero_halo_regions!(parent(reduced.data), model.grid); reduced.reduction!(parent(reduced.data), parent(reduced.input), dims=reduced.dims); return nothing; end; ```. Note that `mean` requires a special implementation since we have to use `sum!` followed by normalization. But this is not too onerous; we can dispatch on that scenario, and other scenarios that require special implementation not covered by the generic version above. We can then integrate `ReducedField`s into abstract operations so we can calculate things like. ```julia; u, v, w = model.velocities. U = ReducedField(mean, u, dims=(1, 2)); V = ReducedField(mean, v, dims=(1, 2)). turbulent_kinetic_energy = @at (Cell, Cell, Cell) ( (u - U)^2 + (v - V)^2 + w^2 ) / 2; ```. This is a little tricky and requires the analysis of an operation tree to deduce which operations must be pre-computed. But this can be done in the constructor for `Computation` and is probably not too difficult (also, the topic of another issue).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/525
https://github.com/CliMA/Oceananigans.jl/issues/525:165,Integrability,integrat,integration,165,"We need a generic type that represents a reduction operation over a field that can be used both by the user to compute arbitrary reductions on the fly, and also for integration into `AbstractOperations`. One way to accomplish this is to define a new field that looks something like. ```julia; struct ReducedField{X, Y, Z, A, G, O, D, I} <: AbstractLocatedField{X, Y, Z, G}; data :: A; grid :: G; reduction! :: O; dims :: D; input :: I; end; ```. here `data` and `grid` are an array and grid similar to an ordinary `Field`, except that `data` is reduced along the tuple of dimensions in `dims`. The `input` is the 3D field / OffsetArray on which the reduction is performed. The function `reduction` performs the reduction; eg. ```julia; U = ReducedField(mean, model.velocities.u, dims=(1, 2)); ```. Returns an object `U` that represents the average of `model.velocities.u` over dims `(1, 2)` (x and y). We can also write wrappers / translators that allow dimensions to be referenced by name rather than number (integration with DimensionalData.jl would help in this respect). . Computing a reduction would look something like. ```julia; function compute!(reduced); zero_halo_regions!(parent(reduced.data), model.grid); reduced.reduction!(parent(reduced.data), parent(reduced.input), dims=reduced.dims); return nothing; end; ```. Note that `mean` requires a special implementation since we have to use `sum!` followed by normalization. But this is not too onerous; we can dispatch on that scenario, and other scenarios that require special implementation not covered by the generic version above. We can then integrate `ReducedField`s into abstract operations so we can calculate things like. ```julia; u, v, w = model.velocities. U = ReducedField(mean, u, dims=(1, 2)); V = ReducedField(mean, v, dims=(1, 2)). turbulent_kinetic_energy = @at (Cell, Cell, Cell) ( (u - U)^2 + (v - V)^2 + w^2 ) / 2; ```. This is a little tricky and requires the analysis of an operation tree to deduce which operations mu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/525
https://github.com/CliMA/Oceananigans.jl/issues/525:920,Integrability,wrap,wrappers,920,"We need a generic type that represents a reduction operation over a field that can be used both by the user to compute arbitrary reductions on the fly, and also for integration into `AbstractOperations`. One way to accomplish this is to define a new field that looks something like. ```julia; struct ReducedField{X, Y, Z, A, G, O, D, I} <: AbstractLocatedField{X, Y, Z, G}; data :: A; grid :: G; reduction! :: O; dims :: D; input :: I; end; ```. here `data` and `grid` are an array and grid similar to an ordinary `Field`, except that `data` is reduced along the tuple of dimensions in `dims`. The `input` is the 3D field / OffsetArray on which the reduction is performed. The function `reduction` performs the reduction; eg. ```julia; U = ReducedField(mean, model.velocities.u, dims=(1, 2)); ```. Returns an object `U` that represents the average of `model.velocities.u` over dims `(1, 2)` (x and y). We can also write wrappers / translators that allow dimensions to be referenced by name rather than number (integration with DimensionalData.jl would help in this respect). . Computing a reduction would look something like. ```julia; function compute!(reduced); zero_halo_regions!(parent(reduced.data), model.grid); reduced.reduction!(parent(reduced.data), parent(reduced.input), dims=reduced.dims); return nothing; end; ```. Note that `mean` requires a special implementation since we have to use `sum!` followed by normalization. But this is not too onerous; we can dispatch on that scenario, and other scenarios that require special implementation not covered by the generic version above. We can then integrate `ReducedField`s into abstract operations so we can calculate things like. ```julia; u, v, w = model.velocities. U = ReducedField(mean, u, dims=(1, 2)); V = ReducedField(mean, v, dims=(1, 2)). turbulent_kinetic_energy = @at (Cell, Cell, Cell) ( (u - U)^2 + (v - V)^2 + w^2 ) / 2; ```. This is a little tricky and requires the analysis of an operation tree to deduce which operations mu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/525
https://github.com/CliMA/Oceananigans.jl/issues/525:1010,Integrability,integrat,integration,1010,"We need a generic type that represents a reduction operation over a field that can be used both by the user to compute arbitrary reductions on the fly, and also for integration into `AbstractOperations`. One way to accomplish this is to define a new field that looks something like. ```julia; struct ReducedField{X, Y, Z, A, G, O, D, I} <: AbstractLocatedField{X, Y, Z, G}; data :: A; grid :: G; reduction! :: O; dims :: D; input :: I; end; ```. here `data` and `grid` are an array and grid similar to an ordinary `Field`, except that `data` is reduced along the tuple of dimensions in `dims`. The `input` is the 3D field / OffsetArray on which the reduction is performed. The function `reduction` performs the reduction; eg. ```julia; U = ReducedField(mean, model.velocities.u, dims=(1, 2)); ```. Returns an object `U` that represents the average of `model.velocities.u` over dims `(1, 2)` (x and y). We can also write wrappers / translators that allow dimensions to be referenced by name rather than number (integration with DimensionalData.jl would help in this respect). . Computing a reduction would look something like. ```julia; function compute!(reduced); zero_halo_regions!(parent(reduced.data), model.grid); reduced.reduction!(parent(reduced.data), parent(reduced.input), dims=reduced.dims); return nothing; end; ```. Note that `mean` requires a special implementation since we have to use `sum!` followed by normalization. But this is not too onerous; we can dispatch on that scenario, and other scenarios that require special implementation not covered by the generic version above. We can then integrate `ReducedField`s into abstract operations so we can calculate things like. ```julia; u, v, w = model.velocities. U = ReducedField(mean, u, dims=(1, 2)); V = ReducedField(mean, v, dims=(1, 2)). turbulent_kinetic_energy = @at (Cell, Cell, Cell) ( (u - U)^2 + (v - V)^2 + w^2 ) / 2; ```. This is a little tricky and requires the analysis of an operation tree to deduce which operations mu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/525
https://github.com/CliMA/Oceananigans.jl/issues/525:1607,Integrability,integrat,integrate,1607,"ly, and also for integration into `AbstractOperations`. One way to accomplish this is to define a new field that looks something like. ```julia; struct ReducedField{X, Y, Z, A, G, O, D, I} <: AbstractLocatedField{X, Y, Z, G}; data :: A; grid :: G; reduction! :: O; dims :: D; input :: I; end; ```. here `data` and `grid` are an array and grid similar to an ordinary `Field`, except that `data` is reduced along the tuple of dimensions in `dims`. The `input` is the 3D field / OffsetArray on which the reduction is performed. The function `reduction` performs the reduction; eg. ```julia; U = ReducedField(mean, model.velocities.u, dims=(1, 2)); ```. Returns an object `U` that represents the average of `model.velocities.u` over dims `(1, 2)` (x and y). We can also write wrappers / translators that allow dimensions to be referenced by name rather than number (integration with DimensionalData.jl would help in this respect). . Computing a reduction would look something like. ```julia; function compute!(reduced); zero_halo_regions!(parent(reduced.data), model.grid); reduced.reduction!(parent(reduced.data), parent(reduced.input), dims=reduced.dims); return nothing; end; ```. Note that `mean` requires a special implementation since we have to use `sum!` followed by normalization. But this is not too onerous; we can dispatch on that scenario, and other scenarios that require special implementation not covered by the generic version above. We can then integrate `ReducedField`s into abstract operations so we can calculate things like. ```julia; u, v, w = model.velocities. U = ReducedField(mean, u, dims=(1, 2)); V = ReducedField(mean, v, dims=(1, 2)). turbulent_kinetic_energy = @at (Cell, Cell, Cell) ( (u - U)^2 + (v - V)^2 + w^2 ) / 2; ```. This is a little tricky and requires the analysis of an operation tree to deduce which operations must be pre-computed. But this can be done in the constructor for `Computation` and is probably not too difficult (also, the topic of another issue).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/525
https://github.com/CliMA/Oceananigans.jl/issues/525:662,Performance,perform,performed,662,"We need a generic type that represents a reduction operation over a field that can be used both by the user to compute arbitrary reductions on the fly, and also for integration into `AbstractOperations`. One way to accomplish this is to define a new field that looks something like. ```julia; struct ReducedField{X, Y, Z, A, G, O, D, I} <: AbstractLocatedField{X, Y, Z, G}; data :: A; grid :: G; reduction! :: O; dims :: D; input :: I; end; ```. here `data` and `grid` are an array and grid similar to an ordinary `Field`, except that `data` is reduced along the tuple of dimensions in `dims`. The `input` is the 3D field / OffsetArray on which the reduction is performed. The function `reduction` performs the reduction; eg. ```julia; U = ReducedField(mean, model.velocities.u, dims=(1, 2)); ```. Returns an object `U` that represents the average of `model.velocities.u` over dims `(1, 2)` (x and y). We can also write wrappers / translators that allow dimensions to be referenced by name rather than number (integration with DimensionalData.jl would help in this respect). . Computing a reduction would look something like. ```julia; function compute!(reduced); zero_halo_regions!(parent(reduced.data), model.grid); reduced.reduction!(parent(reduced.data), parent(reduced.input), dims=reduced.dims); return nothing; end; ```. Note that `mean` requires a special implementation since we have to use `sum!` followed by normalization. But this is not too onerous; we can dispatch on that scenario, and other scenarios that require special implementation not covered by the generic version above. We can then integrate `ReducedField`s into abstract operations so we can calculate things like. ```julia; u, v, w = model.velocities. U = ReducedField(mean, u, dims=(1, 2)); V = ReducedField(mean, v, dims=(1, 2)). turbulent_kinetic_energy = @at (Cell, Cell, Cell) ( (u - U)^2 + (v - V)^2 + w^2 ) / 2; ```. This is a little tricky and requires the analysis of an operation tree to deduce which operations mu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/525
https://github.com/CliMA/Oceananigans.jl/issues/525:698,Performance,perform,performs,698,"We need a generic type that represents a reduction operation over a field that can be used both by the user to compute arbitrary reductions on the fly, and also for integration into `AbstractOperations`. One way to accomplish this is to define a new field that looks something like. ```julia; struct ReducedField{X, Y, Z, A, G, O, D, I} <: AbstractLocatedField{X, Y, Z, G}; data :: A; grid :: G; reduction! :: O; dims :: D; input :: I; end; ```. here `data` and `grid` are an array and grid similar to an ordinary `Field`, except that `data` is reduced along the tuple of dimensions in `dims`. The `input` is the 3D field / OffsetArray on which the reduction is performed. The function `reduction` performs the reduction; eg. ```julia; U = ReducedField(mean, model.velocities.u, dims=(1, 2)); ```. Returns an object `U` that represents the average of `model.velocities.u` over dims `(1, 2)` (x and y). We can also write wrappers / translators that allow dimensions to be referenced by name rather than number (integration with DimensionalData.jl would help in this respect). . Computing a reduction would look something like. ```julia; function compute!(reduced); zero_halo_regions!(parent(reduced.data), model.grid); reduced.reduction!(parent(reduced.data), parent(reduced.input), dims=reduced.dims); return nothing; end; ```. Note that `mean` requires a special implementation since we have to use `sum!` followed by normalization. But this is not too onerous; we can dispatch on that scenario, and other scenarios that require special implementation not covered by the generic version above. We can then integrate `ReducedField`s into abstract operations so we can calculate things like. ```julia; u, v, w = model.velocities. U = ReducedField(mean, u, dims=(1, 2)); V = ReducedField(mean, v, dims=(1, 2)). turbulent_kinetic_energy = @at (Cell, Cell, Cell) ( (u - U)^2 + (v - V)^2 + w^2 ) / 2; ```. This is a little tricky and requires the analysis of an operation tree to deduce which operations mu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/525
https://github.com/CliMA/Oceananigans.jl/pull/526:158,Deployability,update,update,158,Following the reversal of the k index (PR #462) we need to regenerate all regression test data to correspond to the new convention. This PR does that. Had to update some of the tests as the output data format has changed (e.g. now has halos) and was originally generated a long time ago. I also increased code reuse among the regression tests for summarizing the result of each regression test. This PR is part of #471,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/526
https://github.com/CliMA/Oceananigans.jl/pull/526:85,Testability,test,test,85,Following the reversal of the k index (PR #462) we need to regenerate all regression test data to correspond to the new convention. This PR does that. Had to update some of the tests as the output data format has changed (e.g. now has halos) and was originally generated a long time ago. I also increased code reuse among the regression tests for summarizing the result of each regression test. This PR is part of #471,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/526
https://github.com/CliMA/Oceananigans.jl/pull/526:177,Testability,test,tests,177,Following the reversal of the k index (PR #462) we need to regenerate all regression test data to correspond to the new convention. This PR does that. Had to update some of the tests as the output data format has changed (e.g. now has halos) and was originally generated a long time ago. I also increased code reuse among the regression tests for summarizing the result of each regression test. This PR is part of #471,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/526
https://github.com/CliMA/Oceananigans.jl/pull/526:337,Testability,test,tests,337,Following the reversal of the k index (PR #462) we need to regenerate all regression test data to correspond to the new convention. This PR does that. Had to update some of the tests as the output data format has changed (e.g. now has halos) and was originally generated a long time ago. I also increased code reuse among the regression tests for summarizing the result of each regression test. This PR is part of #471,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/526
https://github.com/CliMA/Oceananigans.jl/pull/526:389,Testability,test,test,389,Following the reversal of the k index (PR #462) we need to regenerate all regression test data to correspond to the new convention. This PR does that. Had to update some of the tests as the output data format has changed (e.g. now has halos) and was originally generated a long time ago. I also increased code reuse among the regression tests for summarizing the result of each regression test. This PR is part of #471,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/526
https://github.com/CliMA/Oceananigans.jl/pull/529:8,Deployability,integrat,integrates,8,"This PR integrates the finite volume operators introduced in PR #283. This includes merging `closure_operators.jl` into `Oceananigans.Operators`. All tests pass but there's quite a bit of cleanup to be done. @glwagner This PR affects a lot of code you've written so we should probably work on merging this PR together. Now that tests pass we can focus on cleanup. I still need to convert the biharmonic operators and `leith_enstrophy_diffusivity.jl` closure to finite volume. I'll also add a test for Leith. There are regression tests for constant diffusivty, Smagorinsky, and AMD, but not for other closures, so we should probably be careful that closures with no regression test remain unchanged. Some comments:. 1. The `norm` functions defined in `velocity_tracer_gradients.jl` https://github.com/climate-machine/Oceananigans.jl/blob/2bb32015e64bff830f2233d588360ccc6b8605b4/src/TurbulenceClosures/velocity_tracer_gradients.jl#L130-L154 all make use of functions like `Δᶠx_ffc` but they are defined in an `@eval` loop in in `verstappen_anisotropic_minimum_dissipation.jl`. We should probably make it clearer that these functions are closure-specific. 2. In `smagorinsky_lilly.jl`, the `κ_∂x_c`, `κ_∂y_c`, and `κ_∂z_c` functions use `ℑxᶠᵃᵃ(i, j, k, grid, νₑ, closure)` however I'm pretty sure we can just use `ℑxᶠᵃᵃ(i, j, k, grid, νₑ)` here. If so, we can get rid of the `ℑxᶠᵃᵃ(i, j, k, grid::AG{FT}, c, args...)` function definitions. 3. Certain functions are shared between turbulence closures, e.g. `ΣᵢⱼΣᵢⱼᶜᶜᶜ` is used by both `smagorinsky_lilly.jl` and `blasius_smagorinsky.jl`. Should they be moved to `closure_operators.jl`?. 4. Also, VAMD uses `Δᶠxᶜᶜᶜ` for the filter widths while Rozema AMD uses `Δx` (which looks like the regular `Δx` used by `Oceananigans.Operators`). We should probably change all filter widths to use `Δᶠ`. 5. Smagorinsky-Lilly uses `Δᶠ_ccc` for filter widths. Switching to `Δᶠᶜᶜᶜ` is probably a bad idea as `ᶠ` is denotes face. Should we change them to `Δᶠxᶜᶜᶜ = Δᶠyᶜᶜᶜ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/529
https://github.com/CliMA/Oceananigans.jl/pull/529:2848,Deployability,release,release,2848,"L154 all make use of functions like `Δᶠx_ffc` but they are defined in an `@eval` loop in in `verstappen_anisotropic_minimum_dissipation.jl`. We should probably make it clearer that these functions are closure-specific. 2. In `smagorinsky_lilly.jl`, the `κ_∂x_c`, `κ_∂y_c`, and `κ_∂z_c` functions use `ℑxᶠᵃᵃ(i, j, k, grid, νₑ, closure)` however I'm pretty sure we can just use `ℑxᶠᵃᵃ(i, j, k, grid, νₑ)` here. If so, we can get rid of the `ℑxᶠᵃᵃ(i, j, k, grid::AG{FT}, c, args...)` function definitions. 3. Certain functions are shared between turbulence closures, e.g. `ΣᵢⱼΣᵢⱼᶜᶜᶜ` is used by both `smagorinsky_lilly.jl` and `blasius_smagorinsky.jl`. Should they be moved to `closure_operators.jl`?. 4. Also, VAMD uses `Δᶠxᶜᶜᶜ` for the filter widths while Rozema AMD uses `Δx` (which looks like the regular `Δx` used by `Oceananigans.Operators`). We should probably change all filter widths to use `Δᶠ`. 5. Smagorinsky-Lilly uses `Δᶠ_ccc` for filter widths. Switching to `Δᶠᶜᶜᶜ` is probably a bad idea as `ᶠ` is denotes face. Should we change them to `Δᶠxᶜᶜᶜ = Δᶠyᶜᶜᶜ = Δᶠzᶜᶜᶜ = Δᶠ_ccc`?. 6. I could never find a symbol like `\cdot` for divergences that can be used in function names. What do you think of renaming function names like `∇_κ_∇c` to `div_κ_∇c`?. 7. `▶` is used in a lot of places in the `AbstractOperators` module. They should probably be changed to `ℑ` for consistency, but since it's all local to AbstractOperators, I'm leave the decision to @glwagner. Some changes we need to make for vertically stretched grids:; * I initially thought that we might need `apply_z_top_bc!` and `apply_z_bottom_bc!` to use ΔzC or ΔzF based on the field, but this would only apply to `w` for which you cannot use flux boundary conditions for z, so maybe it can always just use ΔzF (spacing between faces) and we can keep the one version.; * Same comment as above for `_fill_top_halo!` and `_fill_bottom_halo!`. I'll release v0.16 once this is merged as JULES.jl depends on these finite volume operators.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/529
https://github.com/CliMA/Oceananigans.jl/pull/529:8,Integrability,integrat,integrates,8,"This PR integrates the finite volume operators introduced in PR #283. This includes merging `closure_operators.jl` into `Oceananigans.Operators`. All tests pass but there's quite a bit of cleanup to be done. @glwagner This PR affects a lot of code you've written so we should probably work on merging this PR together. Now that tests pass we can focus on cleanup. I still need to convert the biharmonic operators and `leith_enstrophy_diffusivity.jl` closure to finite volume. I'll also add a test for Leith. There are regression tests for constant diffusivty, Smagorinsky, and AMD, but not for other closures, so we should probably be careful that closures with no regression test remain unchanged. Some comments:. 1. The `norm` functions defined in `velocity_tracer_gradients.jl` https://github.com/climate-machine/Oceananigans.jl/blob/2bb32015e64bff830f2233d588360ccc6b8605b4/src/TurbulenceClosures/velocity_tracer_gradients.jl#L130-L154 all make use of functions like `Δᶠx_ffc` but they are defined in an `@eval` loop in in `verstappen_anisotropic_minimum_dissipation.jl`. We should probably make it clearer that these functions are closure-specific. 2. In `smagorinsky_lilly.jl`, the `κ_∂x_c`, `κ_∂y_c`, and `κ_∂z_c` functions use `ℑxᶠᵃᵃ(i, j, k, grid, νₑ, closure)` however I'm pretty sure we can just use `ℑxᶠᵃᵃ(i, j, k, grid, νₑ)` here. If so, we can get rid of the `ℑxᶠᵃᵃ(i, j, k, grid::AG{FT}, c, args...)` function definitions. 3. Certain functions are shared between turbulence closures, e.g. `ΣᵢⱼΣᵢⱼᶜᶜᶜ` is used by both `smagorinsky_lilly.jl` and `blasius_smagorinsky.jl`. Should they be moved to `closure_operators.jl`?. 4. Also, VAMD uses `Δᶠxᶜᶜᶜ` for the filter widths while Rozema AMD uses `Δx` (which looks like the regular `Δx` used by `Oceananigans.Operators`). We should probably change all filter widths to use `Δᶠ`. 5. Smagorinsky-Lilly uses `Δᶠ_ccc` for filter widths. Switching to `Δᶠᶜᶜᶜ` is probably a bad idea as `ᶠ` is denotes face. Should we change them to `Δᶠxᶜᶜᶜ = Δᶠyᶜᶜᶜ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/529
https://github.com/CliMA/Oceananigans.jl/pull/529:2894,Integrability,depend,depends,2894,"L154 all make use of functions like `Δᶠx_ffc` but they are defined in an `@eval` loop in in `verstappen_anisotropic_minimum_dissipation.jl`. We should probably make it clearer that these functions are closure-specific. 2. In `smagorinsky_lilly.jl`, the `κ_∂x_c`, `κ_∂y_c`, and `κ_∂z_c` functions use `ℑxᶠᵃᵃ(i, j, k, grid, νₑ, closure)` however I'm pretty sure we can just use `ℑxᶠᵃᵃ(i, j, k, grid, νₑ)` here. If so, we can get rid of the `ℑxᶠᵃᵃ(i, j, k, grid::AG{FT}, c, args...)` function definitions. 3. Certain functions are shared between turbulence closures, e.g. `ΣᵢⱼΣᵢⱼᶜᶜᶜ` is used by both `smagorinsky_lilly.jl` and `blasius_smagorinsky.jl`. Should they be moved to `closure_operators.jl`?. 4. Also, VAMD uses `Δᶠxᶜᶜᶜ` for the filter widths while Rozema AMD uses `Δx` (which looks like the regular `Δx` used by `Oceananigans.Operators`). We should probably change all filter widths to use `Δᶠ`. 5. Smagorinsky-Lilly uses `Δᶠ_ccc` for filter widths. Switching to `Δᶠᶜᶜᶜ` is probably a bad idea as `ᶠ` is denotes face. Should we change them to `Δᶠxᶜᶜᶜ = Δᶠyᶜᶜᶜ = Δᶠzᶜᶜᶜ = Δᶠ_ccc`?. 6. I could never find a symbol like `\cdot` for divergences that can be used in function names. What do you think of renaming function names like `∇_κ_∇c` to `div_κ_∇c`?. 7. `▶` is used in a lot of places in the `AbstractOperators` module. They should probably be changed to `ℑ` for consistency, but since it's all local to AbstractOperators, I'm leave the decision to @glwagner. Some changes we need to make for vertically stretched grids:; * I initially thought that we might need `apply_z_top_bc!` and `apply_z_bottom_bc!` to use ΔzC or ΔzF based on the field, but this would only apply to `w` for which you cannot use flux boundary conditions for z, so maybe it can always just use ΔzF (spacing between faces) and we can keep the one version.; * Same comment as above for `_fill_top_halo!` and `_fill_bottom_halo!`. I'll release v0.16 once this is merged as JULES.jl depends on these finite volume operators.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/529
https://github.com/CliMA/Oceananigans.jl/pull/529:150,Testability,test,tests,150,"This PR integrates the finite volume operators introduced in PR #283. This includes merging `closure_operators.jl` into `Oceananigans.Operators`. All tests pass but there's quite a bit of cleanup to be done. @glwagner This PR affects a lot of code you've written so we should probably work on merging this PR together. Now that tests pass we can focus on cleanup. I still need to convert the biharmonic operators and `leith_enstrophy_diffusivity.jl` closure to finite volume. I'll also add a test for Leith. There are regression tests for constant diffusivty, Smagorinsky, and AMD, but not for other closures, so we should probably be careful that closures with no regression test remain unchanged. Some comments:. 1. The `norm` functions defined in `velocity_tracer_gradients.jl` https://github.com/climate-machine/Oceananigans.jl/blob/2bb32015e64bff830f2233d588360ccc6b8605b4/src/TurbulenceClosures/velocity_tracer_gradients.jl#L130-L154 all make use of functions like `Δᶠx_ffc` but they are defined in an `@eval` loop in in `verstappen_anisotropic_minimum_dissipation.jl`. We should probably make it clearer that these functions are closure-specific. 2. In `smagorinsky_lilly.jl`, the `κ_∂x_c`, `κ_∂y_c`, and `κ_∂z_c` functions use `ℑxᶠᵃᵃ(i, j, k, grid, νₑ, closure)` however I'm pretty sure we can just use `ℑxᶠᵃᵃ(i, j, k, grid, νₑ)` here. If so, we can get rid of the `ℑxᶠᵃᵃ(i, j, k, grid::AG{FT}, c, args...)` function definitions. 3. Certain functions are shared between turbulence closures, e.g. `ΣᵢⱼΣᵢⱼᶜᶜᶜ` is used by both `smagorinsky_lilly.jl` and `blasius_smagorinsky.jl`. Should they be moved to `closure_operators.jl`?. 4. Also, VAMD uses `Δᶠxᶜᶜᶜ` for the filter widths while Rozema AMD uses `Δx` (which looks like the regular `Δx` used by `Oceananigans.Operators`). We should probably change all filter widths to use `Δᶠ`. 5. Smagorinsky-Lilly uses `Δᶠ_ccc` for filter widths. Switching to `Δᶠᶜᶜᶜ` is probably a bad idea as `ᶠ` is denotes face. Should we change them to `Δᶠxᶜᶜᶜ = Δᶠyᶜᶜᶜ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/529
https://github.com/CliMA/Oceananigans.jl/pull/529:328,Testability,test,tests,328,"This PR integrates the finite volume operators introduced in PR #283. This includes merging `closure_operators.jl` into `Oceananigans.Operators`. All tests pass but there's quite a bit of cleanup to be done. @glwagner This PR affects a lot of code you've written so we should probably work on merging this PR together. Now that tests pass we can focus on cleanup. I still need to convert the biharmonic operators and `leith_enstrophy_diffusivity.jl` closure to finite volume. I'll also add a test for Leith. There are regression tests for constant diffusivty, Smagorinsky, and AMD, but not for other closures, so we should probably be careful that closures with no regression test remain unchanged. Some comments:. 1. The `norm` functions defined in `velocity_tracer_gradients.jl` https://github.com/climate-machine/Oceananigans.jl/blob/2bb32015e64bff830f2233d588360ccc6b8605b4/src/TurbulenceClosures/velocity_tracer_gradients.jl#L130-L154 all make use of functions like `Δᶠx_ffc` but they are defined in an `@eval` loop in in `verstappen_anisotropic_minimum_dissipation.jl`. We should probably make it clearer that these functions are closure-specific. 2. In `smagorinsky_lilly.jl`, the `κ_∂x_c`, `κ_∂y_c`, and `κ_∂z_c` functions use `ℑxᶠᵃᵃ(i, j, k, grid, νₑ, closure)` however I'm pretty sure we can just use `ℑxᶠᵃᵃ(i, j, k, grid, νₑ)` here. If so, we can get rid of the `ℑxᶠᵃᵃ(i, j, k, grid::AG{FT}, c, args...)` function definitions. 3. Certain functions are shared between turbulence closures, e.g. `ΣᵢⱼΣᵢⱼᶜᶜᶜ` is used by both `smagorinsky_lilly.jl` and `blasius_smagorinsky.jl`. Should they be moved to `closure_operators.jl`?. 4. Also, VAMD uses `Δᶠxᶜᶜᶜ` for the filter widths while Rozema AMD uses `Δx` (which looks like the regular `Δx` used by `Oceananigans.Operators`). We should probably change all filter widths to use `Δᶠ`. 5. Smagorinsky-Lilly uses `Δᶠ_ccc` for filter widths. Switching to `Δᶠᶜᶜᶜ` is probably a bad idea as `ᶠ` is denotes face. Should we change them to `Δᶠxᶜᶜᶜ = Δᶠyᶜᶜᶜ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/529
https://github.com/CliMA/Oceananigans.jl/pull/529:492,Testability,test,test,492,"This PR integrates the finite volume operators introduced in PR #283. This includes merging `closure_operators.jl` into `Oceananigans.Operators`. All tests pass but there's quite a bit of cleanup to be done. @glwagner This PR affects a lot of code you've written so we should probably work on merging this PR together. Now that tests pass we can focus on cleanup. I still need to convert the biharmonic operators and `leith_enstrophy_diffusivity.jl` closure to finite volume. I'll also add a test for Leith. There are regression tests for constant diffusivty, Smagorinsky, and AMD, but not for other closures, so we should probably be careful that closures with no regression test remain unchanged. Some comments:. 1. The `norm` functions defined in `velocity_tracer_gradients.jl` https://github.com/climate-machine/Oceananigans.jl/blob/2bb32015e64bff830f2233d588360ccc6b8605b4/src/TurbulenceClosures/velocity_tracer_gradients.jl#L130-L154 all make use of functions like `Δᶠx_ffc` but they are defined in an `@eval` loop in in `verstappen_anisotropic_minimum_dissipation.jl`. We should probably make it clearer that these functions are closure-specific. 2. In `smagorinsky_lilly.jl`, the `κ_∂x_c`, `κ_∂y_c`, and `κ_∂z_c` functions use `ℑxᶠᵃᵃ(i, j, k, grid, νₑ, closure)` however I'm pretty sure we can just use `ℑxᶠᵃᵃ(i, j, k, grid, νₑ)` here. If so, we can get rid of the `ℑxᶠᵃᵃ(i, j, k, grid::AG{FT}, c, args...)` function definitions. 3. Certain functions are shared between turbulence closures, e.g. `ΣᵢⱼΣᵢⱼᶜᶜᶜ` is used by both `smagorinsky_lilly.jl` and `blasius_smagorinsky.jl`. Should they be moved to `closure_operators.jl`?. 4. Also, VAMD uses `Δᶠxᶜᶜᶜ` for the filter widths while Rozema AMD uses `Δx` (which looks like the regular `Δx` used by `Oceananigans.Operators`). We should probably change all filter widths to use `Δᶠ`. 5. Smagorinsky-Lilly uses `Δᶠ_ccc` for filter widths. Switching to `Δᶠᶜᶜᶜ` is probably a bad idea as `ᶠ` is denotes face. Should we change them to `Δᶠxᶜᶜᶜ = Δᶠyᶜᶜᶜ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/529
https://github.com/CliMA/Oceananigans.jl/pull/529:529,Testability,test,tests,529,"This PR integrates the finite volume operators introduced in PR #283. This includes merging `closure_operators.jl` into `Oceananigans.Operators`. All tests pass but there's quite a bit of cleanup to be done. @glwagner This PR affects a lot of code you've written so we should probably work on merging this PR together. Now that tests pass we can focus on cleanup. I still need to convert the biharmonic operators and `leith_enstrophy_diffusivity.jl` closure to finite volume. I'll also add a test for Leith. There are regression tests for constant diffusivty, Smagorinsky, and AMD, but not for other closures, so we should probably be careful that closures with no regression test remain unchanged. Some comments:. 1. The `norm` functions defined in `velocity_tracer_gradients.jl` https://github.com/climate-machine/Oceananigans.jl/blob/2bb32015e64bff830f2233d588360ccc6b8605b4/src/TurbulenceClosures/velocity_tracer_gradients.jl#L130-L154 all make use of functions like `Δᶠx_ffc` but they are defined in an `@eval` loop in in `verstappen_anisotropic_minimum_dissipation.jl`. We should probably make it clearer that these functions are closure-specific. 2. In `smagorinsky_lilly.jl`, the `κ_∂x_c`, `κ_∂y_c`, and `κ_∂z_c` functions use `ℑxᶠᵃᵃ(i, j, k, grid, νₑ, closure)` however I'm pretty sure we can just use `ℑxᶠᵃᵃ(i, j, k, grid, νₑ)` here. If so, we can get rid of the `ℑxᶠᵃᵃ(i, j, k, grid::AG{FT}, c, args...)` function definitions. 3. Certain functions are shared between turbulence closures, e.g. `ΣᵢⱼΣᵢⱼᶜᶜᶜ` is used by both `smagorinsky_lilly.jl` and `blasius_smagorinsky.jl`. Should they be moved to `closure_operators.jl`?. 4. Also, VAMD uses `Δᶠxᶜᶜᶜ` for the filter widths while Rozema AMD uses `Δx` (which looks like the regular `Δx` used by `Oceananigans.Operators`). We should probably change all filter widths to use `Δᶠ`. 5. Smagorinsky-Lilly uses `Δᶠ_ccc` for filter widths. Switching to `Δᶠᶜᶜᶜ` is probably a bad idea as `ᶠ` is denotes face. Should we change them to `Δᶠxᶜᶜᶜ = Δᶠyᶜᶜᶜ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/529
https://github.com/CliMA/Oceananigans.jl/pull/529:676,Testability,test,test,676,"This PR integrates the finite volume operators introduced in PR #283. This includes merging `closure_operators.jl` into `Oceananigans.Operators`. All tests pass but there's quite a bit of cleanup to be done. @glwagner This PR affects a lot of code you've written so we should probably work on merging this PR together. Now that tests pass we can focus on cleanup. I still need to convert the biharmonic operators and `leith_enstrophy_diffusivity.jl` closure to finite volume. I'll also add a test for Leith. There are regression tests for constant diffusivty, Smagorinsky, and AMD, but not for other closures, so we should probably be careful that closures with no regression test remain unchanged. Some comments:. 1. The `norm` functions defined in `velocity_tracer_gradients.jl` https://github.com/climate-machine/Oceananigans.jl/blob/2bb32015e64bff830f2233d588360ccc6b8605b4/src/TurbulenceClosures/velocity_tracer_gradients.jl#L130-L154 all make use of functions like `Δᶠx_ffc` but they are defined in an `@eval` loop in in `verstappen_anisotropic_minimum_dissipation.jl`. We should probably make it clearer that these functions are closure-specific. 2. In `smagorinsky_lilly.jl`, the `κ_∂x_c`, `κ_∂y_c`, and `κ_∂z_c` functions use `ℑxᶠᵃᵃ(i, j, k, grid, νₑ, closure)` however I'm pretty sure we can just use `ℑxᶠᵃᵃ(i, j, k, grid, νₑ)` here. If so, we can get rid of the `ℑxᶠᵃᵃ(i, j, k, grid::AG{FT}, c, args...)` function definitions. 3. Certain functions are shared between turbulence closures, e.g. `ΣᵢⱼΣᵢⱼᶜᶜᶜ` is used by both `smagorinsky_lilly.jl` and `blasius_smagorinsky.jl`. Should they be moved to `closure_operators.jl`?. 4. Also, VAMD uses `Δᶠxᶜᶜᶜ` for the filter widths while Rozema AMD uses `Δx` (which looks like the regular `Δx` used by `Oceananigans.Operators`). We should probably change all filter widths to use `Δᶠ`. 5. Smagorinsky-Lilly uses `Δᶠ_ccc` for filter widths. Switching to `Δᶠᶜᶜᶜ` is probably a bad idea as `ᶠ` is denotes face. Should we change them to `Δᶠxᶜᶜᶜ = Δᶠyᶜᶜᶜ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/529
https://github.com/CliMA/Oceananigans.jl/pull/529:1103,Usability,clear,clearer,1103," into `Oceananigans.Operators`. All tests pass but there's quite a bit of cleanup to be done. @glwagner This PR affects a lot of code you've written so we should probably work on merging this PR together. Now that tests pass we can focus on cleanup. I still need to convert the biharmonic operators and `leith_enstrophy_diffusivity.jl` closure to finite volume. I'll also add a test for Leith. There are regression tests for constant diffusivty, Smagorinsky, and AMD, but not for other closures, so we should probably be careful that closures with no regression test remain unchanged. Some comments:. 1. The `norm` functions defined in `velocity_tracer_gradients.jl` https://github.com/climate-machine/Oceananigans.jl/blob/2bb32015e64bff830f2233d588360ccc6b8605b4/src/TurbulenceClosures/velocity_tracer_gradients.jl#L130-L154 all make use of functions like `Δᶠx_ffc` but they are defined in an `@eval` loop in in `verstappen_anisotropic_minimum_dissipation.jl`. We should probably make it clearer that these functions are closure-specific. 2. In `smagorinsky_lilly.jl`, the `κ_∂x_c`, `κ_∂y_c`, and `κ_∂z_c` functions use `ℑxᶠᵃᵃ(i, j, k, grid, νₑ, closure)` however I'm pretty sure we can just use `ℑxᶠᵃᵃ(i, j, k, grid, νₑ)` here. If so, we can get rid of the `ℑxᶠᵃᵃ(i, j, k, grid::AG{FT}, c, args...)` function definitions. 3. Certain functions are shared between turbulence closures, e.g. `ΣᵢⱼΣᵢⱼᶜᶜᶜ` is used by both `smagorinsky_lilly.jl` and `blasius_smagorinsky.jl`. Should they be moved to `closure_operators.jl`?. 4. Also, VAMD uses `Δᶠxᶜᶜᶜ` for the filter widths while Rozema AMD uses `Δx` (which looks like the regular `Δx` used by `Oceananigans.Operators`). We should probably change all filter widths to use `Δᶠ`. 5. Smagorinsky-Lilly uses `Δᶠ_ccc` for filter widths. Switching to `Δᶠᶜᶜᶜ` is probably a bad idea as `ᶠ` is denotes face. Should we change them to `Δᶠxᶜᶜᶜ = Δᶠyᶜᶜᶜ = Δᶠzᶜᶜᶜ = Δᶠ_ccc`?. 6. I could never find a symbol like `\cdot` for divergences that can be used in function na",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/529
https://github.com/CliMA/Oceananigans.jl/issues/531:249,Usability,simpl,simplest,249,"For example, you need values of `ΔzC[0]` and `ΔzF[0]` (in the halo regions) to compute vertical derivatives at the top and bottom. I think the halo cells in this case are all the same size and equal in size to the top-most or bottom-most cells. The simplest way to get this to work is to provide `ΔzC` and `ΔzF` as offset arrays and we won't have to do anything special at the boundaries. Hmmm, on a domain `z ∈ [0, L]` I guess a hack would be to call e.g. `ΔzC(x, y, min(max(0, z), L))` instead of `ΔzC(x, y, z)` but this seems dirty. I don't see a disadvantage of using an offset array over a function in this case. Users can specify `ΔzC` using an array or a function which we convert to an offset array. This issue also crops up in the atmosphere where you need to take derivatives of a base state, but if it's defined as a function then you run into this issue at the boundaries.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/531
https://github.com/CliMA/Oceananigans.jl/pull/534:394,Availability,checkpoint,checkpoint,394,"This PR adds model setup documentation describing all the possible options the user has when setting up a model. Right now it's still a mega-page work-in-progress but the more useful parts will describe how to set up different kinds of boundary conditions with several examples, how diagnostics work and how flexible they are, and also output writers including finally a little guide on how to checkpoint and restore from a checkpoint. I think this PR is the last piece of work we agreed is needed before a JOSS submission.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/534
https://github.com/CliMA/Oceananigans.jl/pull/534:424,Availability,checkpoint,checkpoint,424,"This PR adds model setup documentation describing all the possible options the user has when setting up a model. Right now it's still a mega-page work-in-progress but the more useful parts will describe how to set up different kinds of boundary conditions with several examples, how diagnostics work and how flexible they are, and also output writers including finally a little guide on how to checkpoint and restore from a checkpoint. I think this PR is the last piece of work we agreed is needed before a JOSS submission.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/534
https://github.com/CliMA/Oceananigans.jl/pull/534:308,Modifiability,flexible,flexible,308,"This PR adds model setup documentation describing all the possible options the user has when setting up a model. Right now it's still a mega-page work-in-progress but the more useful parts will describe how to set up different kinds of boundary conditions with several examples, how diagnostics work and how flexible they are, and also output writers including finally a little guide on how to checkpoint and restore from a checkpoint. I think this PR is the last piece of work we agreed is needed before a JOSS submission.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/534
https://github.com/CliMA/Oceananigans.jl/pull/534:378,Usability,guid,guide,378,"This PR adds model setup documentation describing all the possible options the user has when setting up a model. Right now it's still a mega-page work-in-progress but the more useful parts will describe how to set up different kinds of boundary conditions with several examples, how diagnostics work and how flexible they are, and also output writers including finally a little guide on how to checkpoint and restore from a checkpoint. I think this PR is the last piece of work we agreed is needed before a JOSS submission.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/534
https://github.com/CliMA/Oceananigans.jl/issues/535:635,Modifiability,refactor,refactoring,635,"I noticed that `leith_enstrophy_diffusivity.jl` does a lot of floating point comparisons with zero when computing the components of the Redi tensor, e.g.; ```julia; @inline function Redi_tensor_xz_fcc(i, j, k, grid::AbstractGrid{FT}, buoyancy, C) where FT; bx = ∂x_b(i, j, k, grid, buoyancy, C); bz = ℑxzᶠᵃᶜ(i, j, k, grid, ∂z_b, buoyancy, C); return ifelse(bx == 0 && bz == 0, zero(FT), - bx / bz); end; ```. but if `bx` and `bz` are floats then might be a bad idea to check for `== 0` as they could be very small but not trigger the true branch. Even worse as we're dividing by `bz`. Not sure if this is an issue but noticed it while refactoring for PR #529.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/535
https://github.com/CliMA/Oceananigans.jl/issues/536:114,Deployability,pipeline,pipeline,114,"Currently the example tests are ""broken"", i.e. not run because having PyPlot as a dependency caused the Travis CI pipeline to frequently fail for different reasons. I still really like matplotlib and PyPlot but after playing around with Plots.jl I think it'll be worth switching over. As it doesn't get installed through conda it should be more stable on Travis. Would be really cool if Documenter.jl works with Plots.jl [animations](http://docs.juliaplots.org/latest/animations/). I'll give it a try.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/536
https://github.com/CliMA/Oceananigans.jl/issues/536:303,Deployability,install,installed,303,"Currently the example tests are ""broken"", i.e. not run because having PyPlot as a dependency caused the Travis CI pipeline to frequently fail for different reasons. I still really like matplotlib and PyPlot but after playing around with Plots.jl I think it'll be worth switching over. As it doesn't get installed through conda it should be more stable on Travis. Would be really cool if Documenter.jl works with Plots.jl [animations](http://docs.juliaplots.org/latest/animations/). I'll give it a try.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/536
https://github.com/CliMA/Oceananigans.jl/issues/536:82,Integrability,depend,dependency,82,"Currently the example tests are ""broken"", i.e. not run because having PyPlot as a dependency caused the Travis CI pipeline to frequently fail for different reasons. I still really like matplotlib and PyPlot but after playing around with Plots.jl I think it'll be worth switching over. As it doesn't get installed through conda it should be more stable on Travis. Would be really cool if Documenter.jl works with Plots.jl [animations](http://docs.juliaplots.org/latest/animations/). I'll give it a try.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/536
https://github.com/CliMA/Oceananigans.jl/issues/536:22,Testability,test,tests,22,"Currently the example tests are ""broken"", i.e. not run because having PyPlot as a dependency caused the Travis CI pipeline to frequently fail for different reasons. I still really like matplotlib and PyPlot but after playing around with Plots.jl I think it'll be worth switching over. As it doesn't get installed through conda it should be more stable on Travis. Would be really cool if Documenter.jl works with Plots.jl [animations](http://docs.juliaplots.org/latest/animations/). I'll give it a try.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/536
https://github.com/CliMA/Oceananigans.jl/pull/538:122,Modifiability,refactor,refactor,122,This PR finally gets rid of all the Casette warnings and a few other similar warnings due to method redefinitions. Had to refactor the `FPlane` constructor to avoid a method redefinition. I chose to infer the float type `FT` from the inputs and remove the option to explicitly pass in an `FT`. This is a breaking change (hopefully a minor one) but I couldn't think of another approach that would less intrusive. Suggestions welcome for other ways to resolve the ambiguity between `FPlane` constructors. Resolves #537; Resolves #366,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/538
https://github.com/CliMA/Oceananigans.jl/pull/538:159,Safety,avoid,avoid,159,This PR finally gets rid of all the Casette warnings and a few other similar warnings due to method redefinitions. Had to refactor the `FPlane` constructor to avoid a method redefinition. I chose to infer the float type `FT` from the inputs and remove the option to explicitly pass in an `FT`. This is a breaking change (hopefully a minor one) but I couldn't think of another approach that would less intrusive. Suggestions welcome for other ways to resolve the ambiguity between `FPlane` constructors. Resolves #537; Resolves #366,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/538
https://github.com/CliMA/Oceananigans.jl/issues/539:39,Testability,test,tested,39,"Currently only four closures are being tested. ```; Testing that time stepping works [CPU(), Float32, ConstantIsotropicDiffusivity]...; Testing that time stepping works [CPU(), Float32, ConstantAnisotropicDiffusivity]...; Testing that time stepping works [CPU(), Float32, SmagorinskyLilly]...; Testing that time stepping works [CPU(), Float32, VerstappenAnisotropicMinimumDissipation]...; Testing that time stepping works [CPU(), Float64, ConstantIsotropicDiffusivity]...; Testing that time stepping works [CPU(), Float64, ConstantAnisotropicDiffusivity]...; Testing that time stepping works [CPU(), Float64, SmagorinskyLilly]...; Testing that time stepping works [CPU(), Float64, VerstappenAnisotropicMinimumDissipation]...; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/539
https://github.com/CliMA/Oceananigans.jl/issues/539:52,Testability,Test,Testing,52,"Currently only four closures are being tested. ```; Testing that time stepping works [CPU(), Float32, ConstantIsotropicDiffusivity]...; Testing that time stepping works [CPU(), Float32, ConstantAnisotropicDiffusivity]...; Testing that time stepping works [CPU(), Float32, SmagorinskyLilly]...; Testing that time stepping works [CPU(), Float32, VerstappenAnisotropicMinimumDissipation]...; Testing that time stepping works [CPU(), Float64, ConstantIsotropicDiffusivity]...; Testing that time stepping works [CPU(), Float64, ConstantAnisotropicDiffusivity]...; Testing that time stepping works [CPU(), Float64, SmagorinskyLilly]...; Testing that time stepping works [CPU(), Float64, VerstappenAnisotropicMinimumDissipation]...; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/539
https://github.com/CliMA/Oceananigans.jl/issues/539:136,Testability,Test,Testing,136,"Currently only four closures are being tested. ```; Testing that time stepping works [CPU(), Float32, ConstantIsotropicDiffusivity]...; Testing that time stepping works [CPU(), Float32, ConstantAnisotropicDiffusivity]...; Testing that time stepping works [CPU(), Float32, SmagorinskyLilly]...; Testing that time stepping works [CPU(), Float32, VerstappenAnisotropicMinimumDissipation]...; Testing that time stepping works [CPU(), Float64, ConstantIsotropicDiffusivity]...; Testing that time stepping works [CPU(), Float64, ConstantAnisotropicDiffusivity]...; Testing that time stepping works [CPU(), Float64, SmagorinskyLilly]...; Testing that time stepping works [CPU(), Float64, VerstappenAnisotropicMinimumDissipation]...; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/539
https://github.com/CliMA/Oceananigans.jl/issues/539:222,Testability,Test,Testing,222,"Currently only four closures are being tested. ```; Testing that time stepping works [CPU(), Float32, ConstantIsotropicDiffusivity]...; Testing that time stepping works [CPU(), Float32, ConstantAnisotropicDiffusivity]...; Testing that time stepping works [CPU(), Float32, SmagorinskyLilly]...; Testing that time stepping works [CPU(), Float32, VerstappenAnisotropicMinimumDissipation]...; Testing that time stepping works [CPU(), Float64, ConstantIsotropicDiffusivity]...; Testing that time stepping works [CPU(), Float64, ConstantAnisotropicDiffusivity]...; Testing that time stepping works [CPU(), Float64, SmagorinskyLilly]...; Testing that time stepping works [CPU(), Float64, VerstappenAnisotropicMinimumDissipation]...; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/539
https://github.com/CliMA/Oceananigans.jl/issues/539:294,Testability,Test,Testing,294,"Currently only four closures are being tested. ```; Testing that time stepping works [CPU(), Float32, ConstantIsotropicDiffusivity]...; Testing that time stepping works [CPU(), Float32, ConstantAnisotropicDiffusivity]...; Testing that time stepping works [CPU(), Float32, SmagorinskyLilly]...; Testing that time stepping works [CPU(), Float32, VerstappenAnisotropicMinimumDissipation]...; Testing that time stepping works [CPU(), Float64, ConstantIsotropicDiffusivity]...; Testing that time stepping works [CPU(), Float64, ConstantAnisotropicDiffusivity]...; Testing that time stepping works [CPU(), Float64, SmagorinskyLilly]...; Testing that time stepping works [CPU(), Float64, VerstappenAnisotropicMinimumDissipation]...; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/539
https://github.com/CliMA/Oceananigans.jl/issues/539:389,Testability,Test,Testing,389,"Currently only four closures are being tested. ```; Testing that time stepping works [CPU(), Float32, ConstantIsotropicDiffusivity]...; Testing that time stepping works [CPU(), Float32, ConstantAnisotropicDiffusivity]...; Testing that time stepping works [CPU(), Float32, SmagorinskyLilly]...; Testing that time stepping works [CPU(), Float32, VerstappenAnisotropicMinimumDissipation]...; Testing that time stepping works [CPU(), Float64, ConstantIsotropicDiffusivity]...; Testing that time stepping works [CPU(), Float64, ConstantAnisotropicDiffusivity]...; Testing that time stepping works [CPU(), Float64, SmagorinskyLilly]...; Testing that time stepping works [CPU(), Float64, VerstappenAnisotropicMinimumDissipation]...; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/539
https://github.com/CliMA/Oceananigans.jl/issues/539:473,Testability,Test,Testing,473,"Currently only four closures are being tested. ```; Testing that time stepping works [CPU(), Float32, ConstantIsotropicDiffusivity]...; Testing that time stepping works [CPU(), Float32, ConstantAnisotropicDiffusivity]...; Testing that time stepping works [CPU(), Float32, SmagorinskyLilly]...; Testing that time stepping works [CPU(), Float32, VerstappenAnisotropicMinimumDissipation]...; Testing that time stepping works [CPU(), Float64, ConstantIsotropicDiffusivity]...; Testing that time stepping works [CPU(), Float64, ConstantAnisotropicDiffusivity]...; Testing that time stepping works [CPU(), Float64, SmagorinskyLilly]...; Testing that time stepping works [CPU(), Float64, VerstappenAnisotropicMinimumDissipation]...; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/539
https://github.com/CliMA/Oceananigans.jl/issues/539:559,Testability,Test,Testing,559,"Currently only four closures are being tested. ```; Testing that time stepping works [CPU(), Float32, ConstantIsotropicDiffusivity]...; Testing that time stepping works [CPU(), Float32, ConstantAnisotropicDiffusivity]...; Testing that time stepping works [CPU(), Float32, SmagorinskyLilly]...; Testing that time stepping works [CPU(), Float32, VerstappenAnisotropicMinimumDissipation]...; Testing that time stepping works [CPU(), Float64, ConstantIsotropicDiffusivity]...; Testing that time stepping works [CPU(), Float64, ConstantAnisotropicDiffusivity]...; Testing that time stepping works [CPU(), Float64, SmagorinskyLilly]...; Testing that time stepping works [CPU(), Float64, VerstappenAnisotropicMinimumDissipation]...; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/539
https://github.com/CliMA/Oceananigans.jl/issues/539:631,Testability,Test,Testing,631,"Currently only four closures are being tested. ```; Testing that time stepping works [CPU(), Float32, ConstantIsotropicDiffusivity]...; Testing that time stepping works [CPU(), Float32, ConstantAnisotropicDiffusivity]...; Testing that time stepping works [CPU(), Float32, SmagorinskyLilly]...; Testing that time stepping works [CPU(), Float32, VerstappenAnisotropicMinimumDissipation]...; Testing that time stepping works [CPU(), Float64, ConstantIsotropicDiffusivity]...; Testing that time stepping works [CPU(), Float64, ConstantAnisotropicDiffusivity]...; Testing that time stepping works [CPU(), Float64, SmagorinskyLilly]...; Testing that time stepping works [CPU(), Float64, VerstappenAnisotropicMinimumDissipation]...; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/539
https://github.com/CliMA/Oceananigans.jl/issues/544:21,Testability,test,tests,21,"Was adding some grid tests and noticed this. Will fix as part of PR #543. ```julia; julia> grid = RegularCartesianGrid(Float32; size=(10, 10, 10), length=(1, 1//7, 2π)); julia> eltype.([grid.xF, grid.yF, grid.zF, grid.xC, grid.yC, grid.zC]); 6-element Array{DataType,1}:; Float64; Float64; Float64; Float64; Float64; Float64; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/544
https://github.com/CliMA/Oceananigans.jl/issues/545:387,Energy Efficiency,meter,meter,387,"We should document the following constant definitions in `utils.jl`, which I think are useful and make scripts more readable, but would be quite confusing if you didn't know that they are just `Float64` constants. ```julia; const second = 1.0; const minute = 60.0; const hour = 60minute; const day = 24hour. KiB, MiB, GiB, TiB = 1024.0 .^ (1:4); ```. I'd also like to add constants for `meter`, `centimeter` (`cm`?), and `kilometer` (`km`?).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/545
https://github.com/CliMA/Oceananigans.jl/pull/546:134,Testability,test,tests,134,"This is a revival of PR #475 adding support for applying boundary conditions on y, useful for channel models. I also added some basic tests.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/546
https://github.com/CliMA/Oceananigans.jl/issues/547:112,Testability,test,test,112,"We should add it to the `verification` folder as I'll mention it in the JOSS paper. I believe this verification test with Van Roekel et al. (2018) lives in https://github.com/glwagner/ColumnModelOptimizationProject/blob/master/les/deepening_mixed_layer.jl. @glwagner since you ran those tests do you want to do it? If you're busy I'm happy to do this. I think you also had some stuff on Overleaf that we can maybe transfer to the documentation?. Also, do you think your Kato & Phillips experiments should go in there as well?. ---. Using an analysis script to produce a figure like this might be useful:. ![image](https://user-images.githubusercontent.com/20099589/70105665-8468c280-160f-11ea-846d-c4bddcf02564.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/547
https://github.com/CliMA/Oceananigans.jl/issues/547:287,Testability,test,tests,287,"We should add it to the `verification` folder as I'll mention it in the JOSS paper. I believe this verification test with Van Roekel et al. (2018) lives in https://github.com/glwagner/ColumnModelOptimizationProject/blob/master/les/deepening_mixed_layer.jl. @glwagner since you ran those tests do you want to do it? If you're busy I'm happy to do this. I think you also had some stuff on Overleaf that we can maybe transfer to the documentation?. Also, do you think your Kato & Phillips experiments should go in there as well?. ---. Using an analysis script to produce a figure like this might be useful:. ![image](https://user-images.githubusercontent.com/20099589/70105665-8468c280-160f-11ea-846d-c4bddcf02564.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/547
https://github.com/CliMA/Oceananigans.jl/pull/549:25,Security,expose,exposed,25,Good thing to test as it exposed a typo. Resolves #539,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/549
https://github.com/CliMA/Oceananigans.jl/pull/549:14,Testability,test,test,14,Good thing to test as it exposed a typo. Resolves #539,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/549
https://github.com/CliMA/Oceananigans.jl/issues/552:9,Testability,test,testing,9,"To start testing Oceananigans at low-precision arithmetic and with alternative types with @milankl:. > I think the first thing I would need to do is making sure that Oceananigans is type stable. Meaning that you can pass a type T as an argument and this type is used throughout all computations. Even though you may only use Float64 atm, but having an entirely type-stable code that also means things like; > ```julia; > function f(A::AbstractMatrix); > ...; > 0.5*A[i,j]; > ...; > end; > ```; > are written as; > ```julia; > function f(A::Array{T,2}) where T; > ...; > one_half = T(0.5); > one_half*A[i,j]; > ```; > , makes sure that we can use Sherlog64 to understand where the problems are.; >; > Ideally, all type conversion are explicitly written into the code rather than relying on promotion",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/552
https://github.com/CliMA/Oceananigans.jl/issues/553:390,Availability,ERROR,ERROR,390,"`NetCDFOutputWriter` constructor says that ""`outputs` (which can be a; `Dict` or `NamedTuple`)"" but this line does not work on named tuples. https://github.com/climate-machine/Oceananigans.jl/blob/a511fdd2fedc9aae49a76905be24fdc60c2d60b0/src/OutputWriters/netcdf_output_writer.jl#L162. ```julia; julia> nt = (a=2, b=4, c=8); (a = 2, b = 4, c = 8). julia> for (i, j) in nt; @show i, j; end; ERROR: BoundsError: attempt to access Int64; at index [2]; Stacktrace:; [1] indexed_iterate(::Int64, ::Int64, ::Nothing) at ./tuple.jl:72; [2] top-level scope at ./REPL[4]:1; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/553
https://github.com/CliMA/Oceananigans.jl/issues/553:421,Security,access,access,421,"`NetCDFOutputWriter` constructor says that ""`outputs` (which can be a; `Dict` or `NamedTuple`)"" but this line does not work on named tuples. https://github.com/climate-machine/Oceananigans.jl/blob/a511fdd2fedc9aae49a76905be24fdc60c2d60b0/src/OutputWriters/netcdf_output_writer.jl#L162. ```julia; julia> nt = (a=2, b=4, c=8); (a = 2, b = 4, c = 8). julia> for (i, j) in nt; @show i, j; end; ERROR: BoundsError: attempt to access Int64; at index [2]; Stacktrace:; [1] indexed_iterate(::Int64, ::Int64, ::Nothing) at ./tuple.jl:72; [2] top-level scope at ./REPL[4]:1; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/553
https://github.com/CliMA/Oceananigans.jl/pull/556:139,Deployability,update,updated,139,Docstring did not match the actual constructor. They do now. @suyashbire1 Do you think `clobber` should be true or false by default?. Also updated the docstring to make it clear that `outputs` needs to be a `Dict` for now. Resolves #553,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/556
https://github.com/CliMA/Oceananigans.jl/pull/556:172,Usability,clear,clear,172,Docstring did not match the actual constructor. They do now. @suyashbire1 Do you think `clobber` should be true or false by default?. Also updated the docstring to make it clear that `outputs` needs to be a `Dict` for now. Resolves #553,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/556
https://github.com/CliMA/Oceananigans.jl/issues/562:568,Availability,ERROR,ERROR,568,"I'm following the documentation so either we have a bug or the documentation needs to be clearer on how to use `JLD2OutputWriter` with named tuples. ```julia; using Oceananigans, Oceananigans.OutputWriters; grid = RegularCartesianGrid(size=(16, 16, 16), length=(1, 1, 1)); model = Model(grid=grid); outputs = (u=model->model.velocities.u, T=model->model.tracers.T); model.output_writers[:jld2] = JLD2OutputWriter(model, outputs; frequency=1, prefix=""test"", verbose=true); time_step!(model; Δt=1, Nt=1); ```; produces; ```; [ Info: Calculating JLD2 output (:u, :T)...; ERROR: MethodError: Cannot `convert` an object of type Field{Oceananigans.Cell,Oceananigans.Cell,Oceananigans.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}} to an object of type Field{Oceananigans.Face,Oceananigans.Cell,Oceananigans.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}} ; Closest candidates are:; convert(::Type{T}, ::T) where T at essentials.jl:168; Stacktrace:; [1] setindex!(::Dict{Symbol,Field{Oceananigans.Face,Oceananigans.Cell,Oceananigans.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}, ::Field{Oceananigans.Cell,Oceananigans.Cell,Oceananigans.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::Symbol) at ./dict.jl:380; [2] Dict{Symbol,Field{Oceananigans.Face,Oceananigans.Cell,Oceananigans.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}(::Base.Generator{Base.Iterators.Zip{Tuple{Tuple{Symbol,Symbol},Tu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/562
https://github.com/CliMA/Oceananigans.jl/issues/562:450,Testability,test,test,450,"I'm following the documentation so either we have a bug or the documentation needs to be clearer on how to use `JLD2OutputWriter` with named tuples. ```julia; using Oceananigans, Oceananigans.OutputWriters; grid = RegularCartesianGrid(size=(16, 16, 16), length=(1, 1, 1)); model = Model(grid=grid); outputs = (u=model->model.velocities.u, T=model->model.tracers.T); model.output_writers[:jld2] = JLD2OutputWriter(model, outputs; frequency=1, prefix=""test"", verbose=true); time_step!(model; Δt=1, Nt=1); ```; produces; ```; [ Info: Calculating JLD2 output (:u, :T)...; ERROR: MethodError: Cannot `convert` an object of type Field{Oceananigans.Cell,Oceananigans.Cell,Oceananigans.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}} to an object of type Field{Oceananigans.Face,Oceananigans.Cell,Oceananigans.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}} ; Closest candidates are:; convert(::Type{T}, ::T) where T at essentials.jl:168; Stacktrace:; [1] setindex!(::Dict{Symbol,Field{Oceananigans.Face,Oceananigans.Cell,Oceananigans.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}, ::Field{Oceananigans.Cell,Oceananigans.Cell,Oceananigans.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::Symbol) at ./dict.jl:380; [2] Dict{Symbol,Field{Oceananigans.Face,Oceananigans.Cell,Oceananigans.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}(::Base.Generator{Base.Iterators.Zip{Tuple{Tuple{Symbol,Symbol},Tu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/562
https://github.com/CliMA/Oceananigans.jl/issues/562:89,Usability,clear,clearer,89,"I'm following the documentation so either we have a bug or the documentation needs to be clearer on how to use `JLD2OutputWriter` with named tuples. ```julia; using Oceananigans, Oceananigans.OutputWriters; grid = RegularCartesianGrid(size=(16, 16, 16), length=(1, 1, 1)); model = Model(grid=grid); outputs = (u=model->model.velocities.u, T=model->model.tracers.T); model.output_writers[:jld2] = JLD2OutputWriter(model, outputs; frequency=1, prefix=""test"", verbose=true); time_step!(model; Δt=1, Nt=1); ```; produces; ```; [ Info: Calculating JLD2 output (:u, :T)...; ERROR: MethodError: Cannot `convert` an object of type Field{Oceananigans.Cell,Oceananigans.Cell,Oceananigans.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}} to an object of type Field{Oceananigans.Face,Oceananigans.Cell,Oceananigans.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}} ; Closest candidates are:; convert(::Type{T}, ::T) where T at essentials.jl:168; Stacktrace:; [1] setindex!(::Dict{Symbol,Field{Oceananigans.Face,Oceananigans.Cell,Oceananigans.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}, ::Field{Oceananigans.Cell,Oceananigans.Cell,Oceananigans.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::Symbol) at ./dict.jl:380; [2] Dict{Symbol,Field{Oceananigans.Face,Oceananigans.Cell,Oceananigans.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}(::Base.Generator{Base.Iterators.Zip{Tuple{Tuple{Symbol,Symbol},Tu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/562
https://github.com/CliMA/Oceananigans.jl/issues/563:152,Availability,failure,failures,152,From the test log; ```; WARNING: using CUDAdrv.device in module TimeSteppers conflicts with an existing identifier.; ```. Was also responsible for test failures on PR #559. Another reason to prefer `import` over `using`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/563
https://github.com/CliMA/Oceananigans.jl/issues/563:9,Testability,test,test,9,From the test log; ```; WARNING: using CUDAdrv.device in module TimeSteppers conflicts with an existing identifier.; ```. Was also responsible for test failures on PR #559. Another reason to prefer `import` over `using`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/563
https://github.com/CliMA/Oceananigans.jl/issues/563:14,Testability,log,log,14,From the test log; ```; WARNING: using CUDAdrv.device in module TimeSteppers conflicts with an existing identifier.; ```. Was also responsible for test failures on PR #559. Another reason to prefer `import` over `using`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/563
https://github.com/CliMA/Oceananigans.jl/issues/563:147,Testability,test,test,147,From the test log; ```; WARNING: using CUDAdrv.device in module TimeSteppers conflicts with an existing identifier.; ```. Was also responsible for test failures on PR #559. Another reason to prefer `import` over `using`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/563
https://github.com/CliMA/Oceananigans.jl/pull/564:108,Availability,avail,available,108,Once we decide on a final draft on Google Docs I'll update `paper.md`. JOSS requires a Markdown paper to be available in the repository. X-Ref: https://github.com/openjournals/joss-reviews/issues/1965; X-Ref: https://github.com/openjournals/joss-reviews/issues/2018,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/564
https://github.com/CliMA/Oceananigans.jl/pull/564:52,Deployability,update,update,52,Once we decide on a final draft on Google Docs I'll update `paper.md`. JOSS requires a Markdown paper to be available in the repository. X-Ref: https://github.com/openjournals/joss-reviews/issues/1965; X-Ref: https://github.com/openjournals/joss-reviews/issues/2018,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/564
https://github.com/CliMA/Oceananigans.jl/issues/565:48,Usability,Simpl,SimpleForcing,48,"Forcing functions use `model.parameters` while `SimpleForcing` have their own parameters. Could be confusing as boundary condition functions also rely on `model.parameters`. To be consistent and clearer to users, I feel like `SimpleForcing` should use `model.parameters` instead of storing its own. But maybe I'm missing something and there was a good reason for this. https://github.com/climate-machine/Oceananigans.jl/blob/7080929008182b8d8e2d09e6a1de5d2f23f276d7/src/forcing.jl#L1-L13",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/565
https://github.com/CliMA/Oceananigans.jl/issues/565:195,Usability,clear,clearer,195,"Forcing functions use `model.parameters` while `SimpleForcing` have their own parameters. Could be confusing as boundary condition functions also rely on `model.parameters`. To be consistent and clearer to users, I feel like `SimpleForcing` should use `model.parameters` instead of storing its own. But maybe I'm missing something and there was a good reason for this. https://github.com/climate-machine/Oceananigans.jl/blob/7080929008182b8d8e2d09e6a1de5d2f23f276d7/src/forcing.jl#L1-L13",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/565
https://github.com/CliMA/Oceananigans.jl/issues/565:226,Usability,Simpl,SimpleForcing,226,"Forcing functions use `model.parameters` while `SimpleForcing` have their own parameters. Could be confusing as boundary condition functions also rely on `model.parameters`. To be consistent and clearer to users, I feel like `SimpleForcing` should use `model.parameters` instead of storing its own. But maybe I'm missing something and there was a good reason for this. https://github.com/climate-machine/Oceananigans.jl/blob/7080929008182b8d8e2d09e6a1de5d2f23f276d7/src/forcing.jl#L1-L13",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/565
https://github.com/CliMA/Oceananigans.jl/pull/570:559,Deployability,Update,Updated,559,"This PR refactors and improves the documentation. Some of the things done in this PR:; 1. Split long pages in section. This was done to the physics section and the model setup section.; 2. Switch from PyPlot.jl to Plots.jl for plotting in examples. Each example now comes with an mp4 animation of the output. I believe this greatly improves the examples as users will have a better idea of what each example does. Surprisingly, the plotting code has been simplified. This will also allow us to run the example tests again (currently 5 or 6 broken tests).; 3. Updated performance benchmarks. CPU and GPU used (among other info from `versioninfo()`) is included to provide context for each benchmark.; 4. Added a page in the documentation called ""Using GPUs"" which gives some instructions on how to how to start using GPUs with Oceananigans (and Julia), how to tell if you have a compatible GPU, and some resources on where to get GPUs.; 5. Fixed the public API documentation to include more docstrings and include some docstrings that were left out when we moved certain bits into submodules.; 6. Numerous small fixes and improvements. Things left to do:; 1. Fix `@example` blocks in model setup docs.; 2. Add references.; 3. Generate documentation for private API as well. Resolves #466; Resolves #482; Resolves #483; Resolves #536",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/570
https://github.com/CliMA/Oceananigans.jl/pull/570:8,Modifiability,refactor,refactors,8,"This PR refactors and improves the documentation. Some of the things done in this PR:; 1. Split long pages in section. This was done to the physics section and the model setup section.; 2. Switch from PyPlot.jl to Plots.jl for plotting in examples. Each example now comes with an mp4 animation of the output. I believe this greatly improves the examples as users will have a better idea of what each example does. Surprisingly, the plotting code has been simplified. This will also allow us to run the example tests again (currently 5 or 6 broken tests).; 3. Updated performance benchmarks. CPU and GPU used (among other info from `versioninfo()`) is included to provide context for each benchmark.; 4. Added a page in the documentation called ""Using GPUs"" which gives some instructions on how to how to start using GPUs with Oceananigans (and Julia), how to tell if you have a compatible GPU, and some resources on where to get GPUs.; 5. Fixed the public API documentation to include more docstrings and include some docstrings that were left out when we moved certain bits into submodules.; 6. Numerous small fixes and improvements. Things left to do:; 1. Fix `@example` blocks in model setup docs.; 2. Add references.; 3. Generate documentation for private API as well. Resolves #466; Resolves #482; Resolves #483; Resolves #536",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/570
https://github.com/CliMA/Oceananigans.jl/pull/570:567,Performance,perform,performance,567,"This PR refactors and improves the documentation. Some of the things done in this PR:; 1. Split long pages in section. This was done to the physics section and the model setup section.; 2. Switch from PyPlot.jl to Plots.jl for plotting in examples. Each example now comes with an mp4 animation of the output. I believe this greatly improves the examples as users will have a better idea of what each example does. Surprisingly, the plotting code has been simplified. This will also allow us to run the example tests again (currently 5 or 6 broken tests).; 3. Updated performance benchmarks. CPU and GPU used (among other info from `versioninfo()`) is included to provide context for each benchmark.; 4. Added a page in the documentation called ""Using GPUs"" which gives some instructions on how to how to start using GPUs with Oceananigans (and Julia), how to tell if you have a compatible GPU, and some resources on where to get GPUs.; 5. Fixed the public API documentation to include more docstrings and include some docstrings that were left out when we moved certain bits into submodules.; 6. Numerous small fixes and improvements. Things left to do:; 1. Fix `@example` blocks in model setup docs.; 2. Add references.; 3. Generate documentation for private API as well. Resolves #466; Resolves #482; Resolves #483; Resolves #536",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/570
https://github.com/CliMA/Oceananigans.jl/pull/570:510,Testability,test,tests,510,"This PR refactors and improves the documentation. Some of the things done in this PR:; 1. Split long pages in section. This was done to the physics section and the model setup section.; 2. Switch from PyPlot.jl to Plots.jl for plotting in examples. Each example now comes with an mp4 animation of the output. I believe this greatly improves the examples as users will have a better idea of what each example does. Surprisingly, the plotting code has been simplified. This will also allow us to run the example tests again (currently 5 or 6 broken tests).; 3. Updated performance benchmarks. CPU and GPU used (among other info from `versioninfo()`) is included to provide context for each benchmark.; 4. Added a page in the documentation called ""Using GPUs"" which gives some instructions on how to how to start using GPUs with Oceananigans (and Julia), how to tell if you have a compatible GPU, and some resources on where to get GPUs.; 5. Fixed the public API documentation to include more docstrings and include some docstrings that were left out when we moved certain bits into submodules.; 6. Numerous small fixes and improvements. Things left to do:; 1. Fix `@example` blocks in model setup docs.; 2. Add references.; 3. Generate documentation for private API as well. Resolves #466; Resolves #482; Resolves #483; Resolves #536",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/570
https://github.com/CliMA/Oceananigans.jl/pull/570:547,Testability,test,tests,547,"This PR refactors and improves the documentation. Some of the things done in this PR:; 1. Split long pages in section. This was done to the physics section and the model setup section.; 2. Switch from PyPlot.jl to Plots.jl for plotting in examples. Each example now comes with an mp4 animation of the output. I believe this greatly improves the examples as users will have a better idea of what each example does. Surprisingly, the plotting code has been simplified. This will also allow us to run the example tests again (currently 5 or 6 broken tests).; 3. Updated performance benchmarks. CPU and GPU used (among other info from `versioninfo()`) is included to provide context for each benchmark.; 4. Added a page in the documentation called ""Using GPUs"" which gives some instructions on how to how to start using GPUs with Oceananigans (and Julia), how to tell if you have a compatible GPU, and some resources on where to get GPUs.; 5. Fixed the public API documentation to include more docstrings and include some docstrings that were left out when we moved certain bits into submodules.; 6. Numerous small fixes and improvements. Things left to do:; 1. Fix `@example` blocks in model setup docs.; 2. Add references.; 3. Generate documentation for private API as well. Resolves #466; Resolves #482; Resolves #483; Resolves #536",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/570
https://github.com/CliMA/Oceananigans.jl/pull/570:579,Testability,benchmark,benchmarks,579,"This PR refactors and improves the documentation. Some of the things done in this PR:; 1. Split long pages in section. This was done to the physics section and the model setup section.; 2. Switch from PyPlot.jl to Plots.jl for plotting in examples. Each example now comes with an mp4 animation of the output. I believe this greatly improves the examples as users will have a better idea of what each example does. Surprisingly, the plotting code has been simplified. This will also allow us to run the example tests again (currently 5 or 6 broken tests).; 3. Updated performance benchmarks. CPU and GPU used (among other info from `versioninfo()`) is included to provide context for each benchmark.; 4. Added a page in the documentation called ""Using GPUs"" which gives some instructions on how to how to start using GPUs with Oceananigans (and Julia), how to tell if you have a compatible GPU, and some resources on where to get GPUs.; 5. Fixed the public API documentation to include more docstrings and include some docstrings that were left out when we moved certain bits into submodules.; 6. Numerous small fixes and improvements. Things left to do:; 1. Fix `@example` blocks in model setup docs.; 2. Add references.; 3. Generate documentation for private API as well. Resolves #466; Resolves #482; Resolves #483; Resolves #536",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/570
https://github.com/CliMA/Oceananigans.jl/pull/570:688,Testability,benchmark,benchmark,688,"This PR refactors and improves the documentation. Some of the things done in this PR:; 1. Split long pages in section. This was done to the physics section and the model setup section.; 2. Switch from PyPlot.jl to Plots.jl for plotting in examples. Each example now comes with an mp4 animation of the output. I believe this greatly improves the examples as users will have a better idea of what each example does. Surprisingly, the plotting code has been simplified. This will also allow us to run the example tests again (currently 5 or 6 broken tests).; 3. Updated performance benchmarks. CPU and GPU used (among other info from `versioninfo()`) is included to provide context for each benchmark.; 4. Added a page in the documentation called ""Using GPUs"" which gives some instructions on how to how to start using GPUs with Oceananigans (and Julia), how to tell if you have a compatible GPU, and some resources on where to get GPUs.; 5. Fixed the public API documentation to include more docstrings and include some docstrings that were left out when we moved certain bits into submodules.; 6. Numerous small fixes and improvements. Things left to do:; 1. Fix `@example` blocks in model setup docs.; 2. Add references.; 3. Generate documentation for private API as well. Resolves #466; Resolves #482; Resolves #483; Resolves #536",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/570
https://github.com/CliMA/Oceananigans.jl/pull/570:455,Usability,simpl,simplified,455,"This PR refactors and improves the documentation. Some of the things done in this PR:; 1. Split long pages in section. This was done to the physics section and the model setup section.; 2. Switch from PyPlot.jl to Plots.jl for plotting in examples. Each example now comes with an mp4 animation of the output. I believe this greatly improves the examples as users will have a better idea of what each example does. Surprisingly, the plotting code has been simplified. This will also allow us to run the example tests again (currently 5 or 6 broken tests).; 3. Updated performance benchmarks. CPU and GPU used (among other info from `versioninfo()`) is included to provide context for each benchmark.; 4. Added a page in the documentation called ""Using GPUs"" which gives some instructions on how to how to start using GPUs with Oceananigans (and Julia), how to tell if you have a compatible GPU, and some resources on where to get GPUs.; 5. Fixed the public API documentation to include more docstrings and include some docstrings that were left out when we moved certain bits into submodules.; 6. Numerous small fixes and improvements. Things left to do:; 1. Fix `@example` blocks in model setup docs.; 2. Add references.; 3. Generate documentation for private API as well. Resolves #466; Resolves #482; Resolves #483; Resolves #536",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/570
https://github.com/CliMA/Oceananigans.jl/pull/571:25,Availability,error,error,25,This PR fixes. 1. A sign error in the momentum kernels associated with the Stokes drift tendency terms for surface waves and. 2. Interpolation (or lack thereof) error in the surface wave pseudovorticity term.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/571
https://github.com/CliMA/Oceananigans.jl/pull/571:161,Availability,error,error,161,This PR fixes. 1. A sign error in the momentum kernels associated with the Stokes drift tendency terms for surface waves and. 2. Interpolation (or lack thereof) error in the surface wave pseudovorticity term.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/571
https://github.com/CliMA/Oceananigans.jl/pull/572:570,Availability,down,down,570,"This PR aims to add the lid-driven cavity as a verification experiment (first) and as a simple example (second) that is very well-known in the CFD world. It's set up as a 2D problem in the _yz_ plane. It also tests that horizontal/channel boundary conditions work. The verification experiment aims to reproduce the results detailed by [Ghia, Ghia, & Shin (1982)](https://doi.org/10.1016/0021-9991(82)90058-4). Unfortunately right now it seems to blow up no matter what I do. Once the top plate is set in motion a vorticity anomaly makes its way along the top plate then down to the bottom plate at which point blow up seems to occur no matter the time step or Reynolds number. A [Physics StackExchange post](https://physics.stackexchange.com/questions/461782/clarification-on-the-lid-driven-cavity-problem-in-cfd) suggested that quiescent initial conditions should be fine ""although if the wall Mach number is large, the sudden impulse could be numerically destabilizing"" which would only make sense for compressible models. I tried with vortical initial conditions too but no luck.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/572
https://github.com/CliMA/Oceananigans.jl/pull/572:209,Testability,test,tests,209,"This PR aims to add the lid-driven cavity as a verification experiment (first) and as a simple example (second) that is very well-known in the CFD world. It's set up as a 2D problem in the _yz_ plane. It also tests that horizontal/channel boundary conditions work. The verification experiment aims to reproduce the results detailed by [Ghia, Ghia, & Shin (1982)](https://doi.org/10.1016/0021-9991(82)90058-4). Unfortunately right now it seems to blow up no matter what I do. Once the top plate is set in motion a vorticity anomaly makes its way along the top plate then down to the bottom plate at which point blow up seems to occur no matter the time step or Reynolds number. A [Physics StackExchange post](https://physics.stackexchange.com/questions/461782/clarification-on-the-lid-driven-cavity-problem-in-cfd) suggested that quiescent initial conditions should be fine ""although if the wall Mach number is large, the sudden impulse could be numerically destabilizing"" which would only make sense for compressible models. I tried with vortical initial conditions too but no luck.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/572
https://github.com/CliMA/Oceananigans.jl/pull/572:88,Usability,simpl,simple,88,"This PR aims to add the lid-driven cavity as a verification experiment (first) and as a simple example (second) that is very well-known in the CFD world. It's set up as a 2D problem in the _yz_ plane. It also tests that horizontal/channel boundary conditions work. The verification experiment aims to reproduce the results detailed by [Ghia, Ghia, & Shin (1982)](https://doi.org/10.1016/0021-9991(82)90058-4). Unfortunately right now it seems to blow up no matter what I do. Once the top plate is set in motion a vorticity anomaly makes its way along the top plate then down to the bottom plate at which point blow up seems to occur no matter the time step or Reynolds number. A [Physics StackExchange post](https://physics.stackexchange.com/questions/461782/clarification-on-the-lid-driven-cavity-problem-in-cfd) suggested that quiescent initial conditions should be fine ""although if the wall Mach number is large, the sudden impulse could be numerically destabilizing"" which would only make sense for compressible models. I tried with vortical initial conditions too but no luck.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/572
https://github.com/CliMA/Oceananigans.jl/pull/573:766,Deployability,update,update,766,"This PR aims to add the forced flow analytic test as a verification experiment. The test is described in section 6.1 of [Brown, Cortez, & Minion (2001)](https://doi.org/10.1006/jcph.2001.6715) and is used to test various projection methods for the incompressible Navier-Stokes equations. The reason for implementing this test is to investigate the accuracy of Oceananigans' projection (or fractional step) method following concerns brought up by @sandreza. In particular, we can test whether Oceananigans' time-stepping is indeed second-order accurate in velocity and pressure. A couple of points regarding the accuracy of projection methods for us:; 1. In the introduction to Brown et al. (2001), they heuristically suggest adding a correction term to the pressure update that is linearly proportional to the viscosity ν. To me this suggests that perhaps the accuracy of the projection method matters more at low Reynolds number. The forced flow test uses Re = 1 so it's probably in a regime where the accuracy of the projection method matters a lot.; 2. The entire paper seems to focus on the semi-implicit form of the discrete Navier-Stokes equations where diffusion is treated implicitly. It's unclear to me whether their paper matters to us since we currently treat diffusion completely explicitly. Right now the test blows up (no matter how small the time step). Not sure why. I'll have to investigate and plots things a bit. Most likely I just set things up incorrectly.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/573
https://github.com/CliMA/Oceananigans.jl/pull/573:45,Testability,test,test,45,"This PR aims to add the forced flow analytic test as a verification experiment. The test is described in section 6.1 of [Brown, Cortez, & Minion (2001)](https://doi.org/10.1006/jcph.2001.6715) and is used to test various projection methods for the incompressible Navier-Stokes equations. The reason for implementing this test is to investigate the accuracy of Oceananigans' projection (or fractional step) method following concerns brought up by @sandreza. In particular, we can test whether Oceananigans' time-stepping is indeed second-order accurate in velocity and pressure. A couple of points regarding the accuracy of projection methods for us:; 1. In the introduction to Brown et al. (2001), they heuristically suggest adding a correction term to the pressure update that is linearly proportional to the viscosity ν. To me this suggests that perhaps the accuracy of the projection method matters more at low Reynolds number. The forced flow test uses Re = 1 so it's probably in a regime where the accuracy of the projection method matters a lot.; 2. The entire paper seems to focus on the semi-implicit form of the discrete Navier-Stokes equations where diffusion is treated implicitly. It's unclear to me whether their paper matters to us since we currently treat diffusion completely explicitly. Right now the test blows up (no matter how small the time step). Not sure why. I'll have to investigate and plots things a bit. Most likely I just set things up incorrectly.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/573
https://github.com/CliMA/Oceananigans.jl/pull/573:84,Testability,test,test,84,"This PR aims to add the forced flow analytic test as a verification experiment. The test is described in section 6.1 of [Brown, Cortez, & Minion (2001)](https://doi.org/10.1006/jcph.2001.6715) and is used to test various projection methods for the incompressible Navier-Stokes equations. The reason for implementing this test is to investigate the accuracy of Oceananigans' projection (or fractional step) method following concerns brought up by @sandreza. In particular, we can test whether Oceananigans' time-stepping is indeed second-order accurate in velocity and pressure. A couple of points regarding the accuracy of projection methods for us:; 1. In the introduction to Brown et al. (2001), they heuristically suggest adding a correction term to the pressure update that is linearly proportional to the viscosity ν. To me this suggests that perhaps the accuracy of the projection method matters more at low Reynolds number. The forced flow test uses Re = 1 so it's probably in a regime where the accuracy of the projection method matters a lot.; 2. The entire paper seems to focus on the semi-implicit form of the discrete Navier-Stokes equations where diffusion is treated implicitly. It's unclear to me whether their paper matters to us since we currently treat diffusion completely explicitly. Right now the test blows up (no matter how small the time step). Not sure why. I'll have to investigate and plots things a bit. Most likely I just set things up incorrectly.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/573
https://github.com/CliMA/Oceananigans.jl/pull/573:208,Testability,test,test,208,"This PR aims to add the forced flow analytic test as a verification experiment. The test is described in section 6.1 of [Brown, Cortez, & Minion (2001)](https://doi.org/10.1006/jcph.2001.6715) and is used to test various projection methods for the incompressible Navier-Stokes equations. The reason for implementing this test is to investigate the accuracy of Oceananigans' projection (or fractional step) method following concerns brought up by @sandreza. In particular, we can test whether Oceananigans' time-stepping is indeed second-order accurate in velocity and pressure. A couple of points regarding the accuracy of projection methods for us:; 1. In the introduction to Brown et al. (2001), they heuristically suggest adding a correction term to the pressure update that is linearly proportional to the viscosity ν. To me this suggests that perhaps the accuracy of the projection method matters more at low Reynolds number. The forced flow test uses Re = 1 so it's probably in a regime where the accuracy of the projection method matters a lot.; 2. The entire paper seems to focus on the semi-implicit form of the discrete Navier-Stokes equations where diffusion is treated implicitly. It's unclear to me whether their paper matters to us since we currently treat diffusion completely explicitly. Right now the test blows up (no matter how small the time step). Not sure why. I'll have to investigate and plots things a bit. Most likely I just set things up incorrectly.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/573
https://github.com/CliMA/Oceananigans.jl/pull/573:321,Testability,test,test,321,"This PR aims to add the forced flow analytic test as a verification experiment. The test is described in section 6.1 of [Brown, Cortez, & Minion (2001)](https://doi.org/10.1006/jcph.2001.6715) and is used to test various projection methods for the incompressible Navier-Stokes equations. The reason for implementing this test is to investigate the accuracy of Oceananigans' projection (or fractional step) method following concerns brought up by @sandreza. In particular, we can test whether Oceananigans' time-stepping is indeed second-order accurate in velocity and pressure. A couple of points regarding the accuracy of projection methods for us:; 1. In the introduction to Brown et al. (2001), they heuristically suggest adding a correction term to the pressure update that is linearly proportional to the viscosity ν. To me this suggests that perhaps the accuracy of the projection method matters more at low Reynolds number. The forced flow test uses Re = 1 so it's probably in a regime where the accuracy of the projection method matters a lot.; 2. The entire paper seems to focus on the semi-implicit form of the discrete Navier-Stokes equations where diffusion is treated implicitly. It's unclear to me whether their paper matters to us since we currently treat diffusion completely explicitly. Right now the test blows up (no matter how small the time step). Not sure why. I'll have to investigate and plots things a bit. Most likely I just set things up incorrectly.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/573
https://github.com/CliMA/Oceananigans.jl/pull/573:479,Testability,test,test,479,"This PR aims to add the forced flow analytic test as a verification experiment. The test is described in section 6.1 of [Brown, Cortez, & Minion (2001)](https://doi.org/10.1006/jcph.2001.6715) and is used to test various projection methods for the incompressible Navier-Stokes equations. The reason for implementing this test is to investigate the accuracy of Oceananigans' projection (or fractional step) method following concerns brought up by @sandreza. In particular, we can test whether Oceananigans' time-stepping is indeed second-order accurate in velocity and pressure. A couple of points regarding the accuracy of projection methods for us:; 1. In the introduction to Brown et al. (2001), they heuristically suggest adding a correction term to the pressure update that is linearly proportional to the viscosity ν. To me this suggests that perhaps the accuracy of the projection method matters more at low Reynolds number. The forced flow test uses Re = 1 so it's probably in a regime where the accuracy of the projection method matters a lot.; 2. The entire paper seems to focus on the semi-implicit form of the discrete Navier-Stokes equations where diffusion is treated implicitly. It's unclear to me whether their paper matters to us since we currently treat diffusion completely explicitly. Right now the test blows up (no matter how small the time step). Not sure why. I'll have to investigate and plots things a bit. Most likely I just set things up incorrectly.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/573
https://github.com/CliMA/Oceananigans.jl/pull/573:947,Testability,test,test,947,"This PR aims to add the forced flow analytic test as a verification experiment. The test is described in section 6.1 of [Brown, Cortez, & Minion (2001)](https://doi.org/10.1006/jcph.2001.6715) and is used to test various projection methods for the incompressible Navier-Stokes equations. The reason for implementing this test is to investigate the accuracy of Oceananigans' projection (or fractional step) method following concerns brought up by @sandreza. In particular, we can test whether Oceananigans' time-stepping is indeed second-order accurate in velocity and pressure. A couple of points regarding the accuracy of projection methods for us:; 1. In the introduction to Brown et al. (2001), they heuristically suggest adding a correction term to the pressure update that is linearly proportional to the viscosity ν. To me this suggests that perhaps the accuracy of the projection method matters more at low Reynolds number. The forced flow test uses Re = 1 so it's probably in a regime where the accuracy of the projection method matters a lot.; 2. The entire paper seems to focus on the semi-implicit form of the discrete Navier-Stokes equations where diffusion is treated implicitly. It's unclear to me whether their paper matters to us since we currently treat diffusion completely explicitly. Right now the test blows up (no matter how small the time step). Not sure why. I'll have to investigate and plots things a bit. Most likely I just set things up incorrectly.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/573
https://github.com/CliMA/Oceananigans.jl/pull/573:1318,Testability,test,test,1318,"This PR aims to add the forced flow analytic test as a verification experiment. The test is described in section 6.1 of [Brown, Cortez, & Minion (2001)](https://doi.org/10.1006/jcph.2001.6715) and is used to test various projection methods for the incompressible Navier-Stokes equations. The reason for implementing this test is to investigate the accuracy of Oceananigans' projection (or fractional step) method following concerns brought up by @sandreza. In particular, we can test whether Oceananigans' time-stepping is indeed second-order accurate in velocity and pressure. A couple of points regarding the accuracy of projection methods for us:; 1. In the introduction to Brown et al. (2001), they heuristically suggest adding a correction term to the pressure update that is linearly proportional to the viscosity ν. To me this suggests that perhaps the accuracy of the projection method matters more at low Reynolds number. The forced flow test uses Re = 1 so it's probably in a regime where the accuracy of the projection method matters a lot.; 2. The entire paper seems to focus on the semi-implicit form of the discrete Navier-Stokes equations where diffusion is treated implicitly. It's unclear to me whether their paper matters to us since we currently treat diffusion completely explicitly. Right now the test blows up (no matter how small the time step). Not sure why. I'll have to investigate and plots things a bit. Most likely I just set things up incorrectly.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/573
https://github.com/CliMA/Oceananigans.jl/issues/578:62,Testability,log,logger,62,Would be nice to switch from print statements to using a real logger. We can start doing this in the tests where we have a lot of print statements. Logging would also be nice there so we can quickly eyeball how long tests take to execute from build logs. @arcavaliere said he'd be interested in doing this :tada:,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/578
https://github.com/CliMA/Oceananigans.jl/issues/578:101,Testability,test,tests,101,Would be nice to switch from print statements to using a real logger. We can start doing this in the tests where we have a lot of print statements. Logging would also be nice there so we can quickly eyeball how long tests take to execute from build logs. @arcavaliere said he'd be interested in doing this :tada:,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/578
https://github.com/CliMA/Oceananigans.jl/issues/578:148,Testability,Log,Logging,148,Would be nice to switch from print statements to using a real logger. We can start doing this in the tests where we have a lot of print statements. Logging would also be nice there so we can quickly eyeball how long tests take to execute from build logs. @arcavaliere said he'd be interested in doing this :tada:,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/578
https://github.com/CliMA/Oceananigans.jl/issues/578:216,Testability,test,tests,216,Would be nice to switch from print statements to using a real logger. We can start doing this in the tests where we have a lot of print statements. Logging would also be nice there so we can quickly eyeball how long tests take to execute from build logs. @arcavaliere said he'd be interested in doing this :tada:,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/578
https://github.com/CliMA/Oceananigans.jl/issues/578:249,Testability,log,logs,249,Would be nice to switch from print statements to using a real logger. We can start doing this in the tests where we have a lot of print statements. Logging would also be nice there so we can quickly eyeball how long tests take to execute from build logs. @arcavaliere said he'd be interested in doing this :tada:,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/578
https://github.com/CliMA/Oceananigans.jl/issues/579:21,Usability,simpl,simple,21,"I'm trying to code a simple 2D channel model in v0.17.0 where the periodic dimension is the flat dimension. I keep experiencing seemingly spontaneous velocity blowup during spin-up despite changing parameters/removing most forcing. Here is an example:. ```; Nx = 1; Ny = 256; Nz = 32; Lx = 1000e3; Ly = 1000e3; Lz = 4e3; N² = 1e-5; Δp = 1e-5 #will set to be a function of y; end_time = 1day. # ## Define a forcing function; pressure_gradient(x, y, z, t) = Δp / Lx; pressure_gradient_forcing = SimpleForcing(pressure_gradient). ## Instantiate the model; model = ChannelModel(; grid = RegularCartesianGrid(size = (Nx, Ny, Nz), x = (0, Lx), y = (-Ly/2, Ly/2), z=(-Lz, 0)),; closure = ConstantIsotropicDiffusivity(ν=100, κ=100),; coriolis = FPlane(f=1e-5),; tracers = (:b,),; buoyancy = BuoyancyTracer(),; forcing = ModelForcing(v=pressure_gradient_forcing); ). ## Set initial condition.; b₀(x, y, z) = N² * z; set!(model, b=b₀). ## A wizard for managing the simulation time-step.; wizard = TimeStepWizard(cfl=0.2, Δt=1.0, max_change=1.1, max_Δt=90.0); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/579
https://github.com/CliMA/Oceananigans.jl/issues/579:493,Usability,Simpl,SimpleForcing,493,"I'm trying to code a simple 2D channel model in v0.17.0 where the periodic dimension is the flat dimension. I keep experiencing seemingly spontaneous velocity blowup during spin-up despite changing parameters/removing most forcing. Here is an example:. ```; Nx = 1; Ny = 256; Nz = 32; Lx = 1000e3; Ly = 1000e3; Lz = 4e3; N² = 1e-5; Δp = 1e-5 #will set to be a function of y; end_time = 1day. # ## Define a forcing function; pressure_gradient(x, y, z, t) = Δp / Lx; pressure_gradient_forcing = SimpleForcing(pressure_gradient). ## Instantiate the model; model = ChannelModel(; grid = RegularCartesianGrid(size = (Nx, Ny, Nz), x = (0, Lx), y = (-Ly/2, Ly/2), z=(-Lz, 0)),; closure = ConstantIsotropicDiffusivity(ν=100, κ=100),; coriolis = FPlane(f=1e-5),; tracers = (:b,),; buoyancy = BuoyancyTracer(),; forcing = ModelForcing(v=pressure_gradient_forcing); ). ## Set initial condition.; b₀(x, y, z) = N² * z; set!(model, b=b₀). ## A wizard for managing the simulation time-step.; wizard = TimeStepWizard(cfl=0.2, Δt=1.0, max_change=1.1, max_Δt=90.0); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/579
https://github.com/CliMA/Oceananigans.jl/issues/582:118,Modifiability,refactor,refactoring,118,"Could lead to confusion, e.g. in #579. Thanks for helping locate this issue @masonrogers14. Easy PR but might involve refactoring some tests?. https://github.com/climate-machine/Oceananigans.jl/blob/588890004e69cfc7db10472b12a9840b8a9ad7b6/src/boundary_conditions.jl#L339",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/582
https://github.com/CliMA/Oceananigans.jl/issues/582:135,Testability,test,tests,135,"Could lead to confusion, e.g. in #579. Thanks for helping locate this issue @masonrogers14. Easy PR but might involve refactoring some tests?. https://github.com/climate-machine/Oceananigans.jl/blob/588890004e69cfc7db10472b12a9840b8a9ad7b6/src/boundary_conditions.jl#L339",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/582
https://github.com/CliMA/Oceananigans.jl/pull/585:16,Deployability,Update,Updates,16,Resolves #578 ; Updates runtests to use the ModelLogger; Updates tests to use @info instead of println,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/585
https://github.com/CliMA/Oceananigans.jl/pull/585:57,Deployability,Update,Updates,57,Resolves #578 ; Updates runtests to use the ModelLogger; Updates tests to use @info instead of println,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/585
https://github.com/CliMA/Oceananigans.jl/pull/585:65,Testability,test,tests,65,Resolves #578 ; Updates runtests to use the ModelLogger; Updates tests to use @info instead of println,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/585
https://github.com/CliMA/Oceananigans.jl/issues/586:580,Availability,down,down,580,"Implementing a vertically stretched grid (see PR #543) involves adding new Poisson solvers. This offers us a chance to:; 1. refactor the Poisson solvers into a more flexible API,; 2. support triply periodic and 3D box domains,; 3. unite some of the CPU and GPU Poisson solvers,; 4. reuse the Poisson solvers to implicitly time-step diffusion (vertically and possibly in 3D) in the future, and; 5. slide in (or dispatch on) a distributed pressure solve for distributed/MPI models without having to modify the time stepping code for regular models in the future. I am just throwing down some notes and ideas in this issue. This table summarizes the different boundary conditions and grids we may want to simulate, and the Poisson solver algorithm we would need. | Boundary conditions | Grid | Solver | Alternatives |; |----------------------|-----------------------|:-----------:|:-------------:|; | Triply periodic | Regular | FFT³ | |; | | Vertically stretched | FFT²×TRI? | |; | Doubly periodic | Regular | FFT²×TRI | FFT²×DCT |; | | Vertically stretched | FFT²×TRI | |; | Channel | Regular | FFT×DCT×TRI | FFT²×DCT |; | | Vertically stretched | FFT×DCT×TRI | |; | Box | Regular | DCT²×TRI | DCT³ |; | | Vertically stretched | DCT²×TRI | |. Essentially we need an FFT for periodic dimensions and we have the choice of using either a DCT or a TRIdiagonal solve for wall-bounded dimensions, although TRI may only be used once. . Some notes:; 1. Multiple wall-bounded dimensions will require the use of a DCT somewhere.; 2. Solvers for vertically stretched grids need to use TRI in the vertical.; 3. For stretched grids in multiple dimensions I believe that a direct solve is no longer possible and an iterative method such as conjugate gradient must be used. I do not consider this case.; 4. We have the option of using a DCT or a TRI. Which one we pick will depend on performance benchmarks between the two solvers. We should pick the faster one. This could depend on the number of vertical levels.; 5",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/586
https://github.com/CliMA/Oceananigans.jl/issues/586:2199,Energy Efficiency,efficient,efficient,2199,"|; | Doubly periodic | Regular | FFT²×TRI | FFT²×DCT |; | | Vertically stretched | FFT²×TRI | |; | Channel | Regular | FFT×DCT×TRI | FFT²×DCT |; | | Vertically stretched | FFT×DCT×TRI | |; | Box | Regular | DCT²×TRI | DCT³ |; | | Vertically stretched | DCT²×TRI | |. Essentially we need an FFT for periodic dimensions and we have the choice of using either a DCT or a TRIdiagonal solve for wall-bounded dimensions, although TRI may only be used once. . Some notes:; 1. Multiple wall-bounded dimensions will require the use of a DCT somewhere.; 2. Solvers for vertically stretched grids need to use TRI in the vertical.; 3. For stretched grids in multiple dimensions I believe that a direct solve is no longer possible and an iterative method such as conjugate gradient must be used. I do not consider this case.; 4. We have the option of using a DCT or a TRI. Which one we pick will depend on performance benchmarks between the two solvers. We should pick the faster one. This could depend on the number of vertical levels.; 5. Unfortunately I don't think we can get rid of the in-place DCT algorithm that employs permutations on the GPU as it will be needed for channels and boxes at least. It may also turn out to be more efficient for regular grids in some cases.; 6. We should reuse solvers as much as possible.; 7. While it looks like we have many solvers to implement, I think if we abstract away the steps then each solver just needs to implement something like a `forward_x_transform`, `forward_y_transform`, `forward_z_transform`, `backward_z_transform`, etc. then we can implement many solvers without repeating code. For now, I will first just focus on getting Poisson solvers working for vertically stretched grids in doubly periodic domains on the CPU and GPU. This will offer a chance to do some refactoring and benchmarking. We also need to try out faster tridiagonal matrix algorithms. But I'd like to keep the five initial goals in mind. This issue will probably be open for a while.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/586
https://github.com/CliMA/Oceananigans.jl/issues/586:1858,Integrability,depend,depend,1858,"--:|:-------------:|; | Triply periodic | Regular | FFT³ | |; | | Vertically stretched | FFT²×TRI? | |; | Doubly periodic | Regular | FFT²×TRI | FFT²×DCT |; | | Vertically stretched | FFT²×TRI | |; | Channel | Regular | FFT×DCT×TRI | FFT²×DCT |; | | Vertically stretched | FFT×DCT×TRI | |; | Box | Regular | DCT²×TRI | DCT³ |; | | Vertically stretched | DCT²×TRI | |. Essentially we need an FFT for periodic dimensions and we have the choice of using either a DCT or a TRIdiagonal solve for wall-bounded dimensions, although TRI may only be used once. . Some notes:; 1. Multiple wall-bounded dimensions will require the use of a DCT somewhere.; 2. Solvers for vertically stretched grids need to use TRI in the vertical.; 3. For stretched grids in multiple dimensions I believe that a direct solve is no longer possible and an iterative method such as conjugate gradient must be used. I do not consider this case.; 4. We have the option of using a DCT or a TRI. Which one we pick will depend on performance benchmarks between the two solvers. We should pick the faster one. This could depend on the number of vertical levels.; 5. Unfortunately I don't think we can get rid of the in-place DCT algorithm that employs permutations on the GPU as it will be needed for channels and boxes at least. It may also turn out to be more efficient for regular grids in some cases.; 6. We should reuse solvers as much as possible.; 7. While it looks like we have many solvers to implement, I think if we abstract away the steps then each solver just needs to implement something like a `forward_x_transform`, `forward_y_transform`, `forward_z_transform`, `backward_z_transform`, etc. then we can implement many solvers without repeating code. For now, I will first just focus on getting Poisson solvers working for vertically stretched grids in doubly periodic domains on the CPU and GPU. This will offer a chance to do some refactoring and benchmarking. We also need to try out faster tridiagonal matrix algorithms",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/586
https://github.com/CliMA/Oceananigans.jl/issues/586:1958,Integrability,depend,depend,1958," | |; | Doubly periodic | Regular | FFT²×TRI | FFT²×DCT |; | | Vertically stretched | FFT²×TRI | |; | Channel | Regular | FFT×DCT×TRI | FFT²×DCT |; | | Vertically stretched | FFT×DCT×TRI | |; | Box | Regular | DCT²×TRI | DCT³ |; | | Vertically stretched | DCT²×TRI | |. Essentially we need an FFT for periodic dimensions and we have the choice of using either a DCT or a TRIdiagonal solve for wall-bounded dimensions, although TRI may only be used once. . Some notes:; 1. Multiple wall-bounded dimensions will require the use of a DCT somewhere.; 2. Solvers for vertically stretched grids need to use TRI in the vertical.; 3. For stretched grids in multiple dimensions I believe that a direct solve is no longer possible and an iterative method such as conjugate gradient must be used. I do not consider this case.; 4. We have the option of using a DCT or a TRI. Which one we pick will depend on performance benchmarks between the two solvers. We should pick the faster one. This could depend on the number of vertical levels.; 5. Unfortunately I don't think we can get rid of the in-place DCT algorithm that employs permutations on the GPU as it will be needed for channels and boxes at least. It may also turn out to be more efficient for regular grids in some cases.; 6. We should reuse solvers as much as possible.; 7. While it looks like we have many solvers to implement, I think if we abstract away the steps then each solver just needs to implement something like a `forward_x_transform`, `forward_y_transform`, `forward_z_transform`, `backward_z_transform`, etc. then we can implement many solvers without repeating code. For now, I will first just focus on getting Poisson solvers working for vertically stretched grids in doubly periodic domains on the CPU and GPU. This will offer a chance to do some refactoring and benchmarking. We also need to try out faster tridiagonal matrix algorithms. But I'd like to keep the five initial goals in mind. This issue will probably be open for a whi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/586
https://github.com/CliMA/Oceananigans.jl/issues/586:124,Modifiability,refactor,refactor,124,"Implementing a vertically stretched grid (see PR #543) involves adding new Poisson solvers. This offers us a chance to:; 1. refactor the Poisson solvers into a more flexible API,; 2. support triply periodic and 3D box domains,; 3. unite some of the CPU and GPU Poisson solvers,; 4. reuse the Poisson solvers to implicitly time-step diffusion (vertically and possibly in 3D) in the future, and; 5. slide in (or dispatch on) a distributed pressure solve for distributed/MPI models without having to modify the time stepping code for regular models in the future. I am just throwing down some notes and ideas in this issue. This table summarizes the different boundary conditions and grids we may want to simulate, and the Poisson solver algorithm we would need. | Boundary conditions | Grid | Solver | Alternatives |; |----------------------|-----------------------|:-----------:|:-------------:|; | Triply periodic | Regular | FFT³ | |; | | Vertically stretched | FFT²×TRI? | |; | Doubly periodic | Regular | FFT²×TRI | FFT²×DCT |; | | Vertically stretched | FFT²×TRI | |; | Channel | Regular | FFT×DCT×TRI | FFT²×DCT |; | | Vertically stretched | FFT×DCT×TRI | |; | Box | Regular | DCT²×TRI | DCT³ |; | | Vertically stretched | DCT²×TRI | |. Essentially we need an FFT for periodic dimensions and we have the choice of using either a DCT or a TRIdiagonal solve for wall-bounded dimensions, although TRI may only be used once. . Some notes:; 1. Multiple wall-bounded dimensions will require the use of a DCT somewhere.; 2. Solvers for vertically stretched grids need to use TRI in the vertical.; 3. For stretched grids in multiple dimensions I believe that a direct solve is no longer possible and an iterative method such as conjugate gradient must be used. I do not consider this case.; 4. We have the option of using a DCT or a TRI. Which one we pick will depend on performance benchmarks between the two solvers. We should pick the faster one. This could depend on the number of vertical levels.; 5",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/586
https://github.com/CliMA/Oceananigans.jl/issues/586:165,Modifiability,flexible,flexible,165,"Implementing a vertically stretched grid (see PR #543) involves adding new Poisson solvers. This offers us a chance to:; 1. refactor the Poisson solvers into a more flexible API,; 2. support triply periodic and 3D box domains,; 3. unite some of the CPU and GPU Poisson solvers,; 4. reuse the Poisson solvers to implicitly time-step diffusion (vertically and possibly in 3D) in the future, and; 5. slide in (or dispatch on) a distributed pressure solve for distributed/MPI models without having to modify the time stepping code for regular models in the future. I am just throwing down some notes and ideas in this issue. This table summarizes the different boundary conditions and grids we may want to simulate, and the Poisson solver algorithm we would need. | Boundary conditions | Grid | Solver | Alternatives |; |----------------------|-----------------------|:-----------:|:-------------:|; | Triply periodic | Regular | FFT³ | |; | | Vertically stretched | FFT²×TRI? | |; | Doubly periodic | Regular | FFT²×TRI | FFT²×DCT |; | | Vertically stretched | FFT²×TRI | |; | Channel | Regular | FFT×DCT×TRI | FFT²×DCT |; | | Vertically stretched | FFT×DCT×TRI | |; | Box | Regular | DCT²×TRI | DCT³ |; | | Vertically stretched | DCT²×TRI | |. Essentially we need an FFT for periodic dimensions and we have the choice of using either a DCT or a TRIdiagonal solve for wall-bounded dimensions, although TRI may only be used once. . Some notes:; 1. Multiple wall-bounded dimensions will require the use of a DCT somewhere.; 2. Solvers for vertically stretched grids need to use TRI in the vertical.; 3. For stretched grids in multiple dimensions I believe that a direct solve is no longer possible and an iterative method such as conjugate gradient must be used. I do not consider this case.; 4. We have the option of using a DCT or a TRI. Which one we pick will depend on performance benchmarks between the two solvers. We should pick the faster one. This could depend on the number of vertical levels.; 5",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/586
https://github.com/CliMA/Oceananigans.jl/issues/586:2785,Modifiability,refactor,refactoring,2785,"|; | Doubly periodic | Regular | FFT²×TRI | FFT²×DCT |; | | Vertically stretched | FFT²×TRI | |; | Channel | Regular | FFT×DCT×TRI | FFT²×DCT |; | | Vertically stretched | FFT×DCT×TRI | |; | Box | Regular | DCT²×TRI | DCT³ |; | | Vertically stretched | DCT²×TRI | |. Essentially we need an FFT for periodic dimensions and we have the choice of using either a DCT or a TRIdiagonal solve for wall-bounded dimensions, although TRI may only be used once. . Some notes:; 1. Multiple wall-bounded dimensions will require the use of a DCT somewhere.; 2. Solvers for vertically stretched grids need to use TRI in the vertical.; 3. For stretched grids in multiple dimensions I believe that a direct solve is no longer possible and an iterative method such as conjugate gradient must be used. I do not consider this case.; 4. We have the option of using a DCT or a TRI. Which one we pick will depend on performance benchmarks between the two solvers. We should pick the faster one. This could depend on the number of vertical levels.; 5. Unfortunately I don't think we can get rid of the in-place DCT algorithm that employs permutations on the GPU as it will be needed for channels and boxes at least. It may also turn out to be more efficient for regular grids in some cases.; 6. We should reuse solvers as much as possible.; 7. While it looks like we have many solvers to implement, I think if we abstract away the steps then each solver just needs to implement something like a `forward_x_transform`, `forward_y_transform`, `forward_z_transform`, `backward_z_transform`, etc. then we can implement many solvers without repeating code. For now, I will first just focus on getting Poisson solvers working for vertically stretched grids in doubly periodic domains on the CPU and GPU. This will offer a chance to do some refactoring and benchmarking. We also need to try out faster tridiagonal matrix algorithms. But I'd like to keep the five initial goals in mind. This issue will probably be open for a while.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/586
https://github.com/CliMA/Oceananigans.jl/issues/586:1868,Performance,perform,performance,1868,"--:|:-------------:|; | Triply periodic | Regular | FFT³ | |; | | Vertically stretched | FFT²×TRI? | |; | Doubly periodic | Regular | FFT²×TRI | FFT²×DCT |; | | Vertically stretched | FFT²×TRI | |; | Channel | Regular | FFT×DCT×TRI | FFT²×DCT |; | | Vertically stretched | FFT×DCT×TRI | |; | Box | Regular | DCT²×TRI | DCT³ |; | | Vertically stretched | DCT²×TRI | |. Essentially we need an FFT for periodic dimensions and we have the choice of using either a DCT or a TRIdiagonal solve for wall-bounded dimensions, although TRI may only be used once. . Some notes:; 1. Multiple wall-bounded dimensions will require the use of a DCT somewhere.; 2. Solvers for vertically stretched grids need to use TRI in the vertical.; 3. For stretched grids in multiple dimensions I believe that a direct solve is no longer possible and an iterative method such as conjugate gradient must be used. I do not consider this case.; 4. We have the option of using a DCT or a TRI. Which one we pick will depend on performance benchmarks between the two solvers. We should pick the faster one. This could depend on the number of vertical levels.; 5. Unfortunately I don't think we can get rid of the in-place DCT algorithm that employs permutations on the GPU as it will be needed for channels and boxes at least. It may also turn out to be more efficient for regular grids in some cases.; 6. We should reuse solvers as much as possible.; 7. While it looks like we have many solvers to implement, I think if we abstract away the steps then each solver just needs to implement something like a `forward_x_transform`, `forward_y_transform`, `forward_z_transform`, `backward_z_transform`, etc. then we can implement many solvers without repeating code. For now, I will first just focus on getting Poisson solvers working for vertically stretched grids in doubly periodic domains on the CPU and GPU. This will offer a chance to do some refactoring and benchmarking. We also need to try out faster tridiagonal matrix algorithms",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/586
https://github.com/CliMA/Oceananigans.jl/issues/586:1880,Testability,benchmark,benchmarks,1880,"--:|:-------------:|; | Triply periodic | Regular | FFT³ | |; | | Vertically stretched | FFT²×TRI? | |; | Doubly periodic | Regular | FFT²×TRI | FFT²×DCT |; | | Vertically stretched | FFT²×TRI | |; | Channel | Regular | FFT×DCT×TRI | FFT²×DCT |; | | Vertically stretched | FFT×DCT×TRI | |; | Box | Regular | DCT²×TRI | DCT³ |; | | Vertically stretched | DCT²×TRI | |. Essentially we need an FFT for periodic dimensions and we have the choice of using either a DCT or a TRIdiagonal solve for wall-bounded dimensions, although TRI may only be used once. . Some notes:; 1. Multiple wall-bounded dimensions will require the use of a DCT somewhere.; 2. Solvers for vertically stretched grids need to use TRI in the vertical.; 3. For stretched grids in multiple dimensions I believe that a direct solve is no longer possible and an iterative method such as conjugate gradient must be used. I do not consider this case.; 4. We have the option of using a DCT or a TRI. Which one we pick will depend on performance benchmarks between the two solvers. We should pick the faster one. This could depend on the number of vertical levels.; 5. Unfortunately I don't think we can get rid of the in-place DCT algorithm that employs permutations on the GPU as it will be needed for channels and boxes at least. It may also turn out to be more efficient for regular grids in some cases.; 6. We should reuse solvers as much as possible.; 7. While it looks like we have many solvers to implement, I think if we abstract away the steps then each solver just needs to implement something like a `forward_x_transform`, `forward_y_transform`, `forward_z_transform`, `backward_z_transform`, etc. then we can implement many solvers without repeating code. For now, I will first just focus on getting Poisson solvers working for vertically stretched grids in doubly periodic domains on the CPU and GPU. This will offer a chance to do some refactoring and benchmarking. We also need to try out faster tridiagonal matrix algorithms",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/586
https://github.com/CliMA/Oceananigans.jl/issues/586:2801,Testability,benchmark,benchmarking,2801,"|; | Doubly periodic | Regular | FFT²×TRI | FFT²×DCT |; | | Vertically stretched | FFT²×TRI | |; | Channel | Regular | FFT×DCT×TRI | FFT²×DCT |; | | Vertically stretched | FFT×DCT×TRI | |; | Box | Regular | DCT²×TRI | DCT³ |; | | Vertically stretched | DCT²×TRI | |. Essentially we need an FFT for periodic dimensions and we have the choice of using either a DCT or a TRIdiagonal solve for wall-bounded dimensions, although TRI may only be used once. . Some notes:; 1. Multiple wall-bounded dimensions will require the use of a DCT somewhere.; 2. Solvers for vertically stretched grids need to use TRI in the vertical.; 3. For stretched grids in multiple dimensions I believe that a direct solve is no longer possible and an iterative method such as conjugate gradient must be used. I do not consider this case.; 4. We have the option of using a DCT or a TRI. Which one we pick will depend on performance benchmarks between the two solvers. We should pick the faster one. This could depend on the number of vertical levels.; 5. Unfortunately I don't think we can get rid of the in-place DCT algorithm that employs permutations on the GPU as it will be needed for channels and boxes at least. It may also turn out to be more efficient for regular grids in some cases.; 6. We should reuse solvers as much as possible.; 7. While it looks like we have many solvers to implement, I think if we abstract away the steps then each solver just needs to implement something like a `forward_x_transform`, `forward_y_transform`, `forward_z_transform`, `backward_z_transform`, etc. then we can implement many solvers without repeating code. For now, I will first just focus on getting Poisson solvers working for vertically stretched grids in doubly periodic domains on the CPU and GPU. This will offer a chance to do some refactoring and benchmarking. We also need to try out faster tridiagonal matrix algorithms. But I'd like to keep the five initial goals in mind. This issue will probably be open for a while.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/586
https://github.com/CliMA/Oceananigans.jl/issues/587:186,Modifiability,refactor,refactoring,186,Is this something we want to implement in the future? Would 3D implicit diffusion be useful or just vertically implicit?. I ask because if so it might influence some choices I make when refactoring the Poisson solvers. Vertically implicit diffusion can be implemented with just the `BatchedTridiagonalSolver`. For 3D implicit diffusion I believe we can do a Poisson solve similar to what we do for the pressure but I haven't worked out the math in 3D. It's probably not needed for boundary layer turbulence LES but maybe vertically implicit would be useful for mesoscale simulations?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/587
https://github.com/CliMA/Oceananigans.jl/pull/589:267,Modifiability,refactor,refactors,267,"This PR is a stab at implementing the pressure solvers plan/overhaul outlined in #586. So far it implements pressure solvers for all types of domains (triply/doubly periodic, channels, and boxes) on regular grids (except boxes on GPUs for now). Equally important, it refactors and cleans up the pressure solvers so that we can now easily add in pressure solvers for vertically stretched grids and distributed models. A lot of cleanup was done in the process as well. Pressure solver code and kernels have been fully moved from the `TimeSteppers` submodule to the `Solvers` submodule. Different parts have been reorganized into multiple files and the index permutation business has been abstracted away a bit so we have fewer ugly kernels (and fewer kernels!). I could have gone much further in condensing the code base and number of pressure solvers. You'll notice quite a bit of code repetition, but I think for now and the forseeable future this is actually a good thing. The pressure solver code is nontrivial and keeping it as simple as possible will improve the readability and longevity of the code base. It's also easier to add and modify pressure solvers now. For example, if @sandreza wants to implement a fast pressure solve that only works for horizontally periodic domains (Kleiser-Schumann?), it's now much easier to do that. I should probably add some benchmarks.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/589
https://github.com/CliMA/Oceananigans.jl/pull/589:1366,Testability,benchmark,benchmarks,1366,"This PR is a stab at implementing the pressure solvers plan/overhaul outlined in #586. So far it implements pressure solvers for all types of domains (triply/doubly periodic, channels, and boxes) on regular grids (except boxes on GPUs for now). Equally important, it refactors and cleans up the pressure solvers so that we can now easily add in pressure solvers for vertically stretched grids and distributed models. A lot of cleanup was done in the process as well. Pressure solver code and kernels have been fully moved from the `TimeSteppers` submodule to the `Solvers` submodule. Different parts have been reorganized into multiple files and the index permutation business has been abstracted away a bit so we have fewer ugly kernels (and fewer kernels!). I could have gone much further in condensing the code base and number of pressure solvers. You'll notice quite a bit of code repetition, but I think for now and the forseeable future this is actually a good thing. The pressure solver code is nontrivial and keeping it as simple as possible will improve the readability and longevity of the code base. It's also easier to add and modify pressure solvers now. For example, if @sandreza wants to implement a fast pressure solve that only works for horizontally periodic domains (Kleiser-Schumann?), it's now much easier to do that. I should probably add some benchmarks.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/589
https://github.com/CliMA/Oceananigans.jl/pull/589:1031,Usability,simpl,simple,1031,"This PR is a stab at implementing the pressure solvers plan/overhaul outlined in #586. So far it implements pressure solvers for all types of domains (triply/doubly periodic, channels, and boxes) on regular grids (except boxes on GPUs for now). Equally important, it refactors and cleans up the pressure solvers so that we can now easily add in pressure solvers for vertically stretched grids and distributed models. A lot of cleanup was done in the process as well. Pressure solver code and kernels have been fully moved from the `TimeSteppers` submodule to the `Solvers` submodule. Different parts have been reorganized into multiple files and the index permutation business has been abstracted away a bit so we have fewer ugly kernels (and fewer kernels!). I could have gone much further in condensing the code base and number of pressure solvers. You'll notice quite a bit of code repetition, but I think for now and the forseeable future this is actually a good thing. The pressure solver code is nontrivial and keeping it as simple as possible will improve the readability and longevity of the code base. It's also easier to add and modify pressure solvers now. For example, if @sandreza wants to implement a fast pressure solve that only works for horizontally periodic domains (Kleiser-Schumann?), it's now much easier to do that. I should probably add some benchmarks.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/589
https://github.com/CliMA/Oceananigans.jl/pull/590:2422,Energy Efficiency,allocate,allocate,2422,"e base making it easier to maintain, and there will be a very clear boundary between ""core Oceananigans"" and ""distributed parallelism functionality"" which I think will serve us well in the future as MPI seems to permeate deeply into other codes, making them hard to modify. The big thing that is missing is of course the distributed pressure solver, the hard thing to implement. This is where [DistributedTranspose.jl](https://github.com/leios/DistributedTranspose.jl) will come in handy. I also recently found [PencilFFTs.jl](https://github.com/jipolanco/PencilFFTs.jl) which also looks interesting. cc @leios. For testing purposes, I'm tempted to do the pressure solve via an `MPI.Gather` onto rank 0 where it can be solved locally then an `MPI.Scatter` to pass the pressure to all ranks. Super inefficient but might be good to ensure that the `DistributedModel` can reproduce existing regression tests. Performance issues:; * Right now `MPI.Isend`, `MPI.Recv!`, and `MPI.SendRecv!` all expect send and receive buffers to be contiguous in memory I believe. To get around this I allocate memory for these buffers, but this is definitely not performant. @vchuravy suggested that we may be able to send and receive into strided buffers, so will look into this. cc @simonbyrne maybe you know more about this?. Quality of life features we may want in the future (which might effect design choices):; * Distributed diagnostics: these will be pretty expensive no matter how we implement them due to the extra reduction step (`MPI.Gather`) required across all ranks. I wonder if it's even worth thinking about them much. If we really need things like a `DistributedHorizontalAverage` then we can look into that.; * Distributed output writers: I wonder if we should add e.g. a distributed NetCDF output writer or if each rank just writes out its own output and we have a utility function that post-processes the output files and merges them at the end (this seems easier than writing another output writer).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590
https://github.com/CliMA/Oceananigans.jl/pull/590:49,Integrability,interface,interface,49,"This PR takes a stab at designing a non-invasive interface to running Oceananigans on multiple CPUs and GPUs, i.e. distributed parallelism with MPI. By non-invasive I mean that no existing code will have to change. It may not be the best solution but I really like it and I'm hoping we can discuss this design. I see no reason why it won't perform well. Vision of this PR:; 1. Oceananigans core code base wil be free of MPI and uses GPUifyLoops.jl as it already does so nothing changes there.; 2. Everything needed for distributed parallelism will live in the `Oceananigans.Distributed` submodule.; 3. Support for x, y, and z decompositions. In practice, choice of pressure solver may limit which decomposition we can use but they're all supported right now.; 4. Each rank will time step it's own submodel communicating with its neighbors as needed, i.e. in `fill_halo_regions!`. There is no ""master rank"".; 5. Halo communication is implemented by injecting `HaloCommunication` boundary conditions wherever a submodel shares a halo with another rank. This is then dispatched on so no need to modify existing code.; 6. With PR #589 we will be able to easily slide in a `DistributedPressureSolver` struct that can be used to dispatch on `solve_for_pressure!`. So again, no need to modify existing code. This way MPI does not invade the core code base making it easier to maintain, and there will be a very clear boundary between ""core Oceananigans"" and ""distributed parallelism functionality"" which I think will serve us well in the future as MPI seems to permeate deeply into other codes, making them hard to modify. The big thing that is missing is of course the distributed pressure solver, the hard thing to implement. This is where [DistributedTranspose.jl](https://github.com/leios/DistributedTranspose.jl) will come in handy. I also recently found [PencilFFTs.jl](https://github.com/jipolanco/PencilFFTs.jl) which also looks interesting. cc @leios. For testing purposes, I'm tempted to do the pre",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590
https://github.com/CliMA/Oceananigans.jl/pull/590:948,Integrability,inject,injecting,948,"This PR takes a stab at designing a non-invasive interface to running Oceananigans on multiple CPUs and GPUs, i.e. distributed parallelism with MPI. By non-invasive I mean that no existing code will have to change. It may not be the best solution but I really like it and I'm hoping we can discuss this design. I see no reason why it won't perform well. Vision of this PR:; 1. Oceananigans core code base wil be free of MPI and uses GPUifyLoops.jl as it already does so nothing changes there.; 2. Everything needed for distributed parallelism will live in the `Oceananigans.Distributed` submodule.; 3. Support for x, y, and z decompositions. In practice, choice of pressure solver may limit which decomposition we can use but they're all supported right now.; 4. Each rank will time step it's own submodel communicating with its neighbors as needed, i.e. in `fill_halo_regions!`. There is no ""master rank"".; 5. Halo communication is implemented by injecting `HaloCommunication` boundary conditions wherever a submodel shares a halo with another rank. This is then dispatched on so no need to modify existing code.; 6. With PR #589 we will be able to easily slide in a `DistributedPressureSolver` struct that can be used to dispatch on `solve_for_pressure!`. So again, no need to modify existing code. This way MPI does not invade the core code base making it easier to maintain, and there will be a very clear boundary between ""core Oceananigans"" and ""distributed parallelism functionality"" which I think will serve us well in the future as MPI seems to permeate deeply into other codes, making them hard to modify. The big thing that is missing is of course the distributed pressure solver, the hard thing to implement. This is where [DistributedTranspose.jl](https://github.com/leios/DistributedTranspose.jl) will come in handy. I also recently found [PencilFFTs.jl](https://github.com/jipolanco/PencilFFTs.jl) which also looks interesting. cc @leios. For testing purposes, I'm tempted to do the pre",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590
https://github.com/CliMA/Oceananigans.jl/pull/590:340,Performance,perform,perform,340,"This PR takes a stab at designing a non-invasive interface to running Oceananigans on multiple CPUs and GPUs, i.e. distributed parallelism with MPI. By non-invasive I mean that no existing code will have to change. It may not be the best solution but I really like it and I'm hoping we can discuss this design. I see no reason why it won't perform well. Vision of this PR:; 1. Oceananigans core code base wil be free of MPI and uses GPUifyLoops.jl as it already does so nothing changes there.; 2. Everything needed for distributed parallelism will live in the `Oceananigans.Distributed` submodule.; 3. Support for x, y, and z decompositions. In practice, choice of pressure solver may limit which decomposition we can use but they're all supported right now.; 4. Each rank will time step it's own submodel communicating with its neighbors as needed, i.e. in `fill_halo_regions!`. There is no ""master rank"".; 5. Halo communication is implemented by injecting `HaloCommunication` boundary conditions wherever a submodel shares a halo with another rank. This is then dispatched on so no need to modify existing code.; 6. With PR #589 we will be able to easily slide in a `DistributedPressureSolver` struct that can be used to dispatch on `solve_for_pressure!`. So again, no need to modify existing code. This way MPI does not invade the core code base making it easier to maintain, and there will be a very clear boundary between ""core Oceananigans"" and ""distributed parallelism functionality"" which I think will serve us well in the future as MPI seems to permeate deeply into other codes, making them hard to modify. The big thing that is missing is of course the distributed pressure solver, the hard thing to implement. This is where [DistributedTranspose.jl](https://github.com/leios/DistributedTranspose.jl) will come in handy. I also recently found [PencilFFTs.jl](https://github.com/jipolanco/PencilFFTs.jl) which also looks interesting. cc @leios. For testing purposes, I'm tempted to do the pre",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590
https://github.com/CliMA/Oceananigans.jl/pull/590:2248,Performance,Perform,Performance,2248,", no need to modify existing code. This way MPI does not invade the core code base making it easier to maintain, and there will be a very clear boundary between ""core Oceananigans"" and ""distributed parallelism functionality"" which I think will serve us well in the future as MPI seems to permeate deeply into other codes, making them hard to modify. The big thing that is missing is of course the distributed pressure solver, the hard thing to implement. This is where [DistributedTranspose.jl](https://github.com/leios/DistributedTranspose.jl) will come in handy. I also recently found [PencilFFTs.jl](https://github.com/jipolanco/PencilFFTs.jl) which also looks interesting. cc @leios. For testing purposes, I'm tempted to do the pressure solve via an `MPI.Gather` onto rank 0 where it can be solved locally then an `MPI.Scatter` to pass the pressure to all ranks. Super inefficient but might be good to ensure that the `DistributedModel` can reproduce existing regression tests. Performance issues:; * Right now `MPI.Isend`, `MPI.Recv!`, and `MPI.SendRecv!` all expect send and receive buffers to be contiguous in memory I believe. To get around this I allocate memory for these buffers, but this is definitely not performant. @vchuravy suggested that we may be able to send and receive into strided buffers, so will look into this. cc @simonbyrne maybe you know more about this?. Quality of life features we may want in the future (which might effect design choices):; * Distributed diagnostics: these will be pretty expensive no matter how we implement them due to the extra reduction step (`MPI.Gather`) required across all ranks. I wonder if it's even worth thinking about them much. If we really need things like a `DistributedHorizontalAverage` then we can look into that.; * Distributed output writers: I wonder if we should add e.g. a distributed NetCDF output writer or if each rank just writes out its own output and we have a utility function that post-processes the output files and mer",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590
https://github.com/CliMA/Oceananigans.jl/pull/590:2484,Performance,perform,performant,2484,"e base making it easier to maintain, and there will be a very clear boundary between ""core Oceananigans"" and ""distributed parallelism functionality"" which I think will serve us well in the future as MPI seems to permeate deeply into other codes, making them hard to modify. The big thing that is missing is of course the distributed pressure solver, the hard thing to implement. This is where [DistributedTranspose.jl](https://github.com/leios/DistributedTranspose.jl) will come in handy. I also recently found [PencilFFTs.jl](https://github.com/jipolanco/PencilFFTs.jl) which also looks interesting. cc @leios. For testing purposes, I'm tempted to do the pressure solve via an `MPI.Gather` onto rank 0 where it can be solved locally then an `MPI.Scatter` to pass the pressure to all ranks. Super inefficient but might be good to ensure that the `DistributedModel` can reproduce existing regression tests. Performance issues:; * Right now `MPI.Isend`, `MPI.Recv!`, and `MPI.SendRecv!` all expect send and receive buffers to be contiguous in memory I believe. To get around this I allocate memory for these buffers, but this is definitely not performant. @vchuravy suggested that we may be able to send and receive into strided buffers, so will look into this. cc @simonbyrne maybe you know more about this?. Quality of life features we may want in the future (which might effect design choices):; * Distributed diagnostics: these will be pretty expensive no matter how we implement them due to the extra reduction step (`MPI.Gather`) required across all ranks. I wonder if it's even worth thinking about them much. If we really need things like a `DistributedHorizontalAverage` then we can look into that.; * Distributed output writers: I wonder if we should add e.g. a distributed NetCDF output writer or if each rank just writes out its own output and we have a utility function that post-processes the output files and merges them at the end (this seems easier than writing another output writer).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590
https://github.com/CliMA/Oceananigans.jl/pull/590:948,Security,inject,injecting,948,"This PR takes a stab at designing a non-invasive interface to running Oceananigans on multiple CPUs and GPUs, i.e. distributed parallelism with MPI. By non-invasive I mean that no existing code will have to change. It may not be the best solution but I really like it and I'm hoping we can discuss this design. I see no reason why it won't perform well. Vision of this PR:; 1. Oceananigans core code base wil be free of MPI and uses GPUifyLoops.jl as it already does so nothing changes there.; 2. Everything needed for distributed parallelism will live in the `Oceananigans.Distributed` submodule.; 3. Support for x, y, and z decompositions. In practice, choice of pressure solver may limit which decomposition we can use but they're all supported right now.; 4. Each rank will time step it's own submodel communicating with its neighbors as needed, i.e. in `fill_halo_regions!`. There is no ""master rank"".; 5. Halo communication is implemented by injecting `HaloCommunication` boundary conditions wherever a submodel shares a halo with another rank. This is then dispatched on so no need to modify existing code.; 6. With PR #589 we will be able to easily slide in a `DistributedPressureSolver` struct that can be used to dispatch on `solve_for_pressure!`. So again, no need to modify existing code. This way MPI does not invade the core code base making it easier to maintain, and there will be a very clear boundary between ""core Oceananigans"" and ""distributed parallelism functionality"" which I think will serve us well in the future as MPI seems to permeate deeply into other codes, making them hard to modify. The big thing that is missing is of course the distributed pressure solver, the hard thing to implement. This is where [DistributedTranspose.jl](https://github.com/leios/DistributedTranspose.jl) will come in handy. I also recently found [PencilFFTs.jl](https://github.com/jipolanco/PencilFFTs.jl) which also looks interesting. cc @leios. For testing purposes, I'm tempted to do the pre",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590
https://github.com/CliMA/Oceananigans.jl/pull/590:1958,Testability,test,testing,1958,"nditions wherever a submodel shares a halo with another rank. This is then dispatched on so no need to modify existing code.; 6. With PR #589 we will be able to easily slide in a `DistributedPressureSolver` struct that can be used to dispatch on `solve_for_pressure!`. So again, no need to modify existing code. This way MPI does not invade the core code base making it easier to maintain, and there will be a very clear boundary between ""core Oceananigans"" and ""distributed parallelism functionality"" which I think will serve us well in the future as MPI seems to permeate deeply into other codes, making them hard to modify. The big thing that is missing is of course the distributed pressure solver, the hard thing to implement. This is where [DistributedTranspose.jl](https://github.com/leios/DistributedTranspose.jl) will come in handy. I also recently found [PencilFFTs.jl](https://github.com/jipolanco/PencilFFTs.jl) which also looks interesting. cc @leios. For testing purposes, I'm tempted to do the pressure solve via an `MPI.Gather` onto rank 0 where it can be solved locally then an `MPI.Scatter` to pass the pressure to all ranks. Super inefficient but might be good to ensure that the `DistributedModel` can reproduce existing regression tests. Performance issues:; * Right now `MPI.Isend`, `MPI.Recv!`, and `MPI.SendRecv!` all expect send and receive buffers to be contiguous in memory I believe. To get around this I allocate memory for these buffers, but this is definitely not performant. @vchuravy suggested that we may be able to send and receive into strided buffers, so will look into this. cc @simonbyrne maybe you know more about this?. Quality of life features we may want in the future (which might effect design choices):; * Distributed diagnostics: these will be pretty expensive no matter how we implement them due to the extra reduction step (`MPI.Gather`) required across all ranks. I wonder if it's even worth thinking about them much. If we really need things like a ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590
https://github.com/CliMA/Oceananigans.jl/pull/590:2241,Testability,test,tests,2241,"olver` struct that can be used to dispatch on `solve_for_pressure!`. So again, no need to modify existing code. This way MPI does not invade the core code base making it easier to maintain, and there will be a very clear boundary between ""core Oceananigans"" and ""distributed parallelism functionality"" which I think will serve us well in the future as MPI seems to permeate deeply into other codes, making them hard to modify. The big thing that is missing is of course the distributed pressure solver, the hard thing to implement. This is where [DistributedTranspose.jl](https://github.com/leios/DistributedTranspose.jl) will come in handy. I also recently found [PencilFFTs.jl](https://github.com/jipolanco/PencilFFTs.jl) which also looks interesting. cc @leios. For testing purposes, I'm tempted to do the pressure solve via an `MPI.Gather` onto rank 0 where it can be solved locally then an `MPI.Scatter` to pass the pressure to all ranks. Super inefficient but might be good to ensure that the `DistributedModel` can reproduce existing regression tests. Performance issues:; * Right now `MPI.Isend`, `MPI.Recv!`, and `MPI.SendRecv!` all expect send and receive buffers to be contiguous in memory I believe. To get around this I allocate memory for these buffers, but this is definitely not performant. @vchuravy suggested that we may be able to send and receive into strided buffers, so will look into this. cc @simonbyrne maybe you know more about this?. Quality of life features we may want in the future (which might effect design choices):; * Distributed diagnostics: these will be pretty expensive no matter how we implement them due to the extra reduction step (`MPI.Gather`) required across all ranks. I wonder if it's even worth thinking about them much. If we really need things like a `DistributedHorizontalAverage` then we can look into that.; * Distributed output writers: I wonder if we should add e.g. a distributed NetCDF output writer or if each rank just writes out its own outpu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590
https://github.com/CliMA/Oceananigans.jl/pull/590:1404,Usability,clear,clear,1404,"eady does so nothing changes there.; 2. Everything needed for distributed parallelism will live in the `Oceananigans.Distributed` submodule.; 3. Support for x, y, and z decompositions. In practice, choice of pressure solver may limit which decomposition we can use but they're all supported right now.; 4. Each rank will time step it's own submodel communicating with its neighbors as needed, i.e. in `fill_halo_regions!`. There is no ""master rank"".; 5. Halo communication is implemented by injecting `HaloCommunication` boundary conditions wherever a submodel shares a halo with another rank. This is then dispatched on so no need to modify existing code.; 6. With PR #589 we will be able to easily slide in a `DistributedPressureSolver` struct that can be used to dispatch on `solve_for_pressure!`. So again, no need to modify existing code. This way MPI does not invade the core code base making it easier to maintain, and there will be a very clear boundary between ""core Oceananigans"" and ""distributed parallelism functionality"" which I think will serve us well in the future as MPI seems to permeate deeply into other codes, making them hard to modify. The big thing that is missing is of course the distributed pressure solver, the hard thing to implement. This is where [DistributedTranspose.jl](https://github.com/leios/DistributedTranspose.jl) will come in handy. I also recently found [PencilFFTs.jl](https://github.com/jipolanco/PencilFFTs.jl) which also looks interesting. cc @leios. For testing purposes, I'm tempted to do the pressure solve via an `MPI.Gather` onto rank 0 where it can be solved locally then an `MPI.Scatter` to pass the pressure to all ranks. Super inefficient but might be good to ensure that the `DistributedModel` can reproduce existing regression tests. Performance issues:; * Right now `MPI.Isend`, `MPI.Recv!`, and `MPI.SendRecv!` all expect send and receive buffers to be contiguous in memory I believe. To get around this I allocate memory for these buffers, b",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590
https://github.com/CliMA/Oceananigans.jl/pull/591:66,Modifiability,refactor,refactored,66,"This PR felt so good!. The internal code base had to be massively refactored thus the size of this PR but I think it's taking the code base in the right direction with submodules for everything, and will make implementing big new features (like vertically stretched grid and MPI) much easier and cleaner. There were a few breaking changes, e.g. `Face` and `Cell` moving to `Oceananigans.Fields`. In particular, Oceananigans does not export `day`, `minute`, `second`, and `hour` anymore as they conflict with the `Dates` module used by the logger. And it might also confuse users as to why Oceananigans is exporting these common names. They are now exported by `Oceananigans.Utils`. But otherwise, the impact to user scripts is pretty minimal (the examples barely changed). This should be merged as the next PR ASAP as merging anything else in will probably create some form of merge conflict hell. Resolves #456; Resolves #495; Resolves #497; Resolves #563",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/591
https://github.com/CliMA/Oceananigans.jl/pull/591:539,Testability,log,logger,539,"This PR felt so good!. The internal code base had to be massively refactored thus the size of this PR but I think it's taking the code base in the right direction with submodules for everything, and will make implementing big new features (like vertically stretched grid and MPI) much easier and cleaner. There were a few breaking changes, e.g. `Face` and `Cell` moving to `Oceananigans.Fields`. In particular, Oceananigans does not export `day`, `minute`, `second`, and `hour` anymore as they conflict with the `Dates` module used by the logger. And it might also confuse users as to why Oceananigans is exporting these common names. They are now exported by `Oceananigans.Utils`. But otherwise, the impact to user scripts is pretty minimal (the examples barely changed). This should be merged as the next PR ASAP as merging anything else in will probably create some form of merge conflict hell. Resolves #456; Resolves #495; Resolves #497; Resolves #563",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/591
https://github.com/CliMA/Oceananigans.jl/pull/592:901,Deployability,integrat,integrate,901,"This is finishing up some work I started last October on getting a WENO-5 tracer advection scheme working in Julia. Thanks @RaphaelRR for helping with the WENO-5 advection scheme!. This PR adds a 1D advection verification experiment to start exploring different advection schemes and time steppers to help us decide what to implement. I hope this PR can serve as test-driven development: Oceananigans should be able to reproduce the results of this PR, at which point it becomes a true verification experiment. `weno.jl` defines `advective_tracer_flux` functions (`weno5_flux`) so it should work nicely with the existing `Oceananigans.Operators`. At some point in the future I'd like to follow this PR up with a 2D advection test using the Munk gyre solution. Should also test momentum advection. Of course, can't always generalize 1D advection results to 3D turbulence simulations... Things to do to integrate WENO-5:; 1. Design an abstraction for selecting advection schemes.; 2. Extend to multi-dimensional advection scheme.; 3. Extend to a momentum advection scheme as well.; 4. Decide whether we want WENO-3 and/or WENO-7 (or even higher-order advection schemes). Note: On extending to multi-dimensional advection, we can perform the 1D WENO interpolation along each dimension separately to come up with a multidimensional advection scheme. This is what most packages do in practice as true multidimensional would involve huge stencils (and some numerical quadrature?) so it's not worth it for the small increase in accuracy. Doing it dimension-wise might be fine at lower order like WENO <= 7. I should cite the appropriate papers for these claims. This relatively recent paper might be of interest to us: Buchmüller & Helzel (2014), [Improved Accuracy of High-Order WENO Finite Volume Methods on Cartesian Grids](https://doi.org/10.1007/s10915-014-9825-1). Resolves #481; Resolves #934. ---; Not sure if it'll generalize to 3D but seems that you get better accuracy even with half the number of",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/592
https://github.com/CliMA/Oceananigans.jl/pull/592:2047,Deployability,upgrade,upgrade,2047,"ther we want WENO-3 and/or WENO-7 (or even higher-order advection schemes). Note: On extending to multi-dimensional advection, we can perform the 1D WENO interpolation along each dimension separately to come up with a multidimensional advection scheme. This is what most packages do in practice as true multidimensional would involve huge stencils (and some numerical quadrature?) so it's not worth it for the small increase in accuracy. Doing it dimension-wise might be fine at lower order like WENO <= 7. I should cite the appropriate papers for these claims. This relatively recent paper might be of interest to us: Buchmüller & Helzel (2014), [Improved Accuracy of High-Order WENO Finite Volume Methods on Cartesian Grids](https://doi.org/10.1007/s10915-014-9825-1). Resolves #481; Resolves #934. ---; Not sure if it'll generalize to 3D but seems that you get better accuracy even with half the number of grid points (per dimension?). And if we also upgrade time stepper from AB2 to something like LSRK54 then we should be able to take ~3x longer time steps. ![Gaussian_SecondOrderCentered_AB3_N64_CFL0 60](https://user-images.githubusercontent.com/20099589/72301437-c3d5f600-3634-11ea-8784-81aa7d094f98.gif); ![Gaussian_WENO5_CarpenterKennedy2N54_N32_CFL1 80](https://user-images.githubusercontent.com/20099589/72301438-c46e8c80-3634-11ea-97d9-9a1ad8c020fc.gif); ![Square_SecondOrderCentered_AB3_N64_CFL0 60](https://user-images.githubusercontent.com/20099589/72301480-dea86a80-3634-11ea-9e57-0c8be280cfc9.gif); ![Square_WENO5_CarpenterKennedy2N54_N32_CFL1 80](https://user-images.githubusercontent.com/20099589/72301504-f4b62b00-3634-11ea-9480-4a3986bff592.gif). I guess you need more resolution when you have discontinuities:; ![Square_WENO5_CarpenterKennedy2N54_N256_CFL1 80](https://user-images.githubusercontent.com/20099589/72301546-16afad80-3635-11ea-8e50-aca1b916ea73.gif). With `LSRK144NiegemannDiehlBusch` (or `NDBLRK144`) you still get good accuracy up to CFL = 4 (although it's stabl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/592
https://github.com/CliMA/Oceananigans.jl/pull/592:901,Integrability,integrat,integrate,901,"This is finishing up some work I started last October on getting a WENO-5 tracer advection scheme working in Julia. Thanks @RaphaelRR for helping with the WENO-5 advection scheme!. This PR adds a 1D advection verification experiment to start exploring different advection schemes and time steppers to help us decide what to implement. I hope this PR can serve as test-driven development: Oceananigans should be able to reproduce the results of this PR, at which point it becomes a true verification experiment. `weno.jl` defines `advective_tracer_flux` functions (`weno5_flux`) so it should work nicely with the existing `Oceananigans.Operators`. At some point in the future I'd like to follow this PR up with a 2D advection test using the Munk gyre solution. Should also test momentum advection. Of course, can't always generalize 1D advection results to 3D turbulence simulations... Things to do to integrate WENO-5:; 1. Design an abstraction for selecting advection schemes.; 2. Extend to multi-dimensional advection scheme.; 3. Extend to a momentum advection scheme as well.; 4. Decide whether we want WENO-3 and/or WENO-7 (or even higher-order advection schemes). Note: On extending to multi-dimensional advection, we can perform the 1D WENO interpolation along each dimension separately to come up with a multidimensional advection scheme. This is what most packages do in practice as true multidimensional would involve huge stencils (and some numerical quadrature?) so it's not worth it for the small increase in accuracy. Doing it dimension-wise might be fine at lower order like WENO <= 7. I should cite the appropriate papers for these claims. This relatively recent paper might be of interest to us: Buchmüller & Helzel (2014), [Improved Accuracy of High-Order WENO Finite Volume Methods on Cartesian Grids](https://doi.org/10.1007/s10915-014-9825-1). Resolves #481; Resolves #934. ---; Not sure if it'll generalize to 3D but seems that you get better accuracy even with half the number of",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/592
https://github.com/CliMA/Oceananigans.jl/pull/592:982,Modifiability,Extend,Extend,982," is finishing up some work I started last October on getting a WENO-5 tracer advection scheme working in Julia. Thanks @RaphaelRR for helping with the WENO-5 advection scheme!. This PR adds a 1D advection verification experiment to start exploring different advection schemes and time steppers to help us decide what to implement. I hope this PR can serve as test-driven development: Oceananigans should be able to reproduce the results of this PR, at which point it becomes a true verification experiment. `weno.jl` defines `advective_tracer_flux` functions (`weno5_flux`) so it should work nicely with the existing `Oceananigans.Operators`. At some point in the future I'd like to follow this PR up with a 2D advection test using the Munk gyre solution. Should also test momentum advection. Of course, can't always generalize 1D advection results to 3D turbulence simulations... Things to do to integrate WENO-5:; 1. Design an abstraction for selecting advection schemes.; 2. Extend to multi-dimensional advection scheme.; 3. Extend to a momentum advection scheme as well.; 4. Decide whether we want WENO-3 and/or WENO-7 (or even higher-order advection schemes). Note: On extending to multi-dimensional advection, we can perform the 1D WENO interpolation along each dimension separately to come up with a multidimensional advection scheme. This is what most packages do in practice as true multidimensional would involve huge stencils (and some numerical quadrature?) so it's not worth it for the small increase in accuracy. Doing it dimension-wise might be fine at lower order like WENO <= 7. I should cite the appropriate papers for these claims. This relatively recent paper might be of interest to us: Buchmüller & Helzel (2014), [Improved Accuracy of High-Order WENO Finite Volume Methods on Cartesian Grids](https://doi.org/10.1007/s10915-014-9825-1). Resolves #481; Resolves #934. ---; Not sure if it'll generalize to 3D but seems that you get better accuracy even with half the number of gr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/592
https://github.com/CliMA/Oceananigans.jl/pull/592:1032,Modifiability,Extend,Extend,1032,"on getting a WENO-5 tracer advection scheme working in Julia. Thanks @RaphaelRR for helping with the WENO-5 advection scheme!. This PR adds a 1D advection verification experiment to start exploring different advection schemes and time steppers to help us decide what to implement. I hope this PR can serve as test-driven development: Oceananigans should be able to reproduce the results of this PR, at which point it becomes a true verification experiment. `weno.jl` defines `advective_tracer_flux` functions (`weno5_flux`) so it should work nicely with the existing `Oceananigans.Operators`. At some point in the future I'd like to follow this PR up with a 2D advection test using the Munk gyre solution. Should also test momentum advection. Of course, can't always generalize 1D advection results to 3D turbulence simulations... Things to do to integrate WENO-5:; 1. Design an abstraction for selecting advection schemes.; 2. Extend to multi-dimensional advection scheme.; 3. Extend to a momentum advection scheme as well.; 4. Decide whether we want WENO-3 and/or WENO-7 (or even higher-order advection schemes). Note: On extending to multi-dimensional advection, we can perform the 1D WENO interpolation along each dimension separately to come up with a multidimensional advection scheme. This is what most packages do in practice as true multidimensional would involve huge stencils (and some numerical quadrature?) so it's not worth it for the small increase in accuracy. Doing it dimension-wise might be fine at lower order like WENO <= 7. I should cite the appropriate papers for these claims. This relatively recent paper might be of interest to us: Buchmüller & Helzel (2014), [Improved Accuracy of High-Order WENO Finite Volume Methods on Cartesian Grids](https://doi.org/10.1007/s10915-014-9825-1). Resolves #481; Resolves #934. ---; Not sure if it'll generalize to 3D but seems that you get better accuracy even with half the number of grid points (per dimension?). And if we also upgrade ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/592
https://github.com/CliMA/Oceananigans.jl/pull/592:1178,Modifiability,extend,extending,1178,"erent advection schemes and time steppers to help us decide what to implement. I hope this PR can serve as test-driven development: Oceananigans should be able to reproduce the results of this PR, at which point it becomes a true verification experiment. `weno.jl` defines `advective_tracer_flux` functions (`weno5_flux`) so it should work nicely with the existing `Oceananigans.Operators`. At some point in the future I'd like to follow this PR up with a 2D advection test using the Munk gyre solution. Should also test momentum advection. Of course, can't always generalize 1D advection results to 3D turbulence simulations... Things to do to integrate WENO-5:; 1. Design an abstraction for selecting advection schemes.; 2. Extend to multi-dimensional advection scheme.; 3. Extend to a momentum advection scheme as well.; 4. Decide whether we want WENO-3 and/or WENO-7 (or even higher-order advection schemes). Note: On extending to multi-dimensional advection, we can perform the 1D WENO interpolation along each dimension separately to come up with a multidimensional advection scheme. This is what most packages do in practice as true multidimensional would involve huge stencils (and some numerical quadrature?) so it's not worth it for the small increase in accuracy. Doing it dimension-wise might be fine at lower order like WENO <= 7. I should cite the appropriate papers for these claims. This relatively recent paper might be of interest to us: Buchmüller & Helzel (2014), [Improved Accuracy of High-Order WENO Finite Volume Methods on Cartesian Grids](https://doi.org/10.1007/s10915-014-9825-1). Resolves #481; Resolves #934. ---; Not sure if it'll generalize to 3D but seems that you get better accuracy even with half the number of grid points (per dimension?). And if we also upgrade time stepper from AB2 to something like LSRK54 then we should be able to take ~3x longer time steps. ![Gaussian_SecondOrderCentered_AB3_N64_CFL0 60](https://user-images.githubusercontent.com/20099589/72",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/592
https://github.com/CliMA/Oceananigans.jl/pull/592:1227,Performance,perform,perform,1227,"erent advection schemes and time steppers to help us decide what to implement. I hope this PR can serve as test-driven development: Oceananigans should be able to reproduce the results of this PR, at which point it becomes a true verification experiment. `weno.jl` defines `advective_tracer_flux` functions (`weno5_flux`) so it should work nicely with the existing `Oceananigans.Operators`. At some point in the future I'd like to follow this PR up with a 2D advection test using the Munk gyre solution. Should also test momentum advection. Of course, can't always generalize 1D advection results to 3D turbulence simulations... Things to do to integrate WENO-5:; 1. Design an abstraction for selecting advection schemes.; 2. Extend to multi-dimensional advection scheme.; 3. Extend to a momentum advection scheme as well.; 4. Decide whether we want WENO-3 and/or WENO-7 (or even higher-order advection schemes). Note: On extending to multi-dimensional advection, we can perform the 1D WENO interpolation along each dimension separately to come up with a multidimensional advection scheme. This is what most packages do in practice as true multidimensional would involve huge stencils (and some numerical quadrature?) so it's not worth it for the small increase in accuracy. Doing it dimension-wise might be fine at lower order like WENO <= 7. I should cite the appropriate papers for these claims. This relatively recent paper might be of interest to us: Buchmüller & Helzel (2014), [Improved Accuracy of High-Order WENO Finite Volume Methods on Cartesian Grids](https://doi.org/10.1007/s10915-014-9825-1). Resolves #481; Resolves #934. ---; Not sure if it'll generalize to 3D but seems that you get better accuracy even with half the number of grid points (per dimension?). And if we also upgrade time stepper from AB2 to something like LSRK54 then we should be able to take ~3x longer time steps. ![Gaussian_SecondOrderCentered_AB3_N64_CFL0 60](https://user-images.githubusercontent.com/20099589/72",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/592
https://github.com/CliMA/Oceananigans.jl/pull/592:363,Testability,test,test-driven,363,"This is finishing up some work I started last October on getting a WENO-5 tracer advection scheme working in Julia. Thanks @RaphaelRR for helping with the WENO-5 advection scheme!. This PR adds a 1D advection verification experiment to start exploring different advection schemes and time steppers to help us decide what to implement. I hope this PR can serve as test-driven development: Oceananigans should be able to reproduce the results of this PR, at which point it becomes a true verification experiment. `weno.jl` defines `advective_tracer_flux` functions (`weno5_flux`) so it should work nicely with the existing `Oceananigans.Operators`. At some point in the future I'd like to follow this PR up with a 2D advection test using the Munk gyre solution. Should also test momentum advection. Of course, can't always generalize 1D advection results to 3D turbulence simulations... Things to do to integrate WENO-5:; 1. Design an abstraction for selecting advection schemes.; 2. Extend to multi-dimensional advection scheme.; 3. Extend to a momentum advection scheme as well.; 4. Decide whether we want WENO-3 and/or WENO-7 (or even higher-order advection schemes). Note: On extending to multi-dimensional advection, we can perform the 1D WENO interpolation along each dimension separately to come up with a multidimensional advection scheme. This is what most packages do in practice as true multidimensional would involve huge stencils (and some numerical quadrature?) so it's not worth it for the small increase in accuracy. Doing it dimension-wise might be fine at lower order like WENO <= 7. I should cite the appropriate papers for these claims. This relatively recent paper might be of interest to us: Buchmüller & Helzel (2014), [Improved Accuracy of High-Order WENO Finite Volume Methods on Cartesian Grids](https://doi.org/10.1007/s10915-014-9825-1). Resolves #481; Resolves #934. ---; Not sure if it'll generalize to 3D but seems that you get better accuracy even with half the number of",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/592
https://github.com/CliMA/Oceananigans.jl/pull/592:725,Testability,test,test,725,"This is finishing up some work I started last October on getting a WENO-5 tracer advection scheme working in Julia. Thanks @RaphaelRR for helping with the WENO-5 advection scheme!. This PR adds a 1D advection verification experiment to start exploring different advection schemes and time steppers to help us decide what to implement. I hope this PR can serve as test-driven development: Oceananigans should be able to reproduce the results of this PR, at which point it becomes a true verification experiment. `weno.jl` defines `advective_tracer_flux` functions (`weno5_flux`) so it should work nicely with the existing `Oceananigans.Operators`. At some point in the future I'd like to follow this PR up with a 2D advection test using the Munk gyre solution. Should also test momentum advection. Of course, can't always generalize 1D advection results to 3D turbulence simulations... Things to do to integrate WENO-5:; 1. Design an abstraction for selecting advection schemes.; 2. Extend to multi-dimensional advection scheme.; 3. Extend to a momentum advection scheme as well.; 4. Decide whether we want WENO-3 and/or WENO-7 (or even higher-order advection schemes). Note: On extending to multi-dimensional advection, we can perform the 1D WENO interpolation along each dimension separately to come up with a multidimensional advection scheme. This is what most packages do in practice as true multidimensional would involve huge stencils (and some numerical quadrature?) so it's not worth it for the small increase in accuracy. Doing it dimension-wise might be fine at lower order like WENO <= 7. I should cite the appropriate papers for these claims. This relatively recent paper might be of interest to us: Buchmüller & Helzel (2014), [Improved Accuracy of High-Order WENO Finite Volume Methods on Cartesian Grids](https://doi.org/10.1007/s10915-014-9825-1). Resolves #481; Resolves #934. ---; Not sure if it'll generalize to 3D but seems that you get better accuracy even with half the number of",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/592
https://github.com/CliMA/Oceananigans.jl/pull/592:772,Testability,test,test,772,"This is finishing up some work I started last October on getting a WENO-5 tracer advection scheme working in Julia. Thanks @RaphaelRR for helping with the WENO-5 advection scheme!. This PR adds a 1D advection verification experiment to start exploring different advection schemes and time steppers to help us decide what to implement. I hope this PR can serve as test-driven development: Oceananigans should be able to reproduce the results of this PR, at which point it becomes a true verification experiment. `weno.jl` defines `advective_tracer_flux` functions (`weno5_flux`) so it should work nicely with the existing `Oceananigans.Operators`. At some point in the future I'd like to follow this PR up with a 2D advection test using the Munk gyre solution. Should also test momentum advection. Of course, can't always generalize 1D advection results to 3D turbulence simulations... Things to do to integrate WENO-5:; 1. Design an abstraction for selecting advection schemes.; 2. Extend to multi-dimensional advection scheme.; 3. Extend to a momentum advection scheme as well.; 4. Decide whether we want WENO-3 and/or WENO-7 (or even higher-order advection schemes). Note: On extending to multi-dimensional advection, we can perform the 1D WENO interpolation along each dimension separately to come up with a multidimensional advection scheme. This is what most packages do in practice as true multidimensional would involve huge stencils (and some numerical quadrature?) so it's not worth it for the small increase in accuracy. Doing it dimension-wise might be fine at lower order like WENO <= 7. I should cite the appropriate papers for these claims. This relatively recent paper might be of interest to us: Buchmüller & Helzel (2014), [Improved Accuracy of High-Order WENO Finite Volume Methods on Cartesian Grids](https://doi.org/10.1007/s10915-014-9825-1). Resolves #481; Resolves #934. ---; Not sure if it'll generalize to 3D but seems that you get better accuracy even with half the number of",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/592
https://github.com/CliMA/Oceananigans.jl/issues/597:40,Deployability,update,update,40,@jm-c also pointed out that I forgot to update the indices in computing the friction velocity in `stratified_couette_flow.png` after the k index was reversed.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/597
https://github.com/CliMA/Oceananigans.jl/issues/598:134,Deployability,update,updated,134,"Had an earlier clone, was on master branch, everything was in order as ""git status"" ; ; nothing to commit, working tree clean. Then I updated my clone the usual way, just typing ""git pull"", but got plenty of warnings about; conflicts and so on. After that, ""git status"" reports:. On branch master; Your branch and 'origin/master' have diverged,; and have 1106 and 2212 different commits each, respectively.; (use ""git pull"" to merge the remote branch into yours); You have unmerged paths.; (fix conflicts and run ""git commit""); (use ""git merge --abort"" to abort the merge). so it looks like I am far from a clean update. My question: how to proceed when trying to update my Oceananigans local clone and; why the standard way does not work for this repos ?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/598
https://github.com/CliMA/Oceananigans.jl/issues/598:613,Deployability,update,update,613,"Had an earlier clone, was on master branch, everything was in order as ""git status"" ; ; nothing to commit, working tree clean. Then I updated my clone the usual way, just typing ""git pull"", but got plenty of warnings about; conflicts and so on. After that, ""git status"" reports:. On branch master; Your branch and 'origin/master' have diverged,; and have 1106 and 2212 different commits each, respectively.; (use ""git pull"" to merge the remote branch into yours); You have unmerged paths.; (fix conflicts and run ""git commit""); (use ""git merge --abort"" to abort the merge). so it looks like I am far from a clean update. My question: how to proceed when trying to update my Oceananigans local clone and; why the standard way does not work for this repos ?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/598
https://github.com/CliMA/Oceananigans.jl/issues/598:664,Deployability,update,update,664,"Had an earlier clone, was on master branch, everything was in order as ""git status"" ; ; nothing to commit, working tree clean. Then I updated my clone the usual way, just typing ""git pull"", but got plenty of warnings about; conflicts and so on. After that, ""git status"" reports:. On branch master; Your branch and 'origin/master' have diverged,; and have 1106 and 2212 different commits each, respectively.; (use ""git pull"" to merge the remote branch into yours); You have unmerged paths.; (fix conflicts and run ""git commit""); (use ""git merge --abort"" to abort the merge). so it looks like I am far from a clean update. My question: how to proceed when trying to update my Oceananigans local clone and; why the standard way does not work for this repos ?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/598
https://github.com/CliMA/Oceananigans.jl/issues/598:546,Safety,abort,abort,546,"Had an earlier clone, was on master branch, everything was in order as ""git status"" ; ; nothing to commit, working tree clean. Then I updated my clone the usual way, just typing ""git pull"", but got plenty of warnings about; conflicts and so on. After that, ""git status"" reports:. On branch master; Your branch and 'origin/master' have diverged,; and have 1106 and 2212 different commits each, respectively.; (use ""git pull"" to merge the remote branch into yours); You have unmerged paths.; (fix conflicts and run ""git commit""); (use ""git merge --abort"" to abort the merge). so it looks like I am far from a clean update. My question: how to proceed when trying to update my Oceananigans local clone and; why the standard way does not work for this repos ?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/598
https://github.com/CliMA/Oceananigans.jl/issues/598:556,Safety,abort,abort,556,"Had an earlier clone, was on master branch, everything was in order as ""git status"" ; ; nothing to commit, working tree clean. Then I updated my clone the usual way, just typing ""git pull"", but got plenty of warnings about; conflicts and so on. After that, ""git status"" reports:. On branch master; Your branch and 'origin/master' have diverged,; and have 1106 and 2212 different commits each, respectively.; (use ""git pull"" to merge the remote branch into yours); You have unmerged paths.; (fix conflicts and run ""git commit""); (use ""git merge --abort"" to abort the merge). so it looks like I am far from a clean update. My question: how to proceed when trying to update my Oceananigans local clone and; why the standard way does not work for this repos ?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/598
https://github.com/CliMA/Oceananigans.jl/issues/599:389,Usability,clear,clear,389,"@ali-ramadhan etc... the function index here. https://climate-machine.github.io/Oceananigans.jl/stable/function_index/. seems to miss a bunch of functions. It would be more useful if it had all the functions. . For example ```compute_w_from_continuity!``` appears from ``` Oceananigans.jl/src/TimeSteppers/kernels.jl```, but lots of other functions in their don't. Looking at code its not clear to me why that is. Is there a way to get all functions in the index?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/599
https://github.com/CliMA/Oceananigans.jl/pull/601:1479,Testability,test,test,1479,"This PR adds the ability to set boundary conditions on the LES diffusivities. The primary purpose of this functionality is to allow users to fix both fluxes and the gradients of fields on boundaries. This flexibility is needed because currently, if the flux of a field is specified, the gradient of that field across the boundary is naively set to zero. . This naive assumption, which is unfortunately incorrect and means that the calculation of near-wall diffusivities is also incorrect, was made in lieu of formulating some kind of nonlinear solver for the algebraic problem generated by the combination of a prescribed flux and nonlinear boundary diffusivity. Formulating a nonlinear solver to be applied along the boundary to determine boundary gradients from prescribed fluxes and general nonlinear LES formulations might be viewed as ""somewhat difficult"", and may not be useful, either. This PR permits an alternate solution to the puzzle: users may now prescribe both fluxes and gradients (essentially introducing a wall model on top of the interior LES model) by simultaneously setting the value of the LES diffusivity and the gradient of a field on the boundary. The flux of the field across the boundary is then calculated consistently as part of the interior solution. The interior LES model and calculation of nonlinear viscosities and diffusivities at interior cell centers is unchanged. The method for setting boundary values of diffusivities roughly sketched by a test of the new feature in . https://github.com/climate-machine/Oceananigans.jl/blob/f1d341ac8512ba13b4fc165b24a25f6bdf3696ef/test/test_boundary_conditions.jl#L95. This new feature is useful mainly for advanced users at the moment due to the convoluted scripting gymnastics needed to instantiate the `ModelBoundaryConditions` prior to instantiating the `Model`. Some improvements to the user API would be welcome if this feature gains popularity or importance in the future.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/601
https://github.com/CliMA/Oceananigans.jl/pull/601:1605,Testability,test,test,1605,"This PR adds the ability to set boundary conditions on the LES diffusivities. The primary purpose of this functionality is to allow users to fix both fluxes and the gradients of fields on boundaries. This flexibility is needed because currently, if the flux of a field is specified, the gradient of that field across the boundary is naively set to zero. . This naive assumption, which is unfortunately incorrect and means that the calculation of near-wall diffusivities is also incorrect, was made in lieu of formulating some kind of nonlinear solver for the algebraic problem generated by the combination of a prescribed flux and nonlinear boundary diffusivity. Formulating a nonlinear solver to be applied along the boundary to determine boundary gradients from prescribed fluxes and general nonlinear LES formulations might be viewed as ""somewhat difficult"", and may not be useful, either. This PR permits an alternate solution to the puzzle: users may now prescribe both fluxes and gradients (essentially introducing a wall model on top of the interior LES model) by simultaneously setting the value of the LES diffusivity and the gradient of a field on the boundary. The flux of the field across the boundary is then calculated consistently as part of the interior solution. The interior LES model and calculation of nonlinear viscosities and diffusivities at interior cell centers is unchanged. The method for setting boundary values of diffusivities roughly sketched by a test of the new feature in . https://github.com/climate-machine/Oceananigans.jl/blob/f1d341ac8512ba13b4fc165b24a25f6bdf3696ef/test/test_boundary_conditions.jl#L95. This new feature is useful mainly for advanced users at the moment due to the convoluted scripting gymnastics needed to instantiate the `ModelBoundaryConditions` prior to instantiating the `Model`. Some improvements to the user API would be welcome if this feature gains popularity or importance in the future.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/601
https://github.com/CliMA/Oceananigans.jl/pull/603:124,Availability,checkpoint,checkpoint,124,"The idea here is to minimize the amount of modifications required to the parent script when model is being restarted from a checkpoint. Currently, the script might look like this when the model is being run for the first time:; ```julia; model = Model(; architecture = GPU(),; float_type = Float64,; grid = RegularCartesianGrid(size=(Nx, Ny, Nz), length=(Lx, Ly, Lz)),; coriolis = coriolis,; buoyancy = SeawaterBuoyancy(gravitational_acceleration=g_Europa),; closure = closure,; boundary_conditions = model_bcs,; forcing = forcing; ); # model = restore_from_checkpoint(path; kwargs); ```; When restarting from the checkpoint, we'll have to comment the first 9 lines and uncomment the following line. This gets annoying pretty quickly when running a large suite of experiments. So I thought it would be better to integrate the checkpoint specification with model constructor. . ```julia; model = Model(; restarter = ""/path/to/checkpoint/file"",; architecture = GPU(),; float_type = Float64,; grid = RegularCartesianGrid(size=(Nx, Ny, Nz), length=(Lx, Ly, Lz)),; coriolis = coriolis,; buoyancy = SeawaterBuoyancy(gravitational_acceleration=g_Europa),; closure = closure,; boundary_conditions = model_bcs,; forcing = forcing; ); ```; Modifications to parent script are minimized if restarting from checkpointer is integrated into model constructor. . The way I have implemented it currently, if restarter is specified in model constructor all other kwargs to `Model` are ignored. @ali-ramadhan thinks this doesn't cover all possible model specification cases. . Any thoughts on how to improve this?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/603
https://github.com/CliMA/Oceananigans.jl/pull/603:614,Availability,checkpoint,checkpoint,614,"The idea here is to minimize the amount of modifications required to the parent script when model is being restarted from a checkpoint. Currently, the script might look like this when the model is being run for the first time:; ```julia; model = Model(; architecture = GPU(),; float_type = Float64,; grid = RegularCartesianGrid(size=(Nx, Ny, Nz), length=(Lx, Ly, Lz)),; coriolis = coriolis,; buoyancy = SeawaterBuoyancy(gravitational_acceleration=g_Europa),; closure = closure,; boundary_conditions = model_bcs,; forcing = forcing; ); # model = restore_from_checkpoint(path; kwargs); ```; When restarting from the checkpoint, we'll have to comment the first 9 lines and uncomment the following line. This gets annoying pretty quickly when running a large suite of experiments. So I thought it would be better to integrate the checkpoint specification with model constructor. . ```julia; model = Model(; restarter = ""/path/to/checkpoint/file"",; architecture = GPU(),; float_type = Float64,; grid = RegularCartesianGrid(size=(Nx, Ny, Nz), length=(Lx, Ly, Lz)),; coriolis = coriolis,; buoyancy = SeawaterBuoyancy(gravitational_acceleration=g_Europa),; closure = closure,; boundary_conditions = model_bcs,; forcing = forcing; ); ```; Modifications to parent script are minimized if restarting from checkpointer is integrated into model constructor. . The way I have implemented it currently, if restarter is specified in model constructor all other kwargs to `Model` are ignored. @ali-ramadhan thinks this doesn't cover all possible model specification cases. . Any thoughts on how to improve this?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/603
https://github.com/CliMA/Oceananigans.jl/pull/603:826,Availability,checkpoint,checkpoint,826,"The idea here is to minimize the amount of modifications required to the parent script when model is being restarted from a checkpoint. Currently, the script might look like this when the model is being run for the first time:; ```julia; model = Model(; architecture = GPU(),; float_type = Float64,; grid = RegularCartesianGrid(size=(Nx, Ny, Nz), length=(Lx, Ly, Lz)),; coriolis = coriolis,; buoyancy = SeawaterBuoyancy(gravitational_acceleration=g_Europa),; closure = closure,; boundary_conditions = model_bcs,; forcing = forcing; ); # model = restore_from_checkpoint(path; kwargs); ```; When restarting from the checkpoint, we'll have to comment the first 9 lines and uncomment the following line. This gets annoying pretty quickly when running a large suite of experiments. So I thought it would be better to integrate the checkpoint specification with model constructor. . ```julia; model = Model(; restarter = ""/path/to/checkpoint/file"",; architecture = GPU(),; float_type = Float64,; grid = RegularCartesianGrid(size=(Nx, Ny, Nz), length=(Lx, Ly, Lz)),; coriolis = coriolis,; buoyancy = SeawaterBuoyancy(gravitational_acceleration=g_Europa),; closure = closure,; boundary_conditions = model_bcs,; forcing = forcing; ); ```; Modifications to parent script are minimized if restarting from checkpointer is integrated into model constructor. . The way I have implemented it currently, if restarter is specified in model constructor all other kwargs to `Model` are ignored. @ali-ramadhan thinks this doesn't cover all possible model specification cases. . Any thoughts on how to improve this?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/603
https://github.com/CliMA/Oceananigans.jl/pull/603:925,Availability,checkpoint,checkpoint,925,"The idea here is to minimize the amount of modifications required to the parent script when model is being restarted from a checkpoint. Currently, the script might look like this when the model is being run for the first time:; ```julia; model = Model(; architecture = GPU(),; float_type = Float64,; grid = RegularCartesianGrid(size=(Nx, Ny, Nz), length=(Lx, Ly, Lz)),; coriolis = coriolis,; buoyancy = SeawaterBuoyancy(gravitational_acceleration=g_Europa),; closure = closure,; boundary_conditions = model_bcs,; forcing = forcing; ); # model = restore_from_checkpoint(path; kwargs); ```; When restarting from the checkpoint, we'll have to comment the first 9 lines and uncomment the following line. This gets annoying pretty quickly when running a large suite of experiments. So I thought it would be better to integrate the checkpoint specification with model constructor. . ```julia; model = Model(; restarter = ""/path/to/checkpoint/file"",; architecture = GPU(),; float_type = Float64,; grid = RegularCartesianGrid(size=(Nx, Ny, Nz), length=(Lx, Ly, Lz)),; coriolis = coriolis,; buoyancy = SeawaterBuoyancy(gravitational_acceleration=g_Europa),; closure = closure,; boundary_conditions = model_bcs,; forcing = forcing; ); ```; Modifications to parent script are minimized if restarting from checkpointer is integrated into model constructor. . The way I have implemented it currently, if restarter is specified in model constructor all other kwargs to `Model` are ignored. @ali-ramadhan thinks this doesn't cover all possible model specification cases. . Any thoughts on how to improve this?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/603
https://github.com/CliMA/Oceananigans.jl/pull/603:1294,Availability,checkpoint,checkpointer,1294,"The idea here is to minimize the amount of modifications required to the parent script when model is being restarted from a checkpoint. Currently, the script might look like this when the model is being run for the first time:; ```julia; model = Model(; architecture = GPU(),; float_type = Float64,; grid = RegularCartesianGrid(size=(Nx, Ny, Nz), length=(Lx, Ly, Lz)),; coriolis = coriolis,; buoyancy = SeawaterBuoyancy(gravitational_acceleration=g_Europa),; closure = closure,; boundary_conditions = model_bcs,; forcing = forcing; ); # model = restore_from_checkpoint(path; kwargs); ```; When restarting from the checkpoint, we'll have to comment the first 9 lines and uncomment the following line. This gets annoying pretty quickly when running a large suite of experiments. So I thought it would be better to integrate the checkpoint specification with model constructor. . ```julia; model = Model(; restarter = ""/path/to/checkpoint/file"",; architecture = GPU(),; float_type = Float64,; grid = RegularCartesianGrid(size=(Nx, Ny, Nz), length=(Lx, Ly, Lz)),; coriolis = coriolis,; buoyancy = SeawaterBuoyancy(gravitational_acceleration=g_Europa),; closure = closure,; boundary_conditions = model_bcs,; forcing = forcing; ); ```; Modifications to parent script are minimized if restarting from checkpointer is integrated into model constructor. . The way I have implemented it currently, if restarter is specified in model constructor all other kwargs to `Model` are ignored. @ali-ramadhan thinks this doesn't cover all possible model specification cases. . Any thoughts on how to improve this?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/603
https://github.com/CliMA/Oceananigans.jl/pull/603:812,Deployability,integrat,integrate,812,"The idea here is to minimize the amount of modifications required to the parent script when model is being restarted from a checkpoint. Currently, the script might look like this when the model is being run for the first time:; ```julia; model = Model(; architecture = GPU(),; float_type = Float64,; grid = RegularCartesianGrid(size=(Nx, Ny, Nz), length=(Lx, Ly, Lz)),; coriolis = coriolis,; buoyancy = SeawaterBuoyancy(gravitational_acceleration=g_Europa),; closure = closure,; boundary_conditions = model_bcs,; forcing = forcing; ); # model = restore_from_checkpoint(path; kwargs); ```; When restarting from the checkpoint, we'll have to comment the first 9 lines and uncomment the following line. This gets annoying pretty quickly when running a large suite of experiments. So I thought it would be better to integrate the checkpoint specification with model constructor. . ```julia; model = Model(; restarter = ""/path/to/checkpoint/file"",; architecture = GPU(),; float_type = Float64,; grid = RegularCartesianGrid(size=(Nx, Ny, Nz), length=(Lx, Ly, Lz)),; coriolis = coriolis,; buoyancy = SeawaterBuoyancy(gravitational_acceleration=g_Europa),; closure = closure,; boundary_conditions = model_bcs,; forcing = forcing; ); ```; Modifications to parent script are minimized if restarting from checkpointer is integrated into model constructor. . The way I have implemented it currently, if restarter is specified in model constructor all other kwargs to `Model` are ignored. @ali-ramadhan thinks this doesn't cover all possible model specification cases. . Any thoughts on how to improve this?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/603
https://github.com/CliMA/Oceananigans.jl/pull/603:1310,Deployability,integrat,integrated,1310,"The idea here is to minimize the amount of modifications required to the parent script when model is being restarted from a checkpoint. Currently, the script might look like this when the model is being run for the first time:; ```julia; model = Model(; architecture = GPU(),; float_type = Float64,; grid = RegularCartesianGrid(size=(Nx, Ny, Nz), length=(Lx, Ly, Lz)),; coriolis = coriolis,; buoyancy = SeawaterBuoyancy(gravitational_acceleration=g_Europa),; closure = closure,; boundary_conditions = model_bcs,; forcing = forcing; ); # model = restore_from_checkpoint(path; kwargs); ```; When restarting from the checkpoint, we'll have to comment the first 9 lines and uncomment the following line. This gets annoying pretty quickly when running a large suite of experiments. So I thought it would be better to integrate the checkpoint specification with model constructor. . ```julia; model = Model(; restarter = ""/path/to/checkpoint/file"",; architecture = GPU(),; float_type = Float64,; grid = RegularCartesianGrid(size=(Nx, Ny, Nz), length=(Lx, Ly, Lz)),; coriolis = coriolis,; buoyancy = SeawaterBuoyancy(gravitational_acceleration=g_Europa),; closure = closure,; boundary_conditions = model_bcs,; forcing = forcing; ); ```; Modifications to parent script are minimized if restarting from checkpointer is integrated into model constructor. . The way I have implemented it currently, if restarter is specified in model constructor all other kwargs to `Model` are ignored. @ali-ramadhan thinks this doesn't cover all possible model specification cases. . Any thoughts on how to improve this?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/603
https://github.com/CliMA/Oceananigans.jl/pull/603:812,Integrability,integrat,integrate,812,"The idea here is to minimize the amount of modifications required to the parent script when model is being restarted from a checkpoint. Currently, the script might look like this when the model is being run for the first time:; ```julia; model = Model(; architecture = GPU(),; float_type = Float64,; grid = RegularCartesianGrid(size=(Nx, Ny, Nz), length=(Lx, Ly, Lz)),; coriolis = coriolis,; buoyancy = SeawaterBuoyancy(gravitational_acceleration=g_Europa),; closure = closure,; boundary_conditions = model_bcs,; forcing = forcing; ); # model = restore_from_checkpoint(path; kwargs); ```; When restarting from the checkpoint, we'll have to comment the first 9 lines and uncomment the following line. This gets annoying pretty quickly when running a large suite of experiments. So I thought it would be better to integrate the checkpoint specification with model constructor. . ```julia; model = Model(; restarter = ""/path/to/checkpoint/file"",; architecture = GPU(),; float_type = Float64,; grid = RegularCartesianGrid(size=(Nx, Ny, Nz), length=(Lx, Ly, Lz)),; coriolis = coriolis,; buoyancy = SeawaterBuoyancy(gravitational_acceleration=g_Europa),; closure = closure,; boundary_conditions = model_bcs,; forcing = forcing; ); ```; Modifications to parent script are minimized if restarting from checkpointer is integrated into model constructor. . The way I have implemented it currently, if restarter is specified in model constructor all other kwargs to `Model` are ignored. @ali-ramadhan thinks this doesn't cover all possible model specification cases. . Any thoughts on how to improve this?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/603
https://github.com/CliMA/Oceananigans.jl/pull/603:1310,Integrability,integrat,integrated,1310,"The idea here is to minimize the amount of modifications required to the parent script when model is being restarted from a checkpoint. Currently, the script might look like this when the model is being run for the first time:; ```julia; model = Model(; architecture = GPU(),; float_type = Float64,; grid = RegularCartesianGrid(size=(Nx, Ny, Nz), length=(Lx, Ly, Lz)),; coriolis = coriolis,; buoyancy = SeawaterBuoyancy(gravitational_acceleration=g_Europa),; closure = closure,; boundary_conditions = model_bcs,; forcing = forcing; ); # model = restore_from_checkpoint(path; kwargs); ```; When restarting from the checkpoint, we'll have to comment the first 9 lines and uncomment the following line. This gets annoying pretty quickly when running a large suite of experiments. So I thought it would be better to integrate the checkpoint specification with model constructor. . ```julia; model = Model(; restarter = ""/path/to/checkpoint/file"",; architecture = GPU(),; float_type = Float64,; grid = RegularCartesianGrid(size=(Nx, Ny, Nz), length=(Lx, Ly, Lz)),; coriolis = coriolis,; buoyancy = SeawaterBuoyancy(gravitational_acceleration=g_Europa),; closure = closure,; boundary_conditions = model_bcs,; forcing = forcing; ); ```; Modifications to parent script are minimized if restarting from checkpointer is integrated into model constructor. . The way I have implemented it currently, if restarter is specified in model constructor all other kwargs to `Model` are ignored. @ali-ramadhan thinks this doesn't cover all possible model specification cases. . Any thoughts on how to improve this?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/603
https://github.com/CliMA/Oceananigans.jl/issues/605:665,Deployability,integrat,integrating,665,"Over at [JULES.jl](https://github.com/thabbott/JULES.jl) @thabbott, @RaphaelRR, and I have been building a compressible non-hydrostatic model on top of Oceananigans.jl for atmospheric simulations. It follows the numerics of the Advanced Research WRF Model as described in Klemp et al. (2007) and Skamarock et al. (2019). With three qualitative verification experiments I think it's ready to be tagged as v0.1. I'm opening this issue to discuss the possibility of merging JULES.jl into Oceananigans.jl which would add a `CompressibleModel` type (discussed a bit in #566). The two models share a lot of the infrastructure we've already built for Oceananigans, and in integrating the two we will readily get a GPU-ready research-grade compressible atmosphere model. Verification experiments:; 1. Hydrostatic adjustment in an isothermal atmosphere [very qualitative, see Bannon (1995)]; 2. Dry rising thermal bubble: https://github.com/thabbott/JULES.jl/pull/31; 3. Nonlinear density current: https://github.com/thabbott/JULES.jl/pull/32. Dry rising thermal bubble can be compared with figure 5 of Wicker and Skamarock (1998), figure 7 of Jahn et al. (2015), and https://faculty.nps.edu/fxgirald/projects/mesoscale/rtb_movie.html. Nonlinear density current can be compared with figure 1 of Straka et al. (1993) and https://faculty.nps.edu/fxgirald/projects/mesoscale/dc_movie.html. Things we can hopefully share between `IncompressibleModel` and `CompressibleModel:; 1. Operators; 2. Grids; 3. Coriolis; 4. Forcing functions; 5. Boundary conditions; 6. Turbulence closures; 7. Diagnostics; 8. Output writers; 9. Advection schemes; 10. User interface (setting initial conditions, boundary conditions, time stepping, etc.). Atmosphere-specific abstractions that would differentiate compressible from incompressible models:; 1. Prognostic temperature (potential temperature, entropy, enthalpy, etc.); 2. Base state (dry adiabatic, isothermal, analytic sounding, form from initial conditions, etc.); 3. Acoust",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605
https://github.com/CliMA/Oceananigans.jl/issues/605:665,Integrability,integrat,integrating,665,"Over at [JULES.jl](https://github.com/thabbott/JULES.jl) @thabbott, @RaphaelRR, and I have been building a compressible non-hydrostatic model on top of Oceananigans.jl for atmospheric simulations. It follows the numerics of the Advanced Research WRF Model as described in Klemp et al. (2007) and Skamarock et al. (2019). With three qualitative verification experiments I think it's ready to be tagged as v0.1. I'm opening this issue to discuss the possibility of merging JULES.jl into Oceananigans.jl which would add a `CompressibleModel` type (discussed a bit in #566). The two models share a lot of the infrastructure we've already built for Oceananigans, and in integrating the two we will readily get a GPU-ready research-grade compressible atmosphere model. Verification experiments:; 1. Hydrostatic adjustment in an isothermal atmosphere [very qualitative, see Bannon (1995)]; 2. Dry rising thermal bubble: https://github.com/thabbott/JULES.jl/pull/31; 3. Nonlinear density current: https://github.com/thabbott/JULES.jl/pull/32. Dry rising thermal bubble can be compared with figure 5 of Wicker and Skamarock (1998), figure 7 of Jahn et al. (2015), and https://faculty.nps.edu/fxgirald/projects/mesoscale/rtb_movie.html. Nonlinear density current can be compared with figure 1 of Straka et al. (1993) and https://faculty.nps.edu/fxgirald/projects/mesoscale/dc_movie.html. Things we can hopefully share between `IncompressibleModel` and `CompressibleModel:; 1. Operators; 2. Grids; 3. Coriolis; 4. Forcing functions; 5. Boundary conditions; 6. Turbulence closures; 7. Diagnostics; 8. Output writers; 9. Advection schemes; 10. User interface (setting initial conditions, boundary conditions, time stepping, etc.). Atmosphere-specific abstractions that would differentiate compressible from incompressible models:; 1. Prognostic temperature (potential temperature, entropy, enthalpy, etc.); 2. Base state (dry adiabatic, isothermal, analytic sounding, form from initial conditions, etc.); 3. Acoust",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605
https://github.com/CliMA/Oceananigans.jl/issues/605:1636,Integrability,interface,interface,1636,"ting the two we will readily get a GPU-ready research-grade compressible atmosphere model. Verification experiments:; 1. Hydrostatic adjustment in an isothermal atmosphere [very qualitative, see Bannon (1995)]; 2. Dry rising thermal bubble: https://github.com/thabbott/JULES.jl/pull/31; 3. Nonlinear density current: https://github.com/thabbott/JULES.jl/pull/32. Dry rising thermal bubble can be compared with figure 5 of Wicker and Skamarock (1998), figure 7 of Jahn et al. (2015), and https://faculty.nps.edu/fxgirald/projects/mesoscale/rtb_movie.html. Nonlinear density current can be compared with figure 1 of Straka et al. (1993) and https://faculty.nps.edu/fxgirald/projects/mesoscale/dc_movie.html. Things we can hopefully share between `IncompressibleModel` and `CompressibleModel:; 1. Operators; 2. Grids; 3. Coriolis; 4. Forcing functions; 5. Boundary conditions; 6. Turbulence closures; 7. Diagnostics; 8. Output writers; 9. Advection schemes; 10. User interface (setting initial conditions, boundary conditions, time stepping, etc.). Atmosphere-specific abstractions that would differentiate compressible from incompressible models:; 1. Prognostic temperature (potential temperature, entropy, enthalpy, etc.); 2. Base state (dry adiabatic, isothermal, analytic sounding, form from initial conditions, etc.); 3. Acoustic time stepper (nothing, fully explicit for regular grids, vertically implicit for stretched grids); 4. Setting fields and initial conditions is more complicated because the density needs to be adjusted when setting the potential temperature. Also because the prognostic variables are ρ, ρu, ρv, ρw, ρθ, etc.; 5. Other atmospheric things like cloud microphysics and radiation but for this there are packages that can be relied on, e.g. [RRTMGP.jl](https://github.com/climate-machine/RRTMGP.jl) and [Cloudy.jl](https://github.com/climate-machine/Cloudy.jl). It would be ideal if we have a single `Model` type and just change the equation between the `CompressibleModel` an",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605
https://github.com/CliMA/Oceananigans.jl/issues/605:2273,Modifiability,variab,variables,2273,"ure 1 of Straka et al. (1993) and https://faculty.nps.edu/fxgirald/projects/mesoscale/dc_movie.html. Things we can hopefully share between `IncompressibleModel` and `CompressibleModel:; 1. Operators; 2. Grids; 3. Coriolis; 4. Forcing functions; 5. Boundary conditions; 6. Turbulence closures; 7. Diagnostics; 8. Output writers; 9. Advection schemes; 10. User interface (setting initial conditions, boundary conditions, time stepping, etc.). Atmosphere-specific abstractions that would differentiate compressible from incompressible models:; 1. Prognostic temperature (potential temperature, entropy, enthalpy, etc.); 2. Base state (dry adiabatic, isothermal, analytic sounding, form from initial conditions, etc.); 3. Acoustic time stepper (nothing, fully explicit for regular grids, vertically implicit for stretched grids); 4. Setting fields and initial conditions is more complicated because the density needs to be adjusted when setting the potential temperature. Also because the prognostic variables are ρ, ρu, ρv, ρw, ρθ, etc.; 5. Other atmospheric things like cloud microphysics and radiation but for this there are packages that can be relied on, e.g. [RRTMGP.jl](https://github.com/climate-machine/RRTMGP.jl) and [Cloudy.jl](https://github.com/climate-machine/Cloudy.jl). It would be ideal if we have a single `Model` type and just change the equation between the `CompressibleModel` and `IncompressibleModel` but the numerical methods and abstractions employed are sufficiently different that I think it makes sense to have two separate model types. It might even make sense to keep a separate package for this `CompressibleModel` but I think for now it's better if we keep it all inside the Oceananigans.jl repository (see https://github.com/climate-machine/Oceananigans.jl/issues/284 for some previous discussion) until the code is more stable and also for extra visibility while the package is young. References:; Bannon (1995): https://doi.org/10.1175/1520-0469(1995)052%3C1743:HALP%3E",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605
https://github.com/CliMA/Oceananigans.jl/issues/606:2361,Integrability,interface,interface,2361,"conditions (although some boundary conditions will be determined by the grid topology). I think it's a good idea that will pay off in code clarity and ease of use.; 1. Functions such as [`fill_halo_regions!`](https://github.com/climate-machine/Oceananigans.jl/blob/8d1b164881f12607748bba044afb93c71c652fac/src/BoundaryConditions/fill_halo_regions.jl#L22) will simplify as we no longer need to pass in both a field and boundary conditions, just the field itself.; 2. No need to prepare boundary condition tuples to pass to functions, for example, in [`complete_pressure_correction_step!`](https://github.com/climate-machine/Oceananigans.jl/blob/8d1b164881f12607748bba044afb93c71c652fac/src/TimeSteppers/TimeSteppers.jl#L177-L183).; 3. Oceananigans has have a pretty deep hierarchy of boundary conditions: BC -> Coordinate BCs -> field BCs -> Solution BCs -> Model BCs. Moving BCs to fields will eliminate the need for solution BCs and model BCs, which will create a simpler hierarchy of just BC -> coordinate BCs -> field BCs. This will make it easier to developers and users to access and interact with boundary conditions, especially as [`ModelBoundaryConditions`](https://github.com/climate-machine/Oceananigans.jl/blob/master/src/BoundaryConditions/solution_and_model_boundary_conditions.jl#L155-L177) can only grow in complexity.; 4. Storing fields in one struct and boundary conditions in another struct feels antithetical to orthogonal design. Another reason to consider having fields carry their boundary conditions around is to avoid having to build more boundary condition machinery, i.e. more [solution_and_model_boundary_conditions.jl](https://github.com/climate-machine/Oceananigans.jl/blob/master/src/BoundaryConditions/solution_and_model_boundary_conditions.jl) when new fields are added or new models are added (e.g. #605). User API may have to change as well, although I don't think we should get rid of the current `boundary_conditions` Model kwarg unless we have a better interface.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/606
https://github.com/CliMA/Oceananigans.jl/issues/606:1907,Safety,avoid,avoid,1907,"conditions (although some boundary conditions will be determined by the grid topology). I think it's a good idea that will pay off in code clarity and ease of use.; 1. Functions such as [`fill_halo_regions!`](https://github.com/climate-machine/Oceananigans.jl/blob/8d1b164881f12607748bba044afb93c71c652fac/src/BoundaryConditions/fill_halo_regions.jl#L22) will simplify as we no longer need to pass in both a field and boundary conditions, just the field itself.; 2. No need to prepare boundary condition tuples to pass to functions, for example, in [`complete_pressure_correction_step!`](https://github.com/climate-machine/Oceananigans.jl/blob/8d1b164881f12607748bba044afb93c71c652fac/src/TimeSteppers/TimeSteppers.jl#L177-L183).; 3. Oceananigans has have a pretty deep hierarchy of boundary conditions: BC -> Coordinate BCs -> field BCs -> Solution BCs -> Model BCs. Moving BCs to fields will eliminate the need for solution BCs and model BCs, which will create a simpler hierarchy of just BC -> coordinate BCs -> field BCs. This will make it easier to developers and users to access and interact with boundary conditions, especially as [`ModelBoundaryConditions`](https://github.com/climate-machine/Oceananigans.jl/blob/master/src/BoundaryConditions/solution_and_model_boundary_conditions.jl#L155-L177) can only grow in complexity.; 4. Storing fields in one struct and boundary conditions in another struct feels antithetical to orthogonal design. Another reason to consider having fields carry their boundary conditions around is to avoid having to build more boundary condition machinery, i.e. more [solution_and_model_boundary_conditions.jl](https://github.com/climate-machine/Oceananigans.jl/blob/master/src/BoundaryConditions/solution_and_model_boundary_conditions.jl) when new fields are added or new models are added (e.g. #605). User API may have to change as well, although I don't think we should get rid of the current `boundary_conditions` Model kwarg unless we have a better interface.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/606
https://github.com/CliMA/Oceananigans.jl/issues/606:1449,Security,access,access,1449,"conditions (although some boundary conditions will be determined by the grid topology). I think it's a good idea that will pay off in code clarity and ease of use.; 1. Functions such as [`fill_halo_regions!`](https://github.com/climate-machine/Oceananigans.jl/blob/8d1b164881f12607748bba044afb93c71c652fac/src/BoundaryConditions/fill_halo_regions.jl#L22) will simplify as we no longer need to pass in both a field and boundary conditions, just the field itself.; 2. No need to prepare boundary condition tuples to pass to functions, for example, in [`complete_pressure_correction_step!`](https://github.com/climate-machine/Oceananigans.jl/blob/8d1b164881f12607748bba044afb93c71c652fac/src/TimeSteppers/TimeSteppers.jl#L177-L183).; 3. Oceananigans has have a pretty deep hierarchy of boundary conditions: BC -> Coordinate BCs -> field BCs -> Solution BCs -> Model BCs. Moving BCs to fields will eliminate the need for solution BCs and model BCs, which will create a simpler hierarchy of just BC -> coordinate BCs -> field BCs. This will make it easier to developers and users to access and interact with boundary conditions, especially as [`ModelBoundaryConditions`](https://github.com/climate-machine/Oceananigans.jl/blob/master/src/BoundaryConditions/solution_and_model_boundary_conditions.jl#L155-L177) can only grow in complexity.; 4. Storing fields in one struct and boundary conditions in another struct feels antithetical to orthogonal design. Another reason to consider having fields carry their boundary conditions around is to avoid having to build more boundary condition machinery, i.e. more [solution_and_model_boundary_conditions.jl](https://github.com/climate-machine/Oceananigans.jl/blob/master/src/BoundaryConditions/solution_and_model_boundary_conditions.jl) when new fields are added or new models are added (e.g. #605). User API may have to change as well, although I don't think we should get rid of the current `boundary_conditions` Model kwarg unless we have a better interface.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/606
https://github.com/CliMA/Oceananigans.jl/issues/606:731,Usability,simpl,simplify,731,"The issue of whether fields should store their boundary conditions was brought up in #601. We've discussed this idea before but I'm opening this issue to see if this is something we want to pursue. Note: Moving boundary conditions to fields should happen alongside or after the introduce of grid topologies (#489) which would decouple the grid topology from the boundary conditions (although some boundary conditions will be determined by the grid topology). I think it's a good idea that will pay off in code clarity and ease of use.; 1. Functions such as [`fill_halo_regions!`](https://github.com/climate-machine/Oceananigans.jl/blob/8d1b164881f12607748bba044afb93c71c652fac/src/BoundaryConditions/fill_halo_regions.jl#L22) will simplify as we no longer need to pass in both a field and boundary conditions, just the field itself.; 2. No need to prepare boundary condition tuples to pass to functions, for example, in [`complete_pressure_correction_step!`](https://github.com/climate-machine/Oceananigans.jl/blob/8d1b164881f12607748bba044afb93c71c652fac/src/TimeSteppers/TimeSteppers.jl#L177-L183).; 3. Oceananigans has have a pretty deep hierarchy of boundary conditions: BC -> Coordinate BCs -> field BCs -> Solution BCs -> Model BCs. Moving BCs to fields will eliminate the need for solution BCs and model BCs, which will create a simpler hierarchy of just BC -> coordinate BCs -> field BCs. This will make it easier to developers and users to access and interact with boundary conditions, especially as [`ModelBoundaryConditions`](https://github.com/climate-machine/Oceananigans.jl/blob/master/src/BoundaryConditions/solution_and_model_boundary_conditions.jl#L155-L177) can only grow in complexity.; 4. Storing fields in one struct and boundary conditions in another struct feels antithetical to orthogonal design. Another reason to consider having fields carry their boundary conditions around is to avoid having to build more boundary condition machinery, i.e. more [solution_and_model_boundar",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/606
https://github.com/CliMA/Oceananigans.jl/issues/606:1336,Usability,simpl,simpler,1336,"ch would decouple the grid topology from the boundary conditions (although some boundary conditions will be determined by the grid topology). I think it's a good idea that will pay off in code clarity and ease of use.; 1. Functions such as [`fill_halo_regions!`](https://github.com/climate-machine/Oceananigans.jl/blob/8d1b164881f12607748bba044afb93c71c652fac/src/BoundaryConditions/fill_halo_regions.jl#L22) will simplify as we no longer need to pass in both a field and boundary conditions, just the field itself.; 2. No need to prepare boundary condition tuples to pass to functions, for example, in [`complete_pressure_correction_step!`](https://github.com/climate-machine/Oceananigans.jl/blob/8d1b164881f12607748bba044afb93c71c652fac/src/TimeSteppers/TimeSteppers.jl#L177-L183).; 3. Oceananigans has have a pretty deep hierarchy of boundary conditions: BC -> Coordinate BCs -> field BCs -> Solution BCs -> Model BCs. Moving BCs to fields will eliminate the need for solution BCs and model BCs, which will create a simpler hierarchy of just BC -> coordinate BCs -> field BCs. This will make it easier to developers and users to access and interact with boundary conditions, especially as [`ModelBoundaryConditions`](https://github.com/climate-machine/Oceananigans.jl/blob/master/src/BoundaryConditions/solution_and_model_boundary_conditions.jl#L155-L177) can only grow in complexity.; 4. Storing fields in one struct and boundary conditions in another struct feels antithetical to orthogonal design. Another reason to consider having fields carry their boundary conditions around is to avoid having to build more boundary condition machinery, i.e. more [solution_and_model_boundary_conditions.jl](https://github.com/climate-machine/Oceananigans.jl/blob/master/src/BoundaryConditions/solution_and_model_boundary_conditions.jl) when new fields are added or new models are added (e.g. #605). User API may have to change as well, although I don't think we should get rid of the current `boundary_cond",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/606
https://github.com/CliMA/Oceananigans.jl/issues/607:6,Performance,perform,performance,6,> The performance plots on the README.md file show that the single precision speed up for CPUs is below 1. This is surprising and should be commented on.; >; > _Originally posted by @funsim in https://github.com/openjournals/joss-reviews/issues/2018#issuecomment-580286479_,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/607
https://github.com/CliMA/Oceananigans.jl/issues/608:14,Testability,benchmark,benchmarks,14,> The link to benchmarks.jl in the README.md file is broken.; >; > _Originally posted by @funsim in https://github.com/openjournals/joss-reviews/issues/2018#issuecomment-580286479_,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/608
https://github.com/CliMA/Oceananigans.jl/issues/611:209,Energy Efficiency,Green,Green,209,> It seems that you have not performed a convergence test of your numerical model (based on analytical known solutions or manufactured solutions). I suggest that you add this (for instance based on the Taylor Green example); >; > _Originally posted by @funsim in https://github.com/openjournals/joss-reviews/issues/2018#issuecomment-580286479_,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/611
https://github.com/CliMA/Oceananigans.jl/issues/611:29,Performance,perform,performed,29,> It seems that you have not performed a convergence test of your numerical model (based on analytical known solutions or manufactured solutions). I suggest that you add this (for instance based on the Taylor Green example); >; > _Originally posted by @funsim in https://github.com/openjournals/joss-reviews/issues/2018#issuecomment-580286479_,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/611
https://github.com/CliMA/Oceananigans.jl/issues/611:53,Testability,test,test,53,> It seems that you have not performed a convergence test of your numerical model (based on analytical known solutions or manufactured solutions). I suggest that you add this (for instance based on the Taylor Green example); >; > _Originally posted by @funsim in https://github.com/openjournals/joss-reviews/issues/2018#issuecomment-580286479_,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/611
https://github.com/CliMA/Oceananigans.jl/pull/612:5,Availability,error,error,5,"This error may not be consequential for any work we've done so far because it amounts to changing an irrelevant 'gauge condition' on the pressure in many cases. It does impact set-ups with vertically stretched grids, and it may impact set-ups that specify a horizontal buoyancy gradient at the surface. None of the regression tests deal with such scenarios.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/612
https://github.com/CliMA/Oceananigans.jl/pull/612:326,Testability,test,tests,326,"This error may not be consequential for any work we've done so far because it amounts to changing an irrelevant 'gauge condition' on the pressure in many cases. It does impact set-ups with vertically stretched grids, and it may impact set-ups that specify a horizontal buoyancy gradient at the surface. None of the regression tests deal with such scenarios.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/612
https://github.com/CliMA/Oceananigans.jl/pull/614:411,Deployability,update,updated,411,"This PR adds grid topologies: `Periodic`, `Bounded`, and `Singleton`. We should finalize our choice of named before merging. As `topology` is now a required kwarg of all grid constructors tons of refactoring was needed. It also does a bit of cleanup: `AbstractGrid` is now defined in the Grids submodule, and grids no longer have the `Tx, Ty, Tz` property (total number of grid points). Documentation should be updated before this PR is merged. Resolves #446 ; Resolves #459; Resolves #489",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/614
https://github.com/CliMA/Oceananigans.jl/pull/614:196,Modifiability,refactor,refactoring,196,"This PR adds grid topologies: `Periodic`, `Bounded`, and `Singleton`. We should finalize our choice of named before merging. As `topology` is now a required kwarg of all grid constructors tons of refactoring was needed. It also does a bit of cleanup: `AbstractGrid` is now defined in the Grids submodule, and grids no longer have the `Tx, Ty, Tz` property (total number of grid points). Documentation should be updated before this PR is merged. Resolves #446 ; Resolves #459; Resolves #489",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/614
https://github.com/CliMA/Oceananigans.jl/issues/615:669,Performance,perform,performance,669,"In PR #590 [WIP] I've prototyped how I've thought about adding support for distributed parallelism by adding a non-invasive `Distributed` MPI layer on top of Oceananigans to keep the core code MPI-free. At last week's CliMA software meeting @lcw and @jkozdon have pointed out a potential limitation of this approach: when running on many nodes and communication starts to eat up a lot of compute time it becomes beneficial to overlap computation and communication. Abstractions such as `CLIMA.MPIStateArray` help a lot with this but require MPI to be ""baked in"". Obviously this issue won't be tackled for a while until we have a working distributed model and need more performance, so I'm just documenting the issue here for future discussion. I think we can achieve this by splitting a kernel like `calculate_interior_source_terms!` into two kernels, one that computes source terms ""near"" the boundary (1-2? grid points from any boundary as needed), then halo communication can happen while a second more compute-intensive kernel computes the source terms in the rest of the interior. But that only helps with one particular instance of halo communication. There will be other halo communications needed that may be impossible to overlap with compute-intensive kernels. Pursuing overlapping in this manner to the extreme and applying it to as many kernels as possible may be detrimental to code clarity. Once we want more distributed performance we should go through the algorithm and minimize the number of halo communications (i.e. calls to `fill_halo_regions!`). cc @leios @jm-c; ```[tasklist]; ### Tasks; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/615
https://github.com/CliMA/Oceananigans.jl/issues/615:1435,Performance,perform,performance,1435,"In PR #590 [WIP] I've prototyped how I've thought about adding support for distributed parallelism by adding a non-invasive `Distributed` MPI layer on top of Oceananigans to keep the core code MPI-free. At last week's CliMA software meeting @lcw and @jkozdon have pointed out a potential limitation of this approach: when running on many nodes and communication starts to eat up a lot of compute time it becomes beneficial to overlap computation and communication. Abstractions such as `CLIMA.MPIStateArray` help a lot with this but require MPI to be ""baked in"". Obviously this issue won't be tackled for a while until we have a working distributed model and need more performance, so I'm just documenting the issue here for future discussion. I think we can achieve this by splitting a kernel like `calculate_interior_source_terms!` into two kernels, one that computes source terms ""near"" the boundary (1-2? grid points from any boundary as needed), then halo communication can happen while a second more compute-intensive kernel computes the source terms in the rest of the interior. But that only helps with one particular instance of halo communication. There will be other halo communications needed that may be impossible to overlap with compute-intensive kernels. Pursuing overlapping in this manner to the extreme and applying it to as many kernels as possible may be detrimental to code clarity. Once we want more distributed performance we should go through the algorithm and minimize the number of halo communications (i.e. calls to `fill_halo_regions!`). cc @leios @jm-c; ```[tasklist]; ### Tasks; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/615
https://github.com/CliMA/Oceananigans.jl/pull/617:132,Deployability,update,updates,132,"This PR changes the names of the `y` and `z` components of the rotation vector for the non-traditional f-plane to `fy` and `fz`. It updates the tests and documentation. It also adds a section about the non-traditional f-plane approximation to the ""physics"" section of the documentation.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/617
https://github.com/CliMA/Oceananigans.jl/pull/617:144,Testability,test,tests,144,"This PR changes the names of the `y` and `z` components of the rotation vector for the non-traditional f-plane to `fy` and `fz`. It updates the tests and documentation. It also adds a section about the non-traditional f-plane approximation to the ""physics"" section of the documentation.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/617
https://github.com/CliMA/Oceananigans.jl/pull/619:129,Deployability,install,installed,129,"You're receiving this pull request because the now-deprecated [Julia TagBot GitHub App](https://github.com/apps/julia-tagbot) is installed for this repository. This pull request installs [TagBot as a GitHub Action](https://github.com/marketplace/actions/julia-tagbot).; If this PR does not belong in this repository for any reason, feel free to close it. See [this Discourse thread](https://discourse.julialang.org/t/ann-the-tagbot-github-app-is-deprecated-in-favour-of-the-tagbot-github-action/34344) for more details and to ask questions.; Please do not comment on this pull request, because it is unlikely that I (`@christopher-dG`) will see it.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/619
https://github.com/CliMA/Oceananigans.jl/pull/619:178,Deployability,install,installs,178,"You're receiving this pull request because the now-deprecated [Julia TagBot GitHub App](https://github.com/apps/julia-tagbot) is installed for this repository. This pull request installs [TagBot as a GitHub Action](https://github.com/marketplace/actions/julia-tagbot).; If this PR does not belong in this repository for any reason, feel free to close it. See [this Discourse thread](https://discourse.julialang.org/t/ann-the-tagbot-github-app-is-deprecated-in-favour-of-the-tagbot-github-action/34344) for more details and to ask questions.; Please do not comment on this pull request, because it is unlikely that I (`@christopher-dG`) will see it.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/619
https://github.com/CliMA/Oceananigans.jl/pull/620:291,Modifiability,refactor,refactoring,291,"This PR aims to create a single `FieldBoundaryConditions` function to replace `HorizontallyPeriodicBCs` and `ChannelBCs`. This paves the way for boundary conditions to become a `Field` property (#606). It's a pretty big breaking change so would be good to agree on the design and API before refactoring. Side note: Ideally we would set `default_bc(::Flat) = nothing` but until we elide operations and halo filling along `Flat` dimensions, I think we should use `default_bc(::Flat) = PeriodicBC()`. @glwagner Let me know if this looks like what we discussed. If so, I'll go ahead and change all the tests and examples to use it instead of `HorizontallyPeriodicBCs` and `ChannelBCs`. Reminder to self: Documentation, especially model setup, will have to be revised as part of this PR.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/620
https://github.com/CliMA/Oceananigans.jl/pull/620:598,Testability,test,tests,598,"This PR aims to create a single `FieldBoundaryConditions` function to replace `HorizontallyPeriodicBCs` and `ChannelBCs`. This paves the way for boundary conditions to become a `Field` property (#606). It's a pretty big breaking change so would be good to agree on the design and API before refactoring. Side note: Ideally we would set `default_bc(::Flat) = nothing` but until we elide operations and halo filling along `Flat` dimensions, I think we should use `default_bc(::Flat) = PeriodicBC()`. @glwagner Let me know if this looks like what we discussed. If so, I'll go ahead and change all the tests and examples to use it instead of `HorizontallyPeriodicBCs` and `ChannelBCs`. Reminder to self: Documentation, especially model setup, will have to be revised as part of this PR.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/620
https://github.com/CliMA/Oceananigans.jl/pull/621:84,Integrability,interface,interface,84,"This PR introduces a `Simulation` type that manages time stepping with a high level interface. I think `diagnostics` and `output_writers` will have to become keyword arguments to `time_step!`. It will be a pretty big breaking change once we move `diagnostics` and `output_writers` outside of `Model` so would be good to agree on the design and API before refactoring. @glwagner Let me know what you think, we can iterate on the design in this PR. Resolves #432 ; Resolves #447",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/621
https://github.com/CliMA/Oceananigans.jl/pull/621:355,Modifiability,refactor,refactoring,355,"This PR introduces a `Simulation` type that manages time stepping with a high level interface. I think `diagnostics` and `output_writers` will have to become keyword arguments to `time_step!`. It will be a pretty big breaking change once we move `diagnostics` and `output_writers` outside of `Model` so would be good to agree on the design and API before refactoring. @glwagner Let me know what you think, we can iterate on the design in this PR. Resolves #432 ; Resolves #447",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/621
https://github.com/CliMA/Oceananigans.jl/pull/622:141,Usability,simpl,simplicity,141,"This PR differentiates the AMD model constants for eddy viscosity and eddy diffusivity, and permits them to be functions of `x, y, z`. . For simplicity we will permit just one model constant specification for all tracers. It is possible to permit different constants for different tracers, but . Also, with this PR the ""Verstappen"" implementation of AMD is now diverging from the ""Rozema"" implementation. It may be time to nuke the ""Rozema"" implementation.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/622
https://github.com/CliMA/Oceananigans.jl/issues/625:541,Deployability,release,release,541,"With Julia 1.3 comes Julia library (JLL) packages which packages are starting to depend on, such as FFTW.jl v1.2.0. See this blog post for more info: https://julialang.org/blog/2019/11/artifacts/. But this requires Julia 1.3 so as of right now I've pegged Oceananigans.jl to FFTW.jl v1.1.0, an older version to keep Oceananigans.jl compatible with Julia 1.1+ as our README and docs state. Should we embrace Julia 1.3 so we can keep up to date with all the latest packages?. Note: We already do not support the latest long term support (LTS) release v1.0.5 so we might as well upgrade our requirements to the latest stable release (v.1.3+).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/625
https://github.com/CliMA/Oceananigans.jl/issues/625:576,Deployability,upgrade,upgrade,576,"With Julia 1.3 comes Julia library (JLL) packages which packages are starting to depend on, such as FFTW.jl v1.2.0. See this blog post for more info: https://julialang.org/blog/2019/11/artifacts/. But this requires Julia 1.3 so as of right now I've pegged Oceananigans.jl to FFTW.jl v1.1.0, an older version to keep Oceananigans.jl compatible with Julia 1.1+ as our README and docs state. Should we embrace Julia 1.3 so we can keep up to date with all the latest packages?. Note: We already do not support the latest long term support (LTS) release v1.0.5 so we might as well upgrade our requirements to the latest stable release (v.1.3+).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/625
https://github.com/CliMA/Oceananigans.jl/issues/625:622,Deployability,release,release,622,"With Julia 1.3 comes Julia library (JLL) packages which packages are starting to depend on, such as FFTW.jl v1.2.0. See this blog post for more info: https://julialang.org/blog/2019/11/artifacts/. But this requires Julia 1.3 so as of right now I've pegged Oceananigans.jl to FFTW.jl v1.1.0, an older version to keep Oceananigans.jl compatible with Julia 1.1+ as our README and docs state. Should we embrace Julia 1.3 so we can keep up to date with all the latest packages?. Note: We already do not support the latest long term support (LTS) release v1.0.5 so we might as well upgrade our requirements to the latest stable release (v.1.3+).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/625
https://github.com/CliMA/Oceananigans.jl/issues/625:81,Integrability,depend,depend,81,"With Julia 1.3 comes Julia library (JLL) packages which packages are starting to depend on, such as FFTW.jl v1.2.0. See this blog post for more info: https://julialang.org/blog/2019/11/artifacts/. But this requires Julia 1.3 so as of right now I've pegged Oceananigans.jl to FFTW.jl v1.1.0, an older version to keep Oceananigans.jl compatible with Julia 1.1+ as our README and docs state. Should we embrace Julia 1.3 so we can keep up to date with all the latest packages?. Note: We already do not support the latest long term support (LTS) release v1.0.5 so we might as well upgrade our requirements to the latest stable release (v.1.3+).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/625
https://github.com/CliMA/Oceananigans.jl/pull/627:200,Availability,checkpoint,checkpointer,200,"This PR is part 1/3 of making boundary conditions a field property. I was refactoring the fields module, and in doing so I added optional kwargs to allow for data arrays to be passed. This allows the checkpointer to be simplified as it no longer has to keep track of array references, and makes restoring/checkpointing large models possible. I will address this in part 2. Changes:. 1. `AbstractLocatedField` has been removed. Now there is only `AbstractField`. 2. Fields can now be initialized with a data array. This will make restoring/checkpointing large models possible. Right now `field.data` can store anything. We could check to make sure that `field.data` has the same size as the grid, but this is extra code and could limit flexibility in the future so I did not add a check for this. 3. Field tuple initializers (`VelocityFields`, `TracerFields`, etc.) can now accept data arrays through keyword arguments. 4. `FaceFieldX` has been renamed to `XFaceField`, and same for y and z. Note: This PR branches off #626.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/627
https://github.com/CliMA/Oceananigans.jl/pull/627:305,Availability,checkpoint,checkpointing,305,"This PR is part 1/3 of making boundary conditions a field property. I was refactoring the fields module, and in doing so I added optional kwargs to allow for data arrays to be passed. This allows the checkpointer to be simplified as it no longer has to keep track of array references, and makes restoring/checkpointing large models possible. I will address this in part 2. Changes:. 1. `AbstractLocatedField` has been removed. Now there is only `AbstractField`. 2. Fields can now be initialized with a data array. This will make restoring/checkpointing large models possible. Right now `field.data` can store anything. We could check to make sure that `field.data` has the same size as the grid, but this is extra code and could limit flexibility in the future so I did not add a check for this. 3. Field tuple initializers (`VelocityFields`, `TracerFields`, etc.) can now accept data arrays through keyword arguments. 4. `FaceFieldX` has been renamed to `XFaceField`, and same for y and z. Note: This PR branches off #626.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/627
https://github.com/CliMA/Oceananigans.jl/pull/627:539,Availability,checkpoint,checkpointing,539,"This PR is part 1/3 of making boundary conditions a field property. I was refactoring the fields module, and in doing so I added optional kwargs to allow for data arrays to be passed. This allows the checkpointer to be simplified as it no longer has to keep track of array references, and makes restoring/checkpointing large models possible. I will address this in part 2. Changes:. 1. `AbstractLocatedField` has been removed. Now there is only `AbstractField`. 2. Fields can now be initialized with a data array. This will make restoring/checkpointing large models possible. Right now `field.data` can store anything. We could check to make sure that `field.data` has the same size as the grid, but this is extra code and could limit flexibility in the future so I did not add a check for this. 3. Field tuple initializers (`VelocityFields`, `TracerFields`, etc.) can now accept data arrays through keyword arguments. 4. `FaceFieldX` has been renamed to `XFaceField`, and same for y and z. Note: This PR branches off #626.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/627
https://github.com/CliMA/Oceananigans.jl/pull/627:74,Modifiability,refactor,refactoring,74,"This PR is part 1/3 of making boundary conditions a field property. I was refactoring the fields module, and in doing so I added optional kwargs to allow for data arrays to be passed. This allows the checkpointer to be simplified as it no longer has to keep track of array references, and makes restoring/checkpointing large models possible. I will address this in part 2. Changes:. 1. `AbstractLocatedField` has been removed. Now there is only `AbstractField`. 2. Fields can now be initialized with a data array. This will make restoring/checkpointing large models possible. Right now `field.data` can store anything. We could check to make sure that `field.data` has the same size as the grid, but this is extra code and could limit flexibility in the future so I did not add a check for this. 3. Field tuple initializers (`VelocityFields`, `TracerFields`, etc.) can now accept data arrays through keyword arguments. 4. `FaceFieldX` has been renamed to `XFaceField`, and same for y and z. Note: This PR branches off #626.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/627
https://github.com/CliMA/Oceananigans.jl/pull/627:219,Usability,simpl,simplified,219,"This PR is part 1/3 of making boundary conditions a field property. I was refactoring the fields module, and in doing so I added optional kwargs to allow for data arrays to be passed. This allows the checkpointer to be simplified as it no longer has to keep track of array references, and makes restoring/checkpointing large models possible. I will address this in part 2. Changes:. 1. `AbstractLocatedField` has been removed. Now there is only `AbstractField`. 2. Fields can now be initialized with a data array. This will make restoring/checkpointing large models possible. Right now `field.data` can store anything. We could check to make sure that `field.data` has the same size as the grid, but this is extra code and could limit flexibility in the future so I did not add a check for this. 3. Field tuple initializers (`VelocityFields`, `TracerFields`, etc.) can now accept data arrays through keyword arguments. 4. `FaceFieldX` has been renamed to `XFaceField`, and same for y and z. Note: This PR branches off #626.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/627
https://github.com/CliMA/Oceananigans.jl/pull/628:29,Availability,checkpoint,checkpointer,29,This PR finally upgrades the checkpointer so it can restore large models that take up more than 50% of system memory. It used to create a model then restore the fields which allocates twice as much memory as needed. Now the data needed to restore the fields is passed to the model constructor so no double allocation. Some refactoring had to happen to make this possible. This PR is also part 2/3 of making boundary conditions a field property. Should help a lot with #602 and #603. Resolves #416; Resolves #417. Note: This PR branches off #627.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/628
https://github.com/CliMA/Oceananigans.jl/pull/628:16,Deployability,upgrade,upgrades,16,This PR finally upgrades the checkpointer so it can restore large models that take up more than 50% of system memory. It used to create a model then restore the fields which allocates twice as much memory as needed. Now the data needed to restore the fields is passed to the model constructor so no double allocation. Some refactoring had to happen to make this possible. This PR is also part 2/3 of making boundary conditions a field property. Should help a lot with #602 and #603. Resolves #416; Resolves #417. Note: This PR branches off #627.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/628
https://github.com/CliMA/Oceananigans.jl/pull/628:174,Energy Efficiency,allocate,allocates,174,This PR finally upgrades the checkpointer so it can restore large models that take up more than 50% of system memory. It used to create a model then restore the fields which allocates twice as much memory as needed. Now the data needed to restore the fields is passed to the model constructor so no double allocation. Some refactoring had to happen to make this possible. This PR is also part 2/3 of making boundary conditions a field property. Should help a lot with #602 and #603. Resolves #416; Resolves #417. Note: This PR branches off #627.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/628
https://github.com/CliMA/Oceananigans.jl/pull/628:323,Modifiability,refactor,refactoring,323,This PR finally upgrades the checkpointer so it can restore large models that take up more than 50% of system memory. It used to create a model then restore the fields which allocates twice as much memory as needed. Now the data needed to restore the fields is passed to the model constructor so no double allocation. Some refactoring had to happen to make this possible. This PR is also part 2/3 of making boundary conditions a field property. Should help a lot with #602 and #603. Resolves #416; Resolves #417. Note: This PR branches off #627.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/628
https://github.com/CliMA/Oceananigans.jl/pull/631:2219,Availability,checkpoint,checkpoint,2219,"ion(), boundary_conditions=model_bcs; ); ```. Internally: No surprise, this change ended up being pretty invasive. But note that we now have a more flexible and easier to use package with fewer lines of code!. I'm happy to discuss and iterate over the choices that were made in this PR. But glad that I was able to make these changes. Development of the compressible model can continue based on this branch. Changes:; 1. Fields has a new property: `field.boundary_conditions`. 2. Better pretty printing for fields:; ```; Field located at (Cell, Cell, Cell); ├── data: OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, size: (18, 18, 18); ├── grid: RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}(Nx=16, Ny=16, Nz=16); └── boundary conditions: x=(west=Periodic, east=Periodic), y=(south=Periodic, north=Periodic), z=(bottom=NoFlux, top=NoFlux); ```. 3. Field tuple constructors have two versions now. One that accepts boundary conditions (useful in model constructors) and another that accepts full fields (useful for checkpoint restoration and other custom functionality). 4. ~~You can pass anything into `VelocityFields` and `TracerFields`. Perhaps we should check whether everything passed into these functions is a `Field` or `AbstractField`. But for now that's extra code and it's not an exported function so I'm okay leaving it as is (we might want the flexibility in the future?).~~ A check was added in #627. 5. Model no longer has the `boundary_conditions` property. 6. There is no need for `SolutionBoundaryConditions` and `ModelBoundaryConditions` anymore: code is simpler :tada:. 7. `TurbulentDiffusivities` has been renamed to `DiffusivityFields` for consistency with `VelocityFields` and `TracerFields`, etc. 8. For each turbulence closure, `DiffusivityFields` gets the same two versions (one if you want control over the full field, another if you just want to set boundary conditions). 9. Halo filling and parts of the time stepping have been simplified as there is no ne",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/631
https://github.com/CliMA/Oceananigans.jl/pull/631:3939,Availability,checkpoint,checkpointer,3939,"op=NoFlux); ```. 3. Field tuple constructors have two versions now. One that accepts boundary conditions (useful in model constructors) and another that accepts full fields (useful for checkpoint restoration and other custom functionality). 4. ~~You can pass anything into `VelocityFields` and `TracerFields`. Perhaps we should check whether everything passed into these functions is a `Field` or `AbstractField`. But for now that's extra code and it's not an exported function so I'm okay leaving it as is (we might want the flexibility in the future?).~~ A check was added in #627. 5. Model no longer has the `boundary_conditions` property. 6. There is no need for `SolutionBoundaryConditions` and `ModelBoundaryConditions` anymore: code is simpler :tada:. 7. `TurbulentDiffusivities` has been renamed to `DiffusivityFields` for consistency with `VelocityFields` and `TracerFields`, etc. 8. For each turbulence closure, `DiffusivityFields` gets the same two versions (one if you want control over the full field, another if you just want to set boundary conditions). 9. Halo filling and parts of the time stepping have been simplified as there is no need to juggle around and bundle up boundary conditions. Some comments:; 1. It's not clear whether fields for abstract operations should have boundary conditions as they don't have halos and we don't impose boundary conditions on them. Do we want to generally set their boundary conditions to `nothing`? I did this for the abstract operations tests and they all passed.; 2. We could further simplify the time stepping code if we adapt the `Field` abstraction to be GPU compatible (#298).; 3. This is probably an edge case but I don't think setting diffusivity BCs when using a tuple of closures will actually work. Or rather, I'm not sure how to specify two different diffusivity BCs, one for each closure.; 4. Before merging I still need to update the checkpointer and update the documentation. Resolves #606. Note: This PR branches off from #628.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/631
https://github.com/CliMA/Oceananigans.jl/pull/631:19,Deployability,upgrade,upgrades,19,"This PR (part 3/3) upgrades the field abstraction so fields store their own boundary conditions. This simplifies the model boundary condition hierarchy and generalizes the field and boundary conditions abstractions so they can be used for a compressible model (and any other model we come up with in the future). All future fields will have boundary conditions so PRs like #601 won't be necessary again. The only change in user interface is that you pass a named tuple to the model constructor now instead of an instance of `SolutionBoundaryConditions`. This also works for LES diffusivities so the amount of convoluted scripting gymnastics is much reduced (see test from #601). Setting a diffusivity BC is now almost as easy as a tracer BC. ```julia; grid = RegularCartesianGrid(FT, size=(16, 16, 16), length=(1, 1, 1)). buoyancy_bcs = TracerBoundaryConditions(grid, bottom=BoundaryCondition(Gradient, bz)); κₑ_bcs = DiffusivityBoundaryConditions(grid, bottom=BoundaryCondition(Value, κ₀)); model_bcs = (b=buoyancy_bcs, κₑ=(b=κₑ_bcs,)). model = IncompressibleModel(; grid=grid, architecture=arch, float_type=FT, tracers=:b, buoyancy=BuoyancyTracer(),; closure=AnisotropicMinimumDissipation(), boundary_conditions=model_bcs; ); ```. Internally: No surprise, this change ended up being pretty invasive. But note that we now have a more flexible and easier to use package with fewer lines of code!. I'm happy to discuss and iterate over the choices that were made in this PR. But glad that I was able to make these changes. Development of the compressible model can continue based on this branch. Changes:; 1. Fields has a new property: `field.boundary_conditions`. 2. Better pretty printing for fields:; ```; Field located at (Cell, Cell, Cell); ├── data: OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, size: (18, 18, 18); ├── grid: RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}(Nx=16, Ny=16, Nz=16); └── boundary conditions: x=(west=Periodic, east=Periodic), y=(south=Periodic, nor",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/631
https://github.com/CliMA/Oceananigans.jl/pull/631:3928,Deployability,update,update,3928,"op=NoFlux); ```. 3. Field tuple constructors have two versions now. One that accepts boundary conditions (useful in model constructors) and another that accepts full fields (useful for checkpoint restoration and other custom functionality). 4. ~~You can pass anything into `VelocityFields` and `TracerFields`. Perhaps we should check whether everything passed into these functions is a `Field` or `AbstractField`. But for now that's extra code and it's not an exported function so I'm okay leaving it as is (we might want the flexibility in the future?).~~ A check was added in #627. 5. Model no longer has the `boundary_conditions` property. 6. There is no need for `SolutionBoundaryConditions` and `ModelBoundaryConditions` anymore: code is simpler :tada:. 7. `TurbulentDiffusivities` has been renamed to `DiffusivityFields` for consistency with `VelocityFields` and `TracerFields`, etc. 8. For each turbulence closure, `DiffusivityFields` gets the same two versions (one if you want control over the full field, another if you just want to set boundary conditions). 9. Halo filling and parts of the time stepping have been simplified as there is no need to juggle around and bundle up boundary conditions. Some comments:; 1. It's not clear whether fields for abstract operations should have boundary conditions as they don't have halos and we don't impose boundary conditions on them. Do we want to generally set their boundary conditions to `nothing`? I did this for the abstract operations tests and they all passed.; 2. We could further simplify the time stepping code if we adapt the `Field` abstraction to be GPU compatible (#298).; 3. This is probably an edge case but I don't think setting diffusivity BCs when using a tuple of closures will actually work. Or rather, I'm not sure how to specify two different diffusivity BCs, one for each closure.; 4. Before merging I still need to update the checkpointer and update the documentation. Resolves #606. Note: This PR branches off from #628.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/631
https://github.com/CliMA/Oceananigans.jl/pull/631:3956,Deployability,update,update,3956,"op=NoFlux); ```. 3. Field tuple constructors have two versions now. One that accepts boundary conditions (useful in model constructors) and another that accepts full fields (useful for checkpoint restoration and other custom functionality). 4. ~~You can pass anything into `VelocityFields` and `TracerFields`. Perhaps we should check whether everything passed into these functions is a `Field` or `AbstractField`. But for now that's extra code and it's not an exported function so I'm okay leaving it as is (we might want the flexibility in the future?).~~ A check was added in #627. 5. Model no longer has the `boundary_conditions` property. 6. There is no need for `SolutionBoundaryConditions` and `ModelBoundaryConditions` anymore: code is simpler :tada:. 7. `TurbulentDiffusivities` has been renamed to `DiffusivityFields` for consistency with `VelocityFields` and `TracerFields`, etc. 8. For each turbulence closure, `DiffusivityFields` gets the same two versions (one if you want control over the full field, another if you just want to set boundary conditions). 9. Halo filling and parts of the time stepping have been simplified as there is no need to juggle around and bundle up boundary conditions. Some comments:; 1. It's not clear whether fields for abstract operations should have boundary conditions as they don't have halos and we don't impose boundary conditions on them. Do we want to generally set their boundary conditions to `nothing`? I did this for the abstract operations tests and they all passed.; 2. We could further simplify the time stepping code if we adapt the `Field` abstraction to be GPU compatible (#298).; 3. This is probably an edge case but I don't think setting diffusivity BCs when using a tuple of closures will actually work. Or rather, I'm not sure how to specify two different diffusivity BCs, one for each closure.; 4. Before merging I still need to update the checkpointer and update the documentation. Resolves #606. Note: This PR branches off from #628.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/631
https://github.com/CliMA/Oceananigans.jl/pull/631:649,Energy Efficiency,reduce,reduced,649,"This PR (part 3/3) upgrades the field abstraction so fields store their own boundary conditions. This simplifies the model boundary condition hierarchy and generalizes the field and boundary conditions abstractions so they can be used for a compressible model (and any other model we come up with in the future). All future fields will have boundary conditions so PRs like #601 won't be necessary again. The only change in user interface is that you pass a named tuple to the model constructor now instead of an instance of `SolutionBoundaryConditions`. This also works for LES diffusivities so the amount of convoluted scripting gymnastics is much reduced (see test from #601). Setting a diffusivity BC is now almost as easy as a tracer BC. ```julia; grid = RegularCartesianGrid(FT, size=(16, 16, 16), length=(1, 1, 1)). buoyancy_bcs = TracerBoundaryConditions(grid, bottom=BoundaryCondition(Gradient, bz)); κₑ_bcs = DiffusivityBoundaryConditions(grid, bottom=BoundaryCondition(Value, κ₀)); model_bcs = (b=buoyancy_bcs, κₑ=(b=κₑ_bcs,)). model = IncompressibleModel(; grid=grid, architecture=arch, float_type=FT, tracers=:b, buoyancy=BuoyancyTracer(),; closure=AnisotropicMinimumDissipation(), boundary_conditions=model_bcs; ); ```. Internally: No surprise, this change ended up being pretty invasive. But note that we now have a more flexible and easier to use package with fewer lines of code!. I'm happy to discuss and iterate over the choices that were made in this PR. But glad that I was able to make these changes. Development of the compressible model can continue based on this branch. Changes:; 1. Fields has a new property: `field.boundary_conditions`. 2. Better pretty printing for fields:; ```; Field located at (Cell, Cell, Cell); ├── data: OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, size: (18, 18, 18); ├── grid: RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}(Nx=16, Ny=16, Nz=16); └── boundary conditions: x=(west=Periodic, east=Periodic), y=(south=Periodic, nor",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/631
https://github.com/CliMA/Oceananigans.jl/pull/631:3615,Energy Efficiency,adapt,adapt,3615,"op=NoFlux); ```. 3. Field tuple constructors have two versions now. One that accepts boundary conditions (useful in model constructors) and another that accepts full fields (useful for checkpoint restoration and other custom functionality). 4. ~~You can pass anything into `VelocityFields` and `TracerFields`. Perhaps we should check whether everything passed into these functions is a `Field` or `AbstractField`. But for now that's extra code and it's not an exported function so I'm okay leaving it as is (we might want the flexibility in the future?).~~ A check was added in #627. 5. Model no longer has the `boundary_conditions` property. 6. There is no need for `SolutionBoundaryConditions` and `ModelBoundaryConditions` anymore: code is simpler :tada:. 7. `TurbulentDiffusivities` has been renamed to `DiffusivityFields` for consistency with `VelocityFields` and `TracerFields`, etc. 8. For each turbulence closure, `DiffusivityFields` gets the same two versions (one if you want control over the full field, another if you just want to set boundary conditions). 9. Halo filling and parts of the time stepping have been simplified as there is no need to juggle around and bundle up boundary conditions. Some comments:; 1. It's not clear whether fields for abstract operations should have boundary conditions as they don't have halos and we don't impose boundary conditions on them. Do we want to generally set their boundary conditions to `nothing`? I did this for the abstract operations tests and they all passed.; 2. We could further simplify the time stepping code if we adapt the `Field` abstraction to be GPU compatible (#298).; 3. This is probably an edge case but I don't think setting diffusivity BCs when using a tuple of closures will actually work. Or rather, I'm not sure how to specify two different diffusivity BCs, one for each closure.; 4. Before merging I still need to update the checkpointer and update the documentation. Resolves #606. Note: This PR branches off from #628.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/631
https://github.com/CliMA/Oceananigans.jl/pull/631:428,Integrability,interface,interface,428,"This PR (part 3/3) upgrades the field abstraction so fields store their own boundary conditions. This simplifies the model boundary condition hierarchy and generalizes the field and boundary conditions abstractions so they can be used for a compressible model (and any other model we come up with in the future). All future fields will have boundary conditions so PRs like #601 won't be necessary again. The only change in user interface is that you pass a named tuple to the model constructor now instead of an instance of `SolutionBoundaryConditions`. This also works for LES diffusivities so the amount of convoluted scripting gymnastics is much reduced (see test from #601). Setting a diffusivity BC is now almost as easy as a tracer BC. ```julia; grid = RegularCartesianGrid(FT, size=(16, 16, 16), length=(1, 1, 1)). buoyancy_bcs = TracerBoundaryConditions(grid, bottom=BoundaryCondition(Gradient, bz)); κₑ_bcs = DiffusivityBoundaryConditions(grid, bottom=BoundaryCondition(Value, κ₀)); model_bcs = (b=buoyancy_bcs, κₑ=(b=κₑ_bcs,)). model = IncompressibleModel(; grid=grid, architecture=arch, float_type=FT, tracers=:b, buoyancy=BuoyancyTracer(),; closure=AnisotropicMinimumDissipation(), boundary_conditions=model_bcs; ); ```. Internally: No surprise, this change ended up being pretty invasive. But note that we now have a more flexible and easier to use package with fewer lines of code!. I'm happy to discuss and iterate over the choices that were made in this PR. But glad that I was able to make these changes. Development of the compressible model can continue based on this branch. Changes:; 1. Fields has a new property: `field.boundary_conditions`. 2. Better pretty printing for fields:; ```; Field located at (Cell, Cell, Cell); ├── data: OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, size: (18, 18, 18); ├── grid: RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}(Nx=16, Ny=16, Nz=16); └── boundary conditions: x=(west=Periodic, east=Periodic), y=(south=Periodic, nor",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/631
https://github.com/CliMA/Oceananigans.jl/pull/631:1335,Modifiability,flexible,flexible,1335,"y conditions so PRs like #601 won't be necessary again. The only change in user interface is that you pass a named tuple to the model constructor now instead of an instance of `SolutionBoundaryConditions`. This also works for LES diffusivities so the amount of convoluted scripting gymnastics is much reduced (see test from #601). Setting a diffusivity BC is now almost as easy as a tracer BC. ```julia; grid = RegularCartesianGrid(FT, size=(16, 16, 16), length=(1, 1, 1)). buoyancy_bcs = TracerBoundaryConditions(grid, bottom=BoundaryCondition(Gradient, bz)); κₑ_bcs = DiffusivityBoundaryConditions(grid, bottom=BoundaryCondition(Value, κ₀)); model_bcs = (b=buoyancy_bcs, κₑ=(b=κₑ_bcs,)). model = IncompressibleModel(; grid=grid, architecture=arch, float_type=FT, tracers=:b, buoyancy=BuoyancyTracer(),; closure=AnisotropicMinimumDissipation(), boundary_conditions=model_bcs; ); ```. Internally: No surprise, this change ended up being pretty invasive. But note that we now have a more flexible and easier to use package with fewer lines of code!. I'm happy to discuss and iterate over the choices that were made in this PR. But glad that I was able to make these changes. Development of the compressible model can continue based on this branch. Changes:; 1. Fields has a new property: `field.boundary_conditions`. 2. Better pretty printing for fields:; ```; Field located at (Cell, Cell, Cell); ├── data: OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, size: (18, 18, 18); ├── grid: RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}(Nx=16, Ny=16, Nz=16); └── boundary conditions: x=(west=Periodic, east=Periodic), y=(south=Periodic, north=Periodic), z=(bottom=NoFlux, top=NoFlux); ```. 3. Field tuple constructors have two versions now. One that accepts boundary conditions (useful in model constructors) and another that accepts full fields (useful for checkpoint restoration and other custom functionality). 4. ~~You can pass anything into `VelocityFields` and `TracerFields`. Perha",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/631
https://github.com/CliMA/Oceananigans.jl/pull/631:3615,Modifiability,adapt,adapt,3615,"op=NoFlux); ```. 3. Field tuple constructors have two versions now. One that accepts boundary conditions (useful in model constructors) and another that accepts full fields (useful for checkpoint restoration and other custom functionality). 4. ~~You can pass anything into `VelocityFields` and `TracerFields`. Perhaps we should check whether everything passed into these functions is a `Field` or `AbstractField`. But for now that's extra code and it's not an exported function so I'm okay leaving it as is (we might want the flexibility in the future?).~~ A check was added in #627. 5. Model no longer has the `boundary_conditions` property. 6. There is no need for `SolutionBoundaryConditions` and `ModelBoundaryConditions` anymore: code is simpler :tada:. 7. `TurbulentDiffusivities` has been renamed to `DiffusivityFields` for consistency with `VelocityFields` and `TracerFields`, etc. 8. For each turbulence closure, `DiffusivityFields` gets the same two versions (one if you want control over the full field, another if you just want to set boundary conditions). 9. Halo filling and parts of the time stepping have been simplified as there is no need to juggle around and bundle up boundary conditions. Some comments:; 1. It's not clear whether fields for abstract operations should have boundary conditions as they don't have halos and we don't impose boundary conditions on them. Do we want to generally set their boundary conditions to `nothing`? I did this for the abstract operations tests and they all passed.; 2. We could further simplify the time stepping code if we adapt the `Field` abstraction to be GPU compatible (#298).; 3. This is probably an edge case but I don't think setting diffusivity BCs when using a tuple of closures will actually work. Or rather, I'm not sure how to specify two different diffusivity BCs, one for each closure.; 4. Before merging I still need to update the checkpointer and update the documentation. Resolves #606. Note: This PR branches off from #628.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/631
https://github.com/CliMA/Oceananigans.jl/pull/631:662,Testability,test,test,662,"This PR (part 3/3) upgrades the field abstraction so fields store their own boundary conditions. This simplifies the model boundary condition hierarchy and generalizes the field and boundary conditions abstractions so they can be used for a compressible model (and any other model we come up with in the future). All future fields will have boundary conditions so PRs like #601 won't be necessary again. The only change in user interface is that you pass a named tuple to the model constructor now instead of an instance of `SolutionBoundaryConditions`. This also works for LES diffusivities so the amount of convoluted scripting gymnastics is much reduced (see test from #601). Setting a diffusivity BC is now almost as easy as a tracer BC. ```julia; grid = RegularCartesianGrid(FT, size=(16, 16, 16), length=(1, 1, 1)). buoyancy_bcs = TracerBoundaryConditions(grid, bottom=BoundaryCondition(Gradient, bz)); κₑ_bcs = DiffusivityBoundaryConditions(grid, bottom=BoundaryCondition(Value, κ₀)); model_bcs = (b=buoyancy_bcs, κₑ=(b=κₑ_bcs,)). model = IncompressibleModel(; grid=grid, architecture=arch, float_type=FT, tracers=:b, buoyancy=BuoyancyTracer(),; closure=AnisotropicMinimumDissipation(), boundary_conditions=model_bcs; ); ```. Internally: No surprise, this change ended up being pretty invasive. But note that we now have a more flexible and easier to use package with fewer lines of code!. I'm happy to discuss and iterate over the choices that were made in this PR. But glad that I was able to make these changes. Development of the compressible model can continue based on this branch. Changes:; 1. Fields has a new property: `field.boundary_conditions`. 2. Better pretty printing for fields:; ```; Field located at (Cell, Cell, Cell); ├── data: OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, size: (18, 18, 18); ├── grid: RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}(Nx=16, Ny=16, Nz=16); └── boundary conditions: x=(west=Periodic, east=Periodic), y=(south=Periodic, nor",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/631
https://github.com/CliMA/Oceananigans.jl/pull/631:3529,Testability,test,tests,3529,"op=NoFlux); ```. 3. Field tuple constructors have two versions now. One that accepts boundary conditions (useful in model constructors) and another that accepts full fields (useful for checkpoint restoration and other custom functionality). 4. ~~You can pass anything into `VelocityFields` and `TracerFields`. Perhaps we should check whether everything passed into these functions is a `Field` or `AbstractField`. But for now that's extra code and it's not an exported function so I'm okay leaving it as is (we might want the flexibility in the future?).~~ A check was added in #627. 5. Model no longer has the `boundary_conditions` property. 6. There is no need for `SolutionBoundaryConditions` and `ModelBoundaryConditions` anymore: code is simpler :tada:. 7. `TurbulentDiffusivities` has been renamed to `DiffusivityFields` for consistency with `VelocityFields` and `TracerFields`, etc. 8. For each turbulence closure, `DiffusivityFields` gets the same two versions (one if you want control over the full field, another if you just want to set boundary conditions). 9. Halo filling and parts of the time stepping have been simplified as there is no need to juggle around and bundle up boundary conditions. Some comments:; 1. It's not clear whether fields for abstract operations should have boundary conditions as they don't have halos and we don't impose boundary conditions on them. Do we want to generally set their boundary conditions to `nothing`? I did this for the abstract operations tests and they all passed.; 2. We could further simplify the time stepping code if we adapt the `Field` abstraction to be GPU compatible (#298).; 3. This is probably an edge case but I don't think setting diffusivity BCs when using a tuple of closures will actually work. Or rather, I'm not sure how to specify two different diffusivity BCs, one for each closure.; 4. Before merging I still need to update the checkpointer and update the documentation. Resolves #606. Note: This PR branches off from #628.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/631
https://github.com/CliMA/Oceananigans.jl/pull/631:102,Usability,simpl,simplifies,102,"This PR (part 3/3) upgrades the field abstraction so fields store their own boundary conditions. This simplifies the model boundary condition hierarchy and generalizes the field and boundary conditions abstractions so they can be used for a compressible model (and any other model we come up with in the future). All future fields will have boundary conditions so PRs like #601 won't be necessary again. The only change in user interface is that you pass a named tuple to the model constructor now instead of an instance of `SolutionBoundaryConditions`. This also works for LES diffusivities so the amount of convoluted scripting gymnastics is much reduced (see test from #601). Setting a diffusivity BC is now almost as easy as a tracer BC. ```julia; grid = RegularCartesianGrid(FT, size=(16, 16, 16), length=(1, 1, 1)). buoyancy_bcs = TracerBoundaryConditions(grid, bottom=BoundaryCondition(Gradient, bz)); κₑ_bcs = DiffusivityBoundaryConditions(grid, bottom=BoundaryCondition(Value, κ₀)); model_bcs = (b=buoyancy_bcs, κₑ=(b=κₑ_bcs,)). model = IncompressibleModel(; grid=grid, architecture=arch, float_type=FT, tracers=:b, buoyancy=BuoyancyTracer(),; closure=AnisotropicMinimumDissipation(), boundary_conditions=model_bcs; ); ```. Internally: No surprise, this change ended up being pretty invasive. But note that we now have a more flexible and easier to use package with fewer lines of code!. I'm happy to discuss and iterate over the choices that were made in this PR. But glad that I was able to make these changes. Development of the compressible model can continue based on this branch. Changes:; 1. Fields has a new property: `field.boundary_conditions`. 2. Better pretty printing for fields:; ```; Field located at (Cell, Cell, Cell); ├── data: OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, size: (18, 18, 18); ├── grid: RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}(Nx=16, Ny=16, Nz=16); └── boundary conditions: x=(west=Periodic, east=Periodic), y=(south=Periodic, nor",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/631
https://github.com/CliMA/Oceananigans.jl/pull/631:2777,Usability,simpl,simpler,2777,"l, Cell); ├── data: OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, size: (18, 18, 18); ├── grid: RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}(Nx=16, Ny=16, Nz=16); └── boundary conditions: x=(west=Periodic, east=Periodic), y=(south=Periodic, north=Periodic), z=(bottom=NoFlux, top=NoFlux); ```. 3. Field tuple constructors have two versions now. One that accepts boundary conditions (useful in model constructors) and another that accepts full fields (useful for checkpoint restoration and other custom functionality). 4. ~~You can pass anything into `VelocityFields` and `TracerFields`. Perhaps we should check whether everything passed into these functions is a `Field` or `AbstractField`. But for now that's extra code and it's not an exported function so I'm okay leaving it as is (we might want the flexibility in the future?).~~ A check was added in #627. 5. Model no longer has the `boundary_conditions` property. 6. There is no need for `SolutionBoundaryConditions` and `ModelBoundaryConditions` anymore: code is simpler :tada:. 7. `TurbulentDiffusivities` has been renamed to `DiffusivityFields` for consistency with `VelocityFields` and `TracerFields`, etc. 8. For each turbulence closure, `DiffusivityFields` gets the same two versions (one if you want control over the full field, another if you just want to set boundary conditions). 9. Halo filling and parts of the time stepping have been simplified as there is no need to juggle around and bundle up boundary conditions. Some comments:; 1. It's not clear whether fields for abstract operations should have boundary conditions as they don't have halos and we don't impose boundary conditions on them. Do we want to generally set their boundary conditions to `nothing`? I did this for the abstract operations tests and they all passed.; 2. We could further simplify the time stepping code if we adapt the `Field` abstraction to be GPU compatible (#298).; 3. This is probably an edge case but I don't think setting di",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/631
https://github.com/CliMA/Oceananigans.jl/pull/631:3160,Usability,simpl,simplified,3160,"op=NoFlux); ```. 3. Field tuple constructors have two versions now. One that accepts boundary conditions (useful in model constructors) and another that accepts full fields (useful for checkpoint restoration and other custom functionality). 4. ~~You can pass anything into `VelocityFields` and `TracerFields`. Perhaps we should check whether everything passed into these functions is a `Field` or `AbstractField`. But for now that's extra code and it's not an exported function so I'm okay leaving it as is (we might want the flexibility in the future?).~~ A check was added in #627. 5. Model no longer has the `boundary_conditions` property. 6. There is no need for `SolutionBoundaryConditions` and `ModelBoundaryConditions` anymore: code is simpler :tada:. 7. `TurbulentDiffusivities` has been renamed to `DiffusivityFields` for consistency with `VelocityFields` and `TracerFields`, etc. 8. For each turbulence closure, `DiffusivityFields` gets the same two versions (one if you want control over the full field, another if you just want to set boundary conditions). 9. Halo filling and parts of the time stepping have been simplified as there is no need to juggle around and bundle up boundary conditions. Some comments:; 1. It's not clear whether fields for abstract operations should have boundary conditions as they don't have halos and we don't impose boundary conditions on them. Do we want to generally set their boundary conditions to `nothing`? I did this for the abstract operations tests and they all passed.; 2. We could further simplify the time stepping code if we adapt the `Field` abstraction to be GPU compatible (#298).; 3. This is probably an edge case but I don't think setting diffusivity BCs when using a tuple of closures will actually work. Or rather, I'm not sure how to specify two different diffusivity BCs, one for each closure.; 4. Before merging I still need to update the checkpointer and update the documentation. Resolves #606. Note: This PR branches off from #628.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/631
https://github.com/CliMA/Oceananigans.jl/pull/631:3271,Usability,clear,clear,3271,"op=NoFlux); ```. 3. Field tuple constructors have two versions now. One that accepts boundary conditions (useful in model constructors) and another that accepts full fields (useful for checkpoint restoration and other custom functionality). 4. ~~You can pass anything into `VelocityFields` and `TracerFields`. Perhaps we should check whether everything passed into these functions is a `Field` or `AbstractField`. But for now that's extra code and it's not an exported function so I'm okay leaving it as is (we might want the flexibility in the future?).~~ A check was added in #627. 5. Model no longer has the `boundary_conditions` property. 6. There is no need for `SolutionBoundaryConditions` and `ModelBoundaryConditions` anymore: code is simpler :tada:. 7. `TurbulentDiffusivities` has been renamed to `DiffusivityFields` for consistency with `VelocityFields` and `TracerFields`, etc. 8. For each turbulence closure, `DiffusivityFields` gets the same two versions (one if you want control over the full field, another if you just want to set boundary conditions). 9. Halo filling and parts of the time stepping have been simplified as there is no need to juggle around and bundle up boundary conditions. Some comments:; 1. It's not clear whether fields for abstract operations should have boundary conditions as they don't have halos and we don't impose boundary conditions on them. Do we want to generally set their boundary conditions to `nothing`? I did this for the abstract operations tests and they all passed.; 2. We could further simplify the time stepping code if we adapt the `Field` abstraction to be GPU compatible (#298).; 3. This is probably an edge case but I don't think setting diffusivity BCs when using a tuple of closures will actually work. Or rather, I'm not sure how to specify two different diffusivity BCs, one for each closure.; 4. Before merging I still need to update the checkpointer and update the documentation. Resolves #606. Note: This PR branches off from #628.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/631
https://github.com/CliMA/Oceananigans.jl/pull/631:3577,Usability,simpl,simplify,3577,"op=NoFlux); ```. 3. Field tuple constructors have two versions now. One that accepts boundary conditions (useful in model constructors) and another that accepts full fields (useful for checkpoint restoration and other custom functionality). 4. ~~You can pass anything into `VelocityFields` and `TracerFields`. Perhaps we should check whether everything passed into these functions is a `Field` or `AbstractField`. But for now that's extra code and it's not an exported function so I'm okay leaving it as is (we might want the flexibility in the future?).~~ A check was added in #627. 5. Model no longer has the `boundary_conditions` property. 6. There is no need for `SolutionBoundaryConditions` and `ModelBoundaryConditions` anymore: code is simpler :tada:. 7. `TurbulentDiffusivities` has been renamed to `DiffusivityFields` for consistency with `VelocityFields` and `TracerFields`, etc. 8. For each turbulence closure, `DiffusivityFields` gets the same two versions (one if you want control over the full field, another if you just want to set boundary conditions). 9. Halo filling and parts of the time stepping have been simplified as there is no need to juggle around and bundle up boundary conditions. Some comments:; 1. It's not clear whether fields for abstract operations should have boundary conditions as they don't have halos and we don't impose boundary conditions on them. Do we want to generally set their boundary conditions to `nothing`? I did this for the abstract operations tests and they all passed.; 2. We could further simplify the time stepping code if we adapt the `Field` abstraction to be GPU compatible (#298).; 3. This is probably an edge case but I don't think setting diffusivity BCs when using a tuple of closures will actually work. Or rather, I'm not sure how to specify two different diffusivity BCs, one for each closure.; 4. Before merging I still need to update the checkpointer and update the documentation. Resolves #606. Note: This PR branches off from #628.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/631
https://github.com/CliMA/Oceananigans.jl/pull/632:254,Availability,error,errors,254,Should be useful for LESbrary simulations whose states might actually have an associated date and time from the real world. But I'm not sure if we should merge this PR as `DateTime` from `Base.Dates` only has millisecond precision so you could get small errors in actual `model.clock.time` after many iterations (LESbrary simulations will probably run for millions of iterations). Two small packages that might help us here; https://github.com/JeffreySarnoff/TimesDates.jl; https://github.com/FugroRoames/Chrono.jl,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/632
https://github.com/CliMA/Oceananigans.jl/issues/633:125,Deployability,update,updated,125,The README example uses old syntax for time-stepping a model forward and I don't think will run with #master. It needs to be updated to use the Simulation type.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/633
https://github.com/CliMA/Oceananigans.jl/issues/634:26,Availability,error,error,26,"@arnscheidt reported this error when running this script. https://github.com/ali-ramadhan/antarctic-ice-shelf-meltwater-outflow/blob/eae17968349d72613ccbd0d5b856cc76b30b7850/ice_shelf_meltwater_outflow_2d.jl. ```; InvalidIRError: compiling _set_gpu!(Cassette.Context{nametype(Ctx),Nothing,Nothing,GPUifyLoops.var""##PassType#422"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.Fields._set_gpu!), OffsetArrays.OffsetArray{Float64,3,CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, RegularCartesianGrid{Float64,Oceananigans.Grids.Periodic,Oceananigans.Grids.Periodic,Bounded,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}) resulted in invalid LLVM IR; Reason: unsupported call to the Julia runtime (call to jl_f_apply_type); ```. Looking at the full stacktrace it looks like `threadIdx` is undefined so maybe we just forgot to import CUDAnative.jl in the Fields submodule following the big reorganization in #591. There should have been a test for this.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/634
https://github.com/CliMA/Oceananigans.jl/issues/634:1043,Testability,test,test,1043,"@arnscheidt reported this error when running this script. https://github.com/ali-ramadhan/antarctic-ice-shelf-meltwater-outflow/blob/eae17968349d72613ccbd0d5b856cc76b30b7850/ice_shelf_meltwater_outflow_2d.jl. ```; InvalidIRError: compiling _set_gpu!(Cassette.Context{nametype(Ctx),Nothing,Nothing,GPUifyLoops.var""##PassType#422"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.Fields._set_gpu!), OffsetArrays.OffsetArray{Float64,3,CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, RegularCartesianGrid{Float64,Oceananigans.Grids.Periodic,Oceananigans.Grids.Periodic,Bounded,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}) resulted in invalid LLVM IR; Reason: unsupported call to the Julia runtime (call to jl_f_apply_type); ```. Looking at the full stacktrace it looks like `threadIdx` is undefined so maybe we just forgot to import CUDAnative.jl in the Fields submodule following the big reorganization in #591. There should have been a test for this.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/634
https://github.com/CliMA/Oceananigans.jl/issues/637:150,Safety,avoid,avoid,150,"> Thought: we provide the sugary syntax `.top` and `.bottom` for boundary conditions in `z`. Should we also provide east, west, south, and north, and avoid using `.left` and `.right` in the code for full clarity?; > ; > _Originally posted by @glwagner in https://github.com/climate-machine/Oceananigans.jl/pull/631#pullrequestreview-362963583_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/637
https://github.com/CliMA/Oceananigans.jl/pull/639:69,Security,access,access,69,"This PR allows simulations to hold parameters, useful if you need to access stuff from the `progress` function (e.g. see https://github.com/thabbott/JULES.jl/pull/63) going with the idea that we'll probably get rid of `model.parameters` in favor of more local parameters. It also cleans up show functions for models and simulations.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/639
https://github.com/CliMA/Oceananigans.jl/pull/643:480,Testability,test,test,480,"This PR allows `NetCDFOutputWriter` to write arbitrary outputs, similar to how we pass functions that return data to be saved to disk with the JLD2 output writer, but now with metadata! The `dimensions` kwarg allows you to pass a dictionary of dimensions to apply to any outputs. I also cleaned up the `NetCDFOutputWriter` a bit and changed the name of the time dimension from `""Time""` to `""time""`. @suyashbire1 Let me know if I did anything wrong. I added a pretty comprehensive test that shows how you might write a mix of scalars, profiles, and slices to a NetCDF file with grid/unit/name metadata and global attributes. Here's what the API looks like right now:; ```julia; # Define scalar, vector, 2D slice, and 3D field outputs; f(model) = model.clock.time^2; g(model) = @. model.clock.time * exp(model.grid.zC); h(model) = @. model.clock.time * sin(model.grid.xC) * cos(model.grid.yC'). outputs = Dict(""scalar"" => f, ""profile"" => g, ""slice"" => h); dims = Dict(""scalar"" => (), ""profile"" => (""zC"",), ""slice"" => (""xC"", ""yC"")). output_attributes = Dict(; ""scalar"" => Dict(""longname"" => ""Some scalar"", ""units"" => ""bananas""),; ""profile"" => Dict(""longname"" => ""Some vertical profile"", ""units"" => ""watermelons""),; ""slice"" => Dict(""longname"" => ""Some slice"", ""units"" => ""mushrooms""); ). global_attributes = Dict(""location"" => ""Bay of Fundy"", ""onions"" => 7). simulation.output_writers[:fruits] =; NetCDFOutputWriter(; model, outputs; frequency=1, filename=""test_function_outputs.nc"", dimensions=dims,; global_attributes=global_attributes, output_attributes=output_attributes). run!(simulation); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/643
https://github.com/CliMA/Oceananigans.jl/pull/644:277,Testability,test,testing,277,"This PR changes the default size of face fields so that the length of a field along a `Bounded` dimension is `N+1`, rather than `N`, and therefore includes the bounding faces. The default for `Periodic` and `Flat` dimensions is unchanged. This PR is a work in progress because testing are failing for the NetCDF output writer, and for horizontal averages.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/644
https://github.com/CliMA/Oceananigans.jl/issues/647:1479,Availability,redundant,redundant,1479,"The signature of the model constructor is . ```julia; function IncompressibleModel(;; grid,; architecture = CPU(),; float_type = Float64,; tracers = (:T, :S),; closure = ConstantIsotropicDiffusivity(float_type, ν=ν₀, κ=κ₀),; clock = Clock{float_type}(0, 0), ; buoyancy = SeawaterBuoyancy(float_type),; coriolis = nothing,; surface_waves = nothing,; forcing = ModelForcing(),; boundary_conditions = (u=UVelocityBoundaryConditions(grid),; v=VVelocityBoundaryConditions(grid),; w=WVelocityBoundaryConditions(grid)),; parameters = nothing,; velocities = VelocityFields(architecture, grid, boundary_conditions),; tracer_fields = TracerFields(architecture, grid, tracernames(tracers), boundary_conditions),; pressures = PressureFields(architecture, grid, boundary_conditions),; diffusivities = DiffusivityFields(architecture, grid, tracernames(tracers), boundary_conditions, closure),; timestepper_method = :AdamsBashforth,; timestepper = TimeStepper(timestepper_method, float_type, architecture, grid, tracernames(tracers)),; pressure_solver = PressureSolver(architecture, grid, PressureBoundaryConditions(grid)); ) ; ```. Issues:. 1. `tracers` is apparently expected only to be a tuple of symbols. Nevertheless, the function `tracernames` is called on this argument --- whose only purpose is to return tracer names when its argument may *either* be a tuple of symbols, or a tuple of fields. 2. The arguments (`tracers`, `tracer_fields`) and (`timestepper_method`, `timestepper`) are redundant. . 3. Worse, `tracer_fields` can be set to something inconsistent with `tracers`, and therefore `diffusivities` and `timestepper`. It's probably best if we assign only one keyword argument to each ""concept"", for the sake of simplicity and interpretability. A little bit of cleaning / interpretation to arguments (eg, if an argument may either be a tuple of symbols corresponding to tracer names, or a tuple of tracer fields) is ok, in my opinion, because it could make the code less confusing and easier to use.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/647
https://github.com/CliMA/Oceananigans.jl/issues/647:1479,Safety,redund,redundant,1479,"The signature of the model constructor is . ```julia; function IncompressibleModel(;; grid,; architecture = CPU(),; float_type = Float64,; tracers = (:T, :S),; closure = ConstantIsotropicDiffusivity(float_type, ν=ν₀, κ=κ₀),; clock = Clock{float_type}(0, 0), ; buoyancy = SeawaterBuoyancy(float_type),; coriolis = nothing,; surface_waves = nothing,; forcing = ModelForcing(),; boundary_conditions = (u=UVelocityBoundaryConditions(grid),; v=VVelocityBoundaryConditions(grid),; w=WVelocityBoundaryConditions(grid)),; parameters = nothing,; velocities = VelocityFields(architecture, grid, boundary_conditions),; tracer_fields = TracerFields(architecture, grid, tracernames(tracers), boundary_conditions),; pressures = PressureFields(architecture, grid, boundary_conditions),; diffusivities = DiffusivityFields(architecture, grid, tracernames(tracers), boundary_conditions, closure),; timestepper_method = :AdamsBashforth,; timestepper = TimeStepper(timestepper_method, float_type, architecture, grid, tracernames(tracers)),; pressure_solver = PressureSolver(architecture, grid, PressureBoundaryConditions(grid)); ) ; ```. Issues:. 1. `tracers` is apparently expected only to be a tuple of symbols. Nevertheless, the function `tracernames` is called on this argument --- whose only purpose is to return tracer names when its argument may *either* be a tuple of symbols, or a tuple of fields. 2. The arguments (`tracers`, `tracer_fields`) and (`timestepper_method`, `timestepper`) are redundant. . 3. Worse, `tracer_fields` can be set to something inconsistent with `tracers`, and therefore `diffusivities` and `timestepper`. It's probably best if we assign only one keyword argument to each ""concept"", for the sake of simplicity and interpretability. A little bit of cleaning / interpretation to arguments (eg, if an argument may either be a tuple of symbols corresponding to tracer names, or a tuple of tracer fields) is ok, in my opinion, because it could make the code less confusing and easier to use.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/647
https://github.com/CliMA/Oceananigans.jl/issues/647:1713,Usability,simpl,simplicity,1713,"The signature of the model constructor is . ```julia; function IncompressibleModel(;; grid,; architecture = CPU(),; float_type = Float64,; tracers = (:T, :S),; closure = ConstantIsotropicDiffusivity(float_type, ν=ν₀, κ=κ₀),; clock = Clock{float_type}(0, 0), ; buoyancy = SeawaterBuoyancy(float_type),; coriolis = nothing,; surface_waves = nothing,; forcing = ModelForcing(),; boundary_conditions = (u=UVelocityBoundaryConditions(grid),; v=VVelocityBoundaryConditions(grid),; w=WVelocityBoundaryConditions(grid)),; parameters = nothing,; velocities = VelocityFields(architecture, grid, boundary_conditions),; tracer_fields = TracerFields(architecture, grid, tracernames(tracers), boundary_conditions),; pressures = PressureFields(architecture, grid, boundary_conditions),; diffusivities = DiffusivityFields(architecture, grid, tracernames(tracers), boundary_conditions, closure),; timestepper_method = :AdamsBashforth,; timestepper = TimeStepper(timestepper_method, float_type, architecture, grid, tracernames(tracers)),; pressure_solver = PressureSolver(architecture, grid, PressureBoundaryConditions(grid)); ) ; ```. Issues:. 1. `tracers` is apparently expected only to be a tuple of symbols. Nevertheless, the function `tracernames` is called on this argument --- whose only purpose is to return tracer names when its argument may *either* be a tuple of symbols, or a tuple of fields. 2. The arguments (`tracers`, `tracer_fields`) and (`timestepper_method`, `timestepper`) are redundant. . 3. Worse, `tracer_fields` can be set to something inconsistent with `tracers`, and therefore `diffusivities` and `timestepper`. It's probably best if we assign only one keyword argument to each ""concept"", for the sake of simplicity and interpretability. A little bit of cleaning / interpretation to arguments (eg, if an argument may either be a tuple of symbols corresponding to tracer names, or a tuple of tracer fields) is ok, in my opinion, because it could make the code less confusing and easier to use.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/647
https://github.com/CliMA/Oceananigans.jl/issues/653:288,Integrability,interface,interface,288,"Working with @arnscheidt to output vorticity to NetCDF the code below is what we came up with but it feels quite cumbersome and required us to define some boilerplate `get_vorticity` function so it can all be accessed on demand by the `NetCDFOutputWriter`. I wonder if we can improve the interface to allow users to easily pipe the output of abstract operations to disk. One approach might be to add explicit support for abstract operations to output writers. `NetCDFOutputWriter` already knows what to do if you give it a field or a function. We can tell it to do all this in the background if given an abstract operation like `vorticity_operation = ∂x(v) - ∂y(u)`. ```julia; u, v, w = model.velocities; vorticity_operation = ∂x(v) - ∂y(u); ω = Field(Face, Face, Cell, model.architecture, model.grid, TracerBoundaryConditions(grid)); vorticity_computation = Computation(vorticity_operation, ω). function get_vorticity(model); compute!(vorticity_computation); return Array(interior(ω)); end. fields = Dict(..., ""vorticity"" => get_vorticity); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/653
https://github.com/CliMA/Oceananigans.jl/issues/653:209,Security,access,accessed,209,"Working with @arnscheidt to output vorticity to NetCDF the code below is what we came up with but it feels quite cumbersome and required us to define some boilerplate `get_vorticity` function so it can all be accessed on demand by the `NetCDFOutputWriter`. I wonder if we can improve the interface to allow users to easily pipe the output of abstract operations to disk. One approach might be to add explicit support for abstract operations to output writers. `NetCDFOutputWriter` already knows what to do if you give it a field or a function. We can tell it to do all this in the background if given an abstract operation like `vorticity_operation = ∂x(v) - ∂y(u)`. ```julia; u, v, w = model.velocities; vorticity_operation = ∂x(v) - ∂y(u); ω = Field(Face, Face, Cell, model.architecture, model.grid, TracerBoundaryConditions(grid)); vorticity_computation = Computation(vorticity_operation, ω). function get_vorticity(model); compute!(vorticity_computation); return Array(interior(ω)); end. fields = Dict(..., ""vorticity"" => get_vorticity); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/653
https://github.com/CliMA/Oceananigans.jl/issues/654:1095,Energy Efficiency,energy,energy,1095," closures between incompressible and compressible models. One approach we came up is for all turbulence closures to define functions for the SGS stress tensor like ∂ⱼτᵢⱼ where τᵢⱼ = νˢᵍˢSᵢⱼ and where νˢᵍˢ will dispatch on the type of closure while the strain-rate tensor Sᵢⱼ will dispatch on whether the model is compressible or incompressible. For compressible models, Sᵢⱼ will instead compute and return the _traceless_ strain-rate tensor Sᵢⱼ - ⅓Sₖₖδᵢⱼ. A turbulence closure can define ∂ⱼτᵢⱼ directly to elide or short circuit computations or in case the SGS stress tensor is not of the form ∂ⱼτᵢⱼ = νˢᵍˢSᵢⱼ. Still learning more about this topic but it seems that as a start, just using the traceless strain-rate tensor for compressible models allows us to reuse a closure from an incompressible model. @thabbott suggested that νˢᵍˢ might have to dispatch on the thermodynamic variable as well. Is this true for the viscosity or only the diffusivities κˢᵍˢ? I.e. do we have to treat SGS fluxes of moisture and energy in a special way?. Couple of useful references for compressible LES (mostly with dynamic Smagorinsky):; 1. Moin et al. (1991), A dynamic subgrid‐scale model for compressible turbulence and scalar transport: https://doi.org/10.1063/1.858164; 2. Chai & Mahesh (2012), Dynamic k-equation model for large-eddy simulation of compressible flows: https://doi.org/10.1017/jfm.2012.115. ---. Some notational and misc. changes I'd like to make:. 1. Rename `∂ⱼ_2ν_Σ₁ⱼ` to `∂ⱼτ₁ⱼ` as τᵢⱼ = 2νSᵢⱼ is would no longer be true for `CompressibleModel`, it's τᵢⱼ = 2νSᵢⱼ + λSₘₘδᵢⱼ where λ is the _second viscosity_, or τᵢⱼ = 2μ(Sᵢⱼ - ⅓Sₖₖδᵢⱼ) + μᵥSₖₖδᵢⱼ where μᵥ is the _bulk_ or _volume viscosity_. 2. For constant isotropic viscosity: rename `∂ⱼνᵢⱼ∂ᵢu` to `ν∇²u`. For constant isotropic diffusivity: rename `∂ⱼκᵢⱼ∂ᵢc` to `κ∇²c`. 3. For constant anistropic viscosity: rename `∂ⱼνᵢⱼ∂ᵢu` to `νⱼ∂ⱼ²u`. For constant anistropic diffusivity: rename `∂ⱼκᵢⱼ∂ᵢc` to `κⱼ∂ⱼ²c`. Potentially a misuse of summatio",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/654
https://github.com/CliMA/Oceananigans.jl/issues/654:962,Modifiability,variab,variable,962,"@thabbott and I have been thinking about potential ways we can reuse LES/turbulence closures between incompressible and compressible models. One approach we came up is for all turbulence closures to define functions for the SGS stress tensor like ∂ⱼτᵢⱼ where τᵢⱼ = νˢᵍˢSᵢⱼ and where νˢᵍˢ will dispatch on the type of closure while the strain-rate tensor Sᵢⱼ will dispatch on whether the model is compressible or incompressible. For compressible models, Sᵢⱼ will instead compute and return the _traceless_ strain-rate tensor Sᵢⱼ - ⅓Sₖₖδᵢⱼ. A turbulence closure can define ∂ⱼτᵢⱼ directly to elide or short circuit computations or in case the SGS stress tensor is not of the form ∂ⱼτᵢⱼ = νˢᵍˢSᵢⱼ. Still learning more about this topic but it seems that as a start, just using the traceless strain-rate tensor for compressible models allows us to reuse a closure from an incompressible model. @thabbott suggested that νˢᵍˢ might have to dispatch on the thermodynamic variable as well. Is this true for the viscosity or only the diffusivities κˢᵍˢ? I.e. do we have to treat SGS fluxes of moisture and energy in a special way?. Couple of useful references for compressible LES (mostly with dynamic Smagorinsky):; 1. Moin et al. (1991), A dynamic subgrid‐scale model for compressible turbulence and scalar transport: https://doi.org/10.1063/1.858164; 2. Chai & Mahesh (2012), Dynamic k-equation model for large-eddy simulation of compressible flows: https://doi.org/10.1017/jfm.2012.115. ---. Some notational and misc. changes I'd like to make:. 1. Rename `∂ⱼ_2ν_Σ₁ⱼ` to `∂ⱼτ₁ⱼ` as τᵢⱼ = 2νSᵢⱼ is would no longer be true for `CompressibleModel`, it's τᵢⱼ = 2νSᵢⱼ + λSₘₘδᵢⱼ where λ is the _second viscosity_, or τᵢⱼ = 2μ(Sᵢⱼ - ⅓Sₖₖδᵢⱼ) + μᵥSₖₖδᵢⱼ where μᵥ is the _bulk_ or _volume viscosity_. 2. For constant isotropic viscosity: rename `∂ⱼνᵢⱼ∂ᵢu` to `ν∇²u`. For constant isotropic diffusivity: rename `∂ⱼκᵢⱼ∂ᵢc` to `κ∇²c`. 3. For constant anistropic viscosity: rename `∂ⱼνᵢⱼ∂ᵢu` to `νⱼ∂ⱼ²u`. For constant anis",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/654
https://github.com/CliMA/Oceananigans.jl/issues/654:700,Usability,learn,learning,700,"@thabbott and I have been thinking about potential ways we can reuse LES/turbulence closures between incompressible and compressible models. One approach we came up is for all turbulence closures to define functions for the SGS stress tensor like ∂ⱼτᵢⱼ where τᵢⱼ = νˢᵍˢSᵢⱼ and where νˢᵍˢ will dispatch on the type of closure while the strain-rate tensor Sᵢⱼ will dispatch on whether the model is compressible or incompressible. For compressible models, Sᵢⱼ will instead compute and return the _traceless_ strain-rate tensor Sᵢⱼ - ⅓Sₖₖδᵢⱼ. A turbulence closure can define ∂ⱼτᵢⱼ directly to elide or short circuit computations or in case the SGS stress tensor is not of the form ∂ⱼτᵢⱼ = νˢᵍˢSᵢⱼ. Still learning more about this topic but it seems that as a start, just using the traceless strain-rate tensor for compressible models allows us to reuse a closure from an incompressible model. @thabbott suggested that νˢᵍˢ might have to dispatch on the thermodynamic variable as well. Is this true for the viscosity or only the diffusivities κˢᵍˢ? I.e. do we have to treat SGS fluxes of moisture and energy in a special way?. Couple of useful references for compressible LES (mostly with dynamic Smagorinsky):; 1. Moin et al. (1991), A dynamic subgrid‐scale model for compressible turbulence and scalar transport: https://doi.org/10.1063/1.858164; 2. Chai & Mahesh (2012), Dynamic k-equation model for large-eddy simulation of compressible flows: https://doi.org/10.1017/jfm.2012.115. ---. Some notational and misc. changes I'd like to make:. 1. Rename `∂ⱼ_2ν_Σ₁ⱼ` to `∂ⱼτ₁ⱼ` as τᵢⱼ = 2νSᵢⱼ is would no longer be true for `CompressibleModel`, it's τᵢⱼ = 2νSᵢⱼ + λSₘₘδᵢⱼ where λ is the _second viscosity_, or τᵢⱼ = 2μ(Sᵢⱼ - ⅓Sₖₖδᵢⱼ) + μᵥSₖₖδᵢⱼ where μᵥ is the _bulk_ or _volume viscosity_. 2. For constant isotropic viscosity: rename `∂ⱼνᵢⱼ∂ᵢu` to `ν∇²u`. For constant isotropic diffusivity: rename `∂ⱼκᵢⱼ∂ᵢc` to `κ∇²c`. 3. For constant anistropic viscosity: rename `∂ⱼνᵢⱼ∂ᵢu` to `νⱼ∂ⱼ²u`. For constant anis",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/654
https://github.com/CliMA/Oceananigans.jl/issues/655:356,Availability,checkpoint,checkpointer,356,"Probably defined twice by mistake; ```julia; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; WARNING: Method definition convert_to_arch(Oceananigans.Architectures.CPU, Any) in module OutputWriters at /home/alir/Oceananigans.jl/src/OutputWriters/output_writer_utils.jl:9 overwritten at /home/alir/Oceananigans.jl/src/OutputWriters/checkpointer.jl:93.; ** incremental compilation may be fatally broken for this module **. WARNING: Method definition convert_to_arch(Oceananigans.Architectures.GPU, Any) in module OutputWriters at /home/alir/Oceananigans.jl/src/OutputWriters/output_writer_utils.jl:10 overwritten at /home/alir/Oceananigans.jl/src/OutputWriters/checkpointer.jl:94.; ** incremental compilation may be fatally broken for this module **; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/655
https://github.com/CliMA/Oceananigans.jl/issues/655:684,Availability,checkpoint,checkpointer,684,"Probably defined twice by mistake; ```julia; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; WARNING: Method definition convert_to_arch(Oceananigans.Architectures.CPU, Any) in module OutputWriters at /home/alir/Oceananigans.jl/src/OutputWriters/output_writer_utils.jl:9 overwritten at /home/alir/Oceananigans.jl/src/OutputWriters/checkpointer.jl:93.; ** incremental compilation may be fatally broken for this module **. WARNING: Method definition convert_to_arch(Oceananigans.Architectures.GPU, Any) in module OutputWriters at /home/alir/Oceananigans.jl/src/OutputWriters/output_writer_utils.jl:10 overwritten at /home/alir/Oceananigans.jl/src/OutputWriters/checkpointer.jl:94.; ** incremental compilation may be fatally broken for this module **; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/655
https://github.com/CliMA/Oceananigans.jl/pull/656:62,Deployability,release,release,62,Fixes #655. `convert_to_arch` was defined in two places. Will release patch v0.24.1 once merged.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/656
https://github.com/CliMA/Oceananigans.jl/pull/656:70,Deployability,patch,patch,70,Fixes #655. `convert_to_arch` was defined in two places. Will release patch v0.24.1 once merged.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/656
https://github.com/CliMA/Oceananigans.jl/issues/659:1046,Availability,ERROR,ERROR,1046,"ypes:. ```julia; julia> using Oceananigans, Oceananigans.Fields, Oceananigans.AbstractOperations. julia> arch = CPU(); grid = RegularCartesianGrid(size=(16, 16, 16), length=(1, 1, 1));. julia> c, d = (CellField(arch, grid) for i=1:2);. julia> e = @at (Face, Cell, Cell) c * d; BinaryOperation at (Face, Cell, Cell); ├── grid: RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}; │ ├── size: (16, 16, 16); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: . * at (Face, Cell, Cell) via ℑxᶠᵃᵃ; ├── OffsetArray{Float64, 3, Array{Float64,3}}; └── OffsetArray{Float64, 3, Array{Float64,3}}; ```. notice that the ""location"" is specified with `(Face, Cell, Cell)`. Boundary conditions are different:. ```julia; julia> bc = FieldBoundaryConditions(grid, (Cell, Cell, Cell), north=BoundaryCondition(Value, 1.0)); ERROR: MethodError: no method matching DefaultBoundaryCondition(::Bounded, ::Type{Cell}); Closest candidates are:; DefaultBoundaryCondition(::Bounded, ::Face) at /Users/gregorywagner/.julia/packages/Oceananigans/Pyzcd/src/BoundaryConditions/field_boundary_conditions.jl:20; DefaultBoundaryCondition(::Bounded, ::Cell) at /Users/gregorywagner/.julia/packages/Oceananigans/Pyzcd/src/BoundaryConditions/field_boundary_conditions.jl:19; DefaultBoundaryCondition(::Union{Flat, Periodic}, ::Any) at /Users/gregorywagner/.julia/packages/Oceananigans/Pyzcd/src/BoundaryConditions/field_boundary_conditions.jl:17; Stacktrace:; [1] (::Core.var""#kw#Type"")(::NamedTuple{(:north,),Tuple{BoundaryCondition{Value,Float64}}}, ::Type{NamedTuple{(:x, :y, :z),T} where T<:Tuple}, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}, ::Tuple{DataType,DataType,DataType}) at ./none:0; [2] top-level scope at REPL[13]:1; ```. while this works:. ```julia; julia> bc = FieldBoundaryConditions(grid, (Cell(), Cell(), Cell()), nor",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/659
https://github.com/CliMA/Oceananigans.jl/issues/660:57,Availability,checkpoint,checkpointer,57,"For example, this line:. ```julia; model.output_writers[:checkpointer] = Checkpointer(model; interval=1e6, prefix=""model_checkpoint""); ```. fails because `model` does not have a field `output_writers`. We need to use a `Simulation` here.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/660
https://github.com/CliMA/Oceananigans.jl/issues/660:73,Availability,Checkpoint,Checkpointer,73,"For example, this line:. ```julia; model.output_writers[:checkpointer] = Checkpointer(model; interval=1e6, prefix=""model_checkpoint""); ```. fails because `model` does not have a field `output_writers`. We need to use a `Simulation` here.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/660
https://github.com/CliMA/Oceananigans.jl/issues/661:24,Availability,checkpoint,checkpointing,24,"MWE in which I expected checkpointing to occur every 10 iterations:. ```julia. using Oceananigans, Oceananigans.Fields; arch = CPU(); grid = RegularCartesianGrid(size=(16, 16, 16), length=(1, 1, 1));; model = IncompressibleModel(grid=RegularCartesianGrid(size=(16, 16, 16), length=(1, 1, 1))); simulation = Simulation(model, Δt=0.1, stop_iteration=1000). simulation.output_writers[:checkpointer] = Checkpointer(model; interval=10, prefix=""model_checkpoint"") # expect to checkpoint every 10 iterations?. run!(simulation); ```. but the files produced are. ```; model_checkpoint_iteration0.jld2 model_checkpoint_iteration400.jld2 model_checkpoint_iteration801.jld2; model_checkpoint_iteration101.jld2 model_checkpoint_iteration500.jld2 model_checkpoint_iteration901.jld2; model_checkpoint_iteration200.jld2 model_checkpoint_iteration600.jld2; model_checkpoint_iteration300.jld2 model_checkpoint_iteration700.jld2; ```. eg, checkpoints are only saved every 100 iterations. Am I missing something?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/661
https://github.com/CliMA/Oceananigans.jl/issues/661:382,Availability,checkpoint,checkpointer,382,"MWE in which I expected checkpointing to occur every 10 iterations:. ```julia. using Oceananigans, Oceananigans.Fields; arch = CPU(); grid = RegularCartesianGrid(size=(16, 16, 16), length=(1, 1, 1));; model = IncompressibleModel(grid=RegularCartesianGrid(size=(16, 16, 16), length=(1, 1, 1))); simulation = Simulation(model, Δt=0.1, stop_iteration=1000). simulation.output_writers[:checkpointer] = Checkpointer(model; interval=10, prefix=""model_checkpoint"") # expect to checkpoint every 10 iterations?. run!(simulation); ```. but the files produced are. ```; model_checkpoint_iteration0.jld2 model_checkpoint_iteration400.jld2 model_checkpoint_iteration801.jld2; model_checkpoint_iteration101.jld2 model_checkpoint_iteration500.jld2 model_checkpoint_iteration901.jld2; model_checkpoint_iteration200.jld2 model_checkpoint_iteration600.jld2; model_checkpoint_iteration300.jld2 model_checkpoint_iteration700.jld2; ```. eg, checkpoints are only saved every 100 iterations. Am I missing something?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/661
https://github.com/CliMA/Oceananigans.jl/issues/661:398,Availability,Checkpoint,Checkpointer,398,"MWE in which I expected checkpointing to occur every 10 iterations:. ```julia. using Oceananigans, Oceananigans.Fields; arch = CPU(); grid = RegularCartesianGrid(size=(16, 16, 16), length=(1, 1, 1));; model = IncompressibleModel(grid=RegularCartesianGrid(size=(16, 16, 16), length=(1, 1, 1))); simulation = Simulation(model, Δt=0.1, stop_iteration=1000). simulation.output_writers[:checkpointer] = Checkpointer(model; interval=10, prefix=""model_checkpoint"") # expect to checkpoint every 10 iterations?. run!(simulation); ```. but the files produced are. ```; model_checkpoint_iteration0.jld2 model_checkpoint_iteration400.jld2 model_checkpoint_iteration801.jld2; model_checkpoint_iteration101.jld2 model_checkpoint_iteration500.jld2 model_checkpoint_iteration901.jld2; model_checkpoint_iteration200.jld2 model_checkpoint_iteration600.jld2; model_checkpoint_iteration300.jld2 model_checkpoint_iteration700.jld2; ```. eg, checkpoints are only saved every 100 iterations. Am I missing something?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/661
https://github.com/CliMA/Oceananigans.jl/issues/661:470,Availability,checkpoint,checkpoint,470,"MWE in which I expected checkpointing to occur every 10 iterations:. ```julia. using Oceananigans, Oceananigans.Fields; arch = CPU(); grid = RegularCartesianGrid(size=(16, 16, 16), length=(1, 1, 1));; model = IncompressibleModel(grid=RegularCartesianGrid(size=(16, 16, 16), length=(1, 1, 1))); simulation = Simulation(model, Δt=0.1, stop_iteration=1000). simulation.output_writers[:checkpointer] = Checkpointer(model; interval=10, prefix=""model_checkpoint"") # expect to checkpoint every 10 iterations?. run!(simulation); ```. but the files produced are. ```; model_checkpoint_iteration0.jld2 model_checkpoint_iteration400.jld2 model_checkpoint_iteration801.jld2; model_checkpoint_iteration101.jld2 model_checkpoint_iteration500.jld2 model_checkpoint_iteration901.jld2; model_checkpoint_iteration200.jld2 model_checkpoint_iteration600.jld2; model_checkpoint_iteration300.jld2 model_checkpoint_iteration700.jld2; ```. eg, checkpoints are only saved every 100 iterations. Am I missing something?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/661
https://github.com/CliMA/Oceananigans.jl/issues/661:920,Availability,checkpoint,checkpoints,920,"MWE in which I expected checkpointing to occur every 10 iterations:. ```julia. using Oceananigans, Oceananigans.Fields; arch = CPU(); grid = RegularCartesianGrid(size=(16, 16, 16), length=(1, 1, 1));; model = IncompressibleModel(grid=RegularCartesianGrid(size=(16, 16, 16), length=(1, 1, 1))); simulation = Simulation(model, Δt=0.1, stop_iteration=1000). simulation.output_writers[:checkpointer] = Checkpointer(model; interval=10, prefix=""model_checkpoint"") # expect to checkpoint every 10 iterations?. run!(simulation); ```. but the files produced are. ```; model_checkpoint_iteration0.jld2 model_checkpoint_iteration400.jld2 model_checkpoint_iteration801.jld2; model_checkpoint_iteration101.jld2 model_checkpoint_iteration500.jld2 model_checkpoint_iteration901.jld2; model_checkpoint_iteration200.jld2 model_checkpoint_iteration600.jld2; model_checkpoint_iteration300.jld2 model_checkpoint_iteration700.jld2; ```. eg, checkpoints are only saved every 100 iterations. Am I missing something?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/661
https://github.com/CliMA/Oceananigans.jl/pull/664:17,Availability,error,error,17,This PR fixes an error in the Adams-Bashforth time-stepping algorithm so that tendencies from time-step `n-1` are computed correctly. This PR also computes tendencies after a time-step is complete rather than at the beginning of a time-step. This change causes the regression tests to fail. We should merge this change and correct the regression tests in a subsequent PR.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/664
https://github.com/CliMA/Oceananigans.jl/pull/664:276,Testability,test,tests,276,This PR fixes an error in the Adams-Bashforth time-stepping algorithm so that tendencies from time-step `n-1` are computed correctly. This PR also computes tendencies after a time-step is complete rather than at the beginning of a time-step. This change causes the regression tests to fail. We should merge this change and correct the regression tests in a subsequent PR.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/664
https://github.com/CliMA/Oceananigans.jl/pull/664:346,Testability,test,tests,346,This PR fixes an error in the Adams-Bashforth time-stepping algorithm so that tendencies from time-step `n-1` are computed correctly. This PR also computes tendencies after a time-step is complete rather than at the beginning of a time-step. This change causes the regression tests to fail. We should merge this change and correct the regression tests in a subsequent PR.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/664
https://github.com/CliMA/Oceananigans.jl/pull/665:28,Modifiability,rewrite,rewrites,28,This PR builds off #664 and rewrites the regression tests to match changes made in #664 to the time-stepping algorithm. It also does some minor refactoring and cleanup of the regression test scripts.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/665
https://github.com/CliMA/Oceananigans.jl/pull/665:144,Modifiability,refactor,refactoring,144,This PR builds off #664 and rewrites the regression tests to match changes made in #664 to the time-stepping algorithm. It also does some minor refactoring and cleanup of the regression test scripts.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/665
https://github.com/CliMA/Oceananigans.jl/pull/665:52,Testability,test,tests,52,This PR builds off #664 and rewrites the regression tests to match changes made in #664 to the time-stepping algorithm. It also does some minor refactoring and cleanup of the regression test scripts.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/665
https://github.com/CliMA/Oceananigans.jl/pull/665:186,Testability,test,test,186,This PR builds off #664 and rewrites the regression tests to match changes made in #664 to the time-stepping algorithm. It also does some minor refactoring and cleanup of the regression test scripts.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/665
https://github.com/CliMA/Oceananigans.jl/pull/666:8,Modifiability,refactor,refactors,8,"This PR refactors the time-stepping algorithm to use the ""predictor velocities"" abstraction in the fractional step method. This brings the implemented algorithm in line with the algorithm described in the documentation.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/666
https://github.com/CliMA/Oceananigans.jl/pull/666:58,Safety,predict,predictor,58,"This PR refactors the time-stepping algorithm to use the ""predictor velocities"" abstraction in the fractional step method. This brings the implemented algorithm in line with the algorithm described in the documentation.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/666
https://github.com/CliMA/Oceananigans.jl/issues/673:45,Testability,test,test,45,"From call with @glwagner: We should properly test that the pressure projection step produces an incompressible flow field (without computing w from continuity). Right now the `incompressible_in_time` test found in `test_time_stepping.jl` tests for incompressibility after `time_step!` is done and w has been recomputed from w. Interestingly, the sum accumulated in time while the sum of the absolute values does not:. ```; [04/03/2020 13:57:51] Velocity divergence after 1 time steps [CPU, Float64]: min=-6.037244272213971e-19, max=-6.037244272213971e-19, sum=-1.9275293505266353e-22, abs_sum=1.284399769586337e-16 --- Info /home/travis/build/climate-machine/Oceananigans.jl/test/test_time_stepping.jl:106; [04/03/2020 13:57:52] Velocity divergence after 10 time steps [CPU, Float64]: min=-7.735240399597831e-19, max=-7.735240399597831e-19, sum=1.666113807244092e-21, abs_sum=1.5625275138570133e-16 --- Info /home/travis/build/climate-machine/Oceananigans.jl/test/test_time_stepping.jl:106; [04/03/2020 13:58:06] Velocity divergence after 100 time steps [CPU, Float64]: min=-6.005395833397209e-19, max=-6.005395833397209e-19, sum=8.58925289833789e-20, abs_sum=2.661629631159426e-16 --- Info /home/travis/build/climate-machine/Oceananigans.jl/test/test_time_stepping.jl:106; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/673
https://github.com/CliMA/Oceananigans.jl/issues/673:200,Testability,test,test,200,"From call with @glwagner: We should properly test that the pressure projection step produces an incompressible flow field (without computing w from continuity). Right now the `incompressible_in_time` test found in `test_time_stepping.jl` tests for incompressibility after `time_step!` is done and w has been recomputed from w. Interestingly, the sum accumulated in time while the sum of the absolute values does not:. ```; [04/03/2020 13:57:51] Velocity divergence after 1 time steps [CPU, Float64]: min=-6.037244272213971e-19, max=-6.037244272213971e-19, sum=-1.9275293505266353e-22, abs_sum=1.284399769586337e-16 --- Info /home/travis/build/climate-machine/Oceananigans.jl/test/test_time_stepping.jl:106; [04/03/2020 13:57:52] Velocity divergence after 10 time steps [CPU, Float64]: min=-7.735240399597831e-19, max=-7.735240399597831e-19, sum=1.666113807244092e-21, abs_sum=1.5625275138570133e-16 --- Info /home/travis/build/climate-machine/Oceananigans.jl/test/test_time_stepping.jl:106; [04/03/2020 13:58:06] Velocity divergence after 100 time steps [CPU, Float64]: min=-6.005395833397209e-19, max=-6.005395833397209e-19, sum=8.58925289833789e-20, abs_sum=2.661629631159426e-16 --- Info /home/travis/build/climate-machine/Oceananigans.jl/test/test_time_stepping.jl:106; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/673
https://github.com/CliMA/Oceananigans.jl/issues/673:238,Testability,test,tests,238,"From call with @glwagner: We should properly test that the pressure projection step produces an incompressible flow field (without computing w from continuity). Right now the `incompressible_in_time` test found in `test_time_stepping.jl` tests for incompressibility after `time_step!` is done and w has been recomputed from w. Interestingly, the sum accumulated in time while the sum of the absolute values does not:. ```; [04/03/2020 13:57:51] Velocity divergence after 1 time steps [CPU, Float64]: min=-6.037244272213971e-19, max=-6.037244272213971e-19, sum=-1.9275293505266353e-22, abs_sum=1.284399769586337e-16 --- Info /home/travis/build/climate-machine/Oceananigans.jl/test/test_time_stepping.jl:106; [04/03/2020 13:57:52] Velocity divergence after 10 time steps [CPU, Float64]: min=-7.735240399597831e-19, max=-7.735240399597831e-19, sum=1.666113807244092e-21, abs_sum=1.5625275138570133e-16 --- Info /home/travis/build/climate-machine/Oceananigans.jl/test/test_time_stepping.jl:106; [04/03/2020 13:58:06] Velocity divergence after 100 time steps [CPU, Float64]: min=-6.005395833397209e-19, max=-6.005395833397209e-19, sum=8.58925289833789e-20, abs_sum=2.661629631159426e-16 --- Info /home/travis/build/climate-machine/Oceananigans.jl/test/test_time_stepping.jl:106; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/673
https://github.com/CliMA/Oceananigans.jl/issues/673:675,Testability,test,test,675,"From call with @glwagner: We should properly test that the pressure projection step produces an incompressible flow field (without computing w from continuity). Right now the `incompressible_in_time` test found in `test_time_stepping.jl` tests for incompressibility after `time_step!` is done and w has been recomputed from w. Interestingly, the sum accumulated in time while the sum of the absolute values does not:. ```; [04/03/2020 13:57:51] Velocity divergence after 1 time steps [CPU, Float64]: min=-6.037244272213971e-19, max=-6.037244272213971e-19, sum=-1.9275293505266353e-22, abs_sum=1.284399769586337e-16 --- Info /home/travis/build/climate-machine/Oceananigans.jl/test/test_time_stepping.jl:106; [04/03/2020 13:57:52] Velocity divergence after 10 time steps [CPU, Float64]: min=-7.735240399597831e-19, max=-7.735240399597831e-19, sum=1.666113807244092e-21, abs_sum=1.5625275138570133e-16 --- Info /home/travis/build/climate-machine/Oceananigans.jl/test/test_time_stepping.jl:106; [04/03/2020 13:58:06] Velocity divergence after 100 time steps [CPU, Float64]: min=-6.005395833397209e-19, max=-6.005395833397209e-19, sum=8.58925289833789e-20, abs_sum=2.661629631159426e-16 --- Info /home/travis/build/climate-machine/Oceananigans.jl/test/test_time_stepping.jl:106; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/673
https://github.com/CliMA/Oceananigans.jl/issues/673:959,Testability,test,test,959,"From call with @glwagner: We should properly test that the pressure projection step produces an incompressible flow field (without computing w from continuity). Right now the `incompressible_in_time` test found in `test_time_stepping.jl` tests for incompressibility after `time_step!` is done and w has been recomputed from w. Interestingly, the sum accumulated in time while the sum of the absolute values does not:. ```; [04/03/2020 13:57:51] Velocity divergence after 1 time steps [CPU, Float64]: min=-6.037244272213971e-19, max=-6.037244272213971e-19, sum=-1.9275293505266353e-22, abs_sum=1.284399769586337e-16 --- Info /home/travis/build/climate-machine/Oceananigans.jl/test/test_time_stepping.jl:106; [04/03/2020 13:57:52] Velocity divergence after 10 time steps [CPU, Float64]: min=-7.735240399597831e-19, max=-7.735240399597831e-19, sum=1.666113807244092e-21, abs_sum=1.5625275138570133e-16 --- Info /home/travis/build/climate-machine/Oceananigans.jl/test/test_time_stepping.jl:106; [04/03/2020 13:58:06] Velocity divergence after 100 time steps [CPU, Float64]: min=-6.005395833397209e-19, max=-6.005395833397209e-19, sum=8.58925289833789e-20, abs_sum=2.661629631159426e-16 --- Info /home/travis/build/climate-machine/Oceananigans.jl/test/test_time_stepping.jl:106; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/673
https://github.com/CliMA/Oceananigans.jl/issues/673:1242,Testability,test,test,1242,"From call with @glwagner: We should properly test that the pressure projection step produces an incompressible flow field (without computing w from continuity). Right now the `incompressible_in_time` test found in `test_time_stepping.jl` tests for incompressibility after `time_step!` is done and w has been recomputed from w. Interestingly, the sum accumulated in time while the sum of the absolute values does not:. ```; [04/03/2020 13:57:51] Velocity divergence after 1 time steps [CPU, Float64]: min=-6.037244272213971e-19, max=-6.037244272213971e-19, sum=-1.9275293505266353e-22, abs_sum=1.284399769586337e-16 --- Info /home/travis/build/climate-machine/Oceananigans.jl/test/test_time_stepping.jl:106; [04/03/2020 13:57:52] Velocity divergence after 10 time steps [CPU, Float64]: min=-7.735240399597831e-19, max=-7.735240399597831e-19, sum=1.666113807244092e-21, abs_sum=1.5625275138570133e-16 --- Info /home/travis/build/climate-machine/Oceananigans.jl/test/test_time_stepping.jl:106; [04/03/2020 13:58:06] Velocity divergence after 100 time steps [CPU, Float64]: min=-6.005395833397209e-19, max=-6.005395833397209e-19, sum=8.58925289833789e-20, abs_sum=2.661629631159426e-16 --- Info /home/travis/build/climate-machine/Oceananigans.jl/test/test_time_stepping.jl:106; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/673
https://github.com/CliMA/Oceananigans.jl/issues/674:41,Testability,test,test,41,"Right now we have a simple interval wave test in `test_dynamics.jl` (vertically propagating and only 10 time steps) and an example (@glwagner thinks it looks off). We should turn them into a rigorous verification experiment. Would be a good test of the pressure gradient term, and we can compare with an analytic solution.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/674
https://github.com/CliMA/Oceananigans.jl/issues/674:241,Testability,test,test,241,"Right now we have a simple interval wave test in `test_dynamics.jl` (vertically propagating and only 10 time steps) and an example (@glwagner thinks it looks off). We should turn them into a rigorous verification experiment. Would be a good test of the pressure gradient term, and we can compare with an analytic solution.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/674
https://github.com/CliMA/Oceananigans.jl/issues/674:20,Usability,simpl,simple,20,"Right now we have a simple interval wave test in `test_dynamics.jl` (vertically propagating and only 10 time steps) and an example (@glwagner thinks it looks off). We should turn them into a rigorous verification experiment. Would be a good test of the pressure gradient term, and we can compare with an analytic solution.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/674
https://github.com/CliMA/Oceananigans.jl/issues/675:64,Availability,down,down,64,"Reported in PR #666. Might be serious enough that it is slowing down documentation building in PR #671. ```; Julia Version 1.3.1; Commit 2d5741174c (2019-12-30 21:36 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-6.0.1 (ORCJIT, skylake); GPU: TITAN V. ──────────────────────────────────────────────────────────────────────────────────────; Static ocean benchmarks Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 173s / 51.2% 43.6GiB / 64.5% . Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────; 32× 32× 32 [CPU, Float32] 10 127ms 0.14% 12.7ms 170MiB 0.59% 17.0MiB; 32× 32× 32 [CPU, Float64] 10 153ms 0.17% 15.3ms 170MiB 0.59% 17.0MiB; 32× 32× 32 [GPU, Float32] 10 24.4ms 0.03% 2.44ms 10.0MiB 0.03% 1.00MiB; 32× 32× 32 [GPU, Float64] 10 24.2ms 0.03% 2.42ms 10.0MiB 0.03% 1.00MiB; 64× 64× 64 [CPU, Float32] 10 713ms 0.81% 71.3ms 676MiB 2.35% 67.6MiB; 64× 64× 64 [CPU, Float64] 10 868ms 0.98% 86.8ms 676MiB 2.35% 67.6MiB; 64× 64× 64 [GPU, Float32] 10 24.8ms 0.03% 2.48ms 10.0MiB 0.03% 1.00MiB; 64× 64× 64 [GPU, Float64] 10 25.2ms 0.03% 2.52ms 10.0MiB 0.03% 1.00MiB; 128×128×128 [CPU, Float32] 10 5.22s 5.90% 522ms 2.64GiB 9.39% 270MiB; 128×128×128 [CPU, Float64] 10 5.44s 6.14% 544ms 2.64GiB 9.39% 270MiB; 128×128×128 [GPU, Float32] 10 46.3ms 0.05% 4.63ms 10.0MiB 0.03% 1.00MiB; 128×128×128 [GPU, Float64] 10 45.6ms 0.05% 4.56ms 10.0MiB 0.03% 1.00MiB; 256×256×256 [CPU, Float32] 10 37.4s 42.3% 3.74s 10.5GiB 37.5% 1.05GiB; 256×256×256 [CPU, Float64] 10 37.7s 42.6% 3.77s 10.5GiB 37.5% 1.05GiB; 256×256×256 [GPU, Float32] 10 338ms 0.38% 33.8ms 10.0MiB 0.03% 1.00MiB; 256×256×256 [GPU, Float64] 10 336ms 0.38% 33.6ms 10.0MiB 0.03% 1.00MiB; ──────────────────────────────────────────────────────────────────────────────────────; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/675
https://github.com/CliMA/Oceananigans.jl/issues/675:458,Testability,benchmark,benchmarks,458,"Reported in PR #666. Might be serious enough that it is slowing down documentation building in PR #671. ```; Julia Version 1.3.1; Commit 2d5741174c (2019-12-30 21:36 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-6.0.1 (ORCJIT, skylake); GPU: TITAN V. ──────────────────────────────────────────────────────────────────────────────────────; Static ocean benchmarks Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 173s / 51.2% 43.6GiB / 64.5% . Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────; 32× 32× 32 [CPU, Float32] 10 127ms 0.14% 12.7ms 170MiB 0.59% 17.0MiB; 32× 32× 32 [CPU, Float64] 10 153ms 0.17% 15.3ms 170MiB 0.59% 17.0MiB; 32× 32× 32 [GPU, Float32] 10 24.4ms 0.03% 2.44ms 10.0MiB 0.03% 1.00MiB; 32× 32× 32 [GPU, Float64] 10 24.2ms 0.03% 2.42ms 10.0MiB 0.03% 1.00MiB; 64× 64× 64 [CPU, Float32] 10 713ms 0.81% 71.3ms 676MiB 2.35% 67.6MiB; 64× 64× 64 [CPU, Float64] 10 868ms 0.98% 86.8ms 676MiB 2.35% 67.6MiB; 64× 64× 64 [GPU, Float32] 10 24.8ms 0.03% 2.48ms 10.0MiB 0.03% 1.00MiB; 64× 64× 64 [GPU, Float64] 10 25.2ms 0.03% 2.52ms 10.0MiB 0.03% 1.00MiB; 128×128×128 [CPU, Float32] 10 5.22s 5.90% 522ms 2.64GiB 9.39% 270MiB; 128×128×128 [CPU, Float64] 10 5.44s 6.14% 544ms 2.64GiB 9.39% 270MiB; 128×128×128 [GPU, Float32] 10 46.3ms 0.05% 4.63ms 10.0MiB 0.03% 1.00MiB; 128×128×128 [GPU, Float64] 10 45.6ms 0.05% 4.56ms 10.0MiB 0.03% 1.00MiB; 256×256×256 [CPU, Float32] 10 37.4s 42.3% 3.74s 10.5GiB 37.5% 1.05GiB; 256×256×256 [CPU, Float64] 10 37.7s 42.6% 3.77s 10.5GiB 37.5% 1.05GiB; 256×256×256 [GPU, Float32] 10 338ms 0.38% 33.8ms 10.0MiB 0.03% 1.00MiB; 256×256×256 [GPU, Float64] 10 336ms 0.38% 33.6ms 10.0MiB 0.03% 1.00MiB; ──────────────────────────────────────────────────────────────────────────────────────; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/675
https://github.com/CliMA/Oceananigans.jl/issues/676:149,Usability,Simpl,Simplest,149,"Since PR #621 introduced simulations, the examples have actually started looking worse as plotting + animation + simulations are all mixed together. Simplest example from https://climate-machine.github.io/Oceananigans.jl/stable/generated/one_dimensional_diffusion/; ```julia; anim = @animate for i=1:100; simulation.stop_iteration += 100; run!(simulation). plot(interior(T)[1, 1, :], zC, linewidth=2, title=tracer_label(model),; label="""", xlabel=""Tracer concentration"", ylabel=""z"", xlims=(0, 1)); end. mp4(anim, ""1d_diffusion.mp4"", fps = 15) # hide; ```. I don't think that's a clean use of the simulation class. I think we should add an output writer, run the simulation, then have a separate loop that reads the output and plots/animates it.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/676
https://github.com/CliMA/Oceananigans.jl/pull/677:654,Modifiability,refactor,refactoring,654,"This PR modifies the time-stepping algorithm so that the tendencies for wall-normal velocity components are calculated on boundaries in `Bounded` directions. In other words, when `x` is `Bounded`, the algorithm now calculates `Gu` on east boundaries, where `i=Nx+1`. Previously `Gu` was only calculated on west boundaries where `i=1`. The same applies to `y` and `z`. This change is necessary because, in general, the values of `Gu`, `Gv`, and `Gw` on `x`, `y`, or `z` boundaries are needed to impose predictor velocity and pressure boundary conditions when `x`, `y`, or `z` are `Bounded` --- respectively. The changes in this PR also motivated a slight refactoring of the way ""equations"" are specified. There is now a file dedicated to equation / tendency specification, called `velocity_and_tracer_tendencies.jl` in `src/TimeStepping`. Resolves #259 (since it implements a simple / minimal abstraction for equations).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/677
https://github.com/CliMA/Oceananigans.jl/pull/677:501,Safety,predict,predictor,501,"This PR modifies the time-stepping algorithm so that the tendencies for wall-normal velocity components are calculated on boundaries in `Bounded` directions. In other words, when `x` is `Bounded`, the algorithm now calculates `Gu` on east boundaries, where `i=Nx+1`. Previously `Gu` was only calculated on west boundaries where `i=1`. The same applies to `y` and `z`. This change is necessary because, in general, the values of `Gu`, `Gv`, and `Gw` on `x`, `y`, or `z` boundaries are needed to impose predictor velocity and pressure boundary conditions when `x`, `y`, or `z` are `Bounded` --- respectively. The changes in this PR also motivated a slight refactoring of the way ""equations"" are specified. There is now a file dedicated to equation / tendency specification, called `velocity_and_tracer_tendencies.jl` in `src/TimeStepping`. Resolves #259 (since it implements a simple / minimal abstraction for equations).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/677
https://github.com/CliMA/Oceananigans.jl/pull/677:875,Usability,simpl,simple,875,"This PR modifies the time-stepping algorithm so that the tendencies for wall-normal velocity components are calculated on boundaries in `Bounded` directions. In other words, when `x` is `Bounded`, the algorithm now calculates `Gu` on east boundaries, where `i=Nx+1`. Previously `Gu` was only calculated on west boundaries where `i=1`. The same applies to `y` and `z`. This change is necessary because, in general, the values of `Gu`, `Gv`, and `Gw` on `x`, `y`, or `z` boundaries are needed to impose predictor velocity and pressure boundary conditions when `x`, `y`, or `z` are `Bounded` --- respectively. The changes in this PR also motivated a slight refactoring of the way ""equations"" are specified. There is now a file dedicated to equation / tendency specification, called `velocity_and_tracer_tendencies.jl` in `src/TimeStepping`. Resolves #259 (since it implements a simple / minimal abstraction for equations).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/677
https://github.com/CliMA/Oceananigans.jl/issues/679:75,Availability,error,error,75,"I tried running the first example listed in README and I got the following error:; ```; julia> topology = (Periodic, Periodic, Bounded); ERROR: UndefVarError: Bounded not defined; Stacktrace:; [1] top-level scope at REPL[45]:1; ```; I'm running Julia 1.4 RC2 on macOS 10.15.3.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/679
https://github.com/CliMA/Oceananigans.jl/issues/679:137,Availability,ERROR,ERROR,137,"I tried running the first example listed in README and I got the following error:; ```; julia> topology = (Periodic, Periodic, Bounded); ERROR: UndefVarError: Bounded not defined; Stacktrace:; [1] top-level scope at REPL[45]:1; ```; I'm running Julia 1.4 RC2 on macOS 10.15.3.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/679
https://github.com/CliMA/Oceananigans.jl/issues/682:653,Modifiability,variab,variables,653,"We currently allow users to implement custom forcing functions with the signature:. ```julia; F(i, j, k, grid, time, U, C, parameters); ```. where `U` is a named tuple of velocity fields, `C` is a named tuple of tracer fields, and `parameters` is the object passed to `IncompressibleModel` via the `parameters` keyword argument. Boundary condition functions have the signature:. ```julia; condition(i, j, grid, time, iteration, U, C, parameters); ```. To stabilize the API, we may want to get rid of `parameters`, include `clock` rather than `time` or `iteration`, and add a named tuple container called `state` that holds `U`, `C`, and any other state variables that we want to add (now or in the future) as accessible to forcing functions or boundary condition functions. I'd propose that state be defined something like. ```julia; state = (velocities=U, tracers=C, diffusivities=K, pressures=pressures, tendencies=G); ```. If we form `state` within the time-stepping loop, it could also simplify the function signatures for time-stepping kernels. Related is #565.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/682
https://github.com/CliMA/Oceananigans.jl/issues/682:709,Security,access,accessible,709,"We currently allow users to implement custom forcing functions with the signature:. ```julia; F(i, j, k, grid, time, U, C, parameters); ```. where `U` is a named tuple of velocity fields, `C` is a named tuple of tracer fields, and `parameters` is the object passed to `IncompressibleModel` via the `parameters` keyword argument. Boundary condition functions have the signature:. ```julia; condition(i, j, grid, time, iteration, U, C, parameters); ```. To stabilize the API, we may want to get rid of `parameters`, include `clock` rather than `time` or `iteration`, and add a named tuple container called `state` that holds `U`, `C`, and any other state variables that we want to add (now or in the future) as accessible to forcing functions or boundary condition functions. I'd propose that state be defined something like. ```julia; state = (velocities=U, tracers=C, diffusivities=K, pressures=pressures, tendencies=G); ```. If we form `state` within the time-stepping loop, it could also simplify the function signatures for time-stepping kernels. Related is #565.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/682
https://github.com/CliMA/Oceananigans.jl/issues/682:990,Usability,simpl,simplify,990,"We currently allow users to implement custom forcing functions with the signature:. ```julia; F(i, j, k, grid, time, U, C, parameters); ```. where `U` is a named tuple of velocity fields, `C` is a named tuple of tracer fields, and `parameters` is the object passed to `IncompressibleModel` via the `parameters` keyword argument. Boundary condition functions have the signature:. ```julia; condition(i, j, grid, time, iteration, U, C, parameters); ```. To stabilize the API, we may want to get rid of `parameters`, include `clock` rather than `time` or `iteration`, and add a named tuple container called `state` that holds `U`, `C`, and any other state variables that we want to add (now or in the future) as accessible to forcing functions or boundary condition functions. I'd propose that state be defined something like. ```julia; state = (velocities=U, tracers=C, diffusivities=K, pressures=pressures, tendencies=G); ```. If we form `state` within the time-stepping loop, it could also simplify the function signatures for time-stepping kernels. Related is #565.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/682
https://github.com/CliMA/Oceananigans.jl/issues/684:13,Testability,benchmark,benchmark,13,Even a quick benchmark at the end of the test suite would be nice to uncover issues like #675 and #397 and keep the benchmark scripts up to date.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/684
https://github.com/CliMA/Oceananigans.jl/issues/684:41,Testability,test,test,41,Even a quick benchmark at the end of the test suite would be nice to uncover issues like #675 and #397 and keep the benchmark scripts up to date.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/684
https://github.com/CliMA/Oceananigans.jl/issues/684:116,Testability,benchmark,benchmark,116,Even a quick benchmark at the end of the test suite would be nice to uncover issues like #675 and #397 and keep the benchmark scripts up to date.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/684
https://github.com/CliMA/Oceananigans.jl/pull/685:3,Availability,fault,fault,3,"My fault, must have messed up and forgot to skip `_apply_*_bcs!` for `NotFluxBC` in PR #631. . Fixes #675 and should fix failing tests on PR #671. Before:; ```; ──────────────────────────────────────────────────────────────────────────────────────; Static ocean benchmarks Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 24.3s / 2.17% 1.83GiB / 18.1% . Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────; 32× 32× 32 [CPU, Float32] 10 256ms 48.6% 25.6ms 170MiB 50.0% 17.0MiB; 32× 32× 32 [CPU, Float64] 10 270ms 51.4% 27.0ms 170MiB 50.0% 17.0MiB; ──────────────────────────────────────────────────────────────────────────────────────; ```. After:; ```; ──────────────────────────────────────────────────────────────────────────────────────; Static ocean benchmarks Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 126s / 62.8% 1.46GiB / 0.13% . Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────; 32× 32× 32 [CPU, Float32] 10 39.4s 49.9% 3.94s 1.00MiB 50.0% 102KiB; 32× 32× 32 [CPU, Float64] 10 39.5s 50.1% 3.95s 1.00MiB 50.0% 102KiB; ──────────────────────────────────────────────────────────────────────────────────────; ```. Unfortunately still a bit higher than v0.22.0 (~50 KiB allocations) but much better and more acceptable than 17 MiB!. Remaining memory allocations seem to be occuring in `fill_halo_regions.jl` but tried inlining some functions and didn't help so I'll revisit the problem in the future. ```; julia> analyze_malloc("".""); 323-element Array{CoverageTools.MallocInfo,1}: ; ⋮ ; CoverageTools.MallocInfo(5008, ""./benchmark/benchmark_static_ocean.jl.32885.mem"", 36) ; CoverageTools.MallocInfo(5952, ""./benchmark/benchmark_utils.jl.32885.mem"", 35) ; CoverageTools.MallocInfo(6080, ""./src/TimeSteppers/time_stepping_kernels.jl.32885.mem"", 139) ; Cove",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/685
https://github.com/CliMA/Oceananigans.jl/pull/685:129,Testability,test,tests,129,"My fault, must have messed up and forgot to skip `_apply_*_bcs!` for `NotFluxBC` in PR #631. . Fixes #675 and should fix failing tests on PR #671. Before:; ```; ──────────────────────────────────────────────────────────────────────────────────────; Static ocean benchmarks Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 24.3s / 2.17% 1.83GiB / 18.1% . Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────; 32× 32× 32 [CPU, Float32] 10 256ms 48.6% 25.6ms 170MiB 50.0% 17.0MiB; 32× 32× 32 [CPU, Float64] 10 270ms 51.4% 27.0ms 170MiB 50.0% 17.0MiB; ──────────────────────────────────────────────────────────────────────────────────────; ```. After:; ```; ──────────────────────────────────────────────────────────────────────────────────────; Static ocean benchmarks Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 126s / 62.8% 1.46GiB / 0.13% . Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────; 32× 32× 32 [CPU, Float32] 10 39.4s 49.9% 3.94s 1.00MiB 50.0% 102KiB; 32× 32× 32 [CPU, Float64] 10 39.5s 50.1% 3.95s 1.00MiB 50.0% 102KiB; ──────────────────────────────────────────────────────────────────────────────────────; ```. Unfortunately still a bit higher than v0.22.0 (~50 KiB allocations) but much better and more acceptable than 17 MiB!. Remaining memory allocations seem to be occuring in `fill_halo_regions.jl` but tried inlining some functions and didn't help so I'll revisit the problem in the future. ```; julia> analyze_malloc("".""); 323-element Array{CoverageTools.MallocInfo,1}: ; ⋮ ; CoverageTools.MallocInfo(5008, ""./benchmark/benchmark_static_ocean.jl.32885.mem"", 36) ; CoverageTools.MallocInfo(5952, ""./benchmark/benchmark_utils.jl.32885.mem"", 35) ; CoverageTools.MallocInfo(6080, ""./src/TimeSteppers/time_stepping_kernels.jl.32885.mem"", 139) ; Cove",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/685
https://github.com/CliMA/Oceananigans.jl/pull/685:262,Testability,benchmark,benchmarks,262,"My fault, must have messed up and forgot to skip `_apply_*_bcs!` for `NotFluxBC` in PR #631. . Fixes #675 and should fix failing tests on PR #671. Before:; ```; ──────────────────────────────────────────────────────────────────────────────────────; Static ocean benchmarks Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 24.3s / 2.17% 1.83GiB / 18.1% . Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────; 32× 32× 32 [CPU, Float32] 10 256ms 48.6% 25.6ms 170MiB 50.0% 17.0MiB; 32× 32× 32 [CPU, Float64] 10 270ms 51.4% 27.0ms 170MiB 50.0% 17.0MiB; ──────────────────────────────────────────────────────────────────────────────────────; ```. After:; ```; ──────────────────────────────────────────────────────────────────────────────────────; Static ocean benchmarks Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 126s / 62.8% 1.46GiB / 0.13% . Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────; 32× 32× 32 [CPU, Float32] 10 39.4s 49.9% 3.94s 1.00MiB 50.0% 102KiB; 32× 32× 32 [CPU, Float64] 10 39.5s 50.1% 3.95s 1.00MiB 50.0% 102KiB; ──────────────────────────────────────────────────────────────────────────────────────; ```. Unfortunately still a bit higher than v0.22.0 (~50 KiB allocations) but much better and more acceptable than 17 MiB!. Remaining memory allocations seem to be occuring in `fill_halo_regions.jl` but tried inlining some functions and didn't help so I'll revisit the problem in the future. ```; julia> analyze_malloc("".""); 323-element Array{CoverageTools.MallocInfo,1}: ; ⋮ ; CoverageTools.MallocInfo(5008, ""./benchmark/benchmark_static_ocean.jl.32885.mem"", 36) ; CoverageTools.MallocInfo(5952, ""./benchmark/benchmark_utils.jl.32885.mem"", 35) ; CoverageTools.MallocInfo(6080, ""./src/TimeSteppers/time_stepping_kernels.jl.32885.mem"", 139) ; Cove",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/685
https://github.com/CliMA/Oceananigans.jl/pull/685:870,Testability,benchmark,benchmarks,870,"My fault, must have messed up and forgot to skip `_apply_*_bcs!` for `NotFluxBC` in PR #631. . Fixes #675 and should fix failing tests on PR #671. Before:; ```; ──────────────────────────────────────────────────────────────────────────────────────; Static ocean benchmarks Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 24.3s / 2.17% 1.83GiB / 18.1% . Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────; 32× 32× 32 [CPU, Float32] 10 256ms 48.6% 25.6ms 170MiB 50.0% 17.0MiB; 32× 32× 32 [CPU, Float64] 10 270ms 51.4% 27.0ms 170MiB 50.0% 17.0MiB; ──────────────────────────────────────────────────────────────────────────────────────; ```. After:; ```; ──────────────────────────────────────────────────────────────────────────────────────; Static ocean benchmarks Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 126s / 62.8% 1.46GiB / 0.13% . Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────; 32× 32× 32 [CPU, Float32] 10 39.4s 49.9% 3.94s 1.00MiB 50.0% 102KiB; 32× 32× 32 [CPU, Float64] 10 39.5s 50.1% 3.95s 1.00MiB 50.0% 102KiB; ──────────────────────────────────────────────────────────────────────────────────────; ```. Unfortunately still a bit higher than v0.22.0 (~50 KiB allocations) but much better and more acceptable than 17 MiB!. Remaining memory allocations seem to be occuring in `fill_halo_regions.jl` but tried inlining some functions and didn't help so I'll revisit the problem in the future. ```; julia> analyze_malloc("".""); 323-element Array{CoverageTools.MallocInfo,1}: ; ⋮ ; CoverageTools.MallocInfo(5008, ""./benchmark/benchmark_static_ocean.jl.32885.mem"", 36) ; CoverageTools.MallocInfo(5952, ""./benchmark/benchmark_utils.jl.32885.mem"", 35) ; CoverageTools.MallocInfo(6080, ""./src/TimeSteppers/time_stepping_kernels.jl.32885.mem"", 139) ; Cove",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/685
https://github.com/CliMA/Oceananigans.jl/pull/685:1767,Testability,benchmark,benchmark,1767,"────────────────────────────────────────────────────────────────────────; Static ocean benchmarks Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 126s / 62.8% 1.46GiB / 0.13% . Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────; 32× 32× 32 [CPU, Float32] 10 39.4s 49.9% 3.94s 1.00MiB 50.0% 102KiB; 32× 32× 32 [CPU, Float64] 10 39.5s 50.1% 3.95s 1.00MiB 50.0% 102KiB; ──────────────────────────────────────────────────────────────────────────────────────; ```. Unfortunately still a bit higher than v0.22.0 (~50 KiB allocations) but much better and more acceptable than 17 MiB!. Remaining memory allocations seem to be occuring in `fill_halo_regions.jl` but tried inlining some functions and didn't help so I'll revisit the problem in the future. ```; julia> analyze_malloc("".""); 323-element Array{CoverageTools.MallocInfo,1}: ; ⋮ ; CoverageTools.MallocInfo(5008, ""./benchmark/benchmark_static_ocean.jl.32885.mem"", 36) ; CoverageTools.MallocInfo(5952, ""./benchmark/benchmark_utils.jl.32885.mem"", 35) ; CoverageTools.MallocInfo(6080, ""./src/TimeSteppers/time_stepping_kernels.jl.32885.mem"", 139) ; CoverageTools.MallocInfo(7136, ""./src/Architectures.jl.32885.mem"", 39) ; CoverageTools.MallocInfo(12160, ""./src/Utils/tuple_utils.jl.32885.mem"", 14) ; CoverageTools.MallocInfo(12480, ""./src/BoundaryConditions/apply_no_penetration_bcs.jl.32885.mem"", 20); CoverageTools.MallocInfo(12480, ""./src/BoundaryConditions/apply_no_penetration_bcs.jl.32885.mem"", 38); CoverageTools.MallocInfo(12800, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 45) ; CoverageTools.MallocInfo(12800, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 49) ; CoverageTools.MallocInfo(16640, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 52) ; CoverageTools.MallocInfo(16640, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 53) ; CoverageTools.MallocInfo(16640, ""./src/Bo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/685
https://github.com/CliMA/Oceananigans.jl/pull/685:1855,Testability,benchmark,benchmark,1855,"an benchmarks Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 126s / 62.8% 1.46GiB / 0.13% . Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────; 32× 32× 32 [CPU, Float32] 10 39.4s 49.9% 3.94s 1.00MiB 50.0% 102KiB; 32× 32× 32 [CPU, Float64] 10 39.5s 50.1% 3.95s 1.00MiB 50.0% 102KiB; ──────────────────────────────────────────────────────────────────────────────────────; ```. Unfortunately still a bit higher than v0.22.0 (~50 KiB allocations) but much better and more acceptable than 17 MiB!. Remaining memory allocations seem to be occuring in `fill_halo_regions.jl` but tried inlining some functions and didn't help so I'll revisit the problem in the future. ```; julia> analyze_malloc("".""); 323-element Array{CoverageTools.MallocInfo,1}: ; ⋮ ; CoverageTools.MallocInfo(5008, ""./benchmark/benchmark_static_ocean.jl.32885.mem"", 36) ; CoverageTools.MallocInfo(5952, ""./benchmark/benchmark_utils.jl.32885.mem"", 35) ; CoverageTools.MallocInfo(6080, ""./src/TimeSteppers/time_stepping_kernels.jl.32885.mem"", 139) ; CoverageTools.MallocInfo(7136, ""./src/Architectures.jl.32885.mem"", 39) ; CoverageTools.MallocInfo(12160, ""./src/Utils/tuple_utils.jl.32885.mem"", 14) ; CoverageTools.MallocInfo(12480, ""./src/BoundaryConditions/apply_no_penetration_bcs.jl.32885.mem"", 20); CoverageTools.MallocInfo(12480, ""./src/BoundaryConditions/apply_no_penetration_bcs.jl.32885.mem"", 38); CoverageTools.MallocInfo(12800, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 45) ; CoverageTools.MallocInfo(12800, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 49) ; CoverageTools.MallocInfo(16640, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 52) ; CoverageTools.MallocInfo(16640, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 53) ; CoverageTools.MallocInfo(16640, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 56) ; CoverageTools.MallocInfo(1664",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/685
https://github.com/CliMA/Oceananigans.jl/pull/685:3839,Testability,benchmark,benchmark,3839,"Info(12480, ""./src/BoundaryConditions/apply_no_penetration_bcs.jl.32885.mem"", 20); CoverageTools.MallocInfo(12480, ""./src/BoundaryConditions/apply_no_penetration_bcs.jl.32885.mem"", 38); CoverageTools.MallocInfo(12800, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 45) ; CoverageTools.MallocInfo(12800, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 49) ; CoverageTools.MallocInfo(16640, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 52) ; CoverageTools.MallocInfo(16640, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 53) ; CoverageTools.MallocInfo(16640, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 56) ; CoverageTools.MallocInfo(16640, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 57) ; CoverageTools.MallocInfo(44000, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 26) ; CoverageTools.MallocInfo(44000, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 27) ; CoverageTools.MallocInfo(44000, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 28) ; CoverageTools.MallocInfo(44000, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 29) ; CoverageTools.MallocInfo(44000, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 30) ; CoverageTools.MallocInfo(46400, ""./src/BoundaryConditions/apply_flux_bcs.jl.32885.mem"", 17) ; CoverageTools.MallocInfo(46400, ""./src/BoundaryConditions/apply_flux_bcs.jl.32885.mem"", 30) ; CoverageTools.MallocInfo(56320, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 20) ; CoverageTools.MallocInfo(95040, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 25) ; CoverageTools.MallocInfo(235751, ""./benchmark/benchmark_static_ocean.jl.32885.mem"", 55) ; CoverageTools.MallocInfo(249600, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 70) ; CoverageTools.MallocInfo(739712, ""./benchmark/benchmark_utils.jl.32885.mem"", 20) ; CoverageTools.MallocInfo(1686022, ""./benchmark/benchmark_static_ocean.jl.32885.mem"", 50) ; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/685
https://github.com/CliMA/Oceananigans.jl/pull/685:4027,Testability,benchmark,benchmark,4027,"Info(12480, ""./src/BoundaryConditions/apply_no_penetration_bcs.jl.32885.mem"", 20); CoverageTools.MallocInfo(12480, ""./src/BoundaryConditions/apply_no_penetration_bcs.jl.32885.mem"", 38); CoverageTools.MallocInfo(12800, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 45) ; CoverageTools.MallocInfo(12800, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 49) ; CoverageTools.MallocInfo(16640, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 52) ; CoverageTools.MallocInfo(16640, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 53) ; CoverageTools.MallocInfo(16640, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 56) ; CoverageTools.MallocInfo(16640, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 57) ; CoverageTools.MallocInfo(44000, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 26) ; CoverageTools.MallocInfo(44000, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 27) ; CoverageTools.MallocInfo(44000, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 28) ; CoverageTools.MallocInfo(44000, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 29) ; CoverageTools.MallocInfo(44000, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 30) ; CoverageTools.MallocInfo(46400, ""./src/BoundaryConditions/apply_flux_bcs.jl.32885.mem"", 17) ; CoverageTools.MallocInfo(46400, ""./src/BoundaryConditions/apply_flux_bcs.jl.32885.mem"", 30) ; CoverageTools.MallocInfo(56320, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 20) ; CoverageTools.MallocInfo(95040, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 25) ; CoverageTools.MallocInfo(235751, ""./benchmark/benchmark_static_ocean.jl.32885.mem"", 55) ; CoverageTools.MallocInfo(249600, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 70) ; CoverageTools.MallocInfo(739712, ""./benchmark/benchmark_utils.jl.32885.mem"", 20) ; CoverageTools.MallocInfo(1686022, ""./benchmark/benchmark_static_ocean.jl.32885.mem"", 50) ; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/685
https://github.com/CliMA/Oceananigans.jl/pull/685:4111,Testability,benchmark,benchmark,4111,"Info(12480, ""./src/BoundaryConditions/apply_no_penetration_bcs.jl.32885.mem"", 20); CoverageTools.MallocInfo(12480, ""./src/BoundaryConditions/apply_no_penetration_bcs.jl.32885.mem"", 38); CoverageTools.MallocInfo(12800, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 45) ; CoverageTools.MallocInfo(12800, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 49) ; CoverageTools.MallocInfo(16640, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 52) ; CoverageTools.MallocInfo(16640, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 53) ; CoverageTools.MallocInfo(16640, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 56) ; CoverageTools.MallocInfo(16640, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 57) ; CoverageTools.MallocInfo(44000, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 26) ; CoverageTools.MallocInfo(44000, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 27) ; CoverageTools.MallocInfo(44000, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 28) ; CoverageTools.MallocInfo(44000, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 29) ; CoverageTools.MallocInfo(44000, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 30) ; CoverageTools.MallocInfo(46400, ""./src/BoundaryConditions/apply_flux_bcs.jl.32885.mem"", 17) ; CoverageTools.MallocInfo(46400, ""./src/BoundaryConditions/apply_flux_bcs.jl.32885.mem"", 30) ; CoverageTools.MallocInfo(56320, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 20) ; CoverageTools.MallocInfo(95040, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 25) ; CoverageTools.MallocInfo(235751, ""./benchmark/benchmark_static_ocean.jl.32885.mem"", 55) ; CoverageTools.MallocInfo(249600, ""./src/BoundaryConditions/fill_halo_regions.jl.32885.mem"", 70) ; CoverageTools.MallocInfo(739712, ""./benchmark/benchmark_utils.jl.32885.mem"", 20) ; CoverageTools.MallocInfo(1686022, ""./benchmark/benchmark_static_ocean.jl.32885.mem"", 50) ; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/685
https://github.com/CliMA/Oceananigans.jl/issues/686:128,Availability,error,error,128,"I tried to run the `eady_turbulence.jl` example in Oceananigans v0.25.0 in Julia 1.4 RC2 on macOS 10.15.3 and got the following error:. ```; julia> include(""eady_turbulence.jl""); [ Info: CUDAdrv.jl failed to initialize, GPU functionality unavailable (set JULIA_CUDA_SILENT or JULIA_CUDA_VERBOSE to silence or expand this message); N² = ((Rᵈ * f) / Lz) ^ 2 = 0.0004; α = sqrt(N²) / (f * σᵇ) = 0.02314814814814815; ERROR: LoadError: UndefVarError: SolutionBoundaryConditions not defined; Stacktrace:; [1] top-level scope at /Users/truedichotomy/GitHub/Oceananigans.jl/examples/eady_turbulence.jl:138; [2] include(::String) at ./client.jl:439; [3] top-level scope at REPL[1]:1; in expression starting at /Users/truedichotomy/GitHub/Oceananigans.jl/examples/eady_turbulence.jl:138; ```; I noticed that there are a lot of recent commits with regards to boundary conditions, may be the example is using an older interface?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/686
https://github.com/CliMA/Oceananigans.jl/issues/686:413,Availability,ERROR,ERROR,413,"I tried to run the `eady_turbulence.jl` example in Oceananigans v0.25.0 in Julia 1.4 RC2 on macOS 10.15.3 and got the following error:. ```; julia> include(""eady_turbulence.jl""); [ Info: CUDAdrv.jl failed to initialize, GPU functionality unavailable (set JULIA_CUDA_SILENT or JULIA_CUDA_VERBOSE to silence or expand this message); N² = ((Rᵈ * f) / Lz) ^ 2 = 0.0004; α = sqrt(N²) / (f * σᵇ) = 0.02314814814814815; ERROR: LoadError: UndefVarError: SolutionBoundaryConditions not defined; Stacktrace:; [1] top-level scope at /Users/truedichotomy/GitHub/Oceananigans.jl/examples/eady_turbulence.jl:138; [2] include(::String) at ./client.jl:439; [3] top-level scope at REPL[1]:1; in expression starting at /Users/truedichotomy/GitHub/Oceananigans.jl/examples/eady_turbulence.jl:138; ```; I noticed that there are a lot of recent commits with regards to boundary conditions, may be the example is using an older interface?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/686
https://github.com/CliMA/Oceananigans.jl/issues/686:321,Integrability,message,message,321,"I tried to run the `eady_turbulence.jl` example in Oceananigans v0.25.0 in Julia 1.4 RC2 on macOS 10.15.3 and got the following error:. ```; julia> include(""eady_turbulence.jl""); [ Info: CUDAdrv.jl failed to initialize, GPU functionality unavailable (set JULIA_CUDA_SILENT or JULIA_CUDA_VERBOSE to silence or expand this message); N² = ((Rᵈ * f) / Lz) ^ 2 = 0.0004; α = sqrt(N²) / (f * σᵇ) = 0.02314814814814815; ERROR: LoadError: UndefVarError: SolutionBoundaryConditions not defined; Stacktrace:; [1] top-level scope at /Users/truedichotomy/GitHub/Oceananigans.jl/examples/eady_turbulence.jl:138; [2] include(::String) at ./client.jl:439; [3] top-level scope at REPL[1]:1; in expression starting at /Users/truedichotomy/GitHub/Oceananigans.jl/examples/eady_turbulence.jl:138; ```; I noticed that there are a lot of recent commits with regards to boundary conditions, may be the example is using an older interface?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/686
https://github.com/CliMA/Oceananigans.jl/issues/686:906,Integrability,interface,interface,906,"I tried to run the `eady_turbulence.jl` example in Oceananigans v0.25.0 in Julia 1.4 RC2 on macOS 10.15.3 and got the following error:. ```; julia> include(""eady_turbulence.jl""); [ Info: CUDAdrv.jl failed to initialize, GPU functionality unavailable (set JULIA_CUDA_SILENT or JULIA_CUDA_VERBOSE to silence or expand this message); N² = ((Rᵈ * f) / Lz) ^ 2 = 0.0004; α = sqrt(N²) / (f * σᵇ) = 0.02314814814814815; ERROR: LoadError: UndefVarError: SolutionBoundaryConditions not defined; Stacktrace:; [1] top-level scope at /Users/truedichotomy/GitHub/Oceananigans.jl/examples/eady_turbulence.jl:138; [2] include(::String) at ./client.jl:439; [3] top-level scope at REPL[1]:1; in expression starting at /Users/truedichotomy/GitHub/Oceananigans.jl/examples/eady_turbulence.jl:138; ```; I noticed that there are a lot of recent commits with regards to boundary conditions, may be the example is using an older interface?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/686
https://github.com/CliMA/Oceananigans.jl/issues/686:420,Performance,Load,LoadError,420,"I tried to run the `eady_turbulence.jl` example in Oceananigans v0.25.0 in Julia 1.4 RC2 on macOS 10.15.3 and got the following error:. ```; julia> include(""eady_turbulence.jl""); [ Info: CUDAdrv.jl failed to initialize, GPU functionality unavailable (set JULIA_CUDA_SILENT or JULIA_CUDA_VERBOSE to silence or expand this message); N² = ((Rᵈ * f) / Lz) ^ 2 = 0.0004; α = sqrt(N²) / (f * σᵇ) = 0.02314814814814815; ERROR: LoadError: UndefVarError: SolutionBoundaryConditions not defined; Stacktrace:; [1] top-level scope at /Users/truedichotomy/GitHub/Oceananigans.jl/examples/eady_turbulence.jl:138; [2] include(::String) at ./client.jl:439; [3] top-level scope at REPL[1]:1; in expression starting at /Users/truedichotomy/GitHub/Oceananigans.jl/examples/eady_turbulence.jl:138; ```; I noticed that there are a lot of recent commits with regards to boundary conditions, may be the example is using an older interface?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/686
https://github.com/CliMA/Oceananigans.jl/pull/688:174,Testability,test,tested,174,"This pull request changes the compat entry for the `CUDAdrv` package from `^3.1, ^5` to `^3.1, ^5, 6.0`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/688
https://github.com/CliMA/Oceananigans.jl/pull/688:279,Testability,test,tests,279,"This pull request changes the compat entry for the `CUDAdrv` package from `^3.1, ^5` to `^3.1, ^5, 6.0`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/688
https://github.com/CliMA/Oceananigans.jl/pull/689:174,Testability,test,tested,174,"This pull request changes the compat entry for the `CUDAapi` package from `^1.1, ^2` to `^1.1, ^2, 4.0`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/689
https://github.com/CliMA/Oceananigans.jl/pull/689:279,Testability,test,tests,279,"This pull request changes the compat entry for the `CUDAapi` package from `^1.1, ^2` to `^1.1, ^2, 4.0`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/689
https://github.com/CliMA/Oceananigans.jl/issues/692:507,Integrability,wrap,wrapper,507,"@johncmarshall54 has suggested we switch to a full equation of state for seawater for LESbrary simulations as temperature and salinity profiles from state estimates may not be statically stable in Oceananigans when using a linear equation of state. The Roquet et al. (2015a) idealized nonlinear equation of state should be better. Ideally we would use the same equation of state as ECCO/SOSE I think, but TEOS-10 should be what we aim for I suppose. I think we have a couple of options:; 1. There's a Julia wrapper for the TEOS-10 C library but this probably won't work on the GPU: https://github.com/ax1ine/GSW.jl; 2. A 6+52-term polynomial approximation to TEOS-10, accurate to ~0.1% and suitable for Boussinesq models, from Roquet et al. (2015b). We can code up a pure Julia version as there already exist Python, MATLAB, and Fortran implementations here: https://github.com/fabien-roquet/polyTEOS (Thank you @fabien-roquet!). In implementing a pure Julia TEOS-10 equation of state we should make sure it can be shared between Oceananigans and CliMA Ocean (cc @blallen). cc @jm-c @christophernhill @glwagner @rafferrari who might have suggestions or comments. @leios Do you think evaluating a 52-term polynomial at every grid point will be problematic on the GPU? I imagine GPUs should be fast at evaluating polynomials but maybe we have to be smart about storing the coefficients in memory?. References:; 1. Roquet et al. (2015a), ""Defining a Simplified Yet “Realistic” Equation of State for Seawater"", DOI: https://doi.org/10.1175/JPO-D-15-0080.1; 2. Roquet et al. (2015b), ""Accurate polynomial expressions for the density and specific volume of seawater using the TEOS-10 standard"", DOI: https://doi.org/10.1016/j.ocemod.2015.04.002",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/692
https://github.com/CliMA/Oceananigans.jl/issues/692:1447,Usability,Simpl,Simplified,1447,"@johncmarshall54 has suggested we switch to a full equation of state for seawater for LESbrary simulations as temperature and salinity profiles from state estimates may not be statically stable in Oceananigans when using a linear equation of state. The Roquet et al. (2015a) idealized nonlinear equation of state should be better. Ideally we would use the same equation of state as ECCO/SOSE I think, but TEOS-10 should be what we aim for I suppose. I think we have a couple of options:; 1. There's a Julia wrapper for the TEOS-10 C library but this probably won't work on the GPU: https://github.com/ax1ine/GSW.jl; 2. A 6+52-term polynomial approximation to TEOS-10, accurate to ~0.1% and suitable for Boussinesq models, from Roquet et al. (2015b). We can code up a pure Julia version as there already exist Python, MATLAB, and Fortran implementations here: https://github.com/fabien-roquet/polyTEOS (Thank you @fabien-roquet!). In implementing a pure Julia TEOS-10 equation of state we should make sure it can be shared between Oceananigans and CliMA Ocean (cc @blallen). cc @jm-c @christophernhill @glwagner @rafferrari who might have suggestions or comments. @leios Do you think evaluating a 52-term polynomial at every grid point will be problematic on the GPU? I imagine GPUs should be fast at evaluating polynomials but maybe we have to be smart about storing the coefficients in memory?. References:; 1. Roquet et al. (2015a), ""Defining a Simplified Yet “Realistic” Equation of State for Seawater"", DOI: https://doi.org/10.1175/JPO-D-15-0080.1; 2. Roquet et al. (2015b), ""Accurate polynomial expressions for the density and specific volume of seawater using the TEOS-10 standard"", DOI: https://doi.org/10.1016/j.ocemod.2015.04.002",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/692
https://github.com/CliMA/Oceananigans.jl/pull/693:15,Deployability,continuous,continuous,15,"This PR uses a continuous forcing immersed boundary method to simulate viscous flow around a cylinder. I think this is a pretty common test case of CFD codes: as you increase the Reynolds number, you should start to see vortex shedding behind the cylinder which we do see. Movie: https://www.youtube.com/watch?v=s7u_OJXFMoQ; ![image](https://user-images.githubusercontent.com/20099589/76267706-05081200-6242-11ea-8567-41068235616e.png). I think it shows the ease with which Oceananigans can support topography and arbitrary boundaries that could even depend on time: e.g. static cavities in ice shelves, an urban skyline, or a moving lid (non-interacting ice floe?). This method is much simpler to implement than sigma coordinates, is more flexible, and is probably pretty accurate for most problems you'd try to model with Oceananigans (i.e. we're not modeling coastlines on a sphere). Should discuss what an API for topography/boundaries would look like before finishing this PR off. See #694. X-Ref #530",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/693
https://github.com/CliMA/Oceananigans.jl/pull/693:551,Integrability,depend,depend,551,"This PR uses a continuous forcing immersed boundary method to simulate viscous flow around a cylinder. I think this is a pretty common test case of CFD codes: as you increase the Reynolds number, you should start to see vortex shedding behind the cylinder which we do see. Movie: https://www.youtube.com/watch?v=s7u_OJXFMoQ; ![image](https://user-images.githubusercontent.com/20099589/76267706-05081200-6242-11ea-8567-41068235616e.png). I think it shows the ease with which Oceananigans can support topography and arbitrary boundaries that could even depend on time: e.g. static cavities in ice shelves, an urban skyline, or a moving lid (non-interacting ice floe?). This method is much simpler to implement than sigma coordinates, is more flexible, and is probably pretty accurate for most problems you'd try to model with Oceananigans (i.e. we're not modeling coastlines on a sphere). Should discuss what an API for topography/boundaries would look like before finishing this PR off. See #694. X-Ref #530",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/693
https://github.com/CliMA/Oceananigans.jl/pull/693:740,Modifiability,flexible,flexible,740,"This PR uses a continuous forcing immersed boundary method to simulate viscous flow around a cylinder. I think this is a pretty common test case of CFD codes: as you increase the Reynolds number, you should start to see vortex shedding behind the cylinder which we do see. Movie: https://www.youtube.com/watch?v=s7u_OJXFMoQ; ![image](https://user-images.githubusercontent.com/20099589/76267706-05081200-6242-11ea-8567-41068235616e.png). I think it shows the ease with which Oceananigans can support topography and arbitrary boundaries that could even depend on time: e.g. static cavities in ice shelves, an urban skyline, or a moving lid (non-interacting ice floe?). This method is much simpler to implement than sigma coordinates, is more flexible, and is probably pretty accurate for most problems you'd try to model with Oceananigans (i.e. we're not modeling coastlines on a sphere). Should discuss what an API for topography/boundaries would look like before finishing this PR off. See #694. X-Ref #530",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/693
https://github.com/CliMA/Oceananigans.jl/pull/693:135,Testability,test,test,135,"This PR uses a continuous forcing immersed boundary method to simulate viscous flow around a cylinder. I think this is a pretty common test case of CFD codes: as you increase the Reynolds number, you should start to see vortex shedding behind the cylinder which we do see. Movie: https://www.youtube.com/watch?v=s7u_OJXFMoQ; ![image](https://user-images.githubusercontent.com/20099589/76267706-05081200-6242-11ea-8567-41068235616e.png). I think it shows the ease with which Oceananigans can support topography and arbitrary boundaries that could even depend on time: e.g. static cavities in ice shelves, an urban skyline, or a moving lid (non-interacting ice floe?). This method is much simpler to implement than sigma coordinates, is more flexible, and is probably pretty accurate for most problems you'd try to model with Oceananigans (i.e. we're not modeling coastlines on a sphere). Should discuss what an API for topography/boundaries would look like before finishing this PR off. See #694. X-Ref #530",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/693
https://github.com/CliMA/Oceananigans.jl/pull/693:687,Usability,simpl,simpler,687,"This PR uses a continuous forcing immersed boundary method to simulate viscous flow around a cylinder. I think this is a pretty common test case of CFD codes: as you increase the Reynolds number, you should start to see vortex shedding behind the cylinder which we do see. Movie: https://www.youtube.com/watch?v=s7u_OJXFMoQ; ![image](https://user-images.githubusercontent.com/20099589/76267706-05081200-6242-11ea-8567-41068235616e.png). I think it shows the ease with which Oceananigans can support topography and arbitrary boundaries that could even depend on time: e.g. static cavities in ice shelves, an urban skyline, or a moving lid (non-interacting ice floe?). This method is much simpler to implement than sigma coordinates, is more flexible, and is probably pretty accurate for most problems you'd try to model with Oceananigans (i.e. we're not modeling coastlines on a sphere). Should discuss what an API for topography/boundaries would look like before finishing this PR off. See #694. X-Ref #530",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/693
https://github.com/CliMA/Oceananigans.jl/pull/697:880,Deployability,release,release,880,"This PR simplifies the function signatures for boundary condition functions and forcing functions. ; It also nukes the `model.parameters` field in favor of more local ""parameters"" functionality, and adds `ParameterizedForcing` and `ParameterizedBoundaryCondition` convenience types and functions. The new forcing function signature is. ```julia; F(i, j, k, grid, clock, state); ```. while the new boundary condition function signature is. ```julia; bc(i, j, grid, clock, state); ```. where `i, j` are indices along the boundary. `state` is a `NamedTuple` with fields `:velocities`, `:tracers`, and `:diffusivities`, each corresponding to an `OffsetArray` that references the data associated with each field. In the future, if we make substantial changes to `model`, the hope is that we can modify/extend `state` appropriately and thus leave user code unbroken. We should probably release a new minor version when this is merged. Resolves #682 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/697
https://github.com/CliMA/Oceananigans.jl/pull/697:205,Modifiability,Parameteriz,ParameterizedForcing,205,"This PR simplifies the function signatures for boundary condition functions and forcing functions. ; It also nukes the `model.parameters` field in favor of more local ""parameters"" functionality, and adds `ParameterizedForcing` and `ParameterizedBoundaryCondition` convenience types and functions. The new forcing function signature is. ```julia; F(i, j, k, grid, clock, state); ```. while the new boundary condition function signature is. ```julia; bc(i, j, grid, clock, state); ```. where `i, j` are indices along the boundary. `state` is a `NamedTuple` with fields `:velocities`, `:tracers`, and `:diffusivities`, each corresponding to an `OffsetArray` that references the data associated with each field. In the future, if we make substantial changes to `model`, the hope is that we can modify/extend `state` appropriately and thus leave user code unbroken. We should probably release a new minor version when this is merged. Resolves #682 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/697
https://github.com/CliMA/Oceananigans.jl/pull/697:232,Modifiability,Parameteriz,ParameterizedBoundaryCondition,232,"This PR simplifies the function signatures for boundary condition functions and forcing functions. ; It also nukes the `model.parameters` field in favor of more local ""parameters"" functionality, and adds `ParameterizedForcing` and `ParameterizedBoundaryCondition` convenience types and functions. The new forcing function signature is. ```julia; F(i, j, k, grid, clock, state); ```. while the new boundary condition function signature is. ```julia; bc(i, j, grid, clock, state); ```. where `i, j` are indices along the boundary. `state` is a `NamedTuple` with fields `:velocities`, `:tracers`, and `:diffusivities`, each corresponding to an `OffsetArray` that references the data associated with each field. In the future, if we make substantial changes to `model`, the hope is that we can modify/extend `state` appropriately and thus leave user code unbroken. We should probably release a new minor version when this is merged. Resolves #682 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/697
https://github.com/CliMA/Oceananigans.jl/pull/697:797,Modifiability,extend,extend,797,"This PR simplifies the function signatures for boundary condition functions and forcing functions. ; It also nukes the `model.parameters` field in favor of more local ""parameters"" functionality, and adds `ParameterizedForcing` and `ParameterizedBoundaryCondition` convenience types and functions. The new forcing function signature is. ```julia; F(i, j, k, grid, clock, state); ```. while the new boundary condition function signature is. ```julia; bc(i, j, grid, clock, state); ```. where `i, j` are indices along the boundary. `state` is a `NamedTuple` with fields `:velocities`, `:tracers`, and `:diffusivities`, each corresponding to an `OffsetArray` that references the data associated with each field. In the future, if we make substantial changes to `model`, the hope is that we can modify/extend `state` appropriately and thus leave user code unbroken. We should probably release a new minor version when this is merged. Resolves #682 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/697
https://github.com/CliMA/Oceananigans.jl/pull/697:8,Usability,simpl,simplifies,8,"This PR simplifies the function signatures for boundary condition functions and forcing functions. ; It also nukes the `model.parameters` field in favor of more local ""parameters"" functionality, and adds `ParameterizedForcing` and `ParameterizedBoundaryCondition` convenience types and functions. The new forcing function signature is. ```julia; F(i, j, k, grid, clock, state); ```. while the new boundary condition function signature is. ```julia; bc(i, j, grid, clock, state); ```. where `i, j` are indices along the boundary. `state` is a `NamedTuple` with fields `:velocities`, `:tracers`, and `:diffusivities`, each corresponding to an `OffsetArray` that references the data associated with each field. In the future, if we make substantial changes to `model`, the hope is that we can modify/extend `state` appropriately and thus leave user code unbroken. We should probably release a new minor version when this is merged. Resolves #682 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/697
https://github.com/CliMA/Oceananigans.jl/pull/698:1126,Availability,checkpoint,checkpointer,1126,"This PR refactors the FieldBoundaryConditions constructor to allow a consistent user API for specifying field locations. Field locations are specified with _uninstantiated_ types: in other words, a location is . ```julia; (Face, Cell, Cell); ```. rather than. ```julia; (Face(), Cell(), Cell()); ```. The latter form was deemed too much `()`. This is open to debate of course. I am slightly worried the former form is non-Julian. But it seems fairly unequivocal that it's easier to read. I also took the opportunity to clean up field constructors a bit. We now have the concept of _default_ boundary conditions; mostly, this is useful when a user wants to build a field that will never call `fill_halo_regions` and therefore its boundary conditions are irrelevant. I changed the `two_dimensionsional_turbulence.jl` example to use this default. The constructor shenanigans aren't perfect, and there is still a constructor that actually does accept instantiated locations (despite that we officially discourage it, and instantiated field locations are not supported for boundary conditions or abstract operations). It seems the checkpointer needs this special constructor. Resolves #659 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/698
https://github.com/CliMA/Oceananigans.jl/pull/698:8,Modifiability,refactor,refactors,8,"This PR refactors the FieldBoundaryConditions constructor to allow a consistent user API for specifying field locations. Field locations are specified with _uninstantiated_ types: in other words, a location is . ```julia; (Face, Cell, Cell); ```. rather than. ```julia; (Face(), Cell(), Cell()); ```. The latter form was deemed too much `()`. This is open to debate of course. I am slightly worried the former form is non-Julian. But it seems fairly unequivocal that it's easier to read. I also took the opportunity to clean up field constructors a bit. We now have the concept of _default_ boundary conditions; mostly, this is useful when a user wants to build a field that will never call `fill_halo_regions` and therefore its boundary conditions are irrelevant. I changed the `two_dimensionsional_turbulence.jl` example to use this default. The constructor shenanigans aren't perfect, and there is still a constructor that actually does accept instantiated locations (despite that we officially discourage it, and instantiated field locations are not supported for boundary conditions or abstract operations). It seems the checkpointer needs this special constructor. Resolves #659 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/698
https://github.com/CliMA/Oceananigans.jl/pull/699:317,Integrability,wrap,wrapper,317,"This PR makes it a bit easier to prescribe `BoundaryFunction`s by providing field-specific constructors. The field-specific constructors ""know"" about the locations of tracers and velocity fields and relieve the user of the (often confusing) task of specifying the `BoundaryFunction` location.; I also added a further wrapper around `BoundaryCondition` to permit patterns like. ```julia; northern_velocity(x, z, t) = cos((x - sin(t))); u_bcs = UVelocityBoundaryConditions(grid, north=UVelocityBoundaryCondition(Value, :y, northern_velocity)); ```. It doesn't look perfect to me, but I do think it's progress over what the user had to do previously. A potential source of confusion (?) is that `UVelocityBoundaryCondition` is only needed for simple boundary functions. We could alleviate this with more verbosity; eg `UVelocityFunctionBoundaryCondition` or something silly like that. But I'm hesitant because we already seem to have a verbosity problem. We need better design, not more words... I've also added a `parameters` field to `BoundaryFunction`. (It only just occurs to me that perhaps what we want are types like `Tracer()`, `U()`, `V()`, and `W()`. We might use these to classify boundary conditions and forcing functions... ?)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/699
https://github.com/CliMA/Oceananigans.jl/pull/699:740,Usability,simpl,simple,740,"This PR makes it a bit easier to prescribe `BoundaryFunction`s by providing field-specific constructors. The field-specific constructors ""know"" about the locations of tracers and velocity fields and relieve the user of the (often confusing) task of specifying the `BoundaryFunction` location.; I also added a further wrapper around `BoundaryCondition` to permit patterns like. ```julia; northern_velocity(x, z, t) = cos((x - sin(t))); u_bcs = UVelocityBoundaryConditions(grid, north=UVelocityBoundaryCondition(Value, :y, northern_velocity)); ```. It doesn't look perfect to me, but I do think it's progress over what the user had to do previously. A potential source of confusion (?) is that `UVelocityBoundaryCondition` is only needed for simple boundary functions. We could alleviate this with more verbosity; eg `UVelocityFunctionBoundaryCondition` or something silly like that. But I'm hesitant because we already seem to have a verbosity problem. We need better design, not more words... I've also added a `parameters` field to `BoundaryFunction`. (It only just occurs to me that perhaps what we want are types like `Tracer()`, `U()`, `V()`, and `W()`. We might use these to classify boundary conditions and forcing functions... ?)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/699
https://github.com/CliMA/Oceananigans.jl/issues/700:82,Availability,error,error,82,"Actually, the problem looks like its with the method `has_velocities`. I got this error:. ```julia; ERROR: BoundsError: attempt to access (); at index [1]; Stacktrace:; [1] getindex(::Tuple, ::Int64) at ./tuple.jl:24; [2] has_velocities(::Tuple{}) at /Users/gregorywagner/.julia/packages/Oceananigans/Lzkia/src/Fields/field_tuples.jl:101; [3] tracernames(::Tuple{}) at /Users/gregorywagner/.julia/packages/Oceananigans/Lzkia/src/Fields/field_tuples.jl:105; [4] tracernames(::NamedTuple{(),Tuple{}}) at /Users/gregorywagner/.julia/packages/Oceananigans/Lzkia/src/Fields/field_tuples.jl:106; [5] show(::IOContext{REPL.Terminals.TTYTerminal}, ::IncompressibleModel{Oceananigans.TimeSteppers.AdamsBashforthTimeStepper{Float64,NamedTuple{(:u, :v, :w),Tuple{Field{Oceananigans.Face,Oceananigans.Cell,Oceananigans.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Flat,Bounded,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}},Field{Oceananigans.Cell,Oceananigans.Face,Oceananigans.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Flat,Bounded,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},Boundar",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/700
https://github.com/CliMA/Oceananigans.jl/issues/700:100,Availability,ERROR,ERROR,100,"Actually, the problem looks like its with the method `has_velocities`. I got this error:. ```julia; ERROR: BoundsError: attempt to access (); at index [1]; Stacktrace:; [1] getindex(::Tuple, ::Int64) at ./tuple.jl:24; [2] has_velocities(::Tuple{}) at /Users/gregorywagner/.julia/packages/Oceananigans/Lzkia/src/Fields/field_tuples.jl:101; [3] tracernames(::Tuple{}) at /Users/gregorywagner/.julia/packages/Oceananigans/Lzkia/src/Fields/field_tuples.jl:105; [4] tracernames(::NamedTuple{(),Tuple{}}) at /Users/gregorywagner/.julia/packages/Oceananigans/Lzkia/src/Fields/field_tuples.jl:106; [5] show(::IOContext{REPL.Terminals.TTYTerminal}, ::IncompressibleModel{Oceananigans.TimeSteppers.AdamsBashforthTimeStepper{Float64,NamedTuple{(:u, :v, :w),Tuple{Field{Oceananigans.Face,Oceananigans.Cell,Oceananigans.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Flat,Bounded,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}},Field{Oceananigans.Cell,Oceananigans.Face,Oceananigans.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Flat,Bounded,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},Boundar",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/700
https://github.com/CliMA/Oceananigans.jl/issues/700:131,Security,access,access,131,"Actually, the problem looks like its with the method `has_velocities`. I got this error:. ```julia; ERROR: BoundsError: attempt to access (); at index [1]; Stacktrace:; [1] getindex(::Tuple, ::Int64) at ./tuple.jl:24; [2] has_velocities(::Tuple{}) at /Users/gregorywagner/.julia/packages/Oceananigans/Lzkia/src/Fields/field_tuples.jl:101; [3] tracernames(::Tuple{}) at /Users/gregorywagner/.julia/packages/Oceananigans/Lzkia/src/Fields/field_tuples.jl:105; [4] tracernames(::NamedTuple{(),Tuple{}}) at /Users/gregorywagner/.julia/packages/Oceananigans/Lzkia/src/Fields/field_tuples.jl:106; [5] show(::IOContext{REPL.Terminals.TTYTerminal}, ::IncompressibleModel{Oceananigans.TimeSteppers.AdamsBashforthTimeStepper{Float64,NamedTuple{(:u, :v, :w),Tuple{Field{Oceananigans.Face,Oceananigans.Cell,Oceananigans.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Flat,Bounded,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}},Field{Oceananigans.Cell,Oceananigans.Face,Oceananigans.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Flat,Bounded,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},Boundar",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/700
https://github.com/CliMA/Oceananigans.jl/issues/700:9071,Usability,Simpl,SimpleForcing,9071,"le{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}},Field{Oceananigans.Cell,Oceananigans.Cell,Oceananigans.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Flat,Bounded,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}},NamedTuple{(:u, :v, :w),Tuple{SimpleForcing{Oceananigans.Face,Oceananigans.Cell,Oceananigans.Cell,var""#45#48"",Nothing},typeof(Oceananigans.Forcing.zeroforcing),SimpleForcing{Oceananigans.Cell,Oceananigans.Cell,Oceananigans.Face,var""#46#49"",Nothing}}},Oceananigans.Solvers.PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,CPU,NamedTuple{(:kx², :ky², :kz²),Tuple{Array{Float64,3},Array{Float64,3},Array{Float64,3}}},Array{Complex{Float64},3},NamedTuple{(:FFTxy!, :DCTz!, :IFFTxy!, :IDCTz!),Tuple{FFTW.cFFTWPlan{Complex{Float64},-1,true,3},FFTW.r2rFFTWPlan{Complex{Float64},(5,),true,3},AbstractFFTs.ScaledPlan{Complex{Float64},FFTW.cFFTWPlan{Complex{Float64},1,true,3},Float64},FFTW.r2rFFTWPlan{Complex{Float64},(4,),true,3}}},Nothing},Nothing}) at /Users/gregorywagner/.julia/packages/Oceananigans/Lzkia/src/Models/show_models.jl:5; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/700
https://github.com/CliMA/Oceananigans.jl/issues/700:9201,Usability,Simpl,SimpleForcing,9201,"le{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}},Field{Oceananigans.Cell,Oceananigans.Cell,Oceananigans.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Flat,Bounded,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}},NamedTuple{(:u, :v, :w),Tuple{SimpleForcing{Oceananigans.Face,Oceananigans.Cell,Oceananigans.Cell,var""#45#48"",Nothing},typeof(Oceananigans.Forcing.zeroforcing),SimpleForcing{Oceananigans.Cell,Oceananigans.Cell,Oceananigans.Face,var""#46#49"",Nothing}}},Oceananigans.Solvers.PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,CPU,NamedTuple{(:kx², :ky², :kz²),Tuple{Array{Float64,3},Array{Float64,3},Array{Float64,3}}},Array{Complex{Float64},3},NamedTuple{(:FFTxy!, :DCTz!, :IFFTxy!, :IDCTz!),Tuple{FFTW.cFFTWPlan{Complex{Float64},-1,true,3},FFTW.r2rFFTWPlan{Complex{Float64},(5,),true,3},AbstractFFTs.ScaledPlan{Complex{Float64},FFTW.cFFTWPlan{Complex{Float64},1,true,3},Float64},FFTW.r2rFFTWPlan{Complex{Float64},(4,),true,3}}},Nothing},Nothing}) at /Users/gregorywagner/.julia/packages/Oceananigans/Lzkia/src/Models/show_models.jl:5; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/700
https://github.com/CliMA/Oceananigans.jl/issues/703:170,Usability,clear,clear,170,"A better name for `NoPenetration` is zero `NormalFlow`. Rather than `NoPenetration`, we can use. ```julia; BoundaryCondition(NormalFlow, 0); ```. This name makes it more clear that this boundary condition can only be applied to the velocity component normal to a `Bounded` boundary. It will also allow the specification of non-zero normal flow on a boundary, or ""open"" boundaries. Currently the user doesn't touch these boundary conditions (no penetration boundary conditions are determined automatically through the grid topology), so this is not urgent.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/703
https://github.com/CliMA/Oceananigans.jl/pull/704:193,Availability,error,error,193,"This PR adapts the analytical pressure solver test to an explicit test for second-order convergence of the pressure solver in all configurations. The triply periodic solver currently throws an error if we try to construct it, so I'm skipping that test.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/704
https://github.com/CliMA/Oceananigans.jl/pull/704:130,Deployability,configurat,configurations,130,"This PR adapts the analytical pressure solver test to an explicit test for second-order convergence of the pressure solver in all configurations. The triply periodic solver currently throws an error if we try to construct it, so I'm skipping that test.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/704
https://github.com/CliMA/Oceananigans.jl/pull/704:8,Energy Efficiency,adapt,adapts,8,"This PR adapts the analytical pressure solver test to an explicit test for second-order convergence of the pressure solver in all configurations. The triply periodic solver currently throws an error if we try to construct it, so I'm skipping that test.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/704
https://github.com/CliMA/Oceananigans.jl/pull/704:8,Modifiability,adapt,adapts,8,"This PR adapts the analytical pressure solver test to an explicit test for second-order convergence of the pressure solver in all configurations. The triply periodic solver currently throws an error if we try to construct it, so I'm skipping that test.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/704
https://github.com/CliMA/Oceananigans.jl/pull/704:130,Modifiability,config,configurations,130,"This PR adapts the analytical pressure solver test to an explicit test for second-order convergence of the pressure solver in all configurations. The triply periodic solver currently throws an error if we try to construct it, so I'm skipping that test.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/704
https://github.com/CliMA/Oceananigans.jl/pull/704:46,Testability,test,test,46,"This PR adapts the analytical pressure solver test to an explicit test for second-order convergence of the pressure solver in all configurations. The triply periodic solver currently throws an error if we try to construct it, so I'm skipping that test.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/704
https://github.com/CliMA/Oceananigans.jl/pull/704:66,Testability,test,test,66,"This PR adapts the analytical pressure solver test to an explicit test for second-order convergence of the pressure solver in all configurations. The triply periodic solver currently throws an error if we try to construct it, so I'm skipping that test.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/704
https://github.com/CliMA/Oceananigans.jl/pull/704:247,Testability,test,test,247,"This PR adapts the analytical pressure solver test to an explicit test for second-order convergence of the pressure solver in all configurations. The triply periodic solver currently throws an error if we try to construct it, so I'm skipping that test.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/704
https://github.com/CliMA/Oceananigans.jl/issues/705:47,Testability,test,test,47,"Hmmm, yeah one issue is that we don't actually test `show` methods. Perhaps it would be good to add a bunch of `show` tests which would also increase code coverage. _Originally posted by @ali-ramadhan in https://github.com/climate-machine/Oceananigans.jl/issues/700#issuecomment-599480673_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/705
https://github.com/CliMA/Oceananigans.jl/issues/705:118,Testability,test,tests,118,"Hmmm, yeah one issue is that we don't actually test `show` methods. Perhaps it would be good to add a bunch of `show` tests which would also increase code coverage. _Originally posted by @ali-ramadhan in https://github.com/climate-machine/Oceananigans.jl/issues/700#issuecomment-599480673_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/705
https://github.com/CliMA/Oceananigans.jl/issues/706:285,Availability,checkpoint,checkpointer,285,"I think we could use some utilities for instantiating grids and fields from files saved by Oceananigans' output writers. For this it could make sense to change `Oceananigans.OutputWriters` to `Oceananigans.Output` and include both output writers and utilities for reading output. (The checkpointer already has utilities for reading output, I suppose.)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/706
https://github.com/CliMA/Oceananigans.jl/issues/707:388,Availability,error,error,388,"I was running an example of the 2D turbulence using Julia 1.4RC2 (Oceananigans 0.27.0) on an Azure Ubuntu 18.04.3 GPU instance (Tesla K80), I was defining the model:; ```; model = IncompressibleModel(; grid = RegularCartesianGrid(size=(128, 128, 1), length=(2π, 2π, 2π)),; buoyancy = nothing,; tracers = nothing,; closure = ConstantIsotropicDiffusivity(ν=1e-3, κ=1e-3); ); ```; when this error occurred:; ```; julia> model = IncompressibleModel(; grid = RegularCartesianGrid(size=(128, 128, 1), length=(2π, 2π, 2π)),; buoyancy = nothing,; tracers = nothing,; closure = ConstantIsotropicDiffusivity(ν=1e-3, κ=1e-3); ); Error showing value of type IncompressibleModel{Oceananigans.TimeSteppers.AdamsBashforthTimeStepper{Float64,NamedTuple{(:u, :v, :w),Tuple{Field{Face,Cell,Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}},Field{Cell,Face,Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},Coor",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/707
https://github.com/CliMA/Oceananigans.jl/issues/707:618,Availability,Error,Error,618,"I was running an example of the 2D turbulence using Julia 1.4RC2 (Oceananigans 0.27.0) on an Azure Ubuntu 18.04.3 GPU instance (Tesla K80), I was defining the model:; ```; model = IncompressibleModel(; grid = RegularCartesianGrid(size=(128, 128, 1), length=(2π, 2π, 2π)),; buoyancy = nothing,; tracers = nothing,; closure = ConstantIsotropicDiffusivity(ν=1e-3, κ=1e-3); ); ```; when this error occurred:; ```; julia> model = IncompressibleModel(; grid = RegularCartesianGrid(size=(128, 128, 1), length=(2π, 2π, 2π)),; buoyancy = nothing,; tracers = nothing,; closure = ConstantIsotropicDiffusivity(ν=1e-3, κ=1e-3); ); Error showing value of type IncompressibleModel{Oceananigans.TimeSteppers.AdamsBashforthTimeStepper{Float64,NamedTuple{(:u, :v, :w),Tuple{Field{Face,Cell,Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}},Field{Cell,Face,Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},Coor",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/707
https://github.com/CliMA/Oceananigans.jl/issues/707:9375,Availability,ERROR,ERROR,9375,"dition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}},NamedTuple{(:u, :v, :w),Tuple{typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},Oceananigans.Solvers.PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,CPU,NamedTuple{(:kx², :ky², :kz²),Tuple{Array{Float64,3},Array{Float64,3},Array{Float64,3}}},Array{Complex{Float64},3},NamedTuple{(:FFTxy!, :DCTz!, :IFFTxy!, :IDCTz!),Tuple{FFTW.cFFTWPlan{Complex{Float64},-1,true,3},FFTW.r2rFFTWPlan{Complex{Float64},(5,),true,3},AbstractFFTs.ScaledPlan{Complex{Float64},FFTW.cFFTWPlan{Complex{Float64},1,true,3},Float64},FFTW.r2rFFTWPlan{Complex{Float64},(4,),true,3}}},Nothing},Nothing}:; ERROR: BoundsError: attempt to access (); at index [1]; Stacktrace:; [1] getindex(::Tuple, ::Int64) at ./tuple.jl:24; [2] has_velocities(::Tuple{}) at /home/gong/.julia/packages/Oceananigans/XWBSD/src/Fields/field_tuples.jl:101; [3] tracernames(::Tuple{}) at /home/gong/.julia/packages/Oceananigans/XWBSD/src/Fields/field_tuples.jl:105; [4] tracernames(::NamedTuple{(),Tuple{}}) at /home/gong/.julia/packages/Oceananigans/XWBSD/src/Fields/field_tuples.jl:106; [5] show(::IOContext{REPL.Terminals.TTYTerminal}, ::IncompressibleModel{Oceananigans.TimeSteppers.AdamsBashforthTimeStepper{Float64,NamedTuple{(:u, :v, :w),Tuple{Field{Face,Cell,Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,No",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/707
https://github.com/CliMA/Oceananigans.jl/issues/707:9406,Security,access,access,9406,"dition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}},NamedTuple{(:u, :v, :w),Tuple{typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},Oceananigans.Solvers.PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,CPU,NamedTuple{(:kx², :ky², :kz²),Tuple{Array{Float64,3},Array{Float64,3},Array{Float64,3}}},Array{Complex{Float64},3},NamedTuple{(:FFTxy!, :DCTz!, :IFFTxy!, :IDCTz!),Tuple{FFTW.cFFTWPlan{Complex{Float64},-1,true,3},FFTW.r2rFFTWPlan{Complex{Float64},(5,),true,3},AbstractFFTs.ScaledPlan{Complex{Float64},FFTW.cFFTWPlan{Complex{Float64},1,true,3},Float64},FFTW.r2rFFTWPlan{Complex{Float64},(4,),true,3}}},Nothing},Nothing}:; ERROR: BoundsError: attempt to access (); at index [1]; Stacktrace:; [1] getindex(::Tuple, ::Int64) at ./tuple.jl:24; [2] has_velocities(::Tuple{}) at /home/gong/.julia/packages/Oceananigans/XWBSD/src/Fields/field_tuples.jl:101; [3] tracernames(::Tuple{}) at /home/gong/.julia/packages/Oceananigans/XWBSD/src/Fields/field_tuples.jl:105; [4] tracernames(::NamedTuple{(),Tuple{}}) at /home/gong/.julia/packages/Oceananigans/XWBSD/src/Fields/field_tuples.jl:106; [5] show(::IOContext{REPL.Terminals.TTYTerminal}, ::IncompressibleModel{Oceananigans.TimeSteppers.AdamsBashforthTimeStepper{Float64,NamedTuple{(:u, :v, :w),Tuple{Field{Face,Cell,Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,No",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/707
https://github.com/CliMA/Oceananigans.jl/pull/708:88,Availability,robust,robust,88,"This PR redoes the work of #701, except it adds a few more methods to make it even more robust. After this is merged we should revisit #707.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/708
https://github.com/CliMA/Oceananigans.jl/pull/709:8,Usability,simpl,simply,8,"This PR simply cherry picks the commits from #698, which were accidentally reverted with #697 was merged.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/709
https://github.com/CliMA/Oceananigans.jl/pull/710:300,Modifiability,extend,extends,300,"This PR introduces the `NormalFlow` boundary condition, and renames `BoundaryCondition(NoPenetration, nothing)` to `BoundaryCondition(NormalFlow, 0)`. There is an alias `ImpenetrableBoundaryCondition() = BoundaryCondition(NormalFlow, 0)`, though this probably won't be touched by users. This PR also extends boundary conditions to the `x`-direction, and reversed an incorrect assumption that `Value` and `Gradient` boundary conditions should be applied at all halo points. In reality, extra boundary conditions are required for the case that halo regions are larger than 1. Developing an abstraction for higher-order boundary conditions is straightforward, but is not a priority. The implementation of `NormalFlow` boundary conditions is likely incorrect for general stretched grids. We don't have a test for this, however. I think we should wait until we have full stretched grid implementation to fix this; it should not be hard. It requires correctly satisfying the continuity equations in halo regions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/710
https://github.com/CliMA/Oceananigans.jl/pull/710:800,Testability,test,test,800,"This PR introduces the `NormalFlow` boundary condition, and renames `BoundaryCondition(NoPenetration, nothing)` to `BoundaryCondition(NormalFlow, 0)`. There is an alias `ImpenetrableBoundaryCondition() = BoundaryCondition(NormalFlow, 0)`, though this probably won't be touched by users. This PR also extends boundary conditions to the `x`-direction, and reversed an incorrect assumption that `Value` and `Gradient` boundary conditions should be applied at all halo points. In reality, extra boundary conditions are required for the case that halo regions are larger than 1. Developing an abstraction for higher-order boundary conditions is straightforward, but is not a priority. The implementation of `NormalFlow` boundary conditions is likely incorrect for general stretched grids. We don't have a test for this, however. I think we should wait until we have full stretched grid implementation to fix this; it should not be hard. It requires correctly satisfying the continuity equations in halo regions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/710
https://github.com/CliMA/Oceananigans.jl/pull/711:572,Availability,error,error,572,"This PR removes part of the time-stepping algorithm that uses the continuity equation to 'recompute' the vertical velocity at the end of a time-step, after using a fractional step to project the predictor velocity field onto an incompressible field.; This recomputation of vertical velocity relies on a discrete vertical integral of the continuity equation starting at the bottom of the domain and proceeding upwards. The reason for omitting ""w recomputation"" is primarily because vertically integrating the continuity equation _accumulates_ pressure projection round-off error into the vertical velocity field, biased towards the top of the domain. Most models are probably unaffected by this error accumulation and upward bias. However, accumulation of round-off error in a particular part of the domain may become a problem for models with high vertical resolution. The recomputation step also has a computational cost, and the top of the domain is crucial in many oceanographic contexts. The incompressibility of the flow field is still assured without this recomputation step, and it is probable that the velocity field errors are more isotropic and therefore probably more benign. We should note that the error in the _divergence_ is larger without recomputation. However, it probably still falls below acceptable limits, and it does not accumulate in time. With this change the regression tests fail. Also, an ""incompressibility test"" that relies on a measurement of the absolute magnitude of the divergence error fails. We probably simply need to relax the error requirement for the incompressibility test. The regression tests, on the other hand, will have to be regenerated. cc @sandreza @kburns. Resolves #338",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/711
https://github.com/CliMA/Oceananigans.jl/pull/711:694,Availability,error,error,694,"This PR removes part of the time-stepping algorithm that uses the continuity equation to 'recompute' the vertical velocity at the end of a time-step, after using a fractional step to project the predictor velocity field onto an incompressible field.; This recomputation of vertical velocity relies on a discrete vertical integral of the continuity equation starting at the bottom of the domain and proceeding upwards. The reason for omitting ""w recomputation"" is primarily because vertically integrating the continuity equation _accumulates_ pressure projection round-off error into the vertical velocity field, biased towards the top of the domain. Most models are probably unaffected by this error accumulation and upward bias. However, accumulation of round-off error in a particular part of the domain may become a problem for models with high vertical resolution. The recomputation step also has a computational cost, and the top of the domain is crucial in many oceanographic contexts. The incompressibility of the flow field is still assured without this recomputation step, and it is probable that the velocity field errors are more isotropic and therefore probably more benign. We should note that the error in the _divergence_ is larger without recomputation. However, it probably still falls below acceptable limits, and it does not accumulate in time. With this change the regression tests fail. Also, an ""incompressibility test"" that relies on a measurement of the absolute magnitude of the divergence error fails. We probably simply need to relax the error requirement for the incompressibility test. The regression tests, on the other hand, will have to be regenerated. cc @sandreza @kburns. Resolves #338",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/711
https://github.com/CliMA/Oceananigans.jl/pull/711:765,Availability,error,error,765,"This PR removes part of the time-stepping algorithm that uses the continuity equation to 'recompute' the vertical velocity at the end of a time-step, after using a fractional step to project the predictor velocity field onto an incompressible field.; This recomputation of vertical velocity relies on a discrete vertical integral of the continuity equation starting at the bottom of the domain and proceeding upwards. The reason for omitting ""w recomputation"" is primarily because vertically integrating the continuity equation _accumulates_ pressure projection round-off error into the vertical velocity field, biased towards the top of the domain. Most models are probably unaffected by this error accumulation and upward bias. However, accumulation of round-off error in a particular part of the domain may become a problem for models with high vertical resolution. The recomputation step also has a computational cost, and the top of the domain is crucial in many oceanographic contexts. The incompressibility of the flow field is still assured without this recomputation step, and it is probable that the velocity field errors are more isotropic and therefore probably more benign. We should note that the error in the _divergence_ is larger without recomputation. However, it probably still falls below acceptable limits, and it does not accumulate in time. With this change the regression tests fail. Also, an ""incompressibility test"" that relies on a measurement of the absolute magnitude of the divergence error fails. We probably simply need to relax the error requirement for the incompressibility test. The regression tests, on the other hand, will have to be regenerated. cc @sandreza @kburns. Resolves #338",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/711
https://github.com/CliMA/Oceananigans.jl/pull/711:1125,Availability,error,errors,1125,"This PR removes part of the time-stepping algorithm that uses the continuity equation to 'recompute' the vertical velocity at the end of a time-step, after using a fractional step to project the predictor velocity field onto an incompressible field.; This recomputation of vertical velocity relies on a discrete vertical integral of the continuity equation starting at the bottom of the domain and proceeding upwards. The reason for omitting ""w recomputation"" is primarily because vertically integrating the continuity equation _accumulates_ pressure projection round-off error into the vertical velocity field, biased towards the top of the domain. Most models are probably unaffected by this error accumulation and upward bias. However, accumulation of round-off error in a particular part of the domain may become a problem for models with high vertical resolution. The recomputation step also has a computational cost, and the top of the domain is crucial in many oceanographic contexts. The incompressibility of the flow field is still assured without this recomputation step, and it is probable that the velocity field errors are more isotropic and therefore probably more benign. We should note that the error in the _divergence_ is larger without recomputation. However, it probably still falls below acceptable limits, and it does not accumulate in time. With this change the regression tests fail. Also, an ""incompressibility test"" that relies on a measurement of the absolute magnitude of the divergence error fails. We probably simply need to relax the error requirement for the incompressibility test. The regression tests, on the other hand, will have to be regenerated. cc @sandreza @kburns. Resolves #338",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/711
https://github.com/CliMA/Oceananigans.jl/pull/711:1211,Availability,error,error,1211,"This PR removes part of the time-stepping algorithm that uses the continuity equation to 'recompute' the vertical velocity at the end of a time-step, after using a fractional step to project the predictor velocity field onto an incompressible field.; This recomputation of vertical velocity relies on a discrete vertical integral of the continuity equation starting at the bottom of the domain and proceeding upwards. The reason for omitting ""w recomputation"" is primarily because vertically integrating the continuity equation _accumulates_ pressure projection round-off error into the vertical velocity field, biased towards the top of the domain. Most models are probably unaffected by this error accumulation and upward bias. However, accumulation of round-off error in a particular part of the domain may become a problem for models with high vertical resolution. The recomputation step also has a computational cost, and the top of the domain is crucial in many oceanographic contexts. The incompressibility of the flow field is still assured without this recomputation step, and it is probable that the velocity field errors are more isotropic and therefore probably more benign. We should note that the error in the _divergence_ is larger without recomputation. However, it probably still falls below acceptable limits, and it does not accumulate in time. With this change the regression tests fail. Also, an ""incompressibility test"" that relies on a measurement of the absolute magnitude of the divergence error fails. We probably simply need to relax the error requirement for the incompressibility test. The regression tests, on the other hand, will have to be regenerated. cc @sandreza @kburns. Resolves #338",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/711
https://github.com/CliMA/Oceananigans.jl/pull/711:1515,Availability,error,error,1515,"This PR removes part of the time-stepping algorithm that uses the continuity equation to 'recompute' the vertical velocity at the end of a time-step, after using a fractional step to project the predictor velocity field onto an incompressible field.; This recomputation of vertical velocity relies on a discrete vertical integral of the continuity equation starting at the bottom of the domain and proceeding upwards. The reason for omitting ""w recomputation"" is primarily because vertically integrating the continuity equation _accumulates_ pressure projection round-off error into the vertical velocity field, biased towards the top of the domain. Most models are probably unaffected by this error accumulation and upward bias. However, accumulation of round-off error in a particular part of the domain may become a problem for models with high vertical resolution. The recomputation step also has a computational cost, and the top of the domain is crucial in many oceanographic contexts. The incompressibility of the flow field is still assured without this recomputation step, and it is probable that the velocity field errors are more isotropic and therefore probably more benign. We should note that the error in the _divergence_ is larger without recomputation. However, it probably still falls below acceptable limits, and it does not accumulate in time. With this change the regression tests fail. Also, an ""incompressibility test"" that relies on a measurement of the absolute magnitude of the divergence error fails. We probably simply need to relax the error requirement for the incompressibility test. The regression tests, on the other hand, will have to be regenerated. cc @sandreza @kburns. Resolves #338",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/711
https://github.com/CliMA/Oceananigans.jl/pull/711:1565,Availability,error,error,1565,"This PR removes part of the time-stepping algorithm that uses the continuity equation to 'recompute' the vertical velocity at the end of a time-step, after using a fractional step to project the predictor velocity field onto an incompressible field.; This recomputation of vertical velocity relies on a discrete vertical integral of the continuity equation starting at the bottom of the domain and proceeding upwards. The reason for omitting ""w recomputation"" is primarily because vertically integrating the continuity equation _accumulates_ pressure projection round-off error into the vertical velocity field, biased towards the top of the domain. Most models are probably unaffected by this error accumulation and upward bias. However, accumulation of round-off error in a particular part of the domain may become a problem for models with high vertical resolution. The recomputation step also has a computational cost, and the top of the domain is crucial in many oceanographic contexts. The incompressibility of the flow field is still assured without this recomputation step, and it is probable that the velocity field errors are more isotropic and therefore probably more benign. We should note that the error in the _divergence_ is larger without recomputation. However, it probably still falls below acceptable limits, and it does not accumulate in time. With this change the regression tests fail. Also, an ""incompressibility test"" that relies on a measurement of the absolute magnitude of the divergence error fails. We probably simply need to relax the error requirement for the incompressibility test. The regression tests, on the other hand, will have to be regenerated. cc @sandreza @kburns. Resolves #338",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/711
https://github.com/CliMA/Oceananigans.jl/pull/711:492,Deployability,integrat,integrating,492,"This PR removes part of the time-stepping algorithm that uses the continuity equation to 'recompute' the vertical velocity at the end of a time-step, after using a fractional step to project the predictor velocity field onto an incompressible field.; This recomputation of vertical velocity relies on a discrete vertical integral of the continuity equation starting at the bottom of the domain and proceeding upwards. The reason for omitting ""w recomputation"" is primarily because vertically integrating the continuity equation _accumulates_ pressure projection round-off error into the vertical velocity field, biased towards the top of the domain. Most models are probably unaffected by this error accumulation and upward bias. However, accumulation of round-off error in a particular part of the domain may become a problem for models with high vertical resolution. The recomputation step also has a computational cost, and the top of the domain is crucial in many oceanographic contexts. The incompressibility of the flow field is still assured without this recomputation step, and it is probable that the velocity field errors are more isotropic and therefore probably more benign. We should note that the error in the _divergence_ is larger without recomputation. However, it probably still falls below acceptable limits, and it does not accumulate in time. With this change the regression tests fail. Also, an ""incompressibility test"" that relies on a measurement of the absolute magnitude of the divergence error fails. We probably simply need to relax the error requirement for the incompressibility test. The regression tests, on the other hand, will have to be regenerated. cc @sandreza @kburns. Resolves #338",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/711
https://github.com/CliMA/Oceananigans.jl/pull/711:492,Integrability,integrat,integrating,492,"This PR removes part of the time-stepping algorithm that uses the continuity equation to 'recompute' the vertical velocity at the end of a time-step, after using a fractional step to project the predictor velocity field onto an incompressible field.; This recomputation of vertical velocity relies on a discrete vertical integral of the continuity equation starting at the bottom of the domain and proceeding upwards. The reason for omitting ""w recomputation"" is primarily because vertically integrating the continuity equation _accumulates_ pressure projection round-off error into the vertical velocity field, biased towards the top of the domain. Most models are probably unaffected by this error accumulation and upward bias. However, accumulation of round-off error in a particular part of the domain may become a problem for models with high vertical resolution. The recomputation step also has a computational cost, and the top of the domain is crucial in many oceanographic contexts. The incompressibility of the flow field is still assured without this recomputation step, and it is probable that the velocity field errors are more isotropic and therefore probably more benign. We should note that the error in the _divergence_ is larger without recomputation. However, it probably still falls below acceptable limits, and it does not accumulate in time. With this change the regression tests fail. Also, an ""incompressibility test"" that relies on a measurement of the absolute magnitude of the divergence error fails. We probably simply need to relax the error requirement for the incompressibility test. The regression tests, on the other hand, will have to be regenerated. cc @sandreza @kburns. Resolves #338",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/711
https://github.com/CliMA/Oceananigans.jl/pull/711:195,Safety,predict,predictor,195,"This PR removes part of the time-stepping algorithm that uses the continuity equation to 'recompute' the vertical velocity at the end of a time-step, after using a fractional step to project the predictor velocity field onto an incompressible field.; This recomputation of vertical velocity relies on a discrete vertical integral of the continuity equation starting at the bottom of the domain and proceeding upwards. The reason for omitting ""w recomputation"" is primarily because vertically integrating the continuity equation _accumulates_ pressure projection round-off error into the vertical velocity field, biased towards the top of the domain. Most models are probably unaffected by this error accumulation and upward bias. However, accumulation of round-off error in a particular part of the domain may become a problem for models with high vertical resolution. The recomputation step also has a computational cost, and the top of the domain is crucial in many oceanographic contexts. The incompressibility of the flow field is still assured without this recomputation step, and it is probable that the velocity field errors are more isotropic and therefore probably more benign. We should note that the error in the _divergence_ is larger without recomputation. However, it probably still falls below acceptable limits, and it does not accumulate in time. With this change the regression tests fail. Also, an ""incompressibility test"" that relies on a measurement of the absolute magnitude of the divergence error fails. We probably simply need to relax the error requirement for the incompressibility test. The regression tests, on the other hand, will have to be regenerated. cc @sandreza @kburns. Resolves #338",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/711
https://github.com/CliMA/Oceananigans.jl/pull/711:1396,Testability,test,tests,1396,"This PR removes part of the time-stepping algorithm that uses the continuity equation to 'recompute' the vertical velocity at the end of a time-step, after using a fractional step to project the predictor velocity field onto an incompressible field.; This recomputation of vertical velocity relies on a discrete vertical integral of the continuity equation starting at the bottom of the domain and proceeding upwards. The reason for omitting ""w recomputation"" is primarily because vertically integrating the continuity equation _accumulates_ pressure projection round-off error into the vertical velocity field, biased towards the top of the domain. Most models are probably unaffected by this error accumulation and upward bias. However, accumulation of round-off error in a particular part of the domain may become a problem for models with high vertical resolution. The recomputation step also has a computational cost, and the top of the domain is crucial in many oceanographic contexts. The incompressibility of the flow field is still assured without this recomputation step, and it is probable that the velocity field errors are more isotropic and therefore probably more benign. We should note that the error in the _divergence_ is larger without recomputation. However, it probably still falls below acceptable limits, and it does not accumulate in time. With this change the regression tests fail. Also, an ""incompressibility test"" that relies on a measurement of the absolute magnitude of the divergence error fails. We probably simply need to relax the error requirement for the incompressibility test. The regression tests, on the other hand, will have to be regenerated. cc @sandreza @kburns. Resolves #338",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/711
https://github.com/CliMA/Oceananigans.jl/pull/711:1436,Testability,test,test,1436,"This PR removes part of the time-stepping algorithm that uses the continuity equation to 'recompute' the vertical velocity at the end of a time-step, after using a fractional step to project the predictor velocity field onto an incompressible field.; This recomputation of vertical velocity relies on a discrete vertical integral of the continuity equation starting at the bottom of the domain and proceeding upwards. The reason for omitting ""w recomputation"" is primarily because vertically integrating the continuity equation _accumulates_ pressure projection round-off error into the vertical velocity field, biased towards the top of the domain. Most models are probably unaffected by this error accumulation and upward bias. However, accumulation of round-off error in a particular part of the domain may become a problem for models with high vertical resolution. The recomputation step also has a computational cost, and the top of the domain is crucial in many oceanographic contexts. The incompressibility of the flow field is still assured without this recomputation step, and it is probable that the velocity field errors are more isotropic and therefore probably more benign. We should note that the error in the _divergence_ is larger without recomputation. However, it probably still falls below acceptable limits, and it does not accumulate in time. With this change the regression tests fail. Also, an ""incompressibility test"" that relies on a measurement of the absolute magnitude of the divergence error fails. We probably simply need to relax the error requirement for the incompressibility test. The regression tests, on the other hand, will have to be regenerated. cc @sandreza @kburns. Resolves #338",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/711
https://github.com/CliMA/Oceananigans.jl/pull/711:1609,Testability,test,test,1609,"This PR removes part of the time-stepping algorithm that uses the continuity equation to 'recompute' the vertical velocity at the end of a time-step, after using a fractional step to project the predictor velocity field onto an incompressible field.; This recomputation of vertical velocity relies on a discrete vertical integral of the continuity equation starting at the bottom of the domain and proceeding upwards. The reason for omitting ""w recomputation"" is primarily because vertically integrating the continuity equation _accumulates_ pressure projection round-off error into the vertical velocity field, biased towards the top of the domain. Most models are probably unaffected by this error accumulation and upward bias. However, accumulation of round-off error in a particular part of the domain may become a problem for models with high vertical resolution. The recomputation step also has a computational cost, and the top of the domain is crucial in many oceanographic contexts. The incompressibility of the flow field is still assured without this recomputation step, and it is probable that the velocity field errors are more isotropic and therefore probably more benign. We should note that the error in the _divergence_ is larger without recomputation. However, it probably still falls below acceptable limits, and it does not accumulate in time. With this change the regression tests fail. Also, an ""incompressibility test"" that relies on a measurement of the absolute magnitude of the divergence error fails. We probably simply need to relax the error requirement for the incompressibility test. The regression tests, on the other hand, will have to be regenerated. cc @sandreza @kburns. Resolves #338",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/711
https://github.com/CliMA/Oceananigans.jl/pull/711:1630,Testability,test,tests,1630,"This PR removes part of the time-stepping algorithm that uses the continuity equation to 'recompute' the vertical velocity at the end of a time-step, after using a fractional step to project the predictor velocity field onto an incompressible field.; This recomputation of vertical velocity relies on a discrete vertical integral of the continuity equation starting at the bottom of the domain and proceeding upwards. The reason for omitting ""w recomputation"" is primarily because vertically integrating the continuity equation _accumulates_ pressure projection round-off error into the vertical velocity field, biased towards the top of the domain. Most models are probably unaffected by this error accumulation and upward bias. However, accumulation of round-off error in a particular part of the domain may become a problem for models with high vertical resolution. The recomputation step also has a computational cost, and the top of the domain is crucial in many oceanographic contexts. The incompressibility of the flow field is still assured without this recomputation step, and it is probable that the velocity field errors are more isotropic and therefore probably more benign. We should note that the error in the _divergence_ is larger without recomputation. However, it probably still falls below acceptable limits, and it does not accumulate in time. With this change the regression tests fail. Also, an ""incompressibility test"" that relies on a measurement of the absolute magnitude of the divergence error fails. We probably simply need to relax the error requirement for the incompressibility test. The regression tests, on the other hand, will have to be regenerated. cc @sandreza @kburns. Resolves #338",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/711
https://github.com/CliMA/Oceananigans.jl/pull/711:1540,Usability,simpl,simply,1540,"This PR removes part of the time-stepping algorithm that uses the continuity equation to 'recompute' the vertical velocity at the end of a time-step, after using a fractional step to project the predictor velocity field onto an incompressible field.; This recomputation of vertical velocity relies on a discrete vertical integral of the continuity equation starting at the bottom of the domain and proceeding upwards. The reason for omitting ""w recomputation"" is primarily because vertically integrating the continuity equation _accumulates_ pressure projection round-off error into the vertical velocity field, biased towards the top of the domain. Most models are probably unaffected by this error accumulation and upward bias. However, accumulation of round-off error in a particular part of the domain may become a problem for models with high vertical resolution. The recomputation step also has a computational cost, and the top of the domain is crucial in many oceanographic contexts. The incompressibility of the flow field is still assured without this recomputation step, and it is probable that the velocity field errors are more isotropic and therefore probably more benign. We should note that the error in the _divergence_ is larger without recomputation. However, it probably still falls below acceptable limits, and it does not accumulate in time. With this change the regression tests fail. Also, an ""incompressibility test"" that relies on a measurement of the absolute magnitude of the divergence error fails. We probably simply need to relax the error requirement for the incompressibility test. The regression tests, on the other hand, will have to be regenerated. cc @sandreza @kburns. Resolves #338",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/711
https://github.com/CliMA/Oceananigans.jl/issues/712:62,Availability,error,erroring,62,"The CPU status in the README currently states that a build is erroring: . <img width=""995"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/77115376-96c30c80-6a04-11ea-95dc-c94f17dd09d7.png"">. However, [clicking on the banner](https://travis-ci.com/climate-machine/Oceananigans.jl) shows that this result does not correspond to `master`:. <img width=""815"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/77115429-ae01fa00-6a04-11ea-82fd-855fe9534062.png"">. but instead to the branch `glw/forced-flow-verification`. Is this what is intended?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/712
https://github.com/CliMA/Oceananigans.jl/pull/715:8,Modifiability,refactor,refactors,8,"This PR refactors the grid implementation so that the coordinate arrays `xC`, `yC`, `zC`, `xF`, `yF`, and `zF` have nodal points within the halo regions of fields and are reshape to match their respective dimension. In other words, we now have `size(c, 2) == length(yC)` and `size(u, 1) == length(xF)`, for example, and `xC * yC * zC` produces an object of `size(c)`. There are three new methods `xnodes(loc, grid::AbstractGrid)`, `ynodes(loc, grid::AbstractGrid)`, `znodes(loc, grid::AbstractGrid)`. For example, `xnodes(Cell, grid)` extracts a view over the interior nodes `grid.xC`, while `xnodes(Face, grid) extracts a view over the physical points of `grid.xF`, which include both boundaries for `Bounded` directions. In addition, the `RegularCartesianGrid` keyword `length` is changed to `extent`, and the `VerticallyStretchedCartesianGrid` no longer accepts a keyword `length`, or a keyword `z`.; Note that the `VerticallyStretchedCartesianGrid` implementation is incomplete and untested. This PR should enable saving the halos of fields in NetCDF data if desired, which is needed for reconstructing field gradients and interpolating fields in post-processing. ~~However, it seems the output writer is currently broken and tests are failing. Thus this PR is WIP.~~",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/715
https://github.com/CliMA/Oceananigans.jl/pull/715:1230,Testability,test,tests,1230,"This PR refactors the grid implementation so that the coordinate arrays `xC`, `yC`, `zC`, `xF`, `yF`, and `zF` have nodal points within the halo regions of fields and are reshape to match their respective dimension. In other words, we now have `size(c, 2) == length(yC)` and `size(u, 1) == length(xF)`, for example, and `xC * yC * zC` produces an object of `size(c)`. There are three new methods `xnodes(loc, grid::AbstractGrid)`, `ynodes(loc, grid::AbstractGrid)`, `znodes(loc, grid::AbstractGrid)`. For example, `xnodes(Cell, grid)` extracts a view over the interior nodes `grid.xC`, while `xnodes(Face, grid) extracts a view over the physical points of `grid.xF`, which include both boundaries for `Bounded` directions. In addition, the `RegularCartesianGrid` keyword `length` is changed to `extent`, and the `VerticallyStretchedCartesianGrid` no longer accepts a keyword `length`, or a keyword `z`.; Note that the `VerticallyStretchedCartesianGrid` implementation is incomplete and untested. This PR should enable saving the halos of fields in NetCDF data if desired, which is needed for reconstructing field gradients and interpolating fields in post-processing. ~~However, it seems the output writer is currently broken and tests are failing. Thus this PR is WIP.~~",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/715
https://github.com/CliMA/Oceananigans.jl/issues/716:97,Testability,test,test,97,https://github.com/climate-machine/Oceananigans.jl/blob/e69e81a0a7f93029b7e8c1eed62b8414c11dec1a/test/test_output_writers.jl#L137,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/716
https://github.com/CliMA/Oceananigans.jl/pull/717:169,Testability,test,tested,169,"This pull request changes the compat entry for the `CUDAnative` package from `^2.3` to `^2.3, 3.0`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/717
https://github.com/CliMA/Oceananigans.jl/pull/717:274,Testability,test,tests,274,"This pull request changes the compat entry for the `CUDAnative` package from `^2.3` to `^2.3, 3.0`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/717
https://github.com/CliMA/Oceananigans.jl/pull/718:167,Testability,test,tested,167,"This pull request changes the compat entry for the `CuArrays` package from `^1.2` to `^1.2, 2.0`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/718
https://github.com/CliMA/Oceananigans.jl/pull/718:272,Testability,test,tests,272,"This pull request changes the compat entry for the `CuArrays` package from `^1.2` to `^1.2, 2.0`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/718
https://github.com/CliMA/Oceananigans.jl/issues/721:828,Usability,intuit,intuitive,828,"Just to share an experience I just had... More or less I set up a model with. ```julia; model = IncompressibleModel(grid = grid, boundary_conditions = (κₑ=(T=κₑ_T))); ```. and was surprised when the boundary conditions were not set on diffusivity. Why? Because I forgot a comma: the line. ```julia; boundary_conditions = (κₑ=(T=κₑ_T)) # wrong; ```. should be. ```julia; boundary_conditions = (κₑ=(T=κₑ_T,)) # correct; ```. In other words, the field `κₑ` must be a `NamedTuple` to work correctly. I think `#wrong` version essentially parses as `κₑ=T=κₑ_T`, so that `κₑ` is a `FieldBoundaryCondition` rather than a `NamedTuple` of `FieldBoundaryCondition`s. We could potentially do some checking as a band-aid. But in general, I think this is a tough problem and I don't have too many bright ideas on how to make this elegant and intuitive. So perhaps we can discuss here.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/721
https://github.com/CliMA/Oceananigans.jl/issues/722:84,Energy Efficiency,Adapt,Adapt,84,"One solution for compiling kernels with fields as arguments is to define. ```julia; Adapt.adapt_structure(to, field::AbstractField) = data(field); ```. and. ```julia; Adapt.adapt_structure(to, fields::NamedTuple{S, NTuple{N, <:AbstractField}}) where {S, N} =; datatuple(fields); ```. This approach will automatically unwrap fields when they are passed to GPU kernels (I think). . The disadvantage of this approach is that the code is a little bit harder to interpret, because if you miss the definition of this function, you might be confused why `field.boundary_conditions` and `field.grid` were not accessible from inside GPU kernels. On the other hand, this only affects the lowest-level kernels, and GPU programmers probably know that an `adapt_structure` method must be defined somewhere for an exotic object like `Field` to be passed into a kernel. If we document what we are doing clearly, we may solve this problem. Doing this means we would no longer have to unwrap fields manually prior to passing them to GPU kernels. Are there any other issues that I'm not seeing?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/722
https://github.com/CliMA/Oceananigans.jl/issues/722:167,Energy Efficiency,Adapt,Adapt,167,"One solution for compiling kernels with fields as arguments is to define. ```julia; Adapt.adapt_structure(to, field::AbstractField) = data(field); ```. and. ```julia; Adapt.adapt_structure(to, fields::NamedTuple{S, NTuple{N, <:AbstractField}}) where {S, N} =; datatuple(fields); ```. This approach will automatically unwrap fields when they are passed to GPU kernels (I think). . The disadvantage of this approach is that the code is a little bit harder to interpret, because if you miss the definition of this function, you might be confused why `field.boundary_conditions` and `field.grid` were not accessible from inside GPU kernels. On the other hand, this only affects the lowest-level kernels, and GPU programmers probably know that an `adapt_structure` method must be defined somewhere for an exotic object like `Field` to be passed into a kernel. If we document what we are doing clearly, we may solve this problem. Doing this means we would no longer have to unwrap fields manually prior to passing them to GPU kernels. Are there any other issues that I'm not seeing?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/722
https://github.com/CliMA/Oceananigans.jl/issues/722:84,Modifiability,Adapt,Adapt,84,"One solution for compiling kernels with fields as arguments is to define. ```julia; Adapt.adapt_structure(to, field::AbstractField) = data(field); ```. and. ```julia; Adapt.adapt_structure(to, fields::NamedTuple{S, NTuple{N, <:AbstractField}}) where {S, N} =; datatuple(fields); ```. This approach will automatically unwrap fields when they are passed to GPU kernels (I think). . The disadvantage of this approach is that the code is a little bit harder to interpret, because if you miss the definition of this function, you might be confused why `field.boundary_conditions` and `field.grid` were not accessible from inside GPU kernels. On the other hand, this only affects the lowest-level kernels, and GPU programmers probably know that an `adapt_structure` method must be defined somewhere for an exotic object like `Field` to be passed into a kernel. If we document what we are doing clearly, we may solve this problem. Doing this means we would no longer have to unwrap fields manually prior to passing them to GPU kernels. Are there any other issues that I'm not seeing?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/722
https://github.com/CliMA/Oceananigans.jl/issues/722:167,Modifiability,Adapt,Adapt,167,"One solution for compiling kernels with fields as arguments is to define. ```julia; Adapt.adapt_structure(to, field::AbstractField) = data(field); ```. and. ```julia; Adapt.adapt_structure(to, fields::NamedTuple{S, NTuple{N, <:AbstractField}}) where {S, N} =; datatuple(fields); ```. This approach will automatically unwrap fields when they are passed to GPU kernels (I think). . The disadvantage of this approach is that the code is a little bit harder to interpret, because if you miss the definition of this function, you might be confused why `field.boundary_conditions` and `field.grid` were not accessible from inside GPU kernels. On the other hand, this only affects the lowest-level kernels, and GPU programmers probably know that an `adapt_structure` method must be defined somewhere for an exotic object like `Field` to be passed into a kernel. If we document what we are doing clearly, we may solve this problem. Doing this means we would no longer have to unwrap fields manually prior to passing them to GPU kernels. Are there any other issues that I'm not seeing?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/722
https://github.com/CliMA/Oceananigans.jl/issues/722:601,Security,access,accessible,601,"One solution for compiling kernels with fields as arguments is to define. ```julia; Adapt.adapt_structure(to, field::AbstractField) = data(field); ```. and. ```julia; Adapt.adapt_structure(to, fields::NamedTuple{S, NTuple{N, <:AbstractField}}) where {S, N} =; datatuple(fields); ```. This approach will automatically unwrap fields when they are passed to GPU kernels (I think). . The disadvantage of this approach is that the code is a little bit harder to interpret, because if you miss the definition of this function, you might be confused why `field.boundary_conditions` and `field.grid` were not accessible from inside GPU kernels. On the other hand, this only affects the lowest-level kernels, and GPU programmers probably know that an `adapt_structure` method must be defined somewhere for an exotic object like `Field` to be passed into a kernel. If we document what we are doing clearly, we may solve this problem. Doing this means we would no longer have to unwrap fields manually prior to passing them to GPU kernels. Are there any other issues that I'm not seeing?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/722
https://github.com/CliMA/Oceananigans.jl/issues/722:888,Usability,clear,clearly,888,"One solution for compiling kernels with fields as arguments is to define. ```julia; Adapt.adapt_structure(to, field::AbstractField) = data(field); ```. and. ```julia; Adapt.adapt_structure(to, fields::NamedTuple{S, NTuple{N, <:AbstractField}}) where {S, N} =; datatuple(fields); ```. This approach will automatically unwrap fields when they are passed to GPU kernels (I think). . The disadvantage of this approach is that the code is a little bit harder to interpret, because if you miss the definition of this function, you might be confused why `field.boundary_conditions` and `field.grid` were not accessible from inside GPU kernels. On the other hand, this only affects the lowest-level kernels, and GPU programmers probably know that an `adapt_structure` method must be defined somewhere for an exotic object like `Field` to be passed into a kernel. If we document what we are doing clearly, we may solve this problem. Doing this means we would no longer have to unwrap fields manually prior to passing them to GPU kernels. Are there any other issues that I'm not seeing?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/722
https://github.com/CliMA/Oceananigans.jl/issues/723:986,Testability,log,logging,986,"This line:. https://github.com/climate-machine/Oceananigans.jl/blob/6502f078c8f7698a2fb6cd398d9e96cfacccc787/src/Simulations.jl#L166. prevents the method `progress(simulation)` from being called if `progress` is not a subtype of the abstract type `Function`. . This makes using callable objects for `progress` more complicated (at least, these callable objects would have to subtype `Function`, which seems like an arbitrary requirement for such objects). What is the reasoning behind requiring `progress` to subtype `Function` (and furthermore enforcing this with an if-statement)? If `progress` does not subtype function, the keyword argument is unused (despite the desperate efforts of flailing users, such as myself). Callable objects are nice for `progress`. For example, a callable object is a good way to keep track of wall time, make plots, automatically format strings containing diagnostics information, or otherwise reference objects outside `simulation` for the purposes of logging.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/723
https://github.com/CliMA/Oceananigans.jl/issues/726:26,Performance,perform,performance,26,We've experienced a major performance regression. For v0.27.0:. ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/726
https://github.com/CliMA/Oceananigans.jl/pull/727:391,Energy Efficiency,reduce,reduced,391,"This PR is an attempt to take performance benchmarking more seriously by keeping benchmark scripts up to date and tested. This will be nice so we can get an idea of whether performance has regressed by looking at build logs. More useful for looking at memory allocations as runtimes will vary depending on the CI server. We can still run the benchmark scripts from the terminal or REPL, and reduced versions are run as part of the test suite. This PR is just a start, I'm sure we'll tune this stuff as time goes on.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/727
https://github.com/CliMA/Oceananigans.jl/pull/727:293,Integrability,depend,depending,293,"This PR is an attempt to take performance benchmarking more seriously by keeping benchmark scripts up to date and tested. This will be nice so we can get an idea of whether performance has regressed by looking at build logs. More useful for looking at memory allocations as runtimes will vary depending on the CI server. We can still run the benchmark scripts from the terminal or REPL, and reduced versions are run as part of the test suite. This PR is just a start, I'm sure we'll tune this stuff as time goes on.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/727
https://github.com/CliMA/Oceananigans.jl/pull/727:30,Performance,perform,performance,30,"This PR is an attempt to take performance benchmarking more seriously by keeping benchmark scripts up to date and tested. This will be nice so we can get an idea of whether performance has regressed by looking at build logs. More useful for looking at memory allocations as runtimes will vary depending on the CI server. We can still run the benchmark scripts from the terminal or REPL, and reduced versions are run as part of the test suite. This PR is just a start, I'm sure we'll tune this stuff as time goes on.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/727
https://github.com/CliMA/Oceananigans.jl/pull/727:173,Performance,perform,performance,173,"This PR is an attempt to take performance benchmarking more seriously by keeping benchmark scripts up to date and tested. This will be nice so we can get an idea of whether performance has regressed by looking at build logs. More useful for looking at memory allocations as runtimes will vary depending on the CI server. We can still run the benchmark scripts from the terminal or REPL, and reduced versions are run as part of the test suite. This PR is just a start, I'm sure we'll tune this stuff as time goes on.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/727
https://github.com/CliMA/Oceananigans.jl/pull/727:483,Performance,tune,tune,483,"This PR is an attempt to take performance benchmarking more seriously by keeping benchmark scripts up to date and tested. This will be nice so we can get an idea of whether performance has regressed by looking at build logs. More useful for looking at memory allocations as runtimes will vary depending on the CI server. We can still run the benchmark scripts from the terminal or REPL, and reduced versions are run as part of the test suite. This PR is just a start, I'm sure we'll tune this stuff as time goes on.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/727
https://github.com/CliMA/Oceananigans.jl/pull/727:42,Testability,benchmark,benchmarking,42,"This PR is an attempt to take performance benchmarking more seriously by keeping benchmark scripts up to date and tested. This will be nice so we can get an idea of whether performance has regressed by looking at build logs. More useful for looking at memory allocations as runtimes will vary depending on the CI server. We can still run the benchmark scripts from the terminal or REPL, and reduced versions are run as part of the test suite. This PR is just a start, I'm sure we'll tune this stuff as time goes on.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/727
https://github.com/CliMA/Oceananigans.jl/pull/727:81,Testability,benchmark,benchmark,81,"This PR is an attempt to take performance benchmarking more seriously by keeping benchmark scripts up to date and tested. This will be nice so we can get an idea of whether performance has regressed by looking at build logs. More useful for looking at memory allocations as runtimes will vary depending on the CI server. We can still run the benchmark scripts from the terminal or REPL, and reduced versions are run as part of the test suite. This PR is just a start, I'm sure we'll tune this stuff as time goes on.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/727
https://github.com/CliMA/Oceananigans.jl/pull/727:114,Testability,test,tested,114,"This PR is an attempt to take performance benchmarking more seriously by keeping benchmark scripts up to date and tested. This will be nice so we can get an idea of whether performance has regressed by looking at build logs. More useful for looking at memory allocations as runtimes will vary depending on the CI server. We can still run the benchmark scripts from the terminal or REPL, and reduced versions are run as part of the test suite. This PR is just a start, I'm sure we'll tune this stuff as time goes on.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/727
https://github.com/CliMA/Oceananigans.jl/pull/727:219,Testability,log,logs,219,"This PR is an attempt to take performance benchmarking more seriously by keeping benchmark scripts up to date and tested. This will be nice so we can get an idea of whether performance has regressed by looking at build logs. More useful for looking at memory allocations as runtimes will vary depending on the CI server. We can still run the benchmark scripts from the terminal or REPL, and reduced versions are run as part of the test suite. This PR is just a start, I'm sure we'll tune this stuff as time goes on.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/727
https://github.com/CliMA/Oceananigans.jl/pull/727:342,Testability,benchmark,benchmark,342,"This PR is an attempt to take performance benchmarking more seriously by keeping benchmark scripts up to date and tested. This will be nice so we can get an idea of whether performance has regressed by looking at build logs. More useful for looking at memory allocations as runtimes will vary depending on the CI server. We can still run the benchmark scripts from the terminal or REPL, and reduced versions are run as part of the test suite. This PR is just a start, I'm sure we'll tune this stuff as time goes on.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/727
https://github.com/CliMA/Oceananigans.jl/pull/727:431,Testability,test,test,431,"This PR is an attempt to take performance benchmarking more seriously by keeping benchmark scripts up to date and tested. This will be nice so we can get an idea of whether performance has regressed by looking at build logs. More useful for looking at memory allocations as runtimes will vary depending on the CI server. We can still run the benchmark scripts from the terminal or REPL, and reduced versions are run as part of the test suite. This PR is just a start, I'm sure we'll tune this stuff as time goes on.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/727
https://github.com/CliMA/Oceananigans.jl/pull/731:803,Deployability,Integrat,Integrate,803,"This PR adds a new nonlinear equation of state, @sandreza's favorite 55-term polynomial approximation to TEOS-10 suitable for Boussinesq models as described in Roquet et al. (2014). The TEOS-10 polynomial approximation implemented in this PR has been translated into Julia from https://github.com/fabien-roquet/polyTEOS/blob/master/polyTEOS10.py (Thank you @fabien-roquet!). The Roquet et al. (2014) paper has some test/check values so I added some basic tests based on those, which pass. There are two things to figure out before merging:; 1. How to make `TEOS10` work with different float types. Right now the coefficients are defined as `const`s but then they're `Float64` by default. Perhaps it makes sense to define them as part of a `TEOS10` struct, but that will make the code a bit messier.; 2. Integrate `TEOS10` with `Oceananigans.Buoyancy` by defining `ρ′`, `thermal_expansion`, and `haline_contraction` functions. We can readily do this, just gotta convert geopotential depth `D` (which Oceananigans uses) to dbar (which `TEOS10` expects).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/731
https://github.com/CliMA/Oceananigans.jl/pull/731:803,Integrability,Integrat,Integrate,803,"This PR adds a new nonlinear equation of state, @sandreza's favorite 55-term polynomial approximation to TEOS-10 suitable for Boussinesq models as described in Roquet et al. (2014). The TEOS-10 polynomial approximation implemented in this PR has been translated into Julia from https://github.com/fabien-roquet/polyTEOS/blob/master/polyTEOS10.py (Thank you @fabien-roquet!). The Roquet et al. (2014) paper has some test/check values so I added some basic tests based on those, which pass. There are two things to figure out before merging:; 1. How to make `TEOS10` work with different float types. Right now the coefficients are defined as `const`s but then they're `Float64` by default. Perhaps it makes sense to define them as part of a `TEOS10` struct, but that will make the code a bit messier.; 2. Integrate `TEOS10` with `Oceananigans.Buoyancy` by defining `ρ′`, `thermal_expansion`, and `haline_contraction` functions. We can readily do this, just gotta convert geopotential depth `D` (which Oceananigans uses) to dbar (which `TEOS10` expects).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/731
https://github.com/CliMA/Oceananigans.jl/pull/731:415,Testability,test,test,415,"This PR adds a new nonlinear equation of state, @sandreza's favorite 55-term polynomial approximation to TEOS-10 suitable for Boussinesq models as described in Roquet et al. (2014). The TEOS-10 polynomial approximation implemented in this PR has been translated into Julia from https://github.com/fabien-roquet/polyTEOS/blob/master/polyTEOS10.py (Thank you @fabien-roquet!). The Roquet et al. (2014) paper has some test/check values so I added some basic tests based on those, which pass. There are two things to figure out before merging:; 1. How to make `TEOS10` work with different float types. Right now the coefficients are defined as `const`s but then they're `Float64` by default. Perhaps it makes sense to define them as part of a `TEOS10` struct, but that will make the code a bit messier.; 2. Integrate `TEOS10` with `Oceananigans.Buoyancy` by defining `ρ′`, `thermal_expansion`, and `haline_contraction` functions. We can readily do this, just gotta convert geopotential depth `D` (which Oceananigans uses) to dbar (which `TEOS10` expects).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/731
https://github.com/CliMA/Oceananigans.jl/pull/731:455,Testability,test,tests,455,"This PR adds a new nonlinear equation of state, @sandreza's favorite 55-term polynomial approximation to TEOS-10 suitable for Boussinesq models as described in Roquet et al. (2014). The TEOS-10 polynomial approximation implemented in this PR has been translated into Julia from https://github.com/fabien-roquet/polyTEOS/blob/master/polyTEOS10.py (Thank you @fabien-roquet!). The Roquet et al. (2014) paper has some test/check values so I added some basic tests based on those, which pass. There are two things to figure out before merging:; 1. How to make `TEOS10` work with different float types. Right now the coefficients are defined as `const`s but then they're `Float64` by default. Perhaps it makes sense to define them as part of a `TEOS10` struct, but that will make the code a bit messier.; 2. Integrate `TEOS10` with `Oceananigans.Buoyancy` by defining `ρ′`, `thermal_expansion`, and `haline_contraction` functions. We can readily do this, just gotta convert geopotential depth `D` (which Oceananigans uses) to dbar (which `TEOS10` expects).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/731
https://github.com/CliMA/Oceananigans.jl/issues/732:205,Availability,error,error,205,"In PR #715 (commit https://github.com/climate-machine/Oceananigans.jl/pull/715/commits/df22124af635970f9f46e9706c6b8694fcc921da) I skipped the kinetic energy multiary test as it was giving some weird CUDA error:. ```; Multiary computations [Float64, GPU]: Error During Test at /builds/JuliaGPU/Oceananigans-jl/test/test_abstract_operations.jl:399; Test threw exception; Expression: compute_kinetic_energy(model); CUDA error: device kernel image is invalid (code 200, ERROR_INVALID_IMAGE); ```. We should revisit this issue when we can. It's weird because the test used to work... Build log for more information: https://gitlab.com/JuliaGPU/Oceananigans-jl/-/jobs/510398403",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/732
https://github.com/CliMA/Oceananigans.jl/issues/732:256,Availability,Error,Error,256,"In PR #715 (commit https://github.com/climate-machine/Oceananigans.jl/pull/715/commits/df22124af635970f9f46e9706c6b8694fcc921da) I skipped the kinetic energy multiary test as it was giving some weird CUDA error:. ```; Multiary computations [Float64, GPU]: Error During Test at /builds/JuliaGPU/Oceananigans-jl/test/test_abstract_operations.jl:399; Test threw exception; Expression: compute_kinetic_energy(model); CUDA error: device kernel image is invalid (code 200, ERROR_INVALID_IMAGE); ```. We should revisit this issue when we can. It's weird because the test used to work... Build log for more information: https://gitlab.com/JuliaGPU/Oceananigans-jl/-/jobs/510398403",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/732
https://github.com/CliMA/Oceananigans.jl/issues/732:418,Availability,error,error,418,"In PR #715 (commit https://github.com/climate-machine/Oceananigans.jl/pull/715/commits/df22124af635970f9f46e9706c6b8694fcc921da) I skipped the kinetic energy multiary test as it was giving some weird CUDA error:. ```; Multiary computations [Float64, GPU]: Error During Test at /builds/JuliaGPU/Oceananigans-jl/test/test_abstract_operations.jl:399; Test threw exception; Expression: compute_kinetic_energy(model); CUDA error: device kernel image is invalid (code 200, ERROR_INVALID_IMAGE); ```. We should revisit this issue when we can. It's weird because the test used to work... Build log for more information: https://gitlab.com/JuliaGPU/Oceananigans-jl/-/jobs/510398403",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/732
https://github.com/CliMA/Oceananigans.jl/issues/732:151,Energy Efficiency,energy,energy,151,"In PR #715 (commit https://github.com/climate-machine/Oceananigans.jl/pull/715/commits/df22124af635970f9f46e9706c6b8694fcc921da) I skipped the kinetic energy multiary test as it was giving some weird CUDA error:. ```; Multiary computations [Float64, GPU]: Error During Test at /builds/JuliaGPU/Oceananigans-jl/test/test_abstract_operations.jl:399; Test threw exception; Expression: compute_kinetic_energy(model); CUDA error: device kernel image is invalid (code 200, ERROR_INVALID_IMAGE); ```. We should revisit this issue when we can. It's weird because the test used to work... Build log for more information: https://gitlab.com/JuliaGPU/Oceananigans-jl/-/jobs/510398403",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/732
https://github.com/CliMA/Oceananigans.jl/issues/732:167,Testability,test,test,167,"In PR #715 (commit https://github.com/climate-machine/Oceananigans.jl/pull/715/commits/df22124af635970f9f46e9706c6b8694fcc921da) I skipped the kinetic energy multiary test as it was giving some weird CUDA error:. ```; Multiary computations [Float64, GPU]: Error During Test at /builds/JuliaGPU/Oceananigans-jl/test/test_abstract_operations.jl:399; Test threw exception; Expression: compute_kinetic_energy(model); CUDA error: device kernel image is invalid (code 200, ERROR_INVALID_IMAGE); ```. We should revisit this issue when we can. It's weird because the test used to work... Build log for more information: https://gitlab.com/JuliaGPU/Oceananigans-jl/-/jobs/510398403",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/732
https://github.com/CliMA/Oceananigans.jl/issues/732:269,Testability,Test,Test,269,"In PR #715 (commit https://github.com/climate-machine/Oceananigans.jl/pull/715/commits/df22124af635970f9f46e9706c6b8694fcc921da) I skipped the kinetic energy multiary test as it was giving some weird CUDA error:. ```; Multiary computations [Float64, GPU]: Error During Test at /builds/JuliaGPU/Oceananigans-jl/test/test_abstract_operations.jl:399; Test threw exception; Expression: compute_kinetic_energy(model); CUDA error: device kernel image is invalid (code 200, ERROR_INVALID_IMAGE); ```. We should revisit this issue when we can. It's weird because the test used to work... Build log for more information: https://gitlab.com/JuliaGPU/Oceananigans-jl/-/jobs/510398403",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/732
https://github.com/CliMA/Oceananigans.jl/issues/732:310,Testability,test,test,310,"In PR #715 (commit https://github.com/climate-machine/Oceananigans.jl/pull/715/commits/df22124af635970f9f46e9706c6b8694fcc921da) I skipped the kinetic energy multiary test as it was giving some weird CUDA error:. ```; Multiary computations [Float64, GPU]: Error During Test at /builds/JuliaGPU/Oceananigans-jl/test/test_abstract_operations.jl:399; Test threw exception; Expression: compute_kinetic_energy(model); CUDA error: device kernel image is invalid (code 200, ERROR_INVALID_IMAGE); ```. We should revisit this issue when we can. It's weird because the test used to work... Build log for more information: https://gitlab.com/JuliaGPU/Oceananigans-jl/-/jobs/510398403",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/732
https://github.com/CliMA/Oceananigans.jl/issues/732:348,Testability,Test,Test,348,"In PR #715 (commit https://github.com/climate-machine/Oceananigans.jl/pull/715/commits/df22124af635970f9f46e9706c6b8694fcc921da) I skipped the kinetic energy multiary test as it was giving some weird CUDA error:. ```; Multiary computations [Float64, GPU]: Error During Test at /builds/JuliaGPU/Oceananigans-jl/test/test_abstract_operations.jl:399; Test threw exception; Expression: compute_kinetic_energy(model); CUDA error: device kernel image is invalid (code 200, ERROR_INVALID_IMAGE); ```. We should revisit this issue when we can. It's weird because the test used to work... Build log for more information: https://gitlab.com/JuliaGPU/Oceananigans-jl/-/jobs/510398403",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/732
https://github.com/CliMA/Oceananigans.jl/issues/732:559,Testability,test,test,559,"In PR #715 (commit https://github.com/climate-machine/Oceananigans.jl/pull/715/commits/df22124af635970f9f46e9706c6b8694fcc921da) I skipped the kinetic energy multiary test as it was giving some weird CUDA error:. ```; Multiary computations [Float64, GPU]: Error During Test at /builds/JuliaGPU/Oceananigans-jl/test/test_abstract_operations.jl:399; Test threw exception; Expression: compute_kinetic_energy(model); CUDA error: device kernel image is invalid (code 200, ERROR_INVALID_IMAGE); ```. We should revisit this issue when we can. It's weird because the test used to work... Build log for more information: https://gitlab.com/JuliaGPU/Oceananigans-jl/-/jobs/510398403",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/732
https://github.com/CliMA/Oceananigans.jl/issues/732:586,Testability,log,log,586,"In PR #715 (commit https://github.com/climate-machine/Oceananigans.jl/pull/715/commits/df22124af635970f9f46e9706c6b8694fcc921da) I skipped the kinetic energy multiary test as it was giving some weird CUDA error:. ```; Multiary computations [Float64, GPU]: Error During Test at /builds/JuliaGPU/Oceananigans-jl/test/test_abstract_operations.jl:399; Test threw exception; Expression: compute_kinetic_energy(model); CUDA error: device kernel image is invalid (code 200, ERROR_INVALID_IMAGE); ```. We should revisit this issue when we can. It's weird because the test used to work... Build log for more information: https://gitlab.com/JuliaGPU/Oceananigans-jl/-/jobs/510398403",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/732
https://github.com/CliMA/Oceananigans.jl/pull/733:147,Testability,test,tests,147,I pushed this commit as part of PR #727 but I think GitHub servers were experiencing issues so it seems it somehow didn't make it into master. GPU tests passed so should be an easy merge.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/733
https://github.com/CliMA/Oceananigans.jl/issues/737:122,Deployability,upgrade,upgrade,122,@glwagner suggested that this test could pass at t=0 but fail for t>0 in certain situations (not yet isolated). We should upgrade this test to include some time dependence. https://github.com/climate-machine/Oceananigans.jl/blob/22088d335973553b298a67bacebfa80b32e66acf/test/test_diagnostics.jl#L1-L15,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/737
https://github.com/CliMA/Oceananigans.jl/issues/737:161,Integrability,depend,dependence,161,@glwagner suggested that this test could pass at t=0 but fail for t>0 in certain situations (not yet isolated). We should upgrade this test to include some time dependence. https://github.com/climate-machine/Oceananigans.jl/blob/22088d335973553b298a67bacebfa80b32e66acf/test/test_diagnostics.jl#L1-L15,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/737
https://github.com/CliMA/Oceananigans.jl/issues/737:30,Testability,test,test,30,@glwagner suggested that this test could pass at t=0 but fail for t>0 in certain situations (not yet isolated). We should upgrade this test to include some time dependence. https://github.com/climate-machine/Oceananigans.jl/blob/22088d335973553b298a67bacebfa80b32e66acf/test/test_diagnostics.jl#L1-L15,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/737
https://github.com/CliMA/Oceananigans.jl/issues/737:135,Testability,test,test,135,@glwagner suggested that this test could pass at t=0 but fail for t>0 in certain situations (not yet isolated). We should upgrade this test to include some time dependence. https://github.com/climate-machine/Oceananigans.jl/blob/22088d335973553b298a67bacebfa80b32e66acf/test/test_diagnostics.jl#L1-L15,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/737
https://github.com/CliMA/Oceananigans.jl/issues/737:270,Testability,test,test,270,@glwagner suggested that this test could pass at t=0 but fail for t>0 in certain situations (not yet isolated). We should upgrade this test to include some time dependence. https://github.com/climate-machine/Oceananigans.jl/blob/22088d335973553b298a67bacebfa80b32e66acf/test/test_diagnostics.jl#L1-L15,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/737
https://github.com/CliMA/Oceananigans.jl/pull/738:85,Integrability,depend,depend,85,Just bumping version 0.29 that adds the TEOS-10 equation of state so LESbrary.jl can depend on it.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/738
https://github.com/CliMA/Oceananigans.jl/pull/742:68,Integrability,depend,dependency,68,This PR removes the `RoquetEquationOfState` and `TEOS10` and adds a dependency to `SeawaterPolynomials`. We need. - [x] remove the tests that depend on Roquet and TEOS10; - [x] test that we can time-step a model with a `SeawaterPolynomials.BoussinesqEquationOfState`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/742
https://github.com/CliMA/Oceananigans.jl/pull/742:142,Integrability,depend,depend,142,This PR removes the `RoquetEquationOfState` and `TEOS10` and adds a dependency to `SeawaterPolynomials`. We need. - [x] remove the tests that depend on Roquet and TEOS10; - [x] test that we can time-step a model with a `SeawaterPolynomials.BoussinesqEquationOfState`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/742
https://github.com/CliMA/Oceananigans.jl/pull/742:131,Testability,test,tests,131,This PR removes the `RoquetEquationOfState` and `TEOS10` and adds a dependency to `SeawaterPolynomials`. We need. - [x] remove the tests that depend on Roquet and TEOS10; - [x] test that we can time-step a model with a `SeawaterPolynomials.BoussinesqEquationOfState`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/742
https://github.com/CliMA/Oceananigans.jl/pull/742:177,Testability,test,test,177,This PR removes the `RoquetEquationOfState` and `TEOS10` and adds a dependency to `SeawaterPolynomials`. We need. - [x] remove the tests that depend on Roquet and TEOS10; - [x] test that we can time-step a model with a `SeawaterPolynomials.BoussinesqEquationOfState`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/742
https://github.com/CliMA/Oceananigans.jl/pull/744:9,Integrability,depend,dependent,9,"A 'field-dependent' forcing is a user-specified forcing term that depends on `x, y, z, t, u`, where `u` is the field being forced, and optionally parameters.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/744
https://github.com/CliMA/Oceananigans.jl/pull/744:66,Integrability,depend,depends,66,"A 'field-dependent' forcing is a user-specified forcing term that depends on `x, y, z, t, u`, where `u` is the field being forced, and optionally parameters.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/744
https://github.com/CliMA/Oceananigans.jl/pull/745:0,Integrability,Depend,Depends,0,Depends on functionality in #744 . Needs:. - [x] tests; - [x] possibly more examples in docstrings. Hopefully `Relaxation` will be helpful.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/745
https://github.com/CliMA/Oceananigans.jl/pull/745:49,Testability,test,tests,49,Depends on functionality in #744 . Needs:. - [x] tests; - [x] possibly more examples in docstrings. Hopefully `Relaxation` will be helpful.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/745
https://github.com/CliMA/Oceananigans.jl/pull/746:213,Availability,error,error,213,"This PR attempts to use `adapt_structure` for `Oceananigans.Fields` so that they can be used as arguments in kernels on the GPU. After fixing a few related issues, attempts at compilation on the GPU fail with the error. ```; CUDA error: a PTX JIT compilation failed (code 218, ERROR_INVALID_PTX); ptxas application ptx input, line 6381; error : Entry function 'ptxcall_calculate_Gu__66' uses too much parameter space (0x16c8 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; Stacktrace:; [1] CUDAdrv.CuModule(::String, ::Dict{CUDAdrv.CUjit_option_enum,Any}) at /data5/glwagner/.julia/packages/CUDAdrv/mCr0O/src/module.jl:41; [2] macro expansion at /data5/glwagner/.julia/packages/CUDAnative/wdJjC/src/execution.jl:423 [inlined]; [3] #cufunction#195(::String, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(cufunction),; ```. I don't have too much hope that I can solve this (the burden on the compiler is too great?), but I'm opening this PR as a way to record what I've done. Resolves #722",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/746
https://github.com/CliMA/Oceananigans.jl/pull/746:230,Availability,error,error,230,"This PR attempts to use `adapt_structure` for `Oceananigans.Fields` so that they can be used as arguments in kernels on the GPU. After fixing a few related issues, attempts at compilation on the GPU fail with the error. ```; CUDA error: a PTX JIT compilation failed (code 218, ERROR_INVALID_PTX); ptxas application ptx input, line 6381; error : Entry function 'ptxcall_calculate_Gu__66' uses too much parameter space (0x16c8 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; Stacktrace:; [1] CUDAdrv.CuModule(::String, ::Dict{CUDAdrv.CUjit_option_enum,Any}) at /data5/glwagner/.julia/packages/CUDAdrv/mCr0O/src/module.jl:41; [2] macro expansion at /data5/glwagner/.julia/packages/CUDAnative/wdJjC/src/execution.jl:423 [inlined]; [3] #cufunction#195(::String, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(cufunction),; ```. I don't have too much hope that I can solve this (the burden on the compiler is too great?), but I'm opening this PR as a way to record what I've done. Resolves #722",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/746
https://github.com/CliMA/Oceananigans.jl/pull/746:337,Availability,error,error,337,"This PR attempts to use `adapt_structure` for `Oceananigans.Fields` so that they can be used as arguments in kernels on the GPU. After fixing a few related issues, attempts at compilation on the GPU fail with the error. ```; CUDA error: a PTX JIT compilation failed (code 218, ERROR_INVALID_PTX); ptxas application ptx input, line 6381; error : Entry function 'ptxcall_calculate_Gu__66' uses too much parameter space (0x16c8 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; Stacktrace:; [1] CUDAdrv.CuModule(::String, ::Dict{CUDAdrv.CUjit_option_enum,Any}) at /data5/glwagner/.julia/packages/CUDAdrv/mCr0O/src/module.jl:41; [2] macro expansion at /data5/glwagner/.julia/packages/CUDAnative/wdJjC/src/execution.jl:423 [inlined]; [3] #cufunction#195(::String, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(cufunction),; ```. I don't have too much hope that I can solve this (the burden on the compiler is too great?), but I'm opening this PR as a way to record what I've done. Resolves #722",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/746
https://github.com/CliMA/Oceananigans.jl/pull/746:488,Availability,error,errors,488,"This PR attempts to use `adapt_structure` for `Oceananigans.Fields` so that they can be used as arguments in kernels on the GPU. After fixing a few related issues, attempts at compilation on the GPU fail with the error. ```; CUDA error: a PTX JIT compilation failed (code 218, ERROR_INVALID_PTX); ptxas application ptx input, line 6381; error : Entry function 'ptxcall_calculate_Gu__66' uses too much parameter space (0x16c8 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; Stacktrace:; [1] CUDAdrv.CuModule(::String, ::Dict{CUDAdrv.CUjit_option_enum,Any}) at /data5/glwagner/.julia/packages/CUDAdrv/mCr0O/src/module.jl:41; [2] macro expansion at /data5/glwagner/.julia/packages/CUDAnative/wdJjC/src/execution.jl:423 [inlined]; [3] #cufunction#195(::String, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(cufunction),; ```. I don't have too much hope that I can solve this (the burden on the compiler is too great?), but I'm opening this PR as a way to record what I've done. Resolves #722",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/746
https://github.com/CliMA/Oceananigans.jl/pull/746:473,Safety,abort,aborted,473,"This PR attempts to use `adapt_structure` for `Oceananigans.Fields` so that they can be used as arguments in kernels on the GPU. After fixing a few related issues, attempts at compilation on the GPU fail with the error. ```; CUDA error: a PTX JIT compilation failed (code 218, ERROR_INVALID_PTX); ptxas application ptx input, line 6381; error : Entry function 'ptxcall_calculate_Gu__66' uses too much parameter space (0x16c8 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; Stacktrace:; [1] CUDAdrv.CuModule(::String, ::Dict{CUDAdrv.CUjit_option_enum,Any}) at /data5/glwagner/.julia/packages/CUDAdrv/mCr0O/src/module.jl:41; [2] macro expansion at /data5/glwagner/.julia/packages/CUDAnative/wdJjC/src/execution.jl:423 [inlined]; [3] #cufunction#195(::String, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(cufunction),; ```. I don't have too much hope that I can solve this (the burden on the compiler is too great?), but I'm opening this PR as a way to record what I've done. Resolves #722",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/746
https://github.com/CliMA/Oceananigans.jl/pull/748:77,Availability,error,error,77,Also:. * Changes test_examples.jl to spew example file into the build log on error.; * Makes a minor correction to the replace strings for the `ocean_wind_mixing_ and_convection.jl` example.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/748
https://github.com/CliMA/Oceananigans.jl/pull/748:70,Testability,log,log,70,Also:. * Changes test_examples.jl to spew example file into the build log on error.; * Makes a minor correction to the replace strings for the `ocean_wind_mixing_ and_convection.jl` example.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/748
https://github.com/CliMA/Oceananigans.jl/pull/750:82,Security,access,access,82,Just bumping version to 0.30.0 now that you need to use SeawaterPolynomials.jl to access `TEOS10` (a breaking change).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/750
https://github.com/CliMA/Oceananigans.jl/pull/751:451,Availability,down,downstream,451,"This pull request sets the compat entry for the `SeawaterPolynomials` package to `0.2`. This is a brand new compat entry. Previously, you did not have a compat entry for the `SeawaterPolynomials` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/751
https://github.com/CliMA/Oceananigans.jl/pull/751:399,Deployability,patch,patch,399,"This pull request sets the compat entry for the `SeawaterPolynomials` package to `0.2`. This is a brand new compat entry. Previously, you did not have a compat entry for the `SeawaterPolynomials` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/751
https://github.com/CliMA/Oceananigans.jl/pull/751:405,Deployability,release,release,405,"This pull request sets the compat entry for the `SeawaterPolynomials` package to `0.2`. This is a brand new compat entry. Previously, you did not have a compat entry for the `SeawaterPolynomials` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/751
https://github.com/CliMA/Oceananigans.jl/pull/751:475,Integrability,depend,depend,475,"This pull request sets the compat entry for the `SeawaterPolynomials` package to `0.2`. This is a brand new compat entry. Previously, you did not have a compat entry for the `SeawaterPolynomials` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/751
https://github.com/CliMA/Oceananigans.jl/pull/751:222,Testability,test,tested,222,"This pull request sets the compat entry for the `SeawaterPolynomials` package to `0.2`. This is a brand new compat entry. Previously, you did not have a compat entry for the `SeawaterPolynomials` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/751
https://github.com/CliMA/Oceananigans.jl/pull/751:327,Testability,test,tests,327,"This pull request sets the compat entry for the `SeawaterPolynomials` package to `0.2`. This is a brand new compat entry. Previously, you did not have a compat entry for the `SeawaterPolynomials` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/751
https://github.com/CliMA/Oceananigans.jl/pull/751:494,Testability,test,tests,494,"This pull request sets the compat entry for the `SeawaterPolynomials` package to `0.2`. This is a brand new compat entry. Previously, you did not have a compat entry for the `SeawaterPolynomials` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/751
https://github.com/CliMA/Oceananigans.jl/pull/753:265,Deployability,deploy,deploydocs,265,"This PR adds the docs dependencies in the `docs/Project.toml` instead of them being added one-by-one via `.travis.yaml`. Furthermore:; - Adds `using Plots` in `docs/make.jl` so that precompilation statements are not captured by Literate.; - Sets `preview=true` in `deploydocs()`. This way, a preview version of what the docs will look like after merge is pushed by Documenter.; - Updates the repository's URL in the docs so that docs are deployed properly. For example, the docs failed to deploy after the recent commit 1e8704c.; .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/753
https://github.com/CliMA/Oceananigans.jl/pull/753:380,Deployability,Update,Updates,380,"This PR adds the docs dependencies in the `docs/Project.toml` instead of them being added one-by-one via `.travis.yaml`. Furthermore:; - Adds `using Plots` in `docs/make.jl` so that precompilation statements are not captured by Literate.; - Sets `preview=true` in `deploydocs()`. This way, a preview version of what the docs will look like after merge is pushed by Documenter.; - Updates the repository's URL in the docs so that docs are deployed properly. For example, the docs failed to deploy after the recent commit 1e8704c.; .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/753
https://github.com/CliMA/Oceananigans.jl/pull/753:438,Deployability,deploy,deployed,438,"This PR adds the docs dependencies in the `docs/Project.toml` instead of them being added one-by-one via `.travis.yaml`. Furthermore:; - Adds `using Plots` in `docs/make.jl` so that precompilation statements are not captured by Literate.; - Sets `preview=true` in `deploydocs()`. This way, a preview version of what the docs will look like after merge is pushed by Documenter.; - Updates the repository's URL in the docs so that docs are deployed properly. For example, the docs failed to deploy after the recent commit 1e8704c.; .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/753
https://github.com/CliMA/Oceananigans.jl/pull/753:489,Deployability,deploy,deploy,489,"This PR adds the docs dependencies in the `docs/Project.toml` instead of them being added one-by-one via `.travis.yaml`. Furthermore:; - Adds `using Plots` in `docs/make.jl` so that precompilation statements are not captured by Literate.; - Sets `preview=true` in `deploydocs()`. This way, a preview version of what the docs will look like after merge is pushed by Documenter.; - Updates the repository's URL in the docs so that docs are deployed properly. For example, the docs failed to deploy after the recent commit 1e8704c.; .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/753
https://github.com/CliMA/Oceananigans.jl/pull/753:22,Integrability,depend,dependencies,22,"This PR adds the docs dependencies in the `docs/Project.toml` instead of them being added one-by-one via `.travis.yaml`. Furthermore:; - Adds `using Plots` in `docs/make.jl` so that precompilation statements are not captured by Literate.; - Sets `preview=true` in `deploydocs()`. This way, a preview version of what the docs will look like after merge is pushed by Documenter.; - Updates the repository's URL in the docs so that docs are deployed properly. For example, the docs failed to deploy after the recent commit 1e8704c.; .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/753
https://github.com/CliMA/Oceananigans.jl/pull/757:165,Integrability,wrap,wrapped,165,This PR changes the grid coordinate arrays so that they are not reshaped to three-dimensional arrays. . The coordinate arrays are now one-dimensional `OffsetArray`s wrapped around a range. This simplifies some code and also makes our more complicated `AbstractOperations` tests pass.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/757
https://github.com/CliMA/Oceananigans.jl/pull/757:272,Testability,test,tests,272,This PR changes the grid coordinate arrays so that they are not reshaped to three-dimensional arrays. . The coordinate arrays are now one-dimensional `OffsetArray`s wrapped around a range. This simplifies some code and also makes our more complicated `AbstractOperations` tests pass.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/757
https://github.com/CliMA/Oceananigans.jl/pull/757:194,Usability,simpl,simplifies,194,This PR changes the grid coordinate arrays so that they are not reshaped to three-dimensional arrays. . The coordinate arrays are now one-dimensional `OffsetArray`s wrapped around a range. This simplifies some code and also makes our more complicated `AbstractOperations` tests pass.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/757
https://github.com/CliMA/Oceananigans.jl/pull/758:54,Testability,test,tested,54,Should speed up GitLab CI builds. CPU is already well-tested on Travis CI and Appveyor.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/758
https://github.com/CliMA/Oceananigans.jl/pull/759:451,Availability,down,downstream,451,"This pull request sets the compat entry for the `SeawaterPolynomials` package to `0.2`. This is a brand new compat entry. Previously, you did not have a compat entry for the `SeawaterPolynomials` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/759
https://github.com/CliMA/Oceananigans.jl/pull/759:399,Deployability,patch,patch,399,"This pull request sets the compat entry for the `SeawaterPolynomials` package to `0.2`. This is a brand new compat entry. Previously, you did not have a compat entry for the `SeawaterPolynomials` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/759
https://github.com/CliMA/Oceananigans.jl/pull/759:405,Deployability,release,release,405,"This pull request sets the compat entry for the `SeawaterPolynomials` package to `0.2`. This is a brand new compat entry. Previously, you did not have a compat entry for the `SeawaterPolynomials` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/759
https://github.com/CliMA/Oceananigans.jl/pull/759:475,Integrability,depend,depend,475,"This pull request sets the compat entry for the `SeawaterPolynomials` package to `0.2`. This is a brand new compat entry. Previously, you did not have a compat entry for the `SeawaterPolynomials` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/759
https://github.com/CliMA/Oceananigans.jl/pull/759:222,Testability,test,tested,222,"This pull request sets the compat entry for the `SeawaterPolynomials` package to `0.2`. This is a brand new compat entry. Previously, you did not have a compat entry for the `SeawaterPolynomials` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/759
https://github.com/CliMA/Oceananigans.jl/pull/759:327,Testability,test,tests,327,"This pull request sets the compat entry for the `SeawaterPolynomials` package to `0.2`. This is a brand new compat entry. Previously, you did not have a compat entry for the `SeawaterPolynomials` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/759
https://github.com/CliMA/Oceananigans.jl/pull/759:494,Testability,test,tests,494,"This pull request sets the compat entry for the `SeawaterPolynomials` package to `0.2`. This is a brand new compat entry. Previously, you did not have a compat entry for the `SeawaterPolynomials` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/759
https://github.com/CliMA/Oceananigans.jl/pull/762:48,Testability,test,tests,48,"Since you now report coverage via the gitlab-ci tests (to include GPU coverage) the coveralls.io is not needed. As far as I know, gitlab-ci is only able to report coverage to codecov.io. Thus, I propose to remove the coveralls badge. (Btw, the URL was broken anyway...)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/762
https://github.com/CliMA/Oceananigans.jl/pull/765:8,Deployability,update,update,8,Need to update README and docs to mention the new Julia 1.4+ requirement.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/765
https://github.com/CliMA/Oceananigans.jl/issues/766:986,Integrability,rout,route,986,"It's annoying to constantly write things like `Face` and `Cell` in Oceananigans scripts. I wonder if we can develop some notation that allows this to be avoided in the vast majority of use cases. We can introduce notation `:u`, `:v`, `:w`, and `:c` to indicate the velocities and tracer locations. Thus we could write. ```julia; x = xnodes(:c, grid); ```. to get `x` at tracer points. Or to build a tracer field,. ```julia; c = Field(:c, GPU(), grid); ```. Note that we currently require. ```julia; c = Field(Cell, Cell, Cell, GPU(), grid); ```. (a side note is that the `grid` should probably come before the `arch`, but that's another issue.). An alternate design would use the function `location`. Right now this is defined. ```julia; location(::AbstractField{X, Y, Z}) where {X, Y, Z} = (X, Y, Z) # note no instantiation; ```. We could define a couple new methods that allow something like. ```julia; x = xnodes(location(:c), grid); ```. for example. I suppose this is the quickest route to the functionality I'm proposing, since we'd have to change almost no existing code. I also wonder if this would allow. ```julia; momentum_flux = @at(location(:w), w * c); ```. That doesn't seem very easy to read so maybe we can discuss how to specify the location of abstract operations transparently.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/766
https://github.com/CliMA/Oceananigans.jl/issues/766:153,Safety,avoid,avoided,153,"It's annoying to constantly write things like `Face` and `Cell` in Oceananigans scripts. I wonder if we can develop some notation that allows this to be avoided in the vast majority of use cases. We can introduce notation `:u`, `:v`, `:w`, and `:c` to indicate the velocities and tracer locations. Thus we could write. ```julia; x = xnodes(:c, grid); ```. to get `x` at tracer points. Or to build a tracer field,. ```julia; c = Field(:c, GPU(), grid); ```. Note that we currently require. ```julia; c = Field(Cell, Cell, Cell, GPU(), grid); ```. (a side note is that the `grid` should probably come before the `arch`, but that's another issue.). An alternate design would use the function `location`. Right now this is defined. ```julia; location(::AbstractField{X, Y, Z}) where {X, Y, Z} = (X, Y, Z) # note no instantiation; ```. We could define a couple new methods that allow something like. ```julia; x = xnodes(location(:c), grid); ```. for example. I suppose this is the quickest route to the functionality I'm proposing, since we'd have to change almost no existing code. I also wonder if this would allow. ```julia; momentum_flux = @at(location(:w), w * c); ```. That doesn't seem very easy to read so maybe we can discuss how to specify the location of abstract operations transparently.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/766
https://github.com/CliMA/Oceananigans.jl/pull/767:1210,Energy Efficiency,Green,Green,1210,"This PR adds verification tests for numerical convergence of time-stepping and spatial discretization. One test does not pass (the most complicated one): forced, fixed slip simulation. More detailed analysis of this test is needed. Below is a summary of the results. # Time stepping convergence tests. ![image](https://user-images.githubusercontent.com/15271942/83302597-a65f8e00-a1c9-11ea-89b0-c1816cd7328e.png). # Advection and diffusion of a one-dimensional cosine. ![cosine_advection_diffusion_solutions](https://user-images.githubusercontent.com/15271942/83302620-ae1f3280-a1c9-11ea-90ed-17642646350d.png). ![cosine_advection_diffusion_error_convergence](https://user-images.githubusercontent.com/15271942/83302631-b24b5000-a1c9-11ea-9e75-457e3b912203.png). # Advection and diffusion of a one-dimensional Gaussian. ![image](https://user-images.githubusercontent.com/15271942/83302659-be371200-a1c9-11ea-9398-0bddd4f20a6e.png). ![image](https://user-images.githubusercontent.com/15271942/83302666-c1320280-a1c9-11ea-8d74-d454336ab22b.png). # Two-dimensional diffusion. ![image](https://user-images.githubusercontent.com/15271942/83303244-b5930b80-a1ca-11ea-9ef1-deb7f1230ac4.png). # Two-dimensional Taylor-Green vortex. ![taylor_green_convergence](https://user-images.githubusercontent.com/15271942/83302684-c8f1a700-a1c9-11ea-8ddb-f4f8d7e11962.png). # Two-dimensional forced flow with free-slip boundary conditions. ![forced_free_slip_convergence](https://user-images.githubusercontent.com/15271942/83303260-bd52b000-a1ca-11ea-83ad-6d6a71c530a8.png). # Two-dimensional forced flow with fixed-slip boundary conditions. _This test does not pass_. We don't know if there is a bug in the test or a problem in Oceananigans. ![forced_fixed_slip_convergence](https://user-images.githubusercontent.com/15271942/83303305-cf345300-a1ca-11ea-81c8-2cdcb14d4066.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/767
https://github.com/CliMA/Oceananigans.jl/pull/767:26,Testability,test,tests,26,"This PR adds verification tests for numerical convergence of time-stepping and spatial discretization. One test does not pass (the most complicated one): forced, fixed slip simulation. More detailed analysis of this test is needed. Below is a summary of the results. # Time stepping convergence tests. ![image](https://user-images.githubusercontent.com/15271942/83302597-a65f8e00-a1c9-11ea-89b0-c1816cd7328e.png). # Advection and diffusion of a one-dimensional cosine. ![cosine_advection_diffusion_solutions](https://user-images.githubusercontent.com/15271942/83302620-ae1f3280-a1c9-11ea-90ed-17642646350d.png). ![cosine_advection_diffusion_error_convergence](https://user-images.githubusercontent.com/15271942/83302631-b24b5000-a1c9-11ea-9e75-457e3b912203.png). # Advection and diffusion of a one-dimensional Gaussian. ![image](https://user-images.githubusercontent.com/15271942/83302659-be371200-a1c9-11ea-9398-0bddd4f20a6e.png). ![image](https://user-images.githubusercontent.com/15271942/83302666-c1320280-a1c9-11ea-8d74-d454336ab22b.png). # Two-dimensional diffusion. ![image](https://user-images.githubusercontent.com/15271942/83303244-b5930b80-a1ca-11ea-9ef1-deb7f1230ac4.png). # Two-dimensional Taylor-Green vortex. ![taylor_green_convergence](https://user-images.githubusercontent.com/15271942/83302684-c8f1a700-a1c9-11ea-8ddb-f4f8d7e11962.png). # Two-dimensional forced flow with free-slip boundary conditions. ![forced_free_slip_convergence](https://user-images.githubusercontent.com/15271942/83303260-bd52b000-a1ca-11ea-83ad-6d6a71c530a8.png). # Two-dimensional forced flow with fixed-slip boundary conditions. _This test does not pass_. We don't know if there is a bug in the test or a problem in Oceananigans. ![forced_fixed_slip_convergence](https://user-images.githubusercontent.com/15271942/83303305-cf345300-a1ca-11ea-81c8-2cdcb14d4066.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/767
https://github.com/CliMA/Oceananigans.jl/pull/767:107,Testability,test,test,107,"This PR adds verification tests for numerical convergence of time-stepping and spatial discretization. One test does not pass (the most complicated one): forced, fixed slip simulation. More detailed analysis of this test is needed. Below is a summary of the results. # Time stepping convergence tests. ![image](https://user-images.githubusercontent.com/15271942/83302597-a65f8e00-a1c9-11ea-89b0-c1816cd7328e.png). # Advection and diffusion of a one-dimensional cosine. ![cosine_advection_diffusion_solutions](https://user-images.githubusercontent.com/15271942/83302620-ae1f3280-a1c9-11ea-90ed-17642646350d.png). ![cosine_advection_diffusion_error_convergence](https://user-images.githubusercontent.com/15271942/83302631-b24b5000-a1c9-11ea-9e75-457e3b912203.png). # Advection and diffusion of a one-dimensional Gaussian. ![image](https://user-images.githubusercontent.com/15271942/83302659-be371200-a1c9-11ea-9398-0bddd4f20a6e.png). ![image](https://user-images.githubusercontent.com/15271942/83302666-c1320280-a1c9-11ea-8d74-d454336ab22b.png). # Two-dimensional diffusion. ![image](https://user-images.githubusercontent.com/15271942/83303244-b5930b80-a1ca-11ea-9ef1-deb7f1230ac4.png). # Two-dimensional Taylor-Green vortex. ![taylor_green_convergence](https://user-images.githubusercontent.com/15271942/83302684-c8f1a700-a1c9-11ea-8ddb-f4f8d7e11962.png). # Two-dimensional forced flow with free-slip boundary conditions. ![forced_free_slip_convergence](https://user-images.githubusercontent.com/15271942/83303260-bd52b000-a1ca-11ea-83ad-6d6a71c530a8.png). # Two-dimensional forced flow with fixed-slip boundary conditions. _This test does not pass_. We don't know if there is a bug in the test or a problem in Oceananigans. ![forced_fixed_slip_convergence](https://user-images.githubusercontent.com/15271942/83303305-cf345300-a1ca-11ea-81c8-2cdcb14d4066.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/767
https://github.com/CliMA/Oceananigans.jl/pull/767:216,Testability,test,test,216,"This PR adds verification tests for numerical convergence of time-stepping and spatial discretization. One test does not pass (the most complicated one): forced, fixed slip simulation. More detailed analysis of this test is needed. Below is a summary of the results. # Time stepping convergence tests. ![image](https://user-images.githubusercontent.com/15271942/83302597-a65f8e00-a1c9-11ea-89b0-c1816cd7328e.png). # Advection and diffusion of a one-dimensional cosine. ![cosine_advection_diffusion_solutions](https://user-images.githubusercontent.com/15271942/83302620-ae1f3280-a1c9-11ea-90ed-17642646350d.png). ![cosine_advection_diffusion_error_convergence](https://user-images.githubusercontent.com/15271942/83302631-b24b5000-a1c9-11ea-9e75-457e3b912203.png). # Advection and diffusion of a one-dimensional Gaussian. ![image](https://user-images.githubusercontent.com/15271942/83302659-be371200-a1c9-11ea-9398-0bddd4f20a6e.png). ![image](https://user-images.githubusercontent.com/15271942/83302666-c1320280-a1c9-11ea-8d74-d454336ab22b.png). # Two-dimensional diffusion. ![image](https://user-images.githubusercontent.com/15271942/83303244-b5930b80-a1ca-11ea-9ef1-deb7f1230ac4.png). # Two-dimensional Taylor-Green vortex. ![taylor_green_convergence](https://user-images.githubusercontent.com/15271942/83302684-c8f1a700-a1c9-11ea-8ddb-f4f8d7e11962.png). # Two-dimensional forced flow with free-slip boundary conditions. ![forced_free_slip_convergence](https://user-images.githubusercontent.com/15271942/83303260-bd52b000-a1ca-11ea-83ad-6d6a71c530a8.png). # Two-dimensional forced flow with fixed-slip boundary conditions. _This test does not pass_. We don't know if there is a bug in the test or a problem in Oceananigans. ![forced_fixed_slip_convergence](https://user-images.githubusercontent.com/15271942/83303305-cf345300-a1ca-11ea-81c8-2cdcb14d4066.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/767
https://github.com/CliMA/Oceananigans.jl/pull/767:295,Testability,test,tests,295,"This PR adds verification tests for numerical convergence of time-stepping and spatial discretization. One test does not pass (the most complicated one): forced, fixed slip simulation. More detailed analysis of this test is needed. Below is a summary of the results. # Time stepping convergence tests. ![image](https://user-images.githubusercontent.com/15271942/83302597-a65f8e00-a1c9-11ea-89b0-c1816cd7328e.png). # Advection and diffusion of a one-dimensional cosine. ![cosine_advection_diffusion_solutions](https://user-images.githubusercontent.com/15271942/83302620-ae1f3280-a1c9-11ea-90ed-17642646350d.png). ![cosine_advection_diffusion_error_convergence](https://user-images.githubusercontent.com/15271942/83302631-b24b5000-a1c9-11ea-9e75-457e3b912203.png). # Advection and diffusion of a one-dimensional Gaussian. ![image](https://user-images.githubusercontent.com/15271942/83302659-be371200-a1c9-11ea-9398-0bddd4f20a6e.png). ![image](https://user-images.githubusercontent.com/15271942/83302666-c1320280-a1c9-11ea-8d74-d454336ab22b.png). # Two-dimensional diffusion. ![image](https://user-images.githubusercontent.com/15271942/83303244-b5930b80-a1ca-11ea-9ef1-deb7f1230ac4.png). # Two-dimensional Taylor-Green vortex. ![taylor_green_convergence](https://user-images.githubusercontent.com/15271942/83302684-c8f1a700-a1c9-11ea-8ddb-f4f8d7e11962.png). # Two-dimensional forced flow with free-slip boundary conditions. ![forced_free_slip_convergence](https://user-images.githubusercontent.com/15271942/83303260-bd52b000-a1ca-11ea-83ad-6d6a71c530a8.png). # Two-dimensional forced flow with fixed-slip boundary conditions. _This test does not pass_. We don't know if there is a bug in the test or a problem in Oceananigans. ![forced_fixed_slip_convergence](https://user-images.githubusercontent.com/15271942/83303305-cf345300-a1ca-11ea-81c8-2cdcb14d4066.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/767
https://github.com/CliMA/Oceananigans.jl/pull/767:1629,Testability,test,test,1629,"This PR adds verification tests for numerical convergence of time-stepping and spatial discretization. One test does not pass (the most complicated one): forced, fixed slip simulation. More detailed analysis of this test is needed. Below is a summary of the results. # Time stepping convergence tests. ![image](https://user-images.githubusercontent.com/15271942/83302597-a65f8e00-a1c9-11ea-89b0-c1816cd7328e.png). # Advection and diffusion of a one-dimensional cosine. ![cosine_advection_diffusion_solutions](https://user-images.githubusercontent.com/15271942/83302620-ae1f3280-a1c9-11ea-90ed-17642646350d.png). ![cosine_advection_diffusion_error_convergence](https://user-images.githubusercontent.com/15271942/83302631-b24b5000-a1c9-11ea-9e75-457e3b912203.png). # Advection and diffusion of a one-dimensional Gaussian. ![image](https://user-images.githubusercontent.com/15271942/83302659-be371200-a1c9-11ea-9398-0bddd4f20a6e.png). ![image](https://user-images.githubusercontent.com/15271942/83302666-c1320280-a1c9-11ea-8d74-d454336ab22b.png). # Two-dimensional diffusion. ![image](https://user-images.githubusercontent.com/15271942/83303244-b5930b80-a1ca-11ea-9ef1-deb7f1230ac4.png). # Two-dimensional Taylor-Green vortex. ![taylor_green_convergence](https://user-images.githubusercontent.com/15271942/83302684-c8f1a700-a1c9-11ea-8ddb-f4f8d7e11962.png). # Two-dimensional forced flow with free-slip boundary conditions. ![forced_free_slip_convergence](https://user-images.githubusercontent.com/15271942/83303260-bd52b000-a1ca-11ea-83ad-6d6a71c530a8.png). # Two-dimensional forced flow with fixed-slip boundary conditions. _This test does not pass_. We don't know if there is a bug in the test or a problem in Oceananigans. ![forced_fixed_slip_convergence](https://user-images.githubusercontent.com/15271942/83303305-cf345300-a1ca-11ea-81c8-2cdcb14d4066.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/767
https://github.com/CliMA/Oceananigans.jl/pull/767:1689,Testability,test,test,1689,"This PR adds verification tests for numerical convergence of time-stepping and spatial discretization. One test does not pass (the most complicated one): forced, fixed slip simulation. More detailed analysis of this test is needed. Below is a summary of the results. # Time stepping convergence tests. ![image](https://user-images.githubusercontent.com/15271942/83302597-a65f8e00-a1c9-11ea-89b0-c1816cd7328e.png). # Advection and diffusion of a one-dimensional cosine. ![cosine_advection_diffusion_solutions](https://user-images.githubusercontent.com/15271942/83302620-ae1f3280-a1c9-11ea-90ed-17642646350d.png). ![cosine_advection_diffusion_error_convergence](https://user-images.githubusercontent.com/15271942/83302631-b24b5000-a1c9-11ea-9e75-457e3b912203.png). # Advection and diffusion of a one-dimensional Gaussian. ![image](https://user-images.githubusercontent.com/15271942/83302659-be371200-a1c9-11ea-9398-0bddd4f20a6e.png). ![image](https://user-images.githubusercontent.com/15271942/83302666-c1320280-a1c9-11ea-8d74-d454336ab22b.png). # Two-dimensional diffusion. ![image](https://user-images.githubusercontent.com/15271942/83303244-b5930b80-a1ca-11ea-9ef1-deb7f1230ac4.png). # Two-dimensional Taylor-Green vortex. ![taylor_green_convergence](https://user-images.githubusercontent.com/15271942/83302684-c8f1a700-a1c9-11ea-8ddb-f4f8d7e11962.png). # Two-dimensional forced flow with free-slip boundary conditions. ![forced_free_slip_convergence](https://user-images.githubusercontent.com/15271942/83303260-bd52b000-a1ca-11ea-83ad-6d6a71c530a8.png). # Two-dimensional forced flow with fixed-slip boundary conditions. _This test does not pass_. We don't know if there is a bug in the test or a problem in Oceananigans. ![forced_fixed_slip_convergence](https://user-images.githubusercontent.com/15271942/83303305-cf345300-a1ca-11ea-81c8-2cdcb14d4066.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/767
https://github.com/CliMA/Oceananigans.jl/issues/769:215,Modifiability,parameteriz,parameterized,215,"We may have discussed this in the past or proposed similar ideas but just thought I'd open a suggestion issue as I think it might make model construction simpler for future users. Right now, for example, creating a parameterized boundary function takes 5 steps; ```julia; B_params = (; Ly = Ly,; B½ = 1.96e-7, # Buoyancy flux at midchannel [m²/s³]; Lᶠ = 10kilometer # Characteristic length scale of the forcing [m]; ); B(x, y, p) = p.B½ * (tanh(2 * (y - p.Ly/2) / p.Lᶠ) + 1) # Surface buoyancy flux [m²/s³]; B_bf = BoundaryFunction{:z, Cell, Cell}(B, B_params); top_b_bc = FluxBoundaryCondition(B_bf); b_bcs = TracerBoundaryConditions(grid, top=top_b_bc); ```. I wonder if we can brush a lot of this under the hood so the user just has to type; ```julia; B_params = (; Ly = Ly,; B½ = 1.96e-7, # Buoyancy flux at midchannel [m²/s³]; Lᶠ = 10kilometer # Characteristic length scale of the forcing [m]; ); B(x, y, p) = p.B½ * (tanh(2 * (y - p.Ly/2) / p.Lᶠ) + 1) # Surface buoyancy flux [m²/s³]; b_bcs = TracerBoundaryConditions(grid, top=FluxBoundaryCondition(B)); ```; I guess it really only skips one step but with 3 arguments it can be inferred to be a parameterized boundary function and the location `{:z, Cell, Cell}` can be inferred from the fact that the BC is being applied at the `top` and it's for a tracer field. Other construction patterns can probably be streamlined too.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/769
https://github.com/CliMA/Oceananigans.jl/issues/769:1152,Modifiability,parameteriz,parameterized,1152,"We may have discussed this in the past or proposed similar ideas but just thought I'd open a suggestion issue as I think it might make model construction simpler for future users. Right now, for example, creating a parameterized boundary function takes 5 steps; ```julia; B_params = (; Ly = Ly,; B½ = 1.96e-7, # Buoyancy flux at midchannel [m²/s³]; Lᶠ = 10kilometer # Characteristic length scale of the forcing [m]; ); B(x, y, p) = p.B½ * (tanh(2 * (y - p.Ly/2) / p.Lᶠ) + 1) # Surface buoyancy flux [m²/s³]; B_bf = BoundaryFunction{:z, Cell, Cell}(B, B_params); top_b_bc = FluxBoundaryCondition(B_bf); b_bcs = TracerBoundaryConditions(grid, top=top_b_bc); ```. I wonder if we can brush a lot of this under the hood so the user just has to type; ```julia; B_params = (; Ly = Ly,; B½ = 1.96e-7, # Buoyancy flux at midchannel [m²/s³]; Lᶠ = 10kilometer # Characteristic length scale of the forcing [m]; ); B(x, y, p) = p.B½ * (tanh(2 * (y - p.Ly/2) / p.Lᶠ) + 1) # Surface buoyancy flux [m²/s³]; b_bcs = TracerBoundaryConditions(grid, top=FluxBoundaryCondition(B)); ```; I guess it really only skips one step but with 3 arguments it can be inferred to be a parameterized boundary function and the location `{:z, Cell, Cell}` can be inferred from the fact that the BC is being applied at the `top` and it's for a tracer field. Other construction patterns can probably be streamlined too.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/769
https://github.com/CliMA/Oceananigans.jl/issues/769:154,Usability,simpl,simpler,154,"We may have discussed this in the past or proposed similar ideas but just thought I'd open a suggestion issue as I think it might make model construction simpler for future users. Right now, for example, creating a parameterized boundary function takes 5 steps; ```julia; B_params = (; Ly = Ly,; B½ = 1.96e-7, # Buoyancy flux at midchannel [m²/s³]; Lᶠ = 10kilometer # Characteristic length scale of the forcing [m]; ); B(x, y, p) = p.B½ * (tanh(2 * (y - p.Ly/2) / p.Lᶠ) + 1) # Surface buoyancy flux [m²/s³]; B_bf = BoundaryFunction{:z, Cell, Cell}(B, B_params); top_b_bc = FluxBoundaryCondition(B_bf); b_bcs = TracerBoundaryConditions(grid, top=top_b_bc); ```. I wonder if we can brush a lot of this under the hood so the user just has to type; ```julia; B_params = (; Ly = Ly,; B½ = 1.96e-7, # Buoyancy flux at midchannel [m²/s³]; Lᶠ = 10kilometer # Characteristic length scale of the forcing [m]; ); B(x, y, p) = p.B½ * (tanh(2 * (y - p.Ly/2) / p.Lᶠ) + 1) # Surface buoyancy flux [m²/s³]; b_bcs = TracerBoundaryConditions(grid, top=FluxBoundaryCondition(B)); ```; I guess it really only skips one step but with 3 arguments it can be inferred to be a parameterized boundary function and the location `{:z, Cell, Cell}` can be inferred from the fact that the BC is being applied at the `top` and it's for a tracer field. Other construction patterns can probably be streamlined too.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/769
https://github.com/CliMA/Oceananigans.jl/issues/770:592,Modifiability,parameteriz,parameterization,592,"Just moving an email thread to a GitHub issue:. > 1. Is it hydrostatic or non-hydrostatic? On GitHub it says 'It is designed to solve the rotating Boussinesq equations used in non-hydrostatic ocean modeling but can be used to solve for any incompressible flow.' so it implies it's non-hydrostatic?; > 2. Since currently only cartesian coordinate is supported, is it possible to set the Coriolis force with rotation axis at the center of the domain and specify the grids in the shape of a circle around this axis as if it's a rotating cylinder but not in cylindrical coordinate?; > 3. Is eddy parameterization supported, like the GM-Redi/Visbeck package in MITgcm?; > 4. for the boundary condition, is topographic feature supported?; I see in the online doc the UVelocityBoundaryConditions probably can be used to set non-slip boundary but features like topographic wall would still need extra setting right? Is it something related to gradient or no-penetration?; >; > _Originally posted over email_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/770
https://github.com/CliMA/Oceananigans.jl/pull/771:21,Security,validat,validation,21,"This PR introduces a validation test replicating the mesoscale eddying channel setup discussed in section 3(b) of Haine & Marshall (1998). It's not clear we want to make this a full validation test so I'm leaving it as a draft PR for now. We may instead want to move to more realistic simulations with a LESbrary approach. References; ----------; Haine & Marshall (1998). [Gravitational, symmetric, and baroclinic instability of the ocean mixed layer](https://doi.org/10.1175/1520-0485(1998)028<0634:GSABIO>2.0.CO;2). Journal of physical oceanography, **28**(4), pp. 634-658.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/771
https://github.com/CliMA/Oceananigans.jl/pull/771:182,Security,validat,validation,182,"This PR introduces a validation test replicating the mesoscale eddying channel setup discussed in section 3(b) of Haine & Marshall (1998). It's not clear we want to make this a full validation test so I'm leaving it as a draft PR for now. We may instead want to move to more realistic simulations with a LESbrary approach. References; ----------; Haine & Marshall (1998). [Gravitational, symmetric, and baroclinic instability of the ocean mixed layer](https://doi.org/10.1175/1520-0485(1998)028<0634:GSABIO>2.0.CO;2). Journal of physical oceanography, **28**(4), pp. 634-658.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/771
https://github.com/CliMA/Oceananigans.jl/pull/771:32,Testability,test,test,32,"This PR introduces a validation test replicating the mesoscale eddying channel setup discussed in section 3(b) of Haine & Marshall (1998). It's not clear we want to make this a full validation test so I'm leaving it as a draft PR for now. We may instead want to move to more realistic simulations with a LESbrary approach. References; ----------; Haine & Marshall (1998). [Gravitational, symmetric, and baroclinic instability of the ocean mixed layer](https://doi.org/10.1175/1520-0485(1998)028<0634:GSABIO>2.0.CO;2). Journal of physical oceanography, **28**(4), pp. 634-658.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/771
https://github.com/CliMA/Oceananigans.jl/pull/771:193,Testability,test,test,193,"This PR introduces a validation test replicating the mesoscale eddying channel setup discussed in section 3(b) of Haine & Marshall (1998). It's not clear we want to make this a full validation test so I'm leaving it as a draft PR for now. We may instead want to move to more realistic simulations with a LESbrary approach. References; ----------; Haine & Marshall (1998). [Gravitational, symmetric, and baroclinic instability of the ocean mixed layer](https://doi.org/10.1175/1520-0485(1998)028<0634:GSABIO>2.0.CO;2). Journal of physical oceanography, **28**(4), pp. 634-658.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/771
https://github.com/CliMA/Oceananigans.jl/pull/771:148,Usability,clear,clear,148,"This PR introduces a validation test replicating the mesoscale eddying channel setup discussed in section 3(b) of Haine & Marshall (1998). It's not clear we want to make this a full validation test so I'm leaving it as a draft PR for now. We may instead want to move to more realistic simulations with a LESbrary approach. References; ----------; Haine & Marshall (1998). [Gravitational, symmetric, and baroclinic instability of the ocean mixed layer](https://doi.org/10.1175/1520-0485(1998)028<0634:GSABIO>2.0.CO;2). Journal of physical oceanography, **28**(4), pp. 634-658.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/771
https://github.com/CliMA/Oceananigans.jl/issues/774:131,Integrability,Depend,Dependence-of-Southern-Ocean-Meridional,131,A nice validation test for channels might be Abernathey et al 2011:. https://journals.ametsoc.org/jpo/article/41/12/2261/11254/The-Dependence-of-Southern-Ocean-Meridional,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/774
https://github.com/CliMA/Oceananigans.jl/issues/774:7,Security,validat,validation,7,A nice validation test for channels might be Abernathey et al 2011:. https://journals.ametsoc.org/jpo/article/41/12/2261/11254/The-Dependence-of-Southern-Ocean-Meridional,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/774
https://github.com/CliMA/Oceananigans.jl/issues/774:18,Testability,test,test,18,A nice validation test for channels might be Abernathey et al 2011:. https://journals.ametsoc.org/jpo/article/41/12/2261/11254/The-Dependence-of-Southern-Ocean-Meridional,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/774
https://github.com/CliMA/Oceananigans.jl/issues/775:39,Security,validat,validation,39,"@johncmarshall54 suggested that a good validation test for an immersed boundary implementation is a topographic Rossby wave, a la:. https://journals.ametsoc.org/mwr/article/125/9/2293/104481/Representation-of-Topography-by-Shaved-Cells-in-a. which has an analytical solution",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/775
https://github.com/CliMA/Oceananigans.jl/issues/775:50,Testability,test,test,50,"@johncmarshall54 suggested that a good validation test for an immersed boundary implementation is a topographic Rossby wave, a la:. https://journals.ametsoc.org/mwr/article/125/9/2293/104481/Representation-of-Topography-by-Shaved-Cells-in-a. which has an analytical solution",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/775
https://github.com/CliMA/Oceananigans.jl/issues/777:10,Security,validat,validation,10,"#767 adds validation tests that confirm the expected rate of numerical convergence for the Oceananigans time-stepper, advection schemes, Laplacian diffusion, and some dynamical tests that validate expected behavior of the pressure solver for free-slip and fixed-slip boundary conditions. We need to add documentation of these validation tests, as well as tests that ensure the validation test scripts continue to run as the API is changed.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/777
https://github.com/CliMA/Oceananigans.jl/issues/777:188,Security,validat,validate,188,"#767 adds validation tests that confirm the expected rate of numerical convergence for the Oceananigans time-stepper, advection schemes, Laplacian diffusion, and some dynamical tests that validate expected behavior of the pressure solver for free-slip and fixed-slip boundary conditions. We need to add documentation of these validation tests, as well as tests that ensure the validation test scripts continue to run as the API is changed.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/777
https://github.com/CliMA/Oceananigans.jl/issues/777:326,Security,validat,validation,326,"#767 adds validation tests that confirm the expected rate of numerical convergence for the Oceananigans time-stepper, advection schemes, Laplacian diffusion, and some dynamical tests that validate expected behavior of the pressure solver for free-slip and fixed-slip boundary conditions. We need to add documentation of these validation tests, as well as tests that ensure the validation test scripts continue to run as the API is changed.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/777
https://github.com/CliMA/Oceananigans.jl/issues/777:377,Security,validat,validation,377,"#767 adds validation tests that confirm the expected rate of numerical convergence for the Oceananigans time-stepper, advection schemes, Laplacian diffusion, and some dynamical tests that validate expected behavior of the pressure solver for free-slip and fixed-slip boundary conditions. We need to add documentation of these validation tests, as well as tests that ensure the validation test scripts continue to run as the API is changed.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/777
https://github.com/CliMA/Oceananigans.jl/issues/777:21,Testability,test,tests,21,"#767 adds validation tests that confirm the expected rate of numerical convergence for the Oceananigans time-stepper, advection schemes, Laplacian diffusion, and some dynamical tests that validate expected behavior of the pressure solver for free-slip and fixed-slip boundary conditions. We need to add documentation of these validation tests, as well as tests that ensure the validation test scripts continue to run as the API is changed.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/777
https://github.com/CliMA/Oceananigans.jl/issues/777:177,Testability,test,tests,177,"#767 adds validation tests that confirm the expected rate of numerical convergence for the Oceananigans time-stepper, advection schemes, Laplacian diffusion, and some dynamical tests that validate expected behavior of the pressure solver for free-slip and fixed-slip boundary conditions. We need to add documentation of these validation tests, as well as tests that ensure the validation test scripts continue to run as the API is changed.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/777
https://github.com/CliMA/Oceananigans.jl/issues/777:337,Testability,test,tests,337,"#767 adds validation tests that confirm the expected rate of numerical convergence for the Oceananigans time-stepper, advection schemes, Laplacian diffusion, and some dynamical tests that validate expected behavior of the pressure solver for free-slip and fixed-slip boundary conditions. We need to add documentation of these validation tests, as well as tests that ensure the validation test scripts continue to run as the API is changed.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/777
https://github.com/CliMA/Oceananigans.jl/issues/777:355,Testability,test,tests,355,"#767 adds validation tests that confirm the expected rate of numerical convergence for the Oceananigans time-stepper, advection schemes, Laplacian diffusion, and some dynamical tests that validate expected behavior of the pressure solver for free-slip and fixed-slip boundary conditions. We need to add documentation of these validation tests, as well as tests that ensure the validation test scripts continue to run as the API is changed.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/777
https://github.com/CliMA/Oceananigans.jl/issues/777:388,Testability,test,test,388,"#767 adds validation tests that confirm the expected rate of numerical convergence for the Oceananigans time-stepper, advection schemes, Laplacian diffusion, and some dynamical tests that validate expected behavior of the pressure solver for free-slip and fixed-slip boundary conditions. We need to add documentation of these validation tests, as well as tests that ensure the validation test scripts continue to run as the API is changed.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/777
https://github.com/CliMA/Oceananigans.jl/issues/778:21,Availability,error,error,21,"Might be user script error (i.e. not Oceananigans related) but seems that sometimes when you run a Slurm/LSF script that keeps restoring from checkpoint and submitting itself again, you can sometimes end up with checkpoints at consective iterations which seems weird. Unsure what happened in this case but worth double checking that it's not an Oceananigans issue. ```; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration0.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration255659.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration379710.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration379711.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration379712.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration443975.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration498963.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration539690.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration573543.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration606802.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration640046.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration666801.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration666802.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration673488.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration706733.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration739977.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration739981.jld2; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/778
https://github.com/CliMA/Oceananigans.jl/issues/778:142,Availability,checkpoint,checkpoint,142,"Might be user script error (i.e. not Oceananigans related) but seems that sometimes when you run a Slurm/LSF script that keeps restoring from checkpoint and submitting itself again, you can sometimes end up with checkpoints at consective iterations which seems weird. Unsure what happened in this case but worth double checking that it's not an Oceananigans issue. ```; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration0.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration255659.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration379710.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration379711.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration379712.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration443975.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration498963.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration539690.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration573543.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration606802.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration640046.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration666801.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration666802.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration673488.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration706733.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration739977.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration739981.jld2; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/778
https://github.com/CliMA/Oceananigans.jl/issues/778:212,Availability,checkpoint,checkpoints,212,"Might be user script error (i.e. not Oceananigans related) but seems that sometimes when you run a Slurm/LSF script that keeps restoring from checkpoint and submitting itself again, you can sometimes end up with checkpoints at consective iterations which seems weird. Unsure what happened in this case but worth double checking that it's not an Oceananigans issue. ```; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration0.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration255659.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration379710.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration379711.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration379712.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration443975.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration498963.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration539690.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration573543.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration606802.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration640046.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration666801.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration666802.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration673488.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration706733.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration739977.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration739981.jld2; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/778
https://github.com/CliMA/Oceananigans.jl/issues/779:119,Availability,checkpoint,checkpoint,119,"When setting up scripts to run on HPC clusters with strict job time limits you need to write scripts that continuously checkpoint and restore from checkpoint and submit the job script again once a wall time limit has been reached. This introduces some complexity into the script, e.g. a `if model.clock.iteration != 0` statement for setting initial conditions and potentially extra data wrangling if an output writer needs to be configured to append to an existing file. It's quite easy to forget to do something important and introduce bugs into these scripts which is undesirable as these jobs tend to run for a long time and we frequently submit many such jobs so the cost of a mistake can be quite high. In the future I think developing some kind of abstraction for setting up this kind of script will be important for people who run scripts on HPC clusters with time limits. Not sure what to do but ideally it would minimize the chance of misconfiguration: it could allow users to take a regular script without checkpointing and somehow allow the script to be restored from checkpoint without having to worry about correctly setting initial conditions, configuring output writers, etc.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/779
https://github.com/CliMA/Oceananigans.jl/issues/779:147,Availability,checkpoint,checkpoint,147,"When setting up scripts to run on HPC clusters with strict job time limits you need to write scripts that continuously checkpoint and restore from checkpoint and submit the job script again once a wall time limit has been reached. This introduces some complexity into the script, e.g. a `if model.clock.iteration != 0` statement for setting initial conditions and potentially extra data wrangling if an output writer needs to be configured to append to an existing file. It's quite easy to forget to do something important and introduce bugs into these scripts which is undesirable as these jobs tend to run for a long time and we frequently submit many such jobs so the cost of a mistake can be quite high. In the future I think developing some kind of abstraction for setting up this kind of script will be important for people who run scripts on HPC clusters with time limits. Not sure what to do but ideally it would minimize the chance of misconfiguration: it could allow users to take a regular script without checkpointing and somehow allow the script to be restored from checkpoint without having to worry about correctly setting initial conditions, configuring output writers, etc.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/779
https://github.com/CliMA/Oceananigans.jl/issues/779:1016,Availability,checkpoint,checkpointing,1016,"When setting up scripts to run on HPC clusters with strict job time limits you need to write scripts that continuously checkpoint and restore from checkpoint and submit the job script again once a wall time limit has been reached. This introduces some complexity into the script, e.g. a `if model.clock.iteration != 0` statement for setting initial conditions and potentially extra data wrangling if an output writer needs to be configured to append to an existing file. It's quite easy to forget to do something important and introduce bugs into these scripts which is undesirable as these jobs tend to run for a long time and we frequently submit many such jobs so the cost of a mistake can be quite high. In the future I think developing some kind of abstraction for setting up this kind of script will be important for people who run scripts on HPC clusters with time limits. Not sure what to do but ideally it would minimize the chance of misconfiguration: it could allow users to take a regular script without checkpointing and somehow allow the script to be restored from checkpoint without having to worry about correctly setting initial conditions, configuring output writers, etc.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/779
https://github.com/CliMA/Oceananigans.jl/issues/779:1079,Availability,checkpoint,checkpoint,1079,"When setting up scripts to run on HPC clusters with strict job time limits you need to write scripts that continuously checkpoint and restore from checkpoint and submit the job script again once a wall time limit has been reached. This introduces some complexity into the script, e.g. a `if model.clock.iteration != 0` statement for setting initial conditions and potentially extra data wrangling if an output writer needs to be configured to append to an existing file. It's quite easy to forget to do something important and introduce bugs into these scripts which is undesirable as these jobs tend to run for a long time and we frequently submit many such jobs so the cost of a mistake can be quite high. In the future I think developing some kind of abstraction for setting up this kind of script will be important for people who run scripts on HPC clusters with time limits. Not sure what to do but ideally it would minimize the chance of misconfiguration: it could allow users to take a regular script without checkpointing and somehow allow the script to be restored from checkpoint without having to worry about correctly setting initial conditions, configuring output writers, etc.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/779
https://github.com/CliMA/Oceananigans.jl/issues/779:106,Deployability,continuous,continuously,106,"When setting up scripts to run on HPC clusters with strict job time limits you need to write scripts that continuously checkpoint and restore from checkpoint and submit the job script again once a wall time limit has been reached. This introduces some complexity into the script, e.g. a `if model.clock.iteration != 0` statement for setting initial conditions and potentially extra data wrangling if an output writer needs to be configured to append to an existing file. It's quite easy to forget to do something important and introduce bugs into these scripts which is undesirable as these jobs tend to run for a long time and we frequently submit many such jobs so the cost of a mistake can be quite high. In the future I think developing some kind of abstraction for setting up this kind of script will be important for people who run scripts on HPC clusters with time limits. Not sure what to do but ideally it would minimize the chance of misconfiguration: it could allow users to take a regular script without checkpointing and somehow allow the script to be restored from checkpoint without having to worry about correctly setting initial conditions, configuring output writers, etc.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/779
https://github.com/CliMA/Oceananigans.jl/issues/779:429,Modifiability,config,configured,429,"When setting up scripts to run on HPC clusters with strict job time limits you need to write scripts that continuously checkpoint and restore from checkpoint and submit the job script again once a wall time limit has been reached. This introduces some complexity into the script, e.g. a `if model.clock.iteration != 0` statement for setting initial conditions and potentially extra data wrangling if an output writer needs to be configured to append to an existing file. It's quite easy to forget to do something important and introduce bugs into these scripts which is undesirable as these jobs tend to run for a long time and we frequently submit many such jobs so the cost of a mistake can be quite high. In the future I think developing some kind of abstraction for setting up this kind of script will be important for people who run scripts on HPC clusters with time limits. Not sure what to do but ideally it would minimize the chance of misconfiguration: it could allow users to take a regular script without checkpointing and somehow allow the script to be restored from checkpoint without having to worry about correctly setting initial conditions, configuring output writers, etc.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/779
https://github.com/CliMA/Oceananigans.jl/issues/779:1158,Modifiability,config,configuring,1158,"When setting up scripts to run on HPC clusters with strict job time limits you need to write scripts that continuously checkpoint and restore from checkpoint and submit the job script again once a wall time limit has been reached. This introduces some complexity into the script, e.g. a `if model.clock.iteration != 0` statement for setting initial conditions and potentially extra data wrangling if an output writer needs to be configured to append to an existing file. It's quite easy to forget to do something important and introduce bugs into these scripts which is undesirable as these jobs tend to run for a long time and we frequently submit many such jobs so the cost of a mistake can be quite high. In the future I think developing some kind of abstraction for setting up this kind of script will be important for people who run scripts on HPC clusters with time limits. Not sure what to do but ideally it would minimize the chance of misconfiguration: it could allow users to take a regular script without checkpointing and somehow allow the script to be restored from checkpoint without having to worry about correctly setting initial conditions, configuring output writers, etc.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/779
https://github.com/CliMA/Oceananigans.jl/pull/782:66,Testability,test,tests,66,"This PR continues #767 by adding documentation of the convergence tests. There is still some todo:. - [x] document forced, free-slip convergence test; - [x] document forced, fixed-slip convergence test",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/782
https://github.com/CliMA/Oceananigans.jl/pull/782:145,Testability,test,test,145,"This PR continues #767 by adding documentation of the convergence tests. There is still some todo:. - [x] document forced, free-slip convergence test; - [x] document forced, fixed-slip convergence test",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/782
https://github.com/CliMA/Oceananigans.jl/pull/782:197,Testability,test,test,197,"This PR continues #767 by adding documentation of the convergence tests. There is still some todo:. - [x] document forced, free-slip convergence test; - [x] document forced, fixed-slip convergence test",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/782
https://github.com/CliMA/Oceananigans.jl/pull/783:116,Availability,checkpoint,checkpointing,116,"This PR adds one main feature and one bug fix. 1) Zonal and Volume Averages have been added to diagnostics; 2) Some checkpointing fixes have been added to allow for more flexible: specifically, CPU to GPU (visa versa is now possible) restarts are now possible and velocity / tracer fields are still checkpointed if they use function boundary conditions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/783
https://github.com/CliMA/Oceananigans.jl/pull/783:299,Availability,checkpoint,checkpointed,299,"This PR adds one main feature and one bug fix. 1) Zonal and Volume Averages have been added to diagnostics; 2) Some checkpointing fixes have been added to allow for more flexible: specifically, CPU to GPU (visa versa is now possible) restarts are now possible and velocity / tracer fields are still checkpointed if they use function boundary conditions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/783
https://github.com/CliMA/Oceananigans.jl/pull/783:170,Modifiability,flexible,flexible,170,"This PR adds one main feature and one bug fix. 1) Zonal and Volume Averages have been added to diagnostics; 2) Some checkpointing fixes have been added to allow for more flexible: specifically, CPU to GPU (visa versa is now possible) restarts are now possible and velocity / tracer fields are still checkpointed if they use function boundary conditions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/783
https://github.com/CliMA/Oceananigans.jl/issues/784:101,Availability,error,errors,101,"There seems to be an issue with running on GPUs with the latest master branch. Specifically one gets errors with launch, which could be due to GPUify loops requiring a specific version of cuda native. See for example,. <img width=""1670"" alt=""Screen Shot 2020-06-20 at 5 23 11 PM"" src=""https://user-images.githubusercontent.com/22668662/86287910-b266b300-bbae-11ea-96a0-7b1e4fa6d250.png"">",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/784
https://github.com/CliMA/Oceananigans.jl/issues/787:30,Availability,error,error,30,"@raphaelouillon reported this error when running `examples/langmuir_turbulence.jl` using julia 1.4.1:. ```julia; [ Info: i: 0100, t: 8.333 min, Δt: 5.000 s, umax = (7.7e-02, 2.4e-02, 2.0e-02) ms⁻¹, wall time: 11.796 s; [ Info: i: 0200, t: 17.500 min, Δt: 5.500 s, umax = (8.3e-02, 2.9e-02, 1.7e-02) ms⁻¹, wall time: 14.838 s; [ Info: i: 0300, t: 27.583 min, Δt: 6.050 s, umax = (8.7e-02, 3.4e-02, 1.6e-02) ms⁻¹, wall time: 17.098 s; [ Info: i: 0400, t: 38.675 min, Δt: 6.655 s, umax = (8.5e-02, 4.2e-02, 2.0e-02) ms⁻¹, wall time: 19.350 s; [ Info: i: 0500, t: 50.876 min, Δt: 7.321 s, umax = (9.9e-02, 4.4e-02, 2.1e-02) ms⁻¹, wall time: 21.588 s; [ Info: i: 0600, t: 1.072 hr, Δt: 8.053 s, umax = (9.1e-02, 5.3e-02, 2.2e-02) ms⁻¹, wall time: 23.869 s; [ Info: i: 0700, t: 1.315 hr, Δt: 8.773 s, umax = (9.5e-02, 5.9e-02, 2.5e-02) ms⁻¹, wall time: 26.116 s; [ Info: i: 0800, t: 1.548 hr, Δt: 8.392 s, umax = (9.3e-02, 6.6e-02, 2.6e-02) ms⁻¹, wall time: 28.362 s; [ Info: i: 0900, t: 1.787 hr, Δt: 8.595 s, umax = (9.6e-02, 6.7e-02, 2.5e-02) ms⁻¹, wall time: 30.612 s; [ Info: i: 1000, t: 2.019 hr, Δt: 8.331 s, umax = (9.4e-02, 6.3e-02, 2.2e-02) ms⁻¹, wall time: 32.931 s; [ Info: i: 1100, t: 2.255 hr, Δt: 8.515 s, umax = (9.6e-02, 6.8e-02, 2.7e-02) ms⁻¹, wall time: 35.212 s; [ Info: i: 1200, t: 2.486 hr, Δt: 8.321 s, umax = (9.5e-02, 7.3e-02, 2.7e-02) ms⁻¹, wall time: 37.449 s; [ Info: i: 1300, t: 2.721 hr, Δt: 8.455 s, umax = (9.3e-02, 7.7e-02, 2.2e-02) ms⁻¹, wall time: 39.705 s; [ Info: i: 1400, t: 2.960 hr, Δt: 8.615 s, umax = (9.1e-02, 8.8e-02, 3.3e-02) ms⁻¹, wall time: 42.052 s; ^P[ Info: i: 1500, t: 3.206 hr, Δt: 8.826 s, umax = (8.9e-02, 9.0e-02, 2.8e-02) ms⁻¹, wall time: 44.425 s; [ Info: i: 1600, t: 3.452 hr, Δt: 8.888 s, umax = (9.2e-02, 8.9e-02, 2.3e-02) ms⁻¹, wall time: 46.877 s; [ Info: i: 1700, t: 3.695 hr, Δt: 8.730 s, umax = (8.6e-02, 9.0e-02, 2.5e-02) ms⁻¹, wall time: 49.291 s; [ Info: i: 1800, t: 3.943 hr, Δt: 8.922 s, umax = (9.2e-02, 9.4e-02, 2.5e-02) ms⁻¹, wall tim",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/787
https://github.com/CliMA/Oceananigans.jl/issues/787:2541,Safety,Abort,Aborted,2541,"ll time: 42.052 s; ^P[ Info: i: 1500, t: 3.206 hr, Δt: 8.826 s, umax = (8.9e-02, 9.0e-02, 2.8e-02) ms⁻¹, wall time: 44.425 s; [ Info: i: 1600, t: 3.452 hr, Δt: 8.888 s, umax = (9.2e-02, 8.9e-02, 2.3e-02) ms⁻¹, wall time: 46.877 s; [ Info: i: 1700, t: 3.695 hr, Δt: 8.730 s, umax = (8.6e-02, 9.0e-02, 2.5e-02) ms⁻¹, wall time: 49.291 s; [ Info: i: 1800, t: 3.943 hr, Δt: 8.922 s, umax = (9.2e-02, 9.4e-02, 2.5e-02) ms⁻¹, wall time: 51.564 s; [ Info: i: 1900, t: 4.180 hr, Δt: 8.548 s, umax = (8.7e-02, 9.4e-02, 2.5e-02) ms⁻¹, wall time: 53.794 s; [ Info: Simulation is stopping. Model time 4.180 hr has hit or exceeded simulation stop time 4.000 hr.; WARNING: using Plots.grid in module Main conflicts with an existing identifier.; [ Info: Making an animation from the saved data...; [ Info: Drawing frame 1 from iteration 0 ; Illegal inttoptr; %33 = ptrtoint double addrspace(13)* %32 to i64; Illegal inttoptr; %52 = inttoptr i64 %51 to i8 addrspace(13)*. signal (6): Aborted; in expression starting at /home/raphael/Documents/Code/Oceananigans.jl/examples/langmuir_turbulence.jl:271; gsignal at /usr/bin/../lib/x86_64-linux-gnu/libc.so.6 (unknown line); abort at /usr/bin/../lib/x86_64-linux-gnu/libc.so.6 (unknown line); unknown function (ip: 0x7f83cc060d04); _ZN4llvm13FPPassManager13runOnFunctionERNS_8FunctionE at /usr/bin/../lib/x86_64-linux-gnu/libLLVM-8.so.1 (unknown line); _ZN4llvm13FPPassManager11runOnModuleERNS_6ModuleE at /usr/bin/../lib/x86_64-linux-gnu/libLLVM-8.so.1 (unknown line); _ZN4llvm6legacy15PassManagerImpl3runERNS_6ModuleE at /usr/bin/../lib/x86_64-linux-gnu/libLLVM-8.so.1 (unknown line); unknown function (ip: 0x7f83cc14aac1); unknown function (ip: 0x7f83cc14d2d8); unknown function (ip: 0x7f83cc14d8cd); unknown function (ip: 0x7f83cc088b4a); unknown function (ip: 0x7f83cc0ba082); unknown function (ip: 0x7f83cc0df84b); jl_apply_generic at /usr/bin/../lib/x86_64-linux-gnu/libjulia.so.1 (unknown line); gr_display at /home/raphael/.julia/packages/Plots/mXrnb/src/backen",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/787
https://github.com/CliMA/Oceananigans.jl/issues/787:2728,Safety,abort,abort,2728," Δt: 8.888 s, umax = (9.2e-02, 8.9e-02, 2.3e-02) ms⁻¹, wall time: 46.877 s; [ Info: i: 1700, t: 3.695 hr, Δt: 8.730 s, umax = (8.6e-02, 9.0e-02, 2.5e-02) ms⁻¹, wall time: 49.291 s; [ Info: i: 1800, t: 3.943 hr, Δt: 8.922 s, umax = (9.2e-02, 9.4e-02, 2.5e-02) ms⁻¹, wall time: 51.564 s; [ Info: i: 1900, t: 4.180 hr, Δt: 8.548 s, umax = (8.7e-02, 9.4e-02, 2.5e-02) ms⁻¹, wall time: 53.794 s; [ Info: Simulation is stopping. Model time 4.180 hr has hit or exceeded simulation stop time 4.000 hr.; WARNING: using Plots.grid in module Main conflicts with an existing identifier.; [ Info: Making an animation from the saved data...; [ Info: Drawing frame 1 from iteration 0 ; Illegal inttoptr; %33 = ptrtoint double addrspace(13)* %32 to i64; Illegal inttoptr; %52 = inttoptr i64 %51 to i8 addrspace(13)*. signal (6): Aborted; in expression starting at /home/raphael/Documents/Code/Oceananigans.jl/examples/langmuir_turbulence.jl:271; gsignal at /usr/bin/../lib/x86_64-linux-gnu/libc.so.6 (unknown line); abort at /usr/bin/../lib/x86_64-linux-gnu/libc.so.6 (unknown line); unknown function (ip: 0x7f83cc060d04); _ZN4llvm13FPPassManager13runOnFunctionERNS_8FunctionE at /usr/bin/../lib/x86_64-linux-gnu/libLLVM-8.so.1 (unknown line); _ZN4llvm13FPPassManager11runOnModuleERNS_6ModuleE at /usr/bin/../lib/x86_64-linux-gnu/libLLVM-8.so.1 (unknown line); _ZN4llvm6legacy15PassManagerImpl3runERNS_6ModuleE at /usr/bin/../lib/x86_64-linux-gnu/libLLVM-8.so.1 (unknown line); unknown function (ip: 0x7f83cc14aac1); unknown function (ip: 0x7f83cc14d2d8); unknown function (ip: 0x7f83cc14d8cd); unknown function (ip: 0x7f83cc088b4a); unknown function (ip: 0x7f83cc0ba082); unknown function (ip: 0x7f83cc0df84b); jl_apply_generic at /usr/bin/../lib/x86_64-linux-gnu/libjulia.so.1 (unknown line); gr_display at /home/raphael/.julia/packages/Plots/mXrnb/src/backends/gr.jl:1616; unknown function (ip: 0x7f838be529a8); gr_display at /home/raphael/.julia/packages/Plots/mXrnb/src/backends/gr.jl:674; _show at /home/raphael",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/787
https://github.com/CliMA/Oceananigans.jl/issues/787:4941,Safety,Abort,Aborted,4941,PPassManager11runOnModuleERNS_6ModuleE at /usr/bin/../lib/x86_64-linux-gnu/libLLVM-8.so.1 (unknown line); _ZN4llvm6legacy15PassManagerImpl3runERNS_6ModuleE at /usr/bin/../lib/x86_64-linux-gnu/libLLVM-8.so.1 (unknown line); unknown function (ip: 0x7f83cc14aac1); unknown function (ip: 0x7f83cc14d2d8); unknown function (ip: 0x7f83cc14d8cd); unknown function (ip: 0x7f83cc088b4a); unknown function (ip: 0x7f83cc0ba082); unknown function (ip: 0x7f83cc0df84b); jl_apply_generic at /usr/bin/../lib/x86_64-linux-gnu/libjulia.so.1 (unknown line); gr_display at /home/raphael/.julia/packages/Plots/mXrnb/src/backends/gr.jl:1616; unknown function (ip: 0x7f838be529a8); gr_display at /home/raphael/.julia/packages/Plots/mXrnb/src/backends/gr.jl:674; _show at /home/raphael/.julia/packages/Plots/mXrnb/src/backends/gr.jl:1957; show at /home/raphael/.julia/packages/Plots/mXrnb/src/output.jl:215 [inlined]; png at /home/raphael/.julia/packages/Plots/mXrnb/src/output.jl:7; frame at /home/raphael/.julia/packages/Plots/mXrnb/src/animation.jl:20; frame at /home/raphael/.julia/packages/Plots/mXrnb/src/animation.jl:18; macro expansion at /home/raphael/.julia/packages/Plots/mXrnb/src/animation.jl:172 [inlined]; macro expansion at /home/raphael/Documents/Code/Oceananigans.jl/examples/langmuir_turbulence.jl:322 [inlined]; top-level scope at /home/raphael/.julia/packages/Plots/mXrnb/src/animation.jl:183; unknown function (ip: 0x7f83cc10d030); unknown function (ip: 0x7f83cc0e8105); jl_load at /usr/bin/../lib/x86_64-linux-gnu/libjulia.so.1 (unknown line); include at ./Base.jl:377; exec_options at ./client.jl:288; _start at ./client.jl:484; jfptr__start_2075.clone_1 at /usr/lib/x86_64-linux-gnu/julia/sys.so (unknown line); unknown function (ip: 0x55bf459799d9); unknown function (ip: 0x55bf459795a6); __libc_start_main at /usr/bin/../lib/x86_64-linux-gnu/libc.so.6 (unknown line); unknown function (ip: 0x55bf4597964d); Allocations: 259469010 (Pool: 259407383; Big: 61627); GC: 547; Aborted (core dumped); ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/787
https://github.com/CliMA/Oceananigans.jl/issues/788:20,Availability,error,error,20,"Hi,; I encounter an error when running `pkg> test Oceananigans` despite being able to run example simulation internal_wave.jl on both CPU and GPU. The description of CUDA error code 201 is also attached below. ```; ERROR: LoadError: CUDA error (code 201, CUDA_ERROR_INVALID_CONTEXT); Stacktrace:; [1] throw_api_error(::CUDAdrv.cudaError_enum) at /home/raphael/.julia/packages/CUDAdrv/Uc14X/src/error.jl:105; [2] macro expansion at /home/raphael/.julia/packages/CUDAdrv/Uc14X/src/error.jl:112 [inlined]; [3] cuCtxGetDevice(::Base.RefValue{Int32}) at /home/raphael/.julia/packages/CUDAapi/XuSHC/src/call.jl:93; [4] device at /home/raphael/.julia/packages/CUDAdrv/Uc14X/src/context.jl:142 [inlined]; [5] device! at /home/raphael/.julia/packages/CUDAnative/ierw8/src/init.jl:198 [inlined]; [6] device!(::CUDAdrv.CuDevice) at /home/raphael/.julia/packages/CUDAnative/ierw8/src/init.jl:188; [7] top-level scope at /home/raphael/.julia/packages/Oceananigans/1xP6n/test/runtests.jl:74; [8] include(::String) at ./client.jl:439; [9] top-level scope at none:6; in expression starting at /home/raphael/.julia/packages/Oceananigans/1xP6n/test/runtests.jl:61; ERROR: Package Oceananigans errored during testing; ```. Has anyone encountered this issue? I am on master 0.30.0. Thanks for your help!; ![Screenshot_2020-07-02 CUDA Driver API CUDA Toolkit Documentation](https://user-images.githubusercontent.com/31293515/86409162-4f484f80-bc86-11ea-8736-bad7a9da5345.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/788
https://github.com/CliMA/Oceananigans.jl/issues/788:171,Availability,error,error,171,"Hi,; I encounter an error when running `pkg> test Oceananigans` despite being able to run example simulation internal_wave.jl on both CPU and GPU. The description of CUDA error code 201 is also attached below. ```; ERROR: LoadError: CUDA error (code 201, CUDA_ERROR_INVALID_CONTEXT); Stacktrace:; [1] throw_api_error(::CUDAdrv.cudaError_enum) at /home/raphael/.julia/packages/CUDAdrv/Uc14X/src/error.jl:105; [2] macro expansion at /home/raphael/.julia/packages/CUDAdrv/Uc14X/src/error.jl:112 [inlined]; [3] cuCtxGetDevice(::Base.RefValue{Int32}) at /home/raphael/.julia/packages/CUDAapi/XuSHC/src/call.jl:93; [4] device at /home/raphael/.julia/packages/CUDAdrv/Uc14X/src/context.jl:142 [inlined]; [5] device! at /home/raphael/.julia/packages/CUDAnative/ierw8/src/init.jl:198 [inlined]; [6] device!(::CUDAdrv.CuDevice) at /home/raphael/.julia/packages/CUDAnative/ierw8/src/init.jl:188; [7] top-level scope at /home/raphael/.julia/packages/Oceananigans/1xP6n/test/runtests.jl:74; [8] include(::String) at ./client.jl:439; [9] top-level scope at none:6; in expression starting at /home/raphael/.julia/packages/Oceananigans/1xP6n/test/runtests.jl:61; ERROR: Package Oceananigans errored during testing; ```. Has anyone encountered this issue? I am on master 0.30.0. Thanks for your help!; ![Screenshot_2020-07-02 CUDA Driver API CUDA Toolkit Documentation](https://user-images.githubusercontent.com/31293515/86409162-4f484f80-bc86-11ea-8736-bad7a9da5345.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/788
https://github.com/CliMA/Oceananigans.jl/issues/788:215,Availability,ERROR,ERROR,215,"Hi,; I encounter an error when running `pkg> test Oceananigans` despite being able to run example simulation internal_wave.jl on both CPU and GPU. The description of CUDA error code 201 is also attached below. ```; ERROR: LoadError: CUDA error (code 201, CUDA_ERROR_INVALID_CONTEXT); Stacktrace:; [1] throw_api_error(::CUDAdrv.cudaError_enum) at /home/raphael/.julia/packages/CUDAdrv/Uc14X/src/error.jl:105; [2] macro expansion at /home/raphael/.julia/packages/CUDAdrv/Uc14X/src/error.jl:112 [inlined]; [3] cuCtxGetDevice(::Base.RefValue{Int32}) at /home/raphael/.julia/packages/CUDAapi/XuSHC/src/call.jl:93; [4] device at /home/raphael/.julia/packages/CUDAdrv/Uc14X/src/context.jl:142 [inlined]; [5] device! at /home/raphael/.julia/packages/CUDAnative/ierw8/src/init.jl:198 [inlined]; [6] device!(::CUDAdrv.CuDevice) at /home/raphael/.julia/packages/CUDAnative/ierw8/src/init.jl:188; [7] top-level scope at /home/raphael/.julia/packages/Oceananigans/1xP6n/test/runtests.jl:74; [8] include(::String) at ./client.jl:439; [9] top-level scope at none:6; in expression starting at /home/raphael/.julia/packages/Oceananigans/1xP6n/test/runtests.jl:61; ERROR: Package Oceananigans errored during testing; ```. Has anyone encountered this issue? I am on master 0.30.0. Thanks for your help!; ![Screenshot_2020-07-02 CUDA Driver API CUDA Toolkit Documentation](https://user-images.githubusercontent.com/31293515/86409162-4f484f80-bc86-11ea-8736-bad7a9da5345.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/788
https://github.com/CliMA/Oceananigans.jl/issues/788:238,Availability,error,error,238,"Hi,; I encounter an error when running `pkg> test Oceananigans` despite being able to run example simulation internal_wave.jl on both CPU and GPU. The description of CUDA error code 201 is also attached below. ```; ERROR: LoadError: CUDA error (code 201, CUDA_ERROR_INVALID_CONTEXT); Stacktrace:; [1] throw_api_error(::CUDAdrv.cudaError_enum) at /home/raphael/.julia/packages/CUDAdrv/Uc14X/src/error.jl:105; [2] macro expansion at /home/raphael/.julia/packages/CUDAdrv/Uc14X/src/error.jl:112 [inlined]; [3] cuCtxGetDevice(::Base.RefValue{Int32}) at /home/raphael/.julia/packages/CUDAapi/XuSHC/src/call.jl:93; [4] device at /home/raphael/.julia/packages/CUDAdrv/Uc14X/src/context.jl:142 [inlined]; [5] device! at /home/raphael/.julia/packages/CUDAnative/ierw8/src/init.jl:198 [inlined]; [6] device!(::CUDAdrv.CuDevice) at /home/raphael/.julia/packages/CUDAnative/ierw8/src/init.jl:188; [7] top-level scope at /home/raphael/.julia/packages/Oceananigans/1xP6n/test/runtests.jl:74; [8] include(::String) at ./client.jl:439; [9] top-level scope at none:6; in expression starting at /home/raphael/.julia/packages/Oceananigans/1xP6n/test/runtests.jl:61; ERROR: Package Oceananigans errored during testing; ```. Has anyone encountered this issue? I am on master 0.30.0. Thanks for your help!; ![Screenshot_2020-07-02 CUDA Driver API CUDA Toolkit Documentation](https://user-images.githubusercontent.com/31293515/86409162-4f484f80-bc86-11ea-8736-bad7a9da5345.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/788
https://github.com/CliMA/Oceananigans.jl/issues/788:394,Availability,error,error,394,"Hi,; I encounter an error when running `pkg> test Oceananigans` despite being able to run example simulation internal_wave.jl on both CPU and GPU. The description of CUDA error code 201 is also attached below. ```; ERROR: LoadError: CUDA error (code 201, CUDA_ERROR_INVALID_CONTEXT); Stacktrace:; [1] throw_api_error(::CUDAdrv.cudaError_enum) at /home/raphael/.julia/packages/CUDAdrv/Uc14X/src/error.jl:105; [2] macro expansion at /home/raphael/.julia/packages/CUDAdrv/Uc14X/src/error.jl:112 [inlined]; [3] cuCtxGetDevice(::Base.RefValue{Int32}) at /home/raphael/.julia/packages/CUDAapi/XuSHC/src/call.jl:93; [4] device at /home/raphael/.julia/packages/CUDAdrv/Uc14X/src/context.jl:142 [inlined]; [5] device! at /home/raphael/.julia/packages/CUDAnative/ierw8/src/init.jl:198 [inlined]; [6] device!(::CUDAdrv.CuDevice) at /home/raphael/.julia/packages/CUDAnative/ierw8/src/init.jl:188; [7] top-level scope at /home/raphael/.julia/packages/Oceananigans/1xP6n/test/runtests.jl:74; [8] include(::String) at ./client.jl:439; [9] top-level scope at none:6; in expression starting at /home/raphael/.julia/packages/Oceananigans/1xP6n/test/runtests.jl:61; ERROR: Package Oceananigans errored during testing; ```. Has anyone encountered this issue? I am on master 0.30.0. Thanks for your help!; ![Screenshot_2020-07-02 CUDA Driver API CUDA Toolkit Documentation](https://user-images.githubusercontent.com/31293515/86409162-4f484f80-bc86-11ea-8736-bad7a9da5345.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/788
https://github.com/CliMA/Oceananigans.jl/issues/788:479,Availability,error,error,479,"Hi,; I encounter an error when running `pkg> test Oceananigans` despite being able to run example simulation internal_wave.jl on both CPU and GPU. The description of CUDA error code 201 is also attached below. ```; ERROR: LoadError: CUDA error (code 201, CUDA_ERROR_INVALID_CONTEXT); Stacktrace:; [1] throw_api_error(::CUDAdrv.cudaError_enum) at /home/raphael/.julia/packages/CUDAdrv/Uc14X/src/error.jl:105; [2] macro expansion at /home/raphael/.julia/packages/CUDAdrv/Uc14X/src/error.jl:112 [inlined]; [3] cuCtxGetDevice(::Base.RefValue{Int32}) at /home/raphael/.julia/packages/CUDAapi/XuSHC/src/call.jl:93; [4] device at /home/raphael/.julia/packages/CUDAdrv/Uc14X/src/context.jl:142 [inlined]; [5] device! at /home/raphael/.julia/packages/CUDAnative/ierw8/src/init.jl:198 [inlined]; [6] device!(::CUDAdrv.CuDevice) at /home/raphael/.julia/packages/CUDAnative/ierw8/src/init.jl:188; [7] top-level scope at /home/raphael/.julia/packages/Oceananigans/1xP6n/test/runtests.jl:74; [8] include(::String) at ./client.jl:439; [9] top-level scope at none:6; in expression starting at /home/raphael/.julia/packages/Oceananigans/1xP6n/test/runtests.jl:61; ERROR: Package Oceananigans errored during testing; ```. Has anyone encountered this issue? I am on master 0.30.0. Thanks for your help!; ![Screenshot_2020-07-02 CUDA Driver API CUDA Toolkit Documentation](https://user-images.githubusercontent.com/31293515/86409162-4f484f80-bc86-11ea-8736-bad7a9da5345.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/788
https://github.com/CliMA/Oceananigans.jl/issues/788:1147,Availability,ERROR,ERROR,1147,"Hi,; I encounter an error when running `pkg> test Oceananigans` despite being able to run example simulation internal_wave.jl on both CPU and GPU. The description of CUDA error code 201 is also attached below. ```; ERROR: LoadError: CUDA error (code 201, CUDA_ERROR_INVALID_CONTEXT); Stacktrace:; [1] throw_api_error(::CUDAdrv.cudaError_enum) at /home/raphael/.julia/packages/CUDAdrv/Uc14X/src/error.jl:105; [2] macro expansion at /home/raphael/.julia/packages/CUDAdrv/Uc14X/src/error.jl:112 [inlined]; [3] cuCtxGetDevice(::Base.RefValue{Int32}) at /home/raphael/.julia/packages/CUDAapi/XuSHC/src/call.jl:93; [4] device at /home/raphael/.julia/packages/CUDAdrv/Uc14X/src/context.jl:142 [inlined]; [5] device! at /home/raphael/.julia/packages/CUDAnative/ierw8/src/init.jl:198 [inlined]; [6] device!(::CUDAdrv.CuDevice) at /home/raphael/.julia/packages/CUDAnative/ierw8/src/init.jl:188; [7] top-level scope at /home/raphael/.julia/packages/Oceananigans/1xP6n/test/runtests.jl:74; [8] include(::String) at ./client.jl:439; [9] top-level scope at none:6; in expression starting at /home/raphael/.julia/packages/Oceananigans/1xP6n/test/runtests.jl:61; ERROR: Package Oceananigans errored during testing; ```. Has anyone encountered this issue? I am on master 0.30.0. Thanks for your help!; ![Screenshot_2020-07-02 CUDA Driver API CUDA Toolkit Documentation](https://user-images.githubusercontent.com/31293515/86409162-4f484f80-bc86-11ea-8736-bad7a9da5345.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/788
https://github.com/CliMA/Oceananigans.jl/issues/788:1175,Availability,error,errored,1175,"Hi,; I encounter an error when running `pkg> test Oceananigans` despite being able to run example simulation internal_wave.jl on both CPU and GPU. The description of CUDA error code 201 is also attached below. ```; ERROR: LoadError: CUDA error (code 201, CUDA_ERROR_INVALID_CONTEXT); Stacktrace:; [1] throw_api_error(::CUDAdrv.cudaError_enum) at /home/raphael/.julia/packages/CUDAdrv/Uc14X/src/error.jl:105; [2] macro expansion at /home/raphael/.julia/packages/CUDAdrv/Uc14X/src/error.jl:112 [inlined]; [3] cuCtxGetDevice(::Base.RefValue{Int32}) at /home/raphael/.julia/packages/CUDAapi/XuSHC/src/call.jl:93; [4] device at /home/raphael/.julia/packages/CUDAdrv/Uc14X/src/context.jl:142 [inlined]; [5] device! at /home/raphael/.julia/packages/CUDAnative/ierw8/src/init.jl:198 [inlined]; [6] device!(::CUDAdrv.CuDevice) at /home/raphael/.julia/packages/CUDAnative/ierw8/src/init.jl:188; [7] top-level scope at /home/raphael/.julia/packages/Oceananigans/1xP6n/test/runtests.jl:74; [8] include(::String) at ./client.jl:439; [9] top-level scope at none:6; in expression starting at /home/raphael/.julia/packages/Oceananigans/1xP6n/test/runtests.jl:61; ERROR: Package Oceananigans errored during testing; ```. Has anyone encountered this issue? I am on master 0.30.0. Thanks for your help!; ![Screenshot_2020-07-02 CUDA Driver API CUDA Toolkit Documentation](https://user-images.githubusercontent.com/31293515/86409162-4f484f80-bc86-11ea-8736-bad7a9da5345.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/788
https://github.com/CliMA/Oceananigans.jl/issues/788:222,Performance,Load,LoadError,222,"Hi,; I encounter an error when running `pkg> test Oceananigans` despite being able to run example simulation internal_wave.jl on both CPU and GPU. The description of CUDA error code 201 is also attached below. ```; ERROR: LoadError: CUDA error (code 201, CUDA_ERROR_INVALID_CONTEXT); Stacktrace:; [1] throw_api_error(::CUDAdrv.cudaError_enum) at /home/raphael/.julia/packages/CUDAdrv/Uc14X/src/error.jl:105; [2] macro expansion at /home/raphael/.julia/packages/CUDAdrv/Uc14X/src/error.jl:112 [inlined]; [3] cuCtxGetDevice(::Base.RefValue{Int32}) at /home/raphael/.julia/packages/CUDAapi/XuSHC/src/call.jl:93; [4] device at /home/raphael/.julia/packages/CUDAdrv/Uc14X/src/context.jl:142 [inlined]; [5] device! at /home/raphael/.julia/packages/CUDAnative/ierw8/src/init.jl:198 [inlined]; [6] device!(::CUDAdrv.CuDevice) at /home/raphael/.julia/packages/CUDAnative/ierw8/src/init.jl:188; [7] top-level scope at /home/raphael/.julia/packages/Oceananigans/1xP6n/test/runtests.jl:74; [8] include(::String) at ./client.jl:439; [9] top-level scope at none:6; in expression starting at /home/raphael/.julia/packages/Oceananigans/1xP6n/test/runtests.jl:61; ERROR: Package Oceananigans errored during testing; ```. Has anyone encountered this issue? I am on master 0.30.0. Thanks for your help!; ![Screenshot_2020-07-02 CUDA Driver API CUDA Toolkit Documentation](https://user-images.githubusercontent.com/31293515/86409162-4f484f80-bc86-11ea-8736-bad7a9da5345.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/788
https://github.com/CliMA/Oceananigans.jl/issues/788:45,Testability,test,test,45,"Hi,; I encounter an error when running `pkg> test Oceananigans` despite being able to run example simulation internal_wave.jl on both CPU and GPU. The description of CUDA error code 201 is also attached below. ```; ERROR: LoadError: CUDA error (code 201, CUDA_ERROR_INVALID_CONTEXT); Stacktrace:; [1] throw_api_error(::CUDAdrv.cudaError_enum) at /home/raphael/.julia/packages/CUDAdrv/Uc14X/src/error.jl:105; [2] macro expansion at /home/raphael/.julia/packages/CUDAdrv/Uc14X/src/error.jl:112 [inlined]; [3] cuCtxGetDevice(::Base.RefValue{Int32}) at /home/raphael/.julia/packages/CUDAapi/XuSHC/src/call.jl:93; [4] device at /home/raphael/.julia/packages/CUDAdrv/Uc14X/src/context.jl:142 [inlined]; [5] device! at /home/raphael/.julia/packages/CUDAnative/ierw8/src/init.jl:198 [inlined]; [6] device!(::CUDAdrv.CuDevice) at /home/raphael/.julia/packages/CUDAnative/ierw8/src/init.jl:188; [7] top-level scope at /home/raphael/.julia/packages/Oceananigans/1xP6n/test/runtests.jl:74; [8] include(::String) at ./client.jl:439; [9] top-level scope at none:6; in expression starting at /home/raphael/.julia/packages/Oceananigans/1xP6n/test/runtests.jl:61; ERROR: Package Oceananigans errored during testing; ```. Has anyone encountered this issue? I am on master 0.30.0. Thanks for your help!; ![Screenshot_2020-07-02 CUDA Driver API CUDA Toolkit Documentation](https://user-images.githubusercontent.com/31293515/86409162-4f484f80-bc86-11ea-8736-bad7a9da5345.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/788
https://github.com/CliMA/Oceananigans.jl/issues/788:957,Testability,test,test,957,"Hi,; I encounter an error when running `pkg> test Oceananigans` despite being able to run example simulation internal_wave.jl on both CPU and GPU. The description of CUDA error code 201 is also attached below. ```; ERROR: LoadError: CUDA error (code 201, CUDA_ERROR_INVALID_CONTEXT); Stacktrace:; [1] throw_api_error(::CUDAdrv.cudaError_enum) at /home/raphael/.julia/packages/CUDAdrv/Uc14X/src/error.jl:105; [2] macro expansion at /home/raphael/.julia/packages/CUDAdrv/Uc14X/src/error.jl:112 [inlined]; [3] cuCtxGetDevice(::Base.RefValue{Int32}) at /home/raphael/.julia/packages/CUDAapi/XuSHC/src/call.jl:93; [4] device at /home/raphael/.julia/packages/CUDAdrv/Uc14X/src/context.jl:142 [inlined]; [5] device! at /home/raphael/.julia/packages/CUDAnative/ierw8/src/init.jl:198 [inlined]; [6] device!(::CUDAdrv.CuDevice) at /home/raphael/.julia/packages/CUDAnative/ierw8/src/init.jl:188; [7] top-level scope at /home/raphael/.julia/packages/Oceananigans/1xP6n/test/runtests.jl:74; [8] include(::String) at ./client.jl:439; [9] top-level scope at none:6; in expression starting at /home/raphael/.julia/packages/Oceananigans/1xP6n/test/runtests.jl:61; ERROR: Package Oceananigans errored during testing; ```. Has anyone encountered this issue? I am on master 0.30.0. Thanks for your help!; ![Screenshot_2020-07-02 CUDA Driver API CUDA Toolkit Documentation](https://user-images.githubusercontent.com/31293515/86409162-4f484f80-bc86-11ea-8736-bad7a9da5345.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/788
https://github.com/CliMA/Oceananigans.jl/issues/788:1126,Testability,test,test,1126,"Hi,; I encounter an error when running `pkg> test Oceananigans` despite being able to run example simulation internal_wave.jl on both CPU and GPU. The description of CUDA error code 201 is also attached below. ```; ERROR: LoadError: CUDA error (code 201, CUDA_ERROR_INVALID_CONTEXT); Stacktrace:; [1] throw_api_error(::CUDAdrv.cudaError_enum) at /home/raphael/.julia/packages/CUDAdrv/Uc14X/src/error.jl:105; [2] macro expansion at /home/raphael/.julia/packages/CUDAdrv/Uc14X/src/error.jl:112 [inlined]; [3] cuCtxGetDevice(::Base.RefValue{Int32}) at /home/raphael/.julia/packages/CUDAapi/XuSHC/src/call.jl:93; [4] device at /home/raphael/.julia/packages/CUDAdrv/Uc14X/src/context.jl:142 [inlined]; [5] device! at /home/raphael/.julia/packages/CUDAnative/ierw8/src/init.jl:198 [inlined]; [6] device!(::CUDAdrv.CuDevice) at /home/raphael/.julia/packages/CUDAnative/ierw8/src/init.jl:188; [7] top-level scope at /home/raphael/.julia/packages/Oceananigans/1xP6n/test/runtests.jl:74; [8] include(::String) at ./client.jl:439; [9] top-level scope at none:6; in expression starting at /home/raphael/.julia/packages/Oceananigans/1xP6n/test/runtests.jl:61; ERROR: Package Oceananigans errored during testing; ```. Has anyone encountered this issue? I am on master 0.30.0. Thanks for your help!; ![Screenshot_2020-07-02 CUDA Driver API CUDA Toolkit Documentation](https://user-images.githubusercontent.com/31293515/86409162-4f484f80-bc86-11ea-8736-bad7a9da5345.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/788
https://github.com/CliMA/Oceananigans.jl/issues/788:1190,Testability,test,testing,1190,"Hi,; I encounter an error when running `pkg> test Oceananigans` despite being able to run example simulation internal_wave.jl on both CPU and GPU. The description of CUDA error code 201 is also attached below. ```; ERROR: LoadError: CUDA error (code 201, CUDA_ERROR_INVALID_CONTEXT); Stacktrace:; [1] throw_api_error(::CUDAdrv.cudaError_enum) at /home/raphael/.julia/packages/CUDAdrv/Uc14X/src/error.jl:105; [2] macro expansion at /home/raphael/.julia/packages/CUDAdrv/Uc14X/src/error.jl:112 [inlined]; [3] cuCtxGetDevice(::Base.RefValue{Int32}) at /home/raphael/.julia/packages/CUDAapi/XuSHC/src/call.jl:93; [4] device at /home/raphael/.julia/packages/CUDAdrv/Uc14X/src/context.jl:142 [inlined]; [5] device! at /home/raphael/.julia/packages/CUDAnative/ierw8/src/init.jl:198 [inlined]; [6] device!(::CUDAdrv.CuDevice) at /home/raphael/.julia/packages/CUDAnative/ierw8/src/init.jl:188; [7] top-level scope at /home/raphael/.julia/packages/Oceananigans/1xP6n/test/runtests.jl:74; [8] include(::String) at ./client.jl:439; [9] top-level scope at none:6; in expression starting at /home/raphael/.julia/packages/Oceananigans/1xP6n/test/runtests.jl:61; ERROR: Package Oceananigans errored during testing; ```. Has anyone encountered this issue? I am on master 0.30.0. Thanks for your help!; ![Screenshot_2020-07-02 CUDA Driver API CUDA Toolkit Documentation](https://user-images.githubusercontent.com/31293515/86409162-4f484f80-bc86-11ea-8736-bad7a9da5345.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/788
https://github.com/CliMA/Oceananigans.jl/issues/789:675,Availability,error,error,675,"Hi all, I am trying to setup a DNS in a triply bounded domain with inflow conditions on the west wall. All boundary conditions are as default except for the bottom boundary (no-slip), west wall (inflow) and right wall (outflow). I tried setting up the boundaries as; ```; ubcs = UVelocityBoundaryConditions(grid, bottom = BoundaryCondition(Value, 0), west = BoundaryCondition(Value,0.1), east = BoundaryCondition(Gradient,0)); vbcs = VVelocityBoundaryConditions(grid, bottom = BoundaryCondition(Value, 0)); bbcs = TracerBoundaryConditions(grid, west = BoundaryCondition(Value,0)); ```; The tracer boundary condition is fixed to 0 on the west wall. I am getting the following error when running the simulation:. ERROR: LoadError: MethodError: no method matching fill_west_halo!(::OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, ::BoundaryCondition{Value,Float64}, ::CPU, ::RegularCartesianGrid{Float64,Bounded,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,3,Base.ReshapedArray{Float64,3,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}},Tuple{}}}}, ::Clock{Float64}, ::NamedTuple{(:velocities, :tracers, :diffusivities),Tuple{NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}}},NamedTuple{(:b,),Tuple{OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}}},Nothing}}). I now wonder if it is currently possible to have inflow conditions with buoyancy, or if this is a boundary condition that is not implemented. Are inflow conditions incompatible with buoyancy or is the error unrelated? Thanks very much for your help! Entire script below:. ```; # # Lock-release gravity current example. using Oceananigans, Oceananigans.Grids, Printf, SpecialFunctions, Plots. # ## Physical and numerical parameters; #; # First, we pick a resolution and domain size,. Nx = 256; Ny = 256 # x resolution; Nz = 32 # z resolution; Lx = 10; Ly = ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/789
https://github.com/CliMA/Oceananigans.jl/issues/789:711,Availability,ERROR,ERROR,711,"Hi all, I am trying to setup a DNS in a triply bounded domain with inflow conditions on the west wall. All boundary conditions are as default except for the bottom boundary (no-slip), west wall (inflow) and right wall (outflow). I tried setting up the boundaries as; ```; ubcs = UVelocityBoundaryConditions(grid, bottom = BoundaryCondition(Value, 0), west = BoundaryCondition(Value,0.1), east = BoundaryCondition(Gradient,0)); vbcs = VVelocityBoundaryConditions(grid, bottom = BoundaryCondition(Value, 0)); bbcs = TracerBoundaryConditions(grid, west = BoundaryCondition(Value,0)); ```; The tracer boundary condition is fixed to 0 on the west wall. I am getting the following error when running the simulation:. ERROR: LoadError: MethodError: no method matching fill_west_halo!(::OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, ::BoundaryCondition{Value,Float64}, ::CPU, ::RegularCartesianGrid{Float64,Bounded,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,3,Base.ReshapedArray{Float64,3,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}},Tuple{}}}}, ::Clock{Float64}, ::NamedTuple{(:velocities, :tracers, :diffusivities),Tuple{NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}}},NamedTuple{(:b,),Tuple{OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}}},Nothing}}). I now wonder if it is currently possible to have inflow conditions with buoyancy, or if this is a boundary condition that is not implemented. Are inflow conditions incompatible with buoyancy or is the error unrelated? Thanks very much for your help! Entire script below:. ```; # # Lock-release gravity current example. using Oceananigans, Oceananigans.Grids, Printf, SpecialFunctions, Plots. # ## Physical and numerical parameters; #; # First, we pick a resolution and domain size,. Nx = 256; Ny = 256 # x resolution; Nz = 32 # z resolution; Lx = 10; Ly = ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/789
https://github.com/CliMA/Oceananigans.jl/issues/789:1646,Availability,error,error,1646,"m getting the following error when running the simulation:. ERROR: LoadError: MethodError: no method matching fill_west_halo!(::OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, ::BoundaryCondition{Value,Float64}, ::CPU, ::RegularCartesianGrid{Float64,Bounded,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,3,Base.ReshapedArray{Float64,3,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}},Tuple{}}}}, ::Clock{Float64}, ::NamedTuple{(:velocities, :tracers, :diffusivities),Tuple{NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}}},NamedTuple{(:b,),Tuple{OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}}},Nothing}}). I now wonder if it is currently possible to have inflow conditions with buoyancy, or if this is a boundary condition that is not implemented. Are inflow conditions incompatible with buoyancy or is the error unrelated? Thanks very much for your help! Entire script below:. ```; # # Lock-release gravity current example. using Oceananigans, Oceananigans.Grids, Printf, SpecialFunctions, Plots. # ## Physical and numerical parameters; #; # First, we pick a resolution and domain size,. Nx = 256; Ny = 256 # x resolution; Nz = 32 # z resolution; Lx = 10; Ly = 12 # domain extent; Lz = 1 # vertical domain extent; #y₀ = 2 # Initial source position; #δᴸ = 0.1 # thickness of lock transition. Re = 2000; Pe = Re; iRe = 1/Re; iPe = 1/Pe; nothing # hide. # ## Build the grid; #; # We use a domain that is bounded in y (north and south) and z (top and bottom),; # and periodic in x.; #; topology = (Bounded, Bounded, Bounded). grid = RegularCartesianGrid(size=(Nx, Ny, Nz), extent=(Lx, Ly, Lz), topology=topology). # No-slip bottom, free-slip top and side walls through default boundary conditions; ubcs = UVelocityBoundaryConditions(grid, bottom = BoundaryCondition(Value, 0), west = BoundaryCondition(Value,0.1), e",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/789
https://github.com/CliMA/Oceananigans.jl/issues/789:1731,Deployability,release,release,1731,"r: no method matching fill_west_halo!(::OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, ::BoundaryCondition{Value,Float64}, ::CPU, ::RegularCartesianGrid{Float64,Bounded,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,3,Base.ReshapedArray{Float64,3,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}},Tuple{}}}}, ::Clock{Float64}, ::NamedTuple{(:velocities, :tracers, :diffusivities),Tuple{NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}}},NamedTuple{(:b,),Tuple{OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}}},Nothing}}). I now wonder if it is currently possible to have inflow conditions with buoyancy, or if this is a boundary condition that is not implemented. Are inflow conditions incompatible with buoyancy or is the error unrelated? Thanks very much for your help! Entire script below:. ```; # # Lock-release gravity current example. using Oceananigans, Oceananigans.Grids, Printf, SpecialFunctions, Plots. # ## Physical and numerical parameters; #; # First, we pick a resolution and domain size,. Nx = 256; Ny = 256 # x resolution; Nz = 32 # z resolution; Lx = 10; Ly = 12 # domain extent; Lz = 1 # vertical domain extent; #y₀ = 2 # Initial source position; #δᴸ = 0.1 # thickness of lock transition. Re = 2000; Pe = Re; iRe = 1/Re; iPe = 1/Pe; nothing # hide. # ## Build the grid; #; # We use a domain that is bounded in y (north and south) and z (top and bottom),; # and periodic in x.; #; topology = (Bounded, Bounded, Bounded). grid = RegularCartesianGrid(size=(Nx, Ny, Nz), extent=(Lx, Ly, Lz), topology=topology). # No-slip bottom, free-slip top and side walls through default boundary conditions; ubcs = UVelocityBoundaryConditions(grid, bottom = BoundaryCondition(Value, 0), west = BoundaryCondition(Value,0.1), east = BoundaryCondition(Gradient,0.0)); vbcs = VVelocityBoundaryConditions(grid, bottom =",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/789
https://github.com/CliMA/Oceananigans.jl/issues/789:4163,Integrability,message,message,4163,"dist_to_source(x,y,z,t,p.a,p.y₀)-p.R)/p.δᴸ)). b_forcing = SimpleForcing(fun_forcing, parameters=(a=0.5,y₀=2,R=0.5,δᴸ=0.1)). #parameterized_forcing(x, y, z, t, p) = p.μ * exp(z/p.λ) * cos(p.ω*t); #v_forcing = SimpleForcing(parameterized_forcing, parameters=(μ=42, λ=0.1, ω=π)); forcing = ModelForcing(b=b_forcing). model = IncompressibleModel(; grid = grid,; architecture = CPU(),; boundary_conditions = (u=ubcs, v=vbcs, b=bbcs),; closure = ConstantIsotropicDiffusivity(ν=iRe, κ=iPe),; tracers = :b,; buoyancy = BuoyancyTracer(),; forcing = forcing; ). # Set initial condition; b₀(x, y, z) = 0.0#-0.5 * (1 - erf((y - yᴸ) / δᴸ)). set!(model, b=b₀); nothing # hide. ### Progress diagnostic function; using Oceananigans.Diagnostics, Printf. umax = FieldMaximum(abs, model.velocities.u); vmax = FieldMaximum(abs, model.velocities.v); wmax = FieldMaximum(abs, model.velocities.w). wall_clock = time_ns(). function print_progress(simulation); model = simulation.model. # Print a progress message; msg = @sprintf(""i: %04d, t: %s, Δt: %s, umax = (%.1e, %.1e, %.1e) ms⁻¹, wall time: %s\n"",; model.clock.iteration,; prettytime(model.clock.time),; prettytime(wizard.Δt),; umax(), vmax(), wmax(),; prettytime(1e-9 * (time_ns() - wall_clock)); ). @info msg. return nothing; end. # Time step wizard based on CFL condition for AB (CFL<=0.3); wizard = TimeStepWizard(cfl=0.3, Δt=0.01, max_change=1.2, max_Δt=0.1). nothing # hide. simulation = Simulation(model,progress_frequency = 100, Δt = wizard,stop_time = 20,progress = print_progress). nothing # hide. # Output; #; # We set up an output writer for the simulation that saves all velocity fields,; # tracer fields, and the subgrid turbulent diffusivity every 2 minutes. using Oceananigans.OutputWriters. field_outputs = FieldOutputs(merge(model.velocities, model.tracers)). simulation.output_writers[:fields] = JLD2OutputWriter(model, field_outputs,; interval = 0.1,; prefix = ""continuous_release_3D_background_current"",; force = true). nothing # hide. run!(simulat",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/789
https://github.com/CliMA/Oceananigans.jl/issues/789:718,Performance,Load,LoadError,718,"Hi all, I am trying to setup a DNS in a triply bounded domain with inflow conditions on the west wall. All boundary conditions are as default except for the bottom boundary (no-slip), west wall (inflow) and right wall (outflow). I tried setting up the boundaries as; ```; ubcs = UVelocityBoundaryConditions(grid, bottom = BoundaryCondition(Value, 0), west = BoundaryCondition(Value,0.1), east = BoundaryCondition(Gradient,0)); vbcs = VVelocityBoundaryConditions(grid, bottom = BoundaryCondition(Value, 0)); bbcs = TracerBoundaryConditions(grid, west = BoundaryCondition(Value,0)); ```; The tracer boundary condition is fixed to 0 on the west wall. I am getting the following error when running the simulation:. ERROR: LoadError: MethodError: no method matching fill_west_halo!(::OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, ::BoundaryCondition{Value,Float64}, ::CPU, ::RegularCartesianGrid{Float64,Bounded,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,3,Base.ReshapedArray{Float64,3,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}},Tuple{}}}}, ::Clock{Float64}, ::NamedTuple{(:velocities, :tracers, :diffusivities),Tuple{NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}}},NamedTuple{(:b,),Tuple{OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}}},Nothing}}). I now wonder if it is currently possible to have inflow conditions with buoyancy, or if this is a boundary condition that is not implemented. Are inflow conditions incompatible with buoyancy or is the error unrelated? Thanks very much for your help! Entire script below:. ```; # # Lock-release gravity current example. using Oceananigans, Oceananigans.Grids, Printf, SpecialFunctions, Plots. # ## Physical and numerical parameters; #; # First, we pick a resolution and domain size,. Nx = 256; Ny = 256 # x resolution; Nz = 32 # z resolution; Lx = 10; Ly = ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/789
https://github.com/CliMA/Oceananigans.jl/issues/789:3240,Usability,Simpl,SimpleForcing,3240,"north and south) and z (top and bottom),; # and periodic in x.; #; topology = (Bounded, Bounded, Bounded). grid = RegularCartesianGrid(size=(Nx, Ny, Nz), extent=(Lx, Ly, Lz), topology=topology). # No-slip bottom, free-slip top and side walls through default boundary conditions; ubcs = UVelocityBoundaryConditions(grid, bottom = BoundaryCondition(Value, 0), west = BoundaryCondition(Value,0.1), east = BoundaryCondition(Gradient,0.0)); vbcs = VVelocityBoundaryConditions(grid, bottom = BoundaryCondition(Value, 0)); bbcs = TracerBoundaryConditions(grid, west = BoundaryCondition(Value,0.0)); nothing # hide. # ## Model instantiation and initial condition; #; # We use a constant viscosity and diffusivity.; # Set forcing; #fun_forcing(x, y, z, t) = (0.5*(1-erf(abs(sqrt((x-xc)^2+(y-yc)^2+(z-zc)^2)-R)))); fun_dist_to_source(x,y,z,t,a,y₀) = sqrt((x-Lx/2)^2+(y-y₀-a*t)^2+(z+Lz/2)^2); fun_forcing(x, y, z, t,p) = -0.5*(1-erf((fun_dist_to_source(x,y,z,t,p.a,p.y₀)-p.R)/p.δᴸ)). b_forcing = SimpleForcing(fun_forcing, parameters=(a=0.5,y₀=2,R=0.5,δᴸ=0.1)). #parameterized_forcing(x, y, z, t, p) = p.μ * exp(z/p.λ) * cos(p.ω*t); #v_forcing = SimpleForcing(parameterized_forcing, parameters=(μ=42, λ=0.1, ω=π)); forcing = ModelForcing(b=b_forcing). model = IncompressibleModel(; grid = grid,; architecture = CPU(),; boundary_conditions = (u=ubcs, v=vbcs, b=bbcs),; closure = ConstantIsotropicDiffusivity(ν=iRe, κ=iPe),; tracers = :b,; buoyancy = BuoyancyTracer(),; forcing = forcing; ). # Set initial condition; b₀(x, y, z) = 0.0#-0.5 * (1 - erf((y - yᴸ) / δᴸ)). set!(model, b=b₀); nothing # hide. ### Progress diagnostic function; using Oceananigans.Diagnostics, Printf. umax = FieldMaximum(abs, model.velocities.u); vmax = FieldMaximum(abs, model.velocities.v); wmax = FieldMaximum(abs, model.velocities.w). wall_clock = time_ns(). function print_progress(simulation); model = simulation.model. # Print a progress message; msg = @sprintf(""i: %04d, t: %s, Δt: %s, umax = (%.1e, %.1e, %.1e) ms⁻¹, wall time: ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/789
https://github.com/CliMA/Oceananigans.jl/issues/789:3390,Usability,Simpl,SimpleForcing,3390,"xtent=(Lx, Ly, Lz), topology=topology). # No-slip bottom, free-slip top and side walls through default boundary conditions; ubcs = UVelocityBoundaryConditions(grid, bottom = BoundaryCondition(Value, 0), west = BoundaryCondition(Value,0.1), east = BoundaryCondition(Gradient,0.0)); vbcs = VVelocityBoundaryConditions(grid, bottom = BoundaryCondition(Value, 0)); bbcs = TracerBoundaryConditions(grid, west = BoundaryCondition(Value,0.0)); nothing # hide. # ## Model instantiation and initial condition; #; # We use a constant viscosity and diffusivity.; # Set forcing; #fun_forcing(x, y, z, t) = (0.5*(1-erf(abs(sqrt((x-xc)^2+(y-yc)^2+(z-zc)^2)-R)))); fun_dist_to_source(x,y,z,t,a,y₀) = sqrt((x-Lx/2)^2+(y-y₀-a*t)^2+(z+Lz/2)^2); fun_forcing(x, y, z, t,p) = -0.5*(1-erf((fun_dist_to_source(x,y,z,t,p.a,p.y₀)-p.R)/p.δᴸ)). b_forcing = SimpleForcing(fun_forcing, parameters=(a=0.5,y₀=2,R=0.5,δᴸ=0.1)). #parameterized_forcing(x, y, z, t, p) = p.μ * exp(z/p.λ) * cos(p.ω*t); #v_forcing = SimpleForcing(parameterized_forcing, parameters=(μ=42, λ=0.1, ω=π)); forcing = ModelForcing(b=b_forcing). model = IncompressibleModel(; grid = grid,; architecture = CPU(),; boundary_conditions = (u=ubcs, v=vbcs, b=bbcs),; closure = ConstantIsotropicDiffusivity(ν=iRe, κ=iPe),; tracers = :b,; buoyancy = BuoyancyTracer(),; forcing = forcing; ). # Set initial condition; b₀(x, y, z) = 0.0#-0.5 * (1 - erf((y - yᴸ) / δᴸ)). set!(model, b=b₀); nothing # hide. ### Progress diagnostic function; using Oceananigans.Diagnostics, Printf. umax = FieldMaximum(abs, model.velocities.u); vmax = FieldMaximum(abs, model.velocities.v); wmax = FieldMaximum(abs, model.velocities.w). wall_clock = time_ns(). function print_progress(simulation); model = simulation.model. # Print a progress message; msg = @sprintf(""i: %04d, t: %s, Δt: %s, umax = (%.1e, %.1e, %.1e) ms⁻¹, wall time: %s\n"",; model.clock.iteration,; prettytime(model.clock.time),; prettytime(wizard.Δt),; umax(), vmax(), wmax(),; prettytime(1e-9 * (time_ns() - wall_clock))",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/789
https://github.com/CliMA/Oceananigans.jl/pull/794:227,Modifiability,plugin,plugin,227,"This PR **finally** adds proper citations that link to a references page all generated from an `oceananigans.bib` file. This is now possible thanks to the new Bibliography.jl package which I've used to hack in a Documenter.jl ""plugin"" at https://github.com/ali-ramadhan/DocumenterBibliographyTest.jl. This is currently the last action item for the JOSS submission. The code that handles citations and bibliography expansion is a little messy and will hopefully evolve into a proper Documenter.jl plugin but for now I've copy pasted the code into Oceananigans.jl until the plugin has stabilized in some form. The `@cite` and `@bibliography` syntax should remain the same though.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/794
https://github.com/CliMA/Oceananigans.jl/pull/794:461,Modifiability,evolve,evolve,461,"This PR **finally** adds proper citations that link to a references page all generated from an `oceananigans.bib` file. This is now possible thanks to the new Bibliography.jl package which I've used to hack in a Documenter.jl ""plugin"" at https://github.com/ali-ramadhan/DocumenterBibliographyTest.jl. This is currently the last action item for the JOSS submission. The code that handles citations and bibliography expansion is a little messy and will hopefully evolve into a proper Documenter.jl plugin but for now I've copy pasted the code into Oceananigans.jl until the plugin has stabilized in some form. The `@cite` and `@bibliography` syntax should remain the same though.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/794
https://github.com/CliMA/Oceananigans.jl/pull/794:496,Modifiability,plugin,plugin,496,"This PR **finally** adds proper citations that link to a references page all generated from an `oceananigans.bib` file. This is now possible thanks to the new Bibliography.jl package which I've used to hack in a Documenter.jl ""plugin"" at https://github.com/ali-ramadhan/DocumenterBibliographyTest.jl. This is currently the last action item for the JOSS submission. The code that handles citations and bibliography expansion is a little messy and will hopefully evolve into a proper Documenter.jl plugin but for now I've copy pasted the code into Oceananigans.jl until the plugin has stabilized in some form. The `@cite` and `@bibliography` syntax should remain the same though.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/794
https://github.com/CliMA/Oceananigans.jl/pull/794:572,Modifiability,plugin,plugin,572,"This PR **finally** adds proper citations that link to a references page all generated from an `oceananigans.bib` file. This is now possible thanks to the new Bibliography.jl package which I've used to hack in a Documenter.jl ""plugin"" at https://github.com/ali-ramadhan/DocumenterBibliographyTest.jl. This is currently the last action item for the JOSS submission. The code that handles citations and bibliography expansion is a little messy and will hopefully evolve into a proper Documenter.jl plugin but for now I've copy pasted the code into Oceananigans.jl until the plugin has stabilized in some form. The `@cite` and `@bibliography` syntax should remain the same though.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/794
https://github.com/CliMA/Oceananigans.jl/issues/796:465,Availability,error,error,465,"Hi all, I recently switched from using v0.30.0 to using the latest version of the master branch, and I am now unable to add the CuArrays package, as it seems to clash with some of the packages used by Oceananigans. Has anyone else experienced this? I was able to reproduce this issue on two computers. When reverting back to v0.30.0, I have no such problem and can add CuArrays without packages clashing. Thanks for letting me know if you get the same issue!. Full error message suggest that Adapt, GPUArrays, CUDA and NNlib are clashing with CuArrays but I am a beginner at Julia so not sure I interpret the error correctly. I tried removing Oceananigans and all dependencies, installing CuArrays first and then adding Oceananigans, but I get the same problem doing things in that order. ```; ERROR: Unsatisfiable requirements detected for package CuArrays [3a865a2d]:; CuArrays [3a865a2d] log:; ├─possible versions are: [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2] or uninstalled; ├─restricted to versions * by an explicit requirement, leaving only versions [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2]; ├─restricted by compatibility requirements with Adapt [79e6a3ab] to versions: [0.2.1, 0.3.0] or uninstalled, leaving only versions: [0.2.1, 0.3.0]; │ └─Adapt [79e6a3ab] log:; │ ├─possible versions are: [0.3.0-0.3.1, 0.4.0-0.4.2, 1.0.0-1.0.1, 1.1.0, 2.0.0-2.0.2] or uninstalled; │ └─restricted to versions 2 by Oceananigans [9e8cae18], leaving only versions 2.0.0-2.0.2; │ └─Oceananigans [9e8cae18] log:; │ ├─possible versions are: 0.30.0 or uninstalled; │ └─Oceananigans [9e8cae18] is fixed to version 0.30.0; ├─restricted by compatibility requirements with GPUArrays [0c68f7d7] to versions: 0.2.1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/796
https://github.com/CliMA/Oceananigans.jl/issues/796:609,Availability,error,error,609,"Hi all, I recently switched from using v0.30.0 to using the latest version of the master branch, and I am now unable to add the CuArrays package, as it seems to clash with some of the packages used by Oceananigans. Has anyone else experienced this? I was able to reproduce this issue on two computers. When reverting back to v0.30.0, I have no such problem and can add CuArrays without packages clashing. Thanks for letting me know if you get the same issue!. Full error message suggest that Adapt, GPUArrays, CUDA and NNlib are clashing with CuArrays but I am a beginner at Julia so not sure I interpret the error correctly. I tried removing Oceananigans and all dependencies, installing CuArrays first and then adding Oceananigans, but I get the same problem doing things in that order. ```; ERROR: Unsatisfiable requirements detected for package CuArrays [3a865a2d]:; CuArrays [3a865a2d] log:; ├─possible versions are: [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2] or uninstalled; ├─restricted to versions * by an explicit requirement, leaving only versions [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2]; ├─restricted by compatibility requirements with Adapt [79e6a3ab] to versions: [0.2.1, 0.3.0] or uninstalled, leaving only versions: [0.2.1, 0.3.0]; │ └─Adapt [79e6a3ab] log:; │ ├─possible versions are: [0.3.0-0.3.1, 0.4.0-0.4.2, 1.0.0-1.0.1, 1.1.0, 2.0.0-2.0.2] or uninstalled; │ └─restricted to versions 2 by Oceananigans [9e8cae18], leaving only versions 2.0.0-2.0.2; │ └─Oceananigans [9e8cae18] log:; │ ├─possible versions are: 0.30.0 or uninstalled; │ └─Oceananigans [9e8cae18] is fixed to version 0.30.0; ├─restricted by compatibility requirements with GPUArrays [0c68f7d7] to versions: 0.2.1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/796
https://github.com/CliMA/Oceananigans.jl/issues/796:794,Availability,ERROR,ERROR,794,"Hi all, I recently switched from using v0.30.0 to using the latest version of the master branch, and I am now unable to add the CuArrays package, as it seems to clash with some of the packages used by Oceananigans. Has anyone else experienced this? I was able to reproduce this issue on two computers. When reverting back to v0.30.0, I have no such problem and can add CuArrays without packages clashing. Thanks for letting me know if you get the same issue!. Full error message suggest that Adapt, GPUArrays, CUDA and NNlib are clashing with CuArrays but I am a beginner at Julia so not sure I interpret the error correctly. I tried removing Oceananigans and all dependencies, installing CuArrays first and then adding Oceananigans, but I get the same problem doing things in that order. ```; ERROR: Unsatisfiable requirements detected for package CuArrays [3a865a2d]:; CuArrays [3a865a2d] log:; ├─possible versions are: [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2] or uninstalled; ├─restricted to versions * by an explicit requirement, leaving only versions [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2]; ├─restricted by compatibility requirements with Adapt [79e6a3ab] to versions: [0.2.1, 0.3.0] or uninstalled, leaving only versions: [0.2.1, 0.3.0]; │ └─Adapt [79e6a3ab] log:; │ ├─possible versions are: [0.3.0-0.3.1, 0.4.0-0.4.2, 1.0.0-1.0.1, 1.1.0, 2.0.0-2.0.2] or uninstalled; │ └─restricted to versions 2 by Oceananigans [9e8cae18], leaving only versions 2.0.0-2.0.2; │ └─Oceananigans [9e8cae18] log:; │ ├─possible versions are: 0.30.0 or uninstalled; │ └─Oceananigans [9e8cae18] is fixed to version 0.30.0; ├─restricted by compatibility requirements with GPUArrays [0c68f7d7] to versions: 0.2.1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/796
https://github.com/CliMA/Oceananigans.jl/issues/796:678,Deployability,install,installing,678,"Hi all, I recently switched from using v0.30.0 to using the latest version of the master branch, and I am now unable to add the CuArrays package, as it seems to clash with some of the packages used by Oceananigans. Has anyone else experienced this? I was able to reproduce this issue on two computers. When reverting back to v0.30.0, I have no such problem and can add CuArrays without packages clashing. Thanks for letting me know if you get the same issue!. Full error message suggest that Adapt, GPUArrays, CUDA and NNlib are clashing with CuArrays but I am a beginner at Julia so not sure I interpret the error correctly. I tried removing Oceananigans and all dependencies, installing CuArrays first and then adding Oceananigans, but I get the same problem doing things in that order. ```; ERROR: Unsatisfiable requirements detected for package CuArrays [3a865a2d]:; CuArrays [3a865a2d] log:; ├─possible versions are: [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2] or uninstalled; ├─restricted to versions * by an explicit requirement, leaving only versions [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2]; ├─restricted by compatibility requirements with Adapt [79e6a3ab] to versions: [0.2.1, 0.3.0] or uninstalled, leaving only versions: [0.2.1, 0.3.0]; │ └─Adapt [79e6a3ab] log:; │ ├─possible versions are: [0.3.0-0.3.1, 0.4.0-0.4.2, 1.0.0-1.0.1, 1.1.0, 2.0.0-2.0.2] or uninstalled; │ └─restricted to versions 2 by Oceananigans [9e8cae18], leaving only versions 2.0.0-2.0.2; │ └─Oceananigans [9e8cae18] log:; │ ├─possible versions are: 0.30.0 or uninstalled; │ └─Oceananigans [9e8cae18] is fixed to version 0.30.0; ├─restricted by compatibility requirements with GPUArrays [0c68f7d7] to versions: 0.2.1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/796
https://github.com/CliMA/Oceananigans.jl/issues/796:492,Energy Efficiency,Adapt,Adapt,492,"Hi all, I recently switched from using v0.30.0 to using the latest version of the master branch, and I am now unable to add the CuArrays package, as it seems to clash with some of the packages used by Oceananigans. Has anyone else experienced this? I was able to reproduce this issue on two computers. When reverting back to v0.30.0, I have no such problem and can add CuArrays without packages clashing. Thanks for letting me know if you get the same issue!. Full error message suggest that Adapt, GPUArrays, CUDA and NNlib are clashing with CuArrays but I am a beginner at Julia so not sure I interpret the error correctly. I tried removing Oceananigans and all dependencies, installing CuArrays first and then adding Oceananigans, but I get the same problem doing things in that order. ```; ERROR: Unsatisfiable requirements detected for package CuArrays [3a865a2d]:; CuArrays [3a865a2d] log:; ├─possible versions are: [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2] or uninstalled; ├─restricted to versions * by an explicit requirement, leaving only versions [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2]; ├─restricted by compatibility requirements with Adapt [79e6a3ab] to versions: [0.2.1, 0.3.0] or uninstalled, leaving only versions: [0.2.1, 0.3.0]; │ └─Adapt [79e6a3ab] log:; │ ├─possible versions are: [0.3.0-0.3.1, 0.4.0-0.4.2, 1.0.0-1.0.1, 1.1.0, 2.0.0-2.0.2] or uninstalled; │ └─restricted to versions 2 by Oceananigans [9e8cae18], leaving only versions 2.0.0-2.0.2; │ └─Oceananigans [9e8cae18] log:; │ ├─possible versions are: 0.30.0 or uninstalled; │ └─Oceananigans [9e8cae18] is fixed to version 0.30.0; ├─restricted by compatibility requirements with GPUArrays [0c68f7d7] to versions: 0.2.1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/796
https://github.com/CliMA/Oceananigans.jl/issues/796:1452,Energy Efficiency,Adapt,Adapt,1452," the same issue!. Full error message suggest that Adapt, GPUArrays, CUDA and NNlib are clashing with CuArrays but I am a beginner at Julia so not sure I interpret the error correctly. I tried removing Oceananigans and all dependencies, installing CuArrays first and then adding Oceananigans, but I get the same problem doing things in that order. ```; ERROR: Unsatisfiable requirements detected for package CuArrays [3a865a2d]:; CuArrays [3a865a2d] log:; ├─possible versions are: [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2] or uninstalled; ├─restricted to versions * by an explicit requirement, leaving only versions [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2]; ├─restricted by compatibility requirements with Adapt [79e6a3ab] to versions: [0.2.1, 0.3.0] or uninstalled, leaving only versions: [0.2.1, 0.3.0]; │ └─Adapt [79e6a3ab] log:; │ ├─possible versions are: [0.3.0-0.3.1, 0.4.0-0.4.2, 1.0.0-1.0.1, 1.1.0, 2.0.0-2.0.2] or uninstalled; │ └─restricted to versions 2 by Oceananigans [9e8cae18], leaving only versions 2.0.0-2.0.2; │ └─Oceananigans [9e8cae18] log:; │ ├─possible versions are: 0.30.0 or uninstalled; │ └─Oceananigans [9e8cae18] is fixed to version 0.30.0; ├─restricted by compatibility requirements with GPUArrays [0c68f7d7] to versions: 0.2.1 or uninstalled, leaving only versions: 0.2.1; │ └─GPUArrays [0c68f7d7] log:; │ ├─possible versions are: [0.3.0-0.3.4, 0.4.0-0.4.2, 0.5.0, 0.6.0-0.6.1, 0.7.0-0.7.2, 1.0.0-1.0.4, 2.0.0-2.0.1, 3.0.0-3.0.1, 3.1.0, 3.2.0, 3.3.0, 3.4.0-3.4.1, 4.0.0] or uninstalled; │ └─restricted by compatibility requirements with CUDA [052768ef] to versions: 4.0.0; │ └─CUDA [052768ef] log:; │ ├─possible versions are: [0.1.0, 1.0.0-1.0.2, 1.1.0] or uninstalled",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/796
https://github.com/CliMA/Oceananigans.jl/issues/796:1556,Energy Efficiency,Adapt,Adapt,1556,"ia so not sure I interpret the error correctly. I tried removing Oceananigans and all dependencies, installing CuArrays first and then adding Oceananigans, but I get the same problem doing things in that order. ```; ERROR: Unsatisfiable requirements detected for package CuArrays [3a865a2d]:; CuArrays [3a865a2d] log:; ├─possible versions are: [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2] or uninstalled; ├─restricted to versions * by an explicit requirement, leaving only versions [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2]; ├─restricted by compatibility requirements with Adapt [79e6a3ab] to versions: [0.2.1, 0.3.0] or uninstalled, leaving only versions: [0.2.1, 0.3.0]; │ └─Adapt [79e6a3ab] log:; │ ├─possible versions are: [0.3.0-0.3.1, 0.4.0-0.4.2, 1.0.0-1.0.1, 1.1.0, 2.0.0-2.0.2] or uninstalled; │ └─restricted to versions 2 by Oceananigans [9e8cae18], leaving only versions 2.0.0-2.0.2; │ └─Oceananigans [9e8cae18] log:; │ ├─possible versions are: 0.30.0 or uninstalled; │ └─Oceananigans [9e8cae18] is fixed to version 0.30.0; ├─restricted by compatibility requirements with GPUArrays [0c68f7d7] to versions: 0.2.1 or uninstalled, leaving only versions: 0.2.1; │ └─GPUArrays [0c68f7d7] log:; │ ├─possible versions are: [0.3.0-0.3.4, 0.4.0-0.4.2, 0.5.0, 0.6.0-0.6.1, 0.7.0-0.7.2, 1.0.0-1.0.4, 2.0.0-2.0.1, 3.0.0-3.0.1, 3.1.0, 3.2.0, 3.3.0, 3.4.0-3.4.1, 4.0.0] or uninstalled; │ └─restricted by compatibility requirements with CUDA [052768ef] to versions: 4.0.0; │ └─CUDA [052768ef] log:; │ ├─possible versions are: [0.1.0, 1.0.0-1.0.2, 1.1.0] or uninstalled; │ └─restricted to versions 1 by Oceananigans [9e8cae18], leaving only versions [1.0.0-1.0.2, 1.1.0]; │ └─Oceananigans [9e8cae18] log: ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/796
https://github.com/CliMA/Oceananigans.jl/issues/796:471,Integrability,message,message,471,"Hi all, I recently switched from using v0.30.0 to using the latest version of the master branch, and I am now unable to add the CuArrays package, as it seems to clash with some of the packages used by Oceananigans. Has anyone else experienced this? I was able to reproduce this issue on two computers. When reverting back to v0.30.0, I have no such problem and can add CuArrays without packages clashing. Thanks for letting me know if you get the same issue!. Full error message suggest that Adapt, GPUArrays, CUDA and NNlib are clashing with CuArrays but I am a beginner at Julia so not sure I interpret the error correctly. I tried removing Oceananigans and all dependencies, installing CuArrays first and then adding Oceananigans, but I get the same problem doing things in that order. ```; ERROR: Unsatisfiable requirements detected for package CuArrays [3a865a2d]:; CuArrays [3a865a2d] log:; ├─possible versions are: [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2] or uninstalled; ├─restricted to versions * by an explicit requirement, leaving only versions [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2]; ├─restricted by compatibility requirements with Adapt [79e6a3ab] to versions: [0.2.1, 0.3.0] or uninstalled, leaving only versions: [0.2.1, 0.3.0]; │ └─Adapt [79e6a3ab] log:; │ ├─possible versions are: [0.3.0-0.3.1, 0.4.0-0.4.2, 1.0.0-1.0.1, 1.1.0, 2.0.0-2.0.2] or uninstalled; │ └─restricted to versions 2 by Oceananigans [9e8cae18], leaving only versions 2.0.0-2.0.2; │ └─Oceananigans [9e8cae18] log:; │ ├─possible versions are: 0.30.0 or uninstalled; │ └─Oceananigans [9e8cae18] is fixed to version 0.30.0; ├─restricted by compatibility requirements with GPUArrays [0c68f7d7] to versions: 0.2.1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/796
https://github.com/CliMA/Oceananigans.jl/issues/796:664,Integrability,depend,dependencies,664,"Hi all, I recently switched from using v0.30.0 to using the latest version of the master branch, and I am now unable to add the CuArrays package, as it seems to clash with some of the packages used by Oceananigans. Has anyone else experienced this? I was able to reproduce this issue on two computers. When reverting back to v0.30.0, I have no such problem and can add CuArrays without packages clashing. Thanks for letting me know if you get the same issue!. Full error message suggest that Adapt, GPUArrays, CUDA and NNlib are clashing with CuArrays but I am a beginner at Julia so not sure I interpret the error correctly. I tried removing Oceananigans and all dependencies, installing CuArrays first and then adding Oceananigans, but I get the same problem doing things in that order. ```; ERROR: Unsatisfiable requirements detected for package CuArrays [3a865a2d]:; CuArrays [3a865a2d] log:; ├─possible versions are: [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2] or uninstalled; ├─restricted to versions * by an explicit requirement, leaving only versions [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2]; ├─restricted by compatibility requirements with Adapt [79e6a3ab] to versions: [0.2.1, 0.3.0] or uninstalled, leaving only versions: [0.2.1, 0.3.0]; │ └─Adapt [79e6a3ab] log:; │ ├─possible versions are: [0.3.0-0.3.1, 0.4.0-0.4.2, 1.0.0-1.0.1, 1.1.0, 2.0.0-2.0.2] or uninstalled; │ └─restricted to versions 2 by Oceananigans [9e8cae18], leaving only versions 2.0.0-2.0.2; │ └─Oceananigans [9e8cae18] log:; │ ├─possible versions are: 0.30.0 or uninstalled; │ └─Oceananigans [9e8cae18] is fixed to version 0.30.0; ├─restricted by compatibility requirements with GPUArrays [0c68f7d7] to versions: 0.2.1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/796
https://github.com/CliMA/Oceananigans.jl/issues/796:492,Modifiability,Adapt,Adapt,492,"Hi all, I recently switched from using v0.30.0 to using the latest version of the master branch, and I am now unable to add the CuArrays package, as it seems to clash with some of the packages used by Oceananigans. Has anyone else experienced this? I was able to reproduce this issue on two computers. When reverting back to v0.30.0, I have no such problem and can add CuArrays without packages clashing. Thanks for letting me know if you get the same issue!. Full error message suggest that Adapt, GPUArrays, CUDA and NNlib are clashing with CuArrays but I am a beginner at Julia so not sure I interpret the error correctly. I tried removing Oceananigans and all dependencies, installing CuArrays first and then adding Oceananigans, but I get the same problem doing things in that order. ```; ERROR: Unsatisfiable requirements detected for package CuArrays [3a865a2d]:; CuArrays [3a865a2d] log:; ├─possible versions are: [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2] or uninstalled; ├─restricted to versions * by an explicit requirement, leaving only versions [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2]; ├─restricted by compatibility requirements with Adapt [79e6a3ab] to versions: [0.2.1, 0.3.0] or uninstalled, leaving only versions: [0.2.1, 0.3.0]; │ └─Adapt [79e6a3ab] log:; │ ├─possible versions are: [0.3.0-0.3.1, 0.4.0-0.4.2, 1.0.0-1.0.1, 1.1.0, 2.0.0-2.0.2] or uninstalled; │ └─restricted to versions 2 by Oceananigans [9e8cae18], leaving only versions 2.0.0-2.0.2; │ └─Oceananigans [9e8cae18] log:; │ ├─possible versions are: 0.30.0 or uninstalled; │ └─Oceananigans [9e8cae18] is fixed to version 0.30.0; ├─restricted by compatibility requirements with GPUArrays [0c68f7d7] to versions: 0.2.1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/796
https://github.com/CliMA/Oceananigans.jl/issues/796:1452,Modifiability,Adapt,Adapt,1452," the same issue!. Full error message suggest that Adapt, GPUArrays, CUDA and NNlib are clashing with CuArrays but I am a beginner at Julia so not sure I interpret the error correctly. I tried removing Oceananigans and all dependencies, installing CuArrays first and then adding Oceananigans, but I get the same problem doing things in that order. ```; ERROR: Unsatisfiable requirements detected for package CuArrays [3a865a2d]:; CuArrays [3a865a2d] log:; ├─possible versions are: [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2] or uninstalled; ├─restricted to versions * by an explicit requirement, leaving only versions [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2]; ├─restricted by compatibility requirements with Adapt [79e6a3ab] to versions: [0.2.1, 0.3.0] or uninstalled, leaving only versions: [0.2.1, 0.3.0]; │ └─Adapt [79e6a3ab] log:; │ ├─possible versions are: [0.3.0-0.3.1, 0.4.0-0.4.2, 1.0.0-1.0.1, 1.1.0, 2.0.0-2.0.2] or uninstalled; │ └─restricted to versions 2 by Oceananigans [9e8cae18], leaving only versions 2.0.0-2.0.2; │ └─Oceananigans [9e8cae18] log:; │ ├─possible versions are: 0.30.0 or uninstalled; │ └─Oceananigans [9e8cae18] is fixed to version 0.30.0; ├─restricted by compatibility requirements with GPUArrays [0c68f7d7] to versions: 0.2.1 or uninstalled, leaving only versions: 0.2.1; │ └─GPUArrays [0c68f7d7] log:; │ ├─possible versions are: [0.3.0-0.3.4, 0.4.0-0.4.2, 0.5.0, 0.6.0-0.6.1, 0.7.0-0.7.2, 1.0.0-1.0.4, 2.0.0-2.0.1, 3.0.0-3.0.1, 3.1.0, 3.2.0, 3.3.0, 3.4.0-3.4.1, 4.0.0] or uninstalled; │ └─restricted by compatibility requirements with CUDA [052768ef] to versions: 4.0.0; │ └─CUDA [052768ef] log:; │ ├─possible versions are: [0.1.0, 1.0.0-1.0.2, 1.1.0] or uninstalled",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/796
https://github.com/CliMA/Oceananigans.jl/issues/796:1556,Modifiability,Adapt,Adapt,1556,"ia so not sure I interpret the error correctly. I tried removing Oceananigans and all dependencies, installing CuArrays first and then adding Oceananigans, but I get the same problem doing things in that order. ```; ERROR: Unsatisfiable requirements detected for package CuArrays [3a865a2d]:; CuArrays [3a865a2d] log:; ├─possible versions are: [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2] or uninstalled; ├─restricted to versions * by an explicit requirement, leaving only versions [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2]; ├─restricted by compatibility requirements with Adapt [79e6a3ab] to versions: [0.2.1, 0.3.0] or uninstalled, leaving only versions: [0.2.1, 0.3.0]; │ └─Adapt [79e6a3ab] log:; │ ├─possible versions are: [0.3.0-0.3.1, 0.4.0-0.4.2, 1.0.0-1.0.1, 1.1.0, 2.0.0-2.0.2] or uninstalled; │ └─restricted to versions 2 by Oceananigans [9e8cae18], leaving only versions 2.0.0-2.0.2; │ └─Oceananigans [9e8cae18] log:; │ ├─possible versions are: 0.30.0 or uninstalled; │ └─Oceananigans [9e8cae18] is fixed to version 0.30.0; ├─restricted by compatibility requirements with GPUArrays [0c68f7d7] to versions: 0.2.1 or uninstalled, leaving only versions: 0.2.1; │ └─GPUArrays [0c68f7d7] log:; │ ├─possible versions are: [0.3.0-0.3.4, 0.4.0-0.4.2, 0.5.0, 0.6.0-0.6.1, 0.7.0-0.7.2, 1.0.0-1.0.4, 2.0.0-2.0.1, 3.0.0-3.0.1, 3.1.0, 3.2.0, 3.3.0, 3.4.0-3.4.1, 4.0.0] or uninstalled; │ └─restricted by compatibility requirements with CUDA [052768ef] to versions: 4.0.0; │ └─CUDA [052768ef] log:; │ ├─possible versions are: [0.1.0, 1.0.0-1.0.2, 1.1.0] or uninstalled; │ └─restricted to versions 1 by Oceananigans [9e8cae18], leaving only versions [1.0.0-1.0.2, 1.1.0]; │ └─Oceananigans [9e8cae18] log: ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/796
https://github.com/CliMA/Oceananigans.jl/issues/796:828,Safety,detect,detected,828,"Hi all, I recently switched from using v0.30.0 to using the latest version of the master branch, and I am now unable to add the CuArrays package, as it seems to clash with some of the packages used by Oceananigans. Has anyone else experienced this? I was able to reproduce this issue on two computers. When reverting back to v0.30.0, I have no such problem and can add CuArrays without packages clashing. Thanks for letting me know if you get the same issue!. Full error message suggest that Adapt, GPUArrays, CUDA and NNlib are clashing with CuArrays but I am a beginner at Julia so not sure I interpret the error correctly. I tried removing Oceananigans and all dependencies, installing CuArrays first and then adding Oceananigans, but I get the same problem doing things in that order. ```; ERROR: Unsatisfiable requirements detected for package CuArrays [3a865a2d]:; CuArrays [3a865a2d] log:; ├─possible versions are: [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2] or uninstalled; ├─restricted to versions * by an explicit requirement, leaving only versions [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2]; ├─restricted by compatibility requirements with Adapt [79e6a3ab] to versions: [0.2.1, 0.3.0] or uninstalled, leaving only versions: [0.2.1, 0.3.0]; │ └─Adapt [79e6a3ab] log:; │ ├─possible versions are: [0.3.0-0.3.1, 0.4.0-0.4.2, 1.0.0-1.0.1, 1.1.0, 2.0.0-2.0.2] or uninstalled; │ └─restricted to versions 2 by Oceananigans [9e8cae18], leaving only versions 2.0.0-2.0.2; │ └─Oceananigans [9e8cae18] log:; │ ├─possible versions are: 0.30.0 or uninstalled; │ └─Oceananigans [9e8cae18] is fixed to version 0.30.0; ├─restricted by compatibility requirements with GPUArrays [0c68f7d7] to versions: 0.2.1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/796
https://github.com/CliMA/Oceananigans.jl/issues/796:891,Testability,log,log,891,"Hi all, I recently switched from using v0.30.0 to using the latest version of the master branch, and I am now unable to add the CuArrays package, as it seems to clash with some of the packages used by Oceananigans. Has anyone else experienced this? I was able to reproduce this issue on two computers. When reverting back to v0.30.0, I have no such problem and can add CuArrays without packages clashing. Thanks for letting me know if you get the same issue!. Full error message suggest that Adapt, GPUArrays, CUDA and NNlib are clashing with CuArrays but I am a beginner at Julia so not sure I interpret the error correctly. I tried removing Oceananigans and all dependencies, installing CuArrays first and then adding Oceananigans, but I get the same problem doing things in that order. ```; ERROR: Unsatisfiable requirements detected for package CuArrays [3a865a2d]:; CuArrays [3a865a2d] log:; ├─possible versions are: [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2] or uninstalled; ├─restricted to versions * by an explicit requirement, leaving only versions [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2]; ├─restricted by compatibility requirements with Adapt [79e6a3ab] to versions: [0.2.1, 0.3.0] or uninstalled, leaving only versions: [0.2.1, 0.3.0]; │ └─Adapt [79e6a3ab] log:; │ ├─possible versions are: [0.3.0-0.3.1, 0.4.0-0.4.2, 1.0.0-1.0.1, 1.1.0, 2.0.0-2.0.2] or uninstalled; │ └─restricted to versions 2 by Oceananigans [9e8cae18], leaving only versions 2.0.0-2.0.2; │ └─Oceananigans [9e8cae18] log:; │ ├─possible versions are: 0.30.0 or uninstalled; │ └─Oceananigans [9e8cae18] is fixed to version 0.30.0; ├─restricted by compatibility requirements with GPUArrays [0c68f7d7] to versions: 0.2.1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/796
https://github.com/CliMA/Oceananigans.jl/issues/796:1573,Testability,log,log,1573,"ia so not sure I interpret the error correctly. I tried removing Oceananigans and all dependencies, installing CuArrays first and then adding Oceananigans, but I get the same problem doing things in that order. ```; ERROR: Unsatisfiable requirements detected for package CuArrays [3a865a2d]:; CuArrays [3a865a2d] log:; ├─possible versions are: [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2] or uninstalled; ├─restricted to versions * by an explicit requirement, leaving only versions [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2]; ├─restricted by compatibility requirements with Adapt [79e6a3ab] to versions: [0.2.1, 0.3.0] or uninstalled, leaving only versions: [0.2.1, 0.3.0]; │ └─Adapt [79e6a3ab] log:; │ ├─possible versions are: [0.3.0-0.3.1, 0.4.0-0.4.2, 1.0.0-1.0.1, 1.1.0, 2.0.0-2.0.2] or uninstalled; │ └─restricted to versions 2 by Oceananigans [9e8cae18], leaving only versions 2.0.0-2.0.2; │ └─Oceananigans [9e8cae18] log:; │ ├─possible versions are: 0.30.0 or uninstalled; │ └─Oceananigans [9e8cae18] is fixed to version 0.30.0; ├─restricted by compatibility requirements with GPUArrays [0c68f7d7] to versions: 0.2.1 or uninstalled, leaving only versions: 0.2.1; │ └─GPUArrays [0c68f7d7] log:; │ ├─possible versions are: [0.3.0-0.3.4, 0.4.0-0.4.2, 0.5.0, 0.6.0-0.6.1, 0.7.0-0.7.2, 1.0.0-1.0.4, 2.0.0-2.0.1, 3.0.0-3.0.1, 3.1.0, 3.2.0, 3.3.0, 3.4.0-3.4.1, 4.0.0] or uninstalled; │ └─restricted by compatibility requirements with CUDA [052768ef] to versions: 4.0.0; │ └─CUDA [052768ef] log:; │ ├─possible versions are: [0.1.0, 1.0.0-1.0.2, 1.1.0] or uninstalled; │ └─restricted to versions 1 by Oceananigans [9e8cae18], leaving only versions [1.0.0-1.0.2, 1.1.0]; │ └─Oceananigans [9e8cae18] log: ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/796
https://github.com/CliMA/Oceananigans.jl/issues/796:1802,Testability,log,log,1802,"atisfiable requirements detected for package CuArrays [3a865a2d]:; CuArrays [3a865a2d] log:; ├─possible versions are: [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2] or uninstalled; ├─restricted to versions * by an explicit requirement, leaving only versions [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2]; ├─restricted by compatibility requirements with Adapt [79e6a3ab] to versions: [0.2.1, 0.3.0] or uninstalled, leaving only versions: [0.2.1, 0.3.0]; │ └─Adapt [79e6a3ab] log:; │ ├─possible versions are: [0.3.0-0.3.1, 0.4.0-0.4.2, 1.0.0-1.0.1, 1.1.0, 2.0.0-2.0.2] or uninstalled; │ └─restricted to versions 2 by Oceananigans [9e8cae18], leaving only versions 2.0.0-2.0.2; │ └─Oceananigans [9e8cae18] log:; │ ├─possible versions are: 0.30.0 or uninstalled; │ └─Oceananigans [9e8cae18] is fixed to version 0.30.0; ├─restricted by compatibility requirements with GPUArrays [0c68f7d7] to versions: 0.2.1 or uninstalled, leaving only versions: 0.2.1; │ └─GPUArrays [0c68f7d7] log:; │ ├─possible versions are: [0.3.0-0.3.4, 0.4.0-0.4.2, 0.5.0, 0.6.0-0.6.1, 0.7.0-0.7.2, 1.0.0-1.0.4, 2.0.0-2.0.1, 3.0.0-3.0.1, 3.1.0, 3.2.0, 3.3.0, 3.4.0-3.4.1, 4.0.0] or uninstalled; │ └─restricted by compatibility requirements with CUDA [052768ef] to versions: 4.0.0; │ └─CUDA [052768ef] log:; │ ├─possible versions are: [0.1.0, 1.0.0-1.0.2, 1.1.0] or uninstalled; │ └─restricted to versions 1 by Oceananigans [9e8cae18], leaving only versions [1.0.0-1.0.2, 1.1.0]; │ └─Oceananigans [9e8cae18] log: see above; └─restricted by compatibility requirements with NNlib [872c559c] to versions: [1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2] or uninstalled — no versions",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/796
https://github.com/CliMA/Oceananigans.jl/issues/796:2073,Testability,log,log,2073,".0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2] or uninstalled; ├─restricted to versions * by an explicit requirement, leaving only versions [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2]; ├─restricted by compatibility requirements with Adapt [79e6a3ab] to versions: [0.2.1, 0.3.0] or uninstalled, leaving only versions: [0.2.1, 0.3.0]; │ └─Adapt [79e6a3ab] log:; │ ├─possible versions are: [0.3.0-0.3.1, 0.4.0-0.4.2, 1.0.0-1.0.1, 1.1.0, 2.0.0-2.0.2] or uninstalled; │ └─restricted to versions 2 by Oceananigans [9e8cae18], leaving only versions 2.0.0-2.0.2; │ └─Oceananigans [9e8cae18] log:; │ ├─possible versions are: 0.30.0 or uninstalled; │ └─Oceananigans [9e8cae18] is fixed to version 0.30.0; ├─restricted by compatibility requirements with GPUArrays [0c68f7d7] to versions: 0.2.1 or uninstalled, leaving only versions: 0.2.1; │ └─GPUArrays [0c68f7d7] log:; │ ├─possible versions are: [0.3.0-0.3.4, 0.4.0-0.4.2, 0.5.0, 0.6.0-0.6.1, 0.7.0-0.7.2, 1.0.0-1.0.4, 2.0.0-2.0.1, 3.0.0-3.0.1, 3.1.0, 3.2.0, 3.3.0, 3.4.0-3.4.1, 4.0.0] or uninstalled; │ └─restricted by compatibility requirements with CUDA [052768ef] to versions: 4.0.0; │ └─CUDA [052768ef] log:; │ ├─possible versions are: [0.1.0, 1.0.0-1.0.2, 1.1.0] or uninstalled; │ └─restricted to versions 1 by Oceananigans [9e8cae18], leaving only versions [1.0.0-1.0.2, 1.1.0]; │ └─Oceananigans [9e8cae18] log: see above; └─restricted by compatibility requirements with NNlib [872c559c] to versions: [1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2] or uninstalled — no versions left; └─NNlib [872c559c] log:; ├─possible versions are: [0.3.2, 0.4.0-0.4.3, 0.5.0, 0.6.0-0.6.6, 0.7.0-0.7.3] or uninstalled; └─restricted by compatibility requirements with CUDA [052768ef] to versions: [0.6.5-0.6.6, 0.7.0-0.7.3]; └─CUDA [052768ef] log: see above; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/796
https://github.com/CliMA/Oceananigans.jl/issues/796:2368,Testability,log,log,2368,".0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2] or uninstalled; ├─restricted to versions * by an explicit requirement, leaving only versions [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2]; ├─restricted by compatibility requirements with Adapt [79e6a3ab] to versions: [0.2.1, 0.3.0] or uninstalled, leaving only versions: [0.2.1, 0.3.0]; │ └─Adapt [79e6a3ab] log:; │ ├─possible versions are: [0.3.0-0.3.1, 0.4.0-0.4.2, 1.0.0-1.0.1, 1.1.0, 2.0.0-2.0.2] or uninstalled; │ └─restricted to versions 2 by Oceananigans [9e8cae18], leaving only versions 2.0.0-2.0.2; │ └─Oceananigans [9e8cae18] log:; │ ├─possible versions are: 0.30.0 or uninstalled; │ └─Oceananigans [9e8cae18] is fixed to version 0.30.0; ├─restricted by compatibility requirements with GPUArrays [0c68f7d7] to versions: 0.2.1 or uninstalled, leaving only versions: 0.2.1; │ └─GPUArrays [0c68f7d7] log:; │ ├─possible versions are: [0.3.0-0.3.4, 0.4.0-0.4.2, 0.5.0, 0.6.0-0.6.1, 0.7.0-0.7.2, 1.0.0-1.0.4, 2.0.0-2.0.1, 3.0.0-3.0.1, 3.1.0, 3.2.0, 3.3.0, 3.4.0-3.4.1, 4.0.0] or uninstalled; │ └─restricted by compatibility requirements with CUDA [052768ef] to versions: 4.0.0; │ └─CUDA [052768ef] log:; │ ├─possible versions are: [0.1.0, 1.0.0-1.0.2, 1.1.0] or uninstalled; │ └─restricted to versions 1 by Oceananigans [9e8cae18], leaving only versions [1.0.0-1.0.2, 1.1.0]; │ └─Oceananigans [9e8cae18] log: see above; └─restricted by compatibility requirements with NNlib [872c559c] to versions: [1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2] or uninstalled — no versions left; └─NNlib [872c559c] log:; ├─possible versions are: [0.3.2, 0.4.0-0.4.3, 0.5.0, 0.6.0-0.6.6, 0.7.0-0.7.3] or uninstalled; └─restricted by compatibility requirements with CUDA [052768ef] to versions: [0.6.5-0.6.6, 0.7.0-0.7.3]; └─CUDA [052768ef] log: see above; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/796
https://github.com/CliMA/Oceananigans.jl/issues/796:2574,Testability,log,log,2574,".0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2] or uninstalled; ├─restricted to versions * by an explicit requirement, leaving only versions [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2]; ├─restricted by compatibility requirements with Adapt [79e6a3ab] to versions: [0.2.1, 0.3.0] or uninstalled, leaving only versions: [0.2.1, 0.3.0]; │ └─Adapt [79e6a3ab] log:; │ ├─possible versions are: [0.3.0-0.3.1, 0.4.0-0.4.2, 1.0.0-1.0.1, 1.1.0, 2.0.0-2.0.2] or uninstalled; │ └─restricted to versions 2 by Oceananigans [9e8cae18], leaving only versions 2.0.0-2.0.2; │ └─Oceananigans [9e8cae18] log:; │ ├─possible versions are: 0.30.0 or uninstalled; │ └─Oceananigans [9e8cae18] is fixed to version 0.30.0; ├─restricted by compatibility requirements with GPUArrays [0c68f7d7] to versions: 0.2.1 or uninstalled, leaving only versions: 0.2.1; │ └─GPUArrays [0c68f7d7] log:; │ ├─possible versions are: [0.3.0-0.3.4, 0.4.0-0.4.2, 0.5.0, 0.6.0-0.6.1, 0.7.0-0.7.2, 1.0.0-1.0.4, 2.0.0-2.0.1, 3.0.0-3.0.1, 3.1.0, 3.2.0, 3.3.0, 3.4.0-3.4.1, 4.0.0] or uninstalled; │ └─restricted by compatibility requirements with CUDA [052768ef] to versions: 4.0.0; │ └─CUDA [052768ef] log:; │ ├─possible versions are: [0.1.0, 1.0.0-1.0.2, 1.1.0] or uninstalled; │ └─restricted to versions 1 by Oceananigans [9e8cae18], leaving only versions [1.0.0-1.0.2, 1.1.0]; │ └─Oceananigans [9e8cae18] log: see above; └─restricted by compatibility requirements with NNlib [872c559c] to versions: [1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2] or uninstalled — no versions left; └─NNlib [872c559c] log:; ├─possible versions are: [0.3.2, 0.4.0-0.4.3, 0.5.0, 0.6.0-0.6.6, 0.7.0-0.7.3] or uninstalled; └─restricted by compatibility requirements with CUDA [052768ef] to versions: [0.6.5-0.6.6, 0.7.0-0.7.3]; └─CUDA [052768ef] log: see above; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/796
https://github.com/CliMA/Oceananigans.jl/issues/796:2830,Testability,log,log,2830,".0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2] or uninstalled; ├─restricted to versions * by an explicit requirement, leaving only versions [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2]; ├─restricted by compatibility requirements with Adapt [79e6a3ab] to versions: [0.2.1, 0.3.0] or uninstalled, leaving only versions: [0.2.1, 0.3.0]; │ └─Adapt [79e6a3ab] log:; │ ├─possible versions are: [0.3.0-0.3.1, 0.4.0-0.4.2, 1.0.0-1.0.1, 1.1.0, 2.0.0-2.0.2] or uninstalled; │ └─restricted to versions 2 by Oceananigans [9e8cae18], leaving only versions 2.0.0-2.0.2; │ └─Oceananigans [9e8cae18] log:; │ ├─possible versions are: 0.30.0 or uninstalled; │ └─Oceananigans [9e8cae18] is fixed to version 0.30.0; ├─restricted by compatibility requirements with GPUArrays [0c68f7d7] to versions: 0.2.1 or uninstalled, leaving only versions: 0.2.1; │ └─GPUArrays [0c68f7d7] log:; │ ├─possible versions are: [0.3.0-0.3.4, 0.4.0-0.4.2, 0.5.0, 0.6.0-0.6.1, 0.7.0-0.7.2, 1.0.0-1.0.4, 2.0.0-2.0.1, 3.0.0-3.0.1, 3.1.0, 3.2.0, 3.3.0, 3.4.0-3.4.1, 4.0.0] or uninstalled; │ └─restricted by compatibility requirements with CUDA [052768ef] to versions: 4.0.0; │ └─CUDA [052768ef] log:; │ ├─possible versions are: [0.1.0, 1.0.0-1.0.2, 1.1.0] or uninstalled; │ └─restricted to versions 1 by Oceananigans [9e8cae18], leaving only versions [1.0.0-1.0.2, 1.1.0]; │ └─Oceananigans [9e8cae18] log: see above; └─restricted by compatibility requirements with NNlib [872c559c] to versions: [1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2] or uninstalled — no versions left; └─NNlib [872c559c] log:; ├─possible versions are: [0.3.2, 0.4.0-0.4.3, 0.5.0, 0.6.0-0.6.6, 0.7.0-0.7.3] or uninstalled; └─restricted by compatibility requirements with CUDA [052768ef] to versions: [0.6.5-0.6.6, 0.7.0-0.7.3]; └─CUDA [052768ef] log: see above; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/796
https://github.com/CliMA/Oceananigans.jl/issues/796:3054,Testability,log,log,3054,".0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2] or uninstalled; ├─restricted to versions * by an explicit requirement, leaving only versions [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2]; ├─restricted by compatibility requirements with Adapt [79e6a3ab] to versions: [0.2.1, 0.3.0] or uninstalled, leaving only versions: [0.2.1, 0.3.0]; │ └─Adapt [79e6a3ab] log:; │ ├─possible versions are: [0.3.0-0.3.1, 0.4.0-0.4.2, 1.0.0-1.0.1, 1.1.0, 2.0.0-2.0.2] or uninstalled; │ └─restricted to versions 2 by Oceananigans [9e8cae18], leaving only versions 2.0.0-2.0.2; │ └─Oceananigans [9e8cae18] log:; │ ├─possible versions are: 0.30.0 or uninstalled; │ └─Oceananigans [9e8cae18] is fixed to version 0.30.0; ├─restricted by compatibility requirements with GPUArrays [0c68f7d7] to versions: 0.2.1 or uninstalled, leaving only versions: 0.2.1; │ └─GPUArrays [0c68f7d7] log:; │ ├─possible versions are: [0.3.0-0.3.4, 0.4.0-0.4.2, 0.5.0, 0.6.0-0.6.1, 0.7.0-0.7.2, 1.0.0-1.0.4, 2.0.0-2.0.1, 3.0.0-3.0.1, 3.1.0, 3.2.0, 3.3.0, 3.4.0-3.4.1, 4.0.0] or uninstalled; │ └─restricted by compatibility requirements with CUDA [052768ef] to versions: 4.0.0; │ └─CUDA [052768ef] log:; │ ├─possible versions are: [0.1.0, 1.0.0-1.0.2, 1.1.0] or uninstalled; │ └─restricted to versions 1 by Oceananigans [9e8cae18], leaving only versions [1.0.0-1.0.2, 1.1.0]; │ └─Oceananigans [9e8cae18] log: see above; └─restricted by compatibility requirements with NNlib [872c559c] to versions: [1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2] or uninstalled — no versions left; └─NNlib [872c559c] log:; ├─possible versions are: [0.3.2, 0.4.0-0.4.3, 0.5.0, 0.6.0-0.6.6, 0.7.0-0.7.3] or uninstalled; └─restricted by compatibility requirements with CUDA [052768ef] to versions: [0.6.5-0.6.6, 0.7.0-0.7.3]; └─CUDA [052768ef] log: see above; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/796
https://github.com/CliMA/Oceananigans.jl/pull/797:17,Performance,load,loading,17,Fixes GPU to CPU loading and writing fields with function boundary conditions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/797
https://github.com/CliMA/Oceananigans.jl/pull/799:281,Availability,error,error,281,"In this PR I'll be updating the documentation, especially the model setup section, to reflect the many recent changes and additions to the API. To avoid this problem of documentation going out of date, I will also be converting and adding `jldoctest`s so we should actually get an error when documentation goes out of date. A lot of `@example` blocks don't run anymore and we even have a `jldoctest` failure but Travis CI seems to pass so I'll look into making Travis CI fail the doc build if a doctest fails. If we have a lot of doctests it might actually be easy to keep them updated: https://juliadocs.github.io/Documenter.jl/latest/man/doctests/#Fixing-Outdated-Doctests",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/799
https://github.com/CliMA/Oceananigans.jl/pull/799:400,Availability,failure,failure,400,"In this PR I'll be updating the documentation, especially the model setup section, to reflect the many recent changes and additions to the API. To avoid this problem of documentation going out of date, I will also be converting and adding `jldoctest`s so we should actually get an error when documentation goes out of date. A lot of `@example` blocks don't run anymore and we even have a `jldoctest` failure but Travis CI seems to pass so I'll look into making Travis CI fail the doc build if a doctest fails. If we have a lot of doctests it might actually be easy to keep them updated: https://juliadocs.github.io/Documenter.jl/latest/man/doctests/#Fixing-Outdated-Doctests",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/799
https://github.com/CliMA/Oceananigans.jl/pull/799:578,Deployability,update,updated,578,"In this PR I'll be updating the documentation, especially the model setup section, to reflect the many recent changes and additions to the API. To avoid this problem of documentation going out of date, I will also be converting and adding `jldoctest`s so we should actually get an error when documentation goes out of date. A lot of `@example` blocks don't run anymore and we even have a `jldoctest` failure but Travis CI seems to pass so I'll look into making Travis CI fail the doc build if a doctest fails. If we have a lot of doctests it might actually be easy to keep them updated: https://juliadocs.github.io/Documenter.jl/latest/man/doctests/#Fixing-Outdated-Doctests",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/799
https://github.com/CliMA/Oceananigans.jl/pull/799:147,Safety,avoid,avoid,147,"In this PR I'll be updating the documentation, especially the model setup section, to reflect the many recent changes and additions to the API. To avoid this problem of documentation going out of date, I will also be converting and adding `jldoctest`s so we should actually get an error when documentation goes out of date. A lot of `@example` blocks don't run anymore and we even have a `jldoctest` failure but Travis CI seems to pass so I'll look into making Travis CI fail the doc build if a doctest fails. If we have a lot of doctests it might actually be easy to keep them updated: https://juliadocs.github.io/Documenter.jl/latest/man/doctests/#Fixing-Outdated-Doctests",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/799
https://github.com/CliMA/Oceananigans.jl/pull/804:75,Deployability,deploy,deploy,75,The `GITHUB_REPOSITORY` environment variable is used by GitHub actions. We deploy from Travis so the right environment variable is `TRAVIS_REPO_SLUG`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/804
https://github.com/CliMA/Oceananigans.jl/pull/804:36,Modifiability,variab,variable,36,The `GITHUB_REPOSITORY` environment variable is used by GitHub actions. We deploy from Travis so the right environment variable is `TRAVIS_REPO_SLUG`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/804
https://github.com/CliMA/Oceananigans.jl/pull/804:119,Modifiability,variab,variable,119,The `GITHUB_REPOSITORY` environment variable is used by GitHub actions. We deploy from Travis so the right environment variable is `TRAVIS_REPO_SLUG`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/804
https://github.com/CliMA/Oceananigans.jl/pull/805:8,Modifiability,rewrite,rewrites,8,"This PR rewrites every kernel and kernel launcher to use `KernelAbstractions` rather than `GPUifyLoops`. A key new function is `launch!`:. https://github.com/CliMA/Oceananigans.jl/blob/7bc83752f72508d6147a8d2e940baf69eff762c0/src/Utils/kernel_launching.jl#L58-L69. This function launches a kernel over `layout`. Performance differences are a crucial question. To start, I've written a function `work_layout` to define the workgroup and worksize for each of our layouts:. https://github.com/CliMA/Oceananigans.jl/blob/7bc83752f72508d6147a8d2e940baf69eff762c0/src/Utils/kernel_launching.jl#L41-L54. This function may need to be improved for performance reasons. Hopefully this is the right way to use `KernelAbstractions`... cc @vchuravy, @leios",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/805
https://github.com/CliMA/Oceananigans.jl/pull/805:312,Performance,Perform,Performance,312,"This PR rewrites every kernel and kernel launcher to use `KernelAbstractions` rather than `GPUifyLoops`. A key new function is `launch!`:. https://github.com/CliMA/Oceananigans.jl/blob/7bc83752f72508d6147a8d2e940baf69eff762c0/src/Utils/kernel_launching.jl#L58-L69. This function launches a kernel over `layout`. Performance differences are a crucial question. To start, I've written a function `work_layout` to define the workgroup and worksize for each of our layouts:. https://github.com/CliMA/Oceananigans.jl/blob/7bc83752f72508d6147a8d2e940baf69eff762c0/src/Utils/kernel_launching.jl#L41-L54. This function may need to be improved for performance reasons. Hopefully this is the right way to use `KernelAbstractions`... cc @vchuravy, @leios",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/805
https://github.com/CliMA/Oceananigans.jl/pull/805:639,Performance,perform,performance,639,"This PR rewrites every kernel and kernel launcher to use `KernelAbstractions` rather than `GPUifyLoops`. A key new function is `launch!`:. https://github.com/CliMA/Oceananigans.jl/blob/7bc83752f72508d6147a8d2e940baf69eff762c0/src/Utils/kernel_launching.jl#L58-L69. This function launches a kernel over `layout`. Performance differences are a crucial question. To start, I've written a function `work_layout` to define the workgroup and worksize for each of our layouts:. https://github.com/CliMA/Oceananigans.jl/blob/7bc83752f72508d6147a8d2e940baf69eff762c0/src/Utils/kernel_launching.jl#L41-L54. This function may need to be improved for performance reasons. Hopefully this is the right way to use `KernelAbstractions`... cc @vchuravy, @leios",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/805
