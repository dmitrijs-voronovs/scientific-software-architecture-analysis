id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://root.cern/root/html532/TTVLVEntry.html:8739,Modifiability,Inherit,InheritsFrom,8739,"e(TGFrame*); virtual Bool_tTGFrame::HandleDragMotion(TGFrame*); virtual Bool_tTGFrame::HandleEvent(Event_t* event); virtual Bool_tTGWindow::HandleExpose(Event_t* event); virtual Bool_tTGFrame::HandleFocusChange(Event_t*); virtual Bool_tTGWindow::HandleIdleEvent(TGIdleHandler*); virtual Bool_tTGFrame::HandleKey(Event_t*); virtual Bool_tTGFrame::HandleMotion(Event_t*); virtual Bool_tTGFrame::HandleSelection(Event_t*); virtual Bool_tTGFrame::HandleSelectionClear(Event_t*); virtual Bool_tTGFrame::HandleSelectionRequest(Event_t*); virtual Bool_tTGWindow::HandleTimer(TTimer*); Bool_tHasAlias(); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTGObject::Hash() const; virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTGWindow::IconifyWindow(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTGFrame::Inspect() const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTGLVEntry::IsActive() const; virtual Bool_tTGFrame::IsComposite() const; Bool_tIsCut(); Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGFrame::IsEditable() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGWindow::IsMapSubwindows() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTGFrame::Layout(); static voidTQObject::LoadRQ_OBJECT(); virtual voidTGWindow::LowerWindow(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::ls(Option_t* option = """") const; virtual voidTGFrame::MapRaised(); virtual voidTGFrame::MapSubwin",MatchSource.WIKI,root/html532/TTVLVEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TTVLVEntry.html
https://root.cern/root/html532/TTVLVEntry.html:19693,Modifiability,Inherit,Inheritance,19693,"elist view viewing mode; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*TGLVEntry::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGGC*TGLVEntry::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTVLVEntry(const TGWindow* p, const TGPicture* bigpic, const TGPicture* smallpic, TGString* name, TGString** subnames, EListViewMode ViewMode); TGTreeLVEntry constructor. ~TTVLVEntry(); TGTreeLVEntry destructor. const char * ConvertAliases(); Convert all aliases into true names. Bool_t FullConverted(); Return true if converted name is alias free. void CopyItem(TTVLVEntry* dest); Copy this item's name and alias to an other. Bool_t HandleCrossing(Event_t* event); Handle mouse crossing event. Bool_t HasAlias(); Check if alias name is not empty. void PrependTilde(); Prepend a ~ to item alias. void SetItemName(const char* name); redraw this entry with new name. void SetCutType(Bool_t type = kFALSE); Set cut type. void SetExpression(const char* name, const char* alias, Bool_t cutType = kFALSE); Set the true name, alias and type of the expression, then refresh it. void Empty(); clear all names and alias. void SetToolTipText(const char* text, ",MatchSource.WIKI,root/html532/TTVLVEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TTVLVEntry.html
https://root.cern/root/html532/TTVLVEntry.html:19706,Modifiability,Inherit,Inherited,19706,"elist view viewing mode; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*TGLVEntry::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGGC*TGLVEntry::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTVLVEntry(const TGWindow* p, const TGPicture* bigpic, const TGPicture* smallpic, TGString* name, TGString** subnames, EListViewMode ViewMode); TGTreeLVEntry constructor. ~TTVLVEntry(); TGTreeLVEntry destructor. const char * ConvertAliases(); Convert all aliases into true names. Bool_t FullConverted(); Return true if converted name is alias free. void CopyItem(TTVLVEntry* dest); Copy this item's name and alias to an other. Bool_t HandleCrossing(Event_t* event); Handle mouse crossing event. Bool_t HasAlias(); Check if alias name is not empty. void PrependTilde(); Prepend a ~ to item alias. void SetItemName(const char* name); redraw this entry with new name. void SetCutType(Bool_t type = kFALSE); Set cut type. void SetExpression(const char* name, const char* alias, Bool_t cutType = kFALSE); Set the true name, alias and type of the expression, then refresh it. void Empty(); clear all names and alias. void SetToolTipText(const char* text, ",MatchSource.WIKI,root/html532/TTVLVEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TTVLVEntry.html
https://root.cern/root/html532/TTVLVEntry.html:8436,Security,Hash,Hash,8436,"NDLeave(); virtual Atom_tTGFrame::HandleDNDPosition(Int_t, Int_t, Atom_t, Int_t, Int_t); virtual Bool_tTGFrame::HandleDoubleClick(Event_t*); virtual Bool_tTGFrame::HandleDragDrop(TGFrame*, Int_t, Int_t, TGLayoutHints*); virtual Bool_tTGFrame::HandleDragEnter(TGFrame*); virtual Bool_tTGFrame::HandleDragLeave(TGFrame*); virtual Bool_tTGFrame::HandleDragMotion(TGFrame*); virtual Bool_tTGFrame::HandleEvent(Event_t* event); virtual Bool_tTGWindow::HandleExpose(Event_t* event); virtual Bool_tTGFrame::HandleFocusChange(Event_t*); virtual Bool_tTGWindow::HandleIdleEvent(TGIdleHandler*); virtual Bool_tTGFrame::HandleKey(Event_t*); virtual Bool_tTGFrame::HandleMotion(Event_t*); virtual Bool_tTGFrame::HandleSelection(Event_t*); virtual Bool_tTGFrame::HandleSelectionClear(Event_t*); virtual Bool_tTGFrame::HandleSelectionRequest(Event_t*); virtual Bool_tTGWindow::HandleTimer(TTimer*); Bool_tHasAlias(); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTGObject::Hash() const; virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTGWindow::IconifyWindow(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTGFrame::Inspect() const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTGLVEntry::IsActive() const; virtual Bool_tTGFrame::IsComposite() const; Bool_tIsCut(); Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGFrame::IsEditable() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGWindow::IsMapSubwindows() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virt",MatchSource.WIKI,root/html532/TTVLVEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TTVLVEntry.html
https://root.cern/root/html532/TTVLVEntry.html:14416,Testability,Test,TestBit,14416,"voidTGFrame::SetHeight(UInt_t h); voidSetItemName(const char* name); virtual voidTGFrame::SetLayoutBroken(Bool_t = kTRUE); virtual voidTGWindow::SetMapSubwindows(Bool_t); virtual voidTGFrame::SetMaxHeight(UInt_t h); virtual voidTGFrame::SetMaxWidth(UInt_t w); virtual voidTGFrame::SetMinHeight(UInt_t h); virtual voidTGFrame::SetMinWidth(UInt_t w); virtual voidTGWindow::SetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTGLVEntry::SetPictures(const TGPicture* bigpic = 0, const TGPicture* smallpic = 0); virtual voidTGFrame::SetSize(const TGDimension& s); voidSetSmallPic(const TGPicture* spic); virtual voidTGLVEntry::SetSubnames(const char* n1 = """", const char* n2 = """", const char* n3 = """", const char* n4 = """", const char* n5 = """", const char* n6 = """", const char* n7 = """", const char* n8 = """", const char* n9 = """", const char* n10 = """", const char* n11 = """", const char* n12 = """"); virtual voidTGLVEntry::SetTitle(const char* text); voidSetToolTipText(const char* text, Long_t delayms = 1000); voidSetTrueName(const char* name); virtual voidTObject::SetUniqueID(UInt_t uid); voidTGLVEntry::SetUserData(void* userData); virtual voidTGLVEntry::SetViewMode(EListViewMode viewMode); virtual voidTGFrame::SetWidth(UInt_t w); virtual voidTGWindow::SetWindowName(const char* name = 0); virtual voidTGFrame::SetX(Int_t x); virtual voidTGFrame::SetY(Int_t y); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTGFrame::UnmapWindow(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TTVLVEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TTVLVEntry.html
https://root.cern/root/html532/TTVLVEntry.html:14455,Testability,Test,TestBits,14455,"voidTGFrame::SetHeight(UInt_t h); voidSetItemName(const char* name); virtual voidTGFrame::SetLayoutBroken(Bool_t = kTRUE); virtual voidTGWindow::SetMapSubwindows(Bool_t); virtual voidTGFrame::SetMaxHeight(UInt_t h); virtual voidTGFrame::SetMaxWidth(UInt_t w); virtual voidTGFrame::SetMinHeight(UInt_t h); virtual voidTGFrame::SetMinWidth(UInt_t w); virtual voidTGWindow::SetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTGLVEntry::SetPictures(const TGPicture* bigpic = 0, const TGPicture* smallpic = 0); virtual voidTGFrame::SetSize(const TGDimension& s); voidSetSmallPic(const TGPicture* spic); virtual voidTGLVEntry::SetSubnames(const char* n1 = """", const char* n2 = """", const char* n3 = """", const char* n4 = """", const char* n5 = """", const char* n6 = """", const char* n7 = """", const char* n8 = """", const char* n9 = """", const char* n10 = """", const char* n11 = """", const char* n12 = """"); virtual voidTGLVEntry::SetTitle(const char* text); voidSetToolTipText(const char* text, Long_t delayms = 1000); voidSetTrueName(const char* name); virtual voidTObject::SetUniqueID(UInt_t uid); voidTGLVEntry::SetUserData(void* userData); virtual voidTGLVEntry::SetViewMode(EListViewMode viewMode); virtual voidTGFrame::SetWidth(UInt_t w); virtual voidTGWindow::SetWindowName(const char* name = 0); virtual voidTGFrame::SetX(Int_t x); virtual voidTGFrame::SetY(Int_t y); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTGFrame::UnmapWindow(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TTVLVEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TTVLVEntry.html
https://root.cern/root/html532/TTVLVEntry.html:1250,Usability,Clear,Clear,1250," TTVLVEntry(const TGWindow* p, const TGPicture* bigpic, const TGPicture* smallpic, TGString* name, TGString** subnames, EListViewMode ViewMode); virtual~TTVLVEntry(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGLVEntry::Activate(Bool_t a); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; const char*ConvertAliases(); virtual voidTObject::Copy(TObject& obje",MatchSource.WIKI,root/html532/TTVLVEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TTVLVEntry.html
https://root.cern/root/html532/TTVLVEntry.html:20654,Usability,clear,clear,20654,"rame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTVLVEntry(const TGWindow* p, const TGPicture* bigpic, const TGPicture* smallpic, TGString* name, TGString** subnames, EListViewMode ViewMode); TGTreeLVEntry constructor. ~TTVLVEntry(); TGTreeLVEntry destructor. const char * ConvertAliases(); Convert all aliases into true names. Bool_t FullConverted(); Return true if converted name is alias free. void CopyItem(TTVLVEntry* dest); Copy this item's name and alias to an other. Bool_t HandleCrossing(Event_t* event); Handle mouse crossing event. Bool_t HasAlias(); Check if alias name is not empty. void PrependTilde(); Prepend a ~ to item alias. void SetItemName(const char* name); redraw this entry with new name. void SetCutType(Bool_t type = kFALSE); Set cut type. void SetExpression(const char* name, const char* alias, Bool_t cutType = kFALSE); Set the true name, alias and type of the expression, then refresh it. void Empty(); clear all names and alias. void SetToolTipText(const char* text, Long_t delayms = 1000); Set tool tip text associated with this item. The delay is in; milliseconds (minimum 250). To remove tool tip call method with text = 0. void SetSmallPic(const TGPicture* spic); Set small picture. const char * GetAlias(); {return fAlias.Data();}. TTVLVContainer * GetContainer(); {return fContainer;}. TGItemContext * GetContext(); {return fContext;}. const char * GetConvName(); {return fConvName;}. const char * GetTrueName(); {return fTrueName.Data();}. TGToolTip * GetTip(); {return fTip;}. Bool_t IsCut(); {return fIsCut;}. void SetAlias(const char* alias); {fAlias = alias;}. void SetTrueName(const char* name); {fTrueName = name;}. » Last changed: root/treeviewer:$Id: TTVLVContainer.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TTVLVEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TTVLVEntry.html
https://root.cern/root/html532/TTVRecord.html:1177,Availability,Error,Error,1177," TTVRecord(); TTVRecord(const TTVRecord&); virtual~TTVRecord(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExecuteUserCode(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFormFrom(TTreeViewer* tv); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtua",MatchSource.WIKI,root/html532/TTVRecord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TTVRecord.html
https://root.cern/root/html532/TTVRecord.html:1306,Availability,error,error,1306," TTVRecord(); TTVRecord(const TTVRecord&); virtual~TTVRecord(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExecuteUserCode(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFormFrom(TTreeViewer* tv); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtua",MatchSource.WIKI,root/html532/TTVRecord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TTVRecord.html
https://root.cern/root/html532/TTVRecord.html:1390,Availability,error,error,1390," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExecuteUserCode(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFormFrom(TTreeViewer* tv); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const char*GetUserCode() const; const char*GetX() const; const char*GetY() const; const char*GetZ() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; Bool_tHasUserCode() const; virtual voidTObject::Info(const char* me",MatchSource.WIKI,root/html532/TTVRecord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TTVRecord.html
https://root.cern/root/html532/TTVRecord.html:4099,Deployability,TOGGLE,TOGGLE,4099,"t char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TTVRecord&operator=(const TTVRecord&); virtual voidTObject::Paint(Option_t* option = """"); voidPlugIn(TTreeViewer* tv); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidSaveSource(ofstream& out); voidSetAutoexec(Bool_t autoexec = kTRUE)TOGGLE GETTER ; voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCut(const char* cut = """", const char* cal = ""-empty-""); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetName(const char* name = """"); static voidTObject::SetObjectStat(Bool_t stat); voidSetOption(const char* option = """"); voidSetRC(Bool_t redirect = kFALSE, Bool_t cut = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetUserCode(const char* code, Bool_t autoexec = kTRUE)MENU ; voidSetX(const char* x = """", const char* xal = ""-empty-""); voidSetY(const char* y = """", const char* yal = ""-empty-""); voidSetZ(const char* z = """", const char* zal = ""-empty-""); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; ",MatchSource.WIKI,root/html532/TTVRecord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TTVRecord.html
https://root.cern/root/html532/TTVRecord.html:2449,Modifiability,Inherit,InheritsFrom,2449,"px, Int_t py); voidExecuteUserCode(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFormFrom(TTreeViewer* tv); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const char*GetUserCode() const; const char*GetX() const; const char*GetY() const; const char*GetZ() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; Bool_tHasUserCode() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; Bool_tMustExecuteCode() const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::oper",MatchSource.WIKI,root/html532/TTVRecord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TTVRecord.html
https://root.cern/root/html532/TTVRecord.html:2515,Modifiability,Inherit,InheritsFrom,2515,"onst char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFormFrom(TTreeViewer* tv); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const char*GetUserCode() const; const char*GetX() const; const char*GetY() const; const char*GetZ() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; Bool_tHasUserCode() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; Bool_tMustExecuteCode() const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, voi",MatchSource.WIKI,root/html532/TTVRecord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TTVRecord.html
https://root.cern/root/html532/TTVRecord.html:6292,Modifiability,Inherit,Inheritance,6292,"t_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. Bool_tfAutoexecautoexecute user code command; TStringfCut; TStringfCutAliascut expression and alias; Bool_tfCutEnabledtrue if current cut is active; TStringfNamename of this record; TStringfOptiongraphic option; Bool_tfScanRedirectedredirect switch; TStringfUserCodecommand executed when record is conected; TStringfX; TStringfXAliasX expression and alias; TStringfY; TStringfYAliasY expression and alias; TStringfZ; TStringfZAliasZ expression and alias. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTVRecord(); TTVRecord default constructor. void ExecuteUserCode(); Execute user-defined code. void FormFrom(TTreeViewer* tv); Populate members from treeviewer tv. void PlugIn(TTreeViewer* tv); Change treeviewer status to this record. void SaveSource(ofstream& out); Save the TTVRecord in a C++ macro file. TTVRecord(). ~TTVRecord(); {}. const char * GetX() const; {return fX;}. const char * GetY() const; {return fY;}. const char * GetZ() const; {return fZ;}. const char * GetName() const; {return fName;}. const char * GetUserCode() const; {return fUserCode;}. Bool_t HasUserCode() const; {return fUserCode.Length() != 0 ? kTRUE : kFALSE;}. Bool_t MustExecuteCode() const; {return fAutoexec;}. void SetAutoexec(Bool_t autoexec = kTRUE); {fAutoexec=autoexec;}. void SetName(const char* name = """"); {fName = name;}. void SetX(const char* x = """", const char* xal = ""-empty-""); {fX = x; fXAlias = xal;}. void SetY(const char* y = """", const char* yal =",MatchSource.WIKI,root/html532/TTVRecord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TTVRecord.html
https://root.cern/root/html532/TTVRecord.html:6305,Modifiability,Inherit,Inherited,6305,"t_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. Bool_tfAutoexecautoexecute user code command; TStringfCut; TStringfCutAliascut expression and alias; Bool_tfCutEnabledtrue if current cut is active; TStringfNamename of this record; TStringfOptiongraphic option; Bool_tfScanRedirectedredirect switch; TStringfUserCodecommand executed when record is conected; TStringfX; TStringfXAliasX expression and alias; TStringfY; TStringfYAliasY expression and alias; TStringfZ; TStringfZAliasZ expression and alias. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTVRecord(); TTVRecord default constructor. void ExecuteUserCode(); Execute user-defined code. void FormFrom(TTreeViewer* tv); Populate members from treeviewer tv. void PlugIn(TTreeViewer* tv); Change treeviewer status to this record. void SaveSource(ofstream& out); Save the TTVRecord in a C++ macro file. TTVRecord(). ~TTVRecord(); {}. const char * GetX() const; {return fX;}. const char * GetY() const; {return fY;}. const char * GetZ() const; {return fZ;}. const char * GetName() const; {return fName;}. const char * GetUserCode() const; {return fUserCode;}. Bool_t HasUserCode() const; {return fUserCode.Length() != 0 ? kTRUE : kFALSE;}. Bool_t MustExecuteCode() const; {return fAutoexec;}. void SetAutoexec(Bool_t autoexec = kTRUE); {fAutoexec=autoexec;}. void SetName(const char* name = """"); {fName = name;}. void SetX(const char* x = """", const char* xal = ""-empty-""); {fX = x; fXAlias = xal;}. void SetY(const char* y = """", const char* yal =",MatchSource.WIKI,root/html532/TTVRecord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TTVRecord.html
https://root.cern/root/html532/TTVRecord.html:6538,Modifiability,PlugIn,PlugIn,6538,"Object::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. Bool_tfAutoexecautoexecute user code command; TStringfCut; TStringfCutAliascut expression and alias; Bool_tfCutEnabledtrue if current cut is active; TStringfNamename of this record; TStringfOptiongraphic option; Bool_tfScanRedirectedredirect switch; TStringfUserCodecommand executed when record is conected; TStringfX; TStringfXAliasX expression and alias; TStringfY; TStringfYAliasY expression and alias; TStringfZ; TStringfZAliasZ expression and alias. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTVRecord(); TTVRecord default constructor. void ExecuteUserCode(); Execute user-defined code. void FormFrom(TTreeViewer* tv); Populate members from treeviewer tv. void PlugIn(TTreeViewer* tv); Change treeviewer status to this record. void SaveSource(ofstream& out); Save the TTVRecord in a C++ macro file. TTVRecord(). ~TTVRecord(); {}. const char * GetX() const; {return fX;}. const char * GetY() const; {return fY;}. const char * GetZ() const; {return fZ;}. const char * GetName() const; {return fName;}. const char * GetUserCode() const; {return fUserCode;}. Bool_t HasUserCode() const; {return fUserCode.Length() != 0 ? kTRUE : kFALSE;}. Bool_t MustExecuteCode() const; {return fAutoexec;}. void SetAutoexec(Bool_t autoexec = kTRUE); {fAutoexec=autoexec;}. void SetName(const char* name = """"); {fName = name;}. void SetX(const char* x = """", const char* xal = ""-empty-""); {fX = x; fXAlias = xal;}. void SetY(const char* y = """", const char* yal = ""-empty-""); {fY = y; fYAlias = yal;}. void SetZ(const char* z = """", const char* zal = ""-empty-""); {fZ = z; fZAlias = zal;}. void SetCut(const char* cut = """", const char* cal = ""-empty-""); {fCut = cut; fCutAlias = cal;}. void SetOption(const char* op",MatchSource.WIKI,root/html532/TTVRecord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TTVRecord.html
https://root.cern/root/html532/TTVRecord.html:2312,Security,Hash,Hash,2312,"0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExecuteUserCode(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFormFrom(TTreeViewer* tv); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const char*GetUserCode() const; const char*GetX() const; const char*GetY() const; const char*GetZ() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; Bool_tHasUserCode() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; Bool_tMustExecuteCode() const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::opera",MatchSource.WIKI,root/html532/TTVRecord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TTVRecord.html
https://root.cern/root/html532/TTVRecord.html:5038,Testability,Test,TestBit,5038,"ct::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TTVRecord&operator=(const TTVRecord&); virtual voidTObject::Paint(Option_t* option = """"); voidPlugIn(TTreeViewer* tv); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidSaveSource(ofstream& out); voidSetAutoexec(Bool_t autoexec = kTRUE)TOGGLE GETTER ; voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCut(const char* cut = """", const char* cal = ""-empty-""); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetName(const char* name = """"); static voidTObject::SetObjectStat(Bool_t stat); voidSetOption(const char* option = """"); voidSetRC(Bool_t redirect = kFALSE, Bool_t cut = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetUserCode(const char* code, Bool_t autoexec = kTRUE)MENU ; voidSetX(const char* x = """", const char* xal = ""-empty-""); voidSetY(const char* y = """", const char* yal = ""-empty-""); voidSetZ(const char* z = """", const char* zal = ""-empty-""); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TTVRecord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TTVRecord.html
https://root.cern/root/html532/TTVRecord.html:5077,Testability,Test,TestBits,5077,"ct::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TTVRecord&operator=(const TTVRecord&); virtual voidTObject::Paint(Option_t* option = """"); voidPlugIn(TTreeViewer* tv); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidSaveSource(ofstream& out); voidSetAutoexec(Bool_t autoexec = kTRUE)TOGGLE GETTER ; voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCut(const char* cut = """", const char* cal = ""-empty-""); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetName(const char* name = """"); static voidTObject::SetObjectStat(Bool_t stat); voidSetOption(const char* option = """"); voidSetRC(Bool_t redirect = kFALSE, Bool_t cut = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetUserCode(const char* code, Bool_t autoexec = kTRUE)MENU ; voidSetX(const char* x = """", const char* xal = ""-empty-""); voidSetY(const char* y = """", const char* yal = ""-empty-""); voidSetZ(const char* z = """", const char* zal = ""-empty-""); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TTVRecord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TTVRecord.html
https://root.cern/root/html532/TTVRecord.html:637,Usability,Clear,Clear,637," TTVRecord(); TTVRecord(const TTVRecord&); virtual~TTVRecord(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExecuteUserCode(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFormFrom(TTreeViewer* tv); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtua",MatchSource.WIKI,root/html532/TTVRecord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TTVRecord.html
https://root.cern/root/html532/TTVSession.html:1246,Availability,Error,Error,1246," TTVSession(TTreeViewer* tv); TTVSession(const TTVSession&); virtual~TTVSession(); voidTObject::AbstractMethod(const char* method) const; TTVRecord*AddRecord(Bool_t fromFile = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TTVRecord*First(); TTVRecord*GetCurrent(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetEntries(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObject",MatchSource.WIKI,root/html532/TTVSession.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TTVSession.html
https://root.cern/root/html532/TTVSession.html:1375,Availability,error,error,1375,"t TTVSession&); virtual~TTVSession(); voidTObject::AbstractMethod(const char* method) const; TTVRecord*AddRecord(Bool_t fromFile = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TTVRecord*First(); TTVRecord*GetCurrent(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetEntries(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TTVRecord*GetRecord(Int_t i); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const ",MatchSource.WIKI,root/html532/TTVSession.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TTVSession.html
https://root.cern/root/html532/TTVSession.html:1459,Availability,error,error,1459,") const; TTVRecord*AddRecord(Bool_t fromFile = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TTVRecord*First(); TTVRecord*GetCurrent(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetEntries(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TTVRecord*GetRecord(Int_t i); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) cons",MatchSource.WIKI,root/html532/TTVSession.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TTVSession.html
https://root.cern/root/html532/TTVSession.html:6165,Deployability,Update,UpdateRecord,6165,"rite(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Int_tfCurrentindex of current record; TClonesArray*fListlist of TV records; TStringfNamename of this session; Int_tfRecordsnumber of records; TTreeViewer*fViewerassociated tree viewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTVSession(TTreeViewer* tv); constructor. ~TTVSession(); destructor. TTVRecord * AddRecord(Bool_t fromFile = kFALSE); add a record. TTVRecord * GetRecord(Int_t i); return record at index i. void SetRecordName(const char* name); Set record name. void RemoveLastRecord(); --- Remove current record from list. void Show(TTVRecord* rec); Display record rec. void SaveSource(ofstream& out); Save the TTVSession in a C++ macro file. void UpdateRecord(const char* name); --- Updates current record according to new X, Y, Z settings. const char * GetName() const; {return fName;}. void SetName(const char* name); {fName = name;}. TTVSession(TTreeViewer* tv). Int_t GetEntries(); {return fRecords;}. TTVRecord * GetCurrent(); {return GetRecord(fCurrent);}. TTVRecord * First(); {return GetRecord(0);}. TTVRecord * Last(); {return GetRecord(fRecords-1);}. TTVRecord * Next(); {return GetRecord(fCurrent+1);}. TTVRecord * Previous(); {return GetRecord(fCurrent-1);}. » Last changed: root/treeviewer:$Id: TTVSession.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TTVSession.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TTVSession.html
https://root.cern/root/html532/TTVSession.html:6201,Deployability,Update,Updates,6201,"rite(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Int_tfCurrentindex of current record; TClonesArray*fListlist of TV records; TStringfNamename of this session; Int_tfRecordsnumber of records; TTreeViewer*fViewerassociated tree viewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTVSession(TTreeViewer* tv); constructor. ~TTVSession(); destructor. TTVRecord * AddRecord(Bool_t fromFile = kFALSE); add a record. TTVRecord * GetRecord(Int_t i); return record at index i. void SetRecordName(const char* name); Set record name. void RemoveLastRecord(); --- Remove current record from list. void Show(TTVRecord* rec); Display record rec. void SaveSource(ofstream& out); Save the TTVSession in a C++ macro file. void UpdateRecord(const char* name); --- Updates current record according to new X, Y, Z settings. const char * GetName() const; {return fName;}. void SetName(const char* name); {fName = name;}. TTVSession(TTreeViewer* tv). Int_t GetEntries(); {return fRecords;}. TTVRecord * GetCurrent(); {return GetRecord(fCurrent);}. TTVRecord * First(); {return GetRecord(0);}. TTVRecord * Last(); {return GetRecord(fRecords-1);}. TTVRecord * Next(); {return GetRecord(fCurrent+1);}. TTVRecord * Previous(); {return GetRecord(fCurrent-1);}. » Last changed: root/treeviewer:$Id: TTVSession.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TTVSession.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TTVSession.html
https://root.cern/root/html532/TTVSession.html:2422,Modifiability,Inherit,InheritsFrom,2422,"hod, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TTVRecord*First(); TTVRecord*GetCurrent(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetEntries(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TTVRecord*GetRecord(Int_t i); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; TTVRecord*Last(); virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; TTVRecord*Next(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject:",MatchSource.WIKI,root/html532/TTVSession.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TTVSession.html
https://root.cern/root/html532/TTVSession.html:2488,Modifiability,Inherit,InheritsFrom,2488,"ecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TTVRecord*First(); TTVRecord*GetCurrent(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetEntries(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TTVRecord*GetRecord(Int_t i); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; TTVRecord*Last(); virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; TTVRecord*Next(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz",MatchSource.WIKI,root/html532/TTVSession.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TTVSession.html
https://root.cern/root/html532/TTVSession.html:5656,Modifiability,Inherit,Inheritance,5656,"s(UInt_t f) const; voidUpdateRecord(const char* name); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Int_tfCurrentindex of current record; TClonesArray*fListlist of TV records; TStringfNamename of this session; Int_tfRecordsnumber of records; TTreeViewer*fViewerassociated tree viewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTVSession(TTreeViewer* tv); constructor. ~TTVSession(); destructor. TTVRecord * AddRecord(Bool_t fromFile = kFALSE); add a record. TTVRecord * GetRecord(Int_t i); return record at index i. void SetRecordName(const char* name); Set record name. void RemoveLastRecord(); --- Remove current record from list. void Show(TTVRecord* rec); Display record rec. void SaveSource(ofstream& out); Save the TTVSession in a C++ macro file. void UpdateRecord(const char* name); --- Updates current record according to new X, Y, Z settings. const char * GetName() const; {return fName;}. void SetName(const char* name); {fName = name;}. TTVSession(TTreeViewer* tv). Int_t GetEntries(); {return fRecords;}. TTVRecord * GetCurrent(); {return GetRecord(fCurrent);}. TTVRecord * First(); {return GetRecord(0);}. TTVRecord * Last(); {return GetRecord(fRecords-1);}. TTVRecord * Next(); {return GetRecord(fCurrent+1);}. TTVRecord * Previous(); {return GetRecord(fCurrent",MatchSource.WIKI,root/html532/TTVSession.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TTVSession.html
https://root.cern/root/html532/TTVSession.html:5669,Modifiability,Inherit,Inherited,5669,"s(UInt_t f) const; voidUpdateRecord(const char* name); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Int_tfCurrentindex of current record; TClonesArray*fListlist of TV records; TStringfNamename of this session; Int_tfRecordsnumber of records; TTreeViewer*fViewerassociated tree viewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTVSession(TTreeViewer* tv); constructor. ~TTVSession(); destructor. TTVRecord * AddRecord(Bool_t fromFile = kFALSE); add a record. TTVRecord * GetRecord(Int_t i); return record at index i. void SetRecordName(const char* name); Set record name. void RemoveLastRecord(); --- Remove current record from list. void Show(TTVRecord* rec); Display record rec. void SaveSource(ofstream& out); Save the TTVSession in a C++ macro file. void UpdateRecord(const char* name); --- Updates current record according to new X, Y, Z settings. const char * GetName() const; {return fName;}. void SetName(const char* name); {fName = name;}. TTVSession(TTreeViewer* tv). Int_t GetEntries(); {return fRecords;}. TTVRecord * GetCurrent(); {return GetRecord(fCurrent);}. TTVRecord * First(); {return GetRecord(0);}. TTVRecord * Last(); {return GetRecord(fRecords-1);}. TTVRecord * Next(); {return GetRecord(fCurrent+1);}. TTVRecord * Previous(); {return GetRecord(fCurrent",MatchSource.WIKI,root/html532/TTVSession.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TTVSession.html
https://root.cern/root/html532/TTVSession.html:2312,Security,Hash,Hash,2312,"ject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TTVRecord*First(); TTVRecord*GetCurrent(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetEntries(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TTVRecord*GetRecord(Int_t i); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; TTVRecord*Last(); virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; TTVRecord*Next(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr",MatchSource.WIKI,root/html532/TTVSession.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TTVSession.html
https://root.cern/root/html532/TTVSession.html:4635,Testability,Test,TestBit,4635,"e(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TTVSession&operator=(const TTVSession&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); TTVRecord*Previous(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidRemoveLastRecord(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidSaveSource(ofstream& out); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); voidSetRecordName(const char* name); virtual voidTObject::SetUniqueID(UInt_t uid); voidShow(TTVRecord* rec); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidUpdateRecord(const char* name); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TTVSession.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TTVSession.html
https://root.cern/root/html532/TTVSession.html:4674,Testability,Test,TestBits,4674,"e(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TTVSession&operator=(const TTVSession&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); TTVRecord*Previous(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidRemoveLastRecord(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidSaveSource(ofstream& out); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); voidSetRecordName(const char* name); virtual voidTObject::SetUniqueID(UInt_t uid); voidShow(TTVRecord* rec); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidUpdateRecord(const char* name); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TTVSession.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TTVSession.html
https://root.cern/root/html532/TTVSession.html:706,Usability,Clear,Clear,706," TTVSession(TTreeViewer* tv); TTVSession(const TTVSession&); virtual~TTVSession(); voidTObject::AbstractMethod(const char* method) const; TTVRecord*AddRecord(Bool_t fromFile = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TTVRecord*First(); TTVRecord*GetCurrent(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetEntries(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObject",MatchSource.WIKI,root/html532/TTVSession.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TTVSession.html
https://root.cern/root/html532/TUDPSocket.html:1719,Availability,Error,Error,1719,"ort); TUDPSocket(const char* host, const char* service); TUDPSocket(const char* host, Int_t port); TUDPSocket(Int_t descriptor, const char* sockpath); virtual~TUDPSocket(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; UInt_tGetBytesRecv() const; UInt_tGetBytesSent() const; Int_tGetCompressionAlgorithm() const; Int_tGetCompressionLevel() const; Int_tGetCompressionSettings() const; virtual Int_tGetDescriptor() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetErrorCode() const; virtual const char*TObject::GetIconName() const; TInetAddressGetInetAddress() const; TTimeStampGetLastUsage(); virtual TInetAddressGetLocalInetAddress(",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:1848,Availability,error,error,1848,"onst char* sockpath); virtual~TUDPSocket(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; UInt_tGetBytesRecv() const; UInt_tGetBytesSent() const; Int_tGetCompressionAlgorithm() const; Int_tGetCompressionLevel() const; Int_tGetCompressionSettings() const; virtual Int_tGetDescriptor() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetErrorCode() const; virtual const char*TObject::GetIconName() const; TInetAddressGetInetAddress() const; TTimeStampGetLastUsage(); virtual TInetAddressGetLocalInetAddress(); virtual Int_tGetLocalPort(); virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t p",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:1932,Availability,error,error,1932,"method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; UInt_tGetBytesRecv() const; UInt_tGetBytesSent() const; Int_tGetCompressionAlgorithm() const; Int_tGetCompressionLevel() const; Int_tGetCompressionSettings() const; virtual Int_tGetDescriptor() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetErrorCode() const; virtual const char*TObject::GetIconName() const; TInetAddressGetInetAddress() const; TTimeStampGetLastUsage(); virtual TInetAddressGetLocalInetAddress(); virtual Int_tGetLocalPort(); virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Int_tGetOption(ESockOptions",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:4071,Availability,error,error,4071,"Int_tGetServType() const; static ULong64_tGetSocketBytesRecv(); static ULong64_tGetSocketBytesSent(); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const char*GetUrl() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tIsValid() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidNetError(const char* where, Int_t error); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual Int_tReconnect(); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tRecv(TMessage*& mess); virtual Int_tRecv(Int_t& status, Int_t& kind); virtual Int_tRecv(char* mess, Int_t max); virtual Int_tRecv(char* mess, Int_t max, Int_t& kind); virtual Int_tRecvRaw(void* ",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:12394,Availability,down,down,12394,"y of the socket. Every socket is added to the TROOT; sockets list which will make sure that any open sockets are properly; closed on program termination. TUDPSocket(const char* sockpath); Create a socket in the Unix domain on 'sockpath'.; Returns when connection has been accepted by the server. Use IsValid(); to check the validity of the socket. Every socket is added to the TROOT; sockets list which will make sure that any open sockets are properly; closed on program termination. TUDPSocket(Int_t descriptor); Create a socket. The socket will adopt previously opened TCP socket with; descriptor desc. TUDPSocket(Int_t descriptor, const char* sockpath); Create a socket. The socket will adopt previously opened Unix socket with; descriptor desc. The sockpath arg is for info purposes only. Use; this method to adopt e.g. a socket created via socketpair(). TUDPSocket(const TUDPSocket& s); TUDPSocket copy ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitely Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Se",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:12704,Availability,error,error,12704,"ket. Every socket is added to the TROOT; sockets list which will make sure that any open sockets are properly; closed on program termination. TUDPSocket(Int_t descriptor); Create a socket. The socket will adopt previously opened TCP socket with; descriptor desc. TUDPSocket(Int_t descriptor, const char* sockpath); Create a socket. The socket will adopt previously opened Unix socket with; descriptor desc. The sockpath arg is for info purposes only. Use; this method to adopt e.g. a socket created via socketpair(). TUDPSocket(const TUDPSocket& s); TUDPSocket copy ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitely Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:12838,Availability,error,error,12838,"n program termination. TUDPSocket(Int_t descriptor); Create a socket. The socket will adopt previously opened TCP socket with; descriptor desc. TUDPSocket(Int_t descriptor, const char* sockpath); Create a socket. The socket will adopt previously opened Unix socket with; descriptor desc. The sockpath arg is for info purposes only. Use; this method to adopt e.g. a socket created via socketpair(). TUDPSocket(const TUDPSocket& s); TUDPSocket copy ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitely Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" fiel",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:13029,Availability,avail,available,13029," socket. The socket will adopt previously opened Unix socket with; descriptor desc. The sockpath arg is for info purposes only. Use; this method to adopt e.g. a socket created via socketpair(). TUDPSocket(const TUDPSocket& s); TUDPSocket copy ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitely Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an ackno",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:13337,Availability,error,error,13337,"tor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitely Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character string buffer. Use kind to set the TMessage ""what"" field.; Returns the number of bytes in the string str that were sent",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:13544,Availability,error,error,13544,"dtor (without; option ""force"", call explicitely Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character string buffer. Use kind to set the TMessage ""what"" field.; Returns the number of bytes in the string str that were sent and -1 in; case of error. In case the kind has been or'ed with kMESS_ACK, the call; will only return after having received an acknowledgement, making the; sending process synchronous. Int_t Send(const TMessage& mess",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:13930,Availability,error,error,13930,"d, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character string buffer. Use kind to set the TMessage ""what"" field.; Returns the number of bytes in the string str that were sent and -1 in; case of error. In case the kind has been or'ed with kMESS_ACK, the call; will only return after having received an acknowledgement, making the; sending process synchronous. Int_t Send(const TMessage& mess); Send a TMessage object. Returns the number of bytes in the TMessage; that were sent and -1 in case of error. In case the TMessage::What; has been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EP",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:14308,Availability,error,error,14308,"has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character string buffer. Use kind to set the TMessage ""what"" field.; Returns the number of bytes in the string str that were sent and -1 in; case of error. In case the kind has been or'ed with kMESS_ACK, the call; will only return after having received an acknowledgement, making the; sending process synchronous. Int_t Send(const TMessage& mess); Send a TMessage object. Returns the number of bytes in the TMessage; that were sent and -1 in case of error. In case the TMessage::What; has been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET).; support for streaming TStreamerInfo added by Rene Brun May 2008; support for streaming TProcessID added by Rene Brun June 2008. Int_t SendObject(const TObject* obj, Int_t kind = kMESS_OBJECT); Send an object. Returns the number of bytes sent and -1 in case of error.; In case the ""kind"" has been or'ed with kMESS_ACK, the call will only; return after having re",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:14609,Availability,error,error,14609," been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character string buffer. Use kind to set the TMessage ""what"" field.; Returns the number of bytes in the string str that were sent and -1 in; case of error. In case the kind has been or'ed with kMESS_ACK, the call; will only return after having received an acknowledgement, making the; sending process synchronous. Int_t Send(const TMessage& mess); Send a TMessage object. Returns the number of bytes in the TMessage; that were sent and -1 in case of error. In case the TMessage::What; has been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET).; support for streaming TStreamerInfo added by Rene Brun May 2008; support for streaming TProcessID added by Rene Brun June 2008. Int_t SendObject(const TObject* obj, Int_t kind = kMESS_OBJECT); Send an object. Returns the number of bytes sent and -1 in case of error.; In case the ""kind"" has been or'ed with kMESS_ACK, the call will only; return after having received an acknowledgement, making the sending; synchronous. Int_t SendRaw(const void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Send a raw buffer of specified length. Using option kOob one can send; OOB data. Returns the number of bytes sent or -1 in case of error.; Returns -4 in case of ",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:15170,Availability,error,error,15170,"NG); Send a character string buffer. Use kind to set the TMessage ""what"" field.; Returns the number of bytes in the string str that were sent and -1 in; case of error. In case the kind has been or'ed with kMESS_ACK, the call; will only return after having received an acknowledgement, making the; sending process synchronous. Int_t Send(const TMessage& mess); Send a TMessage object. Returns the number of bytes in the TMessage; that were sent and -1 in case of error. In case the TMessage::What; has been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET).; support for streaming TStreamerInfo added by Rene Brun May 2008; support for streaming TProcessID added by Rene Brun June 2008. Int_t SendObject(const TObject* obj, Int_t kind = kMESS_OBJECT); Send an object. Returns the number of bytes sent and -1 in case of error.; In case the ""kind"" has been or'ed with kMESS_ACK, the call will only; return after having received an acknowledgement, making the sending; synchronous. Int_t SendRaw(const void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Send a raw buffer of specified length. Using option kOob one can send; OOB data. Returns the number of bytes sent or -1 in case of error.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). void SendStreamerInfos(const TMessage& mess); Check if TStreamerInfo must be sent. The list of TStreamerInfo of classes; in the object in the message is in the fInfos list of the message.; We send only the TStreamerInfos not yet sent on this socket. void SendProcessIDs(const TMessage& mess); Check if TProcessIDs must be sent. The list of TProcessIDs; in the object in the message is found by looking in the TMessage bits.; We send only the TProcessIDs not yet send on th",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:15543,Availability,error,error,15543,"ge object. Returns the number of bytes in the TMessage; that were sent and -1 in case of error. In case the TMessage::What; has been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET).; support for streaming TStreamerInfo added by Rene Brun May 2008; support for streaming TProcessID added by Rene Brun June 2008. Int_t SendObject(const TObject* obj, Int_t kind = kMESS_OBJECT); Send an object. Returns the number of bytes sent and -1 in case of error.; In case the ""kind"" has been or'ed with kMESS_ACK, the call will only; return after having received an acknowledgement, making the sending; synchronous. Int_t SendRaw(const void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Send a raw buffer of specified length. Using option kOob one can send; OOB data. Returns the number of bytes sent or -1 in case of error.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). void SendStreamerInfos(const TMessage& mess); Check if TStreamerInfo must be sent. The list of TStreamerInfo of classes; in the object in the message is in the fInfos list of the message.; We send only the TStreamerInfos not yet sent on this socket. void SendProcessIDs(const TMessage& mess); Check if TProcessIDs must be sent. The list of TProcessIDs; in the object in the message is found by looking in the TMessage bits.; We send only the TProcessIDs not yet send on this socket. Int_t Recv(char* mess, Int_t max); Receive a character string message of maximum max length. The expected; message must be of type kMESS_STRING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:16403,Availability,error,error,16403,"ndRecvOptions opt = kDefault); Send a raw buffer of specified length. Using option kOob one can send; OOB data. Returns the number of bytes sent or -1 in case of error.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). void SendStreamerInfos(const TMessage& mess); Check if TStreamerInfo must be sent. The list of TStreamerInfo of classes; in the object in the message is in the fInfos list of the message.; We send only the TStreamerInfos not yet sent on this socket. void SendProcessIDs(const TMessage& mess); Check if TProcessIDs must be sent. The list of TProcessIDs; in the object in the message is found by looking in the TMessage bits.; We send only the TProcessIDs not yet send on this socket. Int_t Recv(char* mess, Int_t max); Receive a character string message of maximum max length. The expected; message must be of type kMESS_STRING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int_t max, Int_t& kind); Receive a character string message of maximum max length. Returns in; kind the message type. Returns length of received string+4 (can be 0 if; other side of connection is closed) or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is nothing to be read). Int_t Recv(Int_t& status, Int_t& kind); Receives a status and a message type. Returns length of received; integers, 2*sizeof(Int_t) (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking; socket would block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. ",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:16739,Availability,error,error,16739,"ss); Check if TStreamerInfo must be sent. The list of TStreamerInfo of classes; in the object in the message is in the fInfos list of the message.; We send only the TStreamerInfos not yet sent on this socket. void SendProcessIDs(const TMessage& mess); Check if TProcessIDs must be sent. The list of TProcessIDs; in the object in the message is found by looking in the TMessage bits.; We send only the TProcessIDs not yet send on this socket. Int_t Recv(char* mess, Int_t max); Receive a character string message of maximum max length. The expected; message must be of type kMESS_STRING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int_t max, Int_t& kind); Receive a character string message of maximum max length. Returns in; kind the message type. Returns length of received string+4 (can be 0 if; other side of connection is closed) or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is nothing to be read). Int_t Recv(Int_t& status, Int_t& kind); Receives a status and a message type. Returns length of received; integers, 2*sizeof(Int_t) (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking; socket would block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns ",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:17029,Availability,error,error,17029,"sent. The list of TProcessIDs; in the object in the message is found by looking in the TMessage bits.; We send only the TProcessIDs not yet send on this socket. Int_t Recv(char* mess, Int_t max); Receive a character string message of maximum max length. The expected; message must be of type kMESS_STRING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int_t max, Int_t& kind); Receive a character string message of maximum max length. Returns in; kind the message type. Returns length of received string+4 (can be 0 if; other side of connection is closed) or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is nothing to be read). Int_t Recv(Int_t& status, Int_t& kind); Receives a status and a message type. Returns length of received; integers, 2*sizeof(Int_t) (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking; socket would block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containin",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:17321,Availability,error,error,17321,"ING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int_t max, Int_t& kind); Receive a character string message of maximum max length. Returns in; kind the message type. Returns length of received string+4 (can be 0 if; other side of connection is closed) or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is nothing to be read). Int_t Recv(Int_t& status, Int_t& kind); Receives a status and a message type. Returns length of received; integers, 2*sizeof(Int_t) (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking; socket would block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will b",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:17730,Availability,error,error,17730," or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is nothing to be read). Int_t Recv(Int_t& status, Int_t& kind); Receives a status and a message type. Returns length of received; integers, 2*sizeof(Int_t) (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking; socket would block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will be deleted and the; method returns kTRUE. Int_t SetOption(ESockOptions opt, Int_t val); Set socket options. Int_t GetOption(ESockOptions opt, Int_t& val); Get socket options. Returns -1 in case of error. Int_t GetErrorCode() const; Returns error code. Meaning depends on context where it is called.; If no error condition returns 0 else a value < 0.; For example see TServerSocket ctor. void SetCompressionAlgorithm(Int_t al",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:18494,Availability,error,error,18494,"e mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will be deleted and the; method returns kTRUE. Int_t SetOption(ESockOptions opt, Int_t val); Set socket options. Int_t GetOption(ESockOptions opt, Int_t& val); Get socket options. Returns -1 in case of error. Int_t GetErrorCode() const; Returns error code. Meaning depends on context where it is called.; If no error condition returns 0 else a value < 0.; For example see TServerSocket ctor. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void SetCompressionSettings(Int_t settings = 1); Used to specify the compression level and algorithm:; settings = 100 * algorithm + level. level = 0, objects written to this file will not be compressed.; level = 1, minimal compression level but fast. level = 9, maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If compress is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value ",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:18537,Availability,error,error,18537,", Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will be deleted and the; method returns kTRUE. Int_t SetOption(ESockOptions opt, Int_t val); Set socket options. Int_t GetOption(ESockOptions opt, Int_t& val); Get socket options. Returns -1 in case of error. Int_t GetErrorCode() const; Returns error code. Meaning depends on context where it is called.; If no error condition returns 0 else a value < 0.; For example see TServerSocket ctor. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void SetCompressionSettings(Int_t settings = 1); Used to specify the compression level and algorithm:; settings = 100 * algorithm + level. level = 0, objects written to this file will not be compressed.; level = 1, minimal compression level but fast. level = 9, maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If compress is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of the argument. For example,; ROOT::C",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:18603,Availability,error,error,18603,". Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will be deleted and the; method returns kTRUE. Int_t SetOption(ESockOptions opt, Int_t val); Set socket options. Int_t GetOption(ESockOptions opt, Int_t& val); Get socket options. Returns -1 in case of error. Int_t GetErrorCode() const; Returns error code. Meaning depends on context where it is called.; If no error condition returns 0 else a value < 0.; For example see TServerSocket ctor. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void SetCompressionSettings(Int_t settings = 1); Used to specify the compression level and algorithm:; settings = 100 * algorithm + level. level = 0, objects written to this file will not be compressed.; level = 1, minimal compression level but fast. level = 9, maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If compress is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of the argument. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; ",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:19985,Availability,error,error,19985,"= 100 * algorithm + level. level = 0, objects written to this file will not be compressed.; level = 1, minimal compression level but fast. level = 9, maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If compress is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of the argument. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. void NetError(const char* where, Int_t error); Print error string depending on error code. ULong64_t GetSocketBytesSent(); Get total number of bytes sent via all sockets. ULong64_t GetSocketBytesRecv(); Get total number of bytes received via all sockets. Int_t GetCompressionAlgorithm() const. Int_t GetCompressionLevel() const. Int_t GetCompressionSettings() const. TUDPSocket(); { }. void SetDescriptor(Int_t desc); { fSocket = desc; }. TUDPSocket& operator=(const TUDPSocket& ). Option_t * GetOption() const; { return TObject::GetOption(); }. virtual ~TUDPSocket(); { Close(); }. Int_t GetDescriptor() const; { return fSocket; }. TInetAddress GetInetAddress() const; { return fAddress; }. Int_t GetPort() const; { return fAddress.GetPort(); }. const char * GetService() const; { return fService; }. Int_t GetServType() const; { return (Int_t)fServType; }. UInt_t GetBytesSent() const; { return fBytesSent; }. UInt_t GetBytesRecv() const; { return fBytesRecv; }. Int_t GetRemoteProtocol() const; { return fRemoteProtocol; }. TSecContext * GetS",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:19999,Availability,error,error,19999,"= 100 * algorithm + level. level = 0, objects written to this file will not be compressed.; level = 1, minimal compression level but fast. level = 9, maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If compress is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of the argument. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. void NetError(const char* where, Int_t error); Print error string depending on error code. ULong64_t GetSocketBytesSent(); Get total number of bytes sent via all sockets. ULong64_t GetSocketBytesRecv(); Get total number of bytes received via all sockets. Int_t GetCompressionAlgorithm() const. Int_t GetCompressionLevel() const. Int_t GetCompressionSettings() const. TUDPSocket(); { }. void SetDescriptor(Int_t desc); { fSocket = desc; }. TUDPSocket& operator=(const TUDPSocket& ). Option_t * GetOption() const; { return TObject::GetOption(); }. virtual ~TUDPSocket(); { Close(); }. Int_t GetDescriptor() const; { return fSocket; }. TInetAddress GetInetAddress() const; { return fAddress; }. Int_t GetPort() const; { return fAddress.GetPort(); }. const char * GetService() const; { return fService; }. Int_t GetServType() const; { return (Int_t)fServType; }. UInt_t GetBytesSent() const; { return fBytesSent; }. UInt_t GetBytesRecv() const; { return fBytesRecv; }. Int_t GetRemoteProtocol() const; { return fRemoteProtocol; }. TSecContext * GetS",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:20025,Availability,error,error,20025,"= 100 * algorithm + level. level = 0, objects written to this file will not be compressed.; level = 1, minimal compression level but fast. level = 9, maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If compress is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of the argument. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. void NetError(const char* where, Int_t error); Print error string depending on error code. ULong64_t GetSocketBytesSent(); Get total number of bytes sent via all sockets. ULong64_t GetSocketBytesRecv(); Get total number of bytes received via all sockets. Int_t GetCompressionAlgorithm() const. Int_t GetCompressionLevel() const. Int_t GetCompressionSettings() const. TUDPSocket(); { }. void SetDescriptor(Int_t desc); { fSocket = desc; }. TUDPSocket& operator=(const TUDPSocket& ). Option_t * GetOption() const; { return TObject::GetOption(); }. virtual ~TUDPSocket(); { Close(); }. Int_t GetDescriptor() const; { return fSocket; }. TInetAddress GetInetAddress() const; { return fAddress; }. Int_t GetPort() const; { return fAddress.GetPort(); }. const char * GetService() const; { return fService; }. Int_t GetServType() const; { return (Int_t)fServType; }. UInt_t GetBytesSent() const; { return fBytesSent; }. UInt_t GetBytesRecv() const; { return fBytesRecv; }. Int_t GetRemoteProtocol() const; { return fRemoteProtocol; }. TSecContext * GetS",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:13390,Integrability,message,message,13390,"(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitely Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character string buffer. Use kind to set the TMessage ""what"" field.; Returns the number of bytes in the string str that were sent and -1 in; case of error. In case the kind has been or'ed with kMESS_ACK, the call; will ",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:13774,Integrability,message,message,13774,". Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character string buffer. Use kind to set the TMessage ""what"" field.; Returns the number of bytes in the string str that were sent and -1 in; case of error. In case the kind has been or'ed with kMESS_ACK, the call; will only return after having received an acknowledgement, making the; sending process synchronous. Int_t Send(const TMessage& mess); Send a TMessage object. Returns the number of bytes in the TMessage; that were sent and -1 in case of error. In case the TMessage::What; has been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, makin",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:15817,Integrability,message,message,15817,"oBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET).; support for streaming TStreamerInfo added by Rene Brun May 2008; support for streaming TProcessID added by Rene Brun June 2008. Int_t SendObject(const TObject* obj, Int_t kind = kMESS_OBJECT); Send an object. Returns the number of bytes sent and -1 in case of error.; In case the ""kind"" has been or'ed with kMESS_ACK, the call will only; return after having received an acknowledgement, making the sending; synchronous. Int_t SendRaw(const void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Send a raw buffer of specified length. Using option kOob one can send; OOB data. Returns the number of bytes sent or -1 in case of error.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). void SendStreamerInfos(const TMessage& mess); Check if TStreamerInfo must be sent. The list of TStreamerInfo of classes; in the object in the message is in the fInfos list of the message.; We send only the TStreamerInfos not yet sent on this socket. void SendProcessIDs(const TMessage& mess); Check if TProcessIDs must be sent. The list of TProcessIDs; in the object in the message is found by looking in the TMessage bits.; We send only the TProcessIDs not yet send on this socket. Int_t Recv(char* mess, Int_t max); Receive a character string message of maximum max length. The expected; message must be of type kMESS_STRING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int_t max, Int_t& kind); Receive a character string message of maximum max length. Returns in; kind the message type. Returns length of received string+4 (can be 0 if; other side of connection is closed) or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is n",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:15854,Integrability,message,message,15854,"oBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET).; support for streaming TStreamerInfo added by Rene Brun May 2008; support for streaming TProcessID added by Rene Brun June 2008. Int_t SendObject(const TObject* obj, Int_t kind = kMESS_OBJECT); Send an object. Returns the number of bytes sent and -1 in case of error.; In case the ""kind"" has been or'ed with kMESS_ACK, the call will only; return after having received an acknowledgement, making the sending; synchronous. Int_t SendRaw(const void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Send a raw buffer of specified length. Using option kOob one can send; OOB data. Returns the number of bytes sent or -1 in case of error.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). void SendStreamerInfos(const TMessage& mess); Check if TStreamerInfo must be sent. The list of TStreamerInfo of classes; in the object in the message is in the fInfos list of the message.; We send only the TStreamerInfos not yet sent on this socket. void SendProcessIDs(const TMessage& mess); Check if TProcessIDs must be sent. The list of TProcessIDs; in the object in the message is found by looking in the TMessage bits.; We send only the TProcessIDs not yet send on this socket. Int_t Recv(char* mess, Int_t max); Receive a character string message of maximum max length. The expected; message must be of type kMESS_STRING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int_t max, Int_t& kind); Receive a character string message of maximum max length. Returns in; kind the message type. Returns length of received string+4 (can be 0 if; other side of connection is closed) or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is n",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:16049,Integrability,message,message,16049,"ject(const TObject* obj, Int_t kind = kMESS_OBJECT); Send an object. Returns the number of bytes sent and -1 in case of error.; In case the ""kind"" has been or'ed with kMESS_ACK, the call will only; return after having received an acknowledgement, making the sending; synchronous. Int_t SendRaw(const void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Send a raw buffer of specified length. Using option kOob one can send; OOB data. Returns the number of bytes sent or -1 in case of error.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). void SendStreamerInfos(const TMessage& mess); Check if TStreamerInfo must be sent. The list of TStreamerInfo of classes; in the object in the message is in the fInfos list of the message.; We send only the TStreamerInfos not yet sent on this socket. void SendProcessIDs(const TMessage& mess); Check if TProcessIDs must be sent. The list of TProcessIDs; in the object in the message is found by looking in the TMessage bits.; We send only the TProcessIDs not yet send on this socket. Int_t Recv(char* mess, Int_t max); Receive a character string message of maximum max length. The expected; message must be of type kMESS_STRING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int_t max, Int_t& kind); Receive a character string message of maximum max length. Returns in; kind the message type. Returns length of received string+4 (can be 0 if; other side of connection is closed) or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is nothing to be read). Int_t Recv(Int_t& status, Int_t& kind); Receives a status and a message type. Returns length of received; integers, 2*sizeof(Int_t) (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:16220,Integrability,message,message,16220,"en or'ed with kMESS_ACK, the call will only; return after having received an acknowledgement, making the sending; synchronous. Int_t SendRaw(const void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Send a raw buffer of specified length. Using option kOob one can send; OOB data. Returns the number of bytes sent or -1 in case of error.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). void SendStreamerInfos(const TMessage& mess); Check if TStreamerInfo must be sent. The list of TStreamerInfo of classes; in the object in the message is in the fInfos list of the message.; We send only the TStreamerInfos not yet sent on this socket. void SendProcessIDs(const TMessage& mess); Check if TProcessIDs must be sent. The list of TProcessIDs; in the object in the message is found by looking in the TMessage bits.; We send only the TProcessIDs not yet send on this socket. Int_t Recv(char* mess, Int_t max); Receive a character string message of maximum max length. The expected; message must be of type kMESS_STRING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int_t max, Int_t& kind); Receive a character string message of maximum max length. Returns in; kind the message type. Returns length of received string+4 (can be 0 if; other side of connection is closed) or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is nothing to be read). Int_t Recv(Int_t& status, Int_t& kind); Receives a status and a message type. Returns length of received; integers, 2*sizeof(Int_t) (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking; socket would block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMe",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:16265,Integrability,message,message,16265," an acknowledgement, making the sending; synchronous. Int_t SendRaw(const void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Send a raw buffer of specified length. Using option kOob one can send; OOB data. Returns the number of bytes sent or -1 in case of error.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). void SendStreamerInfos(const TMessage& mess); Check if TStreamerInfo must be sent. The list of TStreamerInfo of classes; in the object in the message is in the fInfos list of the message.; We send only the TStreamerInfos not yet sent on this socket. void SendProcessIDs(const TMessage& mess); Check if TProcessIDs must be sent. The list of TProcessIDs; in the object in the message is found by looking in the TMessage bits.; We send only the TProcessIDs not yet send on this socket. Int_t Recv(char* mess, Int_t max); Receive a character string message of maximum max length. The expected; message must be of type kMESS_STRING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int_t max, Int_t& kind); Receive a character string message of maximum max length. Returns in; kind the message type. Returns length of received string+4 (can be 0 if; other side of connection is closed) or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is nothing to be read). Int_t Recv(Int_t& status, Int_t& kind); Receives a status and a message type. Returns length of received; integers, 2*sizeof(Int_t) (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking; socket would block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other sid",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:16570,Integrability,message,message,16570,"r.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). void SendStreamerInfos(const TMessage& mess); Check if TStreamerInfo must be sent. The list of TStreamerInfo of classes; in the object in the message is in the fInfos list of the message.; We send only the TStreamerInfos not yet sent on this socket. void SendProcessIDs(const TMessage& mess); Check if TProcessIDs must be sent. The list of TProcessIDs; in the object in the message is found by looking in the TMessage bits.; We send only the TProcessIDs not yet send on this socket. Int_t Recv(char* mess, Int_t max); Receive a character string message of maximum max length. The expected; message must be of type kMESS_STRING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int_t max, Int_t& kind); Receive a character string message of maximum max length. Returns in; kind the message type. Returns length of received string+4 (can be 0 if; other side of connection is closed) or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is nothing to be read). Int_t Recv(Int_t& status, Int_t& kind); Receives a status and a message type. Returns length of received; integers, 2*sizeof(Int_t) (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking; socket would block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRe",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:16622,Integrability,message,message,16622,"-5 if pipe broken or reset by peer (EPIPE || ECONNRESET). void SendStreamerInfos(const TMessage& mess); Check if TStreamerInfo must be sent. The list of TStreamerInfo of classes; in the object in the message is in the fInfos list of the message.; We send only the TStreamerInfos not yet sent on this socket. void SendProcessIDs(const TMessage& mess); Check if TProcessIDs must be sent. The list of TProcessIDs; in the object in the message is found by looking in the TMessage bits.; We send only the TProcessIDs not yet send on this socket. Int_t Recv(char* mess, Int_t max); Receive a character string message of maximum max length. The expected; message must be of type kMESS_STRING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int_t max, Int_t& kind); Receive a character string message of maximum max length. Returns in; kind the message type. Returns length of received string+4 (can be 0 if; other side of connection is closed) or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is nothing to be read). Int_t Recv(Int_t& status, Int_t& kind); Receives a status and a message type. Returns length of received; integers, 2*sizeof(Int_t) (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking; socket would block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length byt",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:16894,Integrability,message,message,16894,"end only the TStreamerInfos not yet sent on this socket. void SendProcessIDs(const TMessage& mess); Check if TProcessIDs must be sent. The list of TProcessIDs; in the object in the message is found by looking in the TMessage bits.; We send only the TProcessIDs not yet send on this socket. Int_t Recv(char* mess, Int_t max); Receive a character string message of maximum max length. The expected; message must be of type kMESS_STRING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int_t max, Int_t& kind); Receive a character string message of maximum max length. Returns in; kind the message type. Returns length of received string+4 (can be 0 if; other side of connection is closed) or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is nothing to be read). Int_t Recv(Int_t& status, Int_t& kind); Receives a status and a message type. Returns length of received; integers, 2*sizeof(Int_t) (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking; socket would block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:17237,Integrability,message,message,17237,"ING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int_t max, Int_t& kind); Receive a character string message of maximum max length. Returns in; kind the message type. Returns length of received string+4 (can be 0 if; other side of connection is closed) or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is nothing to be read). Int_t Recv(Int_t& status, Int_t& kind); Receives a status and a message type. Returns length of received; integers, 2*sizeof(Int_t) (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking; socket would block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will b",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:17980,Integrability,message,message,17980,"0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking; socket would block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will be deleted and the; method returns kTRUE. Int_t SetOption(ESockOptions opt, Int_t val); Set socket options. Int_t GetOption(ESockOptions opt, Int_t& val); Get socket options. Returns -1 in case of error. Int_t GetErrorCode() const; Returns error code. Meaning depends on context where it is called.; If no error condition returns 0 else a value < 0.; For example see TServerSocket ctor. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void SetCompressionSettings(Int_t settings = 1); Used to specify the compression level and al",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:18027,Integrability,message,message,18027,"ld block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will be deleted and the; method returns kTRUE. Int_t SetOption(ESockOptions opt, Int_t val); Set socket options. Int_t GetOption(ESockOptions opt, Int_t& val); Get socket options. Returns -1 in case of error. Int_t GetErrorCode() const; Returns error code. Meaning depends on context where it is called.; If no error condition returns 0 else a value < 0.; For example see TServerSocket ctor. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void SetCompressionSettings(Int_t settings = 1); Used to specify the compression level and algorithm:; settings = 100 * algorithm + level. level = 0, objects written to this file will not be compres",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:18083,Integrability,message,message,18083,"ld block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will be deleted and the; method returns kTRUE. Int_t SetOption(ESockOptions opt, Int_t val); Set socket options. Int_t GetOption(ESockOptions opt, Int_t& val); Get socket options. Returns -1 in case of error. Int_t GetErrorCode() const; Returns error code. Meaning depends on context where it is called.; If no error condition returns 0 else a value < 0.; For example see TServerSocket ctor. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void SetCompressionSettings(Int_t settings = 1); Used to specify the compression level and algorithm:; settings = 100 * algorithm + level. level = 0, objects written to this file will not be compres",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:18187,Integrability,message,message,18187,"he user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will be deleted and the; method returns kTRUE. Int_t SetOption(ESockOptions opt, Int_t val); Set socket options. Int_t GetOption(ESockOptions opt, Int_t& val); Get socket options. Returns -1 in case of error. Int_t GetErrorCode() const; Returns error code. Meaning depends on context where it is called.; If no error condition returns 0 else a value < 0.; For example see TServerSocket ctor. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void SetCompressionSettings(Int_t settings = 1); Used to specify the compression level and algorithm:; settings = 100 * algorithm + level. level = 0, objects written to this file will not be compressed.; level = 1, minimal compression level but fast. level = 9, maximal compression level but slower a",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:18231,Integrability,message,message,18231,"of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will be deleted and the; method returns kTRUE. Int_t SetOption(ESockOptions opt, Int_t val); Set socket options. Int_t GetOption(ESockOptions opt, Int_t& val); Get socket options. Returns -1 in case of error. Int_t GetErrorCode() const; Returns error code. Meaning depends on context where it is called.; If no error condition returns 0 else a value < 0.; For example see TServerSocket ctor. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void SetCompressionSettings(Int_t settings = 1); Used to specify the compression level and algorithm:; settings = 100 * algorithm + level. level = 0, objects written to this file will not be compressed.; level = 1, minimal compression level but fast. level = 9, maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If comp",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:18284,Integrability,message,message,18284,"of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will be deleted and the; method returns kTRUE. Int_t SetOption(ESockOptions opt, Int_t val); Set socket options. Int_t GetOption(ESockOptions opt, Int_t& val); Get socket options. Returns -1 in case of error. Int_t GetErrorCode() const; Returns error code. Meaning depends on context where it is called.; If no error condition returns 0 else a value < 0.; For example see TServerSocket ctor. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void SetCompressionSettings(Int_t settings = 1); Used to specify the compression level and algorithm:; settings = 100 * algorithm + level. level = 0, objects written to this file will not be compressed.; level = 1, minimal compression level but fast. level = 9, maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If comp",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:18557,Integrability,depend,depends,18557,"); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will be deleted and the; method returns kTRUE. Int_t SetOption(ESockOptions opt, Int_t val); Set socket options. Int_t GetOption(ESockOptions opt, Int_t& val); Get socket options. Returns -1 in case of error. Int_t GetErrorCode() const; Returns error code. Meaning depends on context where it is called.; If no error condition returns 0 else a value < 0.; For example see TServerSocket ctor. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void SetCompressionSettings(Int_t settings = 1); Used to specify the compression level and algorithm:; settings = 100 * algorithm + level. level = 0, objects written to this file will not be compressed.; level = 1, minimal compression level but fast. level = 9, maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If compress is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of the argument. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build a",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:20012,Integrability,depend,depending,20012,"= 100 * algorithm + level. level = 0, objects written to this file will not be compressed.; level = 1, minimal compression level but fast. level = 9, maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If compress is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of the argument. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. void NetError(const char* where, Int_t error); Print error string depending on error code. ULong64_t GetSocketBytesSent(); Get total number of bytes sent via all sockets. ULong64_t GetSocketBytesRecv(); Get total number of bytes received via all sockets. Int_t GetCompressionAlgorithm() const. Int_t GetCompressionLevel() const. Int_t GetCompressionSettings() const. TUDPSocket(); { }. void SetDescriptor(Int_t desc); { fSocket = desc; }. TUDPSocket& operator=(const TUDPSocket& ). Option_t * GetOption() const; { return TObject::GetOption(); }. virtual ~TUDPSocket(); { Close(); }. Int_t GetDescriptor() const; { return fSocket; }. TInetAddress GetInetAddress() const; { return fAddress; }. Int_t GetPort() const; { return fAddress.GetPort(); }. const char * GetService() const; { return fService; }. Int_t GetServType() const; { return (Int_t)fServType; }. UInt_t GetBytesSent() const; { return fBytesSent; }. UInt_t GetBytesRecv() const; { return fBytesRecv; }. Int_t GetRemoteProtocol() const; { return fRemoteProtocol; }. TSecContext * GetS",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:3476,Modifiability,Inherit,InheritsFrom,3476,"::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetErrorCode() const; virtual const char*TObject::GetIconName() const; TInetAddressGetInetAddress() const; TTimeStampGetLastUsage(); virtual TInetAddressGetLocalInetAddress(); virtual Int_tGetLocalPort(); virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Int_tGetOption(ESockOptions opt, Int_t& val); Int_tGetPort() const; Int_tGetRemoteProtocol() const; TSecContext*GetSecContext() const; const char*GetService() const; Int_tGetServType() const; static ULong64_tGetSocketBytesRecv(); static ULong64_tGetSocketBytesSent(); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const char*GetUrl() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tIsValid() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidNetError(const char* where, Int_t error); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::op",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:3542,Modifiability,Inherit,InheritsFrom,3542,"tGetErrorCode() const; virtual const char*TObject::GetIconName() const; TInetAddressGetInetAddress() const; TTimeStampGetLastUsage(); virtual TInetAddressGetLocalInetAddress(); virtual Int_tGetLocalPort(); virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Int_tGetOption(ESockOptions opt, Int_t& val); Int_tGetPort() const; Int_tGetRemoteProtocol() const; TSecContext*GetSecContext() const; const char*GetService() const; Int_tGetServType() const; static ULong64_tGetSocketBytesRecv(); static ULong64_tGetSocketBytesSent(); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const char*GetUrl() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tIsValid() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidNetError(const char* where, Int_t error); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:9075,Modifiability,Inherit,Inheritance,9075,"s array to mark TStreamerInfo classes already sent; UInt_tfBytesRecvtotal bytes received over this socket; UInt_tfBytesSenttotal bytes sent using this socket; Int_tfCompressCompression level and algorithm; TTimeStampfLastUsageTime stamp of last usage; TVirtualMutex*fLastUsageMtxProtect last usage setting / reading; TInetAddressfLocalAddresslocal internet address and port #; TStringTNamed::fNameobject identifier; Int_tfRemoteProtocolprotocol of remote daemon; TSecContext*fSecContextafter a successful Authenticate call; TUDPSocket::EServiceTypefServTyperemote service type; TStringfServicename of service (matches remote port #); Int_tfSocketsocket descriptor; TStringTNamed::fTitleobject title; TList*fUUIDslist of TProcessIDs already sent through the socket; TStringfUrlneeds this for special authentication options; static ULong64_tfgBytesRecvtotal bytes received by all socket objects; static ULong64_tfgBytesSenttotal bytes sent by all socket objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUDPSocket(TInetAddress address, const char* service); Create a socket. Connect to the named service at address addr.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Returns when connection has been accepted by remote side. Use IsValid(); to check the validity of the socket. Every socket is added to the TROOT; sockets list which will make sure that any open sockets are properly; closed on program termination. TUDPSocket(TInetAddress address, Int_t port); Create a socket. Connect to the specified port # at address addr.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Returns when connection has been accepted by remote si",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:9088,Modifiability,Inherit,Inherited,9088,"s array to mark TStreamerInfo classes already sent; UInt_tfBytesRecvtotal bytes received over this socket; UInt_tfBytesSenttotal bytes sent using this socket; Int_tfCompressCompression level and algorithm; TTimeStampfLastUsageTime stamp of last usage; TVirtualMutex*fLastUsageMtxProtect last usage setting / reading; TInetAddressfLocalAddresslocal internet address and port #; TStringTNamed::fNameobject identifier; Int_tfRemoteProtocolprotocol of remote daemon; TSecContext*fSecContextafter a successful Authenticate call; TUDPSocket::EServiceTypefServTyperemote service type; TStringfServicename of service (matches remote port #); Int_tfSocketsocket descriptor; TStringTNamed::fTitleobject title; TList*fUUIDslist of TProcessIDs already sent through the socket; TStringfUrlneeds this for special authentication options; static ULong64_tfgBytesRecvtotal bytes received by all socket objects; static ULong64_tfgBytesSenttotal bytes sent by all socket objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUDPSocket(TInetAddress address, const char* service); Create a socket. Connect to the named service at address addr.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Returns when connection has been accepted by remote side. Use IsValid(); to check the validity of the socket. Every socket is added to the TROOT; sockets list which will make sure that any open sockets are properly; closed on program termination. TUDPSocket(TInetAddress address, Int_t port); Create a socket. Connect to the specified port # at address addr.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Returns when connection has been accepted by remote si",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:5377,Safety,timeout,timeout,5377,"bject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual Int_tReconnect(); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tRecv(TMessage*& mess); virtual Int_tRecv(Int_t& status, Int_t& kind); virtual Int_tRecv(char* mess, Int_t max); virtual Int_tRecv(char* mess, Int_t max, Int_t& kind); virtual Int_tRecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tSelect(Int_t interest = kRead, Long_t timeout = -1); virtual Int_tSend(const TMessage& mess); virtual Int_tSend(Int_t kind); virtual Int_tSend(Int_t status, Int_t kind); virtual Int_tSend(const char* mess, Int_t kind = kMESS_STRING); virtual Int_tSendObject(const TObject* obj, Int_t kind = kMESS_OBJECT); virtual Int_tSendRaw(const void* buffer, Int_t length, ESendRecvOptions opt = kDefault); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCompressionAlgorithm(Int_t algorithm = 0); voidSetCompressionLevel(Int_t level = 1); voidSetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual Int_tSetOption(ESockOptions opt, Int_t val); voidSetRemoteProtocol(Int_t rproto); voidSetSecContext(TSecContext* ctx); voidSetService(const char* ",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:12899,Safety,timeout,timeout,12899,"cket. The socket will adopt previously opened TCP socket with; descriptor desc. TUDPSocket(Int_t descriptor, const char* sockpath); Create a socket. The socket will adopt previously opened Unix socket with; descriptor desc. The sockpath arg is for info purposes only. Use; this method to adopt e.g. a socket created via socketpair(). TUDPSocket(const TUDPSocket& s); TUDPSocket copy ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitely Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:13149,Safety,timeout,timeout,13149,"y. Use; this method to adopt e.g. a socket created via socketpair(). TUDPSocket(const TUDPSocket& s); TUDPSocket copy ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitely Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:13216,Safety,timeout,timeout,13216,"eated via socketpair(). TUDPSocket(const TUDPSocket& s); TUDPSocket copy ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitely Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character string buffer. Use kind to set the TMessage """,MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:13279,Safety,detect,detected,13279,"tor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitely Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character string buffer. Use kind to set the TMessage ""what"" field.; Returns the number of bytes in the string str that were sent",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:13296,Safety,timeout,timeout,13296,"tor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitely Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character string buffer. Use kind to set the TMessage ""what"" field.; Returns the number of bytes in the string str that were sent",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:13318,Safety,timeout,timeout,13318,"tor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitely Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character string buffer. Use kind to set the TMessage ""what"" field.; Returns the number of bytes in the string str that were sent",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:3366,Security,Hash,Hash,3366,"onLevel() const; Int_tGetCompressionSettings() const; virtual Int_tGetDescriptor() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetErrorCode() const; virtual const char*TObject::GetIconName() const; TInetAddressGetInetAddress() const; TTimeStampGetLastUsage(); virtual TInetAddressGetLocalInetAddress(); virtual Int_tGetLocalPort(); virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Int_tGetOption(ESockOptions opt, Int_t& val); Int_tGetPort() const; Int_tGetRemoteProtocol() const; TSecContext*GetSecContext() const; const char*GetService() const; Int_tGetServType() const; static ULong64_tGetSocketBytesRecv(); static ULong64_tGetSocketBytesSent(); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const char*GetUrl() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tIsValid() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidNetError(const char* where, Int_t error); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); s",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:8605,Security,Authenticat,Authenticate,8605,"ion_t*GetOption() const; TUDPSocket&operator=(const TUDPSocket&). Data Members; public:. enum EStatusBits { kIsUnix; kBrokenConn; };; enum EInterest { kRead; kWrite; };; enum EServiceType { kSOCKD; kROOTD; kPROOFD; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TInetAddressfAddressremote internet address and port #; TBitsfBitsInfobits array to mark TStreamerInfo classes already sent; UInt_tfBytesRecvtotal bytes received over this socket; UInt_tfBytesSenttotal bytes sent using this socket; Int_tfCompressCompression level and algorithm; TTimeStampfLastUsageTime stamp of last usage; TVirtualMutex*fLastUsageMtxProtect last usage setting / reading; TInetAddressfLocalAddresslocal internet address and port #; TStringTNamed::fNameobject identifier; Int_tfRemoteProtocolprotocol of remote daemon; TSecContext*fSecContextafter a successful Authenticate call; TUDPSocket::EServiceTypefServTyperemote service type; TStringfServicename of service (matches remote port #); Int_tfSocketsocket descriptor; TStringTNamed::fTitleobject title; TList*fUUIDslist of TProcessIDs already sent through the socket; TStringfUrlneeds this for special authentication options; static ULong64_tfgBytesRecvtotal bytes received by all socket objects; static ULong64_tfgBytesSenttotal bytes sent by all socket objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUDPSocket(TInetAddress address, const char* service); Create a socket. Connect to the named service at address addr.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Returns when connection has been accepted by remote side. Use Is",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:8899,Security,authenticat,authentication,8899,"ion_t*GetOption() const; TUDPSocket&operator=(const TUDPSocket&). Data Members; public:. enum EStatusBits { kIsUnix; kBrokenConn; };; enum EInterest { kRead; kWrite; };; enum EServiceType { kSOCKD; kROOTD; kPROOFD; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TInetAddressfAddressremote internet address and port #; TBitsfBitsInfobits array to mark TStreamerInfo classes already sent; UInt_tfBytesRecvtotal bytes received over this socket; UInt_tfBytesSenttotal bytes sent using this socket; Int_tfCompressCompression level and algorithm; TTimeStampfLastUsageTime stamp of last usage; TVirtualMutex*fLastUsageMtxProtect last usage setting / reading; TInetAddressfLocalAddresslocal internet address and port #; TStringTNamed::fNameobject identifier; Int_tfRemoteProtocolprotocol of remote daemon; TSecContext*fSecContextafter a successful Authenticate call; TUDPSocket::EServiceTypefServTyperemote service type; TStringfServicename of service (matches remote port #); Int_tfSocketsocket descriptor; TStringTNamed::fTitleobject title; TList*fUUIDslist of TProcessIDs already sent through the socket; TStringfUrlneeds this for special authentication options; static ULong64_tfgBytesRecvtotal bytes received by all socket objects; static ULong64_tfgBytesSenttotal bytes sent by all socket objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUDPSocket(TInetAddress address, const char* service); Create a socket. Connect to the named service at address addr.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Returns when connection has been accepted by remote side. Use Is",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:11051,Security,authenticat,authentication,11051,"; Returns when connection has been accepted by remote side. Use IsValid(); to check the validity of the socket. Every socket is added to the TROOT; sockets list which will make sure that any open sockets are properly; closed on program termination. TUDPSocket(const char* host, const char* service); Create a socket. Connect to named service on the remote host.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Returns when connection has been accepted by remote side. Use IsValid(); to check the validity of the socket. Every socket is added to the TROOT; sockets list which will make sure that any open sockets are properly; closed on program termination. TUDPSocket(const char* host, Int_t port); Create a socket; see CreateAuthSocket for the form of url.; Connect to the specified port # on the remote host.; If user is specified in url, try authentication as user.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Returns when connection has been accepted by remote side. Use IsValid(); to check the validity of the socket. Every socket is added to the TROOT; sockets list which will make sure that any open sockets are properly; closed on program termination. TUDPSocket(const char* sockpath); Create a socket in the Unix domain on 'sockpath'.; Returns when connection has been accepted by the server. Use IsValid(); to check the validity of the socket. Every socket is added to the TROOT; sockets list which will make sure that any open sockets are properly; closed on program termination. TUDPSocket(Int_t descriptor); Create a socket. The socket will adopt previously opened TCP socket with; descriptor desc. TUDPSocket(Int_t descriptor, const char* sockpath); Create a s",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:6798,Testability,Test,TestBit,6798,"oidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tSelect(Int_t interest = kRead, Long_t timeout = -1); virtual Int_tSend(const TMessage& mess); virtual Int_tSend(Int_t kind); virtual Int_tSend(Int_t status, Int_t kind); virtual Int_tSend(const char* mess, Int_t kind = kMESS_STRING); virtual Int_tSendObject(const TObject* obj, Int_t kind = kMESS_OBJECT); virtual Int_tSendRaw(const void* buffer, Int_t length, ESendRecvOptions opt = kDefault); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCompressionAlgorithm(Int_t algorithm = 0); voidSetCompressionLevel(Int_t level = 1); voidSetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual Int_tSetOption(ESockOptions opt, Int_t val); voidSetRemoteProtocol(Int_t rproto); voidSetSecContext(TSecContext* ctx); voidSetService(const char* service); voidSetServType(Int_t st); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); voidSetUrl(const char* url); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTouch(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:6837,Testability,Test,TestBits,6837,"oidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tSelect(Int_t interest = kRead, Long_t timeout = -1); virtual Int_tSend(const TMessage& mess); virtual Int_tSend(Int_t kind); virtual Int_tSend(Int_t status, Int_t kind); virtual Int_tSend(const char* mess, Int_t kind = kMESS_STRING); virtual Int_tSendObject(const TObject* obj, Int_t kind = kMESS_OBJECT); virtual Int_tSendRaw(const void* buffer, Int_t length, ESendRecvOptions opt = kDefault); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCompressionAlgorithm(Int_t algorithm = 0); voidSetCompressionLevel(Int_t level = 1); voidSetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual Int_tSetOption(ESockOptions opt, Int_t val); voidSetRemoteProtocol(Int_t rproto); voidSetSecContext(TSecContext* ctx); voidSetService(const char* service); voidSetServType(Int_t st); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); voidSetUrl(const char* url); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTouch(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUDPSocket.html:1137,Usability,Clear,Clear,1137," TUDPSocket(const char* sockpath); TUDPSocket(Int_t descriptor); TUDPSocket(const TUDPSocket& s); TUDPSocket(TInetAddress address, const char* service); TUDPSocket(TInetAddress address, Int_t port); TUDPSocket(const char* host, const char* service); TUDPSocket(const char* host, Int_t port); TUDPSocket(Int_t descriptor, const char* sockpath); virtual~TUDPSocket(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, ",MatchSource.WIKI,root/html532/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUDPSocket.html
https://root.cern/root/html532/TUnfold.html:620,Availability,error,errors,620,". TUnfold. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfold. class TUnfold: public TObject. TUnfold solves the inverse problem. chi**2 = (y-Ax)# Vyy^-1 (y-Ax) + tau^2 (L(x-x0))# L(x-x0) + lambda sum_i(y_i -(Ax)_i). where # means that the matrix is transposed. Monte Carlo input. y: vector of measured quantities (dimension ny); Vyy: covariance matrix for y (dimension ny x ny); in many cases V is diagonal and calculated from the errors of y; A: migration matrix (dimension ny x nx); x: unknown underlying distribution (dimension nx). Regularisation. tau: parameter, defining the regularisation strength; L: matrix of regularisation conditions (dimension nl x nx); x0: bias distribution. Preservation of the area. lambda: lagrangian multiplier; y_i: one component of the vector y; (Ax)_i: one component of the vector Ax. and chi**2 is minimized; (a) not constrained: minimisation is performed a function of x for fixed lambda=0; or; (b) constrained: minimisation is performed a function of x and lambda. This applies to a very large number of problems, where the measured; distribution y is a linear superposition of several Monte Carlo shapes; and the sum of these shapes gives the output distribution x. The constraint can be useful to reduce biases on the result x; in cases where the vector y follows non-Gaussian probability densities; (example: Poisson statistics at counting experiments in particle physics). Some random examples:. (1) measure a cross-section as a function of, say, E_T(detector); and unfold it to obtain the underlying distribution E_T(generator); (2) measure a lifetime distribution and unfold the contributions from; different flavours; (3) measure the transverse mass and decay angle; and unfold for the true mass distribution plus background. Documentation. Some technical documenta",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:2009,Availability,avail,available,2009," Ax. and chi**2 is minimized; (a) not constrained: minimisation is performed a function of x for fixed lambda=0; or; (b) constrained: minimisation is performed a function of x and lambda. This applies to a very large number of problems, where the measured; distribution y is a linear superposition of several Monte Carlo shapes; and the sum of these shapes gives the output distribution x. The constraint can be useful to reduce biases on the result x; in cases where the vector y follows non-Gaussian probability densities; (example: Poisson statistics at counting experiments in particle physics). Some random examples:. (1) measure a cross-section as a function of, say, E_T(detector); and unfold it to obtain the underlying distribution E_T(generator); (2) measure a lifetime distribution and unfold the contributions from; different flavours; (3) measure the transverse mass and decay angle; and unfold for the true mass distribution plus background. Documentation. Some technical documentation is available here:; http://www.desy.de/~sschmitt. References:. A nice overview of the method is given in:; The L-curve and Its Use in the Numerical Treatment of Inverse Problems; (2000) by P. C. Hansen, in Computational Inverse Problems in; Electrocardiology, ed. P. Johnston,; Advances in Computational Bioengineering; http://www.imm.dtu.dk/~pch/TR/Lcurve.ps; The relevant equations are (1), (2) for the unfolding; and (14) for the L-curve curvature definition. Related literature on unfolding:; The program package RUN and the web-page by V.Blobel; http://www.desy.de/~blobel/unfold.html; Talk by V. Blobel, Terascale Statistics school; https://indico.desy.de/contributionDisplay.py?contribId=23&confId=1149; References quoted in Blobel's talk:; Per Chistian Hansen, Rank-Deficient and Discrete Ill-posed Problems,; Siam (1998); Jari Kaipio and Erkki Somersalo, Statistical and Computational; Inverse problems, Springer (2005). Implementation. The result of the unfolding is calculated as follows:. ",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:4232,Availability,error,error,4232,"n_j = sum_i A_ij vector of efficiencies. E^-1 = ((A# Vyy^-1 A)+tau^2 Lsquared). x = E (A# Vyy^-1 y + tau^2 Lsquared x0 +lambda/2 * epsilon) is the result. The derivatives; dx_k/dy_i; dx_k/dA_ij; dx_k/d(tau^2); are calculated for further usage. The covariance matrix V_xx is calculated as:; Vxx_ij = sum_kl dx_i/dy_k Vyy_kl dx_j/dy_l. Warning:. The algorithm is based on ""standard"" matrix inversion, with the; known limitations in numerical accuracy and computing cost for; matrices with large dimensions. Thus the algorithm should not used for large dimensions of x and y; nx should not be much larger than 200; ny should not be much larger than 1000. Example of using TUnfold:. imagine a 2-dimensional histogram is filled, named A; y-axis: generated quantity (e.g. 10 bins); x-axis: reconstructed quantity (e.g. 20 bin); The data are filled in a 1-dimensional histogram, named y; Note1: ALWAYS choose a higher number of bins on the reconstructed side; as compared to the generated size!; Note2: the events which are generated but not reconstructed; have to be added to the appropriate overflow bins of A; Note3: make sure all bins have sufficient statistics and their error is; non-zero. By default, bins with zero error are simply skipped;; however, this may cause problems if You try to unfold something; which depends on these input bins. code fragment (with histograms A and y filled):. TUnfold unfold(A,TUnfold::kHistMapOutputHoriz);; Double_t tau=1.E-4;; Double_t biasScale=0.0;; unfold.DoUnfold(tau,y,biasScale);; TH1D *x=unfold.GetOutput(""x"",""myVariable"");; TH2D *rhoij=unfold.GetRhoIJ(""correlation"",""myVariable"");. will create histograms ""x"" and ""correlation"" from A and y.; if tau is very large, the output is biased to the generated distribution scaled by biasScale; if tau is very small, the output will show oscillations; and large entries in the correlation matrix. Proper choice of tau. One of the difficult questions is about the choice of tau. The most; common method is the L-curve",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:4279,Availability,error,error,4279," V_xx is calculated as:; Vxx_ij = sum_kl dx_i/dy_k Vyy_kl dx_j/dy_l. Warning:. The algorithm is based on ""standard"" matrix inversion, with the; known limitations in numerical accuracy and computing cost for; matrices with large dimensions. Thus the algorithm should not used for large dimensions of x and y; nx should not be much larger than 200; ny should not be much larger than 1000. Example of using TUnfold:. imagine a 2-dimensional histogram is filled, named A; y-axis: generated quantity (e.g. 10 bins); x-axis: reconstructed quantity (e.g. 20 bin); The data are filled in a 1-dimensional histogram, named y; Note1: ALWAYS choose a higher number of bins on the reconstructed side; as compared to the generated size!; Note2: the events which are generated but not reconstructed; have to be added to the appropriate overflow bins of A; Note3: make sure all bins have sufficient statistics and their error is; non-zero. By default, bins with zero error are simply skipped;; however, this may cause problems if You try to unfold something; which depends on these input bins. code fragment (with histograms A and y filled):. TUnfold unfold(A,TUnfold::kHistMapOutputHoriz);; Double_t tau=1.E-4;; Double_t biasScale=0.0;; unfold.DoUnfold(tau,y,biasScale);; TH1D *x=unfold.GetOutput(""x"",""myVariable"");; TH2D *rhoij=unfold.GetRhoIJ(""correlation"",""myVariable"");. will create histograms ""x"" and ""correlation"" from A and y.; if tau is very large, the output is biased to the generated distribution scaled by biasScale; if tau is very small, the output will show oscillations; and large entries in the correlation matrix. Proper choice of tau. One of the difficult questions is about the choice of tau. The most; common method is the L-curve method: a two-dimensional curve is plotted; x-axis: log10(chisquare); y-axis: log10(regularisation condition); In many cases this curve has an L-shape. The best choice of tau is in the; kink of the L. Within TUnfold a simple version of the L-curve analysis is incl",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:6623,Availability,error,error,6623,"me A and y are filled. TUnfold unfold(A,TUnfold::kHistMapOutputHoriz);. unfold.SetInput(y);. Int_t nScan=30;; Int_t iBest;; TSpline *logTauX,*logTauY;; TGraph *lCurve;. iBest=unfold.ScanLcurve(nScan,0.0,0.0,&lCurve);. std::cout<<""tau=""<<unfold.GetTau()<<""\n"";. TH1D *x=unfold.GetOutput(""x"",""myVariable"");; TH2D *rhoij=unfold.GetRhoIJ(""correlation"",""myVariable"");. This creates; logTauX: the L-curve's x-coordinate as a function of log(tau); logTauY: the L-curve's y-coordinate as a function of log(tau); lCurve: a graph of the L-curve; x,rhoij: unfolding result for best choice of tau; iBest: the coordinate/spline knot number with the best choice of tau. Note: always check the L curve after unfolding. The algorithm is not; perfect. Bin averaging of the output. Sometimes it is useful to unfold for a fine binning in x and; calculate the final result with a smaller number of bins. The advantage; is a reduction in the correlation coefficients if bins are averaged.; For this type of averaging the full error matrix has to be used.; There are methods in TUnfold to support this type of calculation; Example:; The vector x has dimension 49, it consists of 7x7 bins; in two variables (Pt,Eta); The unfolding result is to be presented as one-dimensional projections; in (Pt) and (Eta); The bins of x are mapped as: bins 1..7 the first Eta bin; bins 2..14 the second Eta bin. bins 1,8,15,... the first Pt bin. code fragment:. TUnfold unfold(A,TUnfold::kHistMapOutputHoriz);; Double_t tau=1.E-4;; Double_t biasScale=0.0;; unfold.DoUnfold(tau,y,biasScale);; Int_t binMapEta[49+2];; Int_t binMapPt[49+2];; // overflow and underflow bins are not used; binMapEta[0]=-1;; binMapEta[49+1]=-1;; binMapPt[0]=-1;; binMapPt[49+1]=-1;; for(Int_t i=1;i<=49;i++) {; // all bins (i) with the same (i-1)/7 are added; binMapEta[i] = (i-1)/7 +1;; // all bins (i) with the same (i-1)%7 are added; binMapPt[i] = (i-1)%7 +1;; }; TH1D *etaHist=new TH1D(""eta(unfolded)"","";eta"",7,etamin,etamax);; TH1D *etaCorr=new TH2D(""eta(u",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:11832,Availability,Error,Error,11832,"voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDoUnfold(Double_t tau); Double_tDoUnfold(Double_t tau, const TH1* hist_y, Double_t scaleBias = 0.0); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TH1D*GetBias(const char* name, const char* title, Double_t x0 = 0.0, Double_t x1 = 0.0) const; Double_tGetChi2A() const; Double_tGetChi2L() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidGetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; TH2D*GetEmatrix(const char* name, const char* title, Double_t x0 = 0.0, Double_t x1 = 0.0) const; TH1D*GetFoldedOutput(const char* name, const char* title, Double_t y0 = 0.0, Double_t y1 = 0.0) const; virtual const char*TObject::GetIconName() const; TH1D*GetInput(const char* name, const char* title, Double_t y0 = 0.0, Double_t y1 = 0.0) const; virtual Double_tGetLcurveX() cons",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:11961,Availability,error,error,11961,"voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDoUnfold(Double_t tau); Double_tDoUnfold(Double_t tau, const TH1* hist_y, Double_t scaleBias = 0.0); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TH1D*GetBias(const char* name, const char* title, Double_t x0 = 0.0, Double_t x1 = 0.0) const; Double_tGetChi2A() const; Double_tGetChi2L() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidGetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; TH2D*GetEmatrix(const char* name, const char* title, Double_t x0 = 0.0, Double_t x1 = 0.0) const; TH1D*GetFoldedOutput(const char* name, const char* title, Double_t y0 = 0.0, Double_t y1 = 0.0) const; virtual const char*TObject::GetIconName() const; TH1D*GetInput(const char* name, const char* title, Double_t y0 = 0.0, Double_t y1 = 0.0) const; virtual Double_tGetLcurveX() cons",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:12045,Availability,error,error,12045,"voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDoUnfold(Double_t tau); Double_tDoUnfold(Double_t tau, const TH1* hist_y, Double_t scaleBias = 0.0); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TH1D*GetBias(const char* name, const char* title, Double_t x0 = 0.0, Double_t x1 = 0.0) const; Double_tGetChi2A() const; Double_tGetChi2L() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidGetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; TH2D*GetEmatrix(const char* name, const char* title, Double_t x0 = 0.0, Double_t x1 = 0.0) const; TH1D*GetFoldedOutput(const char* name, const char* title, Double_t y0 = 0.0, Double_t y1 = 0.0) const; virtual const char*TObject::GetIconName() const; TH1D*GetInput(const char* name, const char* title, Double_t y0 = 0.0, Double_t y1 = 0.0) const; virtual Double_tGetLcurveX() cons",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:21841,Availability,error,error,21841,"udes; Libraries. Function documentation; const char * GetTUnfoldVersion(void). void InitTUnfold(void); reset all data members. void DeleteMatrix(TMatrixD** m). void DeleteMatrix(TMatrixDSparse** m). void ClearResults(void); delete old results (if any); this function is virtual, so derived classes may flag their results; ad non-valid as well. TUnfold(const TUnfold& ); set all matrix pointers to zero. Double_t DoUnfold(Double_t tau); main unfolding algorithm. Declared virtual, because other algorithms; could be implemented. Purpose: unfold y -> x; Data members required:; fA: matrix to relate x and y; fY: measured data points; fX0: bias on x; fBiasScale: scale factor for fX0; fVyy: covariance matrix for y; fLsquared: regularisation conditions; fTauSquared: regularisation strength; fConstraint: whether the constraint is applied; Data members modified:; fEinv: inverse of the covariance matrix of x; fE: covariance matrix of x; fX: unfolded data points; fDXDY: derivative of x wrt y (for error propagation); fVxx: error matrix (covariance matrix) on x; fAx: estimate of distribution y from unfolded data; fChi2A: contribution to chi**2 from y-Ax; fChi2L: contribution to chi**2 from L*(x-x0); fDXDtauSquared: derivative of x wrt tau; fDXDAM[0,1]: matrix parts of derivative x wrt A; fDXDAZ[0,1]: vector parts of derivative x wrt A; fRhoMax: maximum global correlation coefficient; fRhoAvg: average global correlation coefficient; return code:; fRhoMax if(fRhoMax>=1.0) then the unfolding has failed!. TMatrixDSparse * MultiplyMSparseMSparse(const TMatrixDSparse* a, const TMatrixDSparse* b) const; calculate the product of two sparse matrices; a,b: pointers to sparse matrices, where a->GetNcols()==b->GetNrows(); this is a replacement for the call; new TMatrixDSparse(*a,TMatrixDSparse::kMult,*b);. TMatrixDSparse * MultiplyMSparseTranspMSparse(const TMatrixDSparse* a, const TMatrixDSparse* b) const; multiply a transposed Sparse matrix with another Sparse matrix; a: pointer to sparse matri",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:21867,Availability,error,error,21867,"udes; Libraries. Function documentation; const char * GetTUnfoldVersion(void). void InitTUnfold(void); reset all data members. void DeleteMatrix(TMatrixD** m). void DeleteMatrix(TMatrixDSparse** m). void ClearResults(void); delete old results (if any); this function is virtual, so derived classes may flag their results; ad non-valid as well. TUnfold(const TUnfold& ); set all matrix pointers to zero. Double_t DoUnfold(Double_t tau); main unfolding algorithm. Declared virtual, because other algorithms; could be implemented. Purpose: unfold y -> x; Data members required:; fA: matrix to relate x and y; fY: measured data points; fX0: bias on x; fBiasScale: scale factor for fX0; fVyy: covariance matrix for y; fLsquared: regularisation conditions; fTauSquared: regularisation strength; fConstraint: whether the constraint is applied; Data members modified:; fEinv: inverse of the covariance matrix of x; fE: covariance matrix of x; fX: unfolded data points; fDXDY: derivative of x wrt y (for error propagation); fVxx: error matrix (covariance matrix) on x; fAx: estimate of distribution y from unfolded data; fChi2A: contribution to chi**2 from y-Ax; fChi2L: contribution to chi**2 from L*(x-x0); fDXDtauSquared: derivative of x wrt tau; fDXDAM[0,1]: matrix parts of derivative x wrt A; fDXDAZ[0,1]: vector parts of derivative x wrt A; fRhoMax: maximum global correlation coefficient; fRhoAvg: average global correlation coefficient; return code:; fRhoMax if(fRhoMax>=1.0) then the unfolding has failed!. TMatrixDSparse * MultiplyMSparseMSparse(const TMatrixDSparse* a, const TMatrixDSparse* b) const; calculate the product of two sparse matrices; a,b: pointers to sparse matrices, where a->GetNcols()==b->GetNrows(); this is a replacement for the call; new TMatrixDSparse(*a,TMatrixDSparse::kMult,*b);. TMatrixDSparse * MultiplyMSparseTranspMSparse(const TMatrixDSparse* a, const TMatrixDSparse* b) const; multiply a transposed Sparse matrix with another Sparse matrix; a: pointer to sparse matri",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:26458,Availability,error,errors,26458," the regularisation; return value: number of conditions which have been skipped; modifies data member fLsquared. Int_t RegularizeDerivative(int left_bin, int right_bin, Double_t scale = 1.0); add regularisation on the difference of two bins; left_bin: 1st bin; right_bin: 2nd bin; scale: size of the regularisation; return value: number of conditions which have been skipped; modifies data member fLsquared. Int_t RegularizeCurvature(int left_bin, int center_bin, int right_bin, Double_t scale_left = 1.0, Double_t scale_right = 1.0); add regularisation on the curvature through 3 bins (2nd derivative); left_bin: 1st bin; center_bin: 2nd bin; right_bin: 3rd bin; scale_left: scale factor on center-left difference; scale_right: scale factor on right-center difference; return value: number of conditions which have been skipped; modifies data member fLsquared. Int_t RegularizeBins(int start, int step, int nbin, TUnfold::ERegMode regmode); set regulatisation on a 1-dimensional curve; start: first bin; step: distance between neighbouring bins; nbin: total number of bins; regmode: regularisation mode; return value:; number of errors (i.e. conditions which have been skipped); modifies data member fLsquared. Int_t RegularizeBins2D(int start_bin, int step1, int nbin1, int step2, int nbin2, TUnfold::ERegMode regmode); set regularisation on a 2-dimensional grid of bins; start: first bin; step1: distance between bins in 1st direction; nbin1: number of bins in 1st direction; step2: distance between bins in 2nd direction; nbin2: number of bins in 2nd direction; return value:; number of errors (i.e. conditions which have been skipped); modifies data member fLsquared. Double_t DoUnfold(Double_t tau, const TH1* hist_y, Double_t scaleBias = 0.0); Do unfolding of an input histogram; tau_reg: regularisation parameter; input: input distribution with errors; scaleBias: scale factor applied to the bias; Data members required:; fA, fX0, fLsquared; Data members modified:; those documented in SetInpu",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:26919,Availability,error,errors,26919,". Int_t RegularizeCurvature(int left_bin, int center_bin, int right_bin, Double_t scale_left = 1.0, Double_t scale_right = 1.0); add regularisation on the curvature through 3 bins (2nd derivative); left_bin: 1st bin; center_bin: 2nd bin; right_bin: 3rd bin; scale_left: scale factor on center-left difference; scale_right: scale factor on right-center difference; return value: number of conditions which have been skipped; modifies data member fLsquared. Int_t RegularizeBins(int start, int step, int nbin, TUnfold::ERegMode regmode); set regulatisation on a 1-dimensional curve; start: first bin; step: distance between neighbouring bins; nbin: total number of bins; regmode: regularisation mode; return value:; number of errors (i.e. conditions which have been skipped); modifies data member fLsquared. Int_t RegularizeBins2D(int start_bin, int step1, int nbin1, int step2, int nbin2, TUnfold::ERegMode regmode); set regularisation on a 2-dimensional grid of bins; start: first bin; step1: distance between bins in 1st direction; nbin1: number of bins in 1st direction; step2: distance between bins in 2nd direction; nbin2: number of bins in 2nd direction; return value:; number of errors (i.e. conditions which have been skipped); modifies data member fLsquared. Double_t DoUnfold(Double_t tau, const TH1* hist_y, Double_t scaleBias = 0.0); Do unfolding of an input histogram; tau_reg: regularisation parameter; input: input distribution with errors; scaleBias: scale factor applied to the bias; Data members required:; fA, fX0, fLsquared; Data members modified:; those documented in SetInput(); and those documented in DoUnfold(Double_t); Return value:; maximum global correlation coefficient; NOTE!!! return value >=1.0 means error, and the result is junk. Overflow bins of the input distribution are ignored!. Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0.0, Double_t oneOverZeroError = 0.0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distributi",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:27181,Availability,error,errors,27181,"e); set regulatisation on a 1-dimensional curve; start: first bin; step: distance between neighbouring bins; nbin: total number of bins; regmode: regularisation mode; return value:; number of errors (i.e. conditions which have been skipped); modifies data member fLsquared. Int_t RegularizeBins2D(int start_bin, int step1, int nbin1, int step2, int nbin2, TUnfold::ERegMode regmode); set regularisation on a 2-dimensional grid of bins; start: first bin; step1: distance between bins in 1st direction; nbin1: number of bins in 1st direction; step2: distance between bins in 2nd direction; nbin2: number of bins in 2nd direction; return value:; number of errors (i.e. conditions which have been skipped); modifies data member fLsquared. Double_t DoUnfold(Double_t tau, const TH1* hist_y, Double_t scaleBias = 0.0); Do unfolding of an input histogram; tau_reg: regularisation parameter; input: input distribution with errors; scaleBias: scale factor applied to the bias; Data members required:; fA, fX0, fLsquared; Data members modified:; those documented in SetInput(); and those documented in DoUnfold(Double_t); Return value:; maximum global correlation coefficient; NOTE!!! return value >=1.0 means error, and the result is junk. Overflow bins of the input distribution are ignored!. Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0.0, Double_t oneOverZeroError = 0.0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Data members modified:; fY, fVyy, fVyyinv, fBiasScale, fNdf; Data members cleared; see ClearResults. Double_t DoUnfold(Double_t tau); Unfold with given value of regularisation parameter tau; tau: new tau parame",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:27466,Availability,error,error,27466,"ions which have been skipped); modifies data member fLsquared. Int_t RegularizeBins2D(int start_bin, int step1, int nbin1, int step2, int nbin2, TUnfold::ERegMode regmode); set regularisation on a 2-dimensional grid of bins; start: first bin; step1: distance between bins in 1st direction; nbin1: number of bins in 1st direction; step2: distance between bins in 2nd direction; nbin2: number of bins in 2nd direction; return value:; number of errors (i.e. conditions which have been skipped); modifies data member fLsquared. Double_t DoUnfold(Double_t tau, const TH1* hist_y, Double_t scaleBias = 0.0); Do unfolding of an input histogram; tau_reg: regularisation parameter; input: input distribution with errors; scaleBias: scale factor applied to the bias; Data members required:; fA, fX0, fLsquared; Data members modified:; those documented in SetInput(); and those documented in DoUnfold(Double_t); Return value:; maximum global correlation coefficient; NOTE!!! return value >=1.0 means error, and the result is junk. Overflow bins of the input distribution are ignored!. Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0.0, Double_t oneOverZeroError = 0.0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Data members modified:; fY, fVyy, fVyyinv, fBiasScale, fNdf; Data members cleared; see ClearResults. Double_t DoUnfold(Double_t tau); Unfold with given value of regularisation parameter tau; tau: new tau parameter; required data members:; fA: matrix to relate x and y; fY: measured data points; fX0: bias on x; fBiasScale: scale factor for fX0; fV: inverse of covariance matrix for y; fLsquared: regularisation condition",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:27742,Availability,error,errors,27742,"t direction; nbin1: number of bins in 1st direction; step2: distance between bins in 2nd direction; nbin2: number of bins in 2nd direction; return value:; number of errors (i.e. conditions which have been skipped); modifies data member fLsquared. Double_t DoUnfold(Double_t tau, const TH1* hist_y, Double_t scaleBias = 0.0); Do unfolding of an input histogram; tau_reg: regularisation parameter; input: input distribution with errors; scaleBias: scale factor applied to the bias; Data members required:; fA, fX0, fLsquared; Data members modified:; those documented in SetInput(); and those documented in DoUnfold(Double_t); Return value:; maximum global correlation coefficient; NOTE!!! return value >=1.0 means error, and the result is junk. Overflow bins of the input distribution are ignored!. Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0.0, Double_t oneOverZeroError = 0.0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Data members modified:; fY, fVyy, fVyyinv, fBiasScale, fNdf; Data members cleared; see ClearResults. Double_t DoUnfold(Double_t tau); Unfold with given value of regularisation parameter tau; tau: new tau parameter; required data members:; fA: matrix to relate x and y; fY: measured data points; fX0: bias on x; fBiasScale: scale factor for fX0; fV: inverse of covariance matrix for y; fLsquared: regularisation conditions; modified data members:; fTauSquared and those documented in DoUnfold(void). Int_t ScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); scan the L curve; nPoint: number of points on the resulting curve; ta",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:27832,Availability,error,error,27832,"t direction; nbin1: number of bins in 1st direction; step2: distance between bins in 2nd direction; nbin2: number of bins in 2nd direction; return value:; number of errors (i.e. conditions which have been skipped); modifies data member fLsquared. Double_t DoUnfold(Double_t tau, const TH1* hist_y, Double_t scaleBias = 0.0); Do unfolding of an input histogram; tau_reg: regularisation parameter; input: input distribution with errors; scaleBias: scale factor applied to the bias; Data members required:; fA, fX0, fLsquared; Data members modified:; those documented in SetInput(); and those documented in DoUnfold(Double_t); Return value:; maximum global correlation coefficient; NOTE!!! return value >=1.0 means error, and the result is junk. Overflow bins of the input distribution are ignored!. Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0.0, Double_t oneOverZeroError = 0.0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Data members modified:; fY, fVyy, fVyyinv, fBiasScale, fNdf; Data members cleared; see ClearResults. Double_t DoUnfold(Double_t tau); Unfold with given value of regularisation parameter tau; tau: new tau parameter; required data members:; fA: matrix to relate x and y; fY: measured data points; fX0: bias on x; fBiasScale: scale factor for fX0; fV: inverse of covariance matrix for y; fLsquared: regularisation conditions; modified data members:; fTauSquared and those documented in DoUnfold(void). Int_t ScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); scan the L curve; nPoint: number of points on the resulting curve; ta",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:27861,Availability,error,error,27861,"t direction; nbin1: number of bins in 1st direction; step2: distance between bins in 2nd direction; nbin2: number of bins in 2nd direction; return value:; number of errors (i.e. conditions which have been skipped); modifies data member fLsquared. Double_t DoUnfold(Double_t tau, const TH1* hist_y, Double_t scaleBias = 0.0); Do unfolding of an input histogram; tau_reg: regularisation parameter; input: input distribution with errors; scaleBias: scale factor applied to the bias; Data members required:; fA, fX0, fLsquared; Data members modified:; those documented in SetInput(); and those documented in DoUnfold(Double_t); Return value:; maximum global correlation coefficient; NOTE!!! return value >=1.0 means error, and the result is junk. Overflow bins of the input distribution are ignored!. Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0.0, Double_t oneOverZeroError = 0.0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Data members modified:; fY, fVyy, fVyyinv, fBiasScale, fNdf; Data members cleared; see ClearResults. Double_t DoUnfold(Double_t tau); Unfold with given value of regularisation parameter tau; tau: new tau parameter; required data members:; fA: matrix to relate x and y; fY: measured data points; fX0: bias on x; fBiasScale: scale factor for fX0; fV: inverse of covariance matrix for y; fLsquared: regularisation conditions; modified data members:; fTauSquared and those documented in DoUnfold(void). Int_t ScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); scan the L curve; nPoint: number of points on the resulting curve; ta",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:27907,Availability,error,error,27907,"Unfold(Double_t tau, const TH1* hist_y, Double_t scaleBias = 0.0); Do unfolding of an input histogram; tau_reg: regularisation parameter; input: input distribution with errors; scaleBias: scale factor applied to the bias; Data members required:; fA, fX0, fLsquared; Data members modified:; those documented in SetInput(); and those documented in DoUnfold(Double_t); Return value:; maximum global correlation coefficient; NOTE!!! return value >=1.0 means error, and the result is junk. Overflow bins of the input distribution are ignored!. Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0.0, Double_t oneOverZeroError = 0.0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Data members modified:; fY, fVyy, fVyyinv, fBiasScale, fNdf; Data members cleared; see ClearResults. Double_t DoUnfold(Double_t tau); Unfold with given value of regularisation parameter tau; tau: new tau parameter; required data members:; fA: matrix to relate x and y; fY: measured data points; fX0: bias on x; fBiasScale: scale factor for fX0; fV: inverse of covariance matrix for y; fLsquared: regularisation conditions; modified data members:; fTauSquared and those documented in DoUnfold(void). Int_t ScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); scan the L curve; nPoint: number of points on the resulting curve; tauMin: smallest tau value to study; tauMax: largest tau value to study; lCurve: the L curve as graph; logTauX: output spline of x-coordinates vs tau for the L curve; logTauY: output spline of y-coordinates vs tau for the L curve; return value: the coordinate ",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:27995,Availability,error,errors,27995,"Unfold(Double_t tau, const TH1* hist_y, Double_t scaleBias = 0.0); Do unfolding of an input histogram; tau_reg: regularisation parameter; input: input distribution with errors; scaleBias: scale factor applied to the bias; Data members required:; fA, fX0, fLsquared; Data members modified:; those documented in SetInput(); and those documented in DoUnfold(Double_t); Return value:; maximum global correlation coefficient; NOTE!!! return value >=1.0 means error, and the result is junk. Overflow bins of the input distribution are ignored!. Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0.0, Double_t oneOverZeroError = 0.0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Data members modified:; fY, fVyy, fVyyinv, fBiasScale, fNdf; Data members cleared; see ClearResults. Double_t DoUnfold(Double_t tau); Unfold with given value of regularisation parameter tau; tau: new tau parameter; required data members:; fA: matrix to relate x and y; fY: measured data points; fX0: bias on x; fBiasScale: scale factor for fX0; fV: inverse of covariance matrix for y; fLsquared: regularisation conditions; modified data members:; fTauSquared and those documented in DoUnfold(void). Int_t ScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); scan the L curve; nPoint: number of points on the resulting curve; tauMin: smallest tau value to study; tauMax: largest tau value to study; lCurve: the L curve as graph; logTauX: output spline of x-coordinates vs tau for the L curve; logTauY: output spline of y-coordinates vs tau for the L curve; return value: the coordinate ",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:30591,Availability,error,error,30591,"put(const char* name, const char* title, Double_t y0 = 0.0, Double_t y1 = 0.0) const; retreive unfolding result folded back by the matrix; name: name of the histogram; title: title of the histogram; y0,y1: lower/upper edge of histogram.; if (y0>=y1) then y0=0 and y1=nbin are used. TH1D * GetInput(const char* name, const char* title, Double_t y0 = 0.0, Double_t y1 = 0.0) const; retreive input distribution; name: name of the histogram; title: title of the histogram; y0,y1: lower/upper edge of histogram.; if (y0>=y1) then y0=0 and y1=nbin are used. TH2D * GetRhoIJ(const char* name, const char* title, Double_t x0 = 0.0, Double_t x1 = 0.0) const; retreive full matrix of correlation coefficients; name: name of the histogram; title: title of the histogram; x0,x1: lower/upper edge of histogram.; if (x0>=x1) then x0=0 and x1=nbin are used. TH2D * GetEmatrix(const char* name, const char* title, Double_t x0 = 0.0, Double_t x1 = 0.0) const; retreive full error matrix; name: name of the histogram; title: title of the histogram; x0,x1: lower/upper edge of histogram.; if (x0>=x1) then x0=0 and x1=nbin are used. TH1D * GetRhoI(const char* name, const char* title, Double_t x0 = 0.0, Double_t x1 = 0.0) const; retreive matrix of global correlation coefficients; name: name of the histogram; title: title of the histogram; x0,x1: lower/upper edge of histogram.; if (x0>=x1) then x0=0 and x1=nbin are used. TH2D * GetLsquared(const char* name, const char* title, Double_t x0 = 0.0, Double_t x1 = 0.0) const; retreive ix of regularisation conditions squared; name: name of the histogram; title: title of the histogram; x0,x1: lower/upper edge of histogram.; if (x0>=x1) then x0=0 and x1=nbin are used. void SetConstraint(TUnfold::EConstraint constraint); set type of constraint for the next unfolding. Double_t GetTau(void); return regularisation parameter. Double_t GetChi2L(void); return chi**2 contribution from regularisation conditions. Int_t GetNpar(void); return number of parameters. Double_t Ge",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:32149,Availability,Error,ErrorMatrixToHist,32149,">=x1) then x0=0 and x1=nbin are used. void SetConstraint(TUnfold::EConstraint constraint); set type of constraint for the next unfolding. Double_t GetTau(void); return regularisation parameter. Double_t GetChi2L(void); return chi**2 contribution from regularisation conditions. Int_t GetNpar(void); return number of parameters. Double_t GetLcurveX(void); return value on x axis of L curve. Double_t GetLcurveY(void); return value on y axis of L curve. void GetOutput(TH1* output, const Int_t* binMap = 0) const; get output distribution, cumulated over several bins; output: output histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void ErrorMatrixToHist(TH2* ematrix, const TMatrixDSparse* emat, const Int_t* binMap, Bool_t doClear) const; get an error matrix, cumulated over several bins; ematrix: output error matrix histogram; emat: error matrix; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; get output error matrix, cumulated over several bins; ematrix: output error matrix histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. Double_t GetRhoI(TH1* rhoi, TH2* ematrixinv = 0, const Int_t* binMap = 0) const; get global correlation coefficients and inverted error matrix,; cumulated over several bins; rhoi: global correlation histogram; ematrixinv: inverse of error matrix (if pointer==0 it i",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:32260,Availability,error,error,32260,">=x1) then x0=0 and x1=nbin are used. void SetConstraint(TUnfold::EConstraint constraint); set type of constraint for the next unfolding. Double_t GetTau(void); return regularisation parameter. Double_t GetChi2L(void); return chi**2 contribution from regularisation conditions. Int_t GetNpar(void); return number of parameters. Double_t GetLcurveX(void); return value on x axis of L curve. Double_t GetLcurveY(void); return value on y axis of L curve. void GetOutput(TH1* output, const Int_t* binMap = 0) const; get output distribution, cumulated over several bins; output: output histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void ErrorMatrixToHist(TH2* ematrix, const TMatrixDSparse* emat, const Int_t* binMap, Bool_t doClear) const; get an error matrix, cumulated over several bins; ematrix: output error matrix histogram; emat: error matrix; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; get output error matrix, cumulated over several bins; ematrix: output error matrix histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. Double_t GetRhoI(TH1* rhoi, TH2* ematrixinv = 0, const Int_t* binMap = 0) const; get global correlation coefficients and inverted error matrix,; cumulated over several bins; rhoi: global correlation histogram; ematrixinv: inverse of error matrix (if pointer==0 it i",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:32319,Availability,error,error,32319,">=x1) then x0=0 and x1=nbin are used. void SetConstraint(TUnfold::EConstraint constraint); set type of constraint for the next unfolding. Double_t GetTau(void); return regularisation parameter. Double_t GetChi2L(void); return chi**2 contribution from regularisation conditions. Int_t GetNpar(void); return number of parameters. Double_t GetLcurveX(void); return value on x axis of L curve. Double_t GetLcurveY(void); return value on y axis of L curve. void GetOutput(TH1* output, const Int_t* binMap = 0) const; get output distribution, cumulated over several bins; output: output histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void ErrorMatrixToHist(TH2* ematrix, const TMatrixDSparse* emat, const Int_t* binMap, Bool_t doClear) const; get an error matrix, cumulated over several bins; ematrix: output error matrix histogram; emat: error matrix; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; get output error matrix, cumulated over several bins; ematrix: output error matrix histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. Double_t GetRhoI(TH1* rhoi, TH2* ematrixinv = 0, const Int_t* binMap = 0) const; get global correlation coefficients and inverted error matrix,; cumulated over several bins; rhoi: global correlation histogram; ematrixinv: inverse of error matrix (if pointer==0 it i",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:32349,Availability,error,error,32349,">=x1) then x0=0 and x1=nbin are used. void SetConstraint(TUnfold::EConstraint constraint); set type of constraint for the next unfolding. Double_t GetTau(void); return regularisation parameter. Double_t GetChi2L(void); return chi**2 contribution from regularisation conditions. Int_t GetNpar(void); return number of parameters. Double_t GetLcurveX(void); return value on x axis of L curve. Double_t GetLcurveY(void); return value on y axis of L curve. void GetOutput(TH1* output, const Int_t* binMap = 0) const; get output distribution, cumulated over several bins; output: output histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void ErrorMatrixToHist(TH2* ematrix, const TMatrixDSparse* emat, const Int_t* binMap, Bool_t doClear) const; get an error matrix, cumulated over several bins; ematrix: output error matrix histogram; emat: error matrix; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; get output error matrix, cumulated over several bins; ematrix: output error matrix histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. Double_t GetRhoI(TH1* rhoi, TH2* ematrixinv = 0, const Int_t* binMap = 0) const; get global correlation coefficients and inverted error matrix,; cumulated over several bins; rhoi: global correlation histogram; ematrixinv: inverse of error matrix (if pointer==0 it i",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:32692,Availability,error,error,32692,"L curve. void GetOutput(TH1* output, const Int_t* binMap = 0) const; get output distribution, cumulated over several bins; output: output histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void ErrorMatrixToHist(TH2* ematrix, const TMatrixDSparse* emat, const Int_t* binMap, Bool_t doClear) const; get an error matrix, cumulated over several bins; ematrix: output error matrix histogram; emat: error matrix; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; get output error matrix, cumulated over several bins; ematrix: output error matrix histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. Double_t GetRhoI(TH1* rhoi, TH2* ematrixinv = 0, const Int_t* binMap = 0) const; get global correlation coefficients and inverted error matrix,; cumulated over several bins; rhoi: global correlation histogram; ematrixinv: inverse of error matrix (if pointer==0 it is not returned); binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. return value: average global correlation. void GetRhoIJ(TH2* rhoij, const Int_t* binMap = 0) const; get correlation coefficient matrix, cumulated over several bins; rhoij:",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:32751,Availability,error,error,32751,"L curve. void GetOutput(TH1* output, const Int_t* binMap = 0) const; get output distribution, cumulated over several bins; output: output histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void ErrorMatrixToHist(TH2* ematrix, const TMatrixDSparse* emat, const Int_t* binMap, Bool_t doClear) const; get an error matrix, cumulated over several bins; ematrix: output error matrix histogram; emat: error matrix; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; get output error matrix, cumulated over several bins; ematrix: output error matrix histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. Double_t GetRhoI(TH1* rhoi, TH2* ematrixinv = 0, const Int_t* binMap = 0) const; get global correlation coefficients and inverted error matrix,; cumulated over several bins; rhoi: global correlation histogram; ematrixinv: inverse of error matrix (if pointer==0 it is not returned); binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. return value: average global correlation. void GetRhoIJ(TH2* rhoij, const Int_t* binMap = 0) const; get correlation coefficient matrix, cumulated over several bins; rhoij:",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:33161,Availability,error,error,33161," Int_t* binMap, Bool_t doClear) const; get an error matrix, cumulated over several bins; ematrix: output error matrix histogram; emat: error matrix; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; get output error matrix, cumulated over several bins; ematrix: output error matrix histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. Double_t GetRhoI(TH1* rhoi, TH2* ematrixinv = 0, const Int_t* binMap = 0) const; get global correlation coefficients and inverted error matrix,; cumulated over several bins; rhoi: global correlation histogram; ematrixinv: inverse of error matrix (if pointer==0 it is not returned); binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. return value: average global correlation. void GetRhoIJ(TH2* rhoij, const Int_t* binMap = 0) const; get correlation coefficient matrix, cumulated over several bins; rhoij: correlation coefficient matrix histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. TUnfold(const TUnfold& ). TMatrixDSparse * CreateSparseMatrix(Int_t nrow, Int_t ncol, Int_t nele, Int_t* row, Int_t* col, Double_t* data) const. Int_t GetNx(void). Int_t GetNy(",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:33264,Availability,error,error,33264," Int_t* binMap, Bool_t doClear) const; get an error matrix, cumulated over several bins; ematrix: output error matrix histogram; emat: error matrix; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; get output error matrix, cumulated over several bins; ematrix: output error matrix histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. Double_t GetRhoI(TH1* rhoi, TH2* ematrixinv = 0, const Int_t* binMap = 0) const; get global correlation coefficients and inverted error matrix,; cumulated over several bins; rhoi: global correlation histogram; ematrixinv: inverse of error matrix (if pointer==0 it is not returned); binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. return value: average global correlation. void GetRhoIJ(TH2* rhoij, const Int_t* binMap = 0) const; get correlation coefficient matrix, cumulated over several bins; rhoij: correlation coefficient matrix histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. TUnfold(const TUnfold& ). TMatrixDSparse * CreateSparseMatrix(Int_t nrow, Int_t ncol, Int_t nele, Int_t* row, Int_t* col, Double_t* data) const. Int_t GetNx(void). Int_t GetNy(",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:1428,Energy Efficiency,reduce,reduce,1428,"s (dimension ny); Vyy: covariance matrix for y (dimension ny x ny); in many cases V is diagonal and calculated from the errors of y; A: migration matrix (dimension ny x nx); x: unknown underlying distribution (dimension nx). Regularisation. tau: parameter, defining the regularisation strength; L: matrix of regularisation conditions (dimension nl x nx); x0: bias distribution. Preservation of the area. lambda: lagrangian multiplier; y_i: one component of the vector y; (Ax)_i: one component of the vector Ax. and chi**2 is minimized; (a) not constrained: minimisation is performed a function of x for fixed lambda=0; or; (b) constrained: minimisation is performed a function of x and lambda. This applies to a very large number of problems, where the measured; distribution y is a linear superposition of several Monte Carlo shapes; and the sum of these shapes gives the output distribution x. The constraint can be useful to reduce biases on the result x; in cases where the vector y follows non-Gaussian probability densities; (example: Poisson statistics at counting experiments in particle physics). Some random examples:. (1) measure a cross-section as a function of, say, E_T(detector); and unfold it to obtain the underlying distribution E_T(generator); (2) measure a lifetime distribution and unfold the contributions from; different flavours; (3) measure the transverse mass and decay angle; and unfold for the true mass distribution plus background. Documentation. Some technical documentation is available here:; http://www.desy.de/~sschmitt. References:. A nice overview of the method is given in:; The L-curve and Its Use in the Numerical Treatment of Inverse Problems; (2000) by P. C. Hansen, in Computational Inverse Problems in; Electrocardiology, ed. P. Johnston,; Advances in Computational Bioengineering; http://www.imm.dtu.dk/~pch/TR/Lcurve.ps; The relevant equations are (1), (2) for the unfolding; and (14) for the L-curve curvature definition. Related literature on unfolding",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:4377,Integrability,depend,depends,4377," V_xx is calculated as:; Vxx_ij = sum_kl dx_i/dy_k Vyy_kl dx_j/dy_l. Warning:. The algorithm is based on ""standard"" matrix inversion, with the; known limitations in numerical accuracy and computing cost for; matrices with large dimensions. Thus the algorithm should not used for large dimensions of x and y; nx should not be much larger than 200; ny should not be much larger than 1000. Example of using TUnfold:. imagine a 2-dimensional histogram is filled, named A; y-axis: generated quantity (e.g. 10 bins); x-axis: reconstructed quantity (e.g. 20 bin); The data are filled in a 1-dimensional histogram, named y; Note1: ALWAYS choose a higher number of bins on the reconstructed side; as compared to the generated size!; Note2: the events which are generated but not reconstructed; have to be added to the appropriate overflow bins of A; Note3: make sure all bins have sufficient statistics and their error is; non-zero. By default, bins with zero error are simply skipped;; however, this may cause problems if You try to unfold something; which depends on these input bins. code fragment (with histograms A and y filled):. TUnfold unfold(A,TUnfold::kHistMapOutputHoriz);; Double_t tau=1.E-4;; Double_t biasScale=0.0;; unfold.DoUnfold(tau,y,biasScale);; TH1D *x=unfold.GetOutput(""x"",""myVariable"");; TH2D *rhoij=unfold.GetRhoIJ(""correlation"",""myVariable"");. will create histograms ""x"" and ""correlation"" from A and y.; if tau is very large, the output is biased to the generated distribution scaled by biasScale; if tau is very small, the output will show oscillations; and large entries in the correlation matrix. Proper choice of tau. One of the difficult questions is about the choice of tau. The most; common method is the L-curve method: a two-dimensional curve is plotted; x-axis: log10(chisquare); y-axis: log10(regularisation condition); In many cases this curve has an L-shape. The best choice of tau is in the; kink of the L. Within TUnfold a simple version of the L-curve analysis is incl",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:24626,Integrability,depend,depending,24626," * InvertMSparse(const TMatrixDSparse* A) const; get the inverse of a sparse matrix; A: the original matrix; this is a replacement of the call; new TMatrixD(TMatrixD::kInverted, a);; the matrix inversion is optimized for the case; where a large submatrix of A is diagonal. Bool_t InvertMConditioned(TMatrixD* A); invert the matrix A; the inversion is done with pre-conditioning; all rows and columns are normalized to sqrt(abs(a_ii*a_jj)); such that the diagonals are equal to 1.0; This type of preconditioning improves the numerival results; for the symmetric, positive definite matrices which are; treated here in the context of unfolding. TUnfold(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintArea); set up unfolding matrix and initial regularisation scheme; hist_A: matrix that describes the migrations; histmap: mapping of the histogram axes to the unfolding output; regmode: global regularisation mode; constraint: type of constraint to use; data members initialized to something different from zero:; fA: filled from hist_A; fDA: filled from hist_A; fX0: filled from hist_A; fLsquared: filled depending on the regularisation scheme; Treatment of overflow bins; Bins where the unfolding input (Detector level) is in overflow; are used for the efficiency correction. They have to be filled; properly!; Bins where the unfolding output (Generator level) is in overflow; are treated as a part of the generator level distribution.; I.e. the unfolding output could have non-zero overflow bins if the; input matrix does have such bins. ~TUnfold(void); delete all data members. void SetBias(const TH1* bias); initialize alternative bias from histogram; modifies data member fX0. Int_t RegularizeSize(int bin, Double_t scale = 1.0); add regularisation on the size of bin i; bin: bin number; scale: size of the regularisation; return value: number of conditions which have been skipped; modifies data member fLsquare",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:6792,Modifiability,variab,variables,6792,"fold.ScanLcurve(nScan,0.0,0.0,&lCurve);. std::cout<<""tau=""<<unfold.GetTau()<<""\n"";. TH1D *x=unfold.GetOutput(""x"",""myVariable"");; TH2D *rhoij=unfold.GetRhoIJ(""correlation"",""myVariable"");. This creates; logTauX: the L-curve's x-coordinate as a function of log(tau); logTauY: the L-curve's y-coordinate as a function of log(tau); lCurve: a graph of the L-curve; x,rhoij: unfolding result for best choice of tau; iBest: the coordinate/spline knot number with the best choice of tau. Note: always check the L curve after unfolding. The algorithm is not; perfect. Bin averaging of the output. Sometimes it is useful to unfold for a fine binning in x and; calculate the final result with a smaller number of bins. The advantage; is a reduction in the correlation coefficients if bins are averaged.; For this type of averaging the full error matrix has to be used.; There are methods in TUnfold to support this type of calculation; Example:; The vector x has dimension 49, it consists of 7x7 bins; in two variables (Pt,Eta); The unfolding result is to be presented as one-dimensional projections; in (Pt) and (Eta); The bins of x are mapped as: bins 1..7 the first Eta bin; bins 2..14 the second Eta bin. bins 1,8,15,... the first Pt bin. code fragment:. TUnfold unfold(A,TUnfold::kHistMapOutputHoriz);; Double_t tau=1.E-4;; Double_t biasScale=0.0;; unfold.DoUnfold(tau,y,biasScale);; Int_t binMapEta[49+2];; Int_t binMapPt[49+2];; // overflow and underflow bins are not used; binMapEta[0]=-1;; binMapEta[49+1]=-1;; binMapPt[0]=-1;; binMapPt[49+1]=-1;; for(Int_t i=1;i<=49;i++) {; // all bins (i) with the same (i-1)/7 are added; binMapEta[i] = (i-1)/7 +1;; // all bins (i) with the same (i-1)%7 are added; binMapPt[i] = (i-1)%7 +1;; }; TH1D *etaHist=new TH1D(""eta(unfolded)"","";eta"",7,etamin,etamax);; TH1D *etaCorr=new TH2D(""eta(unfolded)"","";eta;eta"",7,etamin,etamax,7,etamin,etamax);; TH1D *ptHist=new TH1D(""pt(unfolded)"","";pt"",7,ptmin,ptmax);; TH1D *ptCorr=new TH2D(""pt(unfolded)"","";pt;pt"",7,ptmin,ptmax,7",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:10080,Modifiability,variab,variables,10080,"imize the size of (x-x0); kRegModeDerivative minimize the 1st derivative of (x-x0); kRegModeCurvature minimize the 2nd derivative of (x-x0). kRegModeSize is the regularisation scheme which usually is found in; literature. In addition, the bias usually is not present; (bias scale factor is zero). The non-standard regularisation schemes kRegModeDerivative and; kRegModeCurvature have the nice feature that they create correlations; between x-bins, whereas the non-regularized unfolding tends to create; negative correlations between bins. For these regularisation schemes the; parameter tau could be tuned such that the correlations are smallest,; as an alternative to the L-curve method. If kRegModeSize is chosen or if x is a smooth function through all bins,; the regularisation condition can be set on all bins together by giving; the appropriate argument in the constructor (see examples above). If x is composed of independent groups of bins (for example,; signal and background binning in two variables), it may be necessary to; set regularisation conditions for the individual groups of bins.; In this case, give kRegModeNone in the constructor and specify; the bin grouping with calls to; RegularizeBins() specify a 1-dimensional group of bins; RegularizeBins2D() specify a 2-dimensional group of bins. For ultimate flexibility, the regularisation condition can be set on each; bin individually; -> give kRegModeNone in the constructor and use; RegularizeSize() regularize one bin; RegularizeDerivative() regularize the slope given by two bins; RegularizeCurvature() regularize the curvature given by three bins. Function Members (Methods); public:. TUnfold(const TUnfold&); TUnfold(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintArea); virtual~TUnfold(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* ",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:14245,Modifiability,Inherit,InheritsFrom,14245,"le_t x1 = 0.0) const; Double_tGetRhoMax() const; Double_tGetTau() const; virtual const char*TObject::GetTitle() const; static const char*GetTUnfoldVersion(); virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TUnfold&operator=(const TUnfold&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); Int_tRegularizeBins(int start, int step, int nbin, TUnfold::ERegMode regmode); Int_tRegularizeBins2D(int start_bin, int step1, int nbin1, int step2, int nbin2, TUnfold::ERegMode regmode); Int_tRegularizeCurvature(int left_bin, int center_bin, int right_bin, Double_t scale_left = 1.0, Double_t ",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:14311,Modifiability,Inherit,InheritsFrom,14311,"le_t x1 = 0.0) const; Double_tGetRhoMax() const; Double_tGetTau() const; virtual const char*TObject::GetTitle() const; static const char*GetTUnfoldVersion(); virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TUnfold&operator=(const TUnfold&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); Int_tRegularizeBins(int start, int step, int nbin, TUnfold::ERegMode regmode); Int_tRegularizeBins2D(int start_bin, int step1, int nbin1, int step2, int nbin2, TUnfold::ERegMode regmode); Int_tRegularizeCurvature(int left_bin, int center_bin, int right_bin, Double_t scale_left = 1.0, Double_t ",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:20810,Modifiability,Inherit,Inheritance,20810,"aredInput: regularisation parameter; TMatrixDSparse*fVyyInput: covariance matrix for y; TMatrixD*fX0Input: x0; TArrayIfXToHistInput: matrix indices -> histogram bins; TMatrixD*fYInput: y. private:. TMatrixDSparse*fAxResult: Ax; Double_tfChi2AResult: chi**2 contribution from (y-Ax)V(y-Ax); TMatrixDSparse*fDXDAM[2]Result: part of derivative dx_k/dA_ij; TMatrixDSparse*fDXDAZ[2]Result: part of derivative dx_k/dA_ij; TMatrixDSparse*fDXDYResult: derivative dx/dy; TMatrixDSparse*fDXDtauSquaredResult: derivative dx/dtau; TMatrixDSparse*fEResult: matrix E; TMatrixDSparse*fEinvResult: matrix E^(-1); Double_tfLXsquaredResult: chi**2 contribution from (x-s*x0)Lsquared(x-s*x0); Int_tfNdfResult: number of degrees of freedom; Double_tfRhoAvgResult: average global correlation; Double_tfRhoMaxResult: maximum global correlation; TMatrixDSparse*fVxxResult: covariance matrix on x; TMatrixDSparse*fVxxInvResult: inverse of covariance matrix on x; TMatrixD*fXResult: x. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const char * GetTUnfoldVersion(void). void InitTUnfold(void); reset all data members. void DeleteMatrix(TMatrixD** m). void DeleteMatrix(TMatrixDSparse** m). void ClearResults(void); delete old results (if any); this function is virtual, so derived classes may flag their results; ad non-valid as well. TUnfold(const TUnfold& ); set all matrix pointers to zero. Double_t DoUnfold(Double_t tau); main unfolding algorithm. Declared virtual, because other algorithms; could be implemented. Purpose: unfold y -> x; Data members required:; fA: matrix to relate x and y; fY: measured data points; fX0: bias on x; fBiasScale: scale factor for fX0; fVyy: covariance matrix for y; fLsquared: regularisation conditions; fTauSquared: regularisation strength; fConstraint: whether the constraint is applied; Data members modified:; fEinv: inverse of the covariance matrix of x; fE: covariance matrix of x; fX: unfolded data points; fDXDY: derivative of x wrt y ",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:20823,Modifiability,Inherit,Inherited,20823,"aredInput: regularisation parameter; TMatrixDSparse*fVyyInput: covariance matrix for y; TMatrixD*fX0Input: x0; TArrayIfXToHistInput: matrix indices -> histogram bins; TMatrixD*fYInput: y. private:. TMatrixDSparse*fAxResult: Ax; Double_tfChi2AResult: chi**2 contribution from (y-Ax)V(y-Ax); TMatrixDSparse*fDXDAM[2]Result: part of derivative dx_k/dA_ij; TMatrixDSparse*fDXDAZ[2]Result: part of derivative dx_k/dA_ij; TMatrixDSparse*fDXDYResult: derivative dx/dy; TMatrixDSparse*fDXDtauSquaredResult: derivative dx/dtau; TMatrixDSparse*fEResult: matrix E; TMatrixDSparse*fEinvResult: matrix E^(-1); Double_tfLXsquaredResult: chi**2 contribution from (x-s*x0)Lsquared(x-s*x0); Int_tfNdfResult: number of degrees of freedom; Double_tfRhoAvgResult: average global correlation; Double_tfRhoMaxResult: maximum global correlation; TMatrixDSparse*fVxxResult: covariance matrix on x; TMatrixDSparse*fVxxInvResult: inverse of covariance matrix on x; TMatrixD*fXResult: x. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const char * GetTUnfoldVersion(void). void InitTUnfold(void); reset all data members. void DeleteMatrix(TMatrixD** m). void DeleteMatrix(TMatrixDSparse** m). void ClearResults(void); delete old results (if any); this function is virtual, so derived classes may flag their results; ad non-valid as well. TUnfold(const TUnfold& ); set all matrix pointers to zero. Double_t DoUnfold(Double_t tau); main unfolding algorithm. Declared virtual, because other algorithms; could be implemented. Purpose: unfold y -> x; Data members required:; fA: matrix to relate x and y; fY: measured data points; fX0: bias on x; fBiasScale: scale factor for fX0; fVyy: covariance matrix for y; fLsquared: regularisation conditions; fTauSquared: regularisation strength; fConstraint: whether the constraint is applied; Data members modified:; fEinv: inverse of the covariance matrix of x; fE: covariance matrix of x; fX: unfolded data points; fDXDY: derivative of x wrt y ",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:1073,Performance,perform,performed,1073,"ource file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfold. class TUnfold: public TObject. TUnfold solves the inverse problem. chi**2 = (y-Ax)# Vyy^-1 (y-Ax) + tau^2 (L(x-x0))# L(x-x0) + lambda sum_i(y_i -(Ax)_i). where # means that the matrix is transposed. Monte Carlo input. y: vector of measured quantities (dimension ny); Vyy: covariance matrix for y (dimension ny x ny); in many cases V is diagonal and calculated from the errors of y; A: migration matrix (dimension ny x nx); x: unknown underlying distribution (dimension nx). Regularisation. tau: parameter, defining the regularisation strength; L: matrix of regularisation conditions (dimension nl x nx); x0: bias distribution. Preservation of the area. lambda: lagrangian multiplier; y_i: one component of the vector y; (Ax)_i: one component of the vector Ax. and chi**2 is minimized; (a) not constrained: minimisation is performed a function of x for fixed lambda=0; or; (b) constrained: minimisation is performed a function of x and lambda. This applies to a very large number of problems, where the measured; distribution y is a linear superposition of several Monte Carlo shapes; and the sum of these shapes gives the output distribution x. The constraint can be useful to reduce biases on the result x; in cases where the vector y follows non-Gaussian probability densities; (example: Poisson statistics at counting experiments in particle physics). Some random examples:. (1) measure a cross-section as a function of, say, E_T(detector); and unfold it to obtain the underlying distribution E_T(generator); (2) measure a lifetime distribution and unfold the contributions from; different flavours; (3) measure the transverse mass and decay angle; and unfold for the true mass distribution plus background. Documentation. Some technical documentation is available here:; http://www.desy.de/~sschmitt. References:. A nice overview of the method is ",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:1156,Performance,perform,performed,1156,"ource file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfold. class TUnfold: public TObject. TUnfold solves the inverse problem. chi**2 = (y-Ax)# Vyy^-1 (y-Ax) + tau^2 (L(x-x0))# L(x-x0) + lambda sum_i(y_i -(Ax)_i). where # means that the matrix is transposed. Monte Carlo input. y: vector of measured quantities (dimension ny); Vyy: covariance matrix for y (dimension ny x ny); in many cases V is diagonal and calculated from the errors of y; A: migration matrix (dimension ny x nx); x: unknown underlying distribution (dimension nx). Regularisation. tau: parameter, defining the regularisation strength; L: matrix of regularisation conditions (dimension nl x nx); x0: bias distribution. Preservation of the area. lambda: lagrangian multiplier; y_i: one component of the vector y; (Ax)_i: one component of the vector Ax. and chi**2 is minimized; (a) not constrained: minimisation is performed a function of x for fixed lambda=0; or; (b) constrained: minimisation is performed a function of x and lambda. This applies to a very large number of problems, where the measured; distribution y is a linear superposition of several Monte Carlo shapes; and the sum of these shapes gives the output distribution x. The constraint can be useful to reduce biases on the result x; in cases where the vector y follows non-Gaussian probability densities; (example: Poisson statistics at counting experiments in particle physics). Some random examples:. (1) measure a cross-section as a function of, say, E_T(detector); and unfold it to obtain the underlying distribution E_T(generator); (2) measure a lifetime distribution and unfold the contributions from; different flavours; (3) measure the transverse mass and decay angle; and unfold for the true mass distribution plus background. Documentation. Some technical documentation is available here:; http://www.desy.de/~sschmitt. References:. A nice overview of the method is ",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:9680,Performance,tune,tuned,9680,"alisation between data; and Monte Carlo. If the regularisation is strong, i.e. large parameter tau,; then the distribution x or its derivatives will look like the bias; distribution. If the parameter tau is small, the distribution x is; independent of the bias. Three basic types of regularisation are implemented in TUnfold. condition regularisation. kRegModeNone none; kRegModeSize minimize the size of (x-x0); kRegModeDerivative minimize the 1st derivative of (x-x0); kRegModeCurvature minimize the 2nd derivative of (x-x0). kRegModeSize is the regularisation scheme which usually is found in; literature. In addition, the bias usually is not present; (bias scale factor is zero). The non-standard regularisation schemes kRegModeDerivative and; kRegModeCurvature have the nice feature that they create correlations; between x-bins, whereas the non-regularized unfolding tends to create; negative correlations between bins. For these regularisation schemes the; parameter tau could be tuned such that the correlations are smallest,; as an alternative to the L-curve method. If kRegModeSize is chosen or if x is a smooth function through all bins,; the regularisation condition can be set on all bins together by giving; the appropriate argument in the constructor (see examples above). If x is composed of independent groups of bins (for example,; signal and background binning in two variables), it may be necessary to; set regularisation conditions for the individual groups of bins.; In this case, give kRegModeNone in the constructor and specify; the bin grouping with calls to; RegularizeBins() specify a 1-dimensional group of bins; RegularizeBins2D() specify a 2-dimensional group of bins. For ultimate flexibility, the regularisation condition can be set on each; bin individually; -> give kRegModeNone in the constructor and use; RegularizeSize() regularize one bin; RegularizeDerivative() regularize the slope given by two bins; RegularizeCurvature() regularize the curvature given by thr",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:23645,Performance,optimiz,optimized,23645,"is is a replacement for the call; new TMatrixDSparse(*a,TMatrixDSparse::kMult,*b);. TMatrixDSparse * MultiplyMSparseTranspMSparse(const TMatrixDSparse* a, const TMatrixDSparse* b) const; multiply a transposed Sparse matrix with another Sparse matrix; a: pointer to sparse matrix (to be transposed); b: pointer to sparse matrix; this is a replacement for the call; new TMatrixDSparse(TMatrixDSparse(TMatrixDSparse::kTransposed,*a),; TMatrixDSparse::kMult,*b). TMatrixDSparse * MultiplyMSparseM(const TMatrixDSparse* a, const TMatrixD* b) const; multiply a Sparse matrix with a non-sparse matrix; a: pointer to sparse matrix; b: pointer to non-sparse matrix; this is a replacement for the call; new TMatrixDSparse(*a,TMatrixDSparse::kMult,*b);. void AddMSparse(TMatrixDSparse* dest, Double_t f, const TMatrixDSparse* src); a replacement for; (*dest) += f*(*src). TMatrixD * InvertMSparse(const TMatrixDSparse* A) const; get the inverse of a sparse matrix; A: the original matrix; this is a replacement of the call; new TMatrixD(TMatrixD::kInverted, a);; the matrix inversion is optimized for the case; where a large submatrix of A is diagonal. Bool_t InvertMConditioned(TMatrixD* A); invert the matrix A; the inversion is done with pre-conditioning; all rows and columns are normalized to sqrt(abs(a_ii*a_jj)); such that the diagonals are equal to 1.0; This type of preconditioning improves the numerival results; for the symmetric, positive definite matrices which are; treated here in the context of unfolding. TUnfold(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintArea); set up unfolding matrix and initial regularisation scheme; hist_A: matrix that describes the migrations; histmap: mapping of the histogram axes to the unfolding output; regmode: global regularisation mode; constraint: type of constraint to use; data members initialized to something different from zero:; fA: filled from hist_A; fDA: filled ",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:1684,Safety,detect,detector,1684," L: matrix of regularisation conditions (dimension nl x nx); x0: bias distribution. Preservation of the area. lambda: lagrangian multiplier; y_i: one component of the vector y; (Ax)_i: one component of the vector Ax. and chi**2 is minimized; (a) not constrained: minimisation is performed a function of x for fixed lambda=0; or; (b) constrained: minimisation is performed a function of x and lambda. This applies to a very large number of problems, where the measured; distribution y is a linear superposition of several Monte Carlo shapes; and the sum of these shapes gives the output distribution x. The constraint can be useful to reduce biases on the result x; in cases where the vector y follows non-Gaussian probability densities; (example: Poisson statistics at counting experiments in particle physics). Some random examples:. (1) measure a cross-section as a function of, say, E_T(detector); and unfold it to obtain the underlying distribution E_T(generator); (2) measure a lifetime distribution and unfold the contributions from; different flavours; (3) measure the transverse mass and decay angle; and unfold for the true mass distribution plus background. Documentation. Some technical documentation is available here:; http://www.desy.de/~sschmitt. References:. A nice overview of the method is given in:; The L-curve and Its Use in the Numerical Treatment of Inverse Problems; (2000) by P. C. Hansen, in Computational Inverse Problems in; Electrocardiology, ed. P. Johnston,; Advances in Computational Bioengineering; http://www.imm.dtu.dk/~pch/TR/Lcurve.ps; The relevant equations are (1), (2) for the unfolding; and (14) for the L-curve curvature definition. Related literature on unfolding:; The program package RUN and the web-page by V.Blobel; http://www.desy.de/~blobel/unfold.html; Talk by V. Blobel, Terascale Statistics school; https://indico.desy.de/contributionDisplay.py?contribId=23&confId=1149; References quoted in Blobel's talk:; Per Chistian Hansen, Rank-Deficient and D",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:8064,Safety,avoid,avoid,8064,"ld::kHistMapOutputHoriz);; Double_t tau=1.E-4;; Double_t biasScale=0.0;; unfold.DoUnfold(tau,y,biasScale);; Int_t binMapEta[49+2];; Int_t binMapPt[49+2];; // overflow and underflow bins are not used; binMapEta[0]=-1;; binMapEta[49+1]=-1;; binMapPt[0]=-1;; binMapPt[49+1]=-1;; for(Int_t i=1;i<=49;i++) {; // all bins (i) with the same (i-1)/7 are added; binMapEta[i] = (i-1)/7 +1;; // all bins (i) with the same (i-1)%7 are added; binMapPt[i] = (i-1)%7 +1;; }; TH1D *etaHist=new TH1D(""eta(unfolded)"","";eta"",7,etamin,etamax);; TH1D *etaCorr=new TH2D(""eta(unfolded)"","";eta;eta"",7,etamin,etamax,7,etamin,etamax);; TH1D *ptHist=new TH1D(""pt(unfolded)"","";pt"",7,ptmin,ptmax);; TH1D *ptCorr=new TH2D(""pt(unfolded)"","";pt;pt"",7,ptmin,ptmax,7,ptmin,ptmax);; unfold.GetOutput(etaHist,binMapEta);; unfold.GetRhoIJ(etaCorrt,binMapEta);; unfold.GetOutput(ptHist,binMapPt);; unfold.GetRhoIJ(ptCorrt,binMapPt);. Alternative Regularisation conditions. Regularisation is needed for most unfolding problems, in order to avoid; large oscillations and large correlations on the output bins.; It means that some extra conditions are applied on the output bins. Within TUnfold these conditions are posed on the difference (x-x0), where; x: unfolding output; x0: the bias distribution, by default calculated from; the input matrix A. There is a method SetBias() to change the; bias distribution.; The 3rd argument to DoUnfold() is a scale factor applied to the bias; bias_default[j] = sum_i A[i][j]; x0[j] = scaleBias*bias[j]; The scale factor can be used to; (a) completely suppress the bias by setting it to zero; (b) compensate differences in the normalisation between data; and Monte Carlo. If the regularisation is strong, i.e. large parameter tau,; then the distribution x or its derivatives will look like the bias; distribution. If the parameter tau is small, the distribution x is; independent of the bias. Three basic types of regularisation are implemented in TUnfold. condition regularisation. kRegModeNone none; k",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:24726,Safety,Detect,Detector,24726," * InvertMSparse(const TMatrixDSparse* A) const; get the inverse of a sparse matrix; A: the original matrix; this is a replacement of the call; new TMatrixD(TMatrixD::kInverted, a);; the matrix inversion is optimized for the case; where a large submatrix of A is diagonal. Bool_t InvertMConditioned(TMatrixD* A); invert the matrix A; the inversion is done with pre-conditioning; all rows and columns are normalized to sqrt(abs(a_ii*a_jj)); such that the diagonals are equal to 1.0; This type of preconditioning improves the numerival results; for the symmetric, positive definite matrices which are; treated here in the context of unfolding. TUnfold(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintArea); set up unfolding matrix and initial regularisation scheme; hist_A: matrix that describes the migrations; histmap: mapping of the histogram axes to the unfolding output; regmode: global regularisation mode; constraint: type of constraint to use; data members initialized to something different from zero:; fA: filled from hist_A; fDA: filled from hist_A; fX0: filled from hist_A; fLsquared: filled depending on the regularisation scheme; Treatment of overflow bins; Bins where the unfolding input (Detector level) is in overflow; are used for the efficiency correction. They have to be filled; properly!; Bins where the unfolding output (Generator level) is in overflow; are treated as a part of the generator level distribution.; I.e. the unfolding output could have non-zero overflow bins if the; input matrix does have such bins. ~TUnfold(void); delete all data members. void SetBias(const TH1* bias); initialize alternative bias from histogram; modifies data member fX0. Int_t RegularizeSize(int bin, Double_t scale = 1.0); add regularisation on the size of bin i; bin: bin number; scale: size of the regularisation; return value: number of conditions which have been skipped; modifies data member fLsquare",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:14135,Security,Hash,Hash,14135,"le_t x1 = 0.0) const; Double_tGetRhoMax() const; Double_tGetTau() const; virtual const char*TObject::GetTitle() const; static const char*GetTUnfoldVersion(); virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TUnfold&operator=(const TUnfold&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); Int_tRegularizeBins(int start, int step, int nbin, TUnfold::ERegMode regmode); Int_tRegularizeBins2D(int start_bin, int step1, int nbin1, int step2, int nbin2, TUnfold::ERegMode regmode); Int_tRegularizeCurvature(int left_bin, int center_bin, int right_bin, Double_t scale_left = 1.0, Double_t ",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:5338,Testability,test,tests,5338,"s. code fragment (with histograms A and y filled):. TUnfold unfold(A,TUnfold::kHistMapOutputHoriz);; Double_t tau=1.E-4;; Double_t biasScale=0.0;; unfold.DoUnfold(tau,y,biasScale);; TH1D *x=unfold.GetOutput(""x"",""myVariable"");; TH2D *rhoij=unfold.GetRhoIJ(""correlation"",""myVariable"");. will create histograms ""x"" and ""correlation"" from A and y.; if tau is very large, the output is biased to the generated distribution scaled by biasScale; if tau is very small, the output will show oscillations; and large entries in the correlation matrix. Proper choice of tau. One of the difficult questions is about the choice of tau. The most; common method is the L-curve method: a two-dimensional curve is plotted; x-axis: log10(chisquare); y-axis: log10(regularisation condition); In many cases this curve has an L-shape. The best choice of tau is in the; kink of the L. Within TUnfold a simple version of the L-curve analysis is included.; It tests a given number of points in a predefined tau-range and searches; for the maximum of the curvature in the L-curve (kink position).; if no tau range is given, the range of teh scan is determied automatically. Example: scan tau and produce the L-curve plot. Code fragment: assume A and y are filled. TUnfold unfold(A,TUnfold::kHistMapOutputHoriz);. unfold.SetInput(y);. Int_t nScan=30;; Int_t iBest;; TSpline *logTauX,*logTauY;; TGraph *lCurve;. iBest=unfold.ScanLcurve(nScan,0.0,0.0,&lCurve);. std::cout<<""tau=""<<unfold.GetTau()<<""\n"";. TH1D *x=unfold.GetOutput(""x"",""myVariable"");; TH2D *rhoij=unfold.GetRhoIJ(""correlation"",""myVariable"");. This creates; logTauX: the L-curve's x-coordinate as a function of log(tau); logTauY: the L-curve's y-coordinate as a function of log(tau); lCurve: a graph of the L-curve; x,rhoij: unfolding result for best choice of tau; iBest: the coordinate/spline knot number with the best choice of tau. Note: always check the L curve after unfolding. The algorithm is not; perfect. Bin averaging of the output. Sometimes it is usefu",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:5751,Testability,log,logTauX,5751,"if tau is very large, the output is biased to the generated distribution scaled by biasScale; if tau is very small, the output will show oscillations; and large entries in the correlation matrix. Proper choice of tau. One of the difficult questions is about the choice of tau. The most; common method is the L-curve method: a two-dimensional curve is plotted; x-axis: log10(chisquare); y-axis: log10(regularisation condition); In many cases this curve has an L-shape. The best choice of tau is in the; kink of the L. Within TUnfold a simple version of the L-curve analysis is included.; It tests a given number of points in a predefined tau-range and searches; for the maximum of the curvature in the L-curve (kink position).; if no tau range is given, the range of teh scan is determied automatically. Example: scan tau and produce the L-curve plot. Code fragment: assume A and y are filled. TUnfold unfold(A,TUnfold::kHistMapOutputHoriz);. unfold.SetInput(y);. Int_t nScan=30;; Int_t iBest;; TSpline *logTauX,*logTauY;; TGraph *lCurve;. iBest=unfold.ScanLcurve(nScan,0.0,0.0,&lCurve);. std::cout<<""tau=""<<unfold.GetTau()<<""\n"";. TH1D *x=unfold.GetOutput(""x"",""myVariable"");; TH2D *rhoij=unfold.GetRhoIJ(""correlation"",""myVariable"");. This creates; logTauX: the L-curve's x-coordinate as a function of log(tau); logTauY: the L-curve's y-coordinate as a function of log(tau); lCurve: a graph of the L-curve; x,rhoij: unfolding result for best choice of tau; iBest: the coordinate/spline knot number with the best choice of tau. Note: always check the L curve after unfolding. The algorithm is not; perfect. Bin averaging of the output. Sometimes it is useful to unfold for a fine binning in x and; calculate the final result with a smaller number of bins. The advantage; is a reduction in the correlation coefficients if bins are averaged.; For this type of averaging the full error matrix has to be used.; There are methods in TUnfold to support this type of calculation; Example:; The vector x has di",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:5760,Testability,log,logTauY,5760,"if tau is very large, the output is biased to the generated distribution scaled by biasScale; if tau is very small, the output will show oscillations; and large entries in the correlation matrix. Proper choice of tau. One of the difficult questions is about the choice of tau. The most; common method is the L-curve method: a two-dimensional curve is plotted; x-axis: log10(chisquare); y-axis: log10(regularisation condition); In many cases this curve has an L-shape. The best choice of tau is in the; kink of the L. Within TUnfold a simple version of the L-curve analysis is included.; It tests a given number of points in a predefined tau-range and searches; for the maximum of the curvature in the L-curve (kink position).; if no tau range is given, the range of teh scan is determied automatically. Example: scan tau and produce the L-curve plot. Code fragment: assume A and y are filled. TUnfold unfold(A,TUnfold::kHistMapOutputHoriz);. unfold.SetInput(y);. Int_t nScan=30;; Int_t iBest;; TSpline *logTauX,*logTauY;; TGraph *lCurve;. iBest=unfold.ScanLcurve(nScan,0.0,0.0,&lCurve);. std::cout<<""tau=""<<unfold.GetTau()<<""\n"";. TH1D *x=unfold.GetOutput(""x"",""myVariable"");; TH2D *rhoij=unfold.GetRhoIJ(""correlation"",""myVariable"");. This creates; logTauX: the L-curve's x-coordinate as a function of log(tau); logTauY: the L-curve's y-coordinate as a function of log(tau); lCurve: a graph of the L-curve; x,rhoij: unfolding result for best choice of tau; iBest: the coordinate/spline knot number with the best choice of tau. Note: always check the L curve after unfolding. The algorithm is not; perfect. Bin averaging of the output. Sometimes it is useful to unfold for a fine binning in x and; calculate the final result with a smaller number of bins. The advantage; is a reduction in the correlation coefficients if bins are averaged.; For this type of averaging the full error matrix has to be used.; There are methods in TUnfold to support this type of calculation; Example:; The vector x has di",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:5996,Testability,log,logTauX,5996,"uare); y-axis: log10(regularisation condition); In many cases this curve has an L-shape. The best choice of tau is in the; kink of the L. Within TUnfold a simple version of the L-curve analysis is included.; It tests a given number of points in a predefined tau-range and searches; for the maximum of the curvature in the L-curve (kink position).; if no tau range is given, the range of teh scan is determied automatically. Example: scan tau and produce the L-curve plot. Code fragment: assume A and y are filled. TUnfold unfold(A,TUnfold::kHistMapOutputHoriz);. unfold.SetInput(y);. Int_t nScan=30;; Int_t iBest;; TSpline *logTauX,*logTauY;; TGraph *lCurve;. iBest=unfold.ScanLcurve(nScan,0.0,0.0,&lCurve);. std::cout<<""tau=""<<unfold.GetTau()<<""\n"";. TH1D *x=unfold.GetOutput(""x"",""myVariable"");; TH2D *rhoij=unfold.GetRhoIJ(""correlation"",""myVariable"");. This creates; logTauX: the L-curve's x-coordinate as a function of log(tau); logTauY: the L-curve's y-coordinate as a function of log(tau); lCurve: a graph of the L-curve; x,rhoij: unfolding result for best choice of tau; iBest: the coordinate/spline knot number with the best choice of tau. Note: always check the L curve after unfolding. The algorithm is not; perfect. Bin averaging of the output. Sometimes it is useful to unfold for a fine binning in x and; calculate the final result with a smaller number of bins. The advantage; is a reduction in the correlation coefficients if bins are averaged.; For this type of averaging the full error matrix has to be used.; There are methods in TUnfold to support this type of calculation; Example:; The vector x has dimension 49, it consists of 7x7 bins; in two variables (Pt,Eta); The unfolding result is to be presented as one-dimensional projections; in (Pt) and (Eta); The bins of x are mapped as: bins 1..7 the first Eta bin; bins 2..14 the second Eta bin. bins 1,8,15,... the first Pt bin. code fragment:. TUnfold unfold(A,TUnfold::kHistMapOutputHoriz);; Double_t tau=1.E-4;; Double_t biasSc",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:6049,Testability,log,log,6049,"uare); y-axis: log10(regularisation condition); In many cases this curve has an L-shape. The best choice of tau is in the; kink of the L. Within TUnfold a simple version of the L-curve analysis is included.; It tests a given number of points in a predefined tau-range and searches; for the maximum of the curvature in the L-curve (kink position).; if no tau range is given, the range of teh scan is determied automatically. Example: scan tau and produce the L-curve plot. Code fragment: assume A and y are filled. TUnfold unfold(A,TUnfold::kHistMapOutputHoriz);. unfold.SetInput(y);. Int_t nScan=30;; Int_t iBest;; TSpline *logTauX,*logTauY;; TGraph *lCurve;. iBest=unfold.ScanLcurve(nScan,0.0,0.0,&lCurve);. std::cout<<""tau=""<<unfold.GetTau()<<""\n"";. TH1D *x=unfold.GetOutput(""x"",""myVariable"");; TH2D *rhoij=unfold.GetRhoIJ(""correlation"",""myVariable"");. This creates; logTauX: the L-curve's x-coordinate as a function of log(tau); logTauY: the L-curve's y-coordinate as a function of log(tau); lCurve: a graph of the L-curve; x,rhoij: unfolding result for best choice of tau; iBest: the coordinate/spline knot number with the best choice of tau. Note: always check the L curve after unfolding. The algorithm is not; perfect. Bin averaging of the output. Sometimes it is useful to unfold for a fine binning in x and; calculate the final result with a smaller number of bins. The advantage; is a reduction in the correlation coefficients if bins are averaged.; For this type of averaging the full error matrix has to be used.; There are methods in TUnfold to support this type of calculation; Example:; The vector x has dimension 49, it consists of 7x7 bins; in two variables (Pt,Eta); The unfolding result is to be presented as one-dimensional projections; in (Pt) and (Eta); The bins of x are mapped as: bins 1..7 the first Eta bin; bins 2..14 the second Eta bin. bins 1,8,15,... the first Pt bin. code fragment:. TUnfold unfold(A,TUnfold::kHistMapOutputHoriz);; Double_t tau=1.E-4;; Double_t biasSc",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:6059,Testability,log,logTauY,6059,"uare); y-axis: log10(regularisation condition); In many cases this curve has an L-shape. The best choice of tau is in the; kink of the L. Within TUnfold a simple version of the L-curve analysis is included.; It tests a given number of points in a predefined tau-range and searches; for the maximum of the curvature in the L-curve (kink position).; if no tau range is given, the range of teh scan is determied automatically. Example: scan tau and produce the L-curve plot. Code fragment: assume A and y are filled. TUnfold unfold(A,TUnfold::kHistMapOutputHoriz);. unfold.SetInput(y);. Int_t nScan=30;; Int_t iBest;; TSpline *logTauX,*logTauY;; TGraph *lCurve;. iBest=unfold.ScanLcurve(nScan,0.0,0.0,&lCurve);. std::cout<<""tau=""<<unfold.GetTau()<<""\n"";. TH1D *x=unfold.GetOutput(""x"",""myVariable"");; TH2D *rhoij=unfold.GetRhoIJ(""correlation"",""myVariable"");. This creates; logTauX: the L-curve's x-coordinate as a function of log(tau); logTauY: the L-curve's y-coordinate as a function of log(tau); lCurve: a graph of the L-curve; x,rhoij: unfolding result for best choice of tau; iBest: the coordinate/spline knot number with the best choice of tau. Note: always check the L curve after unfolding. The algorithm is not; perfect. Bin averaging of the output. Sometimes it is useful to unfold for a fine binning in x and; calculate the final result with a smaller number of bins. The advantage; is a reduction in the correlation coefficients if bins are averaged.; For this type of averaging the full error matrix has to be used.; There are methods in TUnfold to support this type of calculation; Example:; The vector x has dimension 49, it consists of 7x7 bins; in two variables (Pt,Eta); The unfolding result is to be presented as one-dimensional projections; in (Pt) and (Eta); The bins of x are mapped as: bins 1..7 the first Eta bin; bins 2..14 the second Eta bin. bins 1,8,15,... the first Pt bin. code fragment:. TUnfold unfold(A,TUnfold::kHistMapOutputHoriz);; Double_t tau=1.E-4;; Double_t biasSc",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:6112,Testability,log,log,6112,"uare); y-axis: log10(regularisation condition); In many cases this curve has an L-shape. The best choice of tau is in the; kink of the L. Within TUnfold a simple version of the L-curve analysis is included.; It tests a given number of points in a predefined tau-range and searches; for the maximum of the curvature in the L-curve (kink position).; if no tau range is given, the range of teh scan is determied automatically. Example: scan tau and produce the L-curve plot. Code fragment: assume A and y are filled. TUnfold unfold(A,TUnfold::kHistMapOutputHoriz);. unfold.SetInput(y);. Int_t nScan=30;; Int_t iBest;; TSpline *logTauX,*logTauY;; TGraph *lCurve;. iBest=unfold.ScanLcurve(nScan,0.0,0.0,&lCurve);. std::cout<<""tau=""<<unfold.GetTau()<<""\n"";. TH1D *x=unfold.GetOutput(""x"",""myVariable"");; TH2D *rhoij=unfold.GetRhoIJ(""correlation"",""myVariable"");. This creates; logTauX: the L-curve's x-coordinate as a function of log(tau); logTauY: the L-curve's y-coordinate as a function of log(tau); lCurve: a graph of the L-curve; x,rhoij: unfolding result for best choice of tau; iBest: the coordinate/spline knot number with the best choice of tau. Note: always check the L curve after unfolding. The algorithm is not; perfect. Bin averaging of the output. Sometimes it is useful to unfold for a fine binning in x and; calculate the final result with a smaller number of bins. The advantage; is a reduction in the correlation coefficients if bins are averaged.; For this type of averaging the full error matrix has to be used.; There are methods in TUnfold to support this type of calculation; Example:; The vector x has dimension 49, it consists of 7x7 bins; in two variables (Pt,Eta); The unfolding result is to be presented as one-dimensional projections; in (Pt) and (Eta); The bins of x are mapped as: bins 1..7 the first Eta bin; bins 2..14 the second Eta bin. bins 1,8,15,... the first Pt bin. code fragment:. TUnfold unfold(A,TUnfold::kHistMapOutputHoriz);; Double_t tau=1.E-4;; Double_t biasSc",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:16303,Testability,log,logTauX,16303,"l voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); Int_tRegularizeBins(int start, int step, int nbin, TUnfold::ERegMode regmode); Int_tRegularizeBins2D(int start_bin, int step1, int nbin1, int step2, int nbin2, TUnfold::ERegMode regmode); Int_tRegularizeCurvature(int left_bin, int center_bin, int right_bin, Double_t scale_left = 1.0, Double_t scale_right = 1.0); Int_tRegularizeDerivative(int left_bin, int right_bin, Double_t scale = 1.0); Int_tRegularizeSize(int bin, Double_t scale = 1.0); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); voidSetBias(const TH1* bias); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetConstraint(TUnfold::EConstraint constraint); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Int_tSetInput(const TH1* hist_y, Double_t scaleBias = 0.0, Double_t oneOverZeroError = 0.0); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t opt",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:16326,Testability,log,logTauY,16326,"l voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); Int_tRegularizeBins(int start, int step, int nbin, TUnfold::ERegMode regmode); Int_tRegularizeBins2D(int start_bin, int step1, int nbin1, int step2, int nbin2, TUnfold::ERegMode regmode); Int_tRegularizeCurvature(int left_bin, int center_bin, int right_bin, Double_t scale_left = 1.0, Double_t scale_right = 1.0); Int_tRegularizeDerivative(int left_bin, int right_bin, Double_t scale = 1.0); Int_tRegularizeSize(int bin, Double_t scale = 1.0); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); voidSetBias(const TH1* bias); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetConstraint(TUnfold::EConstraint constraint); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Int_tSetInput(const TH1* hist_y, Double_t scaleBias = 0.0, Double_t oneOverZeroError = 0.0); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t opt",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:17008,Testability,Test,TestBit,17008,"t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); voidSetBias(const TH1* bias); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetConstraint(TUnfold::EConstraint constraint); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Int_tSetInput(const TH1* hist_y, Double_t scaleBias = 0.0, Double_t oneOverZeroError = 0.0); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. TUnfold(); voidAddMSparse(TMatrixDSparse* dest, Double_t f, const TMatrixDSparse* src); virtual voidClearResults(); TMatrixDSparse*CreateSparseMatrix(Int_t nrow, Int_t ncol, Int_t nele, Int_t* row, Int_t* col, Double_t* data) const; static voidDeleteMatrix(TMatrixD** m); static voidDeleteMatrix(TMatrixDSparse** m); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tDoUnfold(); voidErrorMatrixToHist(TH2* ematrix, const TMatrixDSparse* emat, const Int_t* binMap, Bool_t doClear) const; const TMatrixDSparse*GetAx() const; const TMatrixDSparse*GetDXDAM(int i) const; const TMatrixDSparse*G",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:17047,Testability,Test,TestBits,17047,"t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); voidSetBias(const TH1* bias); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetConstraint(TUnfold::EConstraint constraint); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Int_tSetInput(const TH1* hist_y, Double_t scaleBias = 0.0, Double_t oneOverZeroError = 0.0); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. TUnfold(); voidAddMSparse(TMatrixDSparse* dest, Double_t f, const TMatrixDSparse* src); virtual voidClearResults(); TMatrixDSparse*CreateSparseMatrix(Int_t nrow, Int_t ncol, Int_t nele, Int_t* row, Int_t* col, Double_t* data) const; static voidDeleteMatrix(TMatrixD** m); static voidDeleteMatrix(TMatrixDSparse** m); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tDoUnfold(); voidErrorMatrixToHist(TH2* ematrix, const TMatrixDSparse* emat, const Int_t* binMap, Bool_t doClear) const; const TMatrixDSparse*GetAx() const; const TMatrixDSparse*GetDXDAM(int i) const; const TMatrixDSparse*G",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:28648,Testability,log,logTauX,28648," bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Data members modified:; fY, fVyy, fVyyinv, fBiasScale, fNdf; Data members cleared; see ClearResults. Double_t DoUnfold(Double_t tau); Unfold with given value of regularisation parameter tau; tau: new tau parameter; required data members:; fA: matrix to relate x and y; fY: measured data points; fX0: bias on x; fBiasScale: scale factor for fX0; fV: inverse of covariance matrix for y; fLsquared: regularisation conditions; modified data members:; fTauSquared and those documented in DoUnfold(void). Int_t ScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); scan the L curve; nPoint: number of points on the resulting curve; tauMin: smallest tau value to study; tauMax: largest tau value to study; lCurve: the L curve as graph; logTauX: output spline of x-coordinates vs tau for the L curve; logTauY: output spline of y-coordinates vs tau for the L curve; return value: the coordinate number (0..nPoint-1) with the ""best"" choice; of tau. TH1D * GetOutput(const char* name, const char* title, Double_t x0 = 0.0, Double_t x1 = 0.0) const; retreive unfolding result as histogram; name: name of the histogram; title: title of the histogram; x0,x1: lower/upper edge of histogram.; if (x0>=x1) then x0=0 and x1=nbin are used. TH1D * GetBias(const char* name, const char* title, Double_t x0 = 0.0, Double_t x1 = 0.0) const; retreive bias as histogram; name: name of the histogram; title: title of the histogram; x0,x1: lower/upper edge of histogram.; if (x0>=x1) then x0=0 and x1=nbin are used. TH1D * GetFoldedOutput(const char* name, const char* title, Double_t y0 = 0.0, Double_t y1 = 0.0) const; retreive unfolding result folded back by the matrix; name: name of th",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:28671,Testability,log,logTauY,28671," bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Data members modified:; fY, fVyy, fVyyinv, fBiasScale, fNdf; Data members cleared; see ClearResults. Double_t DoUnfold(Double_t tau); Unfold with given value of regularisation parameter tau; tau: new tau parameter; required data members:; fA: matrix to relate x and y; fY: measured data points; fX0: bias on x; fBiasScale: scale factor for fX0; fV: inverse of covariance matrix for y; fLsquared: regularisation conditions; modified data members:; fTauSquared and those documented in DoUnfold(void). Int_t ScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); scan the L curve; nPoint: number of points on the resulting curve; tauMin: smallest tau value to study; tauMax: largest tau value to study; lCurve: the L curve as graph; logTauX: output spline of x-coordinates vs tau for the L curve; logTauY: output spline of y-coordinates vs tau for the L curve; return value: the coordinate number (0..nPoint-1) with the ""best"" choice; of tau. TH1D * GetOutput(const char* name, const char* title, Double_t x0 = 0.0, Double_t x1 = 0.0) const; retreive unfolding result as histogram; name: name of the histogram; title: title of the histogram; x0,x1: lower/upper edge of histogram.; if (x0>=x1) then x0=0 and x1=nbin are used. TH1D * GetBias(const char* name, const char* title, Double_t x0 = 0.0, Double_t x1 = 0.0) const; retreive bias as histogram; name: name of the histogram; title: title of the histogram; x0,x1: lower/upper edge of histogram.; if (x0>=x1) then x0=0 and x1=nbin are used. TH1D * GetFoldedOutput(const char* name, const char* title, Double_t y0 = 0.0, Double_t y1 = 0.0) const; retreive unfolding result folded back by the matrix; name: name of th",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:28855,Testability,log,logTauX,28855," bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Data members modified:; fY, fVyy, fVyyinv, fBiasScale, fNdf; Data members cleared; see ClearResults. Double_t DoUnfold(Double_t tau); Unfold with given value of regularisation parameter tau; tau: new tau parameter; required data members:; fA: matrix to relate x and y; fY: measured data points; fX0: bias on x; fBiasScale: scale factor for fX0; fV: inverse of covariance matrix for y; fLsquared: regularisation conditions; modified data members:; fTauSquared and those documented in DoUnfold(void). Int_t ScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); scan the L curve; nPoint: number of points on the resulting curve; tauMin: smallest tau value to study; tauMax: largest tau value to study; lCurve: the L curve as graph; logTauX: output spline of x-coordinates vs tau for the L curve; logTauY: output spline of y-coordinates vs tau for the L curve; return value: the coordinate number (0..nPoint-1) with the ""best"" choice; of tau. TH1D * GetOutput(const char* name, const char* title, Double_t x0 = 0.0, Double_t x1 = 0.0) const; retreive unfolding result as histogram; name: name of the histogram; title: title of the histogram; x0,x1: lower/upper edge of histogram.; if (x0>=x1) then x0=0 and x1=nbin are used. TH1D * GetBias(const char* name, const char* title, Double_t x0 = 0.0, Double_t x1 = 0.0) const; retreive bias as histogram; name: name of the histogram; title: title of the histogram; x0,x1: lower/upper edge of histogram.; if (x0>=x1) then x0=0 and x1=nbin are used. TH1D * GetFoldedOutput(const char* name, const char* title, Double_t y0 = 0.0, Double_t y1 = 0.0) const; retreive unfolding result folded back by the matrix; name: name of th",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:28919,Testability,log,logTauY,28919," bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Data members modified:; fY, fVyy, fVyyinv, fBiasScale, fNdf; Data members cleared; see ClearResults. Double_t DoUnfold(Double_t tau); Unfold with given value of regularisation parameter tau; tau: new tau parameter; required data members:; fA: matrix to relate x and y; fY: measured data points; fX0: bias on x; fBiasScale: scale factor for fX0; fV: inverse of covariance matrix for y; fLsquared: regularisation conditions; modified data members:; fTauSquared and those documented in DoUnfold(void). Int_t ScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); scan the L curve; nPoint: number of points on the resulting curve; tauMin: smallest tau value to study; tauMax: largest tau value to study; lCurve: the L curve as graph; logTauX: output spline of x-coordinates vs tau for the L curve; logTauY: output spline of y-coordinates vs tau for the L curve; return value: the coordinate number (0..nPoint-1) with the ""best"" choice; of tau. TH1D * GetOutput(const char* name, const char* title, Double_t x0 = 0.0, Double_t x1 = 0.0) const; retreive unfolding result as histogram; name: name of the histogram; title: title of the histogram; x0,x1: lower/upper edge of histogram.; if (x0>=x1) then x0=0 and x1=nbin are used. TH1D * GetBias(const char* name, const char* title, Double_t x0 = 0.0, Double_t x1 = 0.0) const; retreive bias as histogram; name: name of the histogram; title: title of the histogram; x0,x1: lower/upper edge of histogram.; if (x0>=x1) then x0=0 and x1=nbin are used. TH1D * GetFoldedOutput(const char* name, const char* title, Double_t y0 = 0.0, Double_t y1 = 0.0) const; retreive unfolding result folded back by the matrix; name: name of th",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:4289,Usability,simpl,simply,4289," V_xx is calculated as:; Vxx_ij = sum_kl dx_i/dy_k Vyy_kl dx_j/dy_l. Warning:. The algorithm is based on ""standard"" matrix inversion, with the; known limitations in numerical accuracy and computing cost for; matrices with large dimensions. Thus the algorithm should not used for large dimensions of x and y; nx should not be much larger than 200; ny should not be much larger than 1000. Example of using TUnfold:. imagine a 2-dimensional histogram is filled, named A; y-axis: generated quantity (e.g. 10 bins); x-axis: reconstructed quantity (e.g. 20 bin); The data are filled in a 1-dimensional histogram, named y; Note1: ALWAYS choose a higher number of bins on the reconstructed side; as compared to the generated size!; Note2: the events which are generated but not reconstructed; have to be added to the appropriate overflow bins of A; Note3: make sure all bins have sufficient statistics and their error is; non-zero. By default, bins with zero error are simply skipped;; however, this may cause problems if You try to unfold something; which depends on these input bins. code fragment (with histograms A and y filled):. TUnfold unfold(A,TUnfold::kHistMapOutputHoriz);; Double_t tau=1.E-4;; Double_t biasScale=0.0;; unfold.DoUnfold(tau,y,biasScale);; TH1D *x=unfold.GetOutput(""x"",""myVariable"");; TH2D *rhoij=unfold.GetRhoIJ(""correlation"",""myVariable"");. will create histograms ""x"" and ""correlation"" from A and y.; if tau is very large, the output is biased to the generated distribution scaled by biasScale; if tau is very small, the output will show oscillations; and large entries in the correlation matrix. Proper choice of tau. One of the difficult questions is about the choice of tau. The most; common method is the L-curve method: a two-dimensional curve is plotted; x-axis: log10(chisquare); y-axis: log10(regularisation condition); In many cases this curve has an L-shape. The best choice of tau is in the; kink of the L. Within TUnfold a simple version of the L-curve analysis is incl",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:5282,Usability,simpl,simple,5282,"ipped;; however, this may cause problems if You try to unfold something; which depends on these input bins. code fragment (with histograms A and y filled):. TUnfold unfold(A,TUnfold::kHistMapOutputHoriz);; Double_t tau=1.E-4;; Double_t biasScale=0.0;; unfold.DoUnfold(tau,y,biasScale);; TH1D *x=unfold.GetOutput(""x"",""myVariable"");; TH2D *rhoij=unfold.GetRhoIJ(""correlation"",""myVariable"");. will create histograms ""x"" and ""correlation"" from A and y.; if tau is very large, the output is biased to the generated distribution scaled by biasScale; if tau is very small, the output will show oscillations; and large entries in the correlation matrix. Proper choice of tau. One of the difficult questions is about the choice of tau. The most; common method is the L-curve method: a two-dimensional curve is plotted; x-axis: log10(chisquare); y-axis: log10(regularisation condition); In many cases this curve has an L-shape. The best choice of tau is in the; kink of the L. Within TUnfold a simple version of the L-curve analysis is included.; It tests a given number of points in a predefined tau-range and searches; for the maximum of the curvature in the L-curve (kink position).; if no tau range is given, the range of teh scan is determied automatically. Example: scan tau and produce the L-curve plot. Code fragment: assume A and y are filled. TUnfold unfold(A,TUnfold::kHistMapOutputHoriz);. unfold.SetInput(y);. Int_t nScan=30;; Int_t iBest;; TSpline *logTauX,*logTauY;; TGraph *lCurve;. iBest=unfold.ScanLcurve(nScan,0.0,0.0,&lCurve);. std::cout<<""tau=""<<unfold.GetTau()<<""\n"";. TH1D *x=unfold.GetOutput(""x"",""myVariable"");; TH2D *rhoij=unfold.GetRhoIJ(""correlation"",""myVariable"");. This creates; logTauX: the L-curve's x-coordinate as a function of log(tau); logTauY: the L-curve's y-coordinate as a function of log(tau); lCurve: a graph of the L-curve; x,rhoij: unfolding result for best choice of tau; iBest: the coordinate/spline knot number with the best choice of tau. Note: always check the L ",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:11175,Usability,Clear,Clear,11175,"s of bins.; In this case, give kRegModeNone in the constructor and specify; the bin grouping with calls to; RegularizeBins() specify a 1-dimensional group of bins; RegularizeBins2D() specify a 2-dimensional group of bins. For ultimate flexibility, the regularisation condition can be set on each; bin individually; -> give kRegModeNone in the constructor and use; RegularizeSize() regularize one bin; RegularizeDerivative() regularize the slope given by two bins; RegularizeCurvature() regularize the curvature given by three bins. Function Members (Methods); public:. TUnfold(const TUnfold&); TUnfold(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintArea); virtual~TUnfold(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDoUnfold(Double_t tau); Double_tDoUnfold(Double_t tau, const TH1* hist_y, Double_t scaleBias = 0.0); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:21050,Usability,Clear,ClearResults,21050,"V(y-Ax); TMatrixDSparse*fDXDAM[2]Result: part of derivative dx_k/dA_ij; TMatrixDSparse*fDXDAZ[2]Result: part of derivative dx_k/dA_ij; TMatrixDSparse*fDXDYResult: derivative dx/dy; TMatrixDSparse*fDXDtauSquaredResult: derivative dx/dtau; TMatrixDSparse*fEResult: matrix E; TMatrixDSparse*fEinvResult: matrix E^(-1); Double_tfLXsquaredResult: chi**2 contribution from (x-s*x0)Lsquared(x-s*x0); Int_tfNdfResult: number of degrees of freedom; Double_tfRhoAvgResult: average global correlation; Double_tfRhoMaxResult: maximum global correlation; TMatrixDSparse*fVxxResult: covariance matrix on x; TMatrixDSparse*fVxxInvResult: inverse of covariance matrix on x; TMatrixD*fXResult: x. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const char * GetTUnfoldVersion(void). void InitTUnfold(void); reset all data members. void DeleteMatrix(TMatrixD** m). void DeleteMatrix(TMatrixDSparse** m). void ClearResults(void); delete old results (if any); this function is virtual, so derived classes may flag their results; ad non-valid as well. TUnfold(const TUnfold& ); set all matrix pointers to zero. Double_t DoUnfold(Double_t tau); main unfolding algorithm. Declared virtual, because other algorithms; could be implemented. Purpose: unfold y -> x; Data members required:; fA: matrix to relate x and y; fY: measured data points; fX0: bias on x; fBiasScale: scale factor for fX0; fVyy: covariance matrix for y; fLsquared: regularisation conditions; fTauSquared: regularisation strength; fConstraint: whether the constraint is applied; Data members modified:; fEinv: inverse of the covariance matrix of x; fE: covariance matrix of x; fX: unfolded data points; fDXDY: derivative of x wrt y (for error propagation); fVxx: error matrix (covariance matrix) on x; fAx: estimate of distribution y from unfolded data; fChi2A: contribution to chi**2 from y-Ax; fChi2L: contribution to chi**2 from L*(x-x0); fDXDtauSquared: derivative of x wrt tau; fDXDAM[0,1]: matrix parts of d",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:28131,Usability,clear,cleared,28131,"Unfold(Double_t tau, const TH1* hist_y, Double_t scaleBias = 0.0); Do unfolding of an input histogram; tau_reg: regularisation parameter; input: input distribution with errors; scaleBias: scale factor applied to the bias; Data members required:; fA, fX0, fLsquared; Data members modified:; those documented in SetInput(); and those documented in DoUnfold(Double_t); Return value:; maximum global correlation coefficient; NOTE!!! return value >=1.0 means error, and the result is junk. Overflow bins of the input distribution are ignored!. Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0.0, Double_t oneOverZeroError = 0.0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Data members modified:; fY, fVyy, fVyyinv, fBiasScale, fNdf; Data members cleared; see ClearResults. Double_t DoUnfold(Double_t tau); Unfold with given value of regularisation parameter tau; tau: new tau parameter; required data members:; fA: matrix to relate x and y; fY: measured data points; fX0: bias on x; fBiasScale: scale factor for fX0; fV: inverse of covariance matrix for y; fLsquared: regularisation conditions; modified data members:; fTauSquared and those documented in DoUnfold(void). Int_t ScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); scan the L curve; nPoint: number of points on the resulting curve; tauMin: smallest tau value to study; tauMax: largest tau value to study; lCurve: the L curve as graph; logTauX: output spline of x-coordinates vs tau for the L curve; logTauY: output spline of y-coordinates vs tau for the L curve; return value: the coordinate ",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfold.html:28144,Usability,Clear,ClearResults,28144,"Unfold(Double_t tau, const TH1* hist_y, Double_t scaleBias = 0.0); Do unfolding of an input histogram; tau_reg: regularisation parameter; input: input distribution with errors; scaleBias: scale factor applied to the bias; Data members required:; fA, fX0, fLsquared; Data members modified:; those documented in SetInput(); and those documented in DoUnfold(Double_t); Return value:; maximum global correlation coefficient; NOTE!!! return value >=1.0 means error, and the result is junk. Overflow bins of the input distribution are ignored!. Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0.0, Double_t oneOverZeroError = 0.0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Data members modified:; fY, fVyy, fVyyinv, fBiasScale, fNdf; Data members cleared; see ClearResults. Double_t DoUnfold(Double_t tau); Unfold with given value of regularisation parameter tau; tau: new tau parameter; required data members:; fA: matrix to relate x and y; fY: measured data points; fX0: bias on x; fBiasScale: scale factor for fX0; fV: inverse of covariance matrix for y; fLsquared: regularisation conditions; modified data members:; fTauSquared and those documented in DoUnfold(void). Int_t ScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); scan the L curve; nPoint: number of points on the resulting curve; tauMin: smallest tau value to study; tauMax: largest tau value to study; lCurve: the L curve as graph; logTauX: output spline of x-coordinates vs tau for the L curve; logTauY: output spline of y-coordinates vs tau for the L curve; return value: the coordinate ",MatchSource.WIKI,root/html532/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfold.html
https://root.cern/root/html532/TUnfoldSys.html:307,Availability,error,error,307,". TUnfoldSys. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfoldSys. class TUnfoldSys: public TUnfold. TUnfoldSys adds error propagation of systematic errors to TUnfold; Also, background sources (with errors) can be subtracted. The following sources of systematic error are considered:; (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDel",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:339,Availability,error,errors,339,". TUnfoldSys. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfoldSys. class TUnfoldSys: public TUnfold. TUnfoldSys adds error propagation of systematic errors to TUnfold; Also, background sources (with errors) can be subtracted. The following sources of systematic error are considered:; (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDel",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:389,Availability,error,errors,389,". TUnfoldSys. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfoldSys. class TUnfoldSys: public TUnfold. TUnfoldSys adds error propagation of systematic errors to TUnfold; Also, background sources (with errors) can be subtracted. The following sources of systematic error are considered:; (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDel",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:452,Availability,error,error,452,". TUnfoldSys. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfoldSys. class TUnfoldSys: public TUnfold. TUnfoldSys adds error propagation of systematic errors to TUnfold; Also, background sources (with errors) can be subtracted. The following sources of systematic error are considered:; (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDel",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:492,Availability,error,errors,492,". TUnfoldSys. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfoldSys. class TUnfoldSys: public TUnfold. TUnfoldSys adds error propagation of systematic errors to TUnfold; Also, background sources (with errors) can be subtracted. The following sources of systematic error are considered:; (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDel",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:540,Availability,error,errors,540,". TUnfoldSys. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfoldSys. class TUnfoldSys: public TUnfold. TUnfoldSys adds error propagation of systematic errors to TUnfold; Also, background sources (with errors) can be subtracted. The following sources of systematic error are considered:; (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDel",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:609,Availability,error,errors,609,". TUnfoldSys. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfoldSys. class TUnfoldSys: public TUnfold. TUnfoldSys adds error propagation of systematic errors to TUnfold; Also, background sources (with errors) can be subtracted. The following sources of systematic error are considered:; (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDel",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:768,Availability,error,error,768,". TUnfoldSys. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfoldSys. class TUnfoldSys: public TUnfold. TUnfoldSys adds error propagation of systematic errors to TUnfold; Also, background sources (with errors) can be subtracted. The following sources of systematic error are considered:; (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDel",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:795,Availability,error,error,795,". TUnfoldSys. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfoldSys. class TUnfoldSys: public TUnfold. TUnfoldSys adds error propagation of systematic errors to TUnfold; Also, background sources (with errors) can be subtracted. The following sources of systematic error are considered:; (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDel",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:842,Availability,error,error,842,". TUnfoldSys. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfoldSys. class TUnfoldSys: public TUnfold. TUnfoldSys adds error propagation of systematic errors to TUnfold; Also, background sources (with errors) can be subtracted. The following sources of systematic error are considered:; (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDel",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:902,Availability,error,errors,902,". TUnfoldSys. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfoldSys. class TUnfoldSys: public TUnfold. TUnfoldSys adds error propagation of systematic errors to TUnfold; Also, background sources (with errors) can be subtracted. The following sources of systematic error are considered:; (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDel",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:945,Availability,error,errors,945,". TUnfoldSys. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfoldSys. class TUnfoldSys: public TUnfold. TUnfoldSys adds error propagation of systematic errors to TUnfold; Also, background sources (with errors) can be subtracted. The following sources of systematic error are considered:; (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDel",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:1004,Availability,error,errors,1004," Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfoldSys. class TUnfoldSys: public TUnfold. TUnfoldSys adds error propagation of systematic errors to TUnfold; Also, background sources (with errors) can be subtracted. The following sources of systematic error are considered:; (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgro",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:1256,Availability,error,errors,1256,": public TUnfold. TUnfoldSys adds error propagation of systematic errors to TUnfold; Also, background sources (with errors) can be subtracted. The following sources of systematic error are considered:; (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general ar NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Me",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:1337,Availability,error,errors,1337,"background sources (with errors) can be subtracted. The following sources of systematic error are considered:; (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general ar NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatri",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:1416,Availability,error,errors,1416,"stematic error are considered:; (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general ar NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d);",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:1457,Availability,error,errors,1457,"stematic error are considered:; (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general ar NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d);",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:1501,Availability,error,errors,1501,"stogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general ar NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (0); GetEmatrix() (0)+(d)+(e); GetEmatrixTotal() (0)+(a)+(b)+(c)+(d)+",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:1557,Availability,error,error,1557,"stogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general ar NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (0); GetEmatrix() (0)+(d)+(e); GetEmatrixTotal() (0)+(a)+(b)+(c)+(d)+",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:1661,Availability,error,errors,1661,"hifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general ar NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (0); GetEmatrix() (0)+(d)+(e); GetEmatrixTotal() (0)+(a)+(b)+(c)+(d)+(e). Example:. TH2D *histA,*histAsys1,*histAsys2,*histBgr1,*histBgr2;; TH1D *data;; assume the above histograms are filled:; histA: migrat",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:1769,Availability,error,error,1769,"or soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general ar NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (0); GetEmatrix() (0)+(d)+(e); GetEmatrixTotal() (0)+(a)+(b)+(c)+(d)+(e). Example:. TH2D *histA,*histAsys1,*histAsys2,*histBgr1,*histBgr2;; TH1D *data;; assume the above histograms are filled:; histA: migration matrix from generator (x-axis) to detector (y-axis); the errors",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:1790,Availability,error,error,1790,"ined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general ar NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (0); GetEmatrix() (0)+(d)+(e); GetEmatrixTotal() (0)+(a)+(b)+(c)+(d)+(e). Example:. TH2D *histA,*histAsys1,*histAsys2,*histBgr1,*histBgr2;; TH1D *data;; assume the above histograms are filled:; histA: migration matrix from generator (x-axis) to detector (y-axis); the errors of histA are the uncorrelated systematic errors",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:2048,Availability,error,error,2048,"background sources. Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general ar NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (0); GetEmatrix() (0)+(d)+(e); GetEmatrixTotal() (0)+(a)+(b)+(c)+(d)+(e). Example:. TH2D *histA,*histAsys1,*histAsys2,*histBgr1,*histBgr2;; TH1D *data;; assume the above histograms are filled:; histA: migration matrix from generator (x-axis) to detector (y-axis); the errors of histA are the uncorrelated systematic errors; histAsys1: alternative migration matrix, when systematic #1 is applied; histAsys1: alternative migration matrix, when systematic #2 is applied; histBgr: known background to the data, with erro",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:2107,Availability,error,errors,2107,"background sources. Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general ar NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (0); GetEmatrix() (0)+(d)+(e); GetEmatrixTotal() (0)+(a)+(b)+(c)+(d)+(e). Example:. TH2D *histA,*histAsys1,*histAsys2,*histBgr1,*histBgr2;; TH1D *data;; assume the above histograms are filled:; histA: migration matrix from generator (x-axis) to detector (y-axis); the errors of histA are the uncorrelated systematic errors; histAsys1: alternative migration matrix, when systematic #1 is applied; histAsys1: alternative migration matrix, when systematic #2 is applied; histBgr: known background to the data, with erro",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:2241,Availability,error,error,2241,"rror(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general ar NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (0); GetEmatrix() (0)+(d)+(e); GetEmatrixTotal() (0)+(a)+(b)+(c)+(d)+(e). Example:. TH2D *histA,*histAsys1,*histAsys2,*histBgr1,*histBgr2;; TH1D *data;; assume the above histograms are filled:; histA: migration matrix from generator (x-axis) to detector (y-axis); the errors of histA are the uncorrelated systematic errors; histAsys1: alternative migration matrix, when systematic #1 is applied; histAsys1: alternative migration matrix, when systematic #2 is applied; histBgr: known background to the data, with errors. set up the unfolding:. TUnfoldSys unfold(histA,TUnfold::kHistMapOutputVert);; unfold.SetInput(input);; // this background has 5% scale uncertainty; unfold.SubtractBackground(histBgr1,""bgr1"",1.0,0.05);; // ",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:2261,Availability,avail,available,2261,"rror(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general ar NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (0); GetEmatrix() (0)+(d)+(e); GetEmatrixTotal() (0)+(a)+(b)+(c)+(d)+(e). Example:. TH2D *histA,*histAsys1,*histAsys2,*histBgr1,*histBgr2;; TH1D *data;; assume the above histograms are filled:; histA: migration matrix from generator (x-axis) to detector (y-axis); the errors of histA are the uncorrelated systematic errors; histAsys1: alternative migration matrix, when systematic #1 is applied; histAsys1: alternative migration matrix, when systematic #2 is applied; histBgr: known background to the data, with errors. set up the unfolding:. TUnfoldSys unfold(histA,TUnfold::kHistMapOutputVert);; unfold.SetInput(input);; // this background has 5% scale uncertainty; unfold.SubtractBackground(histBgr1,""bgr1"",1.0,0.05);; // ",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:2286,Availability,error,error,2286,"btractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general ar NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (0); GetEmatrix() (0)+(d)+(e); GetEmatrixTotal() (0)+(a)+(b)+(c)+(d)+(e). Example:. TH2D *histA,*histAsys1,*histAsys2,*histBgr1,*histBgr2;; TH1D *data;; assume the above histograms are filled:; histA: migration matrix from generator (x-axis) to detector (y-axis); the errors of histA are the uncorrelated systematic errors; histAsys1: alternative migration matrix, when systematic #1 is applied; histAsys1: alternative migration matrix, when systematic #2 is applied; histBgr: known background to the data, with errors. set up the unfolding:. TUnfoldSys unfold(histA,TUnfold::kHistMapOutputVert);; unfold.SetInput(input);; // this background has 5% scale uncertainty; unfold.SubtractBackground(histBgr1,""bgr1"",1.0,0.05);; // this background is scaled by 0.8 and has 10% scale uncertainty; unfold.Subtra",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:2314,Availability,error,error,2314,"btractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general ar NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (0); GetEmatrix() (0)+(d)+(e); GetEmatrixTotal() (0)+(a)+(b)+(c)+(d)+(e). Example:. TH2D *histA,*histAsys1,*histAsys2,*histBgr1,*histBgr2;; TH1D *data;; assume the above histograms are filled:; histA: migration matrix from generator (x-axis) to detector (y-axis); the errors of histA are the uncorrelated systematic errors; histAsys1: alternative migration matrix, when systematic #1 is applied; histAsys1: alternative migration matrix, when systematic #2 is applied; histBgr: known background to the data, with errors. set up the unfolding:. TUnfoldSys unfold(histA,TUnfold::kHistMapOutputVert);; unfold.SetInput(input);; // this background has 5% scale uncertainty; unfold.SubtractBackground(histBgr1,""bgr1"",1.0,0.05);; // this background is scaled by 0.8 and has 10% scale uncertainty; unfold.Subtra",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:2766,Availability,error,errors,2766,"rces (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general ar NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (0); GetEmatrix() (0)+(d)+(e); GetEmatrixTotal() (0)+(a)+(b)+(c)+(d)+(e). Example:. TH2D *histA,*histAsys1,*histAsys2,*histBgr1,*histBgr2;; TH1D *data;; assume the above histograms are filled:; histA: migration matrix from generator (x-axis) to detector (y-axis); the errors of histA are the uncorrelated systematic errors; histAsys1: alternative migration matrix, when systematic #1 is applied; histAsys1: alternative migration matrix, when systematic #2 is applied; histBgr: known background to the data, with errors. set up the unfolding:. TUnfoldSys unfold(histA,TUnfold::kHistMapOutputVert);; unfold.SetInput(input);; // this background has 5% scale uncertainty; unfold.SubtractBackground(histBgr1,""bgr1"",1.0,0.05);; // this background is scaled by 0.8 and has 10% scale uncertainty; unfold.SubtractBackground(histBgr2,""bgr2"",0.8,0.1);; unfold.AddSysError(histAsys1,""syserror1"",TUnfold::kHistMapOutputVert,; TUnfoldSys::kSysErrModeMatrix);; unfold.AddSysError(histAsys2,""syserror2"",TUnfold::kHistMapOutputVert,; TUnfoldSys::kSysErrModeMatrix);. run the unfolding: see description of class TUnfold; unfold.ScanLcurve( ...). retrieve the output; the errors include errors from input, from histBgr1 and from histBgr2; unfold.GetOutput(output);. retreive systematic shifts corresponding to correlated",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:2814,Availability,error,errors,2814,"rces (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general ar NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (0); GetEmatrix() (0)+(d)+(e); GetEmatrixTotal() (0)+(a)+(b)+(c)+(d)+(e). Example:. TH2D *histA,*histAsys1,*histAsys2,*histBgr1,*histBgr2;; TH1D *data;; assume the above histograms are filled:; histA: migration matrix from generator (x-axis) to detector (y-axis); the errors of histA are the uncorrelated systematic errors; histAsys1: alternative migration matrix, when systematic #1 is applied; histAsys1: alternative migration matrix, when systematic #2 is applied; histBgr: known background to the data, with errors. set up the unfolding:. TUnfoldSys unfold(histA,TUnfold::kHistMapOutputVert);; unfold.SetInput(input);; // this background has 5% scale uncertainty; unfold.SubtractBackground(histBgr1,""bgr1"",1.0,0.05);; // this background is scaled by 0.8 and has 10% scale uncertainty; unfold.SubtractBackground(histBgr2,""bgr2"",0.8,0.1);; unfold.AddSysError(histAsys1,""syserror1"",TUnfold::kHistMapOutputVert,; TUnfoldSys::kSysErrModeMatrix);; unfold.AddSysError(histAsys2,""syserror2"",TUnfold::kHistMapOutputVert,; TUnfoldSys::kSysErrModeMatrix);. run the unfolding: see description of class TUnfold; unfold.ScanLcurve( ...). retrieve the output; the errors include errors from input, from histBgr1 and from histBgr2; unfold.GetOutput(output);. retreive systematic shifts corresponding to correlated",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:3010,Availability,error,errors,3010,"rces (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general ar NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (0); GetEmatrix() (0)+(d)+(e); GetEmatrixTotal() (0)+(a)+(b)+(c)+(d)+(e). Example:. TH2D *histA,*histAsys1,*histAsys2,*histBgr1,*histBgr2;; TH1D *data;; assume the above histograms are filled:; histA: migration matrix from generator (x-axis) to detector (y-axis); the errors of histA are the uncorrelated systematic errors; histAsys1: alternative migration matrix, when systematic #1 is applied; histAsys1: alternative migration matrix, when systematic #2 is applied; histBgr: known background to the data, with errors. set up the unfolding:. TUnfoldSys unfold(histA,TUnfold::kHistMapOutputVert);; unfold.SetInput(input);; // this background has 5% scale uncertainty; unfold.SubtractBackground(histBgr1,""bgr1"",1.0,0.05);; // this background is scaled by 0.8 and has 10% scale uncertainty; unfold.SubtractBackground(histBgr2,""bgr2"",0.8,0.1);; unfold.AddSysError(histAsys1,""syserror1"",TUnfold::kHistMapOutputVert,; TUnfoldSys::kSysErrModeMatrix);; unfold.AddSysError(histAsys2,""syserror2"",TUnfold::kHistMapOutputVert,; TUnfoldSys::kSysErrModeMatrix);. run the unfolding: see description of class TUnfold; unfold.ScanLcurve( ...). retrieve the output; the errors include errors from input, from histBgr1 and from histBgr2; unfold.GetOutput(output);. retreive systematic shifts corresponding to correlated",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:3651,Availability,error,errors,3651,"ams are filled:; histA: migration matrix from generator (x-axis) to detector (y-axis); the errors of histA are the uncorrelated systematic errors; histAsys1: alternative migration matrix, when systematic #1 is applied; histAsys1: alternative migration matrix, when systematic #2 is applied; histBgr: known background to the data, with errors. set up the unfolding:. TUnfoldSys unfold(histA,TUnfold::kHistMapOutputVert);; unfold.SetInput(input);; // this background has 5% scale uncertainty; unfold.SubtractBackground(histBgr1,""bgr1"",1.0,0.05);; // this background is scaled by 0.8 and has 10% scale uncertainty; unfold.SubtractBackground(histBgr2,""bgr2"",0.8,0.1);; unfold.AddSysError(histAsys1,""syserror1"",TUnfold::kHistMapOutputVert,; TUnfoldSys::kSysErrModeMatrix);; unfold.AddSysError(histAsys2,""syserror2"",TUnfold::kHistMapOutputVert,; TUnfoldSys::kSysErrModeMatrix);. run the unfolding: see description of class TUnfold; unfold.ScanLcurve( ...). retrieve the output; the errors include errors from input, from histBgr1 and from histBgr2; unfold.GetOutput(output);. retreive systematic shifts corresponding to correlated error sources; In the example, there are 4 correlated sources:; * 5% scale error on bgr1; * 10% scale error on bgr2; * the systematic error ""syserror1""; * the systematic error ""syserror2""; These error s are returned as vectors; (corresponding to one-sigma shifts of each source). unfold.GetDeltaSysBackgroundScale(bgr1shifts,""bgr1"");; unfold.GetDeltaSysBackgroundScale(bgr2shifts,""bgr2"");; unfold.GetDeltaSysSource(sys1shifts,""syserror1"");; unfold.GetDeltaSysSource(sys2shifts,""syserror2"");. retreive errors from uncorrelated sources; In the example, there are four sources of uncorrelated error; * the input vector (statistical errors of the data); * the input matrix histA (Monte Carlo statistical errors); * the errors on bgr1 (Monte Carlo statistical errors); * the errors on bgr2 (Monte Carlo statistical errors); These errors are returned as error matrices. unfold.GetE",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:3666,Availability,error,errors,3666,"ams are filled:; histA: migration matrix from generator (x-axis) to detector (y-axis); the errors of histA are the uncorrelated systematic errors; histAsys1: alternative migration matrix, when systematic #1 is applied; histAsys1: alternative migration matrix, when systematic #2 is applied; histBgr: known background to the data, with errors. set up the unfolding:. TUnfoldSys unfold(histA,TUnfold::kHistMapOutputVert);; unfold.SetInput(input);; // this background has 5% scale uncertainty; unfold.SubtractBackground(histBgr1,""bgr1"",1.0,0.05);; // this background is scaled by 0.8 and has 10% scale uncertainty; unfold.SubtractBackground(histBgr2,""bgr2"",0.8,0.1);; unfold.AddSysError(histAsys1,""syserror1"",TUnfold::kHistMapOutputVert,; TUnfoldSys::kSysErrModeMatrix);; unfold.AddSysError(histAsys2,""syserror2"",TUnfold::kHistMapOutputVert,; TUnfoldSys::kSysErrModeMatrix);. run the unfolding: see description of class TUnfold; unfold.ScanLcurve( ...). retrieve the output; the errors include errors from input, from histBgr1 and from histBgr2; unfold.GetOutput(output);. retreive systematic shifts corresponding to correlated error sources; In the example, there are 4 correlated sources:; * 5% scale error on bgr1; * 10% scale error on bgr2; * the systematic error ""syserror1""; * the systematic error ""syserror2""; These error s are returned as vectors; (corresponding to one-sigma shifts of each source). unfold.GetDeltaSysBackgroundScale(bgr1shifts,""bgr1"");; unfold.GetDeltaSysBackgroundScale(bgr2shifts,""bgr2"");; unfold.GetDeltaSysSource(sys1shifts,""syserror1"");; unfold.GetDeltaSysSource(sys2shifts,""syserror2"");. retreive errors from uncorrelated sources; In the example, there are four sources of uncorrelated error; * the input vector (statistical errors of the data); * the input matrix histA (Monte Carlo statistical errors); * the errors on bgr1 (Monte Carlo statistical errors); * the errors on bgr2 (Monte Carlo statistical errors); These errors are returned as error matrices. unfold.GetE",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:3800,Availability,error,error,3800,"ative migration matrix, when systematic #2 is applied; histBgr: known background to the data, with errors. set up the unfolding:. TUnfoldSys unfold(histA,TUnfold::kHistMapOutputVert);; unfold.SetInput(input);; // this background has 5% scale uncertainty; unfold.SubtractBackground(histBgr1,""bgr1"",1.0,0.05);; // this background is scaled by 0.8 and has 10% scale uncertainty; unfold.SubtractBackground(histBgr2,""bgr2"",0.8,0.1);; unfold.AddSysError(histAsys1,""syserror1"",TUnfold::kHistMapOutputVert,; TUnfoldSys::kSysErrModeMatrix);; unfold.AddSysError(histAsys2,""syserror2"",TUnfold::kHistMapOutputVert,; TUnfoldSys::kSysErrModeMatrix);. run the unfolding: see description of class TUnfold; unfold.ScanLcurve( ...). retrieve the output; the errors include errors from input, from histBgr1 and from histBgr2; unfold.GetOutput(output);. retreive systematic shifts corresponding to correlated error sources; In the example, there are 4 correlated sources:; * 5% scale error on bgr1; * 10% scale error on bgr2; * the systematic error ""syserror1""; * the systematic error ""syserror2""; These error s are returned as vectors; (corresponding to one-sigma shifts of each source). unfold.GetDeltaSysBackgroundScale(bgr1shifts,""bgr1"");; unfold.GetDeltaSysBackgroundScale(bgr2shifts,""bgr2"");; unfold.GetDeltaSysSource(sys1shifts,""syserror1"");; unfold.GetDeltaSysSource(sys2shifts,""syserror2"");. retreive errors from uncorrelated sources; In the example, there are four sources of uncorrelated error; * the input vector (statistical errors of the data); * the input matrix histA (Monte Carlo statistical errors); * the errors on bgr1 (Monte Carlo statistical errors); * the errors on bgr2 (Monte Carlo statistical errors); These errors are returned as error matrices. unfold.GetEmatrixInput(stat_error);; unfold.GetEmatrixSysUncorr(uncorr_sys);; unfold.GetEmatrixSysBackgroundUncorr(bgr1uncorr,""bgr1"");; unfold.GetEmatrixSysBackgroundUncorr(bgr2uncorr,""bgr2"");. Error matrices can be added to existing histograms.; T",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:3875,Availability,error,error,3875,"ative migration matrix, when systematic #2 is applied; histBgr: known background to the data, with errors. set up the unfolding:. TUnfoldSys unfold(histA,TUnfold::kHistMapOutputVert);; unfold.SetInput(input);; // this background has 5% scale uncertainty; unfold.SubtractBackground(histBgr1,""bgr1"",1.0,0.05);; // this background is scaled by 0.8 and has 10% scale uncertainty; unfold.SubtractBackground(histBgr2,""bgr2"",0.8,0.1);; unfold.AddSysError(histAsys1,""syserror1"",TUnfold::kHistMapOutputVert,; TUnfoldSys::kSysErrModeMatrix);; unfold.AddSysError(histAsys2,""syserror2"",TUnfold::kHistMapOutputVert,; TUnfoldSys::kSysErrModeMatrix);. run the unfolding: see description of class TUnfold; unfold.ScanLcurve( ...). retrieve the output; the errors include errors from input, from histBgr1 and from histBgr2; unfold.GetOutput(output);. retreive systematic shifts corresponding to correlated error sources; In the example, there are 4 correlated sources:; * 5% scale error on bgr1; * 10% scale error on bgr2; * the systematic error ""syserror1""; * the systematic error ""syserror2""; These error s are returned as vectors; (corresponding to one-sigma shifts of each source). unfold.GetDeltaSysBackgroundScale(bgr1shifts,""bgr1"");; unfold.GetDeltaSysBackgroundScale(bgr2shifts,""bgr2"");; unfold.GetDeltaSysSource(sys1shifts,""syserror1"");; unfold.GetDeltaSysSource(sys2shifts,""syserror2"");. retreive errors from uncorrelated sources; In the example, there are four sources of uncorrelated error; * the input vector (statistical errors of the data); * the input matrix histA (Monte Carlo statistical errors); * the errors on bgr1 (Monte Carlo statistical errors); * the errors on bgr2 (Monte Carlo statistical errors); These errors are returned as error matrices. unfold.GetEmatrixInput(stat_error);; unfold.GetEmatrixSysUncorr(uncorr_sys);; unfold.GetEmatrixSysBackgroundUncorr(bgr1uncorr,""bgr1"");; unfold.GetEmatrixSysBackgroundUncorr(bgr2uncorr,""bgr2"");. Error matrices can be added to existing histograms.; T",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:3902,Availability,error,error,3902,"ative migration matrix, when systematic #2 is applied; histBgr: known background to the data, with errors. set up the unfolding:. TUnfoldSys unfold(histA,TUnfold::kHistMapOutputVert);; unfold.SetInput(input);; // this background has 5% scale uncertainty; unfold.SubtractBackground(histBgr1,""bgr1"",1.0,0.05);; // this background is scaled by 0.8 and has 10% scale uncertainty; unfold.SubtractBackground(histBgr2,""bgr2"",0.8,0.1);; unfold.AddSysError(histAsys1,""syserror1"",TUnfold::kHistMapOutputVert,; TUnfoldSys::kSysErrModeMatrix);; unfold.AddSysError(histAsys2,""syserror2"",TUnfold::kHistMapOutputVert,; TUnfoldSys::kSysErrModeMatrix);. run the unfolding: see description of class TUnfold; unfold.ScanLcurve( ...). retrieve the output; the errors include errors from input, from histBgr1 and from histBgr2; unfold.GetOutput(output);. retreive systematic shifts corresponding to correlated error sources; In the example, there are 4 correlated sources:; * 5% scale error on bgr1; * 10% scale error on bgr2; * the systematic error ""syserror1""; * the systematic error ""syserror2""; These error s are returned as vectors; (corresponding to one-sigma shifts of each source). unfold.GetDeltaSysBackgroundScale(bgr1shifts,""bgr1"");; unfold.GetDeltaSysBackgroundScale(bgr2shifts,""bgr2"");; unfold.GetDeltaSysSource(sys1shifts,""syserror1"");; unfold.GetDeltaSysSource(sys2shifts,""syserror2"");. retreive errors from uncorrelated sources; In the example, there are four sources of uncorrelated error; * the input vector (statistical errors of the data); * the input matrix histA (Monte Carlo statistical errors); * the errors on bgr1 (Monte Carlo statistical errors); * the errors on bgr2 (Monte Carlo statistical errors); These errors are returned as error matrices. unfold.GetEmatrixInput(stat_error);; unfold.GetEmatrixSysUncorr(uncorr_sys);; unfold.GetEmatrixSysBackgroundUncorr(bgr1uncorr,""bgr1"");; unfold.GetEmatrixSysBackgroundUncorr(bgr2uncorr,""bgr2"");. Error matrices can be added to existing histograms.; T",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:3934,Availability,error,error,3934,"ative migration matrix, when systematic #2 is applied; histBgr: known background to the data, with errors. set up the unfolding:. TUnfoldSys unfold(histA,TUnfold::kHistMapOutputVert);; unfold.SetInput(input);; // this background has 5% scale uncertainty; unfold.SubtractBackground(histBgr1,""bgr1"",1.0,0.05);; // this background is scaled by 0.8 and has 10% scale uncertainty; unfold.SubtractBackground(histBgr2,""bgr2"",0.8,0.1);; unfold.AddSysError(histAsys1,""syserror1"",TUnfold::kHistMapOutputVert,; TUnfoldSys::kSysErrModeMatrix);; unfold.AddSysError(histAsys2,""syserror2"",TUnfold::kHistMapOutputVert,; TUnfoldSys::kSysErrModeMatrix);. run the unfolding: see description of class TUnfold; unfold.ScanLcurve( ...). retrieve the output; the errors include errors from input, from histBgr1 and from histBgr2; unfold.GetOutput(output);. retreive systematic shifts corresponding to correlated error sources; In the example, there are 4 correlated sources:; * 5% scale error on bgr1; * 10% scale error on bgr2; * the systematic error ""syserror1""; * the systematic error ""syserror2""; These error s are returned as vectors; (corresponding to one-sigma shifts of each source). unfold.GetDeltaSysBackgroundScale(bgr1shifts,""bgr1"");; unfold.GetDeltaSysBackgroundScale(bgr2shifts,""bgr2"");; unfold.GetDeltaSysSource(sys1shifts,""syserror1"");; unfold.GetDeltaSysSource(sys2shifts,""syserror2"");. retreive errors from uncorrelated sources; In the example, there are four sources of uncorrelated error; * the input vector (statistical errors of the data); * the input matrix histA (Monte Carlo statistical errors); * the errors on bgr1 (Monte Carlo statistical errors); * the errors on bgr2 (Monte Carlo statistical errors); These errors are returned as error matrices. unfold.GetEmatrixInput(stat_error);; unfold.GetEmatrixSysUncorr(uncorr_sys);; unfold.GetEmatrixSysBackgroundUncorr(bgr1uncorr,""bgr1"");; unfold.GetEmatrixSysBackgroundUncorr(bgr2uncorr,""bgr2"");. Error matrices can be added to existing histograms.; T",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:3970,Availability,error,error,3970,"ative migration matrix, when systematic #2 is applied; histBgr: known background to the data, with errors. set up the unfolding:. TUnfoldSys unfold(histA,TUnfold::kHistMapOutputVert);; unfold.SetInput(input);; // this background has 5% scale uncertainty; unfold.SubtractBackground(histBgr1,""bgr1"",1.0,0.05);; // this background is scaled by 0.8 and has 10% scale uncertainty; unfold.SubtractBackground(histBgr2,""bgr2"",0.8,0.1);; unfold.AddSysError(histAsys1,""syserror1"",TUnfold::kHistMapOutputVert,; TUnfoldSys::kSysErrModeMatrix);; unfold.AddSysError(histAsys2,""syserror2"",TUnfold::kHistMapOutputVert,; TUnfoldSys::kSysErrModeMatrix);. run the unfolding: see description of class TUnfold; unfold.ScanLcurve( ...). retrieve the output; the errors include errors from input, from histBgr1 and from histBgr2; unfold.GetOutput(output);. retreive systematic shifts corresponding to correlated error sources; In the example, there are 4 correlated sources:; * 5% scale error on bgr1; * 10% scale error on bgr2; * the systematic error ""syserror1""; * the systematic error ""syserror2""; These error s are returned as vectors; (corresponding to one-sigma shifts of each source). unfold.GetDeltaSysBackgroundScale(bgr1shifts,""bgr1"");; unfold.GetDeltaSysBackgroundScale(bgr2shifts,""bgr2"");; unfold.GetDeltaSysSource(sys1shifts,""syserror1"");; unfold.GetDeltaSysSource(sys2shifts,""syserror2"");. retreive errors from uncorrelated sources; In the example, there are four sources of uncorrelated error; * the input vector (statistical errors of the data); * the input matrix histA (Monte Carlo statistical errors); * the errors on bgr1 (Monte Carlo statistical errors); * the errors on bgr2 (Monte Carlo statistical errors); These errors are returned as error matrices. unfold.GetEmatrixInput(stat_error);; unfold.GetEmatrixSysUncorr(uncorr_sys);; unfold.GetEmatrixSysBackgroundUncorr(bgr1uncorr,""bgr1"");; unfold.GetEmatrixSysBackgroundUncorr(bgr2uncorr,""bgr2"");. Error matrices can be added to existing histograms.; T",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:3995,Availability,error,error,3995,"ative migration matrix, when systematic #2 is applied; histBgr: known background to the data, with errors. set up the unfolding:. TUnfoldSys unfold(histA,TUnfold::kHistMapOutputVert);; unfold.SetInput(input);; // this background has 5% scale uncertainty; unfold.SubtractBackground(histBgr1,""bgr1"",1.0,0.05);; // this background is scaled by 0.8 and has 10% scale uncertainty; unfold.SubtractBackground(histBgr2,""bgr2"",0.8,0.1);; unfold.AddSysError(histAsys1,""syserror1"",TUnfold::kHistMapOutputVert,; TUnfoldSys::kSysErrModeMatrix);; unfold.AddSysError(histAsys2,""syserror2"",TUnfold::kHistMapOutputVert,; TUnfoldSys::kSysErrModeMatrix);. run the unfolding: see description of class TUnfold; unfold.ScanLcurve( ...). retrieve the output; the errors include errors from input, from histBgr1 and from histBgr2; unfold.GetOutput(output);. retreive systematic shifts corresponding to correlated error sources; In the example, there are 4 correlated sources:; * 5% scale error on bgr1; * 10% scale error on bgr2; * the systematic error ""syserror1""; * the systematic error ""syserror2""; These error s are returned as vectors; (corresponding to one-sigma shifts of each source). unfold.GetDeltaSysBackgroundScale(bgr1shifts,""bgr1"");; unfold.GetDeltaSysBackgroundScale(bgr2shifts,""bgr2"");; unfold.GetDeltaSysSource(sys1shifts,""syserror1"");; unfold.GetDeltaSysSource(sys2shifts,""syserror2"");. retreive errors from uncorrelated sources; In the example, there are four sources of uncorrelated error; * the input vector (statistical errors of the data); * the input matrix histA (Monte Carlo statistical errors); * the errors on bgr1 (Monte Carlo statistical errors); * the errors on bgr2 (Monte Carlo statistical errors); These errors are returned as error matrices. unfold.GetEmatrixInput(stat_error);; unfold.GetEmatrixSysUncorr(uncorr_sys);; unfold.GetEmatrixSysBackgroundUncorr(bgr1uncorr,""bgr1"");; unfold.GetEmatrixSysBackgroundUncorr(bgr2uncorr,""bgr2"");. Error matrices can be added to existing histograms.; T",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:4301,Availability,error,errors,4301,"error2"",TUnfold::kHistMapOutputVert,; TUnfoldSys::kSysErrModeMatrix);. run the unfolding: see description of class TUnfold; unfold.ScanLcurve( ...). retrieve the output; the errors include errors from input, from histBgr1 and from histBgr2; unfold.GetOutput(output);. retreive systematic shifts corresponding to correlated error sources; In the example, there are 4 correlated sources:; * 5% scale error on bgr1; * 10% scale error on bgr2; * the systematic error ""syserror1""; * the systematic error ""syserror2""; These error s are returned as vectors; (corresponding to one-sigma shifts of each source). unfold.GetDeltaSysBackgroundScale(bgr1shifts,""bgr1"");; unfold.GetDeltaSysBackgroundScale(bgr2shifts,""bgr2"");; unfold.GetDeltaSysSource(sys1shifts,""syserror1"");; unfold.GetDeltaSysSource(sys2shifts,""syserror2"");. retreive errors from uncorrelated sources; In the example, there are four sources of uncorrelated error; * the input vector (statistical errors of the data); * the input matrix histA (Monte Carlo statistical errors); * the errors on bgr1 (Monte Carlo statistical errors); * the errors on bgr2 (Monte Carlo statistical errors); These errors are returned as error matrices. unfold.GetEmatrixInput(stat_error);; unfold.GetEmatrixSysUncorr(uncorr_sys);; unfold.GetEmatrixSysBackgroundUncorr(bgr1uncorr,""bgr1"");; unfold.GetEmatrixSysBackgroundUncorr(bgr2uncorr,""bgr2"");. Error matrices can be added to existing histograms.; This is useful to retreive the sum of several error matrices.; If the last argument of the .GetEmatrixXXX methods is set to kFALSE, the; histogram is not cleared, but the error matrix is simply added.; Example: add all errors from background subtraction. unfold.GetEmatrixSysBackgroundUncorr(bgrerror,""bgr1"",0,kTRUE);; unfold.GetEmatrixSysBackgroundCorr(bgrerror,""bgr1"",0,kFALSE);; unfold.GetEmatrixSysBackgroundUncorr(bgrerror,""bgr2"",0,kFALSE);; unfold.GetEmatrixSysBackgroundCorr(bgrerror,""bgr2"",0,kFALSE);. There is a special function to get the total error:; unf",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:4390,Availability,error,error,4390,"error2"",TUnfold::kHistMapOutputVert,; TUnfoldSys::kSysErrModeMatrix);. run the unfolding: see description of class TUnfold; unfold.ScanLcurve( ...). retrieve the output; the errors include errors from input, from histBgr1 and from histBgr2; unfold.GetOutput(output);. retreive systematic shifts corresponding to correlated error sources; In the example, there are 4 correlated sources:; * 5% scale error on bgr1; * 10% scale error on bgr2; * the systematic error ""syserror1""; * the systematic error ""syserror2""; These error s are returned as vectors; (corresponding to one-sigma shifts of each source). unfold.GetDeltaSysBackgroundScale(bgr1shifts,""bgr1"");; unfold.GetDeltaSysBackgroundScale(bgr2shifts,""bgr2"");; unfold.GetDeltaSysSource(sys1shifts,""syserror1"");; unfold.GetDeltaSysSource(sys2shifts,""syserror2"");. retreive errors from uncorrelated sources; In the example, there are four sources of uncorrelated error; * the input vector (statistical errors of the data); * the input matrix histA (Monte Carlo statistical errors); * the errors on bgr1 (Monte Carlo statistical errors); * the errors on bgr2 (Monte Carlo statistical errors); These errors are returned as error matrices. unfold.GetEmatrixInput(stat_error);; unfold.GetEmatrixSysUncorr(uncorr_sys);; unfold.GetEmatrixSysBackgroundUncorr(bgr1uncorr,""bgr1"");; unfold.GetEmatrixSysBackgroundUncorr(bgr2uncorr,""bgr2"");. Error matrices can be added to existing histograms.; This is useful to retreive the sum of several error matrices.; If the last argument of the .GetEmatrixXXX methods is set to kFALSE, the; histogram is not cleared, but the error matrix is simply added.; Example: add all errors from background subtraction. unfold.GetEmatrixSysBackgroundUncorr(bgrerror,""bgr1"",0,kTRUE);; unfold.GetEmatrixSysBackgroundCorr(bgrerror,""bgr1"",0,kFALSE);; unfold.GetEmatrixSysBackgroundUncorr(bgrerror,""bgr2"",0,kFALSE);; unfold.GetEmatrixSysBackgroundCorr(bgrerror,""bgr2"",0,kFALSE);. There is a special function to get the total error:; unf",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:4429,Availability,error,errors,4429,"error2"",TUnfold::kHistMapOutputVert,; TUnfoldSys::kSysErrModeMatrix);. run the unfolding: see description of class TUnfold; unfold.ScanLcurve( ...). retrieve the output; the errors include errors from input, from histBgr1 and from histBgr2; unfold.GetOutput(output);. retreive systematic shifts corresponding to correlated error sources; In the example, there are 4 correlated sources:; * 5% scale error on bgr1; * 10% scale error on bgr2; * the systematic error ""syserror1""; * the systematic error ""syserror2""; These error s are returned as vectors; (corresponding to one-sigma shifts of each source). unfold.GetDeltaSysBackgroundScale(bgr1shifts,""bgr1"");; unfold.GetDeltaSysBackgroundScale(bgr2shifts,""bgr2"");; unfold.GetDeltaSysSource(sys1shifts,""syserror1"");; unfold.GetDeltaSysSource(sys2shifts,""syserror2"");. retreive errors from uncorrelated sources; In the example, there are four sources of uncorrelated error; * the input vector (statistical errors of the data); * the input matrix histA (Monte Carlo statistical errors); * the errors on bgr1 (Monte Carlo statistical errors); * the errors on bgr2 (Monte Carlo statistical errors); These errors are returned as error matrices. unfold.GetEmatrixInput(stat_error);; unfold.GetEmatrixSysUncorr(uncorr_sys);; unfold.GetEmatrixSysBackgroundUncorr(bgr1uncorr,""bgr1"");; unfold.GetEmatrixSysBackgroundUncorr(bgr2uncorr,""bgr2"");. Error matrices can be added to existing histograms.; This is useful to retreive the sum of several error matrices.; If the last argument of the .GetEmatrixXXX methods is set to kFALSE, the; histogram is not cleared, but the error matrix is simply added.; Example: add all errors from background subtraction. unfold.GetEmatrixSysBackgroundUncorr(bgrerror,""bgr1"",0,kTRUE);; unfold.GetEmatrixSysBackgroundCorr(bgrerror,""bgr1"",0,kFALSE);; unfold.GetEmatrixSysBackgroundUncorr(bgrerror,""bgr2"",0,kFALSE);; unfold.GetEmatrixSysBackgroundCorr(bgrerror,""bgr2"",0,kFALSE);. There is a special function to get the total error:; unf",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:4500,Availability,error,errors,4500,"error2"",TUnfold::kHistMapOutputVert,; TUnfoldSys::kSysErrModeMatrix);. run the unfolding: see description of class TUnfold; unfold.ScanLcurve( ...). retrieve the output; the errors include errors from input, from histBgr1 and from histBgr2; unfold.GetOutput(output);. retreive systematic shifts corresponding to correlated error sources; In the example, there are 4 correlated sources:; * 5% scale error on bgr1; * 10% scale error on bgr2; * the systematic error ""syserror1""; * the systematic error ""syserror2""; These error s are returned as vectors; (corresponding to one-sigma shifts of each source). unfold.GetDeltaSysBackgroundScale(bgr1shifts,""bgr1"");; unfold.GetDeltaSysBackgroundScale(bgr2shifts,""bgr2"");; unfold.GetDeltaSysSource(sys1shifts,""syserror1"");; unfold.GetDeltaSysSource(sys2shifts,""syserror2"");. retreive errors from uncorrelated sources; In the example, there are four sources of uncorrelated error; * the input vector (statistical errors of the data); * the input matrix histA (Monte Carlo statistical errors); * the errors on bgr1 (Monte Carlo statistical errors); * the errors on bgr2 (Monte Carlo statistical errors); These errors are returned as error matrices. unfold.GetEmatrixInput(stat_error);; unfold.GetEmatrixSysUncorr(uncorr_sys);; unfold.GetEmatrixSysBackgroundUncorr(bgr1uncorr,""bgr1"");; unfold.GetEmatrixSysBackgroundUncorr(bgr2uncorr,""bgr2"");. Error matrices can be added to existing histograms.; This is useful to retreive the sum of several error matrices.; If the last argument of the .GetEmatrixXXX methods is set to kFALSE, the; histogram is not cleared, but the error matrix is simply added.; Example: add all errors from background subtraction. unfold.GetEmatrixSysBackgroundUncorr(bgrerror,""bgr1"",0,kTRUE);; unfold.GetEmatrixSysBackgroundCorr(bgrerror,""bgr1"",0,kFALSE);; unfold.GetEmatrixSysBackgroundUncorr(bgrerror,""bgr2"",0,kFALSE);; unfold.GetEmatrixSysBackgroundCorr(bgrerror,""bgr2"",0,kFALSE);. There is a special function to get the total error:; unf",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:4515,Availability,error,errors,4515,"error2"",TUnfold::kHistMapOutputVert,; TUnfoldSys::kSysErrModeMatrix);. run the unfolding: see description of class TUnfold; unfold.ScanLcurve( ...). retrieve the output; the errors include errors from input, from histBgr1 and from histBgr2; unfold.GetOutput(output);. retreive systematic shifts corresponding to correlated error sources; In the example, there are 4 correlated sources:; * 5% scale error on bgr1; * 10% scale error on bgr2; * the systematic error ""syserror1""; * the systematic error ""syserror2""; These error s are returned as vectors; (corresponding to one-sigma shifts of each source). unfold.GetDeltaSysBackgroundScale(bgr1shifts,""bgr1"");; unfold.GetDeltaSysBackgroundScale(bgr2shifts,""bgr2"");; unfold.GetDeltaSysSource(sys1shifts,""syserror1"");; unfold.GetDeltaSysSource(sys2shifts,""syserror2"");. retreive errors from uncorrelated sources; In the example, there are four sources of uncorrelated error; * the input vector (statistical errors of the data); * the input matrix histA (Monte Carlo statistical errors); * the errors on bgr1 (Monte Carlo statistical errors); * the errors on bgr2 (Monte Carlo statistical errors); These errors are returned as error matrices. unfold.GetEmatrixInput(stat_error);; unfold.GetEmatrixSysUncorr(uncorr_sys);; unfold.GetEmatrixSysBackgroundUncorr(bgr1uncorr,""bgr1"");; unfold.GetEmatrixSysBackgroundUncorr(bgr2uncorr,""bgr2"");. Error matrices can be added to existing histograms.; This is useful to retreive the sum of several error matrices.; If the last argument of the .GetEmatrixXXX methods is set to kFALSE, the; histogram is not cleared, but the error matrix is simply added.; Example: add all errors from background subtraction. unfold.GetEmatrixSysBackgroundUncorr(bgrerror,""bgr1"",0,kTRUE);; unfold.GetEmatrixSysBackgroundCorr(bgrerror,""bgr1"",0,kFALSE);; unfold.GetEmatrixSysBackgroundUncorr(bgrerror,""bgr2"",0,kFALSE);; unfold.GetEmatrixSysBackgroundCorr(bgrerror,""bgr2"",0,kFALSE);. There is a special function to get the total error:; unf",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:4555,Availability,error,errors,4555,"error2"",TUnfold::kHistMapOutputVert,; TUnfoldSys::kSysErrModeMatrix);. run the unfolding: see description of class TUnfold; unfold.ScanLcurve( ...). retrieve the output; the errors include errors from input, from histBgr1 and from histBgr2; unfold.GetOutput(output);. retreive systematic shifts corresponding to correlated error sources; In the example, there are 4 correlated sources:; * 5% scale error on bgr1; * 10% scale error on bgr2; * the systematic error ""syserror1""; * the systematic error ""syserror2""; These error s are returned as vectors; (corresponding to one-sigma shifts of each source). unfold.GetDeltaSysBackgroundScale(bgr1shifts,""bgr1"");; unfold.GetDeltaSysBackgroundScale(bgr2shifts,""bgr2"");; unfold.GetDeltaSysSource(sys1shifts,""syserror1"");; unfold.GetDeltaSysSource(sys2shifts,""syserror2"");. retreive errors from uncorrelated sources; In the example, there are four sources of uncorrelated error; * the input vector (statistical errors of the data); * the input matrix histA (Monte Carlo statistical errors); * the errors on bgr1 (Monte Carlo statistical errors); * the errors on bgr2 (Monte Carlo statistical errors); These errors are returned as error matrices. unfold.GetEmatrixInput(stat_error);; unfold.GetEmatrixSysUncorr(uncorr_sys);; unfold.GetEmatrixSysBackgroundUncorr(bgr1uncorr,""bgr1"");; unfold.GetEmatrixSysBackgroundUncorr(bgr2uncorr,""bgr2"");. Error matrices can be added to existing histograms.; This is useful to retreive the sum of several error matrices.; If the last argument of the .GetEmatrixXXX methods is set to kFALSE, the; histogram is not cleared, but the error matrix is simply added.; Example: add all errors from background subtraction. unfold.GetEmatrixSysBackgroundUncorr(bgrerror,""bgr1"",0,kTRUE);; unfold.GetEmatrixSysBackgroundCorr(bgrerror,""bgr1"",0,kFALSE);; unfold.GetEmatrixSysBackgroundUncorr(bgrerror,""bgr2"",0,kFALSE);; unfold.GetEmatrixSysBackgroundCorr(bgrerror,""bgr2"",0,kFALSE);. There is a special function to get the total error:; unf",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:4570,Availability,error,errors,4570,"error2"",TUnfold::kHistMapOutputVert,; TUnfoldSys::kSysErrModeMatrix);. run the unfolding: see description of class TUnfold; unfold.ScanLcurve( ...). retrieve the output; the errors include errors from input, from histBgr1 and from histBgr2; unfold.GetOutput(output);. retreive systematic shifts corresponding to correlated error sources; In the example, there are 4 correlated sources:; * 5% scale error on bgr1; * 10% scale error on bgr2; * the systematic error ""syserror1""; * the systematic error ""syserror2""; These error s are returned as vectors; (corresponding to one-sigma shifts of each source). unfold.GetDeltaSysBackgroundScale(bgr1shifts,""bgr1"");; unfold.GetDeltaSysBackgroundScale(bgr2shifts,""bgr2"");; unfold.GetDeltaSysSource(sys1shifts,""syserror1"");; unfold.GetDeltaSysSource(sys2shifts,""syserror2"");. retreive errors from uncorrelated sources; In the example, there are four sources of uncorrelated error; * the input vector (statistical errors of the data); * the input matrix histA (Monte Carlo statistical errors); * the errors on bgr1 (Monte Carlo statistical errors); * the errors on bgr2 (Monte Carlo statistical errors); These errors are returned as error matrices. unfold.GetEmatrixInput(stat_error);; unfold.GetEmatrixSysUncorr(uncorr_sys);; unfold.GetEmatrixSysBackgroundUncorr(bgr1uncorr,""bgr1"");; unfold.GetEmatrixSysBackgroundUncorr(bgr2uncorr,""bgr2"");. Error matrices can be added to existing histograms.; This is useful to retreive the sum of several error matrices.; If the last argument of the .GetEmatrixXXX methods is set to kFALSE, the; histogram is not cleared, but the error matrix is simply added.; Example: add all errors from background subtraction. unfold.GetEmatrixSysBackgroundUncorr(bgrerror,""bgr1"",0,kTRUE);; unfold.GetEmatrixSysBackgroundCorr(bgrerror,""bgr1"",0,kFALSE);; unfold.GetEmatrixSysBackgroundUncorr(bgrerror,""bgr2"",0,kFALSE);; unfold.GetEmatrixSysBackgroundCorr(bgrerror,""bgr2"",0,kFALSE);. There is a special function to get the total error:; unf",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:4610,Availability,error,errors,4610,"error2"",TUnfold::kHistMapOutputVert,; TUnfoldSys::kSysErrModeMatrix);. run the unfolding: see description of class TUnfold; unfold.ScanLcurve( ...). retrieve the output; the errors include errors from input, from histBgr1 and from histBgr2; unfold.GetOutput(output);. retreive systematic shifts corresponding to correlated error sources; In the example, there are 4 correlated sources:; * 5% scale error on bgr1; * 10% scale error on bgr2; * the systematic error ""syserror1""; * the systematic error ""syserror2""; These error s are returned as vectors; (corresponding to one-sigma shifts of each source). unfold.GetDeltaSysBackgroundScale(bgr1shifts,""bgr1"");; unfold.GetDeltaSysBackgroundScale(bgr2shifts,""bgr2"");; unfold.GetDeltaSysSource(sys1shifts,""syserror1"");; unfold.GetDeltaSysSource(sys2shifts,""syserror2"");. retreive errors from uncorrelated sources; In the example, there are four sources of uncorrelated error; * the input vector (statistical errors of the data); * the input matrix histA (Monte Carlo statistical errors); * the errors on bgr1 (Monte Carlo statistical errors); * the errors on bgr2 (Monte Carlo statistical errors); These errors are returned as error matrices. unfold.GetEmatrixInput(stat_error);; unfold.GetEmatrixSysUncorr(uncorr_sys);; unfold.GetEmatrixSysBackgroundUncorr(bgr1uncorr,""bgr1"");; unfold.GetEmatrixSysBackgroundUncorr(bgr2uncorr,""bgr2"");. Error matrices can be added to existing histograms.; This is useful to retreive the sum of several error matrices.; If the last argument of the .GetEmatrixXXX methods is set to kFALSE, the; histogram is not cleared, but the error matrix is simply added.; Example: add all errors from background subtraction. unfold.GetEmatrixSysBackgroundUncorr(bgrerror,""bgr1"",0,kTRUE);; unfold.GetEmatrixSysBackgroundCorr(bgrerror,""bgr1"",0,kFALSE);; unfold.GetEmatrixSysBackgroundUncorr(bgrerror,""bgr2"",0,kFALSE);; unfold.GetEmatrixSysBackgroundCorr(bgrerror,""bgr2"",0,kFALSE);. There is a special function to get the total error:; unf",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:4625,Availability,error,errors,4625,"error2"",TUnfold::kHistMapOutputVert,; TUnfoldSys::kSysErrModeMatrix);. run the unfolding: see description of class TUnfold; unfold.ScanLcurve( ...). retrieve the output; the errors include errors from input, from histBgr1 and from histBgr2; unfold.GetOutput(output);. retreive systematic shifts corresponding to correlated error sources; In the example, there are 4 correlated sources:; * 5% scale error on bgr1; * 10% scale error on bgr2; * the systematic error ""syserror1""; * the systematic error ""syserror2""; These error s are returned as vectors; (corresponding to one-sigma shifts of each source). unfold.GetDeltaSysBackgroundScale(bgr1shifts,""bgr1"");; unfold.GetDeltaSysBackgroundScale(bgr2shifts,""bgr2"");; unfold.GetDeltaSysSource(sys1shifts,""syserror1"");; unfold.GetDeltaSysSource(sys2shifts,""syserror2"");. retreive errors from uncorrelated sources; In the example, there are four sources of uncorrelated error; * the input vector (statistical errors of the data); * the input matrix histA (Monte Carlo statistical errors); * the errors on bgr1 (Monte Carlo statistical errors); * the errors on bgr2 (Monte Carlo statistical errors); These errors are returned as error matrices. unfold.GetEmatrixInput(stat_error);; unfold.GetEmatrixSysUncorr(uncorr_sys);; unfold.GetEmatrixSysBackgroundUncorr(bgr1uncorr,""bgr1"");; unfold.GetEmatrixSysBackgroundUncorr(bgr2uncorr,""bgr2"");. Error matrices can be added to existing histograms.; This is useful to retreive the sum of several error matrices.; If the last argument of the .GetEmatrixXXX methods is set to kFALSE, the; histogram is not cleared, but the error matrix is simply added.; Example: add all errors from background subtraction. unfold.GetEmatrixSysBackgroundUncorr(bgrerror,""bgr1"",0,kTRUE);; unfold.GetEmatrixSysBackgroundCorr(bgrerror,""bgr1"",0,kFALSE);; unfold.GetEmatrixSysBackgroundUncorr(bgrerror,""bgr2"",0,kFALSE);; unfold.GetEmatrixSysBackgroundCorr(bgrerror,""bgr2"",0,kFALSE);. There is a special function to get the total error:; unf",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:4648,Availability,error,error,4648,"error2"",TUnfold::kHistMapOutputVert,; TUnfoldSys::kSysErrModeMatrix);. run the unfolding: see description of class TUnfold; unfold.ScanLcurve( ...). retrieve the output; the errors include errors from input, from histBgr1 and from histBgr2; unfold.GetOutput(output);. retreive systematic shifts corresponding to correlated error sources; In the example, there are 4 correlated sources:; * 5% scale error on bgr1; * 10% scale error on bgr2; * the systematic error ""syserror1""; * the systematic error ""syserror2""; These error s are returned as vectors; (corresponding to one-sigma shifts of each source). unfold.GetDeltaSysBackgroundScale(bgr1shifts,""bgr1"");; unfold.GetDeltaSysBackgroundScale(bgr2shifts,""bgr2"");; unfold.GetDeltaSysSource(sys1shifts,""syserror1"");; unfold.GetDeltaSysSource(sys2shifts,""syserror2"");. retreive errors from uncorrelated sources; In the example, there are four sources of uncorrelated error; * the input vector (statistical errors of the data); * the input matrix histA (Monte Carlo statistical errors); * the errors on bgr1 (Monte Carlo statistical errors); * the errors on bgr2 (Monte Carlo statistical errors); These errors are returned as error matrices. unfold.GetEmatrixInput(stat_error);; unfold.GetEmatrixSysUncorr(uncorr_sys);; unfold.GetEmatrixSysBackgroundUncorr(bgr1uncorr,""bgr1"");; unfold.GetEmatrixSysBackgroundUncorr(bgr2uncorr,""bgr2"");. Error matrices can be added to existing histograms.; This is useful to retreive the sum of several error matrices.; If the last argument of the .GetEmatrixXXX methods is set to kFALSE, the; histogram is not cleared, but the error matrix is simply added.; Example: add all errors from background subtraction. unfold.GetEmatrixSysBackgroundUncorr(bgrerror,""bgr1"",0,kTRUE);; unfold.GetEmatrixSysBackgroundCorr(bgrerror,""bgr1"",0,kFALSE);; unfold.GetEmatrixSysBackgroundUncorr(bgrerror,""bgr2"",0,kFALSE);; unfold.GetEmatrixSysBackgroundCorr(bgrerror,""bgr2"",0,kFALSE);. There is a special function to get the total error:; unf",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:4858,Availability,Error,Error,4858," bgr1; * 10% scale error on bgr2; * the systematic error ""syserror1""; * the systematic error ""syserror2""; These error s are returned as vectors; (corresponding to one-sigma shifts of each source). unfold.GetDeltaSysBackgroundScale(bgr1shifts,""bgr1"");; unfold.GetDeltaSysBackgroundScale(bgr2shifts,""bgr2"");; unfold.GetDeltaSysSource(sys1shifts,""syserror1"");; unfold.GetDeltaSysSource(sys2shifts,""syserror2"");. retreive errors from uncorrelated sources; In the example, there are four sources of uncorrelated error; * the input vector (statistical errors of the data); * the input matrix histA (Monte Carlo statistical errors); * the errors on bgr1 (Monte Carlo statistical errors); * the errors on bgr2 (Monte Carlo statistical errors); These errors are returned as error matrices. unfold.GetEmatrixInput(stat_error);; unfold.GetEmatrixSysUncorr(uncorr_sys);; unfold.GetEmatrixSysBackgroundUncorr(bgr1uncorr,""bgr1"");; unfold.GetEmatrixSysBackgroundUncorr(bgr2uncorr,""bgr2"");. Error matrices can be added to existing histograms.; This is useful to retreive the sum of several error matrices.; If the last argument of the .GetEmatrixXXX methods is set to kFALSE, the; histogram is not cleared, but the error matrix is simply added.; Example: add all errors from background subtraction. unfold.GetEmatrixSysBackgroundUncorr(bgrerror,""bgr1"",0,kTRUE);; unfold.GetEmatrixSysBackgroundCorr(bgrerror,""bgr1"",0,kFALSE);; unfold.GetEmatrixSysBackgroundUncorr(bgrerror,""bgr2"",0,kFALSE);; unfold.GetEmatrixSysBackgroundCorr(bgrerror,""bgr2"",0,kFALSE);. There is a special function to get the total error:; unfold.GetEmatrixTotal(err_total);. Function Members (Methods); public:. TUnfoldSys(const TUnfoldSys&); TUnfoldSys(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintNone); virtual~TUnfoldSys(); voidTObject::AbstractMethod(const char* method) const; voidAddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap his",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:4957,Availability,error,error,4957,"""syserror1""; * the systematic error ""syserror2""; These error s are returned as vectors; (corresponding to one-sigma shifts of each source). unfold.GetDeltaSysBackgroundScale(bgr1shifts,""bgr1"");; unfold.GetDeltaSysBackgroundScale(bgr2shifts,""bgr2"");; unfold.GetDeltaSysSource(sys1shifts,""syserror1"");; unfold.GetDeltaSysSource(sys2shifts,""syserror2"");. retreive errors from uncorrelated sources; In the example, there are four sources of uncorrelated error; * the input vector (statistical errors of the data); * the input matrix histA (Monte Carlo statistical errors); * the errors on bgr1 (Monte Carlo statistical errors); * the errors on bgr2 (Monte Carlo statistical errors); These errors are returned as error matrices. unfold.GetEmatrixInput(stat_error);; unfold.GetEmatrixSysUncorr(uncorr_sys);; unfold.GetEmatrixSysBackgroundUncorr(bgr1uncorr,""bgr1"");; unfold.GetEmatrixSysBackgroundUncorr(bgr2uncorr,""bgr2"");. Error matrices can be added to existing histograms.; This is useful to retreive the sum of several error matrices.; If the last argument of the .GetEmatrixXXX methods is set to kFALSE, the; histogram is not cleared, but the error matrix is simply added.; Example: add all errors from background subtraction. unfold.GetEmatrixSysBackgroundUncorr(bgrerror,""bgr1"",0,kTRUE);; unfold.GetEmatrixSysBackgroundCorr(bgrerror,""bgr1"",0,kFALSE);; unfold.GetEmatrixSysBackgroundUncorr(bgrerror,""bgr2"",0,kFALSE);; unfold.GetEmatrixSysBackgroundCorr(bgrerror,""bgr2"",0,kFALSE);. There is a special function to get the total error:; unfold.GetEmatrixTotal(err_total);. Function Members (Methods); public:. TUnfoldSys(const TUnfoldSys&); TUnfoldSys(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintNone); virtual~TUnfoldSys(); voidTObject::AbstractMethod(const char* method) const; voidAddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode); virtual voidTObject::",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:5082,Availability,error,error,5082,"hifts of each source). unfold.GetDeltaSysBackgroundScale(bgr1shifts,""bgr1"");; unfold.GetDeltaSysBackgroundScale(bgr2shifts,""bgr2"");; unfold.GetDeltaSysSource(sys1shifts,""syserror1"");; unfold.GetDeltaSysSource(sys2shifts,""syserror2"");. retreive errors from uncorrelated sources; In the example, there are four sources of uncorrelated error; * the input vector (statistical errors of the data); * the input matrix histA (Monte Carlo statistical errors); * the errors on bgr1 (Monte Carlo statistical errors); * the errors on bgr2 (Monte Carlo statistical errors); These errors are returned as error matrices. unfold.GetEmatrixInput(stat_error);; unfold.GetEmatrixSysUncorr(uncorr_sys);; unfold.GetEmatrixSysBackgroundUncorr(bgr1uncorr,""bgr1"");; unfold.GetEmatrixSysBackgroundUncorr(bgr2uncorr,""bgr2"");. Error matrices can be added to existing histograms.; This is useful to retreive the sum of several error matrices.; If the last argument of the .GetEmatrixXXX methods is set to kFALSE, the; histogram is not cleared, but the error matrix is simply added.; Example: add all errors from background subtraction. unfold.GetEmatrixSysBackgroundUncorr(bgrerror,""bgr1"",0,kTRUE);; unfold.GetEmatrixSysBackgroundCorr(bgrerror,""bgr1"",0,kFALSE);; unfold.GetEmatrixSysBackgroundUncorr(bgrerror,""bgr2"",0,kFALSE);; unfold.GetEmatrixSysBackgroundCorr(bgrerror,""bgr2"",0,kFALSE);. There is a special function to get the total error:; unfold.GetEmatrixTotal(err_total);. Function Members (Methods); public:. TUnfoldSys(const TUnfoldSys&); TUnfoldSys(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintNone); virtual~TUnfoldSys(); voidTObject::AbstractMethod(const char* method) const; voidAddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const cha",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:5130,Availability,error,errors,5130,"old.GetDeltaSysBackgroundScale(bgr2shifts,""bgr2"");; unfold.GetDeltaSysSource(sys1shifts,""syserror1"");; unfold.GetDeltaSysSource(sys2shifts,""syserror2"");. retreive errors from uncorrelated sources; In the example, there are four sources of uncorrelated error; * the input vector (statistical errors of the data); * the input matrix histA (Monte Carlo statistical errors); * the errors on bgr1 (Monte Carlo statistical errors); * the errors on bgr2 (Monte Carlo statistical errors); These errors are returned as error matrices. unfold.GetEmatrixInput(stat_error);; unfold.GetEmatrixSysUncorr(uncorr_sys);; unfold.GetEmatrixSysBackgroundUncorr(bgr1uncorr,""bgr1"");; unfold.GetEmatrixSysBackgroundUncorr(bgr2uncorr,""bgr2"");. Error matrices can be added to existing histograms.; This is useful to retreive the sum of several error matrices.; If the last argument of the .GetEmatrixXXX methods is set to kFALSE, the; histogram is not cleared, but the error matrix is simply added.; Example: add all errors from background subtraction. unfold.GetEmatrixSysBackgroundUncorr(bgrerror,""bgr1"",0,kTRUE);; unfold.GetEmatrixSysBackgroundCorr(bgrerror,""bgr1"",0,kFALSE);; unfold.GetEmatrixSysBackgroundUncorr(bgrerror,""bgr2"",0,kFALSE);; unfold.GetEmatrixSysBackgroundCorr(bgrerror,""bgr2"",0,kFALSE);. There is a special function to get the total error:; unfold.GetEmatrixTotal(err_total);. Function Members (Methods); public:. TUnfoldSys(const TUnfoldSys&); TUnfoldSys(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintNone); virtual~TUnfoldSys(); voidTObject::AbstractMethod(const char* method) const; voidAddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:5466,Availability,error,error,5466,"* the input matrix histA (Monte Carlo statistical errors); * the errors on bgr1 (Monte Carlo statistical errors); * the errors on bgr2 (Monte Carlo statistical errors); These errors are returned as error matrices. unfold.GetEmatrixInput(stat_error);; unfold.GetEmatrixSysUncorr(uncorr_sys);; unfold.GetEmatrixSysBackgroundUncorr(bgr1uncorr,""bgr1"");; unfold.GetEmatrixSysBackgroundUncorr(bgr2uncorr,""bgr2"");. Error matrices can be added to existing histograms.; This is useful to retreive the sum of several error matrices.; If the last argument of the .GetEmatrixXXX methods is set to kFALSE, the; histogram is not cleared, but the error matrix is simply added.; Example: add all errors from background subtraction. unfold.GetEmatrixSysBackgroundUncorr(bgrerror,""bgr1"",0,kTRUE);; unfold.GetEmatrixSysBackgroundCorr(bgrerror,""bgr1"",0,kFALSE);; unfold.GetEmatrixSysBackgroundUncorr(bgrerror,""bgr2"",0,kFALSE);; unfold.GetEmatrixSysBackgroundCorr(bgrerror,""bgr2"",0,kFALSE);. There is a special function to get the total error:; unfold.GetEmatrixTotal(err_total);. Function Members (Methods); public:. TUnfoldSys(const TUnfoldSys&); TUnfoldSys(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintNone); virtual~TUnfoldSys(); voidTObject::AbstractMethod(const char* method) const; voidAddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tTUnfold::DoUn",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:6783,Availability,Error,Error,6783,"Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tTUnfold::DoUnfold(Double_t tau); Double_tTUnfold::DoUnfold(Double_t tau, const TH1* hist_y, Double_t scaleBias = 0.0); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TH1D*TUnfold::GetBias(const char* name, const char* title, Double_t x0 = 0.0, Double_t x1 = 0.0) const; Double_tTUnfold::GetChi2A() const; Double_tTUnfold::GetChi2L() const; Double_tGetChi2Sys(); voidGetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0); voidGetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); voidGetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTUnfold::GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; TH2D*TUnfold::GetEmatrix(const char* name, const char* title, Double_t x0 = 0.0, Double_t x1 =",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:6912,Availability,error,error,6912,"Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tTUnfold::DoUnfold(Double_t tau); Double_tTUnfold::DoUnfold(Double_t tau, const TH1* hist_y, Double_t scaleBias = 0.0); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TH1D*TUnfold::GetBias(const char* name, const char* title, Double_t x0 = 0.0, Double_t x1 = 0.0) const; Double_tTUnfold::GetChi2A() const; Double_tTUnfold::GetChi2L() const; Double_tGetChi2Sys(); voidGetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0); voidGetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); voidGetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTUnfold::GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; TH2D*TUnfold::GetEmatrix(const char* name, const char* title, Double_t x0 = 0.0, Double_t x1 =",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:6996,Availability,error,error,6996,"Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tTUnfold::DoUnfold(Double_t tau); Double_tTUnfold::DoUnfold(Double_t tau, const TH1* hist_y, Double_t scaleBias = 0.0); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TH1D*TUnfold::GetBias(const char* name, const char* title, Double_t x0 = 0.0, Double_t x1 = 0.0) const; Double_tTUnfold::GetChi2A() const; Double_tTUnfold::GetChi2L() const; Double_tGetChi2Sys(); voidGetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0); voidGetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); voidGetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTUnfold::GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; TH2D*TUnfold::GetEmatrix(const char* name, const char* title, Double_t x0 = 0.0, Double_t x1 =",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:14220,Availability,Error,ErrorMatrixToHist,14220,,MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:16779,Availability,error,error,16779,"nst TMatrixTBase<Double_t>* v) const; voidVectorMapToHist(TH1* hist_delta, const TMatrixDSparse* delta, const Int_t* binMap). private:. voidInitTUnfoldSys(). Data Members; public:. enum ESysErrMode { kSysErrModeMatrix; kSysErrModeShift; kSysErrModeRelative; };; enum TUnfold::EConstraint { kEConstraintNone; kEConstraintArea; };; enum TUnfold::ERegMode { kRegModeNone; kRegModeSize; kRegModeDerivative; kRegModeCurvature; kRegModeMixed; };; enum TUnfold::EHistMap { kHistMapOutputHoriz; kHistMapOutputVert; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TMatrixDSparse*TUnfold::fAInput: matrix; TMatrixD*fAoutsideInput: underflow/overflow bins; TMap*fBgrErrCorrInInput: background sources correlated error; TMap*fBgrErrUncorrInInput: uncorrelated error from bgr sources; TMap*fBgrInInput: size of background sources; Double_tTUnfold::fBiasScaleInput: scale factor for the bias; TUnfold::EConstraintTUnfold::fConstraintInput: type of constraint to use; TMatrixD*fDAinColRelSqInput: normalized column err.sq. (inp.matr.); TMatrixDSparse*fDAinRelSqInput: normalized errors from input matrix; TMap*fDeltaCorrAxResult: syst.shift from fSysIn on fAx; TMap*fDeltaCorrXResult: syst.shift from fSysIn on fX; TMatrixDSparse*fDeltaSysTauResult: systematic shift from tau; Double_tfDtauInput: error on tau; TMatrixDSparse*fEmatUncorrAxResult: syst.error from fDA2 on fAx; TMatrixDSparse*fEmatUncorrXResult: syst.error from fDA2 on fX; TArrayITUnfold::fHistToXInput: histogram bins -> matrix indices; TMatrixDSparse*TUnfold::fLsquaredInput: regularisation conditions squared; TUnfold::ERegModeTUnfold::fRegModeInput: type of regularisation; TArrayDTUnfold::fSumOverYInput: sum of all columns; TMap*fSysInInput: correlated errors; Double_tTUnfold::fTauSquaredInput: regularisation parameter; ",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:16826,Availability,error,error,16826,"nst TMatrixTBase<Double_t>* v) const; voidVectorMapToHist(TH1* hist_delta, const TMatrixDSparse* delta, const Int_t* binMap). private:. voidInitTUnfoldSys(). Data Members; public:. enum ESysErrMode { kSysErrModeMatrix; kSysErrModeShift; kSysErrModeRelative; };; enum TUnfold::EConstraint { kEConstraintNone; kEConstraintArea; };; enum TUnfold::ERegMode { kRegModeNone; kRegModeSize; kRegModeDerivative; kRegModeCurvature; kRegModeMixed; };; enum TUnfold::EHistMap { kHistMapOutputHoriz; kHistMapOutputVert; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TMatrixDSparse*TUnfold::fAInput: matrix; TMatrixD*fAoutsideInput: underflow/overflow bins; TMap*fBgrErrCorrInInput: background sources correlated error; TMap*fBgrErrUncorrInInput: uncorrelated error from bgr sources; TMap*fBgrInInput: size of background sources; Double_tTUnfold::fBiasScaleInput: scale factor for the bias; TUnfold::EConstraintTUnfold::fConstraintInput: type of constraint to use; TMatrixD*fDAinColRelSqInput: normalized column err.sq. (inp.matr.); TMatrixDSparse*fDAinRelSqInput: normalized errors from input matrix; TMap*fDeltaCorrAxResult: syst.shift from fSysIn on fAx; TMap*fDeltaCorrXResult: syst.shift from fSysIn on fX; TMatrixDSparse*fDeltaSysTauResult: systematic shift from tau; Double_tfDtauInput: error on tau; TMatrixDSparse*fEmatUncorrAxResult: syst.error from fDA2 on fAx; TMatrixDSparse*fEmatUncorrXResult: syst.error from fDA2 on fX; TArrayITUnfold::fHistToXInput: histogram bins -> matrix indices; TMatrixDSparse*TUnfold::fLsquaredInput: regularisation conditions squared; TUnfold::ERegModeTUnfold::fRegModeInput: type of regularisation; TArrayDTUnfold::fSumOverYInput: sum of all columns; TMap*fSysInInput: correlated errors; Double_tTUnfold::fTauSquaredInput: regularisation parameter; ",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:17142,Availability,error,errors,17142,kEConstraintNone; kEConstraintArea; };; enum TUnfold::ERegMode { kRegModeNone; kRegModeSize; kRegModeDerivative; kRegModeCurvature; kRegModeMixed; };; enum TUnfold::EHistMap { kHistMapOutputHoriz; kHistMapOutputVert; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TMatrixDSparse*TUnfold::fAInput: matrix; TMatrixD*fAoutsideInput: underflow/overflow bins; TMap*fBgrErrCorrInInput: background sources correlated error; TMap*fBgrErrUncorrInInput: uncorrelated error from bgr sources; TMap*fBgrInInput: size of background sources; Double_tTUnfold::fBiasScaleInput: scale factor for the bias; TUnfold::EConstraintTUnfold::fConstraintInput: type of constraint to use; TMatrixD*fDAinColRelSqInput: normalized column err.sq. (inp.matr.); TMatrixDSparse*fDAinRelSqInput: normalized errors from input matrix; TMap*fDeltaCorrAxResult: syst.shift from fSysIn on fAx; TMap*fDeltaCorrXResult: syst.shift from fSysIn on fX; TMatrixDSparse*fDeltaSysTauResult: systematic shift from tau; Double_tfDtauInput: error on tau; TMatrixDSparse*fEmatUncorrAxResult: syst.error from fDA2 on fAx; TMatrixDSparse*fEmatUncorrXResult: syst.error from fDA2 on fX; TArrayITUnfold::fHistToXInput: histogram bins -> matrix indices; TMatrixDSparse*TUnfold::fLsquaredInput: regularisation conditions squared; TUnfold::ERegModeTUnfold::fRegModeInput: type of regularisation; TArrayDTUnfold::fSumOverYInput: sum of all columns; TMap*fSysInInput: correlated errors; Double_tTUnfold::fTauSquaredInput: regularisation parameter; TMatrixDSparse*TUnfold::fVyyInput: covariance matrix for y; TMatrixDSparse*fVyyDataInput: error on fY prior to bgr subtraction; TMatrixD*TUnfold::fX0Input: x0; TArrayITUnfold::fXToHistInput: matrix indices -> histogram bins; TMatrixD*TUnfold::fYInput: y; TMatrixD*fYDataInput: fY prior to b,MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:17360,Availability,error,error,17360,putHoriz; kHistMapOutputVert; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TMatrixDSparse*TUnfold::fAInput: matrix; TMatrixD*fAoutsideInput: underflow/overflow bins; TMap*fBgrErrCorrInInput: background sources correlated error; TMap*fBgrErrUncorrInInput: uncorrelated error from bgr sources; TMap*fBgrInInput: size of background sources; Double_tTUnfold::fBiasScaleInput: scale factor for the bias; TUnfold::EConstraintTUnfold::fConstraintInput: type of constraint to use; TMatrixD*fDAinColRelSqInput: normalized column err.sq. (inp.matr.); TMatrixDSparse*fDAinRelSqInput: normalized errors from input matrix; TMap*fDeltaCorrAxResult: syst.shift from fSysIn on fAx; TMap*fDeltaCorrXResult: syst.shift from fSysIn on fX; TMatrixDSparse*fDeltaSysTauResult: systematic shift from tau; Double_tfDtauInput: error on tau; TMatrixDSparse*fEmatUncorrAxResult: syst.error from fDA2 on fAx; TMatrixDSparse*fEmatUncorrXResult: syst.error from fDA2 on fX; TArrayITUnfold::fHistToXInput: histogram bins -> matrix indices; TMatrixDSparse*TUnfold::fLsquaredInput: regularisation conditions squared; TUnfold::ERegModeTUnfold::fRegModeInput: type of regularisation; TArrayDTUnfold::fSumOverYInput: sum of all columns; TMap*fSysInInput: correlated errors; Double_tTUnfold::fTauSquaredInput: regularisation parameter; TMatrixDSparse*TUnfold::fVyyInput: covariance matrix for y; TMatrixDSparse*fVyyDataInput: error on fY prior to bgr subtraction; TMatrixD*TUnfold::fX0Input: x0; TArrayITUnfold::fXToHistInput: matrix indices -> histogram bins; TMatrixD*TUnfold::fYInput: y; TMatrixD*fYDataInput: fY prior to bgr subtraction. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnfoldSys(const TUnfoldSys& ); set all pointers to zero. TUnfoldSys(const TH2* ,MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:17415,Availability,error,error,17415,"ed; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TMatrixDSparse*TUnfold::fAInput: matrix; TMatrixD*fAoutsideInput: underflow/overflow bins; TMap*fBgrErrCorrInInput: background sources correlated error; TMap*fBgrErrUncorrInInput: uncorrelated error from bgr sources; TMap*fBgrInInput: size of background sources; Double_tTUnfold::fBiasScaleInput: scale factor for the bias; TUnfold::EConstraintTUnfold::fConstraintInput: type of constraint to use; TMatrixD*fDAinColRelSqInput: normalized column err.sq. (inp.matr.); TMatrixDSparse*fDAinRelSqInput: normalized errors from input matrix; TMap*fDeltaCorrAxResult: syst.shift from fSysIn on fAx; TMap*fDeltaCorrXResult: syst.shift from fSysIn on fX; TMatrixDSparse*fDeltaSysTauResult: systematic shift from tau; Double_tfDtauInput: error on tau; TMatrixDSparse*fEmatUncorrAxResult: syst.error from fDA2 on fAx; TMatrixDSparse*fEmatUncorrXResult: syst.error from fDA2 on fX; TArrayITUnfold::fHistToXInput: histogram bins -> matrix indices; TMatrixDSparse*TUnfold::fLsquaredInput: regularisation conditions squared; TUnfold::ERegModeTUnfold::fRegModeInput: type of regularisation; TArrayDTUnfold::fSumOverYInput: sum of all columns; TMap*fSysInInput: correlated errors; Double_tTUnfold::fTauSquaredInput: regularisation parameter; TMatrixDSparse*TUnfold::fVyyInput: covariance matrix for y; TMatrixDSparse*fVyyDataInput: error on fY prior to bgr subtraction; TMatrixD*TUnfold::fX0Input: x0; TArrayITUnfold::fXToHistInput: matrix indices -> histogram bins; TMatrixD*TUnfold::fYInput: y; TMatrixD*fYDataInput: fY prior to bgr subtraction. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnfoldSys(const TUnfoldSys& ); set all pointers to zero. TUnfoldSys(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kE",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:17479,Availability,error,error,17479,"lated error from bgr sources; TMap*fBgrInInput: size of background sources; Double_tTUnfold::fBiasScaleInput: scale factor for the bias; TUnfold::EConstraintTUnfold::fConstraintInput: type of constraint to use; TMatrixD*fDAinColRelSqInput: normalized column err.sq. (inp.matr.); TMatrixDSparse*fDAinRelSqInput: normalized errors from input matrix; TMap*fDeltaCorrAxResult: syst.shift from fSysIn on fAx; TMap*fDeltaCorrXResult: syst.shift from fSysIn on fX; TMatrixDSparse*fDeltaSysTauResult: systematic shift from tau; Double_tfDtauInput: error on tau; TMatrixDSparse*fEmatUncorrAxResult: syst.error from fDA2 on fAx; TMatrixDSparse*fEmatUncorrXResult: syst.error from fDA2 on fX; TArrayITUnfold::fHistToXInput: histogram bins -> matrix indices; TMatrixDSparse*TUnfold::fLsquaredInput: regularisation conditions squared; TUnfold::ERegModeTUnfold::fRegModeInput: type of regularisation; TArrayDTUnfold::fSumOverYInput: sum of all columns; TMap*fSysInInput: correlated errors; Double_tTUnfold::fTauSquaredInput: regularisation parameter; TMatrixDSparse*TUnfold::fVyyInput: covariance matrix for y; TMatrixDSparse*fVyyDataInput: error on fY prior to bgr subtraction; TMatrixD*TUnfold::fX0Input: x0; TArrayITUnfold::fXToHistInput: matrix indices -> histogram bins; TMatrixD*TUnfold::fYInput: y; TMatrixD*fYDataInput: fY prior to bgr subtraction. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnfoldSys(const TUnfoldSys& ); set all pointers to zero. TUnfoldSys(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintNone); arguments:; hist_A: matrix that describes the migrations; histmap: mapping of the histogram axes to the unfolding output; regmode: global regularisation mode; data members initialized to something different from zero:; fDA2, fDAcol; initialize TUnfold. void AddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMo",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:17788,Availability,error,errors,17788,"lated error from bgr sources; TMap*fBgrInInput: size of background sources; Double_tTUnfold::fBiasScaleInput: scale factor for the bias; TUnfold::EConstraintTUnfold::fConstraintInput: type of constraint to use; TMatrixD*fDAinColRelSqInput: normalized column err.sq. (inp.matr.); TMatrixDSparse*fDAinRelSqInput: normalized errors from input matrix; TMap*fDeltaCorrAxResult: syst.shift from fSysIn on fAx; TMap*fDeltaCorrXResult: syst.shift from fSysIn on fX; TMatrixDSparse*fDeltaSysTauResult: systematic shift from tau; Double_tfDtauInput: error on tau; TMatrixDSparse*fEmatUncorrAxResult: syst.error from fDA2 on fAx; TMatrixDSparse*fEmatUncorrXResult: syst.error from fDA2 on fX; TArrayITUnfold::fHistToXInput: histogram bins -> matrix indices; TMatrixDSparse*TUnfold::fLsquaredInput: regularisation conditions squared; TUnfold::ERegModeTUnfold::fRegModeInput: type of regularisation; TArrayDTUnfold::fSumOverYInput: sum of all columns; TMap*fSysInInput: correlated errors; Double_tTUnfold::fTauSquaredInput: regularisation parameter; TMatrixDSparse*TUnfold::fVyyInput: covariance matrix for y; TMatrixDSparse*fVyyDataInput: error on fY prior to bgr subtraction; TMatrixD*TUnfold::fX0Input: x0; TArrayITUnfold::fXToHistInput: matrix indices -> histogram bins; TMatrixD*TUnfold::fYInput: y; TMatrixD*fYDataInput: fY prior to bgr subtraction. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnfoldSys(const TUnfoldSys& ); set all pointers to zero. TUnfoldSys(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintNone); arguments:; hist_A: matrix that describes the migrations; histmap: mapping of the histogram axes to the unfolding output; regmode: global regularisation mode; data members initialized to something different from zero:; fDA2, fDAcol; initialize TUnfold. void AddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMo",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:17947,Availability,error,error,17947,"lated error from bgr sources; TMap*fBgrInInput: size of background sources; Double_tTUnfold::fBiasScaleInput: scale factor for the bias; TUnfold::EConstraintTUnfold::fConstraintInput: type of constraint to use; TMatrixD*fDAinColRelSqInput: normalized column err.sq. (inp.matr.); TMatrixDSparse*fDAinRelSqInput: normalized errors from input matrix; TMap*fDeltaCorrAxResult: syst.shift from fSysIn on fAx; TMap*fDeltaCorrXResult: syst.shift from fSysIn on fX; TMatrixDSparse*fDeltaSysTauResult: systematic shift from tau; Double_tfDtauInput: error on tau; TMatrixDSparse*fEmatUncorrAxResult: syst.error from fDA2 on fAx; TMatrixDSparse*fEmatUncorrXResult: syst.error from fDA2 on fX; TArrayITUnfold::fHistToXInput: histogram bins -> matrix indices; TMatrixDSparse*TUnfold::fLsquaredInput: regularisation conditions squared; TUnfold::ERegModeTUnfold::fRegModeInput: type of regularisation; TArrayDTUnfold::fSumOverYInput: sum of all columns; TMap*fSysInInput: correlated errors; Double_tTUnfold::fTauSquaredInput: regularisation parameter; TMatrixDSparse*TUnfold::fVyyInput: covariance matrix for y; TMatrixDSparse*fVyyDataInput: error on fY prior to bgr subtraction; TMatrixD*TUnfold::fX0Input: x0; TArrayITUnfold::fXToHistInput: matrix indices -> histogram bins; TMatrixD*TUnfold::fYInput: y; TMatrixD*fYDataInput: fY prior to bgr subtraction. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnfoldSys(const TUnfoldSys& ); set all pointers to zero. TUnfoldSys(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintNone); arguments:; hist_A: matrix that describes the migrations; histmap: mapping of the histogram axes to the unfolding output; regmode: global regularisation mode; data members initialized to something different from zero:; fDA2, fDAcol; initialize TUnfold. void AddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMo",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:18848,Availability,error,error,18848,"put: covariance matrix for y; TMatrixDSparse*fVyyDataInput: error on fY prior to bgr subtraction; TMatrixD*TUnfold::fX0Input: x0; TArrayITUnfold::fXToHistInput: matrix indices -> histogram bins; TMatrixD*TUnfold::fYInput: y; TMatrixD*fYDataInput: fY prior to bgr subtraction. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnfoldSys(const TUnfoldSys& ); set all pointers to zero. TUnfoldSys(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintNone); arguments:; hist_A: matrix that describes the migrations; histmap: mapping of the histogram axes to the unfolding output; regmode: global regularisation mode; data members initialized to something different from zero:; fDA2, fDAcol; initialize TUnfold. void AddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode); add a correlated error source; sysError: alternative matrix or matrix of absolute/relative shifts; name: name of the error source; histmap: mapping of the histogram axes to the unfolding output; mode: format of the error source. void DoBackgroundSubtraction(void); performs background subtraction; fY = fYData - fBgrIn; fVyy = fVyyData + fBgrErrUncorr^2 + fBgrErrCorr * fBgrErrCorr#; fVyyinv = fVyy^(-1). Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0.0, Double_t oneOverZeroError = 0.0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Calls the SetInput metghod of the base class, then renames the input; vectors fY and fVyy, then performs the background subtraction; Data members ",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:18948,Availability,error,error,18948,"put: covariance matrix for y; TMatrixDSparse*fVyyDataInput: error on fY prior to bgr subtraction; TMatrixD*TUnfold::fX0Input: x0; TArrayITUnfold::fXToHistInput: matrix indices -> histogram bins; TMatrixD*TUnfold::fYInput: y; TMatrixD*fYDataInput: fY prior to bgr subtraction. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnfoldSys(const TUnfoldSys& ); set all pointers to zero. TUnfoldSys(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintNone); arguments:; hist_A: matrix that describes the migrations; histmap: mapping of the histogram axes to the unfolding output; regmode: global regularisation mode; data members initialized to something different from zero:; fDA2, fDAcol; initialize TUnfold. void AddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode); add a correlated error source; sysError: alternative matrix or matrix of absolute/relative shifts; name: name of the error source; histmap: mapping of the histogram axes to the unfolding output; mode: format of the error source. void DoBackgroundSubtraction(void); performs background subtraction; fY = fYData - fBgrIn; fVyy = fVyyData + fBgrErrUncorr^2 + fBgrErrCorr * fBgrErrCorr#; fVyyinv = fVyy^(-1). Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0.0, Double_t oneOverZeroError = 0.0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Calls the SetInput metghod of the base class, then renames the input; vectors fY and fVyy, then performs the background subtraction; Data members ",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:19046,Availability,error,error,19046,"put: covariance matrix for y; TMatrixDSparse*fVyyDataInput: error on fY prior to bgr subtraction; TMatrixD*TUnfold::fX0Input: x0; TArrayITUnfold::fXToHistInput: matrix indices -> histogram bins; TMatrixD*TUnfold::fYInput: y; TMatrixD*fYDataInput: fY prior to bgr subtraction. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnfoldSys(const TUnfoldSys& ); set all pointers to zero. TUnfoldSys(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintNone); arguments:; hist_A: matrix that describes the migrations; histmap: mapping of the histogram axes to the unfolding output; regmode: global regularisation mode; data members initialized to something different from zero:; fDA2, fDAcol; initialize TUnfold. void AddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode); add a correlated error source; sysError: alternative matrix or matrix of absolute/relative shifts; name: name of the error source; histmap: mapping of the histogram axes to the unfolding output; mode: format of the error source. void DoBackgroundSubtraction(void); performs background subtraction; fY = fYData - fBgrIn; fVyy = fVyyData + fBgrErrUncorr^2 + fBgrErrCorr * fBgrErrCorr#; fVyyinv = fVyy^(-1). Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0.0, Double_t oneOverZeroError = 0.0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Calls the SetInput metghod of the base class, then renames the input; vectors fY and fVyy, then performs the background subtraction; Data members ",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:19427,Availability,error,errors,19427,"int = kEConstraintNone); arguments:; hist_A: matrix that describes the migrations; histmap: mapping of the histogram axes to the unfolding output; regmode: global regularisation mode; data members initialized to something different from zero:; fDA2, fDAcol; initialize TUnfold. void AddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode); add a correlated error source; sysError: alternative matrix or matrix of absolute/relative shifts; name: name of the error source; histmap: mapping of the histogram axes to the unfolding output; mode: format of the error source. void DoBackgroundSubtraction(void); performs background subtraction; fY = fYData - fBgrIn; fVyy = fVyyData + fBgrErrUncorr^2 + fBgrErrCorr * fBgrErrCorr#; fVyyinv = fVyy^(-1). Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0.0, Double_t oneOverZeroError = 0.0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Calls the SetInput metghod of the base class, then renames the input; vectors fY and fVyy, then performs the background subtraction; Data members modified:; fYData,fY,fVyyData,fVyy,fVyyinvData,fVyyinv; and those modified by TUnfold::SetInput(); and those modified by DoBackgroundSubtraction(); LM: WARNING: Coverity detects here a false USE_AFTER_FREE for fY and fVyy; the objects are deleted but then re-created immediatly afterwards in; TUnfold::SetInput. void SubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1.0, Double_t scale_error = 0.0); Store background source; bgr: background distribution with uncorrelated errors; name: name of this background source; scale: ",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:19517,Availability,error,error,19517,"int = kEConstraintNone); arguments:; hist_A: matrix that describes the migrations; histmap: mapping of the histogram axes to the unfolding output; regmode: global regularisation mode; data members initialized to something different from zero:; fDA2, fDAcol; initialize TUnfold. void AddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode); add a correlated error source; sysError: alternative matrix or matrix of absolute/relative shifts; name: name of the error source; histmap: mapping of the histogram axes to the unfolding output; mode: format of the error source. void DoBackgroundSubtraction(void); performs background subtraction; fY = fYData - fBgrIn; fVyy = fVyyData + fBgrErrUncorr^2 + fBgrErrCorr * fBgrErrCorr#; fVyyinv = fVyy^(-1). Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0.0, Double_t oneOverZeroError = 0.0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Calls the SetInput metghod of the base class, then renames the input; vectors fY and fVyy, then performs the background subtraction; Data members modified:; fYData,fY,fVyyData,fVyy,fVyyinvData,fVyyinv; and those modified by TUnfold::SetInput(); and those modified by DoBackgroundSubtraction(); LM: WARNING: Coverity detects here a false USE_AFTER_FREE for fY and fVyy; the objects are deleted but then re-created immediatly afterwards in; TUnfold::SetInput. void SubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1.0, Double_t scale_error = 0.0); Store background source; bgr: background distribution with uncorrelated errors; name: name of this background source; scale: ",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:19546,Availability,error,error,19546,"int = kEConstraintNone); arguments:; hist_A: matrix that describes the migrations; histmap: mapping of the histogram axes to the unfolding output; regmode: global regularisation mode; data members initialized to something different from zero:; fDA2, fDAcol; initialize TUnfold. void AddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode); add a correlated error source; sysError: alternative matrix or matrix of absolute/relative shifts; name: name of the error source; histmap: mapping of the histogram axes to the unfolding output; mode: format of the error source. void DoBackgroundSubtraction(void); performs background subtraction; fY = fYData - fBgrIn; fVyy = fVyyData + fBgrErrUncorr^2 + fBgrErrCorr * fBgrErrCorr#; fVyyinv = fVyy^(-1). Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0.0, Double_t oneOverZeroError = 0.0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Calls the SetInput metghod of the base class, then renames the input; vectors fY and fVyy, then performs the background subtraction; Data members modified:; fYData,fY,fVyyData,fVyy,fVyyinvData,fVyyinv; and those modified by TUnfold::SetInput(); and those modified by DoBackgroundSubtraction(); LM: WARNING: Coverity detects here a false USE_AFTER_FREE for fY and fVyy; the objects are deleted but then re-created immediatly afterwards in; TUnfold::SetInput. void SubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1.0, Double_t scale_error = 0.0); Store background source; bgr: background distribution with uncorrelated errors; name: name of this background source; scale: ",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:19592,Availability,error,error,19592,"ernative matrix or matrix of absolute/relative shifts; name: name of the error source; histmap: mapping of the histogram axes to the unfolding output; mode: format of the error source. void DoBackgroundSubtraction(void); performs background subtraction; fY = fYData - fBgrIn; fVyy = fVyyData + fBgrErrUncorr^2 + fBgrErrCorr * fBgrErrCorr#; fVyyinv = fVyy^(-1). Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0.0, Double_t oneOverZeroError = 0.0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Calls the SetInput metghod of the base class, then renames the input; vectors fY and fVyy, then performs the background subtraction; Data members modified:; fYData,fY,fVyyData,fVyy,fVyyinvData,fVyyinv; and those modified by TUnfold::SetInput(); and those modified by DoBackgroundSubtraction(); LM: WARNING: Coverity detects here a false USE_AFTER_FREE for fY and fVyy; the objects are deleted but then re-created immediatly afterwards in; TUnfold::SetInput. void SubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1.0, Double_t scale_error = 0.0); Store background source; bgr: background distribution with uncorrelated errors; name: name of this background source; scale: scale factor applied to the background; scaleError: error on scale factor (correlated error). Data members modified:; fBgrIn,fBgrErrUncorrIn,fBgrErrCorrIn; and those modified by DoBackgroundSubtraction(); save background source. void InitTUnfoldSys(void); initialize pointers and TMaps. ~TUnfoldSys(void); delete all data members. void ClearResults(void); clear all data members which depend on the unfolding results. void PrepareSysErro",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:19680,Availability,error,errors,19680,"ernative matrix or matrix of absolute/relative shifts; name: name of the error source; histmap: mapping of the histogram axes to the unfolding output; mode: format of the error source. void DoBackgroundSubtraction(void); performs background subtraction; fY = fYData - fBgrIn; fVyy = fVyyData + fBgrErrUncorr^2 + fBgrErrCorr * fBgrErrCorr#; fVyyinv = fVyy^(-1). Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0.0, Double_t oneOverZeroError = 0.0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Calls the SetInput metghod of the base class, then renames the input; vectors fY and fVyy, then performs the background subtraction; Data members modified:; fYData,fY,fVyyData,fVyy,fVyyinvData,fVyyinv; and those modified by TUnfold::SetInput(); and those modified by DoBackgroundSubtraction(); LM: WARNING: Coverity detects here a false USE_AFTER_FREE for fY and fVyy; the objects are deleted but then re-created immediatly afterwards in; TUnfold::SetInput. void SubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1.0, Double_t scale_error = 0.0); Store background source; bgr: background distribution with uncorrelated errors; name: name of this background source; scale: scale factor applied to the background; scaleError: error on scale factor (correlated error). Data members modified:; fBgrIn,fBgrErrUncorrIn,fBgrErrCorrIn; and those modified by DoBackgroundSubtraction(); save background source. void InitTUnfoldSys(void); initialize pointers and TMaps. ~TUnfoldSys(void); delete all data members. void ClearResults(void); clear all data members which depend on the unfolding results. void PrepareSysErro",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:20386,Availability,error,errors,20386," with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Calls the SetInput metghod of the base class, then renames the input; vectors fY and fVyy, then performs the background subtraction; Data members modified:; fYData,fY,fVyyData,fVyy,fVyyinvData,fVyyinv; and those modified by TUnfold::SetInput(); and those modified by DoBackgroundSubtraction(); LM: WARNING: Coverity detects here a false USE_AFTER_FREE for fY and fVyy; the objects are deleted but then re-created immediatly afterwards in; TUnfold::SetInput. void SubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1.0, Double_t scale_error = 0.0); Store background source; bgr: background distribution with uncorrelated errors; name: name of this background source; scale: scale factor applied to the background; scaleError: error on scale factor (correlated error). Data members modified:; fBgrIn,fBgrErrUncorrIn,fBgrErrCorrIn; and those modified by DoBackgroundSubtraction(); save background source. void InitTUnfoldSys(void); initialize pointers and TMaps. ~TUnfoldSys(void); delete all data members. void ClearResults(void); clear all data members which depend on the unfolding results. void PrepareSysError(void); calculations required for syst.error; data members modified; fEmatUncorrX, fEmatUncorrAx, fDeltaCorrX, fDeltaCorrAx. void GetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); get output error contribution from statistical fluctuations in A; ematrix: output error matrix histogram; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors; data members modified:; fVYAx, fESparse, fEAtV, fErrorAStat. TMatrixDSparse * PrepareUncorrEmat(const TMatrixDSparse*",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:20491,Availability,error,error,20491," with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Calls the SetInput metghod of the base class, then renames the input; vectors fY and fVyy, then performs the background subtraction; Data members modified:; fYData,fY,fVyyData,fVyy,fVyyinvData,fVyyinv; and those modified by TUnfold::SetInput(); and those modified by DoBackgroundSubtraction(); LM: WARNING: Coverity detects here a false USE_AFTER_FREE for fY and fVyy; the objects are deleted but then re-created immediatly afterwards in; TUnfold::SetInput. void SubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1.0, Double_t scale_error = 0.0); Store background source; bgr: background distribution with uncorrelated errors; name: name of this background source; scale: scale factor applied to the background; scaleError: error on scale factor (correlated error). Data members modified:; fBgrIn,fBgrErrUncorrIn,fBgrErrCorrIn; and those modified by DoBackgroundSubtraction(); save background source. void InitTUnfoldSys(void); initialize pointers and TMaps. ~TUnfoldSys(void); delete all data members. void ClearResults(void); clear all data members which depend on the unfolding results. void PrepareSysError(void); calculations required for syst.error; data members modified; fEmatUncorrX, fEmatUncorrAx, fDeltaCorrX, fDeltaCorrAx. void GetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); get output error contribution from statistical fluctuations in A; ematrix: output error matrix histogram; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors; data members modified:; fVYAx, fESparse, fEAtV, fErrorAStat. TMatrixDSparse * PrepareUncorrEmat(const TMatrixDSparse*",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:20525,Availability,error,error,20525," with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Calls the SetInput metghod of the base class, then renames the input; vectors fY and fVyy, then performs the background subtraction; Data members modified:; fYData,fY,fVyyData,fVyy,fVyyinvData,fVyyinv; and those modified by TUnfold::SetInput(); and those modified by DoBackgroundSubtraction(); LM: WARNING: Coverity detects here a false USE_AFTER_FREE for fY and fVyy; the objects are deleted but then re-created immediatly afterwards in; TUnfold::SetInput. void SubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1.0, Double_t scale_error = 0.0); Store background source; bgr: background distribution with uncorrelated errors; name: name of this background source; scale: scale factor applied to the background; scaleError: error on scale factor (correlated error). Data members modified:; fBgrIn,fBgrErrUncorrIn,fBgrErrCorrIn; and those modified by DoBackgroundSubtraction(); save background source. void InitTUnfoldSys(void); initialize pointers and TMaps. ~TUnfoldSys(void); delete all data members. void ClearResults(void); clear all data members which depend on the unfolding results. void PrepareSysError(void); calculations required for syst.error; data members modified; fEmatUncorrX, fEmatUncorrAx, fDeltaCorrX, fDeltaCorrAx. void GetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); get output error contribution from statistical fluctuations in A; ematrix: output error matrix histogram; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors; data members modified:; fVYAx, fESparse, fEAtV, fErrorAStat. TMatrixDSparse * PrepareUncorrEmat(const TMatrixDSparse*",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:20916,Availability,error,error,20916,"fied by TUnfold::SetInput(); and those modified by DoBackgroundSubtraction(); LM: WARNING: Coverity detects here a false USE_AFTER_FREE for fY and fVyy; the objects are deleted but then re-created immediatly afterwards in; TUnfold::SetInput. void SubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1.0, Double_t scale_error = 0.0); Store background source; bgr: background distribution with uncorrelated errors; name: name of this background source; scale: scale factor applied to the background; scaleError: error on scale factor (correlated error). Data members modified:; fBgrIn,fBgrErrUncorrIn,fBgrErrCorrIn; and those modified by DoBackgroundSubtraction(); save background source. void InitTUnfoldSys(void); initialize pointers and TMaps. ~TUnfoldSys(void); delete all data members. void ClearResults(void); clear all data members which depend on the unfolding results. void PrepareSysError(void); calculations required for syst.error; data members modified; fEmatUncorrX, fEmatUncorrAx, fDeltaCorrX, fDeltaCorrAx. void GetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); get output error contribution from statistical fluctuations in A; ematrix: output error matrix histogram; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors; data members modified:; fVYAx, fESparse, fEAtV, fErrorAStat. TMatrixDSparse * PrepareUncorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2); propagate uncorrelated systematic errors to a covariance matrix; m0,m1 : coefficients (matrices) for propagating the errors. the error matrix is calculated by standard error propagation, where the; derivative of the result vector X wrt the matrix A is given by. dX_k / dA_ij = M0_kj * Z0_i - M1_ki * Z1_j. where:; the matrices M0 and M1 are arguments to this function; the vectors Z0, Z1 : GetDXDAZ(). The matrix A is calculated from a matrix B as. A_ij = B_ij / sum_k B_kj. where k runs over additional in",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:21104,Availability,error,error,21104,"Unfold::SetInput. void SubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1.0, Double_t scale_error = 0.0); Store background source; bgr: background distribution with uncorrelated errors; name: name of this background source; scale: scale factor applied to the background; scaleError: error on scale factor (correlated error). Data members modified:; fBgrIn,fBgrErrUncorrIn,fBgrErrCorrIn; and those modified by DoBackgroundSubtraction(); save background source. void InitTUnfoldSys(void); initialize pointers and TMaps. ~TUnfoldSys(void); delete all data members. void ClearResults(void); clear all data members which depend on the unfolding results. void PrepareSysError(void); calculations required for syst.error; data members modified; fEmatUncorrX, fEmatUncorrAx, fDeltaCorrX, fDeltaCorrAx. void GetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); get output error contribution from statistical fluctuations in A; ematrix: output error matrix histogram; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors; data members modified:; fVYAx, fESparse, fEAtV, fErrorAStat. TMatrixDSparse * PrepareUncorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2); propagate uncorrelated systematic errors to a covariance matrix; m0,m1 : coefficients (matrices) for propagating the errors. the error matrix is calculated by standard error propagation, where the; derivative of the result vector X wrt the matrix A is given by. dX_k / dA_ij = M0_kj * Z0_i - M1_ki * Z1_j. where:; the matrices M0 and M1 are arguments to this function; the vectors Z0, Z1 : GetDXDAZ(). The matrix A is calculated from a matrix B as. A_ij = B_ij / sum_k B_kj. where k runs over additional indices of B, not present in A.; (underflow and overflow bins, used for efficiency corrections). define: Norm_j = sum_k B_kj (data member fSumOverY). the derivative of A wrt this input matrix B is given by:. dA_ij / dB_kj = ( ",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:21175,Availability,error,error,21175,"Unfold::SetInput. void SubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1.0, Double_t scale_error = 0.0); Store background source; bgr: background distribution with uncorrelated errors; name: name of this background source; scale: scale factor applied to the background; scaleError: error on scale factor (correlated error). Data members modified:; fBgrIn,fBgrErrUncorrIn,fBgrErrCorrIn; and those modified by DoBackgroundSubtraction(); save background source. void InitTUnfoldSys(void); initialize pointers and TMaps. ~TUnfoldSys(void); delete all data members. void ClearResults(void); clear all data members which depend on the unfolding results. void PrepareSysError(void); calculations required for syst.error; data members modified; fEmatUncorrX, fEmatUncorrAx, fDeltaCorrX, fDeltaCorrAx. void GetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); get output error contribution from statistical fluctuations in A; ematrix: output error matrix histogram; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors; data members modified:; fVYAx, fESparse, fEAtV, fErrorAStat. TMatrixDSparse * PrepareUncorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2); propagate uncorrelated systematic errors to a covariance matrix; m0,m1 : coefficients (matrices) for propagating the errors. the error matrix is calculated by standard error propagation, where the; derivative of the result vector X wrt the matrix A is given by. dX_k / dA_ij = M0_kj * Z0_i - M1_ki * Z1_j. where:; the matrices M0 and M1 are arguments to this function; the vectors Z0, Z1 : GetDXDAZ(). The matrix A is calculated from a matrix B as. A_ij = B_ij / sum_k B_kj. where k runs over additional indices of B, not present in A.; (underflow and overflow bins, used for efficiency corrections). define: Norm_j = sum_k B_kj (data member fSumOverY). the derivative of A wrt this input matrix B is given by:. dA_ij / dB_kj = ( ",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:21296,Availability,error,errors,21296,"Unfold::SetInput. void SubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1.0, Double_t scale_error = 0.0); Store background source; bgr: background distribution with uncorrelated errors; name: name of this background source; scale: scale factor applied to the background; scaleError: error on scale factor (correlated error). Data members modified:; fBgrIn,fBgrErrUncorrIn,fBgrErrCorrIn; and those modified by DoBackgroundSubtraction(); save background source. void InitTUnfoldSys(void); initialize pointers and TMaps. ~TUnfoldSys(void); delete all data members. void ClearResults(void); clear all data members which depend on the unfolding results. void PrepareSysError(void); calculations required for syst.error; data members modified; fEmatUncorrX, fEmatUncorrAx, fDeltaCorrX, fDeltaCorrAx. void GetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); get output error contribution from statistical fluctuations in A; ematrix: output error matrix histogram; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors; data members modified:; fVYAx, fESparse, fEAtV, fErrorAStat. TMatrixDSparse * PrepareUncorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2); propagate uncorrelated systematic errors to a covariance matrix; m0,m1 : coefficients (matrices) for propagating the errors. the error matrix is calculated by standard error propagation, where the; derivative of the result vector X wrt the matrix A is given by. dX_k / dA_ij = M0_kj * Z0_i - M1_ki * Z1_j. where:; the matrices M0 and M1 are arguments to this function; the vectors Z0, Z1 : GetDXDAZ(). The matrix A is calculated from a matrix B as. A_ij = B_ij / sum_k B_kj. where k runs over additional indices of B, not present in A.; (underflow and overflow bins, used for efficiency corrections). define: Norm_j = sum_k B_kj (data member fSumOverY). the derivative of A wrt this input matrix B is given by:. dA_ij / dB_kj = ( ",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:21487,Availability,error,errors,21487,"kground; scaleError: error on scale factor (correlated error). Data members modified:; fBgrIn,fBgrErrUncorrIn,fBgrErrCorrIn; and those modified by DoBackgroundSubtraction(); save background source. void InitTUnfoldSys(void); initialize pointers and TMaps. ~TUnfoldSys(void); delete all data members. void ClearResults(void); clear all data members which depend on the unfolding results. void PrepareSysError(void); calculations required for syst.error; data members modified; fEmatUncorrX, fEmatUncorrAx, fDeltaCorrX, fDeltaCorrAx. void GetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); get output error contribution from statistical fluctuations in A; ematrix: output error matrix histogram; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors; data members modified:; fVYAx, fESparse, fEAtV, fErrorAStat. TMatrixDSparse * PrepareUncorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2); propagate uncorrelated systematic errors to a covariance matrix; m0,m1 : coefficients (matrices) for propagating the errors. the error matrix is calculated by standard error propagation, where the; derivative of the result vector X wrt the matrix A is given by. dX_k / dA_ij = M0_kj * Z0_i - M1_ki * Z1_j. where:; the matrices M0 and M1 are arguments to this function; the vectors Z0, Z1 : GetDXDAZ(). The matrix A is calculated from a matrix B as. A_ij = B_ij / sum_k B_kj. where k runs over additional indices of B, not present in A.; (underflow and overflow bins, used for efficiency corrections). define: Norm_j = sum_k B_kj (data member fSumOverY). the derivative of A wrt this input matrix B is given by:. dA_ij / dB_kj = ( delta_ik - A_ij ) * 1/Norm_j. The covariance matrix Vxx is:. Vxx_mn = sum_ijlk [ (dX_m / dA_ij) * (dA_ij / dB_kj) * DB_kj; * (dX_n / dA_lj) * (dA_lj / dB_kj) ]. where DB_kj is the error on B_kj squared; Simplify the sum over k:. sum_k [ (dA_ij / dB_kj) * DB_kj * (dA_lj / dB_kj) ]; = sum_",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:21570,Availability,error,errors,21570,"kground; scaleError: error on scale factor (correlated error). Data members modified:; fBgrIn,fBgrErrUncorrIn,fBgrErrCorrIn; and those modified by DoBackgroundSubtraction(); save background source. void InitTUnfoldSys(void); initialize pointers and TMaps. ~TUnfoldSys(void); delete all data members. void ClearResults(void); clear all data members which depend on the unfolding results. void PrepareSysError(void); calculations required for syst.error; data members modified; fEmatUncorrX, fEmatUncorrAx, fDeltaCorrX, fDeltaCorrAx. void GetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); get output error contribution from statistical fluctuations in A; ematrix: output error matrix histogram; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors; data members modified:; fVYAx, fESparse, fEAtV, fErrorAStat. TMatrixDSparse * PrepareUncorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2); propagate uncorrelated systematic errors to a covariance matrix; m0,m1 : coefficients (matrices) for propagating the errors. the error matrix is calculated by standard error propagation, where the; derivative of the result vector X wrt the matrix A is given by. dX_k / dA_ij = M0_kj * Z0_i - M1_ki * Z1_j. where:; the matrices M0 and M1 are arguments to this function; the vectors Z0, Z1 : GetDXDAZ(). The matrix A is calculated from a matrix B as. A_ij = B_ij / sum_k B_kj. where k runs over additional indices of B, not present in A.; (underflow and overflow bins, used for efficiency corrections). define: Norm_j = sum_k B_kj (data member fSumOverY). the derivative of A wrt this input matrix B is given by:. dA_ij / dB_kj = ( delta_ik - A_ij ) * 1/Norm_j. The covariance matrix Vxx is:. Vxx_mn = sum_ijlk [ (dX_m / dA_ij) * (dA_ij / dB_kj) * DB_kj; * (dX_n / dA_lj) * (dA_lj / dB_kj) ]. where DB_kj is the error on B_kj squared; Simplify the sum over k:. sum_k [ (dA_ij / dB_kj) * DB_kj * (dA_lj / dB_kj) ]; = sum_",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:21582,Availability,error,error,21582,"ave background source. void InitTUnfoldSys(void); initialize pointers and TMaps. ~TUnfoldSys(void); delete all data members. void ClearResults(void); clear all data members which depend on the unfolding results. void PrepareSysError(void); calculations required for syst.error; data members modified; fEmatUncorrX, fEmatUncorrAx, fDeltaCorrX, fDeltaCorrAx. void GetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); get output error contribution from statistical fluctuations in A; ematrix: output error matrix histogram; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors; data members modified:; fVYAx, fESparse, fEAtV, fErrorAStat. TMatrixDSparse * PrepareUncorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2); propagate uncorrelated systematic errors to a covariance matrix; m0,m1 : coefficients (matrices) for propagating the errors. the error matrix is calculated by standard error propagation, where the; derivative of the result vector X wrt the matrix A is given by. dX_k / dA_ij = M0_kj * Z0_i - M1_ki * Z1_j. where:; the matrices M0 and M1 are arguments to this function; the vectors Z0, Z1 : GetDXDAZ(). The matrix A is calculated from a matrix B as. A_ij = B_ij / sum_k B_kj. where k runs over additional indices of B, not present in A.; (underflow and overflow bins, used for efficiency corrections). define: Norm_j = sum_k B_kj (data member fSumOverY). the derivative of A wrt this input matrix B is given by:. dA_ij / dB_kj = ( delta_ik - A_ij ) * 1/Norm_j. The covariance matrix Vxx is:. Vxx_mn = sum_ijlk [ (dX_m / dA_ij) * (dA_ij / dB_kj) * DB_kj; * (dX_n / dA_lj) * (dA_lj / dB_kj) ]. where DB_kj is the error on B_kj squared; Simplify the sum over k:. sum_k [ (dA_ij / dB_kj) * DB_kj * (dA_lj / dB_kj) ]; = sum_k [ ( delta_ik - A_ij ) * 1/Norm_j * DB_kj *; * ( delta_lk - A_lj ) * 1/Norm_j ]; = sum_k [ ( delta_ik*delta_lk - delta_ik*A_lj - delta_lk*A_ij; + A_ij * A_lj ) * DB_kj / Norm",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:21621,Availability,error,error,21621,"ave background source. void InitTUnfoldSys(void); initialize pointers and TMaps. ~TUnfoldSys(void); delete all data members. void ClearResults(void); clear all data members which depend on the unfolding results. void PrepareSysError(void); calculations required for syst.error; data members modified; fEmatUncorrX, fEmatUncorrAx, fDeltaCorrX, fDeltaCorrAx. void GetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); get output error contribution from statistical fluctuations in A; ematrix: output error matrix histogram; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors; data members modified:; fVYAx, fESparse, fEAtV, fErrorAStat. TMatrixDSparse * PrepareUncorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2); propagate uncorrelated systematic errors to a covariance matrix; m0,m1 : coefficients (matrices) for propagating the errors. the error matrix is calculated by standard error propagation, where the; derivative of the result vector X wrt the matrix A is given by. dX_k / dA_ij = M0_kj * Z0_i - M1_ki * Z1_j. where:; the matrices M0 and M1 are arguments to this function; the vectors Z0, Z1 : GetDXDAZ(). The matrix A is calculated from a matrix B as. A_ij = B_ij / sum_k B_kj. where k runs over additional indices of B, not present in A.; (underflow and overflow bins, used for efficiency corrections). define: Norm_j = sum_k B_kj (data member fSumOverY). the derivative of A wrt this input matrix B is given by:. dA_ij / dB_kj = ( delta_ik - A_ij ) * 1/Norm_j. The covariance matrix Vxx is:. Vxx_mn = sum_ijlk [ (dX_m / dA_ij) * (dA_ij / dB_kj) * DB_kj; * (dX_n / dA_lj) * (dA_lj / dB_kj) ]. where DB_kj is the error on B_kj squared; Simplify the sum over k:. sum_k [ (dA_ij / dB_kj) * DB_kj * (dA_lj / dB_kj) ]; = sum_k [ ( delta_ik - A_ij ) * 1/Norm_j * DB_kj *; * ( delta_lk - A_lj ) * 1/Norm_j ]; = sum_k [ ( delta_ik*delta_lk - delta_ik*A_lj - delta_lk*A_ij; + A_ij * A_lj ) * DB_kj / Norm",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:22363,Availability,error,error,22363,"se * PrepareUncorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2); propagate uncorrelated systematic errors to a covariance matrix; m0,m1 : coefficients (matrices) for propagating the errors. the error matrix is calculated by standard error propagation, where the; derivative of the result vector X wrt the matrix A is given by. dX_k / dA_ij = M0_kj * Z0_i - M1_ki * Z1_j. where:; the matrices M0 and M1 are arguments to this function; the vectors Z0, Z1 : GetDXDAZ(). The matrix A is calculated from a matrix B as. A_ij = B_ij / sum_k B_kj. where k runs over additional indices of B, not present in A.; (underflow and overflow bins, used for efficiency corrections). define: Norm_j = sum_k B_kj (data member fSumOverY). the derivative of A wrt this input matrix B is given by:. dA_ij / dB_kj = ( delta_ik - A_ij ) * 1/Norm_j. The covariance matrix Vxx is:. Vxx_mn = sum_ijlk [ (dX_m / dA_ij) * (dA_ij / dB_kj) * DB_kj; * (dX_n / dA_lj) * (dA_lj / dB_kj) ]. where DB_kj is the error on B_kj squared; Simplify the sum over k:. sum_k [ (dA_ij / dB_kj) * DB_kj * (dA_lj / dB_kj) ]; = sum_k [ ( delta_ik - A_ij ) * 1/Norm_j * DB_kj *; * ( delta_lk - A_lj ) * 1/Norm_j ]; = sum_k [ ( delta_ik*delta_lk - delta_ik*A_lj - delta_lk*A_ij; + A_ij * A_lj ) * DB_kj / Norm_j^2 ]. introduce normalized errors: Rsq_kj = DB_kj / Norm_j^2; after summing over k:; delta_ik*delta_lk*Rsq_kj -> delta_il*Rsq_ij; delta_ik*A_lj*Rsq_kj -> A_lj*Rsq_ij; delta_lk*A_ij*Rsq_kj -> A_ij*Rsq_lj; A_ij*A_lj*Rsq_kj -> A_ij*A_lj*sum_k(Rsq_kj). introduce sum of normalized errors squared: SRsq_j = sum_k(Rsq_kj). Note: Rsq_ij is stored as fDAinRelSq (excludes extra indices of B); and SRsq_j is stored as fDAinColRelSq (sum includes all indices of B). Vxx_nm = sum_ijl [ (dX_m / dA_ij) * (dX_n / dA_lj); (delta_il*Rsq_ij - A_lj*Rsq_ij - A_ij*Rsq_lj + A_ij*A_lj *SRsq_j) ]. Vxx_nm = sum_j [ F_mj * F_nj * SRsq_j; - sum_j [ G_mj * F_nj ]; - sum_j [ F_mj * G_nj ]; + sum_ij [ (dX_m / dA_ij) * (dX_n / dA_lj) * Rsq_ij ]. where:; ",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:22675,Availability,error,errors,22675,"rices M0 and M1 are arguments to this function; the vectors Z0, Z1 : GetDXDAZ(). The matrix A is calculated from a matrix B as. A_ij = B_ij / sum_k B_kj. where k runs over additional indices of B, not present in A.; (underflow and overflow bins, used for efficiency corrections). define: Norm_j = sum_k B_kj (data member fSumOverY). the derivative of A wrt this input matrix B is given by:. dA_ij / dB_kj = ( delta_ik - A_ij ) * 1/Norm_j. The covariance matrix Vxx is:. Vxx_mn = sum_ijlk [ (dX_m / dA_ij) * (dA_ij / dB_kj) * DB_kj; * (dX_n / dA_lj) * (dA_lj / dB_kj) ]. where DB_kj is the error on B_kj squared; Simplify the sum over k:. sum_k [ (dA_ij / dB_kj) * DB_kj * (dA_lj / dB_kj) ]; = sum_k [ ( delta_ik - A_ij ) * 1/Norm_j * DB_kj *; * ( delta_lk - A_lj ) * 1/Norm_j ]; = sum_k [ ( delta_ik*delta_lk - delta_ik*A_lj - delta_lk*A_ij; + A_ij * A_lj ) * DB_kj / Norm_j^2 ]. introduce normalized errors: Rsq_kj = DB_kj / Norm_j^2; after summing over k:; delta_ik*delta_lk*Rsq_kj -> delta_il*Rsq_ij; delta_ik*A_lj*Rsq_kj -> A_lj*Rsq_ij; delta_lk*A_ij*Rsq_kj -> A_ij*Rsq_lj; A_ij*A_lj*Rsq_kj -> A_ij*A_lj*sum_k(Rsq_kj). introduce sum of normalized errors squared: SRsq_j = sum_k(Rsq_kj). Note: Rsq_ij is stored as fDAinRelSq (excludes extra indices of B); and SRsq_j is stored as fDAinColRelSq (sum includes all indices of B). Vxx_nm = sum_ijl [ (dX_m / dA_ij) * (dX_n / dA_lj); (delta_il*Rsq_ij - A_lj*Rsq_ij - A_ij*Rsq_lj + A_ij*A_lj *SRsq_j) ]. Vxx_nm = sum_j [ F_mj * F_nj * SRsq_j; - sum_j [ G_mj * F_nj ]; - sum_j [ F_mj * G_nj ]; + sum_ij [ (dX_m / dA_ij) * (dX_n / dA_lj) * Rsq_ij ]. where:; F_mj = sum_i [ (dX_m / dA_ij) * A_ij ]; G_mj = sum_i [ (dX_m / dA_ij) * Rsq_ij ]. In order to avoid explicitly calculating the 3-dimensional tensor; (dX_m/dA_ij) the sums are evaluated further, using; dX_k / dA_ij = M0_kj * Z0_i - M1_ki * Z1_j. F_mj = M0_mj * (A# Z0)_j - (M1 A)_mj Z1_j; G_mj = M0_mj * (Rsq# Z0)_j - (M1 Rsq)_mj Z1_j. and. sum_ij [ (dX_m/dA_ij) * (dX_n/dA_ij) * Rsq_ij ] =; sum_j [",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:22925,Availability,error,errors,22925,"ere k runs over additional indices of B, not present in A.; (underflow and overflow bins, used for efficiency corrections). define: Norm_j = sum_k B_kj (data member fSumOverY). the derivative of A wrt this input matrix B is given by:. dA_ij / dB_kj = ( delta_ik - A_ij ) * 1/Norm_j. The covariance matrix Vxx is:. Vxx_mn = sum_ijlk [ (dX_m / dA_ij) * (dA_ij / dB_kj) * DB_kj; * (dX_n / dA_lj) * (dA_lj / dB_kj) ]. where DB_kj is the error on B_kj squared; Simplify the sum over k:. sum_k [ (dA_ij / dB_kj) * DB_kj * (dA_lj / dB_kj) ]; = sum_k [ ( delta_ik - A_ij ) * 1/Norm_j * DB_kj *; * ( delta_lk - A_lj ) * 1/Norm_j ]; = sum_k [ ( delta_ik*delta_lk - delta_ik*A_lj - delta_lk*A_ij; + A_ij * A_lj ) * DB_kj / Norm_j^2 ]. introduce normalized errors: Rsq_kj = DB_kj / Norm_j^2; after summing over k:; delta_ik*delta_lk*Rsq_kj -> delta_il*Rsq_ij; delta_ik*A_lj*Rsq_kj -> A_lj*Rsq_ij; delta_lk*A_ij*Rsq_kj -> A_ij*Rsq_lj; A_ij*A_lj*Rsq_kj -> A_ij*A_lj*sum_k(Rsq_kj). introduce sum of normalized errors squared: SRsq_j = sum_k(Rsq_kj). Note: Rsq_ij is stored as fDAinRelSq (excludes extra indices of B); and SRsq_j is stored as fDAinColRelSq (sum includes all indices of B). Vxx_nm = sum_ijl [ (dX_m / dA_ij) * (dX_n / dA_lj); (delta_il*Rsq_ij - A_lj*Rsq_ij - A_ij*Rsq_lj + A_ij*A_lj *SRsq_j) ]. Vxx_nm = sum_j [ F_mj * F_nj * SRsq_j; - sum_j [ G_mj * F_nj ]; - sum_j [ F_mj * G_nj ]; + sum_ij [ (dX_m / dA_ij) * (dX_n / dA_lj) * Rsq_ij ]. where:; F_mj = sum_i [ (dX_m / dA_ij) * A_ij ]; G_mj = sum_i [ (dX_m / dA_ij) * Rsq_ij ]. In order to avoid explicitly calculating the 3-dimensional tensor; (dX_m/dA_ij) the sums are evaluated further, using; dX_k / dA_ij = M0_kj * Z0_i - M1_ki * Z1_j. F_mj = M0_mj * (A# Z0)_j - (M1 A)_mj Z1_j; G_mj = M0_mj * (Rsq# Z0)_j - (M1 Rsq)_mj Z1_j. and. sum_ij [ (dX_m/dA_ij) * (dX_n/dA_ij) * Rsq_ij ] =; sum_j [ M0_mj * M0_nj * [ sum_i (Z0_i)^2 * Rsq_ij ] ]; + sum_i [ M1_mi * M1_ni * [ sum_j (Z1_j)^2 * Rsq_ij ] ]; - sum_i [ M1_mi * H_ni + M1_ni * H_mi]; where:; H_",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:24607,Availability,error,error,24607,"ums are evaluated further, using; dX_k / dA_ij = M0_kj * Z0_i - M1_ki * Z1_j. F_mj = M0_mj * (A# Z0)_j - (M1 A)_mj Z1_j; G_mj = M0_mj * (Rsq# Z0)_j - (M1 Rsq)_mj Z1_j. and. sum_ij [ (dX_m/dA_ij) * (dX_n/dA_ij) * Rsq_ij ] =; sum_j [ M0_mj * M0_nj * [ sum_i (Z0_i)^2 * Rsq_ij ] ]; + sum_i [ M1_mi * M1_ni * [ sum_j (Z1_j)^2 * Rsq_ij ] ]; - sum_i [ M1_mi * H_ni + M1_ni * H_mi]; where:; H_mi = Z0_i * sum_j [ M0_mj * Z1_j * Rsq_ij ]. collect all contributions:; Vxx_nm = r0 -r1 -r2 +r3 +r4 -r5 -r6; r0 = sum_j [ F_mj * F_nj * SRsq_j ]; r1 = sum_j [ G_mj * F_nj ]; r2 = sum_j [ F_mj * G_nj ]; r3 = sum_j [ M0_mj * M0_nj * [ sum_i (Z0_i)^2 * Rsq_ij ] ]; r4 = sum_i [ M1_mi * M1_ni * [ sum_j (Z1_j)^2 * Rsq_ij ] ]; r5 = sum_i [ M1_mi * H_ni ]; r6 = sum_i [ M1_ni * H_mi ]. calculate contributions containing matrices F and G; r0,r1,r2. void SetTauError(Double_t delta_tau); set uncertainty on tau. void GetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(). void GetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0); get correlated shift induced by a background source; delta: output shift vector histogram; source: name of background source; binMap: see method GetEmatrix(); see PrepareSysError(). void GetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); calculate systematic shift from tau variation; ematrix: output; binMap: see method GetEmatrix(). void GetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift f",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:25277,Availability,error,error,25277,"2 * Rsq_ij ] ]; r5 = sum_i [ M1_mi * H_ni ]; r6 = sum_i [ M1_ni * H_mi ]. calculate contributions containing matrices F and G; r0,r1,r2. void SetTauError(Double_t delta_tau); set uncertainty on tau. void GetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(). void GetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0); get correlated shift induced by a background source; delta: output shift vector histogram; source: name of background source; binMap: see method GetEmatrix(); see PrepareSysError(). void GetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); calculate systematic shift from tau variation; ematrix: output; binMap: see method GetEmatrix(). void GetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given background scale error; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in regularisation parameter; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in input vector alone; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the h",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:25388,Availability,error,errors,25388,"2 * Rsq_ij ] ]; r5 = sum_i [ M1_mi * H_ni ]; r6 = sum_i [ M1_ni * H_mi ]. calculate contributions containing matrices F and G; r0,r1,r2. void SetTauError(Double_t delta_tau); set uncertainty on tau. void GetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(). void GetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0); get correlated shift induced by a background source; delta: output shift vector histogram; source: name of background source; binMap: see method GetEmatrix(); see PrepareSysError(). void GetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); calculate systematic shift from tau variation; ematrix: output; binMap: see method GetEmatrix(). void GetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given background scale error; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in regularisation parameter; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in input vector alone; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the h",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:25573,Availability,error,error,25573,"rce; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(). void GetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0); get correlated shift induced by a background source; delta: output shift vector histogram; source: name of background source; binMap: see method GetEmatrix(); see PrepareSysError(). void GetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); calculate systematic shift from tau variation; ematrix: output; binMap: see method GetEmatrix(). void GetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given background scale error; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in regularisation parameter; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in input vector alone; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat); propagate error matrix vyy to the result; vyy: error matrix on input data fY; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to addin",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:25617,Availability,error,error,25617,"rce; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(). void GetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0); get correlated shift induced by a background source; delta: output shift vector histogram; source: name of background source; binMap: see method GetEmatrix(); see PrepareSysError(). void GetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); calculate systematic shift from tau variation; ematrix: output; binMap: see method GetEmatrix(). void GetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given background scale error; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in regularisation parameter; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in input vector alone; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat); propagate error matrix vyy to the result; vyy: error matrix on input data fY; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to addin",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:25728,Availability,error,errors,25728,"rce; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(). void GetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0); get correlated shift induced by a background source; delta: output shift vector histogram; source: name of background source; binMap: see method GetEmatrix(); see PrepareSysError(). void GetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); calculate systematic shift from tau variation; ematrix: output; binMap: see method GetEmatrix(). void GetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given background scale error; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in regularisation parameter; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in input vector alone; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat); propagate error matrix vyy to the result; vyy: error matrix on input data fY; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to addin",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:25834,Availability,error,error,25834,"inMap: see method GetEmatrix(); see PrepareSysError(). void GetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); calculate systematic shift from tau variation; ematrix: output; binMap: see method GetEmatrix(). void GetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given background scale error; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in regularisation parameter; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in input vector alone; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat); propagate error matrix vyy to the result; vyy: error matrix on input data fY; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); get total error including statistical error; ematrix: output; binMap: see method GetEmatrix(). Double_t GetChi2Sys(void); calculate total chi**2 including systematic errors. void VectorMapToHist(TH1* hist_delta, const TMatrixDSparse",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:25852,Availability,error,error,25852,"inMap: see method GetEmatrix(); see PrepareSysError(). void GetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); calculate systematic shift from tau variation; ematrix: output; binMap: see method GetEmatrix(). void GetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given background scale error; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in regularisation parameter; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in input vector alone; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat); propagate error matrix vyy to the result; vyy: error matrix on input data fY; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); get total error including statistical error; ematrix: output; binMap: see method GetEmatrix(). Double_t GetChi2Sys(void); calculate total chi**2 including systematic errors. void VectorMapToHist(TH1* hist_delta, const TMatrixDSparse",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:26001,Availability,error,errors,26001,"inMap: see method GetEmatrix(); see PrepareSysError(). void GetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); calculate systematic shift from tau variation; ematrix: output; binMap: see method GetEmatrix(). void GetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given background scale error; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in regularisation parameter; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in input vector alone; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat); propagate error matrix vyy to the result; vyy: error matrix on input data fY; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); get total error including statistical error; ematrix: output; binMap: see method GetEmatrix(). Double_t GetChi2Sys(void); calculate total chi**2 including systematic errors. void VectorMapToHist(TH1* hist_delta, const TMatrixDSparse",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:26106,Availability,error,error,26106,"onst Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given background scale error; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in regularisation parameter; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in input vector alone; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat); propagate error matrix vyy to the result; vyy: error matrix on input data fY; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); get total error including statistical error; ematrix: output; binMap: see method GetEmatrix(). Double_t GetChi2Sys(void); calculate total chi**2 including systematic errors. void VectorMapToHist(TH1* hist_delta, const TMatrixDSparse* delta, const Int_t* binMap); sum over bins of *delta, as defined in binMap,fXToHist; hist_delta: histogram to return summed vector; delta: vector to sum and remap. TUnfoldSys(const TUnfoldSys& ). TMatrixDSparse * PrepareCorrEmat(const TMatrixDSparse* m1, const TMatri",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:26124,Availability,error,error,26124,"onst Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given background scale error; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in regularisation parameter; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in input vector alone; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat); propagate error matrix vyy to the result; vyy: error matrix on input data fY; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); get total error including statistical error; ematrix: output; binMap: see method GetEmatrix(). Double_t GetChi2Sys(void); calculate total chi**2 including systematic errors. void VectorMapToHist(TH1* hist_delta, const TMatrixDSparse* delta, const Int_t* binMap); sum over bins of *delta, as defined in binMap,fXToHist; hist_delta: histogram to return summed vector; delta: vector to sum and remap. TUnfoldSys(const TUnfoldSys& ). TMatrixDSparse * PrepareCorrEmat(const TMatrixDSparse* m1, const TMatri",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:26267,Availability,error,errors,26267,"onst Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given background scale error; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in regularisation parameter; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in input vector alone; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat); propagate error matrix vyy to the result; vyy: error matrix on input data fY; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); get total error including statistical error; ematrix: output; binMap: see method GetEmatrix(). Double_t GetChi2Sys(void); calculate total chi**2 including systematic errors. void VectorMapToHist(TH1* hist_delta, const TMatrixDSparse* delta, const Int_t* binMap); sum over bins of *delta, as defined in binMap,fXToHist; hist_delta: histogram to return summed vector; delta: vector to sum and remap. TUnfoldSys(const TUnfoldSys& ). TMatrixDSparse * PrepareCorrEmat(const TMatrixDSparse* m1, const TMatri",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:26389,Availability,error,error,26389,"ale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given background scale error; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in regularisation parameter; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in input vector alone; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat); propagate error matrix vyy to the result; vyy: error matrix on input data fY; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); get total error including statistical error; ematrix: output; binMap: see method GetEmatrix(). Double_t GetChi2Sys(void); calculate total chi**2 including systematic errors. void VectorMapToHist(TH1* hist_delta, const TMatrixDSparse* delta, const Int_t* binMap); sum over bins of *delta, as defined in binMap,fXToHist; hist_delta: histogram to return summed vector; delta: vector to sum and remap. TUnfoldSys(const TUnfoldSys& ). TMatrixDSparse * PrepareCorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2, const TMatrixDSparse* dsys). void ScaleColumnsByVector(TMatrixDSparse* m, const TMatrixTBase<Double_t>* v) const. void GetEmatrixSysBackgroundUncorr(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). » Last changed: root/hist:$Id: TUnfo",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:26426,Availability,error,error,26426,"ale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given background scale error; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in regularisation parameter; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in input vector alone; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat); propagate error matrix vyy to the result; vyy: error matrix on input data fY; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); get total error including statistical error; ematrix: output; binMap: see method GetEmatrix(). Double_t GetChi2Sys(void); calculate total chi**2 including systematic errors. void VectorMapToHist(TH1* hist_delta, const TMatrixDSparse* delta, const Int_t* binMap); sum over bins of *delta, as defined in binMap,fXToHist; hist_delta: histogram to return summed vector; delta: vector to sum and remap. TUnfoldSys(const TUnfoldSys& ). TMatrixDSparse * PrepareCorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2, const TMatrixDSparse* dsys). void ScaleColumnsByVector(TMatrixDSparse* m, const TMatrixTBase<Double_t>* v) const. void GetEmatrixSysBackgroundUncorr(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). » Last changed: root/hist:$Id: TUnfo",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:26571,Availability,error,errors,26571,"ale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given background scale error; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in regularisation parameter; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in input vector alone; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat); propagate error matrix vyy to the result; vyy: error matrix on input data fY; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); get total error including statistical error; ematrix: output; binMap: see method GetEmatrix(). Double_t GetChi2Sys(void); calculate total chi**2 including systematic errors. void VectorMapToHist(TH1* hist_delta, const TMatrixDSparse* delta, const Int_t* binMap); sum over bins of *delta, as defined in binMap,fXToHist; hist_delta: histogram to return summed vector; delta: vector to sum and remap. TUnfoldSys(const TUnfoldSys& ). TMatrixDSparse * PrepareCorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2, const TMatrixDSparse* dsys). void ScaleColumnsByVector(TMatrixDSparse* m, const TMatrixTBase<Double_t>* v) const. void GetEmatrixSysBackgroundUncorr(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). » Last changed: root/hist:$Id: TUnfo",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:26650,Availability,error,error,26650,"trix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in regularisation parameter; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in input vector alone; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat); propagate error matrix vyy to the result; vyy: error matrix on input data fY; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); get total error including statistical error; ematrix: output; binMap: see method GetEmatrix(). Double_t GetChi2Sys(void); calculate total chi**2 including systematic errors. void VectorMapToHist(TH1* hist_delta, const TMatrixDSparse* delta, const Int_t* binMap); sum over bins of *delta, as defined in binMap,fXToHist; hist_delta: histogram to return summed vector; delta: vector to sum and remap. TUnfoldSys(const TUnfoldSys& ). TMatrixDSparse * PrepareCorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2, const TMatrixDSparse* dsys). void ScaleColumnsByVector(TMatrixDSparse* m, const TMatrixTBase<Double_t>* v) const. void GetEmatrixSysBackgroundUncorr(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). » Last changed: root/hist:$Id: TUnfoldSys.h 37440 2010-12-09 15:13:46Z moneta $ » Last generated: 2011-11-03 20:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT supp",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:26678,Availability,error,error,26678,"trix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in regularisation parameter; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in input vector alone; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat); propagate error matrix vyy to the result; vyy: error matrix on input data fY; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); get total error including statistical error; ematrix: output; binMap: see method GetEmatrix(). Double_t GetChi2Sys(void); calculate total chi**2 including systematic errors. void VectorMapToHist(TH1* hist_delta, const TMatrixDSparse* delta, const Int_t* binMap); sum over bins of *delta, as defined in binMap,fXToHist; hist_delta: histogram to return summed vector; delta: vector to sum and remap. TUnfoldSys(const TUnfoldSys& ). TMatrixDSparse * PrepareCorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2, const TMatrixDSparse* dsys). void ScaleColumnsByVector(TMatrixDSparse* m, const TMatrixTBase<Double_t>* v) const. void GetEmatrixSysBackgroundUncorr(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). » Last changed: root/hist:$Id: TUnfoldSys.h 37440 2010-12-09 15:13:46Z moneta $ » Last generated: 2011-11-03 20:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT supp",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:26806,Availability,error,errors,26806,"); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in regularisation parameter; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in input vector alone; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat); propagate error matrix vyy to the result; vyy: error matrix on input data fY; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); get total error including statistical error; ematrix: output; binMap: see method GetEmatrix(). Double_t GetChi2Sys(void); calculate total chi**2 including systematic errors. void VectorMapToHist(TH1* hist_delta, const TMatrixDSparse* delta, const Int_t* binMap); sum over bins of *delta, as defined in binMap,fXToHist; hist_delta: histogram to return summed vector; delta: vector to sum and remap. TUnfoldSys(const TUnfoldSys& ). TMatrixDSparse * PrepareCorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2, const TMatrixDSparse* dsys). void ScaleColumnsByVector(TMatrixDSparse* m, const TMatrixTBase<Double_t>* v) const. void GetEmatrixSysBackgroundUncorr(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). » Last changed: root/hist:$Id: TUnfoldSys.h 37440 2010-12-09 15:13:46Z moneta $ » Last generated: 2011-11-03 20:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:20824,Integrability,depend,depend,20824,"vectors fY and fVyy, then performs the background subtraction; Data members modified:; fYData,fY,fVyyData,fVyy,fVyyinvData,fVyyinv; and those modified by TUnfold::SetInput(); and those modified by DoBackgroundSubtraction(); LM: WARNING: Coverity detects here a false USE_AFTER_FREE for fY and fVyy; the objects are deleted but then re-created immediatly afterwards in; TUnfold::SetInput. void SubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1.0, Double_t scale_error = 0.0); Store background source; bgr: background distribution with uncorrelated errors; name: name of this background source; scale: scale factor applied to the background; scaleError: error on scale factor (correlated error). Data members modified:; fBgrIn,fBgrErrUncorrIn,fBgrErrCorrIn; and those modified by DoBackgroundSubtraction(); save background source. void InitTUnfoldSys(void); initialize pointers and TMaps. ~TUnfoldSys(void); delete all data members. void ClearResults(void); clear all data members which depend on the unfolding results. void PrepareSysError(void); calculations required for syst.error; data members modified; fEmatUncorrX, fEmatUncorrAx, fDeltaCorrX, fDeltaCorrAx. void GetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); get output error contribution from statistical fluctuations in A; ematrix: output error matrix histogram; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors; data members modified:; fVYAx, fESparse, fEAtV, fErrorAStat. TMatrixDSparse * PrepareUncorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2); propagate uncorrelated systematic errors to a covariance matrix; m0,m1 : coefficients (matrices) for propagating the errors. the error matrix is calculated by standard error propagation, where the; derivative of the result vector X wrt the matrix A is given by. dX_k / dA_ij = M0_kj * Z0_i - M1_ki * Z1_j. where:; the matrices M0 and M1 are arguments to this f",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:10319,Modifiability,Inherit,InheritsFrom,10319,,MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:10385,Modifiability,Inherit,InheritsFrom,10385,,MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:18177,Modifiability,Inherit,Inheritance,18177,"t from fSysIn on fAx; TMap*fDeltaCorrXResult: syst.shift from fSysIn on fX; TMatrixDSparse*fDeltaSysTauResult: systematic shift from tau; Double_tfDtauInput: error on tau; TMatrixDSparse*fEmatUncorrAxResult: syst.error from fDA2 on fAx; TMatrixDSparse*fEmatUncorrXResult: syst.error from fDA2 on fX; TArrayITUnfold::fHistToXInput: histogram bins -> matrix indices; TMatrixDSparse*TUnfold::fLsquaredInput: regularisation conditions squared; TUnfold::ERegModeTUnfold::fRegModeInput: type of regularisation; TArrayDTUnfold::fSumOverYInput: sum of all columns; TMap*fSysInInput: correlated errors; Double_tTUnfold::fTauSquaredInput: regularisation parameter; TMatrixDSparse*TUnfold::fVyyInput: covariance matrix for y; TMatrixDSparse*fVyyDataInput: error on fY prior to bgr subtraction; TMatrixD*TUnfold::fX0Input: x0; TArrayITUnfold::fXToHistInput: matrix indices -> histogram bins; TMatrixD*TUnfold::fYInput: y; TMatrixD*fYDataInput: fY prior to bgr subtraction. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnfoldSys(const TUnfoldSys& ); set all pointers to zero. TUnfoldSys(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintNone); arguments:; hist_A: matrix that describes the migrations; histmap: mapping of the histogram axes to the unfolding output; regmode: global regularisation mode; data members initialized to something different from zero:; fDA2, fDAcol; initialize TUnfold. void AddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode); add a correlated error source; sysError: alternative matrix or matrix of absolute/relative shifts; name: name of the error source; histmap: mapping of the histogram axes to the unfolding output; mode: format of the error source. void DoBackgroundSubtraction(void); performs background subtraction; fY = fYData - fBgrIn; fVyy = fVyyData + fBgrErrUncorr^2 + fBgrErrCorr * fB",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:18190,Modifiability,Inherit,Inherited,18190,"t from fSysIn on fAx; TMap*fDeltaCorrXResult: syst.shift from fSysIn on fX; TMatrixDSparse*fDeltaSysTauResult: systematic shift from tau; Double_tfDtauInput: error on tau; TMatrixDSparse*fEmatUncorrAxResult: syst.error from fDA2 on fAx; TMatrixDSparse*fEmatUncorrXResult: syst.error from fDA2 on fX; TArrayITUnfold::fHistToXInput: histogram bins -> matrix indices; TMatrixDSparse*TUnfold::fLsquaredInput: regularisation conditions squared; TUnfold::ERegModeTUnfold::fRegModeInput: type of regularisation; TArrayDTUnfold::fSumOverYInput: sum of all columns; TMap*fSysInInput: correlated errors; Double_tTUnfold::fTauSquaredInput: regularisation parameter; TMatrixDSparse*TUnfold::fVyyInput: covariance matrix for y; TMatrixDSparse*fVyyDataInput: error on fY prior to bgr subtraction; TMatrixD*TUnfold::fX0Input: x0; TArrayITUnfold::fXToHistInput: matrix indices -> histogram bins; TMatrixD*TUnfold::fYInput: y; TMatrixD*fYDataInput: fY prior to bgr subtraction. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnfoldSys(const TUnfoldSys& ); set all pointers to zero. TUnfoldSys(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintNone); arguments:; hist_A: matrix that describes the migrations; histmap: mapping of the histogram axes to the unfolding output; regmode: global regularisation mode; data members initialized to something different from zero:; fDA2, fDAcol; initialize TUnfold. void AddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode); add a correlated error source; sysError: alternative matrix or matrix of absolute/relative shifts; name: name of the error source; histmap: mapping of the histogram axes to the unfolding output; mode: format of the error source. void DoBackgroundSubtraction(void); performs background subtraction; fY = fYData - fBgrIn; fVyy = fVyyData + fBgrErrUncorr^2 + fBgrErrCorr * fB",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:19096,Performance,perform,performs,19096,"gr subtraction. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnfoldSys(const TUnfoldSys& ); set all pointers to zero. TUnfoldSys(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintNone); arguments:; hist_A: matrix that describes the migrations; histmap: mapping of the histogram axes to the unfolding output; regmode: global regularisation mode; data members initialized to something different from zero:; fDA2, fDAcol; initialize TUnfold. void AddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode); add a correlated error source; sysError: alternative matrix or matrix of absolute/relative shifts; name: name of the error source; histmap: mapping of the histogram axes to the unfolding output; mode: format of the error source. void DoBackgroundSubtraction(void); performs background subtraction; fY = fYData - fBgrIn; fVyy = fVyyData + fBgrErrUncorr^2 + fBgrErrCorr * fBgrErrCorr#; fVyyinv = fVyy^(-1). Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0.0, Double_t oneOverZeroError = 0.0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Calls the SetInput metghod of the base class, then renames the input; vectors fY and fVyy, then performs the background subtraction; Data members modified:; fYData,fY,fVyyData,fVyy,fVyyinvData,fVyyinv; and those modified by TUnfold::SetInput(); and those modified by DoBackgroundSubtraction(); LM: WARNING: Coverity detects here a false USE_AFTER_FREE for fY and fVyy; the objects are deleted but then re-",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:19838,Performance,perform,performs,19838,"ernative matrix or matrix of absolute/relative shifts; name: name of the error source; histmap: mapping of the histogram axes to the unfolding output; mode: format of the error source. void DoBackgroundSubtraction(void); performs background subtraction; fY = fYData - fBgrIn; fVyy = fVyyData + fBgrErrUncorr^2 + fBgrErrCorr * fBgrErrCorr#; fVyyinv = fVyy^(-1). Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0.0, Double_t oneOverZeroError = 0.0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Calls the SetInput metghod of the base class, then renames the input; vectors fY and fVyy, then performs the background subtraction; Data members modified:; fYData,fY,fVyyData,fVyy,fVyyinvData,fVyyinv; and those modified by TUnfold::SetInput(); and those modified by DoBackgroundSubtraction(); LM: WARNING: Coverity detects here a false USE_AFTER_FREE for fY and fVyy; the objects are deleted but then re-created immediatly afterwards in; TUnfold::SetInput. void SubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1.0, Double_t scale_error = 0.0); Store background source; bgr: background distribution with uncorrelated errors; name: name of this background source; scale: scale factor applied to the background; scaleError: error on scale factor (correlated error). Data members modified:; fBgrIn,fBgrErrUncorrIn,fBgrErrCorrIn; and those modified by DoBackgroundSubtraction(); save background source. void InitTUnfoldSys(void); initialize pointers and TMaps. ~TUnfoldSys(void); delete all data members. void ClearResults(void); clear all data members which depend on the unfolding results. void PrepareSysErro",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:2743,Safety,detect,detector,2743,"rces (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general ar NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (0); GetEmatrix() (0)+(d)+(e); GetEmatrixTotal() (0)+(a)+(b)+(c)+(d)+(e). Example:. TH2D *histA,*histAsys1,*histAsys2,*histBgr1,*histBgr2;; TH1D *data;; assume the above histograms are filled:; histA: migration matrix from generator (x-axis) to detector (y-axis); the errors of histA are the uncorrelated systematic errors; histAsys1: alternative migration matrix, when systematic #1 is applied; histAsys1: alternative migration matrix, when systematic #2 is applied; histBgr: known background to the data, with errors. set up the unfolding:. TUnfoldSys unfold(histA,TUnfold::kHistMapOutputVert);; unfold.SetInput(input);; // this background has 5% scale uncertainty; unfold.SubtractBackground(histBgr1,""bgr1"",1.0,0.05);; // this background is scaled by 0.8 and has 10% scale uncertainty; unfold.SubtractBackground(histBgr2,""bgr2"",0.8,0.1);; unfold.AddSysError(histAsys1,""syserror1"",TUnfold::kHistMapOutputVert,; TUnfoldSys::kSysErrModeMatrix);; unfold.AddSysError(histAsys2,""syserror2"",TUnfold::kHistMapOutputVert,; TUnfoldSys::kSysErrModeMatrix);. run the unfolding: see description of class TUnfold; unfold.ScanLcurve( ...). retrieve the output; the errors include errors from input, from histBgr1 and from histBgr2; unfold.GetOutput(output);. retreive systematic shifts corresponding to correlated",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:20058,Safety,detect,detects,20058,"ernative matrix or matrix of absolute/relative shifts; name: name of the error source; histmap: mapping of the histogram axes to the unfolding output; mode: format of the error source. void DoBackgroundSubtraction(void); performs background subtraction; fY = fYData - fBgrIn; fVyy = fVyyData + fBgrErrUncorr^2 + fBgrErrCorr * fBgrErrCorr#; fVyyinv = fVyy^(-1). Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0.0, Double_t oneOverZeroError = 0.0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Calls the SetInput metghod of the base class, then renames the input; vectors fY and fVyy, then performs the background subtraction; Data members modified:; fYData,fY,fVyyData,fVyy,fVyyinvData,fVyyinv; and those modified by TUnfold::SetInput(); and those modified by DoBackgroundSubtraction(); LM: WARNING: Coverity detects here a false USE_AFTER_FREE for fY and fVyy; the objects are deleted but then re-created immediatly afterwards in; TUnfold::SetInput. void SubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1.0, Double_t scale_error = 0.0); Store background source; bgr: background distribution with uncorrelated errors; name: name of this background source; scale: scale factor applied to the background; scaleError: error on scale factor (correlated error). Data members modified:; fBgrIn,fBgrErrUncorrIn,fBgrErrCorrIn; and those modified by DoBackgroundSubtraction(); save background source. void InitTUnfoldSys(void); initialize pointers and TMaps. ~TUnfoldSys(void); delete all data members. void ClearResults(void); clear all data members which depend on the unfolding results. void PrepareSysErro",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:23471,Safety,avoid,avoid,23471,"* 1/Norm_j ]; = sum_k [ ( delta_ik*delta_lk - delta_ik*A_lj - delta_lk*A_ij; + A_ij * A_lj ) * DB_kj / Norm_j^2 ]. introduce normalized errors: Rsq_kj = DB_kj / Norm_j^2; after summing over k:; delta_ik*delta_lk*Rsq_kj -> delta_il*Rsq_ij; delta_ik*A_lj*Rsq_kj -> A_lj*Rsq_ij; delta_lk*A_ij*Rsq_kj -> A_ij*Rsq_lj; A_ij*A_lj*Rsq_kj -> A_ij*A_lj*sum_k(Rsq_kj). introduce sum of normalized errors squared: SRsq_j = sum_k(Rsq_kj). Note: Rsq_ij is stored as fDAinRelSq (excludes extra indices of B); and SRsq_j is stored as fDAinColRelSq (sum includes all indices of B). Vxx_nm = sum_ijl [ (dX_m / dA_ij) * (dX_n / dA_lj); (delta_il*Rsq_ij - A_lj*Rsq_ij - A_ij*Rsq_lj + A_ij*A_lj *SRsq_j) ]. Vxx_nm = sum_j [ F_mj * F_nj * SRsq_j; - sum_j [ G_mj * F_nj ]; - sum_j [ F_mj * G_nj ]; + sum_ij [ (dX_m / dA_ij) * (dX_n / dA_lj) * Rsq_ij ]. where:; F_mj = sum_i [ (dX_m / dA_ij) * A_ij ]; G_mj = sum_i [ (dX_m / dA_ij) * Rsq_ij ]. In order to avoid explicitly calculating the 3-dimensional tensor; (dX_m/dA_ij) the sums are evaluated further, using; dX_k / dA_ij = M0_kj * Z0_i - M1_ki * Z1_j. F_mj = M0_mj * (A# Z0)_j - (M1 A)_mj Z1_j; G_mj = M0_mj * (Rsq# Z0)_j - (M1 Rsq)_mj Z1_j. and. sum_ij [ (dX_m/dA_ij) * (dX_n/dA_ij) * Rsq_ij ] =; sum_j [ M0_mj * M0_nj * [ sum_i (Z0_i)^2 * Rsq_ij ] ]; + sum_i [ M1_mi * M1_ni * [ sum_j (Z1_j)^2 * Rsq_ij ] ]; - sum_i [ M1_mi * H_ni + M1_ni * H_mi]; where:; H_mi = Z0_i * sum_j [ M0_mj * Z1_j * Rsq_ij ]. collect all contributions:; Vxx_nm = r0 -r1 -r2 +r3 +r4 -r5 -r6; r0 = sum_j [ F_mj * F_nj * SRsq_j ]; r1 = sum_j [ G_mj * F_nj ]; r2 = sum_j [ F_mj * G_nj ]; r3 = sum_j [ M0_mj * M0_nj * [ sum_i (Z0_i)^2 * Rsq_ij ] ]; r4 = sum_i [ M1_mi * M1_ni * [ sum_j (Z1_j)^2 * Rsq_ij ] ]; r5 = sum_i [ M1_mi * H_ni ]; r6 = sum_i [ M1_ni * H_mi ]. calculate contributions containing matrices F and G; r0,r1,r2. void SetTauError(Double_t delta_tau); set uncertainty on tau. void GetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); calculate systemat",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:1759,Security,Access,Accessing,1759,"or soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general ar NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (0); GetEmatrix() (0)+(d)+(e); GetEmatrixTotal() (0)+(a)+(b)+(c)+(d)+(e). Example:. TH2D *histA,*histAsys1,*histAsys2,*histBgr1,*histBgr2;; TH1D *data;; assume the above histograms are filled:; histA: migration matrix from generator (x-axis) to detector (y-axis); the errors",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:1876,Security,access,accessed,1876,"background sources. Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general ar NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (0); GetEmatrix() (0)+(d)+(e); GetEmatrixTotal() (0)+(a)+(b)+(c)+(d)+(e). Example:. TH2D *histA,*histAsys1,*histAsys2,*histBgr1,*histBgr2;; TH1D *data;; assume the above histograms are filled:; histA: migration matrix from generator (x-axis) to detector (y-axis); the errors of histA are the uncorrelated systematic errors; histAsys1: alternative migration matrix, when systematic #1 is applied; histAsys1: alternative migration matrix, when systematic #2 is applied; histBgr: known background to the data, with erro",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:10209,Security,Hash,Hash,10209,,MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:12437,Testability,log,logTauX,12437,"Object::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); Int_tTUnfold::RegularizeBins(int start, int step, int nbin, TUnfold::ERegMode regmode); Int_tTUnfold::RegularizeBins2D(int start_bin, int step1, int nbin1, int step2, int nbin2, TUnfold::ERegMode regmode); Int_tTUnfold::RegularizeCurvature(int left_bin, int center_bin, int right_bin, Double_t scale_left = 1.0, Double_t scale_right = 1.0); Int_tTUnfold::RegularizeDerivative(int left_bin, int right_bin, Double_t scale = 1.0); Int_tTUnfold::RegularizeSize(int bin, Double_t scale = 1.0); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tTUnfold::ScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); voidTUnfold::SetBias(const TH1* bias); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTUnfold::SetConstraint(TUnfold::EConstraint constraint); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Int_tSetInput(const TH1* hist_y, Double_t scaleBias = 0.0, Double_t oneOverZeroError = 0.0); static voidTObject::SetObjectStat(Bool_t stat); voidSetTauError(Double_t delta_tau); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidSubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1.0, Double_t scale_error = 0.0); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char*",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:12460,Testability,log,logTauY,12460,"Object::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); Int_tTUnfold::RegularizeBins(int start, int step, int nbin, TUnfold::ERegMode regmode); Int_tTUnfold::RegularizeBins2D(int start_bin, int step1, int nbin1, int step2, int nbin2, TUnfold::ERegMode regmode); Int_tTUnfold::RegularizeCurvature(int left_bin, int center_bin, int right_bin, Double_t scale_left = 1.0, Double_t scale_right = 1.0); Int_tTUnfold::RegularizeDerivative(int left_bin, int right_bin, Double_t scale = 1.0); Int_tTUnfold::RegularizeSize(int bin, Double_t scale = 1.0); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tTUnfold::ScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); voidTUnfold::SetBias(const TH1* bias); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTUnfold::SetConstraint(TUnfold::EConstraint constraint); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Int_tSetInput(const TH1* hist_y, Double_t scaleBias = 0.0, Double_t oneOverZeroError = 0.0); static voidTObject::SetObjectStat(Bool_t stat); voidSetTauError(Double_t delta_tau); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidSubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1.0, Double_t scale_error = 0.0); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char*",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:13310,Testability,Test,TestBit,13310,"X = 0, TSpline** logTauY = 0); voidTUnfold::SetBias(const TH1* bias); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTUnfold::SetConstraint(TUnfold::EConstraint constraint); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Int_tSetInput(const TH1* hist_y, Double_t scaleBias = 0.0, Double_t oneOverZeroError = 0.0); static voidTObject::SetObjectStat(Bool_t stat); voidSetTauError(Double_t delta_tau); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidSubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1.0, Double_t scale_error = 0.0); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. TUnfoldSys(); voidTUnfold::AddMSparse(TMatrixDSparse* dest, Double_t f, const TMatrixDSparse* src); virtual voidClearResults(); TMatrixDSparse*TUnfold::CreateSparseMatrix(Int_t nrow, Int_t ncol, Int_t nele, Int_t* row, Int_t* col, Double_t* data) const; static voidTUnfold::DeleteMatrix(TMatrixD** m); static voidTUnfold::DeleteMatrix(TMatrixDSparse** m); voidDoBackgroundSubtraction(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tTUnfold::DoUnfold(); voidTUnfold::ErrorMatrixToHist(TH2* ematrix, const TMatrixDSparse* emat, const Int_t* binMap, Bool_t doClear) const; const TMatrixDSparse*TUnfold::GetAx() const; const TMatrixDSparse*TUnfold::GetDXDAM(int i) const; const TMatrixDSparse*",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:13349,Testability,Test,TestBits,13349,"X = 0, TSpline** logTauY = 0); voidTUnfold::SetBias(const TH1* bias); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTUnfold::SetConstraint(TUnfold::EConstraint constraint); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Int_tSetInput(const TH1* hist_y, Double_t scaleBias = 0.0, Double_t oneOverZeroError = 0.0); static voidTObject::SetObjectStat(Bool_t stat); voidSetTauError(Double_t delta_tau); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidSubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1.0, Double_t scale_error = 0.0); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. TUnfoldSys(); voidTUnfold::AddMSparse(TMatrixDSparse* dest, Double_t f, const TMatrixDSparse* src); virtual voidClearResults(); TMatrixDSparse*TUnfold::CreateSparseMatrix(Int_t nrow, Int_t ncol, Int_t nele, Int_t* row, Int_t* col, Double_t* data) const; static voidTUnfold::DeleteMatrix(TMatrixD** m); static voidTUnfold::DeleteMatrix(TMatrixDSparse** m); voidDoBackgroundSubtraction(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tTUnfold::DoUnfold(); voidTUnfold::ErrorMatrixToHist(TH2* ematrix, const TMatrixDSparse* emat, const Int_t* binMap, Bool_t doClear) const; const TMatrixDSparse*TUnfold::GetAx() const; const TMatrixDSparse*TUnfold::GetDXDAM(int i) const; const TMatrixDSparse*",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:5065,Usability,clear,cleared,5065,"hifts of each source). unfold.GetDeltaSysBackgroundScale(bgr1shifts,""bgr1"");; unfold.GetDeltaSysBackgroundScale(bgr2shifts,""bgr2"");; unfold.GetDeltaSysSource(sys1shifts,""syserror1"");; unfold.GetDeltaSysSource(sys2shifts,""syserror2"");. retreive errors from uncorrelated sources; In the example, there are four sources of uncorrelated error; * the input vector (statistical errors of the data); * the input matrix histA (Monte Carlo statistical errors); * the errors on bgr1 (Monte Carlo statistical errors); * the errors on bgr2 (Monte Carlo statistical errors); These errors are returned as error matrices. unfold.GetEmatrixInput(stat_error);; unfold.GetEmatrixSysUncorr(uncorr_sys);; unfold.GetEmatrixSysBackgroundUncorr(bgr1uncorr,""bgr1"");; unfold.GetEmatrixSysBackgroundUncorr(bgr2uncorr,""bgr2"");. Error matrices can be added to existing histograms.; This is useful to retreive the sum of several error matrices.; If the last argument of the .GetEmatrixXXX methods is set to kFALSE, the; histogram is not cleared, but the error matrix is simply added.; Example: add all errors from background subtraction. unfold.GetEmatrixSysBackgroundUncorr(bgrerror,""bgr1"",0,kTRUE);; unfold.GetEmatrixSysBackgroundCorr(bgrerror,""bgr1"",0,kFALSE);; unfold.GetEmatrixSysBackgroundUncorr(bgrerror,""bgr2"",0,kFALSE);; unfold.GetEmatrixSysBackgroundCorr(bgrerror,""bgr2"",0,kFALSE);. There is a special function to get the total error:; unfold.GetEmatrixTotal(err_total);. Function Members (Methods); public:. TUnfoldSys(const TUnfoldSys&); TUnfoldSys(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintNone); virtual~TUnfoldSys(); voidTObject::AbstractMethod(const char* method) const; voidAddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const cha",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:5098,Usability,simpl,simply,5098,"hifts of each source). unfold.GetDeltaSysBackgroundScale(bgr1shifts,""bgr1"");; unfold.GetDeltaSysBackgroundScale(bgr2shifts,""bgr2"");; unfold.GetDeltaSysSource(sys1shifts,""syserror1"");; unfold.GetDeltaSysSource(sys2shifts,""syserror2"");. retreive errors from uncorrelated sources; In the example, there are four sources of uncorrelated error; * the input vector (statistical errors of the data); * the input matrix histA (Monte Carlo statistical errors); * the errors on bgr1 (Monte Carlo statistical errors); * the errors on bgr2 (Monte Carlo statistical errors); These errors are returned as error matrices. unfold.GetEmatrixInput(stat_error);; unfold.GetEmatrixSysUncorr(uncorr_sys);; unfold.GetEmatrixSysBackgroundUncorr(bgr1uncorr,""bgr1"");; unfold.GetEmatrixSysBackgroundUncorr(bgr2uncorr,""bgr2"");. Error matrices can be added to existing histograms.; This is useful to retreive the sum of several error matrices.; If the last argument of the .GetEmatrixXXX methods is set to kFALSE, the; histogram is not cleared, but the error matrix is simply added.; Example: add all errors from background subtraction. unfold.GetEmatrixSysBackgroundUncorr(bgrerror,""bgr1"",0,kTRUE);; unfold.GetEmatrixSysBackgroundCorr(bgrerror,""bgr1"",0,kFALSE);; unfold.GetEmatrixSysBackgroundUncorr(bgrerror,""bgr2"",0,kFALSE);; unfold.GetEmatrixSysBackgroundCorr(bgrerror,""bgr2"",0,kFALSE);. There is a special function to get the total error:; unfold.GetEmatrixTotal(err_total);. Function Members (Methods); public:. TUnfoldSys(const TUnfoldSys&); TUnfoldSys(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintNone); virtual~TUnfoldSys(); voidTObject::AbstractMethod(const char* method) const; voidAddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const cha",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:6108,Usability,Clear,Clear,6108,"istogram is not cleared, but the error matrix is simply added.; Example: add all errors from background subtraction. unfold.GetEmatrixSysBackgroundUncorr(bgrerror,""bgr1"",0,kTRUE);; unfold.GetEmatrixSysBackgroundCorr(bgrerror,""bgr1"",0,kFALSE);; unfold.GetEmatrixSysBackgroundUncorr(bgrerror,""bgr2"",0,kFALSE);; unfold.GetEmatrixSysBackgroundCorr(bgrerror,""bgr2"",0,kFALSE);. There is a special function to get the total error:; unfold.GetEmatrixTotal(err_total);. Function Members (Methods); public:. TUnfoldSys(const TUnfoldSys&); TUnfoldSys(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintNone); virtual~TUnfoldSys(); voidTObject::AbstractMethod(const char* method) const; voidAddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tTUnfold::DoUnfold(Double_t tau); Double_tTUnfold::DoUnfold(Double_t tau, const TH1* hist_y, Double_t scaleBias = 0.0); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t ev",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:8030,Usability,clear,clearEmat,8030,"ble_t x0 = 0.0, Double_t x1 = 0.0) const; Double_tTUnfold::GetChi2A() const; Double_tTUnfold::GetChi2L() const; Double_tGetChi2Sys(); voidGetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0); voidGetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); voidGetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTUnfold::GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; TH2D*TUnfold::GetEmatrix(const char* name, const char* title, Double_t x0 = 0.0, Double_t x1 = 0.0) const; voidGetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysBackgroundUncorr(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); TH1D*TUnfold::GetFoldedOutput(const char* name, const char* title, Double_t y0 = 0.0, Double_t y1 = 0.0) const; virtual const char*TObject::GetIconName() const; TH1D*TUnfold::GetInput(const char* name, const char* title, Double_t y0 = 0.0, Double_t y1 = 0.0) const; virtual Double_tTUnfold::GetLcurveX() const; virtual Double_tTUnfold::GetLcurveY() const; TH2D*TUnfold::GetLsquared(const char* name, const char* title, Double_t x0 = 0.0, Double_t x1 = 0.0) const; virtual const char*TObject::GetName() const; Int_tTUnfold::GetNdf() const; Int_tTUnfold::GetNpar() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::Get",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:8149,Usability,clear,clearEmat,8149,"ble_t x0 = 0.0, Double_t x1 = 0.0) const; Double_tTUnfold::GetChi2A() const; Double_tTUnfold::GetChi2L() const; Double_tGetChi2Sys(); voidGetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0); voidGetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); voidGetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTUnfold::GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; TH2D*TUnfold::GetEmatrix(const char* name, const char* title, Double_t x0 = 0.0, Double_t x1 = 0.0) const; voidGetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysBackgroundUncorr(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); TH1D*TUnfold::GetFoldedOutput(const char* name, const char* title, Double_t y0 = 0.0, Double_t y1 = 0.0) const; virtual const char*TObject::GetIconName() const; TH1D*TUnfold::GetInput(const char* name, const char* title, Double_t y0 = 0.0, Double_t y1 = 0.0) const; virtual Double_tTUnfold::GetLcurveX() const; virtual Double_tTUnfold::GetLcurveY() const; TH2D*TUnfold::GetLsquared(const char* name, const char* title, Double_t x0 = 0.0, Double_t x1 = 0.0) const; virtual const char*TObject::GetName() const; Int_tTUnfold::GetNdf() const; Int_tTUnfold::GetNpar() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::Get",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:8269,Usability,clear,clearEmat,8269,"ble_t x0 = 0.0, Double_t x1 = 0.0) const; Double_tTUnfold::GetChi2A() const; Double_tTUnfold::GetChi2L() const; Double_tGetChi2Sys(); voidGetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0); voidGetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); voidGetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTUnfold::GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; TH2D*TUnfold::GetEmatrix(const char* name, const char* title, Double_t x0 = 0.0, Double_t x1 = 0.0) const; voidGetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysBackgroundUncorr(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); TH1D*TUnfold::GetFoldedOutput(const char* name, const char* title, Double_t y0 = 0.0, Double_t y1 = 0.0) const; virtual const char*TObject::GetIconName() const; TH1D*TUnfold::GetInput(const char* name, const char* title, Double_t y0 = 0.0, Double_t y1 = 0.0) const; virtual Double_tTUnfold::GetLcurveX() const; virtual Double_tTUnfold::GetLcurveY() const; TH2D*TUnfold::GetLsquared(const char* name, const char* title, Double_t x0 = 0.0, Double_t x1 = 0.0) const; virtual const char*TObject::GetName() const; Int_tTUnfold::GetNdf() const; Int_tTUnfold::GetNpar() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::Get",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:8379,Usability,clear,clearEmat,8379,"ble_t x0 = 0.0, Double_t x1 = 0.0) const; Double_tTUnfold::GetChi2A() const; Double_tTUnfold::GetChi2L() const; Double_tGetChi2Sys(); voidGetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0); voidGetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); voidGetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTUnfold::GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; TH2D*TUnfold::GetEmatrix(const char* name, const char* title, Double_t x0 = 0.0, Double_t x1 = 0.0) const; voidGetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysBackgroundUncorr(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); TH1D*TUnfold::GetFoldedOutput(const char* name, const char* title, Double_t y0 = 0.0, Double_t y1 = 0.0) const; virtual const char*TObject::GetIconName() const; TH1D*TUnfold::GetInput(const char* name, const char* title, Double_t y0 = 0.0, Double_t y1 = 0.0) const; virtual Double_tTUnfold::GetLcurveX() const; virtual Double_tTUnfold::GetLcurveY() const; TH2D*TUnfold::GetLsquared(const char* name, const char* title, Double_t x0 = 0.0, Double_t x1 = 0.0) const; virtual const char*TObject::GetName() const; Int_tTUnfold::GetNdf() const; Int_tTUnfold::GetNpar() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::Get",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:8466,Usability,clear,clearEmat,8466,"ble_t x0 = 0.0, Double_t x1 = 0.0) const; Double_tTUnfold::GetChi2A() const; Double_tTUnfold::GetChi2L() const; Double_tGetChi2Sys(); voidGetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0); voidGetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); voidGetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTUnfold::GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; TH2D*TUnfold::GetEmatrix(const char* name, const char* title, Double_t x0 = 0.0, Double_t x1 = 0.0) const; voidGetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysBackgroundUncorr(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); TH1D*TUnfold::GetFoldedOutput(const char* name, const char* title, Double_t y0 = 0.0, Double_t y1 = 0.0) const; virtual const char*TObject::GetIconName() const; TH1D*TUnfold::GetInput(const char* name, const char* title, Double_t y0 = 0.0, Double_t y1 = 0.0) const; virtual Double_tTUnfold::GetLcurveX() const; virtual Double_tTUnfold::GetLcurveY() const; TH2D*TUnfold::GetLsquared(const char* name, const char* title, Double_t x0 = 0.0, Double_t x1 = 0.0) const; virtual const char*TObject::GetName() const; Int_tTUnfold::GetNdf() const; Int_tTUnfold::GetNpar() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::Get",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:8556,Usability,clear,clearEmat,8556,"ble_t x0 = 0.0, Double_t x1 = 0.0) const; Double_tTUnfold::GetChi2A() const; Double_tTUnfold::GetChi2L() const; Double_tGetChi2Sys(); voidGetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0); voidGetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); voidGetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTUnfold::GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; TH2D*TUnfold::GetEmatrix(const char* name, const char* title, Double_t x0 = 0.0, Double_t x1 = 0.0) const; voidGetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysBackgroundUncorr(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); TH1D*TUnfold::GetFoldedOutput(const char* name, const char* title, Double_t y0 = 0.0, Double_t y1 = 0.0) const; virtual const char*TObject::GetIconName() const; TH1D*TUnfold::GetInput(const char* name, const char* title, Double_t y0 = 0.0, Double_t y1 = 0.0) const; virtual Double_tTUnfold::GetLcurveX() const; virtual Double_tTUnfold::GetLcurveY() const; TH2D*TUnfold::GetLsquared(const char* name, const char* title, Double_t x0 = 0.0, Double_t x1 = 0.0) const; virtual const char*TObject::GetName() const; Int_tTUnfold::GetNdf() const; Int_tTUnfold::GetNpar() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::Get",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:14760,Usability,clear,clearEmat,14760,"atrixDSparse* src); virtual voidClearResults(); TMatrixDSparse*TUnfold::CreateSparseMatrix(Int_t nrow, Int_t ncol, Int_t nele, Int_t* row, Int_t* col, Double_t* data) const; static voidTUnfold::DeleteMatrix(TMatrixD** m); static voidTUnfold::DeleteMatrix(TMatrixDSparse** m); voidDoBackgroundSubtraction(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tTUnfold::DoUnfold(); voidTUnfold::ErrorMatrixToHist(TH2* ematrix, const TMatrixDSparse* emat, const Int_t* binMap, Bool_t doClear) const; const TMatrixDSparse*TUnfold::GetAx() const; const TMatrixDSparse*TUnfold::GetDXDAM(int i) const; const TMatrixDSparse*TUnfold::GetDXDAZ(int i) const; const TMatrixDSparse*TUnfold::GetDXDtauSquared() const; const TMatrixDSparse*TUnfold::GetDXDY() const; const TMatrixDSparse*TUnfold::GetE() const; const TMatrixDSparse*TUnfold::GetEinv() const; voidGetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat); Int_tTUnfold::GetNx() const; Int_tTUnfold::GetNy() const; const TMatrixDSparse*TUnfold::GetVxx() const; const TMatrixDSparse*TUnfold::GetVxxInv() const; const TMatrixD*TUnfold::GetX() const; static Bool_tTUnfold::InvertMConditioned(TMatrixD* A); TMatrixD*TUnfold::InvertMSparse(const TMatrixDSparse* A) const; voidTObject::MakeZombie(); TMatrixDSparse*TUnfold::MultiplyMSparseM(const TMatrixDSparse* a, const TMatrixD* b) const; TMatrixDSparse*TUnfold::MultiplyMSparseMSparse(const TMatrixDSparse* a, const TMatrixDSparse* b) const; TMatrixDSparse*TUnfold::MultiplyMSparseMSparseTranspVector(const TMatrixDSparse* m1, const TMatrixDSparse* m2, const TMatrixTBase<Double_t>* v) const; TMatrixDSparse*TUnfold::MultiplyMSparseTranspMSparse(const TMatrixDSparse* a, const TMatrixDSparse* b) const; virtual TMatrixDSparse*PrepareCorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2, const TMatrixDSparse* dsys); virtual voidPrepareSysError(); virtual TMatrixDSparse*PrepareUncorrEmat(const T",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:20775,Usability,Clear,ClearResults,20775,"vectors fY and fVyy, then performs the background subtraction; Data members modified:; fYData,fY,fVyyData,fVyy,fVyyinvData,fVyyinv; and those modified by TUnfold::SetInput(); and those modified by DoBackgroundSubtraction(); LM: WARNING: Coverity detects here a false USE_AFTER_FREE for fY and fVyy; the objects are deleted but then re-created immediatly afterwards in; TUnfold::SetInput. void SubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1.0, Double_t scale_error = 0.0); Store background source; bgr: background distribution with uncorrelated errors; name: name of this background source; scale: scale factor applied to the background; scaleError: error on scale factor (correlated error). Data members modified:; fBgrIn,fBgrErrUncorrIn,fBgrErrCorrIn; and those modified by DoBackgroundSubtraction(); save background source. void InitTUnfoldSys(void); initialize pointers and TMaps. ~TUnfoldSys(void); delete all data members. void ClearResults(void); clear all data members which depend on the unfolding results. void PrepareSysError(void); calculations required for syst.error; data members modified; fEmatUncorrX, fEmatUncorrAx, fDeltaCorrX, fDeltaCorrAx. void GetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); get output error contribution from statistical fluctuations in A; ematrix: output error matrix histogram; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors; data members modified:; fVYAx, fESparse, fEAtV, fErrorAStat. TMatrixDSparse * PrepareUncorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2); propagate uncorrelated systematic errors to a covariance matrix; m0,m1 : coefficients (matrices) for propagating the errors. the error matrix is calculated by standard error propagation, where the; derivative of the result vector X wrt the matrix A is given by. dX_k / dA_ij = M0_kj * Z0_i - M1_ki * Z1_j. where:; the matrices M0 and M1 are arguments to this f",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:20795,Usability,clear,clear,20795,"vectors fY and fVyy, then performs the background subtraction; Data members modified:; fYData,fY,fVyyData,fVyy,fVyyinvData,fVyyinv; and those modified by TUnfold::SetInput(); and those modified by DoBackgroundSubtraction(); LM: WARNING: Coverity detects here a false USE_AFTER_FREE for fY and fVyy; the objects are deleted but then re-created immediatly afterwards in; TUnfold::SetInput. void SubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1.0, Double_t scale_error = 0.0); Store background source; bgr: background distribution with uncorrelated errors; name: name of this background source; scale: scale factor applied to the background; scaleError: error on scale factor (correlated error). Data members modified:; fBgrIn,fBgrErrUncorrIn,fBgrErrCorrIn; and those modified by DoBackgroundSubtraction(); save background source. void InitTUnfoldSys(void); initialize pointers and TMaps. ~TUnfoldSys(void); delete all data members. void ClearResults(void); clear all data members which depend on the unfolding results. void PrepareSysError(void); calculations required for syst.error; data members modified; fEmatUncorrX, fEmatUncorrAx, fDeltaCorrX, fDeltaCorrAx. void GetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); get output error contribution from statistical fluctuations in A; ematrix: output error matrix histogram; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors; data members modified:; fVYAx, fESparse, fEAtV, fErrorAStat. TMatrixDSparse * PrepareUncorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2); propagate uncorrelated systematic errors to a covariance matrix; m0,m1 : coefficients (matrices) for propagating the errors. the error matrix is calculated by standard error propagation, where the; derivative of the result vector X wrt the matrix A is given by. dX_k / dA_ij = M0_kj * Z0_i - M1_ki * Z1_j. where:; the matrices M0 and M1 are arguments to this f",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:21073,Usability,clear,clearEmat,21073,"Unfold::SetInput. void SubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1.0, Double_t scale_error = 0.0); Store background source; bgr: background distribution with uncorrelated errors; name: name of this background source; scale: scale factor applied to the background; scaleError: error on scale factor (correlated error). Data members modified:; fBgrIn,fBgrErrUncorrIn,fBgrErrCorrIn; and those modified by DoBackgroundSubtraction(); save background source. void InitTUnfoldSys(void); initialize pointers and TMaps. ~TUnfoldSys(void); delete all data members. void ClearResults(void); clear all data members which depend on the unfolding results. void PrepareSysError(void); calculations required for syst.error; data members modified; fEmatUncorrX, fEmatUncorrAx, fDeltaCorrX, fDeltaCorrAx. void GetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); get output error contribution from statistical fluctuations in A; ematrix: output error matrix histogram; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors; data members modified:; fVYAx, fESparse, fEAtV, fErrorAStat. TMatrixDSparse * PrepareUncorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2); propagate uncorrelated systematic errors to a covariance matrix; m0,m1 : coefficients (matrices) for propagating the errors. the error matrix is calculated by standard error propagation, where the; derivative of the result vector X wrt the matrix A is given by. dX_k / dA_ij = M0_kj * Z0_i - M1_ki * Z1_j. where:; the matrices M0 and M1 are arguments to this function; the vectors Z0, Z1 : GetDXDAZ(). The matrix A is calculated from a matrix B as. A_ij = B_ij / sum_k B_kj. where k runs over additional indices of B, not present in A.; (underflow and overflow bins, used for efficiency corrections). define: Norm_j = sum_k B_kj (data member fSumOverY). the derivative of A wrt this input matrix B is given by:. dA_ij / dB_kj = ( ",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:21232,Usability,clear,clearEmat,21232,"Unfold::SetInput. void SubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1.0, Double_t scale_error = 0.0); Store background source; bgr: background distribution with uncorrelated errors; name: name of this background source; scale: scale factor applied to the background; scaleError: error on scale factor (correlated error). Data members modified:; fBgrIn,fBgrErrUncorrIn,fBgrErrCorrIn; and those modified by DoBackgroundSubtraction(); save background source. void InitTUnfoldSys(void); initialize pointers and TMaps. ~TUnfoldSys(void); delete all data members. void ClearResults(void); clear all data members which depend on the unfolding results. void PrepareSysError(void); calculations required for syst.error; data members modified; fEmatUncorrX, fEmatUncorrAx, fDeltaCorrX, fDeltaCorrAx. void GetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); get output error contribution from statistical fluctuations in A; ematrix: output error matrix histogram; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors; data members modified:; fVYAx, fESparse, fEAtV, fErrorAStat. TMatrixDSparse * PrepareUncorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2); propagate uncorrelated systematic errors to a covariance matrix; m0,m1 : coefficients (matrices) for propagating the errors. the error matrix is calculated by standard error propagation, where the; derivative of the result vector X wrt the matrix A is given by. dX_k / dA_ij = M0_kj * Z0_i - M1_ki * Z1_j. where:; the matrices M0 and M1 are arguments to this function; the vectors Z0, Z1 : GetDXDAZ(). The matrix A is calculated from a matrix B as. A_ij = B_ij / sum_k B_kj. where k runs over additional indices of B, not present in A.; (underflow and overflow bins, used for efficiency corrections). define: Norm_j = sum_k B_kj (data member fSumOverY). the derivative of A wrt this input matrix B is given by:. dA_ij / dB_kj = ( ",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:21256,Usability,clear,clear,21256,"Unfold::SetInput. void SubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1.0, Double_t scale_error = 0.0); Store background source; bgr: background distribution with uncorrelated errors; name: name of this background source; scale: scale factor applied to the background; scaleError: error on scale factor (correlated error). Data members modified:; fBgrIn,fBgrErrUncorrIn,fBgrErrCorrIn; and those modified by DoBackgroundSubtraction(); save background source. void InitTUnfoldSys(void); initialize pointers and TMaps. ~TUnfoldSys(void); delete all data members. void ClearResults(void); clear all data members which depend on the unfolding results. void PrepareSysError(void); calculations required for syst.error; data members modified; fEmatUncorrX, fEmatUncorrAx, fDeltaCorrX, fDeltaCorrAx. void GetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); get output error contribution from statistical fluctuations in A; ematrix: output error matrix histogram; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors; data members modified:; fVYAx, fESparse, fEAtV, fErrorAStat. TMatrixDSparse * PrepareUncorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2); propagate uncorrelated systematic errors to a covariance matrix; m0,m1 : coefficients (matrices) for propagating the errors. the error matrix is calculated by standard error propagation, where the; derivative of the result vector X wrt the matrix A is given by. dX_k / dA_ij = M0_kj * Z0_i - M1_ki * Z1_j. where:; the matrices M0 and M1 are arguments to this function; the vectors Z0, Z1 : GetDXDAZ(). The matrix A is calculated from a matrix B as. A_ij = B_ij / sum_k B_kj. where k runs over additional indices of B, not present in A.; (underflow and overflow bins, used for efficiency corrections). define: Norm_j = sum_k B_kj (data member fSumOverY). the derivative of A wrt this input matrix B is given by:. dA_ij / dB_kj = ( ",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:22386,Usability,Simpl,Simplify,22386,"se * PrepareUncorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2); propagate uncorrelated systematic errors to a covariance matrix; m0,m1 : coefficients (matrices) for propagating the errors. the error matrix is calculated by standard error propagation, where the; derivative of the result vector X wrt the matrix A is given by. dX_k / dA_ij = M0_kj * Z0_i - M1_ki * Z1_j. where:; the matrices M0 and M1 are arguments to this function; the vectors Z0, Z1 : GetDXDAZ(). The matrix A is calculated from a matrix B as. A_ij = B_ij / sum_k B_kj. where k runs over additional indices of B, not present in A.; (underflow and overflow bins, used for efficiency corrections). define: Norm_j = sum_k B_kj (data member fSumOverY). the derivative of A wrt this input matrix B is given by:. dA_ij / dB_kj = ( delta_ik - A_ij ) * 1/Norm_j. The covariance matrix Vxx is:. Vxx_mn = sum_ijlk [ (dX_m / dA_ij) * (dA_ij / dB_kj) * DB_kj; * (dX_n / dA_lj) * (dA_lj / dB_kj) ]. where DB_kj is the error on B_kj squared; Simplify the sum over k:. sum_k [ (dA_ij / dB_kj) * DB_kj * (dA_lj / dB_kj) ]; = sum_k [ ( delta_ik - A_ij ) * 1/Norm_j * DB_kj *; * ( delta_lk - A_lj ) * 1/Norm_j ]; = sum_k [ ( delta_ik*delta_lk - delta_ik*A_lj - delta_lk*A_ij; + A_ij * A_lj ) * DB_kj / Norm_j^2 ]. introduce normalized errors: Rsq_kj = DB_kj / Norm_j^2; after summing over k:; delta_ik*delta_lk*Rsq_kj -> delta_il*Rsq_ij; delta_ik*A_lj*Rsq_kj -> A_lj*Rsq_ij; delta_lk*A_ij*Rsq_kj -> A_ij*Rsq_lj; A_ij*A_lj*Rsq_kj -> A_ij*A_lj*sum_k(Rsq_kj). introduce sum of normalized errors squared: SRsq_j = sum_k(Rsq_kj). Note: Rsq_ij is stored as fDAinRelSq (excludes extra indices of B); and SRsq_j is stored as fDAinColRelSq (sum includes all indices of B). Vxx_nm = sum_ijl [ (dX_m / dA_ij) * (dX_n / dA_lj); (delta_il*Rsq_ij - A_lj*Rsq_ij - A_ij*Rsq_lj + A_ij*A_lj *SRsq_j) ]. Vxx_nm = sum_j [ F_mj * F_nj * SRsq_j; - sum_j [ G_mj * F_nj ]; - sum_j [ F_mj * G_nj ]; + sum_ij [ (dX_m / dA_ij) * (dX_n / dA_lj) * Rsq_ij ]. where:; ",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:25172,Usability,clear,clearEmat,25172,"2 * Rsq_ij ] ]; r5 = sum_i [ M1_mi * H_ni ]; r6 = sum_i [ M1_ni * H_mi ]. calculate contributions containing matrices F and G; r0,r1,r2. void SetTauError(Double_t delta_tau); set uncertainty on tau. void GetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(). void GetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0); get correlated shift induced by a background source; delta: output shift vector histogram; source: name of background source; binMap: see method GetEmatrix(); see PrepareSysError(). void GetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); calculate systematic shift from tau variation; ematrix: output; binMap: see method GetEmatrix(). void GetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given background scale error; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in regularisation parameter; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in input vector alone; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the h",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:25324,Usability,clear,clearEmat,25324,"2 * Rsq_ij ] ]; r5 = sum_i [ M1_mi * H_ni ]; r6 = sum_i [ M1_ni * H_mi ]. calculate contributions containing matrices F and G; r0,r1,r2. void SetTauError(Double_t delta_tau); set uncertainty on tau. void GetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(). void GetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0); get correlated shift induced by a background source; delta: output shift vector histogram; source: name of background source; binMap: see method GetEmatrix(); see PrepareSysError(). void GetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); calculate systematic shift from tau variation; ematrix: output; binMap: see method GetEmatrix(). void GetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given background scale error; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in regularisation parameter; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in input vector alone; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the h",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:25348,Usability,clear,clear,25348,"2 * Rsq_ij ] ]; r5 = sum_i [ M1_mi * H_ni ]; r6 = sum_i [ M1_ni * H_mi ]. calculate contributions containing matrices F and G; r0,r1,r2. void SetTauError(Double_t delta_tau); set uncertainty on tau. void GetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(). void GetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0); get correlated shift induced by a background source; delta: output shift vector histogram; source: name of background source; binMap: see method GetEmatrix(); see PrepareSysError(). void GetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); calculate systematic shift from tau variation; ematrix: output; binMap: see method GetEmatrix(). void GetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given background scale error; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in regularisation parameter; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in input vector alone; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the h",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:25496,Usability,clear,clearEmat,25496,"rce; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(). void GetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0); get correlated shift induced by a background source; delta: output shift vector histogram; source: name of background source; binMap: see method GetEmatrix(); see PrepareSysError(). void GetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); calculate systematic shift from tau variation; ematrix: output; binMap: see method GetEmatrix(). void GetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given background scale error; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in regularisation parameter; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in input vector alone; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat); propagate error matrix vyy to the result; vyy: error matrix on input data fY; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to addin",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:25664,Usability,clear,clearEmat,25664,"rce; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(). void GetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0); get correlated shift induced by a background source; delta: output shift vector histogram; source: name of background source; binMap: see method GetEmatrix(); see PrepareSysError(). void GetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); calculate systematic shift from tau variation; ematrix: output; binMap: see method GetEmatrix(). void GetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given background scale error; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in regularisation parameter; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in input vector alone; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat); propagate error matrix vyy to the result; vyy: error matrix on input data fY; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to addin",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:25688,Usability,clear,clear,25688,"rce; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(). void GetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0); get correlated shift induced by a background source; delta: output shift vector histogram; source: name of background source; binMap: see method GetEmatrix(); see PrepareSysError(). void GetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); calculate systematic shift from tau variation; ematrix: output; binMap: see method GetEmatrix(). void GetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given background scale error; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in regularisation parameter; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in input vector alone; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat); propagate error matrix vyy to the result; vyy: error matrix on input data fY; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to addin",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:25804,Usability,clear,clearEmat,25804,"inMap: see method GetEmatrix(); see PrepareSysError(). void GetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); calculate systematic shift from tau variation; ematrix: output; binMap: see method GetEmatrix(). void GetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given background scale error; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in regularisation parameter; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in input vector alone; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat); propagate error matrix vyy to the result; vyy: error matrix on input data fY; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); get total error including statistical error; ematrix: output; binMap: see method GetEmatrix(). Double_t GetChi2Sys(void); calculate total chi**2 including systematic errors. void VectorMapToHist(TH1* hist_delta, const TMatrixDSparse",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:25937,Usability,clear,clearEmat,25937,"inMap: see method GetEmatrix(); see PrepareSysError(). void GetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); calculate systematic shift from tau variation; ematrix: output; binMap: see method GetEmatrix(). void GetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given background scale error; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in regularisation parameter; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in input vector alone; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat); propagate error matrix vyy to the result; vyy: error matrix on input data fY; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); get total error including statistical error; ematrix: output; binMap: see method GetEmatrix(). Double_t GetChi2Sys(void); calculate total chi**2 including systematic errors. void VectorMapToHist(TH1* hist_delta, const TMatrixDSparse",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:25961,Usability,clear,clear,25961,"inMap: see method GetEmatrix(); see PrepareSysError(). void GetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); calculate systematic shift from tau variation; ematrix: output; binMap: see method GetEmatrix(). void GetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given background scale error; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in regularisation parameter; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in input vector alone; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat); propagate error matrix vyy to the result; vyy: error matrix on input data fY; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); get total error including statistical error; ematrix: output; binMap: see method GetEmatrix(). Double_t GetChi2Sys(void); calculate total chi**2 including systematic errors. void VectorMapToHist(TH1* hist_delta, const TMatrixDSparse",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:26076,Usability,clear,clearEmat,26076,"onst Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given background scale error; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in regularisation parameter; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in input vector alone; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat); propagate error matrix vyy to the result; vyy: error matrix on input data fY; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); get total error including statistical error; ematrix: output; binMap: see method GetEmatrix(). Double_t GetChi2Sys(void); calculate total chi**2 including systematic errors. void VectorMapToHist(TH1* hist_delta, const TMatrixDSparse* delta, const Int_t* binMap); sum over bins of *delta, as defined in binMap,fXToHist; hist_delta: histogram to return summed vector; delta: vector to sum and remap. TUnfoldSys(const TUnfoldSys& ). TMatrixDSparse * PrepareCorrEmat(const TMatrixDSparse* m1, const TMatri",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:26203,Usability,clear,clearEmat,26203,"onst Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given background scale error; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in regularisation parameter; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in input vector alone; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat); propagate error matrix vyy to the result; vyy: error matrix on input data fY; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); get total error including statistical error; ematrix: output; binMap: see method GetEmatrix(). Double_t GetChi2Sys(void); calculate total chi**2 including systematic errors. void VectorMapToHist(TH1* hist_delta, const TMatrixDSparse* delta, const Int_t* binMap); sum over bins of *delta, as defined in binMap,fXToHist; hist_delta: histogram to return summed vector; delta: vector to sum and remap. TUnfoldSys(const TUnfoldSys& ). TMatrixDSparse * PrepareCorrEmat(const TMatrixDSparse* m1, const TMatri",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:26227,Usability,clear,clear,26227,"onst Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given background scale error; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in regularisation parameter; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in input vector alone; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat); propagate error matrix vyy to the result; vyy: error matrix on input data fY; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); get total error including statistical error; ematrix: output; binMap: see method GetEmatrix(). Double_t GetChi2Sys(void); calculate total chi**2 including systematic errors. void VectorMapToHist(TH1* hist_delta, const TMatrixDSparse* delta, const Int_t* binMap); sum over bins of *delta, as defined in binMap,fXToHist; hist_delta: histogram to return summed vector; delta: vector to sum and remap. TUnfoldSys(const TUnfoldSys& ). TMatrixDSparse * PrepareCorrEmat(const TMatrixDSparse* m1, const TMatri",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:26367,Usability,clear,clearEmat,26367,"ale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given background scale error; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in regularisation parameter; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in input vector alone; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat); propagate error matrix vyy to the result; vyy: error matrix on input data fY; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); get total error including statistical error; ematrix: output; binMap: see method GetEmatrix(). Double_t GetChi2Sys(void); calculate total chi**2 including systematic errors. void VectorMapToHist(TH1* hist_delta, const TMatrixDSparse* delta, const Int_t* binMap); sum over bins of *delta, as defined in binMap,fXToHist; hist_delta: histogram to return summed vector; delta: vector to sum and remap. TUnfoldSys(const TUnfoldSys& ). TMatrixDSparse * PrepareCorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2, const TMatrixDSparse* dsys). void ScaleColumnsByVector(TMatrixDSparse* m, const TMatrixTBase<Double_t>* v) const. void GetEmatrixSysBackgroundUncorr(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). » Last changed: root/hist:$Id: TUnfo",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:26507,Usability,clear,clearEmat,26507,"ale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given background scale error; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in regularisation parameter; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in input vector alone; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat); propagate error matrix vyy to the result; vyy: error matrix on input data fY; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); get total error including statistical error; ematrix: output; binMap: see method GetEmatrix(). Double_t GetChi2Sys(void); calculate total chi**2 including systematic errors. void VectorMapToHist(TH1* hist_delta, const TMatrixDSparse* delta, const Int_t* binMap); sum over bins of *delta, as defined in binMap,fXToHist; hist_delta: histogram to return summed vector; delta: vector to sum and remap. TUnfoldSys(const TUnfoldSys& ). TMatrixDSparse * PrepareCorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2, const TMatrixDSparse* dsys). void ScaleColumnsByVector(TMatrixDSparse* m, const TMatrixTBase<Double_t>* v) const. void GetEmatrixSysBackgroundUncorr(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). » Last changed: root/hist:$Id: TUnfo",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:26531,Usability,clear,clear,26531,"ale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given background scale error; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in regularisation parameter; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in input vector alone; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat); propagate error matrix vyy to the result; vyy: error matrix on input data fY; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); get total error including statistical error; ematrix: output; binMap: see method GetEmatrix(). Double_t GetChi2Sys(void); calculate total chi**2 including systematic errors. void VectorMapToHist(TH1* hist_delta, const TMatrixDSparse* delta, const Int_t* binMap); sum over bins of *delta, as defined in binMap,fXToHist; hist_delta: histogram to return summed vector; delta: vector to sum and remap. TUnfoldSys(const TUnfoldSys& ). TMatrixDSparse * PrepareCorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2, const TMatrixDSparse* dsys). void ScaleColumnsByVector(TMatrixDSparse* m, const TMatrixTBase<Double_t>* v) const. void GetEmatrixSysBackgroundUncorr(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). » Last changed: root/hist:$Id: TUnfo",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnfoldSys.html:27370,Usability,clear,clearEmat,27370,"); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in regularisation parameter; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in input vector alone; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat); propagate error matrix vyy to the result; vyy: error matrix on input data fY; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); get total error including statistical error; ematrix: output; binMap: see method GetEmatrix(). Double_t GetChi2Sys(void); calculate total chi**2 including systematic errors. void VectorMapToHist(TH1* hist_delta, const TMatrixDSparse* delta, const Int_t* binMap); sum over bins of *delta, as defined in binMap,fXToHist; hist_delta: histogram to return summed vector; delta: vector to sum and remap. TUnfoldSys(const TUnfoldSys& ). TMatrixDSparse * PrepareCorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2, const TMatrixDSparse* dsys). void ScaleColumnsByVector(TMatrixDSparse* m, const TMatrixTBase<Double_t>* v) const. void GetEmatrixSysBackgroundUncorr(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). » Last changed: root/hist:$Id: TUnfoldSys.h 37440 2010-12-09 15:13:46Z moneta $ » Last generated: 2011-11-03 20:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnfoldSys.html
https://root.cern/root/html532/TUnixSystem.html:3199,Availability,Error,Error,3199,"_t* opt = """", const char* library_name = """", const char* build_dir = """", UInt_t dirmode = 0); virtual char*TSystem::ConcatFileName(const char* dir, const char* name); intConnectService(const char* server, int port, int tcpwindowsize, const char* protocol = ""tcp""); virtual voidTNamed::Copy(TObject& named) const; virtual intCopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual const char*TSystem::DirName(const char* pathname); virtual voidDispatchOneEvent(Bool_t pendingOnly = kFALSE); voidDispatchSignals(ESignals sig); Bool_tDispatchTimers(Bool_t mode); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual Func_tDynFindSymbol(const char* module, const char* entry); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Int_tExec(const char* shellcmd); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExit(int code, Bool_t mode = kTRUE); virtual voidTSystem::ExitLoop(); virtual Bool_tExpandPathName(TString& patbuf); virtual char*ExpandPathName(const char* path); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual const char*FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFreeDirectory(void* dirp); virtual TSystem::EAclicModeTSystem::GetAclicMode() const; virtual Int_tTSystem::GetAclicProperties() const; voidT",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:3369,Availability,error,error,3369,"ConnectService(const char* server, int port, int tcpwindowsize, const char* protocol = ""tcp""); virtual voidTNamed::Copy(TObject& named) const; virtual intCopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual const char*TSystem::DirName(const char* pathname); virtual voidDispatchOneEvent(Bool_t pendingOnly = kFALSE); voidDispatchSignals(ESignals sig); Bool_tDispatchTimers(Bool_t mode); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual Func_tDynFindSymbol(const char* module, const char* entry); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Int_tExec(const char* shellcmd); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExit(int code, Bool_t mode = kTRUE); virtual voidTSystem::ExitLoop(); virtual Bool_tExpandPathName(TString& patbuf); virtual char*ExpandPathName(const char* path); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual const char*FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFreeDirectory(void* dirp); virtual TSystem::EAclicModeTSystem::GetAclicMode() const; virtual Int_tTSystem::GetAclicProperties() const; voidTSystem::GetBeepDefaults(Int_t& freq, Int_t& duration) const; virtual const char*TSystem::GetBuildArch() const; virtual const char*TSystem::GetBuildCompiler() const; virtu",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:3453,Availability,error,error,3453," = ""tcp""); virtual voidTNamed::Copy(TObject& named) const; virtual intCopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual const char*TSystem::DirName(const char* pathname); virtual voidDispatchOneEvent(Bool_t pendingOnly = kFALSE); voidDispatchSignals(ESignals sig); Bool_tDispatchTimers(Bool_t mode); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual Func_tDynFindSymbol(const char* module, const char* entry); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Int_tExec(const char* shellcmd); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExit(int code, Bool_t mode = kTRUE); virtual voidTSystem::ExitLoop(); virtual Bool_tExpandPathName(TString& patbuf); virtual char*ExpandPathName(const char* path); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual const char*FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFreeDirectory(void* dirp); virtual TSystem::EAclicModeTSystem::GetAclicMode() const; virtual Int_tTSystem::GetAclicProperties() const; voidTSystem::GetBeepDefaults(Int_t& freq, Int_t& duration) const; virtual const char*TSystem::GetBuildArch() const; virtual const char*TSystem::GetBuildCompiler() const; virtual const char*TSystem::GetBuildCompilerVersion() const; virtual const char*TSystem::",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:11906,Availability,mask,mask,11906,"nst char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tSelect(TList* active, Long_t timeout); virtual Int_tSelect(TFileHandler* fh, Long_t timeout); virtual intSendBuf(int sock, const void* buffer, int length); virtual intSendRaw(int sock, const void* buffer, int length, int flag); virtual voidTSystem::SetAclicMode(TSystem::EAclicMode mode); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTSystem::SetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); virtual voidSetDisplay(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetDynamicPath(const char* lib); virtual voidSetenv(const char* name, const char* value); voidTSystem::SetErrorStr(const char* errstr); virtual voidTSystem::SetFlagsDebug(const char*); virtual voidTSystem::SetFlagsOpt(const char*); virtual Int_tSetFPEMask(Int_t mask = kDefaultMask); virtual voidTSystem::SetIncludePath(const char* includePath); virtual voidTSystem::SetLinkdefSuffix(const char* suffix); virtual voidTSystem::SetLinkedLibs(const char* linkedLibs); virtual voidTSystem::SetMakeExe(const char* directives); virtual voidTSystem::SetMakeSharedLib(const char* directives); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTSystem::SetObjExt(const char* objExt); virtual voidSetProgname(const char* name); virtual intSetSockOpt(int sock, int option, int val); virtual voidTSystem::SetSoExt(const char* soExt); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidTSystem::ShowOutput(RedirectHandle_t* h); virtual voidSigAlarmInterruptsSyscalls(Bool_t set); virtual Int_tTNamed::Sizeof() const; virtual voidS",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:13531,Availability,mask,mask,13531,"ual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTSystem::SetObjExt(const char* objExt); virtual voidSetProgname(const char* name); virtual intSetSockOpt(int sock, int option, int val); virtual voidTSystem::SetSoExt(const char* soExt); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidTSystem::ShowOutput(RedirectHandle_t* h); virtual voidSigAlarmInterruptsSyscalls(Bool_t set); virtual Int_tTNamed::Sizeof() const; virtual voidSleep(UInt_t milliSec); virtual TStringTSystem::SplitAclicMode(const char* filename, TString& mode, TString& args, TString& io) const; virtual voidStackTrace(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual intSymlink(const char* from, const char* to); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidSyslog(ELogLevel level, const char* mess); virtual const char*TempDirectory() const; virtual FILE*TempFileName(TString& base, const char* dir = 0); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual intUmask(Int_t mask); virtual const char*TSystem::UnixPathName(const char* unixpathname); virtual intUnlink(const char* name); virtual voidUnload(const char* module); virtual voidTSystem::Unsetenv(const char* name); virtual voidTObject::UseCurrentStyle(); virtual intUtime(const char* file, Long_t modtime, Long_t actime); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual char*TSystem::Which(const char* search, const char* file, EAccessMode mode = kFileExists); virtual const char*WorkingDirectory(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:18363,Availability,error,error,18363,"rationUsed by Beep(); Int_tTSystem::fBeepFreqUsed by Beep(); TStringTSystem::fBuildArchArchitecure for which ROOT was built (passed to ./configure); TStringTSystem::fBuildCompilerCompiler used to build this ROOT; TStringTSystem::fBuildCompilerVersionCompiler version used to build this ROOT; TStringTSystem::fBuildDirLocation where to build ACLiC shared library and use as scratch area.; TStringTSystem::fBuildNodeDetailed information where ROOT was built; TSeqCollection*TSystem::fCompiledList of shared libs from compiled macros to be deleted; Bool_tTSystem::fDoneTrue if eventloop should be finished; TSeqCollection*TSystem::fFileHandlerList of file handlers; TStringTSystem::fFlagsDebugFlags for debug compilation; TStringTSystem::fFlagsOptFlags for optimized compilation; TSeqCollection*TSystem::fHelpersList of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); TStringTSystem::fLastErrorStringLast system error message; Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of fd's in masks; TStringTSystem::fObjExtExtension of object fi",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:19017,Availability,mask,mask,19017,"st of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); TStringTSystem::fLastErrorStringLast system error message; Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of fd's in masks; TStringTSystem::fObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*TSystem::fOnExitListList of items to be cleaned-up on exit; TFdSet*TSystem::fReadmask!Files that should be checked for read events; TFdSet*TSystem::fReadready!Files with reads waiting; Int_tTSystem::fSigcntNumber of pending signals; TSeqCollection*TSystem::fSignalHandlerList of signal handlers; TFdSet*TSystem::fSignals!Signals that were trapped; TStringTSystem::fSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*TSystem::fStdExceptionHandlerList of std::exception handlers; TSeqCollection*TSystem::fTimersList of timers; TStringTNamed::fTitleobject title; TStringTSystem::fWdpathWorking directory; TFdSet*TSystem::fWritemask!Files that should be checked for write events; TFdSet*TSystem::fWriteready!Files with writes waiting. Class Charts. Inh",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:19064,Availability,mask,mask,19064,"st of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); TStringTSystem::fLastErrorStringLast system error message; Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of fd's in masks; TStringTSystem::fObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*TSystem::fOnExitListList of items to be cleaned-up on exit; TFdSet*TSystem::fReadmask!Files that should be checked for read events; TFdSet*TSystem::fReadready!Files with reads waiting; Int_tTSystem::fSigcntNumber of pending signals; TSeqCollection*TSystem::fSignalHandlerList of signal handlers; TFdSet*TSystem::fSignals!Signals that were trapped; TStringTSystem::fSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*TSystem::fStdExceptionHandlerList of std::exception handlers; TSeqCollection*TSystem::fTimersList of timers; TStringTNamed::fTitleobject title; TStringTSystem::fWdpathWorking directory; TFdSet*TSystem::fWritemask!Files that should be checked for write events; TFdSet*TSystem::fWriteready!Files with writes waiting. Class Charts. Inh",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:19145,Availability,mask,masks,19145,"st of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); TStringTSystem::fLastErrorStringLast system error message; Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of fd's in masks; TStringTSystem::fObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*TSystem::fOnExitListList of items to be cleaned-up on exit; TFdSet*TSystem::fReadmask!Files that should be checked for read events; TFdSet*TSystem::fReadready!Files with reads waiting; Int_tTSystem::fSigcntNumber of pending signals; TSeqCollection*TSystem::fSignalHandlerList of signal handlers; TFdSet*TSystem::fSignals!Signals that were trapped; TStringTSystem::fSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*TSystem::fStdExceptionHandlerList of std::exception handlers; TSeqCollection*TSystem::fTimersList of timers; TStringTNamed::fTitleobject title; TStringTSystem::fWdpathWorking directory; TFdSet*TSystem::fWritemask!Files that should be checked for write events; TFdSet*TSystem::fWriteready!Files with writes waiting. Class Charts. Inh",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:20579,Availability,error,error,20579,"at were trapped; TStringTSystem::fSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*TSystem::fStdExceptionHandlerList of std::exception handlers; TSeqCollection*TSystem::fTimersList of timers; TStringTNamed::fTitleobject title; TStringTSystem::fWdpathWorking directory; TFdSet*TSystem::fWritemask!Files that should be checked for write events; TFdSet*TSystem::fWriteready!Files with writes waiting. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnixSystem(); { }. ~TUnixSystem(); Reset to original state. Bool_t Init(); Initialize Unix system interface. void SetProgname(const char* name); Set the application name (from command line, argv[0]) and copy it in; gProgName. Copy the application pathname in gProgPath.; If name is 0 let the system set the actual executable name and path; (works on MacOS X and Linux). void SetDisplay(); Set DISPLAY environment variable based on utmp entry. Only for UNIX. const char * GetError(); Return system error string. const char * HostName(); Return the system's host name. void AddFileHandler(TFileHandler* fh); Add a file handler to the list of system file handlers. Only adds; the handler if it is not already in the list of file handlers. TFileHandler * RemoveFileHandler(TFileHandler* fh); Remove a file handler from the list of file handlers. Returns; the handler or 0 if the handler was not in the list of file handlers. void AddSignalHandler(TSignalHandler* sh); Add a signal handler to list of system signal handlers. Only adds; the handler if it is not already in the list of signal handlers. TSignalHandler * RemoveSignalHandler(TSignalHandler* sh); Remove a signal handler from list of signal handlers. Returns; the handler or 0 if the handler was not in the list of signal handlers. void ResetSignal(ESignals sig, Bool_t reset = kTRUE); If reset is true reset the signal handler for the specified signal; to the default handler, else restore previous behaviour. void IgnoreSigna",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:22234,Availability,mask,mask,22234,"rom list of signal handlers. Returns; the handler or 0 if the handler was not in the list of signal handlers. void ResetSignal(ESignals sig, Bool_t reset = kTRUE); If reset is true reset the signal handler for the specified signal; to the default handler, else restore previous behaviour. void IgnoreSignal(ESignals sig, Bool_t ignore = kTRUE); If ignore is true ignore the specified signal, else restore previous; behaviour. void SigAlarmInterruptsSyscalls(Bool_t set); When the argument is true the SIGALRM signal handler is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milliseconds. Int_t Select(TList* active, Long_t timeout); Select on file descriptors. The timeout to is in millisec. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. Returns; -4 in case the list did not contain any file handlers or file handlers; with file descriptor >= 0. Int_t Select(TFileHandler* fh, Long_t timeout); Select on the file descriptor related to file handler h.; The timeout to is in millisec. Returns the number of ready descriptors,; or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR; and -3 EBADF. In case of EINTR the errno has been reset and the method; can be called again. Return",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:22681,Availability,error,error,22681,"e restore previous; behaviour. void SigAlarmInterruptsSyscalls(Bool_t set); When the argument is true the SIGALRM signal handler is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milliseconds. Int_t Select(TList* active, Long_t timeout); Select on file descriptors. The timeout to is in millisec. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. Returns; -4 in case the list did not contain any file handlers or file handlers; with file descriptor >= 0. Int_t Select(TFileHandler* fh, Long_t timeout); Select on the file descriptor related to file handler h.; The timeout to is in millisec. Returns the number of ready descriptors,; or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR; and -3 EBADF. In case of EINTR the errno has been reset and the method; can be called again. Returns -4 in case the file handler is 0 or does; not have a file descriptor >= 0. void DispatchSignals(ESignals sig); Handle and dispatch signals. Bool_t CheckSignals(Bool_t sync); Check if some signals were raised and call their Notify() member. void CheckChilds(); Check if childs have finished. Bool_t CheckDescriptors(); Check if there is activity on some file descriptors and call their; Notify(",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:23134,Availability,error,error,23134,"alls(). Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milliseconds. Int_t Select(TList* active, Long_t timeout); Select on file descriptors. The timeout to is in millisec. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. Returns; -4 in case the list did not contain any file handlers or file handlers; with file descriptor >= 0. Int_t Select(TFileHandler* fh, Long_t timeout); Select on the file descriptor related to file handler h.; The timeout to is in millisec. Returns the number of ready descriptors,; or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR; and -3 EBADF. In case of EINTR the errno has been reset and the method; can be called again. Returns -4 in case the file handler is 0 or does; not have a file descriptor >= 0. void DispatchSignals(ESignals sig); Handle and dispatch signals. Bool_t CheckSignals(Bool_t sync); Check if some signals were raised and call their Notify() member. void CheckChilds(); Check if childs have finished. Bool_t CheckDescriptors(); Check if there is activity on some file descriptors and call their; Notify() member. int MakeDirectory(const char* name); Make a Unix file system directory. Returns 0 in case of success and; -1 if the directory could not be created. void * OpenDirectory(const char* name); Open a Unix file system directory. Returns 0 if directory does not exist. void FreeDirectory(void* dirp); Close a Unix file system directory. const char * GetDirEntry(void* dirp); Get next Unix file system directory entry. Returns 0 if no more entries. Boo",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:24879,Availability,error,error,24879," system directory. Returns 0 if directory does not exist. void FreeDirectory(void* dirp); Close a Unix file system directory. const char * GetDirEntry(void* dirp); Get next Unix file system directory entry. Returns 0 if no more entries. Bool_t ChangeDirectory(const char* path); Change directory. Returns kTRUE in case of success, kFALSE otherwise. const char * WorkingDirectory(); Return working directory. const char * HomeDirectory(const char* userName = 0); Return the user's home directory. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. Returns 0 when successful, -1 in case of failure. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. int GetPathInfo(const c",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:25454,Availability,failure,failure,25454,". FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. Returns 0 when successful, -1 in case of failure. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: id, bsize, bfree, blocks.; Id is file system type (machine dependend, see statfs()); Bsize is block size of file system; Blocks is total number of blocks in file system; Bfree is number of free blocks in file system; The function returns 0 in case of success and 1 if the file sy",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:25541,Availability,error,error,25541,". FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. Returns 0 when successful, -1 in case of failure. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: id, bsize, bfree, blocks.; Id is file system type (machine dependend, see statfs()); Bsize is block size of file system; Blocks is total number of blocks in file system; Bfree is number of free blocks in file system; The function returns 0 in case of success and 1 if the file sy",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:25662,Availability,failure,failure,25662,"; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. Returns 0 when successful, -1 in case of failure. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: id, bsize, bfree, blocks.; Id is file system type (machine dependend, see statfs()); Bsize is block size of file system; Blocks is total number of blocks in file system; Bfree is number of free blocks in file system; The function returns 0 in case of success and 1 if the file system could; not be stat'ed. int Link(const char* from, const char* to); Create a link from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Sym",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:26629,Availability,failure,failure,26629,"e a file. Returns 0 when successful, -1 in case of failure. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: id, bsize, bfree, blocks.; Id is file system type (machine dependend, see statfs()); Bsize is block size of file system; Blocks is total number of blocks in file system; Bfree is number of free blocks in file system; The function returns 0 in case of success and 1 if the file system could; not be stat'ed. int Link(const char* from, const char* to); Create a link from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Symlink(const char* from, const char* to); Create a symlink from file1 to file2. Returns 0 when succesfull,; -1 in case of failure. int Unlink(const char* name); Unlink, i.e. remove, a file or directory. Returns 0 when succesfull,; -1 in case of failure. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. int Chmod(const",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:26765,Availability,failure,failure,26765,"ts to the local file system.; This is used to avoid going through the NIC card for local operations. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: id, bsize, bfree, blocks.; Id is file system type (machine dependend, see statfs()); Bsize is block size of file system; Blocks is total number of blocks in file system; Bfree is number of free blocks in file system; The function returns 0 in case of success and 1 if the file system could; not be stat'ed. int Link(const char* from, const char* to); Create a link from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Symlink(const char* from, const char* to); Create a symlink from file1 to file2. Returns 0 when succesfull,; -1 in case of failure. int Unlink(const char* name); Unlink, i.e. remove, a file or directory. Returns 0 when succesfull,; -1 in case of failure. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the proces",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:26888,Availability,failure,failure,26888,"char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: id, bsize, bfree, blocks.; Id is file system type (machine dependend, see statfs()); Bsize is block size of file system; Blocks is total number of blocks in file system; Bfree is number of free blocks in file system; The function returns 0 in case of success and 1 if the file system could; not be stat'ed. int Link(const char* from, const char* to); Create a link from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Symlink(const char* from, const char* to); Create a symlink from file1 to file2. Returns 0 when succesfull,; -1 in case of failure. int Unlink(const char* name); Unlink, i.e. remove, a file or directory. Returns 0 when succesfull,; -1 in case of failure. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set a files modification and access ",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:27240,Availability,error,error,27240,"ee, blocks.; Id is file system type (machine dependend, see statfs()); Bsize is block size of file system; Blocks is total number of blocks in file system; Bfree is number of free blocks in file system; The function returns 0 in case of success and 1 if the file system could; not be stat'ed. int Link(const char* from, const char* to); Create a link from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Symlink(const char* from, const char* to); Create a symlink from file1 to file2. Returns 0 when succesfull,; -1 in case of failure. int Unlink(const char* name); Unlink, i.e. remove, a file or directory. Returns 0 when succesfull,; -1 in case of failure. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file ""wfil"" in a search path.; The search path is specified as a : separated list of directories.; Return value is pointing to wfile for c",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:27590,Availability,error,error,27590," from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Symlink(const char* from, const char* to); Create a symlink from file1 to file2. Returns 0 when succesfull,; -1 in case of failure. int Unlink(const char* name); Unlink, i.e. remove, a file or directory. Returns 0 when succesfull,; -1 in case of failure. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file ""wfil"" in a search path.; The search path is specified as a : separated list of directories.; Return value is pointing to wfile for compatibility with; Which(const char*,const char*,EAccessMode) version. Int_t GetUid(const char* user = 0); Returns the user's id. If user = 0, returns current user's id. Int_t GetEffectiveUid(); Returns the effective user id. The effective id corresponds to the; set id bit on the file being executed. Int_t GetGid(const char* group = 0); Returns the",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:27691,Availability,error,error,27691,"te a symlink from file1 to file2. Returns 0 when succesfull,; -1 in case of failure. int Unlink(const char* name); Unlink, i.e. remove, a file or directory. Returns 0 when succesfull,; -1 in case of failure. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file ""wfil"" in a search path.; The search path is specified as a : separated list of directories.; Return value is pointing to wfile for compatibility with; Which(const char*,const char*,EAccessMode) version. Int_t GetUid(const char* user = 0); Returns the user's id. If user = 0, returns current user's id. Int_t GetEffectiveUid(); Returns the effective user id. The effective id corresponds to the; set id bit on the file being executed. Int_t GetGid(const char* group = 0); Returns the group's id. If group = 0, returns current user's group. Int_t GetEffectiveGid(); Returns the effective group id. The effect",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:27727,Availability,mask,mask,27727,"esfull,; -1 in case of failure. int Unlink(const char* name); Unlink, i.e. remove, a file or directory. Returns 0 when succesfull,; -1 in case of failure. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file ""wfil"" in a search path.; The search path is specified as a : separated list of directories.; Return value is pointing to wfile for compatibility with; Which(const char*,const char*,EAccessMode) version. Int_t GetUid(const char* user = 0); Returns the user's id. If user = 0, returns current user's id. Int_t GetEffectiveUid(); Returns the effective user id. The effective id corresponds to the; set id bit on the file being executed. Int_t GetGid(const char* group = 0); Returns the group's id. If group = 0, returns current user's group. Int_t GetEffectiveGid(); Returns the effective group id. The effective group id corresponds; to the set id bit on the fi",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:27769,Availability,mask,mask,27769,"esfull,; -1 in case of failure. int Unlink(const char* name); Unlink, i.e. remove, a file or directory. Returns 0 when succesfull,; -1 in case of failure. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file ""wfil"" in a search path.; The search path is specified as a : separated list of directories.; Return value is pointing to wfile for compatibility with; Which(const char*,const char*,EAccessMode) version. Int_t GetUid(const char* user = 0); Returns the user's id. If user = 0, returns current user's id. Int_t GetEffectiveUid(); Returns the effective user id. The effective id corresponds to the; set id bit on the file being executed. Int_t GetGid(const char* group = 0); Returns the group's id. If group = 0, returns current user's group. Int_t GetEffectiveGid(); Returns the effective group id. The effective group id corresponds; to the set id bit on the fi",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:27963,Availability,error,error,27963,"pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file ""wfil"" in a search path.; The search path is specified as a : separated list of directories.; Return value is pointing to wfile for compatibility with; Which(const char*,const char*,EAccessMode) version. Int_t GetUid(const char* user = 0); Returns the user's id. If user = 0, returns current user's id. Int_t GetEffectiveUid(); Returns the effective user id. The effective id corresponds to the; set id bit on the file being executed. Int_t GetGid(const char* group = 0); Returns the group's id. If group = 0, returns current user's group. Int_t GetEffectiveGid(); Returns the effective group id. The effective group id corresponds; to the set id bit on the file being executed. UserGroup_t * GetUserInfo(Int_t uid); Returns all user info in the UserGroup_t structure. The returned; structure must be deleted by the user. In case of error 0 is returned. UserGroup_",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:28915,Availability,error,error,28915,"ime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file ""wfil"" in a search path.; The search path is specified as a : separated list of directories.; Return value is pointing to wfile for compatibility with; Which(const char*,const char*,EAccessMode) version. Int_t GetUid(const char* user = 0); Returns the user's id. If user = 0, returns current user's id. Int_t GetEffectiveUid(); Returns the effective user id. The effective id corresponds to the; set id bit on the file being executed. Int_t GetGid(const char* group = 0); Returns the group's id. If group = 0, returns current user's group. Int_t GetEffectiveGid(); Returns the effective group id. The effective group id corresponds; to the set id bit on the file being executed. UserGroup_t * GetUserInfo(Int_t uid); Returns all user info in the UserGroup_t structure. The returned; structure must be deleted by the user. In case of error 0 is returned. UserGroup_t * GetUserInfo(const char* user = 0); Returns all user info in the UserGroup_t structure. If user = 0, returns; current user's id info. The returned structure must be deleted by the; user. In case of error 0 is returned. UserGroup_t * GetGroupInfo(Int_t gid); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; The returned structure must be deleted by the user. In case of; error 0 is returned. UserGroup_t * GetGroupInfo(const char* group = 0); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. The string passed will be owned by; the environment and can not be reused till a ""nam",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:29147,Availability,error,error,29147,"ed list of directories.; Return value is pointing to wfile for compatibility with; Which(const char*,const char*,EAccessMode) version. Int_t GetUid(const char* user = 0); Returns the user's id. If user = 0, returns current user's id. Int_t GetEffectiveUid(); Returns the effective user id. The effective id corresponds to the; set id bit on the file being executed. Int_t GetGid(const char* group = 0); Returns the group's id. If group = 0, returns current user's group. Int_t GetEffectiveGid(); Returns the effective group id. The effective group id corresponds; to the set id bit on the file being executed. UserGroup_t * GetUserInfo(Int_t uid); Returns all user info in the UserGroup_t structure. The returned; structure must be deleted by the user. In case of error 0 is returned. UserGroup_t * GetUserInfo(const char* user = 0); Returns all user info in the UserGroup_t structure. If user = 0, returns; current user's id info. The returned structure must be deleted by the; user. In case of error 0 is returned. UserGroup_t * GetGroupInfo(Int_t gid); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; The returned structure must be deleted by the user. In case of; error 0 is returned. UserGroup_t * GetGroupInfo(const char* group = 0); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. The string passed will be owned by; the environment and can not be reused till a ""name"" is set; again. The solution below will lose the space for the string; in that case, but if this functions is not called thousands; of times that should not be a problem. const char * Getenv(const char* name); Get environment vari",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:29414,Availability,error,error,29414," the effective user id. The effective id corresponds to the; set id bit on the file being executed. Int_t GetGid(const char* group = 0); Returns the group's id. If group = 0, returns current user's group. Int_t GetEffectiveGid(); Returns the effective group id. The effective group id corresponds; to the set id bit on the file being executed. UserGroup_t * GetUserInfo(Int_t uid); Returns all user info in the UserGroup_t structure. The returned; structure must be deleted by the user. In case of error 0 is returned. UserGroup_t * GetUserInfo(const char* user = 0); Returns all user info in the UserGroup_t structure. If user = 0, returns; current user's id info. The returned structure must be deleted by the; user. In case of error 0 is returned. UserGroup_t * GetGroupInfo(Int_t gid); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; The returned structure must be deleted by the user. In case of; error 0 is returned. UserGroup_t * GetGroupInfo(const char* group = 0); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. The string passed will be owned by; the environment and can not be reused till a ""name"" is set; again. The solution below will lose the space for the string; in that case, but if this functions is not called thousands; of times that should not be a problem. const char * Getenv(const char* name); Get environment variable. int Exec(const char* shellcmd); Execute a command. FILE * OpenPipe(const char* shellcmd, const char* mode); Open a pipe. int ClosePipe(FILE* pipe); Close the pipe. int GetPid(); Get process id. void Exit(int code, Bool_t mode = kTRUE); Exit the application. voi",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:29737,Availability,error,error,29737,"ile being executed. UserGroup_t * GetUserInfo(Int_t uid); Returns all user info in the UserGroup_t structure. The returned; structure must be deleted by the user. In case of error 0 is returned. UserGroup_t * GetUserInfo(const char* user = 0); Returns all user info in the UserGroup_t structure. If user = 0, returns; current user's id info. The returned structure must be deleted by the; user. In case of error 0 is returned. UserGroup_t * GetGroupInfo(Int_t gid); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; The returned structure must be deleted by the user. In case of; error 0 is returned. UserGroup_t * GetGroupInfo(const char* group = 0); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. The string passed will be owned by; the environment and can not be reused till a ""name"" is set; again. The solution below will lose the space for the string; in that case, but if this functions is not called thousands; of times that should not be a problem. const char * Getenv(const char* name); Get environment variable. int Exec(const char* shellcmd); Execute a command. FILE * OpenPipe(const char* shellcmd, const char* mode); Open a pipe. int ClosePipe(FILE* pipe); Close the pipe. int GetPid(); Get process id. void Exit(int code, Bool_t mode = kTRUE); Exit the application. void Abort(int code = 0); Abort the application. void StackTrace(); Print a stack trace. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:31639,Availability,error,error,31639," of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; This function saves internally the current state into a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. Func_t DynFindSymbol(const char* module, const char* entry); dynamic linking of module. int Load(const char* module, const char* entry = """", Bool_t system = kFALSE); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded and -1 in case lib does not exist; or in case of error. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. TTime Now(); Get current time in milliseconds since 0:00 Jan 1 1995. Bool_t DispatchTimers(Bool_t mode); Handle and dispatch timers. If mode = kTRUE dispatch synchronous; timers else a-synchronous timers. void AddTimer(TTimer* ti); Add timer to list of system timers. ",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:31951,Availability,error,error,31951,"n. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; This function saves internally the current state into a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. Func_t DynFindSymbol(const char* module, const char* entry); dynamic linking of module. int Load(const char* module, const char* entry = """", Bool_t system = kFALSE); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded and -1 in case lib does not exist; or in case of error. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. TTime Now(); Get current time in milliseconds since 0:00 Jan 1 1995. Bool_t DispatchTimers(Bool_t mode); Handle and dispatch timers. If mode = kTRUE dispatch synchronous; timers else a-synchronous timers. void AddTimer(TTimer* ti); Add timer to list of system timers. TTimer * RemoveTimer(TTimer* ti); Remove timer from list of system timers. void ResetTimer(TTimer* ti); Reset a-sync timer. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. Returns an TInetAddress; object. To see if the hostname l",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:32348,Availability,error,error,32348,"ucture.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. Func_t DynFindSymbol(const char* module, const char* entry); dynamic linking of module. int Load(const char* module, const char* entry = """", Bool_t system = kFALSE); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded and -1 in case lib does not exist; or in case of error. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. TTime Now(); Get current time in milliseconds since 0:00 Jan 1 1995. Bool_t DispatchTimers(Bool_t mode); Handle and dispatch timers. If mode = kTRUE dispatch synchronous; timers else a-synchronous timers. void AddTimer(TTimer* ti); Add timer to list of system timers. TTimer * RemoveTimer(TTimer* ti); Remove timer from list of system timers. void ResetTimer(TTimer* ti); Reset a-sync timer. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. Returns an TInetAddress; object. To see if the hostname lookup was successfull call; TInetAddress::IsValid(). TInetAddress GetSockName(int sock); Get Internet Protocol (IP) address of host and port #. TInetAddress GetPeerName(int sock); Get Internet Protocol (IP) address of remote host and port #. int GetServiceByName(const char* service); Get port # of internet service. char * GetServiceByPort(int port); Get name of internet service. int ConnectService(const char* server, int p",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:34824,Availability,error,error,34824," scaling).; Is called via the TSocket constructor. int AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); Announce TCP/IP service.; Open a socket, bind to it and start listening for TCP/IP connections; on the port. If reuse is true reuse the address, backlog specifies; how many sockets can be waiting to be accepted.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Returns socket fd or -1 if socket() failed, -2 if bind() failed; or -3 if listen() failed. int AnnounceUdpService(int port, int backlog); Announce UDP service. int AnnounceUnixService(int port, int backlog); Announce unix domain service on path ""kServerPath/<port>"". int AnnounceUnixService(const char* sockpath, int backlog); Announce unix domain service on path 'sockpath'. int AcceptConnection(int sock); Accept a connection. In case of an error return -1. In case; non-blocking I/O is enabled and no connections are available; return -2. void CloseConnection(int sock, Bool_t force = kFALSE); Close socket. int RecvBuf(int sock, void* buffer, int length); Receive a buffer headed by a length indicator. Lenght is the size of; the buffer. Returns the number of bytes received in buf or -1 in; case of error. int SendBuf(int sock, const void* buffer, int length); Send a buffer headed by a length indicator. Returns length of sent buffer; or -1 in case of error. int RecvRaw(int sock, void* buffer, int length, int flag); Receive exactly length bytes into buffer. Use opt to receive out-of-band; data or to have a peek at what is in the buffer (see TSocket). Buffer; must be able to store at least length bytes. Returns the number of; bytes received (can be 0 if other side of connection was closed) or -1; in case of error, -2 in case of MSG_OOB and errno == EWOULDBLOCK, -3; in case of MSG_OOB and errno == EINVAL and -4 in case of kNoBlock",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:34901,Availability,avail,available,34901,"nounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); Announce TCP/IP service.; Open a socket, bind to it and start listening for TCP/IP connections; on the port. If reuse is true reuse the address, backlog specifies; how many sockets can be waiting to be accepted.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Returns socket fd or -1 if socket() failed, -2 if bind() failed; or -3 if listen() failed. int AnnounceUdpService(int port, int backlog); Announce UDP service. int AnnounceUnixService(int port, int backlog); Announce unix domain service on path ""kServerPath/<port>"". int AnnounceUnixService(const char* sockpath, int backlog); Announce unix domain service on path 'sockpath'. int AcceptConnection(int sock); Accept a connection. In case of an error return -1. In case; non-blocking I/O is enabled and no connections are available; return -2. void CloseConnection(int sock, Bool_t force = kFALSE); Close socket. int RecvBuf(int sock, void* buffer, int length); Receive a buffer headed by a length indicator. Lenght is the size of; the buffer. Returns the number of bytes received in buf or -1 in; case of error. int SendBuf(int sock, const void* buffer, int length); Send a buffer headed by a length indicator. Returns length of sent buffer; or -1 in case of error. int RecvRaw(int sock, void* buffer, int length, int flag); Receive exactly length bytes into buffer. Use opt to receive out-of-band; data or to have a peek at what is in the buffer (see TSocket). Buffer; must be able to store at least length bytes. Returns the number of; bytes received (can be 0 if other side of connection was closed) or -1; in case of error, -2 in case of MSG_OOB and errno == EWOULDBLOCK, -3; in case of MSG_OOB and errno == EINVAL and -4 in case of kNoBlock and; errno == EWOULDBLOCK. Returns -5 if pipe broken or",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:35185,Availability,error,error,35185,"to be accepted.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Returns socket fd or -1 if socket() failed, -2 if bind() failed; or -3 if listen() failed. int AnnounceUdpService(int port, int backlog); Announce UDP service. int AnnounceUnixService(int port, int backlog); Announce unix domain service on path ""kServerPath/<port>"". int AnnounceUnixService(const char* sockpath, int backlog); Announce unix domain service on path 'sockpath'. int AcceptConnection(int sock); Accept a connection. In case of an error return -1. In case; non-blocking I/O is enabled and no connections are available; return -2. void CloseConnection(int sock, Bool_t force = kFALSE); Close socket. int RecvBuf(int sock, void* buffer, int length); Receive a buffer headed by a length indicator. Lenght is the size of; the buffer. Returns the number of bytes received in buf or -1 in; case of error. int SendBuf(int sock, const void* buffer, int length); Send a buffer headed by a length indicator. Returns length of sent buffer; or -1 in case of error. int RecvRaw(int sock, void* buffer, int length, int flag); Receive exactly length bytes into buffer. Use opt to receive out-of-band; data or to have a peek at what is in the buffer (see TSocket). Buffer; must be able to store at least length bytes. Returns the number of; bytes received (can be 0 if other side of connection was closed) or -1; in case of error, -2 in case of MSG_OOB and errno == EWOULDBLOCK, -3; in case of MSG_OOB and errno == EINVAL and -4 in case of kNoBlock and; errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer; (EPIPE || ECONNRESET). int SendRaw(int sock, const void* buffer, int length, int flag); Send exactly length bytes from buffer. Use opt to send out-of-band; data (see TSocket). Returns the number of bytes sent or -1 in case of; error. Returns -4 in case of kNoB",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:35339,Availability,error,error,35339,"indowsize > 65KB and for platforms supporting window scaling).; Returns socket fd or -1 if socket() failed, -2 if bind() failed; or -3 if listen() failed. int AnnounceUdpService(int port, int backlog); Announce UDP service. int AnnounceUnixService(int port, int backlog); Announce unix domain service on path ""kServerPath/<port>"". int AnnounceUnixService(const char* sockpath, int backlog); Announce unix domain service on path 'sockpath'. int AcceptConnection(int sock); Accept a connection. In case of an error return -1. In case; non-blocking I/O is enabled and no connections are available; return -2. void CloseConnection(int sock, Bool_t force = kFALSE); Close socket. int RecvBuf(int sock, void* buffer, int length); Receive a buffer headed by a length indicator. Lenght is the size of; the buffer. Returns the number of bytes received in buf or -1 in; case of error. int SendBuf(int sock, const void* buffer, int length); Send a buffer headed by a length indicator. Returns length of sent buffer; or -1 in case of error. int RecvRaw(int sock, void* buffer, int length, int flag); Receive exactly length bytes into buffer. Use opt to receive out-of-band; data or to have a peek at what is in the buffer (see TSocket). Buffer; must be able to store at least length bytes. Returns the number of; bytes received (can be 0 if other side of connection was closed) or -1; in case of error, -2 in case of MSG_OOB and errno == EWOULDBLOCK, -3; in case of MSG_OOB and errno == EINVAL and -4 in case of kNoBlock and; errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer; (EPIPE || ECONNRESET). int SendRaw(int sock, const void* buffer, int length, int flag); Send exactly length bytes from buffer. Use opt to send out-of-band; data (see TSocket). Returns the number of bytes sent or -1 in case of; error. Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). int SetSockOpt(int sock, int option, int val); Set socket optio",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:35701,Availability,error,error,35701,"omain service on path 'sockpath'. int AcceptConnection(int sock); Accept a connection. In case of an error return -1. In case; non-blocking I/O is enabled and no connections are available; return -2. void CloseConnection(int sock, Bool_t force = kFALSE); Close socket. int RecvBuf(int sock, void* buffer, int length); Receive a buffer headed by a length indicator. Lenght is the size of; the buffer. Returns the number of bytes received in buf or -1 in; case of error. int SendBuf(int sock, const void* buffer, int length); Send a buffer headed by a length indicator. Returns length of sent buffer; or -1 in case of error. int RecvRaw(int sock, void* buffer, int length, int flag); Receive exactly length bytes into buffer. Use opt to receive out-of-band; data or to have a peek at what is in the buffer (see TSocket). Buffer; must be able to store at least length bytes. Returns the number of; bytes received (can be 0 if other side of connection was closed) or -1; in case of error, -2 in case of MSG_OOB and errno == EWOULDBLOCK, -3; in case of MSG_OOB and errno == EINVAL and -4 in case of kNoBlock and; errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer; (EPIPE || ECONNRESET). int SendRaw(int sock, const void* buffer, int length, int flag); Send exactly length bytes from buffer. Use opt to send out-of-band; data (see TSocket). Returns the number of bytes sent or -1 in case of; error. Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). int SetSockOpt(int sock, int option, int val); Set socket option. int GetSockOpt(int sock, int option, int* val); Get socket option. void UnixSignal(ESignals sig, void* h); Set a signal handler for a signal. void UnixIgnoreSignal(ESignals sig, Bool_t ignore); If ignore is true ignore the specified signal, else restore previous; behaviour. void UnixSigAlarmInterruptsSyscalls(Bool_t set); When the argument is true the SIGALRM signal handler is set so that; interrupt",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:36124,Availability,error,error,36124," size of; the buffer. Returns the number of bytes received in buf or -1 in; case of error. int SendBuf(int sock, const void* buffer, int length); Send a buffer headed by a length indicator. Returns length of sent buffer; or -1 in case of error. int RecvRaw(int sock, void* buffer, int length, int flag); Receive exactly length bytes into buffer. Use opt to receive out-of-band; data or to have a peek at what is in the buffer (see TSocket). Buffer; must be able to store at least length bytes. Returns the number of; bytes received (can be 0 if other side of connection was closed) or -1; in case of error, -2 in case of MSG_OOB and errno == EWOULDBLOCK, -3; in case of MSG_OOB and errno == EINVAL and -4 in case of kNoBlock and; errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer; (EPIPE || ECONNRESET). int SendRaw(int sock, const void* buffer, int length, int flag); Send exactly length bytes from buffer. Use opt to send out-of-band; data (see TSocket). Returns the number of bytes sent or -1 in case of; error. Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). int SetSockOpt(int sock, int option, int val); Set socket option. int GetSockOpt(int sock, int option, int* val); Get socket option. void UnixSignal(ESignals sig, void* h); Set a signal handler for a signal. void UnixIgnoreSignal(ESignals sig, Bool_t ignore); If ignore is true ignore the specified signal, else restore previous; behaviour. void UnixSigAlarmInterruptsSyscalls(Bool_t set); When the argument is true the SIGALRM signal handler is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). const char * UnixSigname(ESignals sig); Return the signal name associa",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:37582,Availability,mask,masks,37582,"re is true ignore the specified signal, else restore previous; behaviour. void UnixSigAlarmInterruptsSyscalls(Bool_t set); When the argument is true the SIGALRM signal handler is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). const char * UnixSigname(ESignals sig); Return the signal name associated with a signal. void UnixResetSignal(ESignals sig); Restore old signal handler for specified signal. void UnixResetSignals(); Restore old signal handlers. Long64_t UnixNow(); Get current time in milliseconds since 0:00 Jan 1 1995. int UnixSetitimer(Long_t ms); Set interval timer to time-out in ms milliseconds. int UnixSelect(Int_t nfds, TFdSet* readready, TFdSet* writeready, Long_t timeout); Wait for events on the file descriptors specified in the readready and; writeready masks or for timeout (in milliseconds) to occur. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. const char * UnixHomedirectory(const char* user = 0); Returns the user's home directory. int UnixMakedir(const char* name); Make a Unix file system directory. Returns 0 in case of success and; -1 if the directory could not be created (either already exists or; illegal path name). void * UnixOpendir(const char* name); Open a directory. const char * UnixGetdirentry(void* dir); Returns the next directory entry. int UnixFilestat(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int UnixFSstat(const char* path, Long_",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:37720,Availability,error,error,37720,"er is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). const char * UnixSigname(ESignals sig); Return the signal name associated with a signal. void UnixResetSignal(ESignals sig); Restore old signal handler for specified signal. void UnixResetSignals(); Restore old signal handlers. Long64_t UnixNow(); Get current time in milliseconds since 0:00 Jan 1 1995. int UnixSetitimer(Long_t ms); Set interval timer to time-out in ms milliseconds. int UnixSelect(Int_t nfds, TFdSet* readready, TFdSet* writeready, Long_t timeout); Wait for events on the file descriptors specified in the readready and; writeready masks or for timeout (in milliseconds) to occur. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. const char * UnixHomedirectory(const char* user = 0); Returns the user's home directory. int UnixMakedir(const char* name); Make a Unix file system directory. Returns 0 in case of success and; -1 if the directory could not be created (either already exists or; illegal path name). void * UnixOpendir(const char* name); Open a directory. const char * UnixGetdirentry(void* dir); Returns the next directory entry. int UnixFilestat(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int UnixFSstat(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: id, bsize, bfree, blocks.; Id is file system type (machine dependend, see statfs()); Bsi",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:39378,Availability,error,error,39378,"t_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int UnixFSstat(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: id, bsize, bfree, blocks.; Id is file system type (machine dependend, see statfs()); Bsize is block size of file system; Blocks is total number of blocks in file system; Bfree is number of free blocks in file system; The function returns 0 in case of success and 1 if the file system could; not be stat'ed. int UnixWaitchild(); Wait till child is finished. int UnixTcpConnect(const char* hostname, int port, int tcpwindowsize); Open a TCP/IP connection to server and connect to a service (i.e. port).; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Is called via the TSocket constructor. Returns -1 in case of error. int UnixUdpConnect(const char* hostname, int port); Creates a UDP socket connection; Is called via the TSocket constructor. Returns -1 in case of error. int UnixUnixConnect(int port); Connect to a Unix domain socket. int UnixUnixConnect(const char* path); Connect to a Unix domain socket. Returns -1 in case of error. int UnixTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize); Open a socket, bind to it and start listening for TCP/IP connections; on the port. If reuse is true reuse the address, backlog specifies; how many sockets can be waiting to be accepted. If port is 0 a port; scan will be done to find a free port. This option is mutual exlusive; with the reuse option.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Returns socket fd or -1 if socket() failed, -2 if bind() failed; or -3 if listen(",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:39531,Availability,error,error,39531,"_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: id, bsize, bfree, blocks.; Id is file system type (machine dependend, see statfs()); Bsize is block size of file system; Blocks is total number of blocks in file system; Bfree is number of free blocks in file system; The function returns 0 in case of success and 1 if the file system could; not be stat'ed. int UnixWaitchild(); Wait till child is finished. int UnixTcpConnect(const char* hostname, int port, int tcpwindowsize); Open a TCP/IP connection to server and connect to a service (i.e. port).; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Is called via the TSocket constructor. Returns -1 in case of error. int UnixUdpConnect(const char* hostname, int port); Creates a UDP socket connection; Is called via the TSocket constructor. Returns -1 in case of error. int UnixUnixConnect(int port); Connect to a Unix domain socket. int UnixUnixConnect(const char* path); Connect to a Unix domain socket. Returns -1 in case of error. int UnixTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize); Open a socket, bind to it and start listening for TCP/IP connections; on the port. If reuse is true reuse the address, backlog specifies; how many sockets can be waiting to be accepted. If port is 0 a port; scan will be done to find a free port. This option is mutual exlusive; with the reuse option.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Returns socket fd or -1 if socket() failed, -2 if bind() failed; or -3 if listen() failed. int UnixUdpService(int port, int backlog); Open a socket, bind to it and start listening for UDP connections; on the port. If reuse is true reu",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:39696,Availability,error,error,39696,"()); Bsize is block size of file system; Blocks is total number of blocks in file system; Bfree is number of free blocks in file system; The function returns 0 in case of success and 1 if the file system could; not be stat'ed. int UnixWaitchild(); Wait till child is finished. int UnixTcpConnect(const char* hostname, int port, int tcpwindowsize); Open a TCP/IP connection to server and connect to a service (i.e. port).; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Is called via the TSocket constructor. Returns -1 in case of error. int UnixUdpConnect(const char* hostname, int port); Creates a UDP socket connection; Is called via the TSocket constructor. Returns -1 in case of error. int UnixUnixConnect(int port); Connect to a Unix domain socket. int UnixUnixConnect(const char* path); Connect to a Unix domain socket. Returns -1 in case of error. int UnixTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize); Open a socket, bind to it and start listening for TCP/IP connections; on the port. If reuse is true reuse the address, backlog specifies; how many sockets can be waiting to be accepted. If port is 0 a port; scan will be done to find a free port. This option is mutual exlusive; with the reuse option.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Returns socket fd or -1 if socket() failed, -2 if bind() failed; or -3 if listen() failed. int UnixUdpService(int port, int backlog); Open a socket, bind to it and start listening for UDP connections; on the port. If reuse is true reuse the address, backlog specifies; how many sockets can be waiting to be accepted. If port is 0 a port; scan will be done to find a free port. This option is mutual ",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:41207,Availability,error,error,41207,"window scaling).; Returns socket fd or -1 if socket() failed, -2 if bind() failed; or -3 if listen() failed. int UnixUdpService(int port, int backlog); Open a socket, bind to it and start listening for UDP connections; on the port. If reuse is true reuse the address, backlog specifies; how many sockets can be waiting to be accepted. If port is 0 a port; scan will be done to find a free port. This option is mutual exlusive; with the reuse option. int UnixUnixService(int port, int backlog); Open a socket, bind to it and start listening for Unix domain connections; to it. Returns socket fd or -1. int UnixUnixService(const char* sockpath, int backlog); Open a socket on path 'sockpath', bind to it and start listening for Unix; domain connections to it. Returns socket fd or -1. int UnixRecv(int sock, void* buf, int len, int flag); Receive exactly length bytes into buffer. Returns number of bytes; received. Returns -1 in case of error, -2 in case of MSG_OOB; and errno == EWOULDBLOCK, -3 in case of MSG_OOB and errno == EINVAL; and -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). int UnixSend(int sock, const void* buf, int len, int flag); Send exactly length bytes from buffer. Returns -1 in case of error,; otherwise number of sent bytes. Returns -4 in case of kNoBlock and; errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer; (EPIPE || ECONNRESET). void AddDynamicPath(const char* lib); Add a new directory to the dynamic path. const char * GetDynamicPath(); Return the dynamic path (used to find shared libraries). void SetDynamicPath(const char* lib); Set the dynamic path to a new value.; If the value of 'path' is zero, the dynamic path is reset to its; default value. char * DynamicPathName(const char* lib, Bool_t quiet = kFALSE); Returns the path of a shared library (searches for library in the; shared library search path). If no file name extension is provided; it first tries .so, .sl, .dl and the",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:41547,Availability,error,error,41547,"s; how many sockets can be waiting to be accepted. If port is 0 a port; scan will be done to find a free port. This option is mutual exlusive; with the reuse option. int UnixUnixService(int port, int backlog); Open a socket, bind to it and start listening for Unix domain connections; to it. Returns socket fd or -1. int UnixUnixService(const char* sockpath, int backlog); Open a socket on path 'sockpath', bind to it and start listening for Unix; domain connections to it. Returns socket fd or -1. int UnixRecv(int sock, void* buf, int len, int flag); Receive exactly length bytes into buffer. Returns number of bytes; received. Returns -1 in case of error, -2 in case of MSG_OOB; and errno == EWOULDBLOCK, -3 in case of MSG_OOB and errno == EINVAL; and -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). int UnixSend(int sock, const void* buf, int len, int flag); Send exactly length bytes from buffer. Returns -1 in case of error,; otherwise number of sent bytes. Returns -4 in case of kNoBlock and; errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer; (EPIPE || ECONNRESET). void AddDynamicPath(const char* lib); Add a new directory to the dynamic path. const char * GetDynamicPath(); Return the dynamic path (used to find shared libraries). void SetDynamicPath(const char* lib); Set the dynamic path to a new value.; If the value of 'path' is zero, the dynamic path is reset to its; default value. char * DynamicPathName(const char* lib, Bool_t quiet = kFALSE); Returns the path of a shared library (searches for library in the; shared library search path). If no file name extension is provided; it first tries .so, .sl, .dl and then .a (for AIX). The returned string; must be deleted. void * FindDynLib(const char* lib); Returns the handle to a loaded shared library. Returns 0 when library; not loaded. int UnixDynLoad(const char* lib); Load a shared library. Returns 0 on successful loading, 1 in; case lib was al",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:42617,Availability,error,error,42617,"ise number of sent bytes. Returns -4 in case of kNoBlock and; errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer; (EPIPE || ECONNRESET). void AddDynamicPath(const char* lib); Add a new directory to the dynamic path. const char * GetDynamicPath(); Return the dynamic path (used to find shared libraries). void SetDynamicPath(const char* lib); Set the dynamic path to a new value.; If the value of 'path' is zero, the dynamic path is reset to its; default value. char * DynamicPathName(const char* lib, Bool_t quiet = kFALSE); Returns the path of a shared library (searches for library in the; shared library search path). If no file name extension is provided; it first tries .so, .sl, .dl and then .a (for AIX). The returned string; must be deleted. void * FindDynLib(const char* lib); Returns the handle to a loaded shared library. Returns 0 when library; not loaded. int UnixDynLoad(const char* lib); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded and -1 in case lib does not exist; or in case of error. Func_t UnixDynFindSymbol(const char* lib, const char* entry); Finds and returns a function pointer to a symbol in the shared library.; Returns 0 when symbol not found. void UnixDynListSymbols(const char* lib, const char* re = """"); List symbols in a shared library. One can use wildcards to list only; the interesting symbols. void UnixDynListLibs(const char* lib = """"); List all loaded shared libraries. void UnixDynUnload(const char* lib); Unload a shared library. int ReadUtmpFile(); Read utmp file. Returns number of entries in utmp file. void * SearchUtmpEntry(int nentries, const char* tty); Look for utmp entry which is connected to terminal tty. int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Returns cpu load average an",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:43450,Availability,error,error,43450," library; not loaded. int UnixDynLoad(const char* lib); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded and -1 in case lib does not exist; or in case of error. Func_t UnixDynFindSymbol(const char* lib, const char* entry); Finds and returns a function pointer to a symbol in the shared library.; Returns 0 when symbol not found. void UnixDynListSymbols(const char* lib, const char* re = """"); List symbols in a shared library. One can use wildcards to list only; the interesting symbols. void UnixDynListLibs(const char* lib = """"); List all loaded shared libraries. void UnixDynUnload(const char* lib); Unload a shared library. int ReadUtmpFile(); Read utmp file. Returns number of entries in utmp file. void * SearchUtmpEntry(int nentries, const char* tty); Look for utmp entry which is connected to terminal tty. int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Returns cpu load average and load info into the CpuInfo_t structure.; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; interval over which the CPU load will be measured, in ms (default 1000). int GetMemInfo(MemInfo_t* info) const; Returns ram and swap memory usage info into the MemInfo_t structure.; Returns -1 in case of error, 0 otherwise. int GetProcInfo(ProcInfo_t* info) const; Returns cpu and memory used by this process into the ProcInfo_t structure.; Returns -1 in case of error, 0 otherwise. » Author: Fons Rademakers 15/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/unix:$Id: TUnixSystem.h 41630 2011-10-28 14:16:25Z rdm $ » Last generated: 2011-12-02 14:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:43627,Availability,error,error,43627," library; not loaded. int UnixDynLoad(const char* lib); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded and -1 in case lib does not exist; or in case of error. Func_t UnixDynFindSymbol(const char* lib, const char* entry); Finds and returns a function pointer to a symbol in the shared library.; Returns 0 when symbol not found. void UnixDynListSymbols(const char* lib, const char* re = """"); List symbols in a shared library. One can use wildcards to list only; the interesting symbols. void UnixDynListLibs(const char* lib = """"); List all loaded shared libraries. void UnixDynUnload(const char* lib); Unload a shared library. int ReadUtmpFile(); Read utmp file. Returns number of entries in utmp file. void * SearchUtmpEntry(int nentries, const char* tty); Look for utmp entry which is connected to terminal tty. int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Returns cpu load average and load info into the CpuInfo_t structure.; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; interval over which the CPU load will be measured, in ms (default 1000). int GetMemInfo(MemInfo_t* info) const; Returns ram and swap memory usage info into the MemInfo_t structure.; Returns -1 in case of error, 0 otherwise. int GetProcInfo(ProcInfo_t* info) const; Returns cpu and memory used by this process into the ProcInfo_t structure.; Returns -1 in case of error, 0 otherwise. » Author: Fons Rademakers 15/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/unix:$Id: TUnixSystem.h 41630 2011-10-28 14:16:25Z rdm $ » Last generated: 2011-12-02 14:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:43878,Availability,error,error,43878," library; not loaded. int UnixDynLoad(const char* lib); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded and -1 in case lib does not exist; or in case of error. Func_t UnixDynFindSymbol(const char* lib, const char* entry); Finds and returns a function pointer to a symbol in the shared library.; Returns 0 when symbol not found. void UnixDynListSymbols(const char* lib, const char* re = """"); List symbols in a shared library. One can use wildcards to list only; the interesting symbols. void UnixDynListLibs(const char* lib = """"); List all loaded shared libraries. void UnixDynUnload(const char* lib); Unload a shared library. int ReadUtmpFile(); Read utmp file. Returns number of entries in utmp file. void * SearchUtmpEntry(int nentries, const char* tty); Look for utmp entry which is connected to terminal tty. int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Returns cpu load average and load info into the CpuInfo_t structure.; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; interval over which the CPU load will be measured, in ms (default 1000). int GetMemInfo(MemInfo_t* info) const; Returns ram and swap memory usage info into the MemInfo_t structure.; Returns -1 in case of error, 0 otherwise. int GetProcInfo(ProcInfo_t* info) const; Returns cpu and memory used by this process into the ProcInfo_t structure.; Returns -1 in case of error, 0 otherwise. » Author: Fons Rademakers 15/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/unix:$Id: TUnixSystem.h 41630 2011-10-28 14:16:25Z rdm $ » Last generated: 2011-12-02 14:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:44037,Availability,error,error,44037," library; not loaded. int UnixDynLoad(const char* lib); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded and -1 in case lib does not exist; or in case of error. Func_t UnixDynFindSymbol(const char* lib, const char* entry); Finds and returns a function pointer to a symbol in the shared library.; Returns 0 when symbol not found. void UnixDynListSymbols(const char* lib, const char* re = """"); List symbols in a shared library. One can use wildcards to list only; the interesting symbols. void UnixDynListLibs(const char* lib = """"); List all loaded shared libraries. void UnixDynUnload(const char* lib); Unload a shared library. int ReadUtmpFile(); Read utmp file. Returns number of entries in utmp file. void * SearchUtmpEntry(int nentries, const char* tty); Look for utmp entry which is connected to terminal tty. int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Returns cpu load average and load info into the CpuInfo_t structure.; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; interval over which the CPU load will be measured, in ms (default 1000). int GetMemInfo(MemInfo_t* info) const; Returns ram and swap memory usage info into the MemInfo_t structure.; Returns -1 in case of error, 0 otherwise. int GetProcInfo(ProcInfo_t* info) const; Returns cpu and memory used by this process into the ProcInfo_t structure.; Returns -1 in case of error, 0 otherwise. » Author: Fons Rademakers 15/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/unix:$Id: TUnixSystem.h 41630 2011-10-28 14:16:25Z rdm $ » Last generated: 2011-12-02 14:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:326,Integrability,interface,interface,326,". TUnixSystem. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » UNIX; » TUnixSystem. class TUnixSystem: public TSystem. TUnixSystem. Class providing an interface to the UNIX Operating System. Function Members (Methods); public:. TUnixSystem(); virtual~TUnixSystem(); virtual voidAbort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intAcceptConnection(int sock); virtual Bool_tAccessPathName(const char* path, EAccessMode mode = kFileExists); virtual voidAddDynamicPath(const char* lib); virtual voidAddFileHandler(TFileHandler* fh); virtual voidTSystem::AddIncludePath(const char* includePath); virtual voidTSystem::AddLinkedLibs(const char* linkedLib); virtual voidAddSignalHandler(TSignalHandler* sh); virtual voidTSystem::AddStdExceptionHandler(TStdExceptionHandler* eh); virtual voidAddTimer(TTimer* ti); virtual intAnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); virtual intAnnounceUdpService(int port, int backlog); virtual intAnnounceUnixService(int port, int backlog); virtual intAnnounceUnixService(const char* sockpath, int backlog); virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*TSystem::BaseName(const char* pathname); voidTSystem::Beep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); virtual voidTObject::Browse(TBrowser* b); Bool_tTSystem::cd(const char* path); virtual Bool_tChangeDirectory(const char* path); voidCheckChilds(); Bool_tCheckDescriptors(); Bool_tCheckSignals(Bool_t sync); virtual intChmod(const char* file, UInt_t mode); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTSystem::CleanCompiledMacros(); virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidCloseConnection(int sock",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:2448,Integrability,protocol,protocol,2448,", Bool_t setDefault = kFALSE); virtual voidTObject::Browse(TBrowser* b); Bool_tTSystem::cd(const char* path); virtual Bool_tChangeDirectory(const char* path); voidCheckChilds(); Bool_tCheckDescriptors(); Bool_tCheckSignals(Bool_t sync); virtual intChmod(const char* file, UInt_t mode); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTSystem::CleanCompiledMacros(); virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidCloseConnection(int sock, Bool_t force = kFALSE); virtual voidCloselog(); virtual intClosePipe(FILE* pipe); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual intTSystem::CompileMacro(const char* filename, Option_t* opt = """", const char* library_name = """", const char* build_dir = """", UInt_t dirmode = 0); virtual char*TSystem::ConcatFileName(const char* dir, const char* name); intConnectService(const char* server, int port, int tcpwindowsize, const char* protocol = ""tcp""); virtual voidTNamed::Copy(TObject& named) const; virtual intCopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual const char*TSystem::DirName(const char* pathname); virtual voidDispatchOneEvent(Bool_t pendingOnly = kFALSE); voidDispatchSignals(ESignals sig); Bool_tDispatchTimers(Bool_t mode); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual Func_tDynFindSymbol(const char* module, const char* entry); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Int_tExec(const char* shellcmd); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* ",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:9107,Integrability,protocol,protocol,9107,"TObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsPathLocal(const char* path); virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual intLink(const char* from, const char* to); virtual voidListLibraries(const char* regexp = """"); virtual voidListSymbols(const char* module, const char* re = """"); virtual intLoad(const char* module, const char* entry = """", Bool_t system = kFALSE); virtual voidTNamed::ls(Option_t* option = """") const; virtual intMakeDirectory(const char* name); voidTObject::MayNotUse(const char* method) const; virtual intTSystem::mkdir(const char* name, Bool_t recursive = kFALSE); virtual Long_tTSystem::NextTimeOut(Bool_t mode); virtual Bool_tTObject::Notify(); virtual voidTSystem::NotifyApplicationCreated(); virtual TTimeNow(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual intOpenConnection(const char* server, int port, int tcpwindowsize = -1, const char* protocol = ""tcp""); virtual void*OpenDirectory(const char* name); virtual voidOpenlog(const char* name, Int_t options, ELogFacility facility); virtual FILE*OpenPipe(const char* shellcmd, const char* mode); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual const char*PrependPathName(const char* dir, TString& name); virtual voidTNamed::Print(Option_t* option = """") const; virtual Bool_tTSystem::ProcessEvents(); const char*TSystem::pwd(); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObjec",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:18369,Integrability,message,message,18369,"rationUsed by Beep(); Int_tTSystem::fBeepFreqUsed by Beep(); TStringTSystem::fBuildArchArchitecure for which ROOT was built (passed to ./configure); TStringTSystem::fBuildCompilerCompiler used to build this ROOT; TStringTSystem::fBuildCompilerVersionCompiler version used to build this ROOT; TStringTSystem::fBuildDirLocation where to build ACLiC shared library and use as scratch area.; TStringTSystem::fBuildNodeDetailed information where ROOT was built; TSeqCollection*TSystem::fCompiledList of shared libs from compiled macros to be deleted; Bool_tTSystem::fDoneTrue if eventloop should be finished; TSeqCollection*TSystem::fFileHandlerList of file handlers; TStringTSystem::fFlagsDebugFlags for debug compilation; TStringTSystem::fFlagsOptFlags for optimized compilation; TSeqCollection*TSystem::fHelpersList of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); TStringTSystem::fLastErrorStringLast system error message; Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of fd's in masks; TStringTSystem::fObjExtExtension of object fi",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:20180,Integrability,interface,interface,20180,"m::fObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*TSystem::fOnExitListList of items to be cleaned-up on exit; TFdSet*TSystem::fReadmask!Files that should be checked for read events; TFdSet*TSystem::fReadready!Files with reads waiting; Int_tTSystem::fSigcntNumber of pending signals; TSeqCollection*TSystem::fSignalHandlerList of signal handlers; TFdSet*TSystem::fSignals!Signals that were trapped; TStringTSystem::fSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*TSystem::fStdExceptionHandlerList of std::exception handlers; TSeqCollection*TSystem::fTimersList of timers; TStringTNamed::fTitleobject title; TStringTSystem::fWdpathWorking directory; TFdSet*TSystem::fWritemask!Files that should be checked for write events; TFdSet*TSystem::fWriteready!Files with writes waiting. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnixSystem(); { }. ~TUnixSystem(); Reset to original state. Bool_t Init(); Initialize Unix system interface. void SetProgname(const char* name); Set the application name (from command line, argv[0]) and copy it in; gProgName. Copy the application pathname in gProgPath.; If name is 0 let the system set the actual executable name and path; (works on MacOS X and Linux). void SetDisplay(); Set DISPLAY environment variable based on utmp entry. Only for UNIX. const char * GetError(); Return system error string. const char * HostName(); Return the system's host name. void AddFileHandler(TFileHandler* fh); Add a file handler to the list of system file handlers. Only adds; the handler if it is not already in the list of file handlers. TFileHandler * RemoveFileHandler(TFileHandler* fh); Remove a file handler from the list of file handlers. Returns; the handler or 0 if the handler was not in the list of file handlers. void AddSignalHandler(TSignalHandler* sh); Add a signal handler to list of system signal handlers. Only adds; the handler if it is not already in the list of signa",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:26260,Integrability,depend,dependend,26260,"ists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. Returns 0 when successful, -1 in case of failure. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: id, bsize, bfree, blocks.; Id is file system type (machine dependend, see statfs()); Bsize is block size of file system; Blocks is total number of blocks in file system; Bfree is number of free blocks in file system; The function returns 0 in case of success and 1 if the file system could; not be stat'ed. int Link(const char* from, const char* to); Create a link from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Symlink(const char* from, const char* to); Create a symlink from file1 to file2. Returns 0 when succesfull,; -1 in case of failure. int Unlink(const char* name); Unlink, i.e. remove, a file or directory. Returns 0 when succesfull,; -1 in case of failure. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Un",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:30801,Integrability,message,message,30801,"value); Set environment variable. The string passed will be owned by; the environment and can not be reused till a ""name"" is set; again. The solution below will lose the space for the string; in that case, but if this functions is not called thousands; of times that should not be a problem. const char * Getenv(const char* name); Get environment variable. int Exec(const char* shellcmd); Execute a command. FILE * OpenPipe(const char* shellcmd, const char* mode); Open a pipe. int ClosePipe(FILE* pipe); Close the pipe. int GetPid(); Get process id. void Exit(int code, Bool_t mode = kTRUE); Exit the application. void Abort(int code = 0); Abort the application. void StackTrace(); Print a stack trace. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; This function saves internally the current state into a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. Func_t DynFindSymbol(const char* module, const char* entry); dynamic linking of module. int Load(const char* module, const char* entry = """", Bool_t system",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:32808,Integrability,Protocol,Protocol,32808,"t system = kFALSE); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded and -1 in case lib does not exist; or in case of error. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. TTime Now(); Get current time in milliseconds since 0:00 Jan 1 1995. Bool_t DispatchTimers(Bool_t mode); Handle and dispatch timers. If mode = kTRUE dispatch synchronous; timers else a-synchronous timers. void AddTimer(TTimer* ti); Add timer to list of system timers. TTimer * RemoveTimer(TTimer* ti); Remove timer from list of system timers. void ResetTimer(TTimer* ti); Reset a-sync timer. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. Returns an TInetAddress; object. To see if the hostname lookup was successfull call; TInetAddress::IsValid(). TInetAddress GetSockName(int sock); Get Internet Protocol (IP) address of host and port #. TInetAddress GetPeerName(int sock); Get Internet Protocol (IP) address of remote host and port #. int GetServiceByName(const char* service); Get port # of internet service. char * GetServiceByPort(int port); Get name of internet service. int ConnectService(const char* server, int port, int tcpwindowsize, const char* protocol = ""tcp""); Connect to service servicename on server servername. int OpenConnection(const char* server, int port, int tcpwindowsize = -1, const char* protocol = ""tcp""); Open a connection to a service on a server. Returns -1 in case; connection cannot be opened.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:32998,Integrability,Protocol,Protocol,32998,"load a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. TTime Now(); Get current time in milliseconds since 0:00 Jan 1 1995. Bool_t DispatchTimers(Bool_t mode); Handle and dispatch timers. If mode = kTRUE dispatch synchronous; timers else a-synchronous timers. void AddTimer(TTimer* ti); Add timer to list of system timers. TTimer * RemoveTimer(TTimer* ti); Remove timer from list of system timers. void ResetTimer(TTimer* ti); Reset a-sync timer. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. Returns an TInetAddress; object. To see if the hostname lookup was successfull call; TInetAddress::IsValid(). TInetAddress GetSockName(int sock); Get Internet Protocol (IP) address of host and port #. TInetAddress GetPeerName(int sock); Get Internet Protocol (IP) address of remote host and port #. int GetServiceByName(const char* service); Get port # of internet service. char * GetServiceByPort(int port); Get name of internet service. int ConnectService(const char* server, int port, int tcpwindowsize, const char* protocol = ""tcp""); Connect to service servicename on server servername. int OpenConnection(const char* server, int port, int tcpwindowsize = -1, const char* protocol = ""tcp""); Open a connection to a service on a server. Returns -1 in case; connection cannot be opened.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Is called via the TSocket constructor. int AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); Announce TCP/IP service.; Open a s",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:33089,Integrability,Protocol,Protocol,33089,"in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. TTime Now(); Get current time in milliseconds since 0:00 Jan 1 1995. Bool_t DispatchTimers(Bool_t mode); Handle and dispatch timers. If mode = kTRUE dispatch synchronous; timers else a-synchronous timers. void AddTimer(TTimer* ti); Add timer to list of system timers. TTimer * RemoveTimer(TTimer* ti); Remove timer from list of system timers. void ResetTimer(TTimer* ti); Reset a-sync timer. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. Returns an TInetAddress; object. To see if the hostname lookup was successfull call; TInetAddress::IsValid(). TInetAddress GetSockName(int sock); Get Internet Protocol (IP) address of host and port #. TInetAddress GetPeerName(int sock); Get Internet Protocol (IP) address of remote host and port #. int GetServiceByName(const char* service); Get port # of internet service. char * GetServiceByPort(int port); Get name of internet service. int ConnectService(const char* server, int port, int tcpwindowsize, const char* protocol = ""tcp""); Connect to service servicename on server servername. int OpenConnection(const char* server, int port, int tcpwindowsize = -1, const char* protocol = ""tcp""); Open a connection to a service on a server. Returns -1 in case; connection cannot be opened.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Is called via the TSocket constructor. int AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); Announce TCP/IP service.; Open a socket, bind to it and start listening for TCP/IP connections; on the port. If reuse is true re",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:33358,Integrability,protocol,protocol,33358,". TTime Now(); Get current time in milliseconds since 0:00 Jan 1 1995. Bool_t DispatchTimers(Bool_t mode); Handle and dispatch timers. If mode = kTRUE dispatch synchronous; timers else a-synchronous timers. void AddTimer(TTimer* ti); Add timer to list of system timers. TTimer * RemoveTimer(TTimer* ti); Remove timer from list of system timers. void ResetTimer(TTimer* ti); Reset a-sync timer. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. Returns an TInetAddress; object. To see if the hostname lookup was successfull call; TInetAddress::IsValid(). TInetAddress GetSockName(int sock); Get Internet Protocol (IP) address of host and port #. TInetAddress GetPeerName(int sock); Get Internet Protocol (IP) address of remote host and port #. int GetServiceByName(const char* service); Get port # of internet service. char * GetServiceByPort(int port); Get name of internet service. int ConnectService(const char* server, int port, int tcpwindowsize, const char* protocol = ""tcp""); Connect to service servicename on server servername. int OpenConnection(const char* server, int port, int tcpwindowsize = -1, const char* protocol = ""tcp""); Open a connection to a service on a server. Returns -1 in case; connection cannot be opened.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Is called via the TSocket constructor. int AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); Announce TCP/IP service.; Open a socket, bind to it and start listening for TCP/IP connections; on the port. If reuse is true reuse the address, backlog specifies; how many sockets can be waiting to be accepted.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms s",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:33515,Integrability,protocol,protocol,33515," dispatch synchronous; timers else a-synchronous timers. void AddTimer(TTimer* ti); Add timer to list of system timers. TTimer * RemoveTimer(TTimer* ti); Remove timer from list of system timers. void ResetTimer(TTimer* ti); Reset a-sync timer. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. Returns an TInetAddress; object. To see if the hostname lookup was successfull call; TInetAddress::IsValid(). TInetAddress GetSockName(int sock); Get Internet Protocol (IP) address of host and port #. TInetAddress GetPeerName(int sock); Get Internet Protocol (IP) address of remote host and port #. int GetServiceByName(const char* service); Get port # of internet service. char * GetServiceByPort(int port); Get name of internet service. int ConnectService(const char* server, int port, int tcpwindowsize, const char* protocol = ""tcp""); Connect to service servicename on server servername. int OpenConnection(const char* server, int port, int tcpwindowsize = -1, const char* protocol = ""tcp""); Open a connection to a service on a server. Returns -1 in case; connection cannot be opened.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Is called via the TSocket constructor. int AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); Announce TCP/IP service.; Open a socket, bind to it and start listening for TCP/IP connections; on the port. If reuse is true reuse the address, backlog specifies; how many sockets can be waiting to be accepted.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Returns socket fd or -1 if socket() failed, -2 if bind() failed; or -3 if listen() failed. int AnnounceUdpService(int port",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:38666,Integrability,depend,dependend,38666,"EINTR; the errno has been reset and the method can be called again. const char * UnixHomedirectory(const char* user = 0); Returns the user's home directory. int UnixMakedir(const char* name); Make a Unix file system directory. Returns 0 in case of success and; -1 if the directory could not be created (either already exists or; illegal path name). void * UnixOpendir(const char* name); Open a directory. const char * UnixGetdirentry(void* dir); Returns the next directory entry. int UnixFilestat(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int UnixFSstat(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: id, bsize, bfree, blocks.; Id is file system type (machine dependend, see statfs()); Bsize is block size of file system; Blocks is total number of blocks in file system; Bfree is number of free blocks in file system; The function returns 0 in case of success and 1 if the file system could; not be stat'ed. int UnixWaitchild(); Wait till child is finished. int UnixTcpConnect(const char* hostname, int port, int tcpwindowsize); Open a TCP/IP connection to server and connect to a service (i.e. port).; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Is called via the TSocket constructor. Returns -1 in case of error. int UnixUdpConnect(const char* hostname, int port); Creates a UDP socket connection; Is called via the TSocket constructor. Returns -1 in case of error. int UnixUnixConnect(int port); Connect to a Unix domain socket. int UnixUnixConnect(const char* path); Connect to a Unix domain socket. Returns -1 in case of error. int UnixTcpService(int port, Bool_t reuse, int backlog, int tcpwindows",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:7631,Modifiability,Inherit,InheritsFrom,7631,"tual intGetServiceByName(const char* service); virtual char*GetServiceByPort(int port); virtual TInetAddressGetSockName(int sock); virtual intGetSockOpt(int sock, int option, int* val); virtual const char*TSystem::GetSoExt() const; virtual intGetSysInfo(SysInfo_t* info) const; virtual const char*TNamed::GetTitle() const; virtual Int_tGetUid(const char* user = 0); virtual UInt_tTObject::GetUniqueID() const; virtual UserGroup_t*GetUserInfo(Int_t uid); virtual UserGroup_t*GetUserInfo(const char* user = 0); virtual TList*TSystem::GetVolumes(Option_t*) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual const char*HomeDirectory(const char* userName = 0); virtual const char*HostName(); virtual voidTSystem::IgnoreInterrupt(Bool_t ignore = kTRUE); virtual voidIgnoreSignal(ESignals sig, Bool_t ignore = kTRUE); Bool_tTSystem::InControl() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual Bool_tInit(); virtual voidTSystem::InnerLoop(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTSystem::IsAbsoluteFileName(const char* dir); virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTSystem::IsFileInIncludePath(const char* name, char** fullpath = 0); virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsPathLocal(const char* path); virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual intLink(const char* from, const char* to); virtual voidListLibraries(const char* regexp = """"); virtual voidListSymbols(const char* module, const char* re = """"); virtual intLoad(const char* module, const char* entry = """", Bool_t system = kFALSE); virtual voidTNamed::ls(Option_t* option = """") const; virtual intMakeDirectory(const char* nam",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:7697,Modifiability,Inherit,InheritsFrom,7697,"viceByPort(int port); virtual TInetAddressGetSockName(int sock); virtual intGetSockOpt(int sock, int option, int* val); virtual const char*TSystem::GetSoExt() const; virtual intGetSysInfo(SysInfo_t* info) const; virtual const char*TNamed::GetTitle() const; virtual Int_tGetUid(const char* user = 0); virtual UInt_tTObject::GetUniqueID() const; virtual UserGroup_t*GetUserInfo(Int_t uid); virtual UserGroup_t*GetUserInfo(const char* user = 0); virtual TList*TSystem::GetVolumes(Option_t*) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual const char*HomeDirectory(const char* userName = 0); virtual const char*HostName(); virtual voidTSystem::IgnoreInterrupt(Bool_t ignore = kTRUE); virtual voidIgnoreSignal(ESignals sig, Bool_t ignore = kTRUE); Bool_tTSystem::InControl() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual Bool_tInit(); virtual voidTSystem::InnerLoop(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTSystem::IsAbsoluteFileName(const char* dir); virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTSystem::IsFileInIncludePath(const char* name, char** fullpath = 0); virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsPathLocal(const char* path); virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual intLink(const char* from, const char* to); virtual voidListLibraries(const char* regexp = """"); virtual voidListSymbols(const char* module, const char* re = """"); virtual intLoad(const char* module, const char* entry = """", Bool_t system = kFALSE); virtual voidTNamed::ls(Option_t* option = """") const; virtual intMakeDirectory(const char* name); voidTObject::MayNotUse(const char* method) const; virtual intT",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:17333,Modifiability,config,configure,17333,"har* path); static intUnixUnixService(int port, int backlog); static intUnixUnixService(const char* sockpath, int backlog); static intUnixWaitchild(). Data Members; public:. enum TSystem::EAclicMode { kDefault; kDebug; kOpt; };; enum TSystem::EAclicProperties { kFlatBuildDir; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TSystem::EAclicModeTSystem::fAclicModeWhether the compilation should be done debug or opt; Int_tTSystem::fAclicPropertiesVarious boolean flag for change ACLiC's behavior.; Int_tTSystem::fBeepDurationUsed by Beep(); Int_tTSystem::fBeepFreqUsed by Beep(); TStringTSystem::fBuildArchArchitecure for which ROOT was built (passed to ./configure); TStringTSystem::fBuildCompilerCompiler used to build this ROOT; TStringTSystem::fBuildCompilerVersionCompiler version used to build this ROOT; TStringTSystem::fBuildDirLocation where to build ACLiC shared library and use as scratch area.; TStringTSystem::fBuildNodeDetailed information where ROOT was built; TSeqCollection*TSystem::fCompiledList of shared libs from compiled macros to be deleted; Bool_tTSystem::fDoneTrue if eventloop should be finished; TSeqCollection*TSystem::fFileHandlerList of file handlers; TStringTSystem::fFlagsDebugFlags for debug compilation; TStringTSystem::fFlagsOptFlags for optimized compilation; TSeqCollection*TSystem::fHelpersList of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); TStringTSystem::fLastErrorStringLast system error message; Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixD",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:20004,Modifiability,Inherit,Inheritance,20004,"System::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of fd's in masks; TStringTSystem::fObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*TSystem::fOnExitListList of items to be cleaned-up on exit; TFdSet*TSystem::fReadmask!Files that should be checked for read events; TFdSet*TSystem::fReadready!Files with reads waiting; Int_tTSystem::fSigcntNumber of pending signals; TSeqCollection*TSystem::fSignalHandlerList of signal handlers; TFdSet*TSystem::fSignals!Signals that were trapped; TStringTSystem::fSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*TSystem::fStdExceptionHandlerList of std::exception handlers; TSeqCollection*TSystem::fTimersList of timers; TStringTNamed::fTitleobject title; TStringTSystem::fWdpathWorking directory; TFdSet*TSystem::fWritemask!Files that should be checked for write events; TFdSet*TSystem::fWriteready!Files with writes waiting. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnixSystem(); { }. ~TUnixSystem(); Reset to original state. Bool_t Init(); Initialize Unix system interface. void SetProgname(const char* name); Set the application name (from command line, argv[0]) and copy it in; gProgName. Copy the application pathname in gProgPath.; If name is 0 let the system set the actual executable name and path; (works on MacOS X and Linux). void SetDisplay(); Set DISPLAY environment variable based on utmp entry. Only for UNIX. const char * GetError(); Return system error string. const char * HostName(); Return the system's host name. void AddFileHandler(TFileHandler* fh); Add a file handler to the list of system file handlers. Only adds; the handler if it is not already in the list of file handlers. TFileHandler * RemoveFileHandler(TFileHandler* fh); Remove a file handler from the list of file handlers. Returns; the handler or 0 if the handler was not in the list of file handlers. void AddSignalHandler(TSign",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:20017,Modifiability,Inherit,Inherited,20017,"System::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of fd's in masks; TStringTSystem::fObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*TSystem::fOnExitListList of items to be cleaned-up on exit; TFdSet*TSystem::fReadmask!Files that should be checked for read events; TFdSet*TSystem::fReadready!Files with reads waiting; Int_tTSystem::fSigcntNumber of pending signals; TSeqCollection*TSystem::fSignalHandlerList of signal handlers; TFdSet*TSystem::fSignals!Signals that were trapped; TStringTSystem::fSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*TSystem::fStdExceptionHandlerList of std::exception handlers; TSeqCollection*TSystem::fTimersList of timers; TStringTNamed::fTitleobject title; TStringTSystem::fWdpathWorking directory; TFdSet*TSystem::fWritemask!Files that should be checked for write events; TFdSet*TSystem::fWriteready!Files with writes waiting. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnixSystem(); { }. ~TUnixSystem(); Reset to original state. Bool_t Init(); Initialize Unix system interface. void SetProgname(const char* name); Set the application name (from command line, argv[0]) and copy it in; gProgName. Copy the application pathname in gProgPath.; If name is 0 let the system set the actual executable name and path; (works on MacOS X and Linux). void SetDisplay(); Set DISPLAY environment variable based on utmp entry. Only for UNIX. const char * GetError(); Return system error string. const char * HostName(); Return the system's host name. void AddFileHandler(TFileHandler* fh); Add a file handler to the list of system file handlers. Only adds; the handler if it is not already in the list of file handlers. TFileHandler * RemoveFileHandler(TFileHandler* fh); Remove a file handler from the list of file handlers. Returns; the handler or 0 if the handler was not in the list of file handlers. void AddSignalHandler(TSign",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:20495,Modifiability,variab,variable,20495,"em::fSignalHandlerList of signal handlers; TFdSet*TSystem::fSignals!Signals that were trapped; TStringTSystem::fSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*TSystem::fStdExceptionHandlerList of std::exception handlers; TSeqCollection*TSystem::fTimersList of timers; TStringTNamed::fTitleobject title; TStringTSystem::fWdpathWorking directory; TFdSet*TSystem::fWritemask!Files that should be checked for write events; TFdSet*TSystem::fWriteready!Files with writes waiting. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnixSystem(); { }. ~TUnixSystem(); Reset to original state. Bool_t Init(); Initialize Unix system interface. void SetProgname(const char* name); Set the application name (from command line, argv[0]) and copy it in; gProgName. Copy the application pathname in gProgPath.; If name is 0 let the system set the actual executable name and path; (works on MacOS X and Linux). void SetDisplay(); Set DISPLAY environment variable based on utmp entry. Only for UNIX. const char * GetError(); Return system error string. const char * HostName(); Return the system's host name. void AddFileHandler(TFileHandler* fh); Add a file handler to the list of system file handlers. Only adds; the handler if it is not already in the list of file handlers. TFileHandler * RemoveFileHandler(TFileHandler* fh); Remove a file handler from the list of file handlers. Returns; the handler or 0 if the handler was not in the list of file handlers. void AddSignalHandler(TSignalHandler* sh); Add a signal handler to list of system signal handlers. Only adds; the handler if it is not already in the list of signal handlers. TSignalHandler * RemoveSignalHandler(TSignalHandler* sh); Remove a signal handler from list of signal handlers. Returns; the handler or 0 if the handler was not in the list of signal handlers. void ResetSignal(ESignals sig, Bool_t reset = kTRUE); If reset is true reset the signal handler for the specified sig",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:24416,Modifiability,config,configured,24416,"Bool_t sync); Check if some signals were raised and call their Notify() member. void CheckChilds(); Check if childs have finished. Bool_t CheckDescriptors(); Check if there is activity on some file descriptors and call their; Notify() member. int MakeDirectory(const char* name); Make a Unix file system directory. Returns 0 in case of success and; -1 if the directory could not be created. void * OpenDirectory(const char* name); Open a Unix file system directory. Returns 0 if directory does not exist. void FreeDirectory(void* dirp); Close a Unix file system directory. const char * GetDirEntry(void* dirp); Get next Unix file system directory entry. Returns 0 if no more entries. Bool_t ChangeDirectory(const char* path); Change directory. Returns kTRUE in case of success, kFALSE otherwise. const char * WorkingDirectory(); Return working directory. const char * HomeDirectory(const char* userName = 0); Return the user's home directory. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when succes",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:27091,Modifiability,variab,variables,27091,"; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: id, bsize, bfree, blocks.; Id is file system type (machine dependend, see statfs()); Bsize is block size of file system; Blocks is total number of blocks in file system; Bfree is number of free blocks in file system; The function returns 0 in case of success and 1 if the file system could; not be stat'ed. int Link(const char* from, const char* to); Create a link from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Symlink(const char* from, const char* to); Create a symlink from file1 to file2. Returns 0 when succesfull,; -1 in case of failure. int Unlink(const char* name); Unlink, i.e. remove, a file or directory. Returns 0 when succesfull,; -1 in case of failure. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Fi",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:27441,Modifiability,variab,variables,27441,"stem; The function returns 0 in case of success and 1 if the file system could; not be stat'ed. int Link(const char* from, const char* to); Create a link from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Symlink(const char* from, const char* to); Create a symlink from file1 to file2. Returns 0 when succesfull,; -1 in case of failure. int Unlink(const char* name); Unlink, i.e. remove, a file or directory. Returns 0 when succesfull,; -1 in case of failure. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file ""wfil"" in a search path.; The search path is specified as a : separated list of directories.; Return value is pointing to wfile for compatibility with; Which(const char*,const char*,EAccessMode) version. Int_t GetUid(const char* user = 0); Returns the user's id. If user = 0, returns current user's id. Int_t GetEffectiveUid(); Re",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:29824,Modifiability,variab,variable,29824,"d); Returns all user info in the UserGroup_t structure. The returned; structure must be deleted by the user. In case of error 0 is returned. UserGroup_t * GetUserInfo(const char* user = 0); Returns all user info in the UserGroup_t structure. If user = 0, returns; current user's id info. The returned structure must be deleted by the; user. In case of error 0 is returned. UserGroup_t * GetGroupInfo(Int_t gid); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; The returned structure must be deleted by the user. In case of; error 0 is returned. UserGroup_t * GetGroupInfo(const char* group = 0); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. The string passed will be owned by; the environment and can not be reused till a ""name"" is set; again. The solution below will lose the space for the string; in that case, but if this functions is not called thousands; of times that should not be a problem. const char * Getenv(const char* name); Get environment variable. int Exec(const char* shellcmd); Execute a command. FILE * OpenPipe(const char* shellcmd, const char* mode); Open a pipe. int ClosePipe(FILE* pipe); Close the pipe. int GetPid(); Get process id. void Exit(int code, Bool_t mode = kTRUE); Exit the application. void Abort(int code = 0); Abort the application. void StackTrace(); Print a stack trace. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:30147,Modifiability,variab,variable,30147,"y the; user. In case of error 0 is returned. UserGroup_t * GetGroupInfo(Int_t gid); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; The returned structure must be deleted by the user. In case of; error 0 is returned. UserGroup_t * GetGroupInfo(const char* group = 0); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. The string passed will be owned by; the environment and can not be reused till a ""name"" is set; again. The solution below will lose the space for the string; in that case, but if this functions is not called thousands; of times that should not be a problem. const char * Getenv(const char* name); Get environment variable. int Exec(const char* shellcmd); Execute a command. FILE * OpenPipe(const char* shellcmd, const char* mode); Open a pipe. int ClosePipe(FILE* pipe); Close the pipe. int GetPid(); Get process id. void Exit(int code, Bool_t mode = kTRUE); Exit the application. void Abort(int code = 0); Abort the application. void StackTrace(); Print a stack trace. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; T",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:17950,Performance,optimiz,optimized,17950,"rationUsed by Beep(); Int_tTSystem::fBeepFreqUsed by Beep(); TStringTSystem::fBuildArchArchitecure for which ROOT was built (passed to ./configure); TStringTSystem::fBuildCompilerCompiler used to build this ROOT; TStringTSystem::fBuildCompilerVersionCompiler version used to build this ROOT; TStringTSystem::fBuildDirLocation where to build ACLiC shared library and use as scratch area.; TStringTSystem::fBuildNodeDetailed information where ROOT was built; TSeqCollection*TSystem::fCompiledList of shared libs from compiled macros to be deleted; Bool_tTSystem::fDoneTrue if eventloop should be finished; TSeqCollection*TSystem::fFileHandlerList of file handlers; TStringTSystem::fFlagsDebugFlags for debug compilation; TStringTSystem::fFlagsOptFlags for optimized compilation; TSeqCollection*TSystem::fHelpersList of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); TStringTSystem::fLastErrorStringLast system error message; Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of fd's in masks; TStringTSystem::fObjExtExtension of object fi",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:18695,Performance,cache,cache,18695,"rationUsed by Beep(); Int_tTSystem::fBeepFreqUsed by Beep(); TStringTSystem::fBuildArchArchitecure for which ROOT was built (passed to ./configure); TStringTSystem::fBuildCompilerCompiler used to build this ROOT; TStringTSystem::fBuildCompilerVersionCompiler version used to build this ROOT; TStringTSystem::fBuildDirLocation where to build ACLiC shared library and use as scratch area.; TStringTSystem::fBuildNodeDetailed information where ROOT was built; TSeqCollection*TSystem::fCompiledList of shared libs from compiled macros to be deleted; Bool_tTSystem::fDoneTrue if eventloop should be finished; TSeqCollection*TSystem::fFileHandlerList of file handlers; TStringTSystem::fFlagsDebugFlags for debug compilation; TStringTSystem::fFlagsOptFlags for optimized compilation; TSeqCollection*TSystem::fHelpersList of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); TStringTSystem::fLastErrorStringLast system error message; Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of fd's in masks; TStringTSystem::fObjExtExtension of object fi",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:18812,Performance,Cache,Cache,18812,"st of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); TStringTSystem::fLastErrorStringLast system error message; Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of fd's in masks; TStringTSystem::fObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*TSystem::fOnExitListList of items to be cleaned-up on exit; TFdSet*TSystem::fReadmask!Files that should be checked for read events; TFdSet*TSystem::fReadready!Files with reads waiting; Int_tTSystem::fSigcntNumber of pending signals; TSeqCollection*TSystem::fSignalHandlerList of signal handlers; TFdSet*TSystem::fSignals!Signals that were trapped; TStringTSystem::fSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*TSystem::fStdExceptionHandlerList of std::exception handlers; TSeqCollection*TSystem::fTimersList of timers; TStringTNamed::fTitleobject title; TStringTSystem::fWdpathWorking directory; TFdSet*TSystem::fWritemask!Files that should be checked for write events; TFdSet*TSystem::fWriteready!Files with writes waiting. Class Charts. Inh",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:31738,Performance,Load,Load,31738,"vel and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; This function saves internally the current state into a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. Func_t DynFindSymbol(const char* module, const char* entry); dynamic linking of module. int Load(const char* module, const char* entry = """", Bool_t system = kFALSE); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded and -1 in case lib does not exist; or in case of error. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. TTime Now(); Get current time in milliseconds since 0:00 Jan 1 1995. Bool_t DispatchTimers(Bool_t mode); Handle and dispatch timers. If mode = kTRUE dispatch synchronous; timers else a-synchronous timers. void AddTimer(TTimer* ti); Add timer to list of system timers. TTimer * RemoveTimer(TTimer* ti); Remove timer from list of system timers. void ResetTimer(TTimer* ti); Reset a-sync timer. TInetAddress GetHostByName(const char",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:31812,Performance,Load,Load,31812,"vel and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; This function saves internally the current state into a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. Func_t DynFindSymbol(const char* module, const char* entry); dynamic linking of module. int Load(const char* module, const char* entry = """", Bool_t system = kFALSE); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded and -1 in case lib does not exist; or in case of error. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. TTime Now(); Get current time in milliseconds since 0:00 Jan 1 1995. Bool_t DispatchTimers(Bool_t mode); Handle and dispatch timers. If mode = kTRUE dispatch synchronous; timers else a-synchronous timers. void AddTimer(TTimer* ti); Add timer to list of system timers. TTimer * RemoveTimer(TTimer* ti); Remove timer from list of system timers. void ResetTimer(TTimer* ti); Reset a-sync timer. TInetAddress GetHostByName(const char",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:31859,Performance,load,loading,31859,"n. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; This function saves internally the current state into a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. Func_t DynFindSymbol(const char* module, const char* entry); dynamic linking of module. int Load(const char* module, const char* entry = """", Bool_t system = kFALSE); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded and -1 in case lib does not exist; or in case of error. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. TTime Now(); Get current time in milliseconds since 0:00 Jan 1 1995. Bool_t DispatchTimers(Bool_t mode); Handle and dispatch timers. If mode = kTRUE dispatch synchronous; timers else a-synchronous timers. void AddTimer(TTimer* ti); Add timer to list of system timers. TTimer * RemoveTimer(TTimer* ti); Remove timer from list of system timers. void ResetTimer(TTimer* ti); Reset a-sync timer. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. Returns an TInetAddress; object. To see if the hostname l",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:31895,Performance,load,loaded,31895,"n. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; This function saves internally the current state into a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. Func_t DynFindSymbol(const char* module, const char* entry); dynamic linking of module. int Load(const char* module, const char* entry = """", Bool_t system = kFALSE); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded and -1 in case lib does not exist; or in case of error. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. TTime Now(); Get current time in milliseconds since 0:00 Jan 1 1995. Bool_t DispatchTimers(Bool_t mode); Handle and dispatch timers. If mode = kTRUE dispatch synchronous; timers else a-synchronous timers. void AddTimer(TTimer* ti); Add timer to list of system timers. TTimer * RemoveTimer(TTimer* ti); Remove timer from list of system timers. void ResetTimer(TTimer* ti); Reset a-sync timer. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. Returns an TInetAddress; object. To see if the hostname l",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:32163,Performance,load,loaded,32163,"ifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; This function saves internally the current state into a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. Func_t DynFindSymbol(const char* module, const char* entry); dynamic linking of module. int Load(const char* module, const char* entry = """", Bool_t system = kFALSE); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded and -1 in case lib does not exist; or in case of error. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. TTime Now(); Get current time in milliseconds since 0:00 Jan 1 1995. Bool_t DispatchTimers(Bool_t mode); Handle and dispatch timers. If mode = kTRUE dispatch synchronous; timers else a-synchronous timers. void AddTimer(TTimer* ti); Add timer to list of system timers. TTimer * RemoveTimer(TTimer* ti); Remove timer from list of system timers. void ResetTimer(TTimer* ti); Reset a-sync timer. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. Returns an TInetAddress; object. To see if the hostname lookup was successfull call; TInetAddress::IsValid(). TInetAddress GetSockName(int sock); Get Internet Protocol (IP) address of host and port #. TInetAddress GetPeerName(int sock); Get Internet Protocol (IP) address of remote host and port #. int GetSer",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:32252,Performance,load,loaded,32252,"ed before (""w"").; This function saves internally the current state into a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. Func_t DynFindSymbol(const char* module, const char* entry); dynamic linking of module. int Load(const char* module, const char* entry = """", Bool_t system = kFALSE); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded and -1 in case lib does not exist; or in case of error. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. TTime Now(); Get current time in milliseconds since 0:00 Jan 1 1995. Bool_t DispatchTimers(Bool_t mode); Handle and dispatch timers. If mode = kTRUE dispatch synchronous; timers else a-synchronous timers. void AddTimer(TTimer* ti); Add timer to list of system timers. TTimer * RemoveTimer(TTimer* ti); Remove timer from list of system timers. void ResetTimer(TTimer* ti); Reset a-sync timer. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. Returns an TInetAddress; object. To see if the hostname lookup was successfull call; TInetAddress::IsValid(). TInetAddress GetSockName(int sock); Get Internet Protocol (IP) address of host and port #. TInetAddress GetPeerName(int sock); Get Internet Protocol (IP) address of remote host and port #. int GetServiceByName(const char* service); Get port # of internet service. char * GetServiceByPort(in",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:42385,Performance,load,loaded,42385,"ns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). int UnixSend(int sock, const void* buf, int len, int flag); Send exactly length bytes from buffer. Returns -1 in case of error,; otherwise number of sent bytes. Returns -4 in case of kNoBlock and; errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer; (EPIPE || ECONNRESET). void AddDynamicPath(const char* lib); Add a new directory to the dynamic path. const char * GetDynamicPath(); Return the dynamic path (used to find shared libraries). void SetDynamicPath(const char* lib); Set the dynamic path to a new value.; If the value of 'path' is zero, the dynamic path is reset to its; default value. char * DynamicPathName(const char* lib, Bool_t quiet = kFALSE); Returns the path of a shared library (searches for library in the; shared library search path). If no file name extension is provided; it first tries .so, .sl, .dl and then .a (for AIX). The returned string; must be deleted. void * FindDynLib(const char* lib); Returns the handle to a loaded shared library. Returns 0 when library; not loaded. int UnixDynLoad(const char* lib); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded and -1 in case lib does not exist; or in case of error. Func_t UnixDynFindSymbol(const char* lib, const char* entry); Finds and returns a function pointer to a symbol in the shared library.; Returns 0 when symbol not found. void UnixDynListSymbols(const char* lib, const char* re = """"); List symbols in a shared library. One can use wildcards to list only; the interesting symbols. void UnixDynListLibs(const char* lib = """"); List all loaded shared libraries. void UnixDynUnload(const char* lib); Unload a shared library. int ReadUtmpFile(); Read utmp file. Returns number of entries in utmp file. void * SearchUtmpEntry(int nentries, const char* tty); Look for utmp entry which is connected to terminal tty. int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:42436,Performance,load,loaded,42436," int UnixSend(int sock, const void* buf, int len, int flag); Send exactly length bytes from buffer. Returns -1 in case of error,; otherwise number of sent bytes. Returns -4 in case of kNoBlock and; errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer; (EPIPE || ECONNRESET). void AddDynamicPath(const char* lib); Add a new directory to the dynamic path. const char * GetDynamicPath(); Return the dynamic path (used to find shared libraries). void SetDynamicPath(const char* lib); Set the dynamic path to a new value.; If the value of 'path' is zero, the dynamic path is reset to its; default value. char * DynamicPathName(const char* lib, Bool_t quiet = kFALSE); Returns the path of a shared library (searches for library in the; shared library search path). If no file name extension is provided; it first tries .so, .sl, .dl and then .a (for AIX). The returned string; must be deleted. void * FindDynLib(const char* lib); Returns the handle to a loaded shared library. Returns 0 when library; not loaded. int UnixDynLoad(const char* lib); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded and -1 in case lib does not exist; or in case of error. Func_t UnixDynFindSymbol(const char* lib, const char* entry); Finds and returns a function pointer to a symbol in the shared library.; Returns 0 when symbol not found. void UnixDynListSymbols(const char* lib, const char* re = """"); List symbols in a shared library. One can use wildcards to list only; the interesting symbols. void UnixDynListLibs(const char* lib = """"); List all loaded shared libraries. void UnixDynUnload(const char* lib); Unload a shared library. int ReadUtmpFile(); Read utmp file. Returns number of entries in utmp file. void * SearchUtmpEntry(int nentries, const char* tty); Look for utmp entry which is connected to terminal tty. int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structur",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:42478,Performance,Load,Load,42478,"en, int flag); Send exactly length bytes from buffer. Returns -1 in case of error,; otherwise number of sent bytes. Returns -4 in case of kNoBlock and; errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer; (EPIPE || ECONNRESET). void AddDynamicPath(const char* lib); Add a new directory to the dynamic path. const char * GetDynamicPath(); Return the dynamic path (used to find shared libraries). void SetDynamicPath(const char* lib); Set the dynamic path to a new value.; If the value of 'path' is zero, the dynamic path is reset to its; default value. char * DynamicPathName(const char* lib, Bool_t quiet = kFALSE); Returns the path of a shared library (searches for library in the; shared library search path). If no file name extension is provided; it first tries .so, .sl, .dl and then .a (for AIX). The returned string; must be deleted. void * FindDynLib(const char* lib); Returns the handle to a loaded shared library. Returns 0 when library; not loaded. int UnixDynLoad(const char* lib); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded and -1 in case lib does not exist; or in case of error. Func_t UnixDynFindSymbol(const char* lib, const char* entry); Finds and returns a function pointer to a symbol in the shared library.; Returns 0 when symbol not found. void UnixDynListSymbols(const char* lib, const char* re = """"); List symbols in a shared library. One can use wildcards to list only; the interesting symbols. void UnixDynListLibs(const char* lib = """"); List all loaded shared libraries. void UnixDynUnload(const char* lib); Unload a shared library. int ReadUtmpFile(); Read utmp file. Returns number of entries in utmp file. void * SearchUtmpEntry(int nentries, const char* tty); Look for utmp entry which is connected to terminal tty. int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. i",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:42525,Performance,load,loading,42525,"ise number of sent bytes. Returns -4 in case of kNoBlock and; errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer; (EPIPE || ECONNRESET). void AddDynamicPath(const char* lib); Add a new directory to the dynamic path. const char * GetDynamicPath(); Return the dynamic path (used to find shared libraries). void SetDynamicPath(const char* lib); Set the dynamic path to a new value.; If the value of 'path' is zero, the dynamic path is reset to its; default value. char * DynamicPathName(const char* lib, Bool_t quiet = kFALSE); Returns the path of a shared library (searches for library in the; shared library search path). If no file name extension is provided; it first tries .so, .sl, .dl and then .a (for AIX). The returned string; must be deleted. void * FindDynLib(const char* lib); Returns the handle to a loaded shared library. Returns 0 when library; not loaded. int UnixDynLoad(const char* lib); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded and -1 in case lib does not exist; or in case of error. Func_t UnixDynFindSymbol(const char* lib, const char* entry); Finds and returns a function pointer to a symbol in the shared library.; Returns 0 when symbol not found. void UnixDynListSymbols(const char* lib, const char* re = """"); List symbols in a shared library. One can use wildcards to list only; the interesting symbols. void UnixDynListLibs(const char* lib = """"); List all loaded shared libraries. void UnixDynUnload(const char* lib); Unload a shared library. int ReadUtmpFile(); Read utmp file. Returns number of entries in utmp file. void * SearchUtmpEntry(int nentries, const char* tty); Look for utmp entry which is connected to terminal tty. int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Returns cpu load average an",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:42561,Performance,load,loaded,42561,"ise number of sent bytes. Returns -4 in case of kNoBlock and; errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer; (EPIPE || ECONNRESET). void AddDynamicPath(const char* lib); Add a new directory to the dynamic path. const char * GetDynamicPath(); Return the dynamic path (used to find shared libraries). void SetDynamicPath(const char* lib); Set the dynamic path to a new value.; If the value of 'path' is zero, the dynamic path is reset to its; default value. char * DynamicPathName(const char* lib, Bool_t quiet = kFALSE); Returns the path of a shared library (searches for library in the; shared library search path). If no file name extension is provided; it first tries .so, .sl, .dl and then .a (for AIX). The returned string; must be deleted. void * FindDynLib(const char* lib); Returns the handle to a loaded shared library. Returns 0 when library; not loaded. int UnixDynLoad(const char* lib); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded and -1 in case lib does not exist; or in case of error. Func_t UnixDynFindSymbol(const char* lib, const char* entry); Finds and returns a function pointer to a symbol in the shared library.; Returns 0 when symbol not found. void UnixDynListSymbols(const char* lib, const char* re = """"); List symbols in a shared library. One can use wildcards to list only; the interesting symbols. void UnixDynListLibs(const char* lib = """"); List all loaded shared libraries. void UnixDynUnload(const char* lib); Unload a shared library. int ReadUtmpFile(); Read utmp file. Returns number of entries in utmp file. void * SearchUtmpEntry(int nentries, const char* tty); Look for utmp entry which is connected to terminal tty. int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Returns cpu load average an",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:43003,Performance,load,loaded,43003,"he dynamic path is reset to its; default value. char * DynamicPathName(const char* lib, Bool_t quiet = kFALSE); Returns the path of a shared library (searches for library in the; shared library search path). If no file name extension is provided; it first tries .so, .sl, .dl and then .a (for AIX). The returned string; must be deleted. void * FindDynLib(const char* lib); Returns the handle to a loaded shared library. Returns 0 when library; not loaded. int UnixDynLoad(const char* lib); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded and -1 in case lib does not exist; or in case of error. Func_t UnixDynFindSymbol(const char* lib, const char* entry); Finds and returns a function pointer to a symbol in the shared library.; Returns 0 when symbol not found. void UnixDynListSymbols(const char* lib, const char* re = """"); List symbols in a shared library. One can use wildcards to list only; the interesting symbols. void UnixDynListLibs(const char* lib = """"); List all loaded shared libraries. void UnixDynUnload(const char* lib); Unload a shared library. int ReadUtmpFile(); Read utmp file. Returns number of entries in utmp file. void * SearchUtmpEntry(int nentries, const char* tty); Look for utmp entry which is connected to terminal tty. int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Returns cpu load average and load info into the CpuInfo_t structure.; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; interval over which the CPU load will be measured, in ms (default 1000). int GetMemInfo(MemInfo_t* info) const; Returns ram and swap memory usage info into the MemInfo_t structure.; Returns -1 in case of error, 0 otherwise. int GetProcInfo(ProcInfo_t* info) const; Returns cpu and memory used by this process into ",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:43547,Performance,load,load,43547," library; not loaded. int UnixDynLoad(const char* lib); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded and -1 in case lib does not exist; or in case of error. Func_t UnixDynFindSymbol(const char* lib, const char* entry); Finds and returns a function pointer to a symbol in the shared library.; Returns 0 when symbol not found. void UnixDynListSymbols(const char* lib, const char* re = """"); List symbols in a shared library. One can use wildcards to list only; the interesting symbols. void UnixDynListLibs(const char* lib = """"); List all loaded shared libraries. void UnixDynUnload(const char* lib); Unload a shared library. int ReadUtmpFile(); Read utmp file. Returns number of entries in utmp file. void * SearchUtmpEntry(int nentries, const char* tty); Look for utmp entry which is connected to terminal tty. int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Returns cpu load average and load info into the CpuInfo_t structure.; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; interval over which the CPU load will be measured, in ms (default 1000). int GetMemInfo(MemInfo_t* info) const; Returns ram and swap memory usage info into the MemInfo_t structure.; Returns -1 in case of error, 0 otherwise. int GetProcInfo(ProcInfo_t* info) const; Returns cpu and memory used by this process into the ProcInfo_t structure.; Returns -1 in case of error, 0 otherwise. » Author: Fons Rademakers 15/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/unix:$Id: TUnixSystem.h 41630 2011-10-28 14:16:25Z rdm $ » Last generated: 2011-12-02 14:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:43564,Performance,load,load,43564," library; not loaded. int UnixDynLoad(const char* lib); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded and -1 in case lib does not exist; or in case of error. Func_t UnixDynFindSymbol(const char* lib, const char* entry); Finds and returns a function pointer to a symbol in the shared library.; Returns 0 when symbol not found. void UnixDynListSymbols(const char* lib, const char* re = """"); List symbols in a shared library. One can use wildcards to list only; the interesting symbols. void UnixDynListLibs(const char* lib = """"); List all loaded shared libraries. void UnixDynUnload(const char* lib); Unload a shared library. int ReadUtmpFile(); Read utmp file. Returns number of entries in utmp file. void * SearchUtmpEntry(int nentries, const char* tty); Look for utmp entry which is connected to terminal tty. int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Returns cpu load average and load info into the CpuInfo_t structure.; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; interval over which the CPU load will be measured, in ms (default 1000). int GetMemInfo(MemInfo_t* info) const; Returns ram and swap memory usage info into the MemInfo_t structure.; Returns -1 in case of error, 0 otherwise. int GetProcInfo(ProcInfo_t* info) const; Returns cpu and memory used by this process into the ProcInfo_t structure.; Returns -1 in case of error, 0 otherwise. » Author: Fons Rademakers 15/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/unix:$Id: TUnixSystem.h 41630 2011-10-28 14:16:25Z rdm $ » Last generated: 2011-12-02 14:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:43702,Performance,load,load,43702," library; not loaded. int UnixDynLoad(const char* lib); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded and -1 in case lib does not exist; or in case of error. Func_t UnixDynFindSymbol(const char* lib, const char* entry); Finds and returns a function pointer to a symbol in the shared library.; Returns 0 when symbol not found. void UnixDynListSymbols(const char* lib, const char* re = """"); List symbols in a shared library. One can use wildcards to list only; the interesting symbols. void UnixDynListLibs(const char* lib = """"); List all loaded shared libraries. void UnixDynUnload(const char* lib); Unload a shared library. int ReadUtmpFile(); Read utmp file. Returns number of entries in utmp file. void * SearchUtmpEntry(int nentries, const char* tty); Look for utmp entry which is connected to terminal tty. int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Returns cpu load average and load info into the CpuInfo_t structure.; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; interval over which the CPU load will be measured, in ms (default 1000). int GetMemInfo(MemInfo_t* info) const; Returns ram and swap memory usage info into the MemInfo_t structure.; Returns -1 in case of error, 0 otherwise. int GetProcInfo(ProcInfo_t* info) const; Returns cpu and memory used by this process into the ProcInfo_t structure.; Returns -1 in case of error, 0 otherwise. » Author: Fons Rademakers 15/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/unix:$Id: TUnixSystem.h 41630 2011-10-28 14:16:25Z rdm $ » Last generated: 2011-12-02 14:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:11083,Safety,timeout,timeout,11083,"t::RecursiveRemove(TObject* obj); virtual intRecvBuf(int sock, void* buffer, int length); virtual intRecvRaw(int sock, void* buffer, int length, int flag); virtual Int_tRedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); virtual TFileHandler*RemoveFileHandler(TFileHandler* fh); voidTSystem::RemoveOnExit(TObject* obj); virtual TSignalHandler*RemoveSignalHandler(TSignalHandler* sh); virtual TStdExceptionHandler*TSystem::RemoveStdExceptionHandler(TStdExceptionHandler* eh); virtual TTimer*RemoveTimer(TTimer* ti); virtual intRename(const char* from, const char* to); voidTObject::ResetBit(UInt_t f); static voidTSystem::ResetErrno(); virtual voidResetSignal(ESignals sig, Bool_t reset = kTRUE); virtual voidResetTimer(TTimer* ti); virtual voidTSystem::Run(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tSelect(TList* active, Long_t timeout); virtual Int_tSelect(TFileHandler* fh, Long_t timeout); virtual intSendBuf(int sock, const void* buffer, int length); virtual intSendRaw(int sock, const void* buffer, int length, int flag); virtual voidTSystem::SetAclicMode(TSystem::EAclicMode mode); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTSystem::SetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); virtual voidSetDisplay(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetDynamicPath(const char* lib); virtual voidSetenv(const char* name, const char* value); voidTSystem::SetErrorStr(const char* errstr); virtual voidTSystem::SetFlagsDebug(const char*); virtual voidTSystem::SetFlagsOpt(const char*); virtual Int_tSetFPEMask(Int_t mask = kDefaultMask); virtual voidTSystem::SetIncludePath(const char* includePath); virtual voidTSystem::SetLinkdefSuffix(const char* suffix); virtual voidTSystem::SetLinkedLibs(con",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:11138,Safety,timeout,timeout,11138,"t sock, void* buffer, int length); virtual intRecvRaw(int sock, void* buffer, int length, int flag); virtual Int_tRedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); virtual TFileHandler*RemoveFileHandler(TFileHandler* fh); voidTSystem::RemoveOnExit(TObject* obj); virtual TSignalHandler*RemoveSignalHandler(TSignalHandler* sh); virtual TStdExceptionHandler*TSystem::RemoveStdExceptionHandler(TStdExceptionHandler* eh); virtual TTimer*RemoveTimer(TTimer* ti); virtual intRename(const char* from, const char* to); voidTObject::ResetBit(UInt_t f); static voidTSystem::ResetErrno(); virtual voidResetSignal(ESignals sig, Bool_t reset = kTRUE); virtual voidResetTimer(TTimer* ti); virtual voidTSystem::Run(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tSelect(TList* active, Long_t timeout); virtual Int_tSelect(TFileHandler* fh, Long_t timeout); virtual intSendBuf(int sock, const void* buffer, int length); virtual intSendRaw(int sock, const void* buffer, int length, int flag); virtual voidTSystem::SetAclicMode(TSystem::EAclicMode mode); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTSystem::SetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); virtual voidSetDisplay(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetDynamicPath(const char* lib); virtual voidSetenv(const char* name, const char* value); voidTSystem::SetErrorStr(const char* errstr); virtual voidTSystem::SetFlagsDebug(const char*); virtual voidTSystem::SetFlagsOpt(const char*); virtual Int_tSetFPEMask(Int_t mask = kDefaultMask); virtual voidTSystem::SetIncludePath(const char* includePath); virtual voidTSystem::SetLinkdefSuffix(const char* suffix); virtual voidTSystem::SetLinkedLibs(const char* linkedLibs); virtual voidTSystem::SetMakeExe(c",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:15863,Safety,timeout,timeout,15863,"ame); static void*FindDynLib(const char* lib); TSystem*TSystem::FindHelper(const char* path, void* dirptr = 0); virtual const char*GetLinkedLibraries(); voidTObject::MakeZombie(); static intReadUtmpFile(); static void*SearchUtmpEntry(int nentries, const char* tty); static const char*TSystem::StripOffProto(const char* path, const char* proto); static Func_tUnixDynFindSymbol(const char* lib, const char* entry); static voidUnixDynListLibs(const char* lib = """"); static voidUnixDynListSymbols(const char* lib, const char* re = """"); static intUnixDynLoad(const char* lib); static voidUnixDynUnload(const char* lib); static intUnixFilestat(const char* path, FileStat_t& buf); static intUnixFSstat(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); static const char*UnixGetdirentry(void* dir); static const char*UnixHomedirectory(const char* user = 0); static voidUnixIgnoreSignal(ESignals sig, Bool_t ignore); static intUnixMakedir(const char* name); static Long64_tUnixNow(); static void*UnixOpendir(const char* name); static intUnixRecv(int sock, void* buf, int len, int flag); static voidUnixResetSignal(ESignals sig); static voidUnixResetSignals(); static intUnixSelect(Int_t nfds, TFdSet* readready, TFdSet* writeready, Long_t timeout); static intUnixSend(int sock, const void* buf, int len, int flag); static intUnixSetitimer(Long_t ms); static voidUnixSigAlarmInterruptsSyscalls(Bool_t set); static voidUnixSignal(ESignals sig, void* h); static const char*UnixSigname(ESignals sig); static intUnixTcpConnect(const char* hostname, int port, int tcpwindowsize); static intUnixTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize); static intUnixUdpConnect(const char* hostname, int port); static intUnixUdpService(int port, int backlog); static intUnixUnixConnect(int port); static intUnixUnixConnect(const char* path); static intUnixUnixService(int port, int backlog); static intUnixUnixService(const char* sockpath, int backlog); static intUnixWaitchild().",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:21910,Safety,timeout,timeout,21910,"he list of file handlers. Returns; the handler or 0 if the handler was not in the list of file handlers. void AddSignalHandler(TSignalHandler* sh); Add a signal handler to list of system signal handlers. Only adds; the handler if it is not already in the list of signal handlers. TSignalHandler * RemoveSignalHandler(TSignalHandler* sh); Remove a signal handler from list of signal handlers. Returns; the handler or 0 if the handler was not in the list of signal handlers. void ResetSignal(ESignals sig, Bool_t reset = kTRUE); If reset is true reset the signal handler for the specified signal; to the default handler, else restore previous behaviour. void IgnoreSignal(ESignals sig, Bool_t ignore = kTRUE); If ignore is true ignore the specified signal, else restore previous; behaviour. void SigAlarmInterruptsSyscalls(Bool_t set); When the argument is true the SIGALRM signal handler is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milliseconds. Int_t Select(TList* active, Long_t timeout); Select on file descriptors. The timeout to is in millisec. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. Returns; -4 in case the list did not contain any file handlers or file handlers; with file descri",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:22523,Safety,timeout,timeout,22523,"estore previous behaviour. void IgnoreSignal(ESignals sig, Bool_t ignore = kTRUE); If ignore is true ignore the specified signal, else restore previous; behaviour. void SigAlarmInterruptsSyscalls(Bool_t set); When the argument is true the SIGALRM signal handler is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milliseconds. Int_t Select(TList* active, Long_t timeout); Select on file descriptors. The timeout to is in millisec. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. Returns; -4 in case the list did not contain any file handlers or file handlers; with file descriptor >= 0. Int_t Select(TFileHandler* fh, Long_t timeout); Select on the file descriptor related to file handler h.; The timeout to is in millisec. Returns the number of ready descriptors,; or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR; and -3 EBADF. In case of EINTR the errno has been reset and the method; can be called again. Returns -4 in case the file handler is 0 or does; not have a file descriptor >= 0. void DispatchSignals(ESignals sig); Handle and dispatch signals. Bool_t CheckSignals(Bool_t sync); Check if some signals were raised and call their Notify() member. void CheckChilds(); C",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:22565,Safety,timeout,timeout,22565,"s sig, Bool_t ignore = kTRUE); If ignore is true ignore the specified signal, else restore previous; behaviour. void SigAlarmInterruptsSyscalls(Bool_t set); When the argument is true the SIGALRM signal handler is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milliseconds. Int_t Select(TList* active, Long_t timeout); Select on file descriptors. The timeout to is in millisec. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. Returns; -4 in case the list did not contain any file handlers or file handlers; with file descriptor >= 0. Int_t Select(TFileHandler* fh, Long_t timeout); Select on the file descriptor related to file handler h.; The timeout to is in millisec. Returns the number of ready descriptors,; or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR; and -3 EBADF. In case of EINTR the errno has been reset and the method; can be called again. Returns -4 in case the file handler is 0 or does; not have a file descriptor >= 0. void DispatchSignals(ESignals sig); Handle and dispatch signals. Bool_t CheckSignals(Bool_t sync); Check if some signals were raised and call their Notify() member. void CheckChilds(); Check if childs have finished. Bool_t CheckDescriptor",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:22650,Safety,timeout,timeout,22650,"e restore previous; behaviour. void SigAlarmInterruptsSyscalls(Bool_t set); When the argument is true the SIGALRM signal handler is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milliseconds. Int_t Select(TList* active, Long_t timeout); Select on file descriptors. The timeout to is in millisec. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. Returns; -4 in case the list did not contain any file handlers or file handlers; with file descriptor >= 0. Int_t Select(TFileHandler* fh, Long_t timeout); Select on the file descriptor related to file handler h.; The timeout to is in millisec. Returns the number of ready descriptors,; or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR; and -3 EBADF. In case of EINTR the errno has been reset and the method; can be called again. Returns -4 in case the file handler is 0 or does; not have a file descriptor >= 0. void DispatchSignals(ESignals sig); Handle and dispatch signals. Bool_t CheckSignals(Bool_t sync); Check if some signals were raised and call their Notify() member. void CheckChilds(); Check if childs have finished. Bool_t CheckDescriptors(); Check if there is activity on some file descriptors and call their; Notify(",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:22947,Safety,timeout,timeout,22947,"ed syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milliseconds. Int_t Select(TList* active, Long_t timeout); Select on file descriptors. The timeout to is in millisec. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. Returns; -4 in case the list did not contain any file handlers or file handlers; with file descriptor >= 0. Int_t Select(TFileHandler* fh, Long_t timeout); Select on the file descriptor related to file handler h.; The timeout to is in millisec. Returns the number of ready descriptors,; or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR; and -3 EBADF. In case of EINTR the errno has been reset and the method; can be called again. Returns -4 in case the file handler is 0 or does; not have a file descriptor >= 0. void DispatchSignals(ESignals sig); Handle and dispatch signals. Bool_t CheckSignals(Bool_t sync); Check if some signals were raised and call their Notify() member. void CheckChilds(); Check if childs have finished. Bool_t CheckDescriptors(); Check if there is activity on some file descriptors and call their; Notify() member. int MakeDirectory(const char* name); Make a Unix file system directory. Returns 0 in case of success and; -1 if the directory could not be created. void * OpenDirectory(const char* name); Open a Unix file system directory. Returns 0 if directory does not exist. void FreeDirectory(void* dirp); C",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:23019,Safety,timeout,timeout,23019,"controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milliseconds. Int_t Select(TList* active, Long_t timeout); Select on file descriptors. The timeout to is in millisec. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. Returns; -4 in case the list did not contain any file handlers or file handlers; with file descriptor >= 0. Int_t Select(TFileHandler* fh, Long_t timeout); Select on the file descriptor related to file handler h.; The timeout to is in millisec. Returns the number of ready descriptors,; or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR; and -3 EBADF. In case of EINTR the errno has been reset and the method; can be called again. Returns -4 in case the file handler is 0 or does; not have a file descriptor >= 0. void DispatchSignals(ESignals sig); Handle and dispatch signals. Bool_t CheckSignals(Bool_t sync); Check if some signals were raised and call their Notify() member. void CheckChilds(); Check if childs have finished. Bool_t CheckDescriptors(); Check if there is activity on some file descriptors and call their; Notify() member. int MakeDirectory(const char* name); Make a Unix file system directory. Returns 0 in case of success and; -1 if the directory could not be created. void * OpenDirectory(const char* name); Open a Unix file system directory. Returns 0 if directory does not exist. void FreeDirectory(void* dirp); Close a Unix file system directory. const char * GetDirEntry(void* di",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:23104,Safety,timeout,timeout,23104,"alls(). Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milliseconds. Int_t Select(TList* active, Long_t timeout); Select on file descriptors. The timeout to is in millisec. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. Returns; -4 in case the list did not contain any file handlers or file handlers; with file descriptor >= 0. Int_t Select(TFileHandler* fh, Long_t timeout); Select on the file descriptor related to file handler h.; The timeout to is in millisec. Returns the number of ready descriptors,; or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR; and -3 EBADF. In case of EINTR the errno has been reset and the method; can be called again. Returns -4 in case the file handler is 0 or does; not have a file descriptor >= 0. void DispatchSignals(ESignals sig); Handle and dispatch signals. Bool_t CheckSignals(Bool_t sync); Check if some signals were raised and call their Notify() member. void CheckChilds(); Check if childs have finished. Bool_t CheckDescriptors(); Check if there is activity on some file descriptors and call their; Notify() member. int MakeDirectory(const char* name); Make a Unix file system directory. Returns 0 in case of success and; -1 if the directory could not be created. void * OpenDirectory(const char* name); Open a Unix file system directory. Returns 0 if directory does not exist. void FreeDirectory(void* dirp); Close a Unix file system directory. const char * GetDirEntry(void* dirp); Get next Unix file system directory entry. Returns 0 if no more entries. Boo",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:24788,Safety,safe,safely,24788,"ectory could not be created. void * OpenDirectory(const char* name); Open a Unix file system directory. Returns 0 if directory does not exist. void FreeDirectory(void* dirp); Close a Unix file system directory. const char * GetDirEntry(void* dirp); Get next Unix file system directory entry. Returns 0 if no more entries. Bool_t ChangeDirectory(const char* path); Change directory. Returns kTRUE in case of success, kFALSE otherwise. const char * WorkingDirectory(); Return working directory. const char * HomeDirectory(const char* userName = 0); Return the user's home directory. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. Returns 0 when successful, -1 in case of failure. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is ",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:24822,Safety,avoid,avoids,24822,"ectory could not be created. void * OpenDirectory(const char* name); Open a Unix file system directory. Returns 0 if directory does not exist. void FreeDirectory(void* dirp); Close a Unix file system directory. const char * GetDirEntry(void* dirp); Get next Unix file system directory entry. Returns 0 if no more entries. Bool_t ChangeDirectory(const char* path); Change directory. Returns kTRUE in case of success, kFALSE otherwise. const char * WorkingDirectory(); Return working directory. const char * HomeDirectory(const char* userName = 0); Return the user's home directory. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. Returns 0 when successful, -1 in case of failure. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is ",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:25793,Safety,avoid,avoid,25793,"ile; (this avoids certain security problems). Returns 0 in case; of error. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. Returns 0 when successful, -1 in case of failure. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: id, bsize, bfree, blocks.; Id is file system type (machine dependend, see statfs()); Bsize is block size of file system; Blocks is total number of blocks in file system; Bfree is number of free blocks in file system; The function returns 0 in case of success and 1 if the file system could; not be stat'ed. int Link(const char* from, const char* to); Create a link from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Symlink(const char* from, const char* to); Create a symlink from file1 to file2. Returns 0 when succesfull,; -1 in case of failure. int Unlink(const char* name); Unlink,",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:30420,Safety,Abort,Abort,30420,"rGroup_t * GetGroupInfo(const char* group = 0); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. The string passed will be owned by; the environment and can not be reused till a ""name"" is set; again. The solution below will lose the space for the string; in that case, but if this functions is not called thousands; of times that should not be a problem. const char * Getenv(const char* name); Get environment variable. int Exec(const char* shellcmd); Execute a command. FILE * OpenPipe(const char* shellcmd, const char* mode); Open a pipe. int ClosePipe(FILE* pipe); Close the pipe. int GetPid(); Get process id. void Exit(int code, Bool_t mode = kTRUE); Exit the application. void Abort(int code = 0); Abort the application. void StackTrace(); Print a stack trace. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; This function saves internally the current state into a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the ",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:30441,Safety,Abort,Abort,30441,"rGroup_t * GetGroupInfo(const char* group = 0); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. The string passed will be owned by; the environment and can not be reused till a ""name"" is set; again. The solution below will lose the space for the string; in that case, but if this functions is not called thousands; of times that should not be a problem. const char * Getenv(const char* name); Get environment variable. int Exec(const char* shellcmd); Execute a command. FILE * OpenPipe(const char* shellcmd, const char* mode); Open a pipe. int ClosePipe(FILE* pipe); Close the pipe. int GetPid(); Get process id. void Exit(int code, Bool_t mode = kTRUE); Exit the application. void Abort(int code = 0); Abort the application. void StackTrace(); Print a stack trace. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; This function saves internally the current state into a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the ",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:36823,Safety,timeout,timeout,36823,"se of kNoBlock and; errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer; (EPIPE || ECONNRESET). int SendRaw(int sock, const void* buffer, int length, int flag); Send exactly length bytes from buffer. Use opt to send out-of-band; data (see TSocket). Returns the number of bytes sent or -1 in case of; error. Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). int SetSockOpt(int sock, int option, int val); Set socket option. int GetSockOpt(int sock, int option, int* val); Get socket option. void UnixSignal(ESignals sig, void* h); Set a signal handler for a signal. void UnixIgnoreSignal(ESignals sig, Bool_t ignore); If ignore is true ignore the specified signal, else restore previous; behaviour. void UnixSigAlarmInterruptsSyscalls(Bool_t set); When the argument is true the SIGALRM signal handler is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). const char * UnixSigname(ESignals sig); Return the signal name associated with a signal. void UnixResetSignal(ESignals sig); Restore old signal handler for specified signal. void UnixResetSignals(); Restore old signal handlers. Long64_t UnixNow(); Get current time in milliseconds since 0:00 Jan 1 1995. int UnixSetitimer(Long_t ms); Set interval timer to time-out in ms milliseconds. int UnixSelect(Int_t nfds, TFdSet* readready, TFdSet* writeready, Long_t timeout); Wait for events on the file descriptors specified in the readready and; writeready masks or for timeout (in milliseconds) to occur. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:37489,Safety,timeout,timeout,37489,"re is true ignore the specified signal, else restore previous; behaviour. void UnixSigAlarmInterruptsSyscalls(Bool_t set); When the argument is true the SIGALRM signal handler is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). const char * UnixSigname(ESignals sig); Return the signal name associated with a signal. void UnixResetSignal(ESignals sig); Restore old signal handler for specified signal. void UnixResetSignals(); Restore old signal handlers. Long64_t UnixNow(); Get current time in milliseconds since 0:00 Jan 1 1995. int UnixSetitimer(Long_t ms); Set interval timer to time-out in ms milliseconds. int UnixSelect(Int_t nfds, TFdSet* readready, TFdSet* writeready, Long_t timeout); Wait for events on the file descriptors specified in the readready and; writeready masks or for timeout (in milliseconds) to occur. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. const char * UnixHomedirectory(const char* user = 0); Returns the user's home directory. int UnixMakedir(const char* name); Make a Unix file system directory. Returns 0 in case of success and; -1 if the directory could not be created (either already exists or; illegal path name). void * UnixOpendir(const char* name); Open a directory. const char * UnixGetdirentry(void* dir); Returns the next directory entry. int UnixFilestat(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int UnixFSstat(const char* path, Long_",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:37595,Safety,timeout,timeout,37595,"re is true ignore the specified signal, else restore previous; behaviour. void UnixSigAlarmInterruptsSyscalls(Bool_t set); When the argument is true the SIGALRM signal handler is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). const char * UnixSigname(ESignals sig); Return the signal name associated with a signal. void UnixResetSignal(ESignals sig); Restore old signal handler for specified signal. void UnixResetSignals(); Restore old signal handlers. Long64_t UnixNow(); Get current time in milliseconds since 0:00 Jan 1 1995. int UnixSetitimer(Long_t ms); Set interval timer to time-out in ms milliseconds. int UnixSelect(Int_t nfds, TFdSet* readready, TFdSet* writeready, Long_t timeout); Wait for events on the file descriptors specified in the readready and; writeready masks or for timeout (in milliseconds) to occur. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. const char * UnixHomedirectory(const char* user = 0); Returns the user's home directory. int UnixMakedir(const char* name); Make a Unix file system directory. Returns 0 in case of success and; -1 if the directory could not be created (either already exists or; illegal path name). void * UnixOpendir(const char* name); Open a directory. const char * UnixGetdirentry(void* dir); Returns the next directory entry. int UnixFilestat(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int UnixFSstat(const char* path, Long_",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:37689,Safety,timeout,timeout,37689,"er is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). const char * UnixSigname(ESignals sig); Return the signal name associated with a signal. void UnixResetSignal(ESignals sig); Restore old signal handler for specified signal. void UnixResetSignals(); Restore old signal handlers. Long64_t UnixNow(); Get current time in milliseconds since 0:00 Jan 1 1995. int UnixSetitimer(Long_t ms); Set interval timer to time-out in ms milliseconds. int UnixSelect(Int_t nfds, TFdSet* readready, TFdSet* writeready, Long_t timeout); Wait for events on the file descriptors specified in the readready and; writeready masks or for timeout (in milliseconds) to occur. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. const char * UnixHomedirectory(const char* user = 0); Returns the user's home directory. int UnixMakedir(const char* name); Make a Unix file system directory. Returns 0 in case of success and; -1 if the directory could not be created (either already exists or; illegal path name). void * UnixOpendir(const char* name); Open a directory. const char * UnixGetdirentry(void* dir); Returns the next directory entry. int UnixFilestat(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int UnixFSstat(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: id, bsize, bfree, blocks.; Id is file system type (machine dependend, see statfs()); Bsi",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:7272,Security,Hash,Hash,7272,"al char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual const char*TSystem::GetObjExt() const; virtual Option_t*TObject::GetOption() const; virtual intGetPathInfo(const char* path, FileStat_t& buf); virtual TInetAddressGetPeerName(int sock); virtual intGetPid(); virtual intGetProcInfo(ProcInfo_t* info) const; virtual intGetServiceByName(const char* service); virtual char*GetServiceByPort(int port); virtual TInetAddressGetSockName(int sock); virtual intGetSockOpt(int sock, int option, int* val); virtual const char*TSystem::GetSoExt() const; virtual intGetSysInfo(SysInfo_t* info) const; virtual const char*TNamed::GetTitle() const; virtual Int_tGetUid(const char* user = 0); virtual UInt_tTObject::GetUniqueID() const; virtual UserGroup_t*GetUserInfo(Int_t uid); virtual UserGroup_t*GetUserInfo(const char* user = 0); virtual TList*TSystem::GetVolumes(Option_t*) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual const char*HomeDirectory(const char* userName = 0); virtual const char*HostName(); virtual voidTSystem::IgnoreInterrupt(Bool_t ignore = kTRUE); virtual voidIgnoreSignal(ESignals sig, Bool_t ignore = kTRUE); Bool_tTSystem::InControl() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual Bool_tInit(); virtual voidTSystem::InnerLoop(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTSystem::IsAbsoluteFileName(const char* dir); virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTSystem::IsFileInIncludePath(const char* name, char** fullpath = 0); virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsPathLocal(const char* path); virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::Is",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:18059,Security,access,access,18059,"rationUsed by Beep(); Int_tTSystem::fBeepFreqUsed by Beep(); TStringTSystem::fBuildArchArchitecure for which ROOT was built (passed to ./configure); TStringTSystem::fBuildCompilerCompiler used to build this ROOT; TStringTSystem::fBuildCompilerVersionCompiler version used to build this ROOT; TStringTSystem::fBuildDirLocation where to build ACLiC shared library and use as scratch area.; TStringTSystem::fBuildNodeDetailed information where ROOT was built; TSeqCollection*TSystem::fCompiledList of shared libs from compiled macros to be deleted; Bool_tTSystem::fDoneTrue if eventloop should be finished; TSeqCollection*TSystem::fFileHandlerList of file handlers; TStringTSystem::fFlagsDebugFlags for debug compilation; TStringTSystem::fFlagsOptFlags for optimized compilation; TSeqCollection*TSystem::fHelpersList of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); TStringTSystem::fLastErrorStringLast system error message; Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of fd's in masks; TStringTSystem::fObjExtExtension of object fi",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:24548,Security,secur,secure,24548,"hed. Bool_t CheckDescriptors(); Check if there is activity on some file descriptors and call their; Notify() member. int MakeDirectory(const char* name); Make a Unix file system directory. Returns 0 in case of success and; -1 if the directory could not be created. void * OpenDirectory(const char* name); Open a Unix file system directory. Returns 0 if directory does not exist. void FreeDirectory(void* dirp); Close a Unix file system directory. const char * GetDirEntry(void* dirp); Get next Unix file system directory entry. Returns 0 if no more entries. Bool_t ChangeDirectory(const char* path); Change directory. Returns kTRUE in case of success, kFALSE otherwise. const char * WorkingDirectory(); Return working directory. const char * HomeDirectory(const char* userName = 0); Return the user's home directory. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error du",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:24837,Security,secur,security,24837,"ectory could not be created. void * OpenDirectory(const char* name); Open a Unix file system directory. Returns 0 if directory does not exist. void FreeDirectory(void* dirp); Close a Unix file system directory. const char * GetDirEntry(void* dirp); Get next Unix file system directory entry. Returns 0 if no more entries. Bool_t ChangeDirectory(const char* path); Change directory. Returns kTRUE in case of success, kFALSE otherwise. const char * WorkingDirectory(); Return working directory. const char * HomeDirectory(const char* userName = 0); Return the user's home directory. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. Returns 0 when successful, -1 in case of failure. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is ",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:24996,Security,Access,AccessPathName,24996,"directory entry. Returns 0 if no more entries. Bool_t ChangeDirectory(const char* path); Change directory. Returns kTRUE in case of success, kFALSE otherwise. const char * WorkingDirectory(); Return working directory. const char * HomeDirectory(const char* userName = 0); Return the user's home directory. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. Returns 0 when successful, -1 in case of failure. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file coul",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:25087,Security,access,access,25087,"directory entry. Returns 0 if no more entries. Bool_t ChangeDirectory(const char* path); Change directory. Returns kTRUE in case of success, kFALSE otherwise. const char * WorkingDirectory(); Return working directory. const char * HomeDirectory(const char* userName = 0); Return the user's home directory. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. Returns 0 when successful, -1 in case of failure. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file coul",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:25121,Security,access,access,25121,"directory entry. Returns 0 if no more entries. Bool_t ChangeDirectory(const char* path); Change directory. Returns kTRUE in case of success, kFALSE otherwise. const char * WorkingDirectory(); Return working directory. const char * HomeDirectory(const char* userName = 0); Return the user's home directory. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. Returns 0 when successful, -1 in case of failure. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file coul",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:25168,Security,access,access,25168,"ctory. Returns kTRUE in case of success, kFALSE otherwise. const char * WorkingDirectory(); Return working directory. const char * HomeDirectory(const char* userName = 0); Return the user's home directory. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. Returns 0 when successful, -1 in case of failure. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:27864,Security,access,access,27864,"a file or directory. Returns 0 when succesfull,; -1 in case of failure. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file ""wfil"" in a search path.; The search path is specified as a : separated list of directories.; Return value is pointing to wfile for compatibility with; Which(const char*,const char*,EAccessMode) version. Int_t GetUid(const char* user = 0); Returns the user's id. If user = 0, returns current user's id. Int_t GetEffectiveUid(); Returns the effective user id. The effective id corresponds to the; set id bit on the file being executed. Int_t GetGid(const char* group = 0); Returns the group's id. If group = 0, returns current user's group. Int_t GetEffectiveGid(); Returns the effective group id. The effective group id corresponds; to the set id bit on the file being executed. UserGroup_t * GetUserInfo(Int_t uid); Returns all user info in th",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:13443,Testability,Test,TestBit,13443,"ual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTSystem::SetObjExt(const char* objExt); virtual voidSetProgname(const char* name); virtual intSetSockOpt(int sock, int option, int val); virtual voidTSystem::SetSoExt(const char* soExt); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidTSystem::ShowOutput(RedirectHandle_t* h); virtual voidSigAlarmInterruptsSyscalls(Bool_t set); virtual Int_tTNamed::Sizeof() const; virtual voidSleep(UInt_t milliSec); virtual TStringTSystem::SplitAclicMode(const char* filename, TString& mode, TString& args, TString& io) const; virtual voidStackTrace(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual intSymlink(const char* from, const char* to); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidSyslog(ELogLevel level, const char* mess); virtual const char*TempDirectory() const; virtual FILE*TempFileName(TString& base, const char* dir = 0); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual intUmask(Int_t mask); virtual const char*TSystem::UnixPathName(const char* unixpathname); virtual intUnlink(const char* name); virtual voidUnload(const char* module); virtual voidTSystem::Unsetenv(const char* name); virtual voidTObject::UseCurrentStyle(); virtual intUtime(const char* file, Long_t modtime, Long_t actime); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual char*TSystem::Which(const char* search, const char* file, EAccessMode mode = kFileExists); virtual const char*WorkingDirectory(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:13482,Testability,Test,TestBits,13482,"ual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTSystem::SetObjExt(const char* objExt); virtual voidSetProgname(const char* name); virtual intSetSockOpt(int sock, int option, int val); virtual voidTSystem::SetSoExt(const char* soExt); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidTSystem::ShowOutput(RedirectHandle_t* h); virtual voidSigAlarmInterruptsSyscalls(Bool_t set); virtual Int_tTNamed::Sizeof() const; virtual voidSleep(UInt_t milliSec); virtual TStringTSystem::SplitAclicMode(const char* filename, TString& mode, TString& args, TString& io) const; virtual voidStackTrace(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual intSymlink(const char* from, const char* to); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidSyslog(ELogLevel level, const char* mess); virtual const char*TempDirectory() const; virtual FILE*TempFileName(TString& base, const char* dir = 0); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual intUmask(Int_t mask); virtual const char*TSystem::UnixPathName(const char* unixpathname); virtual intUnlink(const char* name); virtual voidUnload(const char* module); virtual voidTSystem::Unsetenv(const char* name); virtual voidTObject::UseCurrentStyle(); virtual intUtime(const char* file, Long_t modtime, Long_t actime); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual char*TSystem::Which(const char* search, const char* file, EAccessMode mode = kFileExists); virtual const char*WorkingDirectory(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:30600,Testability,log,log,30600,"ields in the UserGroup_t structure for this call are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. The string passed will be owned by; the environment and can not be reused till a ""name"" is set; again. The solution below will lose the space for the string; in that case, but if this functions is not called thousands; of times that should not be a problem. const char * Getenv(const char* name); Get environment variable. int Exec(const char* shellcmd); Execute a command. FILE * OpenPipe(const char* shellcmd, const char* mode); Open a pipe. int ClosePipe(FILE* pipe); Close the pipe. int GetPid(); Get process id. void Exit(int code, Bool_t mode = kTRUE); Exit the application. void Abort(int code = 0); Abort the application. void StackTrace(); Print a stack trace. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; This function saves internally the current state into a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included S",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:30773,Testability,log,logging,30773,"value); Set environment variable. The string passed will be owned by; the environment and can not be reused till a ""name"" is set; again. The solution below will lose the space for the string; in that case, but if this functions is not called thousands; of times that should not be a problem. const char * Getenv(const char* name); Get environment variable. int Exec(const char* shellcmd); Execute a command. FILE * OpenPipe(const char* shellcmd, const char* mode); Open a pipe. int ClosePipe(FILE* pipe); Close the pipe. int GetPid(); Get process id. void Exit(int code, Bool_t mode = kTRUE); Exit the application. void Abort(int code = 0); Abort the application. void StackTrace(); Print a stack trace. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; This function saves internally the current state into a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. Func_t DynFindSymbol(const char* module, const char* entry); dynamic linking of module. int Load(const char* module, const char* entry = """", Bool_t system",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:30837,Testability,log,log,30837,"value); Set environment variable. The string passed will be owned by; the environment and can not be reused till a ""name"" is set; again. The solution below will lose the space for the string; in that case, but if this functions is not called thousands; of times that should not be a problem. const char * Getenv(const char* name); Get environment variable. int Exec(const char* shellcmd); Execute a command. FILE * OpenPipe(const char* shellcmd, const char* mode); Open a pipe. int ClosePipe(FILE* pipe); Close the pipe. int GetPid(); Get process id. void Exit(int code, Bool_t mode = kTRUE); Exit the application. void Abort(int code = 0); Abort the application. void StackTrace(); Print a stack trace. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; This function saves internally the current state into a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. Func_t DynFindSymbol(const char* module, const char* entry); dynamic linking of module. int Load(const char* module, const char* entry = """", Bool_t system",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:30886,Testability,log,log,30886," the environment and can not be reused till a ""name"" is set; again. The solution below will lose the space for the string; in that case, but if this functions is not called thousands; of times that should not be a problem. const char * Getenv(const char* name); Get environment variable. int Exec(const char* shellcmd); Execute a command. FILE * OpenPipe(const char* shellcmd, const char* mode); Open a pipe. int ClosePipe(FILE* pipe); Close the pipe. int GetPid(); Get process id. void Exit(int code, Bool_t mode = kTRUE); Exit the application. void Abort(int code = 0); Abort the application. void StackTrace(); Print a stack trace. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; This function saves internally the current state into a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. Func_t DynFindSymbol(const char* module, const char* entry); dynamic linking of module. int Load(const char* module, const char* entry = """", Bool_t system = kFALSE); Load a shared library. Returns 0 on successful loading, 1",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnixSystem.html:1872,Usability,Clear,Clear,1872,"SignalHandler(TSignalHandler* sh); virtual voidTSystem::AddStdExceptionHandler(TStdExceptionHandler* eh); virtual voidAddTimer(TTimer* ti); virtual intAnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); virtual intAnnounceUdpService(int port, int backlog); virtual intAnnounceUnixService(int port, int backlog); virtual intAnnounceUnixService(const char* sockpath, int backlog); virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*TSystem::BaseName(const char* pathname); voidTSystem::Beep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); virtual voidTObject::Browse(TBrowser* b); Bool_tTSystem::cd(const char* path); virtual Bool_tChangeDirectory(const char* path); voidCheckChilds(); Bool_tCheckDescriptors(); Bool_tCheckSignals(Bool_t sync); virtual intChmod(const char* file, UInt_t mode); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTSystem::CleanCompiledMacros(); virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidCloseConnection(int sock, Bool_t force = kFALSE); virtual voidCloselog(); virtual intClosePipe(FILE* pipe); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual intTSystem::CompileMacro(const char* filename, Option_t* opt = """", const char* library_name = """", const char* build_dir = """", UInt_t dirmode = 0); virtual char*TSystem::ConcatFileName(const char* dir, const char* name); intConnectService(const char* server, int port, int tcpwindowsize, const char* protocol = ""tcp""); virtual voidTNamed::Copy(TObject& named) const; virtual intCopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual const char*TSystem::DirName(const char* pathname); virtual voidDispatchOneEvent(Bool_t pendingOnly = kFALSE); voidDispatchSignals(ESignals sig); Bool_tDispatchTimers(Bool_t mode); virtual Int_tTObject::DistancetoP",MatchSource.WIKI,root/html532/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnixSystem.html
https://root.cern/root/html532/TUnuran.html:4026,Availability,avail,available,4026,"er for distribution wrapper; unur_gen*fGenpointer to the UnuRan C generator struct; stringfMethodstring representing the method; TRandom*fRngpointer to ROOT random number generator; unur_distr*fUdistrpointer to the UnuRan C distribution struct; unur_urng*fUrngpointer to Unuran C random generator struct . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnuran(TRandom* r = 0, unsigned int log = 0). Constructor with a generator instance and given level of log output. ~TUnuran(). Destructor. TUnuran(const TUnuran& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. bool Init(const std::string & distr, const std::string & method). initialize with Unuran string interface. bool Init(const TUnuranContDist& distr, const string& method = ""auto""). Initialize method for continuous one-dimensional distribution.; User must provide a distribution object (which is copied inside) and a string for a method.; For the list of available method for 1D cont. distribution see the; <A href=""http://statmath.wu-wien.ac.at/unuran/doc/unuran.html#Methods_005ffor_005fCONT"">UnuRan doc</A>.; A re-initialization is needed whenever distribution parameters have been changed. bool Init(const TUnuranMultiContDist& distr, const string& method = ""hitro""). Initialize method for continuous multi-dimensional distribution.; User must provide a distribution object (which is copied inside) and a string for a method.; For the list of available method for multivariate cont. distribution see the; <A href=""http://statmath.wu-wien.ac.at/unuran/doc/unuran.html#Methods_005ffor_005fCVEC"">UnuRan doc</A>; A re-initialization is needed whenever distribution parameters have been changed. bool Init(const TUnuranDiscrDist& distr, const string& method = ""auto""). Initialize method for continuous one-dimensional discrete distribution.; User must provide a distribution object (which is copied inside) and a string for a method.; For the list of available m",MatchSource.WIKI,root/html532/TUnuran.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnuran.html
https://root.cern/root/html532/TUnuran.html:4518,Availability,avail,available,4518," of log output. ~TUnuran(). Destructor. TUnuran(const TUnuran& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. bool Init(const std::string & distr, const std::string & method). initialize with Unuran string interface. bool Init(const TUnuranContDist& distr, const string& method = ""auto""). Initialize method for continuous one-dimensional distribution.; User must provide a distribution object (which is copied inside) and a string for a method.; For the list of available method for 1D cont. distribution see the; <A href=""http://statmath.wu-wien.ac.at/unuran/doc/unuran.html#Methods_005ffor_005fCONT"">UnuRan doc</A>.; A re-initialization is needed whenever distribution parameters have been changed. bool Init(const TUnuranMultiContDist& distr, const string& method = ""hitro""). Initialize method for continuous multi-dimensional distribution.; User must provide a distribution object (which is copied inside) and a string for a method.; For the list of available method for multivariate cont. distribution see the; <A href=""http://statmath.wu-wien.ac.at/unuran/doc/unuran.html#Methods_005ffor_005fCVEC"">UnuRan doc</A>; A re-initialization is needed whenever distribution parameters have been changed. bool Init(const TUnuranDiscrDist& distr, const string& method = ""auto""). Initialize method for continuous one-dimensional discrete distribution.; User must provide a distribution object (which is copied inside) and a string for a method.; For the list of available method for 1D discrete distribution see the; <A href=""http://statmath.wu-wien.ac.at/unuran/doc/unuran.html#Methods_005ffor_005fDISCR"">UnuRan doc</A>; A re-initialization is needed whenever distribution parameters have been changed. bool Init(const TUnuranEmpDist& distr, const string& method = ""empk""). Initialize method for continuous empirical distribution.; User must provide a distribution object (which is copied inside) and a string for a method.; The distribution object can represent binned",MatchSource.WIKI,root/html532/TUnuran.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnuran.html
https://root.cern/root/html532/TUnuran.html:5021,Availability,avail,available,5021,"nt. distribution see the; <A href=""http://statmath.wu-wien.ac.at/unuran/doc/unuran.html#Methods_005ffor_005fCONT"">UnuRan doc</A>.; A re-initialization is needed whenever distribution parameters have been changed. bool Init(const TUnuranMultiContDist& distr, const string& method = ""hitro""). Initialize method for continuous multi-dimensional distribution.; User must provide a distribution object (which is copied inside) and a string for a method.; For the list of available method for multivariate cont. distribution see the; <A href=""http://statmath.wu-wien.ac.at/unuran/doc/unuran.html#Methods_005ffor_005fCVEC"">UnuRan doc</A>; A re-initialization is needed whenever distribution parameters have been changed. bool Init(const TUnuranDiscrDist& distr, const string& method = ""auto""). Initialize method for continuous one-dimensional discrete distribution.; User must provide a distribution object (which is copied inside) and a string for a method.; For the list of available method for 1D discrete distribution see the; <A href=""http://statmath.wu-wien.ac.at/unuran/doc/unuran.html#Methods_005ffor_005fDISCR"">UnuRan doc</A>; A re-initialization is needed whenever distribution parameters have been changed. bool Init(const TUnuranEmpDist& distr, const string& method = ""empk""). Initialize method for continuous empirical distribution.; User must provide a distribution object (which is copied inside) and a string for a method.; The distribution object can represent binned (only 1D) or unbinned (1D or multi-dim) data; The method for the unbinned empirical distribution are based on the kernel smoothing, see; <A href=""http://statmath.wu-wien.ac.at/software/unuran/doc/unuran.html#EMPK"">UnuRan doc</A>; A re-initialization is needed whenever distribution parameters have been changed. bool InitPoisson(double mu, const string& method = ""dstd""). Initialize method for the Poisson distribution; Used to generate poisson numbers for a constant parameter mu of the Poisson distribution.; Use after t",MatchSource.WIKI,root/html532/TUnuran.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnuran.html
https://root.cern/root/html532/TUnuran.html:7851,Availability,error,error,7851,"ged in the subsequent calls.; If the same TUnuran object is used to generate with other distributions it cannot be used. bool ReInitDiscrDist(unsigned int npar, double* params). Reinitialize UNURAN by changing the distribution parameters but mantaining same distribution and method; It is implemented now only for predefined discrete distributions like the poisson or the binomial. double Sample(). Sample 1D distribution; User is responsible for having previously correctly initialized with TUnuran::Init. bool SampleMulti(double* x). Sample multidimensional distributions; User is responsible for having previously correctly initialized with TUnuran::Init. int SampleDiscr(). Sample discrete distributions; User is responsible for having previously correctly initialized with TUnuran::Init. void SetRandom(TRandom* r). set the random engine.; Must be called before init to have effect. TRandom * GetRandom(). return instance of the random engine used. void SetSeed(unsigned int seed). set the seed for the random number generator. bool SetLogLevel(unsigned int iflag = 1). set log level. bool SetLogStream(). set stream for log and error (not yet implemented). { return false;}. const std::string & MethodName() const. used Unuran method. { return fMethod; }. bool SetRandomGenerator(). bool SetContDistribution(const TUnuranContDist& dist). bool SetMultiDistribution(const TUnuranMultiContDist& dist). bool SetDiscreteDistribution(const TUnuranDiscrDist& dist). bool SetEmpiricalDistribution(const TUnuranEmpDist& dist). bool SetMethodAndInit(). change the method and initialize Unuran with the previously given distribution. » Author: L. Moneta Tue Sep 26 16:25:09 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/unuran:$Id: TUnuran.h 36306 2010-10-11 18:55:19Z moneta $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TUnuran.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnuran.html
https://root.cern/root/html532/TUnuran.html:3875,Deployability,continuous,continuous,3875,"Generator(). private:. TUnuran(const TUnuran&); TUnuran&operator=(const TUnuran& rhs). Data Members; protected:. auto_ptr<TUnuranBaseDist>fDistpointer for distribution wrapper; unur_gen*fGenpointer to the UnuRan C generator struct; stringfMethodstring representing the method; TRandom*fRngpointer to ROOT random number generator; unur_distr*fUdistrpointer to the UnuRan C distribution struct; unur_urng*fUrngpointer to Unuran C random generator struct . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnuran(TRandom* r = 0, unsigned int log = 0). Constructor with a generator instance and given level of log output. ~TUnuran(). Destructor. TUnuran(const TUnuran& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. bool Init(const std::string & distr, const std::string & method). initialize with Unuran string interface. bool Init(const TUnuranContDist& distr, const string& method = ""auto""). Initialize method for continuous one-dimensional distribution.; User must provide a distribution object (which is copied inside) and a string for a method.; For the list of available method for 1D cont. distribution see the; <A href=""http://statmath.wu-wien.ac.at/unuran/doc/unuran.html#Methods_005ffor_005fCONT"">UnuRan doc</A>.; A re-initialization is needed whenever distribution parameters have been changed. bool Init(const TUnuranMultiContDist& distr, const string& method = ""hitro""). Initialize method for continuous multi-dimensional distribution.; User must provide a distribution object (which is copied inside) and a string for a method.; For the list of available method for multivariate cont. distribution see the; <A href=""http://statmath.wu-wien.ac.at/unuran/doc/unuran.html#Methods_005ffor_005fCVEC"">UnuRan doc</A>; A re-initialization is needed whenever distribution parameters have been changed. bool Init(const TUnuranDiscrDist& distr, const string& method = ""auto""). Initialize method for continuous one-dimensio",MatchSource.WIKI,root/html532/TUnuran.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnuran.html
https://root.cern/root/html532/TUnuran.html:4365,Deployability,continuous,continuous,4365,"Members; Includes; Libraries. Function documentation; TUnuran(TRandom* r = 0, unsigned int log = 0). Constructor with a generator instance and given level of log output. ~TUnuran(). Destructor. TUnuran(const TUnuran& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. bool Init(const std::string & distr, const std::string & method). initialize with Unuran string interface. bool Init(const TUnuranContDist& distr, const string& method = ""auto""). Initialize method for continuous one-dimensional distribution.; User must provide a distribution object (which is copied inside) and a string for a method.; For the list of available method for 1D cont. distribution see the; <A href=""http://statmath.wu-wien.ac.at/unuran/doc/unuran.html#Methods_005ffor_005fCONT"">UnuRan doc</A>.; A re-initialization is needed whenever distribution parameters have been changed. bool Init(const TUnuranMultiContDist& distr, const string& method = ""hitro""). Initialize method for continuous multi-dimensional distribution.; User must provide a distribution object (which is copied inside) and a string for a method.; For the list of available method for multivariate cont. distribution see the; <A href=""http://statmath.wu-wien.ac.at/unuran/doc/unuran.html#Methods_005ffor_005fCVEC"">UnuRan doc</A>; A re-initialization is needed whenever distribution parameters have been changed. bool Init(const TUnuranDiscrDist& distr, const string& method = ""auto""). Initialize method for continuous one-dimensional discrete distribution.; User must provide a distribution object (which is copied inside) and a string for a method.; For the list of available method for 1D discrete distribution see the; <A href=""http://statmath.wu-wien.ac.at/unuran/doc/unuran.html#Methods_005ffor_005fDISCR"">UnuRan doc</A>; A re-initialization is needed whenever distribution parameters have been changed. bool Init(const TUnuranEmpDist& distr, const string& method = ""empk""). Initialize method for continuous empirica",MatchSource.WIKI,root/html532/TUnuran.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnuran.html
https://root.cern/root/html532/TUnuran.html:4861,Deployability,continuous,continuous,4861," continuous one-dimensional distribution.; User must provide a distribution object (which is copied inside) and a string for a method.; For the list of available method for 1D cont. distribution see the; <A href=""http://statmath.wu-wien.ac.at/unuran/doc/unuran.html#Methods_005ffor_005fCONT"">UnuRan doc</A>.; A re-initialization is needed whenever distribution parameters have been changed. bool Init(const TUnuranMultiContDist& distr, const string& method = ""hitro""). Initialize method for continuous multi-dimensional distribution.; User must provide a distribution object (which is copied inside) and a string for a method.; For the list of available method for multivariate cont. distribution see the; <A href=""http://statmath.wu-wien.ac.at/unuran/doc/unuran.html#Methods_005ffor_005fCVEC"">UnuRan doc</A>; A re-initialization is needed whenever distribution parameters have been changed. bool Init(const TUnuranDiscrDist& distr, const string& method = ""auto""). Initialize method for continuous one-dimensional discrete distribution.; User must provide a distribution object (which is copied inside) and a string for a method.; For the list of available method for 1D discrete distribution see the; <A href=""http://statmath.wu-wien.ac.at/unuran/doc/unuran.html#Methods_005ffor_005fDISCR"">UnuRan doc</A>; A re-initialization is needed whenever distribution parameters have been changed. bool Init(const TUnuranEmpDist& distr, const string& method = ""empk""). Initialize method for continuous empirical distribution.; User must provide a distribution object (which is copied inside) and a string for a method.; The distribution object can represent binned (only 1D) or unbinned (1D or multi-dim) data; The method for the unbinned empirical distribution are based on the kernel smoothing, see; <A href=""http://statmath.wu-wien.ac.at/software/unuran/doc/unuran.html#EMPK"">UnuRan doc</A>; A re-initialization is needed whenever distribution parameters have been changed. bool InitPoisson(double mu, cons",MatchSource.WIKI,root/html532/TUnuran.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnuran.html
https://root.cern/root/html532/TUnuran.html:5356,Deployability,continuous,continuous,5356,"for continuous multi-dimensional distribution.; User must provide a distribution object (which is copied inside) and a string for a method.; For the list of available method for multivariate cont. distribution see the; <A href=""http://statmath.wu-wien.ac.at/unuran/doc/unuran.html#Methods_005ffor_005fCVEC"">UnuRan doc</A>; A re-initialization is needed whenever distribution parameters have been changed. bool Init(const TUnuranDiscrDist& distr, const string& method = ""auto""). Initialize method for continuous one-dimensional discrete distribution.; User must provide a distribution object (which is copied inside) and a string for a method.; For the list of available method for 1D discrete distribution see the; <A href=""http://statmath.wu-wien.ac.at/unuran/doc/unuran.html#Methods_005ffor_005fDISCR"">UnuRan doc</A>; A re-initialization is needed whenever distribution parameters have been changed. bool Init(const TUnuranEmpDist& distr, const string& method = ""empk""). Initialize method for continuous empirical distribution.; User must provide a distribution object (which is copied inside) and a string for a method.; The distribution object can represent binned (only 1D) or unbinned (1D or multi-dim) data; The method for the unbinned empirical distribution are based on the kernel smoothing, see; <A href=""http://statmath.wu-wien.ac.at/software/unuran/doc/unuran.html#EMPK"">UnuRan doc</A>; A re-initialization is needed whenever distribution parameters have been changed. bool InitPoisson(double mu, const string& method = ""dstd""). Initialize method for the Poisson distribution; Used to generate poisson numbers for a constant parameter mu of the Poisson distribution.; Use after the method TUnuran::SampleDiscr to generate the numbers.; The flag reinit perform a fast re-initialization when only the distribution parameters; are changed in the subsequent calls.; If the same TUnuran object is used to generate with other distributions it cannot be used. bool InitBinomial(unsigned int ntot,",MatchSource.WIKI,root/html532/TUnuran.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnuran.html
https://root.cern/root/html532/TUnuran.html:260,Integrability,Interface,Interface,260,". TUnuran. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » UNURAN; » TUnuran. class TUnuran. TUnuran class.; Interface to the UNU.RAN package for generating non uniform random; numbers. This class wraps the UNU.RAN calls in C++ methods.; It provides methods for initializing Unuran and then to sample the; desired distribution.; It provides support for initializing UNU.RAN in these following way (various signatures; for TUnuran::Init); - with string API via TUnuran::Init passing the distribution type and the method; - using a one-dimensional distribution object defined by TUnuranContDist; - using a multi-dimensional distribution object defined by TUnuranMultiContDist; - using a discrete one-dimensional distribution object defined by TUnuranDiscrDist; - using an empirical distribution defined by TUnuranEmpDist; - using pre-defined distributions. Presently only support for Poisson (TUnuran::InitPoisson); and Binomial (TUnuran::InitBinomial) are provided. Other distributions can however be generated; using the previous methods (in particular via the string API). The sampling is provided via these methods:; - TUnuran::Sample() returns a double for all one-dimensional distribution; - TUnuran::SampleDiscr() returns an integer for one-dimensional discrete distribution; - TUnuran::Sample(double *) sample a multi-dimensional distribution. A pointer to a vector with; size at least equal to the distribution dimension must be passed. In addition is possible to set the random number generator in the constructor of the class, its seed; via the TUnuran::SetSeed() method. Function Members (Methods); public:. TUnuran(TRandom* r = 0, unsigned int log = 0); ~TUnuran(); TRandom*GetRandom(); boolInit(const string& distr, const string& method); boolInit(const TUnuranContDist& distr, const string& method = ""auto""); boolInit(const TUnuranMultiC",MatchSource.WIKI,root/html532/TUnuran.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnuran.html
https://root.cern/root/html532/TUnuran.html:348,Integrability,wrap,wraps,348,". TUnuran. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » UNURAN; » TUnuran. class TUnuran. TUnuran class.; Interface to the UNU.RAN package for generating non uniform random; numbers. This class wraps the UNU.RAN calls in C++ methods.; It provides methods for initializing Unuran and then to sample the; desired distribution.; It provides support for initializing UNU.RAN in these following way (various signatures; for TUnuran::Init); - with string API via TUnuran::Init passing the distribution type and the method; - using a one-dimensional distribution object defined by TUnuranContDist; - using a multi-dimensional distribution object defined by TUnuranMultiContDist; - using a discrete one-dimensional distribution object defined by TUnuranDiscrDist; - using an empirical distribution defined by TUnuranEmpDist; - using pre-defined distributions. Presently only support for Poisson (TUnuran::InitPoisson); and Binomial (TUnuran::InitBinomial) are provided. Other distributions can however be generated; using the previous methods (in particular via the string API). The sampling is provided via these methods:; - TUnuran::Sample() returns a double for all one-dimensional distribution; - TUnuran::SampleDiscr() returns an integer for one-dimensional discrete distribution; - TUnuran::Sample(double *) sample a multi-dimensional distribution. A pointer to a vector with; size at least equal to the distribution dimension must be passed. In addition is possible to set the random number generator in the constructor of the class, its seed; via the TUnuran::SetSeed() method. Function Members (Methods); public:. TUnuran(TRandom* r = 0, unsigned int log = 0); ~TUnuran(); TRandom*GetRandom(); boolInit(const string& distr, const string& method); boolInit(const TUnuranContDist& distr, const string& method = ""auto""); boolInit(const TUnuranMultiC",MatchSource.WIKI,root/html532/TUnuran.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnuran.html
https://root.cern/root/html532/TUnuran.html:3051,Integrability,wrap,wrapper,3051," string& method = ""empk""); boolInitBinomial(unsigned int ntot, double prob, const string& method = ""dstd""); boolInitPoisson(double mu, const string& method = ""dstd""); const string&MethodName() const; boolReInitDiscrDist(unsigned int npar, double* params); doubleSample(); intSampleDiscr(); boolSampleMulti(double* x); boolSetLogLevel(unsigned int iflag = 1); boolSetLogStream(); voidSetRandom(TRandom* r); voidSetSeed(unsigned int seed). protected:. boolSetContDistribution(const TUnuranContDist& dist); boolSetDiscreteDistribution(const TUnuranDiscrDist& dist); boolSetEmpiricalDistribution(const TUnuranEmpDist& dist); boolSetMethodAndInit(); boolSetMultiDistribution(const TUnuranMultiContDist& dist); boolSetRandomGenerator(). private:. TUnuran(const TUnuran&); TUnuran&operator=(const TUnuran& rhs). Data Members; protected:. auto_ptr<TUnuranBaseDist>fDistpointer for distribution wrapper; unur_gen*fGenpointer to the UnuRan C generator struct; stringfMethodstring representing the method; TRandom*fRngpointer to ROOT random number generator; unur_distr*fUdistrpointer to the UnuRan C distribution struct; unur_urng*fUrngpointer to Unuran C random generator struct . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnuran(TRandom* r = 0, unsigned int log = 0). Constructor with a generator instance and given level of log output. ~TUnuran(). Destructor. TUnuran(const TUnuran& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. bool Init(const std::string & distr, const std::string & method). initialize with Unuran string interface. bool Init(const TUnuranContDist& distr, const string& method = ""auto""). Initialize method for continuous one-dimensional distribution.; User must provide a distribution object (which is copied inside) and a string for a method.; For the list of available method for 1D cont. distribution see the; <A href=""http://statmath.wu-wien.ac.at/unuran/doc/unuran.html#Methods_005ffor_005fCONT"">",MatchSource.WIKI,root/html532/TUnuran.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnuran.html
https://root.cern/root/html532/TUnuran.html:3770,Integrability,interface,interface,3770,"nst TUnuranEmpDist& dist); boolSetMethodAndInit(); boolSetMultiDistribution(const TUnuranMultiContDist& dist); boolSetRandomGenerator(). private:. TUnuran(const TUnuran&); TUnuran&operator=(const TUnuran& rhs). Data Members; protected:. auto_ptr<TUnuranBaseDist>fDistpointer for distribution wrapper; unur_gen*fGenpointer to the UnuRan C generator struct; stringfMethodstring representing the method; TRandom*fRngpointer to ROOT random number generator; unur_distr*fUdistrpointer to the UnuRan C distribution struct; unur_urng*fUrngpointer to Unuran C random generator struct . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnuran(TRandom* r = 0, unsigned int log = 0). Constructor with a generator instance and given level of log output. ~TUnuran(). Destructor. TUnuran(const TUnuran& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. bool Init(const std::string & distr, const std::string & method). initialize with Unuran string interface. bool Init(const TUnuranContDist& distr, const string& method = ""auto""). Initialize method for continuous one-dimensional distribution.; User must provide a distribution object (which is copied inside) and a string for a method.; For the list of available method for 1D cont. distribution see the; <A href=""http://statmath.wu-wien.ac.at/unuran/doc/unuran.html#Methods_005ffor_005fCONT"">UnuRan doc</A>.; A re-initialization is needed whenever distribution parameters have been changed. bool Init(const TUnuranMultiContDist& distr, const string& method = ""hitro""). Initialize method for continuous multi-dimensional distribution.; User must provide a distribution object (which is copied inside) and a string for a method.; For the list of available method for multivariate cont. distribution see the; <A href=""http://statmath.wu-wien.ac.at/unuran/doc/unuran.html#Methods_005ffor_005fCVEC"">UnuRan doc</A>; A re-initialization is needed whenever distribution parameters have been cha",MatchSource.WIKI,root/html532/TUnuran.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnuran.html
https://root.cern/root/html532/TUnuran.html:3351,Modifiability,Inherit,Inheritance,3351,"iscrDist(unsigned int npar, double* params); doubleSample(); intSampleDiscr(); boolSampleMulti(double* x); boolSetLogLevel(unsigned int iflag = 1); boolSetLogStream(); voidSetRandom(TRandom* r); voidSetSeed(unsigned int seed). protected:. boolSetContDistribution(const TUnuranContDist& dist); boolSetDiscreteDistribution(const TUnuranDiscrDist& dist); boolSetEmpiricalDistribution(const TUnuranEmpDist& dist); boolSetMethodAndInit(); boolSetMultiDistribution(const TUnuranMultiContDist& dist); boolSetRandomGenerator(). private:. TUnuran(const TUnuran&); TUnuran&operator=(const TUnuran& rhs). Data Members; protected:. auto_ptr<TUnuranBaseDist>fDistpointer for distribution wrapper; unur_gen*fGenpointer to the UnuRan C generator struct; stringfMethodstring representing the method; TRandom*fRngpointer to ROOT random number generator; unur_distr*fUdistrpointer to the UnuRan C distribution struct; unur_urng*fUrngpointer to Unuran C random generator struct . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnuran(TRandom* r = 0, unsigned int log = 0). Constructor with a generator instance and given level of log output. ~TUnuran(). Destructor. TUnuran(const TUnuran& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. bool Init(const std::string & distr, const std::string & method). initialize with Unuran string interface. bool Init(const TUnuranContDist& distr, const string& method = ""auto""). Initialize method for continuous one-dimensional distribution.; User must provide a distribution object (which is copied inside) and a string for a method.; For the list of available method for 1D cont. distribution see the; <A href=""http://statmath.wu-wien.ac.at/unuran/doc/unuran.html#Methods_005ffor_005fCONT"">UnuRan doc</A>.; A re-initialization is needed whenever distribution parameters have been changed. bool Init(const TUnuranMultiContDist& distr, const string& method = ""hitro""). Initialize method for continuous m",MatchSource.WIKI,root/html532/TUnuran.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnuran.html
https://root.cern/root/html532/TUnuran.html:3364,Modifiability,Inherit,Inherited,3364,"iscrDist(unsigned int npar, double* params); doubleSample(); intSampleDiscr(); boolSampleMulti(double* x); boolSetLogLevel(unsigned int iflag = 1); boolSetLogStream(); voidSetRandom(TRandom* r); voidSetSeed(unsigned int seed). protected:. boolSetContDistribution(const TUnuranContDist& dist); boolSetDiscreteDistribution(const TUnuranDiscrDist& dist); boolSetEmpiricalDistribution(const TUnuranEmpDist& dist); boolSetMethodAndInit(); boolSetMultiDistribution(const TUnuranMultiContDist& dist); boolSetRandomGenerator(). private:. TUnuran(const TUnuran&); TUnuran&operator=(const TUnuran& rhs). Data Members; protected:. auto_ptr<TUnuranBaseDist>fDistpointer for distribution wrapper; unur_gen*fGenpointer to the UnuRan C generator struct; stringfMethodstring representing the method; TRandom*fRngpointer to ROOT random number generator; unur_distr*fUdistrpointer to the UnuRan C distribution struct; unur_urng*fUrngpointer to Unuran C random generator struct . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnuran(TRandom* r = 0, unsigned int log = 0). Constructor with a generator instance and given level of log output. ~TUnuran(). Destructor. TUnuran(const TUnuran& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. bool Init(const std::string & distr, const std::string & method). initialize with Unuran string interface. bool Init(const TUnuranContDist& distr, const string& method = ""auto""). Initialize method for continuous one-dimensional distribution.; User must provide a distribution object (which is copied inside) and a string for a method.; For the list of available method for 1D cont. distribution see the; <A href=""http://statmath.wu-wien.ac.at/unuran/doc/unuran.html#Methods_005ffor_005fCONT"">UnuRan doc</A>.; A re-initialization is needed whenever distribution parameters have been changed. bool Init(const TUnuranMultiContDist& distr, const string& method = ""hitro""). Initialize method for continuous m",MatchSource.WIKI,root/html532/TUnuran.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnuran.html
https://root.cern/root/html532/TUnuran.html:6125,Performance,perform,perform,6125,"n doc</A>; A re-initialization is needed whenever distribution parameters have been changed. bool Init(const TUnuranEmpDist& distr, const string& method = ""empk""). Initialize method for continuous empirical distribution.; User must provide a distribution object (which is copied inside) and a string for a method.; The distribution object can represent binned (only 1D) or unbinned (1D or multi-dim) data; The method for the unbinned empirical distribution are based on the kernel smoothing, see; <A href=""http://statmath.wu-wien.ac.at/software/unuran/doc/unuran.html#EMPK"">UnuRan doc</A>; A re-initialization is needed whenever distribution parameters have been changed. bool InitPoisson(double mu, const string& method = ""dstd""). Initialize method for the Poisson distribution; Used to generate poisson numbers for a constant parameter mu of the Poisson distribution.; Use after the method TUnuran::SampleDiscr to generate the numbers.; The flag reinit perform a fast re-initialization when only the distribution parameters; are changed in the subsequent calls.; If the same TUnuran object is used to generate with other distributions it cannot be used. bool InitBinomial(unsigned int ntot, double prob, const string& method = ""dstd""). Initialize method for the Binomial distribution; Used to generate poisson numbers for a constant parameters (n,p) of the Binomial distribution.; Use after the method TUnuran::SampleDiscr to generate the numbers.; The flag reinit perform a fast re-initialization when only the distribution parameters; are changed in the subsequent calls.; If the same TUnuran object is used to generate with other distributions it cannot be used. bool ReInitDiscrDist(unsigned int npar, double* params). Reinitialize UNURAN by changing the distribution parameters but mantaining same distribution and method; It is implemented now only for predefined discrete distributions like the poisson or the binomial. double Sample(). Sample 1D distribution; User is responsible for having",MatchSource.WIKI,root/html532/TUnuran.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnuran.html
https://root.cern/root/html532/TUnuran.html:6637,Performance,perform,perform,6637,"/statmath.wu-wien.ac.at/software/unuran/doc/unuran.html#EMPK"">UnuRan doc</A>; A re-initialization is needed whenever distribution parameters have been changed. bool InitPoisson(double mu, const string& method = ""dstd""). Initialize method for the Poisson distribution; Used to generate poisson numbers for a constant parameter mu of the Poisson distribution.; Use after the method TUnuran::SampleDiscr to generate the numbers.; The flag reinit perform a fast re-initialization when only the distribution parameters; are changed in the subsequent calls.; If the same TUnuran object is used to generate with other distributions it cannot be used. bool InitBinomial(unsigned int ntot, double prob, const string& method = ""dstd""). Initialize method for the Binomial distribution; Used to generate poisson numbers for a constant parameters (n,p) of the Binomial distribution.; Use after the method TUnuran::SampleDiscr to generate the numbers.; The flag reinit perform a fast re-initialization when only the distribution parameters; are changed in the subsequent calls.; If the same TUnuran object is used to generate with other distributions it cannot be used. bool ReInitDiscrDist(unsigned int npar, double* params). Reinitialize UNURAN by changing the distribution parameters but mantaining same distribution and method; It is implemented now only for predefined discrete distributions like the poisson or the binomial. double Sample(). Sample 1D distribution; User is responsible for having previously correctly initialized with TUnuran::Init. bool SampleMulti(double* x). Sample multidimensional distributions; User is responsible for having previously correctly initialized with TUnuran::Init. int SampleDiscr(). Sample discrete distributions; User is responsible for having previously correctly initialized with TUnuran::Init. void SetRandom(TRandom* r). set the random engine.; Must be called before init to have effect. TRandom * GetRandom(). return instance of the random engine used. void SetSee",MatchSource.WIKI,root/html532/TUnuran.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnuran.html
https://root.cern/root/html532/TUnuran.html:1806,Testability,log,log,1806,"ods (in particular via the string API). The sampling is provided via these methods:; - TUnuran::Sample() returns a double for all one-dimensional distribution; - TUnuran::SampleDiscr() returns an integer for one-dimensional discrete distribution; - TUnuran::Sample(double *) sample a multi-dimensional distribution. A pointer to a vector with; size at least equal to the distribution dimension must be passed. In addition is possible to set the random number generator in the constructor of the class, its seed; via the TUnuran::SetSeed() method. Function Members (Methods); public:. TUnuran(TRandom* r = 0, unsigned int log = 0); ~TUnuran(); TRandom*GetRandom(); boolInit(const string& distr, const string& method); boolInit(const TUnuranContDist& distr, const string& method = ""auto""); boolInit(const TUnuranMultiContDist& distr, const string& method = ""hitro""); boolInit(const TUnuranDiscrDist& distr, const string& method = ""auto""); boolInit(const TUnuranEmpDist& distr, const string& method = ""empk""); boolInitBinomial(unsigned int ntot, double prob, const string& method = ""dstd""); boolInitPoisson(double mu, const string& method = ""dstd""); const string&MethodName() const; boolReInitDiscrDist(unsigned int npar, double* params); doubleSample(); intSampleDiscr(); boolSampleMulti(double* x); boolSetLogLevel(unsigned int iflag = 1); boolSetLogStream(); voidSetRandom(TRandom* r); voidSetSeed(unsigned int seed). protected:. boolSetContDistribution(const TUnuranContDist& dist); boolSetDiscreteDistribution(const TUnuranDiscrDist& dist); boolSetEmpiricalDistribution(const TUnuranEmpDist& dist); boolSetMethodAndInit(); boolSetMultiDistribution(const TUnuranMultiContDist& dist); boolSetRandomGenerator(). private:. TUnuran(const TUnuran&); TUnuran&operator=(const TUnuran& rhs). Data Members; protected:. auto_ptr<TUnuranBaseDist>fDistpointer for distribution wrapper; unur_gen*fGenpointer to the UnuRan C generator struct; stringfMethodstring representing the method; TRandom*fRngpointer to RO",MatchSource.WIKI,root/html532/TUnuran.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnuran.html
https://root.cern/root/html532/TUnuran.html:3465,Testability,log,log,3465,"ntSampleDiscr(); boolSampleMulti(double* x); boolSetLogLevel(unsigned int iflag = 1); boolSetLogStream(); voidSetRandom(TRandom* r); voidSetSeed(unsigned int seed). protected:. boolSetContDistribution(const TUnuranContDist& dist); boolSetDiscreteDistribution(const TUnuranDiscrDist& dist); boolSetEmpiricalDistribution(const TUnuranEmpDist& dist); boolSetMethodAndInit(); boolSetMultiDistribution(const TUnuranMultiContDist& dist); boolSetRandomGenerator(). private:. TUnuran(const TUnuran&); TUnuran&operator=(const TUnuran& rhs). Data Members; protected:. auto_ptr<TUnuranBaseDist>fDistpointer for distribution wrapper; unur_gen*fGenpointer to the UnuRan C generator struct; stringfMethodstring representing the method; TRandom*fRngpointer to ROOT random number generator; unur_distr*fUdistrpointer to the UnuRan C distribution struct; unur_urng*fUrngpointer to Unuran C random generator struct . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnuran(TRandom* r = 0, unsigned int log = 0). Constructor with a generator instance and given level of log output. ~TUnuran(). Destructor. TUnuran(const TUnuran& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. bool Init(const std::string & distr, const std::string & method). initialize with Unuran string interface. bool Init(const TUnuranContDist& distr, const string& method = ""auto""). Initialize method for continuous one-dimensional distribution.; User must provide a distribution object (which is copied inside) and a string for a method.; For the list of available method for 1D cont. distribution see the; <A href=""http://statmath.wu-wien.ac.at/unuran/doc/unuran.html#Methods_005ffor_005fCONT"">UnuRan doc</A>.; A re-initialization is needed whenever distribution parameters have been changed. bool Init(const TUnuranMultiContDist& distr, const string& method = ""hitro""). Initialize method for continuous multi-dimensional distribution.; User must provide a distributi",MatchSource.WIKI,root/html532/TUnuran.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnuran.html
https://root.cern/root/html532/TUnuran.html:3532,Testability,log,log,3532,"int iflag = 1); boolSetLogStream(); voidSetRandom(TRandom* r); voidSetSeed(unsigned int seed). protected:. boolSetContDistribution(const TUnuranContDist& dist); boolSetDiscreteDistribution(const TUnuranDiscrDist& dist); boolSetEmpiricalDistribution(const TUnuranEmpDist& dist); boolSetMethodAndInit(); boolSetMultiDistribution(const TUnuranMultiContDist& dist); boolSetRandomGenerator(). private:. TUnuran(const TUnuran&); TUnuran&operator=(const TUnuran& rhs). Data Members; protected:. auto_ptr<TUnuranBaseDist>fDistpointer for distribution wrapper; unur_gen*fGenpointer to the UnuRan C generator struct; stringfMethodstring representing the method; TRandom*fRngpointer to ROOT random number generator; unur_distr*fUdistrpointer to the UnuRan C distribution struct; unur_urng*fUrngpointer to Unuran C random generator struct . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnuran(TRandom* r = 0, unsigned int log = 0). Constructor with a generator instance and given level of log output. ~TUnuran(). Destructor. TUnuran(const TUnuran& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. bool Init(const std::string & distr, const std::string & method). initialize with Unuran string interface. bool Init(const TUnuranContDist& distr, const string& method = ""auto""). Initialize method for continuous one-dimensional distribution.; User must provide a distribution object (which is copied inside) and a string for a method.; For the list of available method for 1D cont. distribution see the; <A href=""http://statmath.wu-wien.ac.at/unuran/doc/unuran.html#Methods_005ffor_005fCONT"">UnuRan doc</A>.; A re-initialization is needed whenever distribution parameters have been changed. bool Init(const TUnuranMultiContDist& distr, const string& method = ""hitro""). Initialize method for continuous multi-dimensional distribution.; User must provide a distribution object (which is copied inside) and a string for a method.; For the",MatchSource.WIKI,root/html532/TUnuran.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnuran.html
https://root.cern/root/html532/TUnuran.html:7796,Testability,log,log,7796,"ged in the subsequent calls.; If the same TUnuran object is used to generate with other distributions it cannot be used. bool ReInitDiscrDist(unsigned int npar, double* params). Reinitialize UNURAN by changing the distribution parameters but mantaining same distribution and method; It is implemented now only for predefined discrete distributions like the poisson or the binomial. double Sample(). Sample 1D distribution; User is responsible for having previously correctly initialized with TUnuran::Init. bool SampleMulti(double* x). Sample multidimensional distributions; User is responsible for having previously correctly initialized with TUnuran::Init. int SampleDiscr(). Sample discrete distributions; User is responsible for having previously correctly initialized with TUnuran::Init. void SetRandom(TRandom* r). set the random engine.; Must be called before init to have effect. TRandom * GetRandom(). return instance of the random engine used. void SetSeed(unsigned int seed). set the seed for the random number generator. bool SetLogLevel(unsigned int iflag = 1). set log level. bool SetLogStream(). set stream for log and error (not yet implemented). { return false;}. const std::string & MethodName() const. used Unuran method. { return fMethod; }. bool SetRandomGenerator(). bool SetContDistribution(const TUnuranContDist& dist). bool SetMultiDistribution(const TUnuranMultiContDist& dist). bool SetDiscreteDistribution(const TUnuranDiscrDist& dist). bool SetEmpiricalDistribution(const TUnuranEmpDist& dist). bool SetMethodAndInit(). change the method and initialize Unuran with the previously given distribution. » Author: L. Moneta Tue Sep 26 16:25:09 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/unuran:$Id: TUnuran.h 36306 2010-10-11 18:55:19Z moneta $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TUnuran.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnuran.html
https://root.cern/root/html532/TUnuran.html:7843,Testability,log,log,7843,"ged in the subsequent calls.; If the same TUnuran object is used to generate with other distributions it cannot be used. bool ReInitDiscrDist(unsigned int npar, double* params). Reinitialize UNURAN by changing the distribution parameters but mantaining same distribution and method; It is implemented now only for predefined discrete distributions like the poisson or the binomial. double Sample(). Sample 1D distribution; User is responsible for having previously correctly initialized with TUnuran::Init. bool SampleMulti(double* x). Sample multidimensional distributions; User is responsible for having previously correctly initialized with TUnuran::Init. int SampleDiscr(). Sample discrete distributions; User is responsible for having previously correctly initialized with TUnuran::Init. void SetRandom(TRandom* r). set the random engine.; Must be called before init to have effect. TRandom * GetRandom(). return instance of the random engine used. void SetSeed(unsigned int seed). set the seed for the random number generator. bool SetLogLevel(unsigned int iflag = 1). set log level. bool SetLogStream(). set stream for log and error (not yet implemented). { return false;}. const std::string & MethodName() const. used Unuran method. { return fMethod; }. bool SetRandomGenerator(). bool SetContDistribution(const TUnuranContDist& dist). bool SetMultiDistribution(const TUnuranMultiContDist& dist). bool SetDiscreteDistribution(const TUnuranDiscrDist& dist). bool SetEmpiricalDistribution(const TUnuranEmpDist& dist). bool SetMethodAndInit(). change the method and initialize Unuran with the previously given distribution. » Author: L. Moneta Tue Sep 26 16:25:09 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/unuran:$Id: TUnuran.h 36306 2010-10-11 18:55:19Z moneta $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TUnuran.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnuran.html
https://root.cern/root/html532/TUnuranBaseDist.html:551,Availability,avail,available,551,". TUnuranBaseDist. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » UNURAN; » TUnuranBaseDist. class TUnuranBaseDist. TUnuranBaseDist, base class for Unuran distribution classees such as; TUnuranContDist (for one-dimension) or TUnuranMultiContDist (multi-dimension). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TUnuranBaseDist(); static TClass*Class(); virtual TUnuranBaseDist*Clone() const; virtual TClass*IsA() const; TUnuranBaseDist&operator=(const TUnuranBaseDist&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TUnuranBaseDist(). Destructor (no operations). {}. TUnuranBaseDist * Clone() const. Abstract clone method for a deep copy of the derived classes. » Last changed: root/unuran:$Id: TUnuranBaseDist.h 21526 2007-12-20 10:42:41Z moneta $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TUnuranBaseDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnuranBaseDist.html
https://root.cern/root/html532/TUnuranBaseDist.html:884,Modifiability,Inherit,Inheritance,884,". TUnuranBaseDist. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » UNURAN; » TUnuranBaseDist. class TUnuranBaseDist. TUnuranBaseDist, base class for Unuran distribution classees such as; TUnuranContDist (for one-dimension) or TUnuranMultiContDist (multi-dimension). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TUnuranBaseDist(); static TClass*Class(); virtual TUnuranBaseDist*Clone() const; virtual TClass*IsA() const; TUnuranBaseDist&operator=(const TUnuranBaseDist&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TUnuranBaseDist(). Destructor (no operations). {}. TUnuranBaseDist * Clone() const. Abstract clone method for a deep copy of the derived classes. » Last changed: root/unuran:$Id: TUnuranBaseDist.h 21526 2007-12-20 10:42:41Z moneta $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TUnuranBaseDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnuranBaseDist.html
https://root.cern/root/html532/TUnuranBaseDist.html:897,Modifiability,Inherit,Inherited,897,". TUnuranBaseDist. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » UNURAN; » TUnuranBaseDist. class TUnuranBaseDist. TUnuranBaseDist, base class for Unuran distribution classees such as; TUnuranContDist (for one-dimension) or TUnuranMultiContDist (multi-dimension). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TUnuranBaseDist(); static TClass*Class(); virtual TUnuranBaseDist*Clone() const; virtual TClass*IsA() const; TUnuranBaseDist&operator=(const TUnuranBaseDist&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TUnuranBaseDist(). Destructor (no operations). {}. TUnuranBaseDist * Clone() const. Abstract clone method for a deep copy of the derived classes. » Last changed: root/unuran:$Id: TUnuranBaseDist.h 21526 2007-12-20 10:42:41Z moneta $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TUnuranBaseDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnuranBaseDist.html
https://root.cern/root/html532/TUnuranContDist.html:2366,Integrability,interface,interfaces,2366,"Virtual(TBuffer& b). Data Members; private:. doublefAreaarea below pdf; const ROOT::Math::IBaseFunctionOneDim*fCdfpointer to the cdf (cumulative dist.); const ROOT::Math::IBaseFunctionOneDim*fDPdfpointer to the derivative of the pdf; boolfHasAreaflag to control if distribution has a pre-computed area below the pdf; boolfHasDomainflag to control if distribution has a defined domain (otherwise is [-inf,+inf]; boolfHasModeflag to control if distribution has a pre-computed mode; boolfIsLogPdfflag to control if function pointer represent log of pdf; doublefModemode of the distribution; boolfOwnFuncflag to indicate if class manages the function pointers; const ROOT::Math::IBaseFunctionOneDim*fPdfpointer to the pdf ; doublefXmaxupper value of the domain; doublefXminlower value of the domain . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnuranContDist(const ROOT::Math::IGenFunction& pdf, const ROOT::Math::IGenFunction* dpdf = 0, bool isLogPdf = false, bool copyFunc = false); Constructor from generic function interfaces; manage the functions and clone them if flag copyFunc is true. TUnuranContDist(TF1* pdf = 0, TF1* deriv = 0, bool isLogPdf = false); Constructor from a TF1 objects; function pointers are managed by class. TUnuranContDist(const TUnuranContDist& ); Implementation of copy constructor. ~TUnuranContDist(); destructor implementation. void SetCdf(const ROOT::Math::IGenFunction& cdf); set cdf distribution using a generic function interface. void SetCdf(TF1* cdf); set cumulative distribution function from a TF1. double Pdf(double x) const; evaluate the pdf of the distribution. double DPdf(double x) const; evaluate the derivative of the pdf; if derivative function is not given is evaluated numerically. double Cdf(double x) const; evaluate the integral (cdf) on the domain. TUnuranContDist * Clone() const. Clone (required by base class). { return new TUnuranContDist(*this); }. void SetDomain(double xmin, double xmax). Set t",MatchSource.WIKI,root/html532/TUnuranContDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnuranContDist.html
https://root.cern/root/html532/TUnuranContDist.html:2803,Integrability,interface,interface,2803,"s a pre-computed mode; boolfIsLogPdfflag to control if function pointer represent log of pdf; doublefModemode of the distribution; boolfOwnFuncflag to indicate if class manages the function pointers; const ROOT::Math::IBaseFunctionOneDim*fPdfpointer to the pdf ; doublefXmaxupper value of the domain; doublefXminlower value of the domain . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnuranContDist(const ROOT::Math::IGenFunction& pdf, const ROOT::Math::IGenFunction* dpdf = 0, bool isLogPdf = false, bool copyFunc = false); Constructor from generic function interfaces; manage the functions and clone them if flag copyFunc is true. TUnuranContDist(TF1* pdf = 0, TF1* deriv = 0, bool isLogPdf = false); Constructor from a TF1 objects; function pointers are managed by class. TUnuranContDist(const TUnuranContDist& ); Implementation of copy constructor. ~TUnuranContDist(); destructor implementation. void SetCdf(const ROOT::Math::IGenFunction& cdf); set cdf distribution using a generic function interface. void SetCdf(TF1* cdf); set cumulative distribution function from a TF1. double Pdf(double x) const; evaluate the pdf of the distribution. double DPdf(double x) const; evaluate the derivative of the pdf; if derivative function is not given is evaluated numerically. double Cdf(double x) const; evaluate the integral (cdf) on the domain. TUnuranContDist * Clone() const. Clone (required by base class). { return new TUnuranContDist(*this); }. void SetDomain(double xmin, double xmax). Set the distribution domain. If min < max a domain is defined otherwise is undefined. void SetMode(double mode). set the distribution mode (x position of its maximum). { fMode = mode; fHasMode=true;}. void SetPdfArea(double area). set the area below the pdf. { fArea = area; fHasArea=true;}. bool GetDomain(double& xmin, double& xmax) const. check if distribution has a defined domain and return in case its domain. bool HasCdf() const. check if a cdf function is",MatchSource.WIKI,root/html532/TUnuranContDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnuranContDist.html
https://root.cern/root/html532/TUnuranContDist.html:2113,Modifiability,Inherit,Inheritance,2113,"ouble xmax); voidSetMode(double mode); voidSetPdfArea(double area); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; private:. doublefAreaarea below pdf; const ROOT::Math::IBaseFunctionOneDim*fCdfpointer to the cdf (cumulative dist.); const ROOT::Math::IBaseFunctionOneDim*fDPdfpointer to the derivative of the pdf; boolfHasAreaflag to control if distribution has a pre-computed area below the pdf; boolfHasDomainflag to control if distribution has a defined domain (otherwise is [-inf,+inf]; boolfHasModeflag to control if distribution has a pre-computed mode; boolfIsLogPdfflag to control if function pointer represent log of pdf; doublefModemode of the distribution; boolfOwnFuncflag to indicate if class manages the function pointers; const ROOT::Math::IBaseFunctionOneDim*fPdfpointer to the pdf ; doublefXmaxupper value of the domain; doublefXminlower value of the domain . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnuranContDist(const ROOT::Math::IGenFunction& pdf, const ROOT::Math::IGenFunction* dpdf = 0, bool isLogPdf = false, bool copyFunc = false); Constructor from generic function interfaces; manage the functions and clone them if flag copyFunc is true. TUnuranContDist(TF1* pdf = 0, TF1* deriv = 0, bool isLogPdf = false); Constructor from a TF1 objects; function pointers are managed by class. TUnuranContDist(const TUnuranContDist& ); Implementation of copy constructor. ~TUnuranContDist(); destructor implementation. void SetCdf(const ROOT::Math::IGenFunction& cdf); set cdf distribution using a generic function interface. void SetCdf(TF1* cdf); set cumulative distribution function from a TF1. double Pdf(double x) const; evaluate the pdf of the distribution. double DPdf(double x) const; evaluate the derivative of the pdf; if derivative function is not given is evaluated numerically. double Cdf(double x) const; evaluate the integral (cdf) on t",MatchSource.WIKI,root/html532/TUnuranContDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnuranContDist.html
https://root.cern/root/html532/TUnuranContDist.html:2126,Modifiability,Inherit,Inherited,2126,"ouble xmax); voidSetMode(double mode); voidSetPdfArea(double area); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; private:. doublefAreaarea below pdf; const ROOT::Math::IBaseFunctionOneDim*fCdfpointer to the cdf (cumulative dist.); const ROOT::Math::IBaseFunctionOneDim*fDPdfpointer to the derivative of the pdf; boolfHasAreaflag to control if distribution has a pre-computed area below the pdf; boolfHasDomainflag to control if distribution has a defined domain (otherwise is [-inf,+inf]; boolfHasModeflag to control if distribution has a pre-computed mode; boolfIsLogPdfflag to control if function pointer represent log of pdf; doublefModemode of the distribution; boolfOwnFuncflag to indicate if class manages the function pointers; const ROOT::Math::IBaseFunctionOneDim*fPdfpointer to the pdf ; doublefXmaxupper value of the domain; doublefXminlower value of the domain . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnuranContDist(const ROOT::Math::IGenFunction& pdf, const ROOT::Math::IGenFunction* dpdf = 0, bool isLogPdf = false, bool copyFunc = false); Constructor from generic function interfaces; manage the functions and clone them if flag copyFunc is true. TUnuranContDist(TF1* pdf = 0, TF1* deriv = 0, bool isLogPdf = false); Constructor from a TF1 objects; function pointers are managed by class. TUnuranContDist(const TUnuranContDist& ); Implementation of copy constructor. ~TUnuranContDist(); destructor implementation. void SetCdf(const ROOT::Math::IGenFunction& cdf); set cdf distribution using a generic function interface. void SetCdf(TF1* cdf); set cumulative distribution function from a TF1. double Pdf(double x) const; evaluate the pdf of the distribution. double DPdf(double x) const; evaluate the derivative of the pdf; if derivative function is not given is evaluated numerically. double Cdf(double x) const; evaluate the integral (cdf) on t",MatchSource.WIKI,root/html532/TUnuranContDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnuranContDist.html
https://root.cern/root/html532/TUnuranContDist.html:1841,Testability,log,log,1841,"n, double& xmax) const; boolHasCdf() const; boolHasMode() const; boolHasPdfArea() const; virtual TClass*IsA() const; boolIsLogPdf() const; doubleMode() const; TUnuranContDist&operator=(const TUnuranContDist& rhs); doublePdf(double x) const; doublePdfArea() const; voidSetCdf(TF1* cdf); voidSetCdf(const ROOT::Math::IGenFunction& cdf); voidSetDomain(double xmin, double xmax); voidSetMode(double mode); voidSetPdfArea(double area); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; private:. doublefAreaarea below pdf; const ROOT::Math::IBaseFunctionOneDim*fCdfpointer to the cdf (cumulative dist.); const ROOT::Math::IBaseFunctionOneDim*fDPdfpointer to the derivative of the pdf; boolfHasAreaflag to control if distribution has a pre-computed area below the pdf; boolfHasDomainflag to control if distribution has a defined domain (otherwise is [-inf,+inf]; boolfHasModeflag to control if distribution has a pre-computed mode; boolfIsLogPdfflag to control if function pointer represent log of pdf; doublefModemode of the distribution; boolfOwnFuncflag to indicate if class manages the function pointers; const ROOT::Math::IBaseFunctionOneDim*fPdfpointer to the pdf ; doublefXmaxupper value of the domain; doublefXminlower value of the domain . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnuranContDist(const ROOT::Math::IGenFunction& pdf, const ROOT::Math::IGenFunction* dpdf = 0, bool isLogPdf = false, bool copyFunc = false); Constructor from generic function interfaces; manage the functions and clone them if flag copyFunc is true. TUnuranContDist(TF1* pdf = 0, TF1* deriv = 0, bool isLogPdf = false); Constructor from a TF1 objects; function pointers are managed by class. TUnuranContDist(const TUnuranContDist& ); Implementation of copy constructor. ~TUnuranContDist(); destructor implementation. void SetCdf(const ROOT::Math::IGenFunction& cdf); set cdf distributi",MatchSource.WIKI,root/html532/TUnuranContDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnuranContDist.html
https://root.cern/root/html532/TUnuranContDist.html:4247,Testability,log,log,4247,"e managed by class. TUnuranContDist(const TUnuranContDist& ); Implementation of copy constructor. ~TUnuranContDist(); destructor implementation. void SetCdf(const ROOT::Math::IGenFunction& cdf); set cdf distribution using a generic function interface. void SetCdf(TF1* cdf); set cumulative distribution function from a TF1. double Pdf(double x) const; evaluate the pdf of the distribution. double DPdf(double x) const; evaluate the derivative of the pdf; if derivative function is not given is evaluated numerically. double Cdf(double x) const; evaluate the integral (cdf) on the domain. TUnuranContDist * Clone() const. Clone (required by base class). { return new TUnuranContDist(*this); }. void SetDomain(double xmin, double xmax). Set the distribution domain. If min < max a domain is defined otherwise is undefined. void SetMode(double mode). set the distribution mode (x position of its maximum). { fMode = mode; fHasMode=true;}. void SetPdfArea(double area). set the area below the pdf. { fArea = area; fHasArea=true;}. bool GetDomain(double& xmin, double& xmax) const. check if distribution has a defined domain and return in case its domain. bool HasCdf() const. check if a cdf function is provided for the distribution. { return fCdf != 0; }. bool HasMode() const. check if distribution has a pre-computed mode. { return fHasMode; }. bool HasPdfArea() const. check if distribution has a pre-computed area below the Pdf. { return fHasArea; }. double Mode() const. return the mode (x location of maximum of the pdf). { return fMode; }. double PdfArea() const. return area below the pdf. { return fArea; }. bool IsLogPdf() const. flag to control if given function represent the log of a pdf. { return fIsLogPdf; }. » Last changed: root/unuran:$Id: TUnuranContDist.h 33181 2010-04-25 10:15:08Z moneta $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TUnuranContDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnuranContDist.html
https://root.cern/root/html532/TUnuranDiscrDist.html:3766,Integrability,interface,interface,3766,"he probabilities ; vector<double>fPVecSumVector of the sum of the probabilities ; const ROOT::Math::IBaseFunctionOneDim*fPmfpointer to a function calculating the probability ; doublefSumtotal sum of the probabilities in the given domain; intfXmaxupper value of the domain; intfXminlower value of the domain. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnuranDiscrDist(const ROOT::Math::IGenFunction& func, bool copyFunc = false). Constructor from a generic function object specifying the pdf. TUnuranDiscrDist(TF1* func). Constructor from a TF1 objects specifying the pdf. TUnuranDiscrDist(double* begin, double* end). Constructor from a vector of probability. {}. virtual ~TUnuranDiscrDist(). Destructor. TUnuranDiscrDist(const TUnuranDiscrDist& ). Copy constructor. TUnuranDiscrDist * Clone() const. Clone (required by base class). { return new TUnuranDiscrDist(*this); }. void SetCdf(const ROOT::Math::IGenFunction& cdf). set cdf distribution from a generic function interface. If a method requires it; and is not set it is estimated numerically. void SetCdf(TF1* cdf). set cdf distribution from a TF1 pointer. If a method requires it; and is not set it is estimated numerically. void SetDomain(int xmin, int xmax). Set the distribution domain, by default the domain is [0,INT_MAX]; If xmin >= xmax a domain is removed. void SetMode(int mode). set the mode of the distribution (location of maximum probability). { fMode = mode; fHasMode=true;}. void SetProbSum(double sum). set the value of the sum of the probabilities in the given domain. { fSum = sum; fHasSum=true; }. bool GetDomain(int& xmin, int& xmax) const. check if distribution has domain and return in case its domain. int Mode() const. get the mode (x location of function maximum). { return fMode; }. double ProbSum() const. return area of the pdf. { return fSum; }. bool HasMode() const. flag to control if distribution provides the mode. { return fHasMode; }. bool HasProbSum() const.",MatchSource.WIKI,root/html532/TUnuranDiscrDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnuranDiscrDist.html
https://root.cern/root/html532/TUnuranDiscrDist.html:3070,Modifiability,Inherit,Inheritance,3070,"de); voidSetProbSum(double sum); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; private:. const ROOT::Math::IBaseFunctionOneDim*fCdfpointer to the cumulative distribution function; boolfHasDomainflag to control if distribution has a defined domain (otherwise is [0,INT_MAX]); boolfHasModeflag to control if distribution has a pre-computed mode; boolfHasSumflag to control if distribution has a pre-computed sum of the probabilities; intfModemode of the distribution; boolfOwnFuncflag to control if distribution owns the funcitno pointers; vector<double>fPVecVector of the probabilities ; vector<double>fPVecSumVector of the sum of the probabilities ; const ROOT::Math::IBaseFunctionOneDim*fPmfpointer to a function calculating the probability ; doublefSumtotal sum of the probabilities in the given domain; intfXmaxupper value of the domain; intfXminlower value of the domain. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnuranDiscrDist(const ROOT::Math::IGenFunction& func, bool copyFunc = false). Constructor from a generic function object specifying the pdf. TUnuranDiscrDist(TF1* func). Constructor from a TF1 objects specifying the pdf. TUnuranDiscrDist(double* begin, double* end). Constructor from a vector of probability. {}. virtual ~TUnuranDiscrDist(). Destructor. TUnuranDiscrDist(const TUnuranDiscrDist& ). Copy constructor. TUnuranDiscrDist * Clone() const. Clone (required by base class). { return new TUnuranDiscrDist(*this); }. void SetCdf(const ROOT::Math::IGenFunction& cdf). set cdf distribution from a generic function interface. If a method requires it; and is not set it is estimated numerically. void SetCdf(TF1* cdf). set cdf distribution from a TF1 pointer. If a method requires it; and is not set it is estimated numerically. void SetDomain(int xmin, int xmax). Set the distribution domain, by default the domain is [0,INT_MAX]; If xmin >= xma",MatchSource.WIKI,root/html532/TUnuranDiscrDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnuranDiscrDist.html
https://root.cern/root/html532/TUnuranDiscrDist.html:3083,Modifiability,Inherit,Inherited,3083,"de); voidSetProbSum(double sum); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; private:. const ROOT::Math::IBaseFunctionOneDim*fCdfpointer to the cumulative distribution function; boolfHasDomainflag to control if distribution has a defined domain (otherwise is [0,INT_MAX]); boolfHasModeflag to control if distribution has a pre-computed mode; boolfHasSumflag to control if distribution has a pre-computed sum of the probabilities; intfModemode of the distribution; boolfOwnFuncflag to control if distribution owns the funcitno pointers; vector<double>fPVecVector of the probabilities ; vector<double>fPVecSumVector of the sum of the probabilities ; const ROOT::Math::IBaseFunctionOneDim*fPmfpointer to a function calculating the probability ; doublefSumtotal sum of the probabilities in the given domain; intfXmaxupper value of the domain; intfXminlower value of the domain. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnuranDiscrDist(const ROOT::Math::IGenFunction& func, bool copyFunc = false). Constructor from a generic function object specifying the pdf. TUnuranDiscrDist(TF1* func). Constructor from a TF1 objects specifying the pdf. TUnuranDiscrDist(double* begin, double* end). Constructor from a vector of probability. {}. virtual ~TUnuranDiscrDist(). Destructor. TUnuranDiscrDist(const TUnuranDiscrDist& ). Copy constructor. TUnuranDiscrDist * Clone() const. Clone (required by base class). { return new TUnuranDiscrDist(*this); }. void SetCdf(const ROOT::Math::IGenFunction& cdf). set cdf distribution from a generic function interface. If a method requires it; and is not set it is estimated numerically. void SetCdf(TF1* cdf). set cdf distribution from a TF1 pointer. If a method requires it; and is not set it is estimated numerically. void SetDomain(int xmin, int xmax). Set the distribution domain, by default the domain is [0,INT_MAX]; If xmin >= xma",MatchSource.WIKI,root/html532/TUnuranDiscrDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnuranDiscrDist.html
https://root.cern/root/html532/TUnuranEmpDist.html:2616,Modifiability,Inherit,Inheritance,2616," 0, bool useBuffer = true); TUnuranEmpDist(unsigned int n, double* x); TUnuranEmpDist(unsigned int n, double* x, double* y); TUnuranEmpDist(double* begin, double* end, unsigned int dim = 1); TUnuranEmpDist(unsigned int n, double* x, double* y, double* z); virtual~TUnuranEmpDist(); static TClass*Class(); virtual TUnuranEmpDist*Clone() const; const vector<double>&Data() const; virtual TClass*IsA() const; boolIsBinned() const; doubleLowerBin() const; unsigned intNDim() const; TUnuranEmpDist&operator=(const TUnuranEmpDist& rhs); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); doubleUpperBin() const. Data Members; private:. boolfBinnedflag for binned/unbinned data ; vector<double>fDatapointer to the data vector (used for generation from un-binned data); unsigned intfDimdata dimensionality; doublefMaxmax values (used in the binned case); doublefMinmin values (used in the binned case). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnuranEmpDist(const TH1* h1 = 0, bool useBuffer = true). Constructor from a TH1 objects.; If the histogram has a buffer by default the unbinned data are used. TUnuranEmpDist(double* begin, double* end, unsigned int dim = 1). Constructor from a set of data using an iterator to specify begin/end of the data; In the case of multi-dimension the data are assumed to be passed in this order; x0,y0,...x1,y1,..x2,y2,... {}. TUnuranEmpDist(unsigned int n, double* x). Constructor from a set of 1D data. TUnuranEmpDist(unsigned int n, double* x, double* y). Constructor from a set of 2D data. TUnuranEmpDist(unsigned int n, double* x, double* y, double* z). Constructor from a set of 3D data. virtual ~TUnuranEmpDist(). Destructor (no operations). {}. TUnuranEmpDist(const TUnuranEmpDist& ). Copy constructor. TUnuranEmpDist * Clone() const. Clone (required by base class). { return new TUnuranEmpDist(*this); }. const std::vector<double> & Data() const. ",MatchSource.WIKI,root/html532/TUnuranEmpDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnuranEmpDist.html
https://root.cern/root/html532/TUnuranEmpDist.html:2629,Modifiability,Inherit,Inherited,2629," 0, bool useBuffer = true); TUnuranEmpDist(unsigned int n, double* x); TUnuranEmpDist(unsigned int n, double* x, double* y); TUnuranEmpDist(double* begin, double* end, unsigned int dim = 1); TUnuranEmpDist(unsigned int n, double* x, double* y, double* z); virtual~TUnuranEmpDist(); static TClass*Class(); virtual TUnuranEmpDist*Clone() const; const vector<double>&Data() const; virtual TClass*IsA() const; boolIsBinned() const; doubleLowerBin() const; unsigned intNDim() const; TUnuranEmpDist&operator=(const TUnuranEmpDist& rhs); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); doubleUpperBin() const. Data Members; private:. boolfBinnedflag for binned/unbinned data ; vector<double>fDatapointer to the data vector (used for generation from un-binned data); unsigned intfDimdata dimensionality; doublefMaxmax values (used in the binned case); doublefMinmin values (used in the binned case). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnuranEmpDist(const TH1* h1 = 0, bool useBuffer = true). Constructor from a TH1 objects.; If the histogram has a buffer by default the unbinned data are used. TUnuranEmpDist(double* begin, double* end, unsigned int dim = 1). Constructor from a set of data using an iterator to specify begin/end of the data; In the case of multi-dimension the data are assumed to be passed in this order; x0,y0,...x1,y1,..x2,y2,... {}. TUnuranEmpDist(unsigned int n, double* x). Constructor from a set of 1D data. TUnuranEmpDist(unsigned int n, double* x, double* y). Constructor from a set of 2D data. TUnuranEmpDist(unsigned int n, double* x, double* y, double* z). Constructor from a set of 3D data. virtual ~TUnuranEmpDist(). Destructor (no operations). {}. TUnuranEmpDist(const TUnuranEmpDist& ). Copy constructor. TUnuranEmpDist * Clone() const. Clone (required by base class). { return new TUnuranEmpDist(*this); }. const std::vector<double> & Data() const. ",MatchSource.WIKI,root/html532/TUnuranEmpDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnuranEmpDist.html
https://root.cern/root/html532/TUnuranMultiContDist.html:363,Deployability,continuous,continuous,363,". TUnuranMultiContDist. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » UNURAN; » TUnuranMultiContDist. class TUnuranMultiContDist: public TUnuranBaseDist. TUnuranMultiContDist class describing multi dimensional continuous distributions.; It is used by TUnuran to generate a set of random numbers according to this distribution via; TUnuran::Sample(double *).; The class can be constructed from a multi-dimensional function (TF1 pointer, which can be actually also a; TF2 or a TF3).; It provides a method to set the domain of the distribution ( SetDomain ) which will correspond to the range; of the generated random numbers. By default the domain is [(-inf,-inf,...)(+inf,+inf,...)], indipendently of the; range set in the TF1 class used to construct the distribution. The derivatives of the pdf which are used by some UNURAN methods are estimated numerically in the; Derivative() method. Some extra information (like distribution mode) can be set using SetMode.; Some methods require instead of the pdf the log of the pdf.; This can also be controlled by setting a flag when constructing this class. Function Members (Methods); public:. TUnuranMultiContDist(const TUnuranMultiContDist&); TUnuranMultiContDist(const ROOT::Math::IMultiGenFunction& pdf, bool isLogPdf = false); TUnuranMultiContDist(TF1* func = 0, unsigned int dim = 0, bool isLogPdf = false); virtual~TUnuranMultiContDist(); static TClass*Class(); virtual TUnuranMultiContDist*Clone() const; doubleDerivative(const double* x, int icoord) const; const double*GetLowerDomain() const; const double*GetMode() const; const double*GetUpperDomain() const; voidGradient(const double* x, double* grad) const; virtual TClass*IsA() const; boolIsLogPdf() const; unsigned intNDim() const; TUnuranMultiContDist&operator=(const TUnuranMultiContDist& rhs); doublePdf(const double* x) const; voidSetDo",MatchSource.WIKI,root/html532/TUnuranMultiContDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnuranMultiContDist.html
https://root.cern/root/html532/TUnuranMultiContDist.html:3286,Integrability,interface,interface,3286,"nt log of pdf; vector<double>fModevector representing the x coordinates of the maximum of the pdf ; boolfOwnFuncflag to indicate if class manages the function pointers; const ROOT::Math::IBaseFunctionMultiDim*fPdfpointer to the pdf; vector<double>fXmaxvector with upper x values of the domain ; vector<double>fXminvector with lower x values of the domain. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnuranMultiContDist(TF1* func = 0, unsigned int dim = 0, bool isLogPdf = false). Constructor from a TF1 object representing the Probability density function.; The derivatives of the Pdf are estimated, when required by the UNURAN algorithm,; using numerical derivation.; If a value of dim 0 is passed , the dimension of the function is taken from TF1::GetNdim().; This works only for 2D and 3D (for TF2 and TF3 objects). TUnuranMultiContDist(const ROOT::Math::IMultiGenFunction& pdf, bool isLogPdf = false). Constructor as before but from a generic function object interface for multi-dim functions. virtual ~TUnuranMultiContDist(). Destructor. TUnuranMultiContDist(const TUnuranMultiContDist& ). Copy constructor. TUnuranMultiContDist * Clone() const. Clone (required by base class). { return new TUnuranMultiContDist(*this); }. unsigned int NDim() const. get number of dimension of the distribution. void SetDomain(const double* xmin, const double* xmax). set the domain of the distribution giving an array of minimum and maximum values; By default otherwise the domain is undefined, i.e. is [-inf,+inf]; To remove the domain do a SetDomain(0,0).; There is no possibility to have a domain defined in only one coordinate. Use instead inf or DOUBLE_MAX to; specify un infinite domain in that coordinate. void SetMode(const double* x). set the mode of the distribution (coordinates of the distribution maximum values). const double * GetLowerDomain() const. get the distribution lower domain values. Return a null pointer if domain is not defined. const ",MatchSource.WIKI,root/html532/TUnuranMultiContDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnuranMultiContDist.html
https://root.cern/root/html532/TUnuranMultiContDist.html:2644,Modifiability,Inherit,Inheritance,2644,"ouble*GetLowerDomain() const; const double*GetMode() const; const double*GetUpperDomain() const; voidGradient(const double* x, double* grad) const; virtual TClass*IsA() const; boolIsLogPdf() const; unsigned intNDim() const; TUnuranMultiContDist&operator=(const TUnuranMultiContDist& rhs); doublePdf(const double* x) const; voidSetDomain(const double* xmin, const double* xmax); voidSetMode(const double* x); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; private:. boolfIsLogPdfflag to control if function pointer represent log of pdf; vector<double>fModevector representing the x coordinates of the maximum of the pdf ; boolfOwnFuncflag to indicate if class manages the function pointers; const ROOT::Math::IBaseFunctionMultiDim*fPdfpointer to the pdf; vector<double>fXmaxvector with upper x values of the domain ; vector<double>fXminvector with lower x values of the domain. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnuranMultiContDist(TF1* func = 0, unsigned int dim = 0, bool isLogPdf = false). Constructor from a TF1 object representing the Probability density function.; The derivatives of the Pdf are estimated, when required by the UNURAN algorithm,; using numerical derivation.; If a value of dim 0 is passed , the dimension of the function is taken from TF1::GetNdim().; This works only for 2D and 3D (for TF2 and TF3 objects). TUnuranMultiContDist(const ROOT::Math::IMultiGenFunction& pdf, bool isLogPdf = false). Constructor as before but from a generic function object interface for multi-dim functions. virtual ~TUnuranMultiContDist(). Destructor. TUnuranMultiContDist(const TUnuranMultiContDist& ). Copy constructor. TUnuranMultiContDist * Clone() const. Clone (required by base class). { return new TUnuranMultiContDist(*this); }. unsigned int NDim() const. get number of dimension of the distribution. void SetDomain(const double* xmin, const double",MatchSource.WIKI,root/html532/TUnuranMultiContDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnuranMultiContDist.html
https://root.cern/root/html532/TUnuranMultiContDist.html:2657,Modifiability,Inherit,Inherited,2657,"ouble*GetLowerDomain() const; const double*GetMode() const; const double*GetUpperDomain() const; voidGradient(const double* x, double* grad) const; virtual TClass*IsA() const; boolIsLogPdf() const; unsigned intNDim() const; TUnuranMultiContDist&operator=(const TUnuranMultiContDist& rhs); doublePdf(const double* x) const; voidSetDomain(const double* xmin, const double* xmax); voidSetMode(const double* x); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; private:. boolfIsLogPdfflag to control if function pointer represent log of pdf; vector<double>fModevector representing the x coordinates of the maximum of the pdf ; boolfOwnFuncflag to indicate if class manages the function pointers; const ROOT::Math::IBaseFunctionMultiDim*fPdfpointer to the pdf; vector<double>fXmaxvector with upper x values of the domain ; vector<double>fXminvector with lower x values of the domain. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnuranMultiContDist(TF1* func = 0, unsigned int dim = 0, bool isLogPdf = false). Constructor from a TF1 object representing the Probability density function.; The derivatives of the Pdf are estimated, when required by the UNURAN algorithm,; using numerical derivation.; If a value of dim 0 is passed , the dimension of the function is taken from TF1::GetNdim().; This works only for 2D and 3D (for TF2 and TF3 objects). TUnuranMultiContDist(const ROOT::Math::IMultiGenFunction& pdf, bool isLogPdf = false). Constructor as before but from a generic function object interface for multi-dim functions. virtual ~TUnuranMultiContDist(). Destructor. TUnuranMultiContDist(const TUnuranMultiContDist& ). Copy constructor. TUnuranMultiContDist * Clone() const. Clone (required by base class). { return new TUnuranMultiContDist(*this); }. unsigned int NDim() const. get number of dimension of the distribution. void SetDomain(const double* xmin, const double",MatchSource.WIKI,root/html532/TUnuranMultiContDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnuranMultiContDist.html
https://root.cern/root/html532/TUnuranMultiContDist.html:1160,Testability,log,log,1160,"ass description; function members; data members; class charts. ROOT; » MATH; » UNURAN; » TUnuranMultiContDist. class TUnuranMultiContDist: public TUnuranBaseDist. TUnuranMultiContDist class describing multi dimensional continuous distributions.; It is used by TUnuran to generate a set of random numbers according to this distribution via; TUnuran::Sample(double *).; The class can be constructed from a multi-dimensional function (TF1 pointer, which can be actually also a; TF2 or a TF3).; It provides a method to set the domain of the distribution ( SetDomain ) which will correspond to the range; of the generated random numbers. By default the domain is [(-inf,-inf,...)(+inf,+inf,...)], indipendently of the; range set in the TF1 class used to construct the distribution. The derivatives of the pdf which are used by some UNURAN methods are estimated numerically in the; Derivative() method. Some extra information (like distribution mode) can be set using SetMode.; Some methods require instead of the pdf the log of the pdf.; This can also be controlled by setting a flag when constructing this class. Function Members (Methods); public:. TUnuranMultiContDist(const TUnuranMultiContDist&); TUnuranMultiContDist(const ROOT::Math::IMultiGenFunction& pdf, bool isLogPdf = false); TUnuranMultiContDist(TF1* func = 0, unsigned int dim = 0, bool isLogPdf = false); virtual~TUnuranMultiContDist(); static TClass*Class(); virtual TUnuranMultiContDist*Clone() const; doubleDerivative(const double* x, int icoord) const; const double*GetLowerDomain() const; const double*GetMode() const; const double*GetUpperDomain() const; voidGradient(const double* x, double* grad) const; virtual TClass*IsA() const; boolIsLogPdf() const; unsigned intNDim() const; TUnuranMultiContDist&operator=(const TUnuranMultiContDist& rhs); doublePdf(const double* x) const; voidSetDomain(const double* xmin, const double* xmax); voidSetMode(const double* x); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreame",MatchSource.WIKI,root/html532/TUnuranMultiContDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnuranMultiContDist.html
https://root.cern/root/html532/TUnuranMultiContDist.html:2277,Testability,log,log,2277,"se); TUnuranMultiContDist(TF1* func = 0, unsigned int dim = 0, bool isLogPdf = false); virtual~TUnuranMultiContDist(); static TClass*Class(); virtual TUnuranMultiContDist*Clone() const; doubleDerivative(const double* x, int icoord) const; const double*GetLowerDomain() const; const double*GetMode() const; const double*GetUpperDomain() const; voidGradient(const double* x, double* grad) const; virtual TClass*IsA() const; boolIsLogPdf() const; unsigned intNDim() const; TUnuranMultiContDist&operator=(const TUnuranMultiContDist& rhs); doublePdf(const double* x) const; voidSetDomain(const double* xmin, const double* xmax); voidSetMode(const double* x); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; private:. boolfIsLogPdfflag to control if function pointer represent log of pdf; vector<double>fModevector representing the x coordinates of the maximum of the pdf ; boolfOwnFuncflag to indicate if class manages the function pointers; const ROOT::Math::IBaseFunctionMultiDim*fPdfpointer to the pdf; vector<double>fXmaxvector with upper x values of the domain ; vector<double>fXminvector with lower x values of the domain. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnuranMultiContDist(TF1* func = 0, unsigned int dim = 0, bool isLogPdf = false). Constructor from a TF1 object representing the Probability density function.; The derivatives of the Pdf are estimated, when required by the UNURAN algorithm,; using numerical derivation.; If a value of dim 0 is passed , the dimension of the function is taken from TF1::GetNdim().; This works only for 2D and 3D (for TF2 and TF3 objects). TUnuranMultiContDist(const ROOT::Math::IMultiGenFunction& pdf, bool isLogPdf = false). Constructor as before but from a generic function object interface for multi-dim functions. virtual ~TUnuranMultiContDist(). Destructor. TUnuranMultiContDist(const TUnuranMultiContDist& ). Copy ",MatchSource.WIKI,root/html532/TUnuranMultiContDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnuranMultiContDist.html
https://root.cern/root/html532/TUnuranMultiContDist.html:4630,Testability,log,log,4630,"ject interface for multi-dim functions. virtual ~TUnuranMultiContDist(). Destructor. TUnuranMultiContDist(const TUnuranMultiContDist& ). Copy constructor. TUnuranMultiContDist * Clone() const. Clone (required by base class). { return new TUnuranMultiContDist(*this); }. unsigned int NDim() const. get number of dimension of the distribution. void SetDomain(const double* xmin, const double* xmax). set the domain of the distribution giving an array of minimum and maximum values; By default otherwise the domain is undefined, i.e. is [-inf,+inf]; To remove the domain do a SetDomain(0,0).; There is no possibility to have a domain defined in only one coordinate. Use instead inf or DOUBLE_MAX to; specify un infinite domain in that coordinate. void SetMode(const double* x). set the mode of the distribution (coordinates of the distribution maximum values). const double * GetLowerDomain() const. get the distribution lower domain values. Return a null pointer if domain is not defined. const double * GetUpperDomain() const. get the distribution upper domain values. Return a null pointer if domain is not defined. const double * GetMode() const. get the mode (vector of coordinate positions of the maxima of the distribution); If a mode has not defined return a NULL pointer. bool IsLogPdf() const. flag to control if given function represent the log of a pdf. { return fIsLogPdf; }. double Pdf(const double* x) const. evaluate the probability density function, used by UnuRan. void Gradient(const double* x, double* grad) const. evaluate the gradient vector of the Pdf. Used by UnuRan. double Derivative(const double* x, int icoord) const. evaluate the partial derivative for the given coordinate. Used by UnuRan. » Last changed: root/unuran:$Id: TUnuranMultiContDist.h 33181 2010-04-25 10:15:08Z moneta $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TUnuranMultiContDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnuranMultiContDist.html
https://root.cern/root/html532/TUnuranSampler.html:1183,Availability,error,error,1183," Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » UNURAN; » TUnuranSampler. class TUnuranSampler: public ROOT::Math::DistSampler. Function Members (Methods); public:. TUnuranSampler(); TUnuranSampler(const TUnuranSampler&); virtual~TUnuranSampler(); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, ROOT::Fit::UnBinData& data); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true); boolROOT::Math::DistSampler::Generate(unsigned int nevt, int nbins, double xmin, double xmax, ROOT::Fit::BinData& data, bool extend = true); virtual TRandom*GetRandom(); virtual boolInit(const char* algo = """"); virtual boolInit(const ROOT::Math::DistSamplerOptions& opt); unsigned intROOT::Math::DistSampler::NDim() const; const ROOT::Math::IMultiGenFunction&ROOT::Math::DistSampler::ParentPdf() const; virtual boolSample(double* x); virtual doubleSample1D(); virtual boolSampleBin(double prob, double& value, double* error = 0); virtual boolROOT::Math::DistSampler::SampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidSetArea(double area); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); voidSetFunction(TF1* pdf); virtual voidSetMode(double mode); voidSetPrintLevel(int level); virtual voidSetRandom(TRandom* r); voidROOT::Math::DistSampler::SetRange(const ROOT::Fit::DataRange& range); voidROOT::Math::DistSampler::SetRange(const double* xmin, const double* xmax); voidROOT::Math::DistSampler::SetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int seed). protected:. boolDoInit1D(const char* algo); boolDoInitDiscrete1D(const char* algo); boolDoInitND(const char* algo); virtual voidROOT::Math::DistSampler::DoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolROOT::Math::DistSampler::IsInitialized(); cons",MatchSource.WIKI,root/html532/TUnuranSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnuranSampler.html
https://root.cern/root/html532/TUnuranSampler.html:1303,Availability,error,errors,1303," Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » UNURAN; » TUnuranSampler. class TUnuranSampler: public ROOT::Math::DistSampler. Function Members (Methods); public:. TUnuranSampler(); TUnuranSampler(const TUnuranSampler&); virtual~TUnuranSampler(); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, ROOT::Fit::UnBinData& data); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true); boolROOT::Math::DistSampler::Generate(unsigned int nevt, int nbins, double xmin, double xmax, ROOT::Fit::BinData& data, bool extend = true); virtual TRandom*GetRandom(); virtual boolInit(const char* algo = """"); virtual boolInit(const ROOT::Math::DistSamplerOptions& opt); unsigned intROOT::Math::DistSampler::NDim() const; const ROOT::Math::IMultiGenFunction&ROOT::Math::DistSampler::ParentPdf() const; virtual boolSample(double* x); virtual doubleSample1D(); virtual boolSampleBin(double prob, double& value, double* error = 0); virtual boolROOT::Math::DistSampler::SampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidSetArea(double area); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); voidSetFunction(TF1* pdf); virtual voidSetMode(double mode); voidSetPrintLevel(int level); virtual voidSetRandom(TRandom* r); voidROOT::Math::DistSampler::SetRange(const ROOT::Fit::DataRange& range); voidROOT::Math::DistSampler::SetRange(const double* xmin, const double* xmax); voidROOT::Math::DistSampler::SetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int seed). protected:. boolDoInit1D(const char* algo); boolDoInitDiscrete1D(const char* algo); boolDoInitND(const char* algo); virtual voidROOT::Math::DistSampler::DoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolROOT::Math::DistSampler::IsInitialized(); cons",MatchSource.WIKI,root/html532/TUnuranSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnuranSampler.html
https://root.cern/root/html532/TUnuranSampler.html:3635,Availability,error,error,3635,"debug level; doublefModemode of dist; boolfOneDimflag to indicate if the function is 1 dimension; TUnuran*fUnuranunuran engine class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnuranSampler(). ~TUnuranSampler(). bool Init(const char* algo = """"); initialize unuran classes using the given algorithm. bool Init(const ROOT::Math::DistSamplerOptions& opt); default initialization with algorithm name. bool DoInit1D(const char* algo); initilize for 1D sampling; need to create 1D interface from Multidim one; (to do: use directly 1D functions ??). bool DoInitDiscrete1D(const char* algo); initilize for 1D sampling of discrete distributions. bool DoInitND(const char* algo); initilize for 1D sampling. void SetFunction(TF1* pdf); set function from a TF1 pointer. void SetRandom(TRandom* r); set random generator (must be called before Init to have effect). void SetSeed(unsigned int seed); set random generator seed (must be called before Init to have effect). TRandom * GetRandom(); get random generator used. double Sample1D(); sample 1D distributions. bool Sample(double* x); sample multi-dim distributions. bool SampleBin(double prob, double& value, double* error = 0); sample a bin according to Poisson statistics. TUnuranSampler(); default constructor. void SetFunction(const ROOT::Math::IGenFunction& func); set the parent function distribution to use for random sampling (one dim case). void SetPrintLevel(int level). Set the print level; (if level=-1 use default). {fLevel = level;}. void SetMode(double mode). set the mode. void SetArea(double area). set the area. » Author: L. Moneta Fri Sep 22 15:06:47 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: TUnuranSampler.h 37419 2010-12-08 21:19:45Z moneta $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TUnuranSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnuranSampler.html
https://root.cern/root/html532/TUnuranSampler.html:2953,Integrability,interface,interface,2953,"Math::DistSampler::DoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolROOT::Math::DistSampler::IsInitialized(); const ROOT::Fit::DataRange&ROOT::Math::DistSampler::PdfRange() const. Data Members; private:. doublefAreaarea of dist; boolfDiscreteflag to indicate if the function is discrete; const ROOT::Math::IBaseFunctionOneDim*fFunc1D1D function pointer; boolfHasAreaflag to indicate if a area is set; boolfHasModeflag to indicate if a mode is set; intfLeveldebug level; doublefModemode of dist; boolfOneDimflag to indicate if the function is 1 dimension; TUnuran*fUnuranunuran engine class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnuranSampler(). ~TUnuranSampler(). bool Init(const char* algo = """"); initialize unuran classes using the given algorithm. bool Init(const ROOT::Math::DistSamplerOptions& opt); default initialization with algorithm name. bool DoInit1D(const char* algo); initilize for 1D sampling; need to create 1D interface from Multidim one; (to do: use directly 1D functions ??). bool DoInitDiscrete1D(const char* algo); initilize for 1D sampling of discrete distributions. bool DoInitND(const char* algo); initilize for 1D sampling. void SetFunction(TF1* pdf); set function from a TF1 pointer. void SetRandom(TRandom* r); set random generator (must be called before Init to have effect). void SetSeed(unsigned int seed); set random generator seed (must be called before Init to have effect). TRandom * GetRandom(); get random generator used. double Sample1D(); sample 1D distributions. bool Sample(double* x); sample multi-dim distributions. bool SampleBin(double prob, double& value, double* error = 0); sample a bin according to Poisson statistics. TUnuranSampler(); default constructor. void SetFunction(const ROOT::Math::IGenFunction& func); set the parent function distribution to use for random sampling (one dim case). void SetPrintLevel(int level). Set the print level; (if level=-1 use default). ",MatchSource.WIKI,root/html532/TUnuranSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnuranSampler.html
https://root.cern/root/html532/TUnuranSampler.html:649,Modifiability,extend,extend,649," Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » UNURAN; » TUnuranSampler. class TUnuranSampler: public ROOT::Math::DistSampler. Function Members (Methods); public:. TUnuranSampler(); TUnuranSampler(const TUnuranSampler&); virtual~TUnuranSampler(); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, ROOT::Fit::UnBinData& data); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true); boolROOT::Math::DistSampler::Generate(unsigned int nevt, int nbins, double xmin, double xmax, ROOT::Fit::BinData& data, bool extend = true); virtual TRandom*GetRandom(); virtual boolInit(const char* algo = """"); virtual boolInit(const ROOT::Math::DistSamplerOptions& opt); unsigned intROOT::Math::DistSampler::NDim() const; const ROOT::Math::IMultiGenFunction&ROOT::Math::DistSampler::ParentPdf() const; virtual boolSample(double* x); virtual doubleSample1D(); virtual boolSampleBin(double prob, double& value, double* error = 0); virtual boolROOT::Math::DistSampler::SampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidSetArea(double area); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); voidSetFunction(TF1* pdf); virtual voidSetMode(double mode); voidSetPrintLevel(int level); virtual voidSetRandom(TRandom* r); voidROOT::Math::DistSampler::SetRange(const ROOT::Fit::DataRange& range); voidROOT::Math::DistSampler::SetRange(const double* xmin, const double* xmax); voidROOT::Math::DistSampler::SetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int seed). protected:. boolDoInit1D(const char* algo); boolDoInitDiscrete1D(const char* algo); boolDoInitND(const char* algo); virtual voidROOT::Math::DistSampler::DoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolROOT::Math::DistSampler::IsInitialized(); cons",MatchSource.WIKI,root/html532/TUnuranSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnuranSampler.html
https://root.cern/root/html532/TUnuranSampler.html:790,Modifiability,extend,extend,790," Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » UNURAN; » TUnuranSampler. class TUnuranSampler: public ROOT::Math::DistSampler. Function Members (Methods); public:. TUnuranSampler(); TUnuranSampler(const TUnuranSampler&); virtual~TUnuranSampler(); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, ROOT::Fit::UnBinData& data); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true); boolROOT::Math::DistSampler::Generate(unsigned int nevt, int nbins, double xmin, double xmax, ROOT::Fit::BinData& data, bool extend = true); virtual TRandom*GetRandom(); virtual boolInit(const char* algo = """"); virtual boolInit(const ROOT::Math::DistSamplerOptions& opt); unsigned intROOT::Math::DistSampler::NDim() const; const ROOT::Math::IMultiGenFunction&ROOT::Math::DistSampler::ParentPdf() const; virtual boolSample(double* x); virtual doubleSample1D(); virtual boolSampleBin(double prob, double& value, double* error = 0); virtual boolROOT::Math::DistSampler::SampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidSetArea(double area); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); voidSetFunction(TF1* pdf); virtual voidSetMode(double mode); voidSetPrintLevel(int level); virtual voidSetRandom(TRandom* r); voidROOT::Math::DistSampler::SetRange(const ROOT::Fit::DataRange& range); voidROOT::Math::DistSampler::SetRange(const double* xmin, const double* xmax); voidROOT::Math::DistSampler::SetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int seed). protected:. boolDoInit1D(const char* algo); boolDoInitDiscrete1D(const char* algo); boolDoInitND(const char* algo); virtual voidROOT::Math::DistSampler::DoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolROOT::Math::DistSampler::IsInitialized(); cons",MatchSource.WIKI,root/html532/TUnuranSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnuranSampler.html
https://root.cern/root/html532/TUnuranSampler.html:2576,Modifiability,Inherit,Inheritance,2576,"ge& range); voidROOT::Math::DistSampler::SetRange(const double* xmin, const double* xmax); voidROOT::Math::DistSampler::SetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int seed). protected:. boolDoInit1D(const char* algo); boolDoInitDiscrete1D(const char* algo); boolDoInitND(const char* algo); virtual voidROOT::Math::DistSampler::DoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolROOT::Math::DistSampler::IsInitialized(); const ROOT::Fit::DataRange&ROOT::Math::DistSampler::PdfRange() const. Data Members; private:. doublefAreaarea of dist; boolfDiscreteflag to indicate if the function is discrete; const ROOT::Math::IBaseFunctionOneDim*fFunc1D1D function pointer; boolfHasAreaflag to indicate if a area is set; boolfHasModeflag to indicate if a mode is set; intfLeveldebug level; doublefModemode of dist; boolfOneDimflag to indicate if the function is 1 dimension; TUnuran*fUnuranunuran engine class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnuranSampler(). ~TUnuranSampler(). bool Init(const char* algo = """"); initialize unuran classes using the given algorithm. bool Init(const ROOT::Math::DistSamplerOptions& opt); default initialization with algorithm name. bool DoInit1D(const char* algo); initilize for 1D sampling; need to create 1D interface from Multidim one; (to do: use directly 1D functions ??). bool DoInitDiscrete1D(const char* algo); initilize for 1D sampling of discrete distributions. bool DoInitND(const char* algo); initilize for 1D sampling. void SetFunction(TF1* pdf); set function from a TF1 pointer. void SetRandom(TRandom* r); set random generator (must be called before Init to have effect). void SetSeed(unsigned int seed); set random generator seed (must be called before Init to have effect). TRandom * GetRandom(); get random generator used. double Sample1D(); sample 1D distributions. bool Sample(double* x); sample multi-dim distributions. bool SampleBin(dou",MatchSource.WIKI,root/html532/TUnuranSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnuranSampler.html
https://root.cern/root/html532/TUnuranSampler.html:2589,Modifiability,Inherit,Inherited,2589,"ge& range); voidROOT::Math::DistSampler::SetRange(const double* xmin, const double* xmax); voidROOT::Math::DistSampler::SetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int seed). protected:. boolDoInit1D(const char* algo); boolDoInitDiscrete1D(const char* algo); boolDoInitND(const char* algo); virtual voidROOT::Math::DistSampler::DoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolROOT::Math::DistSampler::IsInitialized(); const ROOT::Fit::DataRange&ROOT::Math::DistSampler::PdfRange() const. Data Members; private:. doublefAreaarea of dist; boolfDiscreteflag to indicate if the function is discrete; const ROOT::Math::IBaseFunctionOneDim*fFunc1D1D function pointer; boolfHasAreaflag to indicate if a area is set; boolfHasModeflag to indicate if a mode is set; intfLeveldebug level; doublefModemode of dist; boolfOneDimflag to indicate if the function is 1 dimension; TUnuran*fUnuranunuran engine class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnuranSampler(). ~TUnuranSampler(). bool Init(const char* algo = """"); initialize unuran classes using the given algorithm. bool Init(const ROOT::Math::DistSamplerOptions& opt); default initialization with algorithm name. bool DoInit1D(const char* algo); initilize for 1D sampling; need to create 1D interface from Multidim one; (to do: use directly 1D functions ??). bool DoInitDiscrete1D(const char* algo); initilize for 1D sampling of discrete distributions. bool DoInitND(const char* algo); initilize for 1D sampling. void SetFunction(TF1* pdf); set function from a TF1 pointer. void SetRandom(TRandom* r); set random generator (must be called before Init to have effect). void SetSeed(unsigned int seed); set random generator seed (must be called before Init to have effect). TRandom * GetRandom(); get random generator used. double Sample1D(); sample 1D distributions. bool Sample(double* x); sample multi-dim distributions. bool SampleBin(dou",MatchSource.WIKI,root/html532/TUnuranSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUnuranSampler.html
https://root.cern/root/html532/TUploadDataSetDlg.html:416,Availability,avail,available,416,". TUploadDataSetDlg. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » GUI; » SESSIONVIEWER; » TUploadDataSetDlg. class TUploadDataSetDlg: public TGTransientFrame. TSessionDialogs. This file defines several dialogs that are used by TSessionViewer.; The following dialogs are available: TNewChainDlg and TNewQueryDlg. Function Members (Methods); public:. TUploadDataSetDlg(TSessionViewer* gui, Int_t w, Int_t h); virtual~TUploadDataSetDlg(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidAddFiles(const char* fileName); voidAddFiles(TList* fileList); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); voidBrowseFiles(); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); voidClearFiles(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::",MatchSource.WIKI,root/html532/TUploadDataSetDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUploadDataSetDlg.html
https://root.cern/root/html532/TUploadDataSetDlg.html:4483,Availability,Error,Error,4483,"(const char* signal); voidTQObject::Emit(const char* signal, Long_t* paramArr); voidTQObject::Emit(const char* signal, const char* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::G",MatchSource.WIKI,root/html532/TUploadDataSetDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUploadDataSetDlg.html
https://root.cern/root/html532/TUploadDataSetDlg.html:4612,Availability,error,error,4612,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html532/TUploadDataSetDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUploadDataSetDlg.html
https://root.cern/root/html532/TUploadDataSetDlg.html:4696,Availability,error,error,4696,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UIn",MatchSource.WIKI,root/html532/TUploadDataSetDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUploadDataSetDlg.html
https://root.cern/root/html532/TUploadDataSetDlg.html:19106,Availability,mask,mask,19106,,MatchSource.WIKI,root/html532/TUploadDataSetDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUploadDataSetDlg.html
https://root.cern/root/html532/TUploadDataSetDlg.html:11309,Integrability,Message,Message,11309,"Frame::IsDNDTarget() const; virtual Bool_tTGCompositeFrame::IsEditable() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGCompositeFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGCompositeFrame::IsMapSubwindows() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTGCompositeFrame::IsVisible(TGFrame* f) const; Bool_tTGCompositeFrame::IsVisible(TGFrameElement* ptr) const; Bool_tTObject::IsZombie() const; virtual voidTGCompositeFrame::Layout(); static voidTQObject::LoadRQ_OBJECT(); virtual voidTGWindow::LowerWindow(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::ls(Option_t* option = """") const; virtual voidTGFrame::MapRaised(); virtual voidTGCompositeFrame::MapSubwindows(); virtual voidTGFrame::MapWindow(); voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidTGFrame::Move(Int_t x, Int_t y); virtual voidTGFrame::MoveResize(Int_t x, Int_t y, UInt_t w = 0, UInt_t h = 0); virtual Int_tTGCompositeFrame::MustCleanup() const; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidOnAppendFiles(Bool_t on); voidOnOverwriteDataset(Bool_t on); voidOnOverwriteFiles(Bool_t on); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObje",MatchSource.WIKI,root/html532/TUploadDataSetDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUploadDataSetDlg.html
https://root.cern/root/html532/TUploadDataSetDlg.html:9854,Modifiability,Inherit,InheritsFrom,9854,"TGCompositeFrame::HandleDragMotion(TGFrame*); virtual Bool_tTGFrame::HandleEvent(Event_t* event); virtual Bool_tTGWindow::HandleExpose(Event_t* event); virtual Bool_tTGCompositeFrame::HandleFocusChange(Event_t*); virtual Bool_tTGWindow::HandleIdleEvent(TGIdleHandler*); virtual Bool_tTGMainFrame::HandleKey(Event_t* event); virtual Bool_tTGMainFrame::HandleMotion(Event_t* event); virtual Bool_tTGMainFrame::HandleSelection(Event_t* event); virtual Bool_tTGFrame::HandleSelectionClear(Event_t*); virtual Bool_tTGMainFrame::HandleSelectionRequest(Event_t* event); virtual Bool_tTGWindow::HandleTimer(TTimer*); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTGObject::Hash() const; virtual voidTGCompositeFrame::HideFrame(TGFrame* f); virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTGWindow::IconifyWindow(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTGFrame::Inspect() const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTGFrame::IsActive() const; Bool_tTGCompositeFrame::IsArranged(TGFrame* f) const; Bool_tTGCompositeFrame::IsArranged(TGFrameElement* ptr) const; virtual Bool_tTGCompositeFrame::IsComposite() const; Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGCompositeFrame::IsEditable() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGCompositeFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGCompositeFrame::IsMapSubwindows() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTGCompositeFrame::IsVisible(TGFrame* f) const; Bool_tTGCompositeFrame::IsVisible(TGFrameElement* ptr) const; Bool_tTObject::IsZombie() co",MatchSource.WIKI,root/html532/TUploadDataSetDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUploadDataSetDlg.html
https://root.cern/root/html532/TUploadDataSetDlg.html:9920,Modifiability,Inherit,InheritsFrom,9920,"e::HandleEvent(Event_t* event); virtual Bool_tTGWindow::HandleExpose(Event_t* event); virtual Bool_tTGCompositeFrame::HandleFocusChange(Event_t*); virtual Bool_tTGWindow::HandleIdleEvent(TGIdleHandler*); virtual Bool_tTGMainFrame::HandleKey(Event_t* event); virtual Bool_tTGMainFrame::HandleMotion(Event_t* event); virtual Bool_tTGMainFrame::HandleSelection(Event_t* event); virtual Bool_tTGFrame::HandleSelectionClear(Event_t*); virtual Bool_tTGMainFrame::HandleSelectionRequest(Event_t* event); virtual Bool_tTGWindow::HandleTimer(TTimer*); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTGObject::Hash() const; virtual voidTGCompositeFrame::HideFrame(TGFrame* f); virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTGWindow::IconifyWindow(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTGFrame::Inspect() const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTGFrame::IsActive() const; Bool_tTGCompositeFrame::IsArranged(TGFrame* f) const; Bool_tTGCompositeFrame::IsArranged(TGFrameElement* ptr) const; virtual Bool_tTGCompositeFrame::IsComposite() const; Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGCompositeFrame::IsEditable() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGCompositeFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGCompositeFrame::IsMapSubwindows() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTGCompositeFrame::IsVisible(TGFrame* f) const; Bool_tTGCompositeFrame::IsVisible(TGFrameElement* ptr) const; Bool_tTObject::IsZombie() const; virtual voidTGCompositeFrame::Layout(); static voidTQObject::",MatchSource.WIKI,root/html532/TUploadDataSetDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUploadDataSetDlg.html
https://root.cern/root/html532/TUploadDataSetDlg.html:22761,Modifiability,Inherit,Inheritance,22761,"_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fAddButtonAdd >> button; TGCheckButton*fAppendFilesappend files; TGTextButton*fBrowseButtonBrowse... button; TGTextButton*fClearButtonClear button; TGTextButton*fCloseDlgButtonClose Dialog button; TGTextEntry*fDSetNamedataset name text entry; TGTextEntry*fDestinationURLdestination URL text entry; TGLVContainer*fLVContainerand its container; TGListView*fListViewdataset files list view; TGTextEntry*fLocationURLlocation URL text entry; TGCheckButton*fOverwriteDSetoverwrite DataSet; TGCheckButton*fOverwriteFilesoverwrite All Files; TGTextButton*fRemoveButtonRemove button; TList*fSkippedFilesList of skipped files; TGTextButton*fUploadButtonUpload button; Bool_tfUploading; TSessionViewer*fViewerpointer on main viewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2). void CloseWindow(). TUploadDataSetDlg(TSessionViewer* gui, Int_t w, Int_t h). virtual ~TUploadDataSetDlg(). void AddFiles(const char* fileName). void AddFiles(TList* fileList). void BrowseFiles(). void ClearFiles(). void RemoveFile(). void UploadDataSet(). void OnOverwriteDataset(Bool_t on). void OnOverwriteFiles(Bool_t on). void OnAppendFiles(Bool_t on). » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: TSessionDialogs.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TUploadDataSetDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUploadDataSetDlg.html
https://root.cern/root/html532/TUploadDataSetDlg.html:22774,Modifiability,Inherit,Inherited,22774,"_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fAddButtonAdd >> button; TGCheckButton*fAppendFilesappend files; TGTextButton*fBrowseButtonBrowse... button; TGTextButton*fClearButtonClear button; TGTextButton*fCloseDlgButtonClose Dialog button; TGTextEntry*fDSetNamedataset name text entry; TGTextEntry*fDestinationURLdestination URL text entry; TGLVContainer*fLVContainerand its container; TGListView*fListViewdataset files list view; TGTextEntry*fLocationURLlocation URL text entry; TGCheckButton*fOverwriteDSetoverwrite DataSet; TGCheckButton*fOverwriteFilesoverwrite All Files; TGTextButton*fRemoveButtonRemove button; TList*fSkippedFilesList of skipped files; TGTextButton*fUploadButtonUpload button; Bool_tfUploading; TSessionViewer*fViewerpointer on main viewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2). void CloseWindow(). TUploadDataSetDlg(TSessionViewer* gui, Int_t w, Int_t h). virtual ~TUploadDataSetDlg(). void AddFiles(const char* fileName). void AddFiles(TList* fileList). void BrowseFiles(). void ClearFiles(). void RemoveFile(). void UploadDataSet(). void OnOverwriteDataset(Bool_t on). void OnOverwriteFiles(Bool_t on). void OnAppendFiles(Bool_t on). » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: TSessionDialogs.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TUploadDataSetDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUploadDataSetDlg.html
https://root.cern/root/html532/TUploadDataSetDlg.html:9564,Security,Hash,Hash,9564,"virtual Bool_tTGCompositeFrame::HandleDoubleClick(Event_t*); virtual Bool_tTGCompositeFrame::HandleDragDrop(TGFrame* frame, Int_t x, Int_t y, TGLayoutHints* lo); virtual Bool_tTGCompositeFrame::HandleDragEnter(TGFrame*); virtual Bool_tTGCompositeFrame::HandleDragLeave(TGFrame*); virtual Bool_tTGCompositeFrame::HandleDragMotion(TGFrame*); virtual Bool_tTGFrame::HandleEvent(Event_t* event); virtual Bool_tTGWindow::HandleExpose(Event_t* event); virtual Bool_tTGCompositeFrame::HandleFocusChange(Event_t*); virtual Bool_tTGWindow::HandleIdleEvent(TGIdleHandler*); virtual Bool_tTGMainFrame::HandleKey(Event_t* event); virtual Bool_tTGMainFrame::HandleMotion(Event_t* event); virtual Bool_tTGMainFrame::HandleSelection(Event_t* event); virtual Bool_tTGFrame::HandleSelectionClear(Event_t*); virtual Bool_tTGMainFrame::HandleSelectionRequest(Event_t* event); virtual Bool_tTGWindow::HandleTimer(TTimer*); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTGObject::Hash() const; virtual voidTGCompositeFrame::HideFrame(TGFrame* f); virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTGWindow::IconifyWindow(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTGFrame::Inspect() const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTGFrame::IsActive() const; Bool_tTGCompositeFrame::IsArranged(TGFrame* f) const; Bool_tTGCompositeFrame::IsArranged(TGFrameElement* ptr) const; virtual Bool_tTGCompositeFrame::IsComposite() const; Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGCompositeFrame::IsEditable() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGCompositeFrame::IsLayoutBroken() const; virtual Bool_tTGWi",MatchSource.WIKI,root/html532/TUploadDataSetDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUploadDataSetDlg.html
https://root.cern/root/html532/TUploadDataSetDlg.html:16246,Testability,Test,TestBit,16246,"me(const char* name); const TGPicture*TGMainFrame::SetIconPixmap(const char* iconName); voidTGMainFrame::SetIconPixmap(char** xpm_array); virtual voidTGCompositeFrame::SetLayoutBroken(Bool_t on = kTRUE); virtual voidTGCompositeFrame::SetLayoutManager(TGLayoutManager* l); virtual voidTGCompositeFrame::SetMapSubwindows(Bool_t on); virtual voidTGFrame::SetMaxHeight(UInt_t h); virtual voidTGFrame::SetMaxWidth(UInt_t w); virtual voidTGFrame::SetMinHeight(UInt_t h); virtual voidTGFrame::SetMinWidth(UInt_t w); voidTGMainFrame::SetMWMHints(UInt_t value, UInt_t funcs, UInt_t input); virtual voidTGWindow::SetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTGFrame::SetSize(const TGDimension& s); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTGFrame::SetWidth(UInt_t w); virtual voidTGMainFrame::SetWindowName(const char* name = 0); voidTGMainFrame::SetWMPosition(Int_t x, Int_t y); voidTGMainFrame::SetWMSize(UInt_t w, UInt_t h); voidTGMainFrame::SetWMSizeHints(UInt_t wmin, UInt_t hmin, UInt_t wmax, UInt_t hmax, UInt_t winc, UInt_t hinc); voidTGMainFrame::SetWMState(EInitialState state); virtual voidTGFrame::SetX(Int_t x); virtual voidTGFrame::SetY(Int_t y); virtual voidTGCompositeFrame::ShowFrame(TGFrame* f); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_tTGCompositeFrame::TranslateCoordinates(TGFrame* child, Int_t x, Int_t y, Int_t& fx, Int_t& fy); virtual voidTGFrame::UnmapWindow(); voidUploadDataSet(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TUploadDataSetDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUploadDataSetDlg.html
https://root.cern/root/html532/TUploadDataSetDlg.html:16285,Testability,Test,TestBits,16285,"me(const char* name); const TGPicture*TGMainFrame::SetIconPixmap(const char* iconName); voidTGMainFrame::SetIconPixmap(char** xpm_array); virtual voidTGCompositeFrame::SetLayoutBroken(Bool_t on = kTRUE); virtual voidTGCompositeFrame::SetLayoutManager(TGLayoutManager* l); virtual voidTGCompositeFrame::SetMapSubwindows(Bool_t on); virtual voidTGFrame::SetMaxHeight(UInt_t h); virtual voidTGFrame::SetMaxWidth(UInt_t w); virtual voidTGFrame::SetMinHeight(UInt_t h); virtual voidTGFrame::SetMinWidth(UInt_t w); voidTGMainFrame::SetMWMHints(UInt_t value, UInt_t funcs, UInt_t input); virtual voidTGWindow::SetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTGFrame::SetSize(const TGDimension& s); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTGFrame::SetWidth(UInt_t w); virtual voidTGMainFrame::SetWindowName(const char* name = 0); voidTGMainFrame::SetWMPosition(Int_t x, Int_t y); voidTGMainFrame::SetWMSize(UInt_t w, UInt_t h); voidTGMainFrame::SetWMSizeHints(UInt_t wmin, UInt_t hmin, UInt_t wmax, UInt_t hmax, UInt_t winc, UInt_t hinc); voidTGMainFrame::SetWMState(EInitialState state); virtual voidTGFrame::SetX(Int_t x); virtual voidTGFrame::SetY(Int_t y); virtual voidTGCompositeFrame::ShowFrame(TGFrame* f); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_tTGCompositeFrame::TranslateCoordinates(TGFrame* child, Int_t x, Int_t y, Int_t& fx, Int_t& fy); virtual voidTGFrame::UnmapWindow(); voidUploadDataSet(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TUploadDataSetDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUploadDataSetDlg.html
https://root.cern/root/html532/TUploadDataSetDlg.html:1731,Usability,Clear,Clear,1731,"leList); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); voidBrowseFiles(); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); voidClearFiles(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindow(); virtual voidTQObject::Destroyed()SIGNAL ; virtual voidTGWindow::DestroySubwindows(); virtual voidTGWindow::DestroyWindow(); Bool_tTQObject::Dis",MatchSource.WIKI,root/html532/TUploadDataSetDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUploadDataSetDlg.html
https://root.cern/root/html532/TUploadDataSetDlg.html:23103,Usability,Clear,ClearFiles,23103,"_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fAddButtonAdd >> button; TGCheckButton*fAppendFilesappend files; TGTextButton*fBrowseButtonBrowse... button; TGTextButton*fClearButtonClear button; TGTextButton*fCloseDlgButtonClose Dialog button; TGTextEntry*fDSetNamedataset name text entry; TGTextEntry*fDestinationURLdestination URL text entry; TGLVContainer*fLVContainerand its container; TGListView*fListViewdataset files list view; TGTextEntry*fLocationURLlocation URL text entry; TGCheckButton*fOverwriteDSetoverwrite DataSet; TGCheckButton*fOverwriteFilesoverwrite All Files; TGTextButton*fRemoveButtonRemove button; TList*fSkippedFilesList of skipped files; TGTextButton*fUploadButtonUpload button; Bool_tfUploading; TSessionViewer*fViewerpointer on main viewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2). void CloseWindow(). TUploadDataSetDlg(TSessionViewer* gui, Int_t w, Int_t h). virtual ~TUploadDataSetDlg(). void AddFiles(const char* fileName). void AddFiles(TList* fileList). void BrowseFiles(). void ClearFiles(). void RemoveFile(). void UploadDataSet(). void OnOverwriteDataset(Bool_t on). void OnOverwriteFiles(Bool_t on). void OnAppendFiles(Bool_t on). » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: TSessionDialogs.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TUploadDataSetDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUploadDataSetDlg.html
https://root.cern/root/html532/TUri.html:1423,Availability,Error,Error,1423," TUri(); TUri(const TUri& uri); TUri(const TString& uri); TUri(const char* uri); virtual~TUri(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const TStringGetAuthority() const; virtual Option_t*TObject::GetDrawOption() const; sta",MatchSource.WIKI,root/html532/TUri.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUri.html
https://root.cern/root/html532/TUri.html:1552,Availability,error,error,1552,"i(const TUri& uri); TUri(const TString& uri); TUri(const char* uri); virtual~TUri(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const TStringGetAuthority() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const TStringGetFragment() const; const TStringGetHierPart() const; const TStringGetHost() const; virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const TStringGetPath() const; const TStringGetPort() const; const TStringGetQuery() const; const TStringGetRelativePart() const; const TStringGetScheme() const; virtual const char*T",MatchSource.WIKI,root/html532/TUri.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUri.html
https://root.cern/root/html532/TUri.html:1636,Availability,error,error,1636," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const TStringGetAuthority() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const TStringGetFragment() const; const TStringGetHierPart() const; const TStringGetHost() const; virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const TStringGetPath() const; const TStringGetPort() const; const TStringGetQuery() const; const TStringGetRelativePart() const; const TStringGetScheme() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const TStringG",MatchSource.WIKI,root/html532/TUri.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUri.html
https://root.cern/root/html532/TUri.html:13307,Availability,error,error,13307,"hority path-abempty; / path-absolute; / path-rootless; / path-empty. const TString GetRelativePart() const; relative-part = ""//"" authority path-abempty; / path-absolute; / path-noscheme; / path-empty. Bool_t SetHierPart(const TString& hier); returns hier-part component of URI; hier-part = ""//"" authority path-abempty; / path-absolute; / path-rootless; / path-empty. Bool_t IsHierPart(const TString& ); Returns kTRUE if string qualifies as hier-part:. hier-part = ""//"" authority path-abempty; / path-absolute; / path-rootless; / path-empty. Bool_t IsRelativePart(const TString& ); Returns kTRUE is string qualifies as relative-part:; relative-part = ""//"" authority path-abempty; / path-absolute; / path-noscheme; / path-empty. Bool_t SetRelativePart(const TString& ); Returns kTRUE is string qualifies as relative-part:; relative-part = ""//"" authority path-abempty; / path-absolute; / path-noscheme; / path-empty. const TString PctEncode(const TString& source); Percent-encode and return the given string according to RFC 3986; in principle, this function cannot fail or produce an error. Bool_t IsHost(const TString& ); Returns kTRUE if string qualifies as valid host component:; host = IP-literal / IPv4address / reg-name; implemented: host = IPv4address / reg-name. Bool_t IsPath(const TString& ); Retruns kTRUE if string qualifies as valid path component:; path = path-abempty ; begins with ""/"" or is empty; / path-absolute ; begins with ""/"" but not ""//""; / path-noscheme ; begins with a non-colon segment; / path-rootless ; begins with a segment; / path-empty ; zero characters. Bool_t IsPathAbempty(const TString& ); Returns kTRUE if string qualifies as valid path-abempty component:; path-abempty = *( ""/"" segment ); segment = *pchar. Bool_t IsPathAbsolute(const TString& ); Returns kTRUE if string qualifies as valid path-absolute component; path-absolute = ""/"" [ segment-nz *( ""/"" segment ) ]; segment-nz = 1*pchar; segment = *pchar. Bool_t IsPathNoscheme(const TString& ); Returns kTRUE if s",MatchSource.WIKI,root/html532/TUri.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUri.html
https://root.cern/root/html532/TUri.html:8739,Integrability,rout,routine,8739,"l_tfHasPort; Bool_tfHasQuery; Bool_tfHasScheme; Bool_tfHasUserinfo; TStringfHostauthority/host: hostname or ip-address; TStringfPath; TStringfPortauthority/port: port number, normally 1-65535; TStringfQuery; TStringfScheme; TStringfUserinfoauthority/userinfo: user@password, ... Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUri(const TString& uri); Constructor that calls SetUri with a complete URI. TUri(const char* uri); Constructor that calls SetUri with a complete URI. TUri(const TUri& uri); TUri copy ctor. TUri & operator=(const TUri& rhs); TUri assignment operator. const TString GetUri() const; Returns the whole URI -; an implementation of chapter 5.3 component recomposition.; The result URI is composed out of the five basic parts. URI = scheme "":"" hier-part [ ""?"" query ] [ ""#"" fragment ]; hier-part = ""//"" authority path-abempty; / path-absolute; / path-rootless; / path-empty. const TString RemoveDotSegments(const TString& ); This functions implements the ""remove_dot_segments"" routine; of chapter 5.2.4 ""for interpreting and removing the; special '.' and '..' complete path segments from a; referenced path"". Bool_t IsAbsolute() const; Returns kTRUE if instance qualifies as absolute-URI; absolute-URI = scheme "":"" hier-part [ ""?"" query ]; cf. Appendix A. Bool_t IsRelative() const; Returns kTRUE if instance qualifies as relative-ref; relative-ref = relative-part [ ""?"" query ] [ ""#"" fragment ]; cf. Appendix A. Bool_t IsUri() const; Returns kTRUE if instance qualifies as URI; URI = scheme "":"" hier-part [ ""?"" query ] [ ""#"" fragment ]; cf. Appendix A. Bool_t IsReference() const; Returns kTRUE if instance qualifies as URI-reference; URI-reference = URI / relative-ref; cf. Appendix A. Bool_t SetScheme(const TString& scheme); Set scheme component of URI:; scheme = ALPHA *( ALPHA / DIGIT / ""+"" / ""-"" / ""."" ). Bool_t IsScheme(const TString& ); Returns kTRUE if string qualifies as URI scheme:; scheme = ALPHA *( ALPHA / DIGIT / ""+"" / """,MatchSource.WIKI,root/html532/TUri.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUri.html
https://root.cern/root/html532/TUri.html:3131,Modifiability,Inherit,InheritsFrom,3131,"ual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const TStringGetPath() const; const TStringGetPort() const; const TStringGetQuery() const; const TStringGetRelativePart() const; const TStringGetScheme() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const TStringGetUri() const; const TStringGetUserInfo() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tHasAuthority() const; Bool_tHasFragment() const; virtual ULong_tTObject::Hash() const; Bool_tHasHierPart() const; Bool_tHasHost() const; Bool_tHasPath() const; Bool_tHasPort() const; Bool_tHasQuery() const; Bool_tHasRelativePart() const; Bool_tHasScheme() const; Bool_tHasUserInfo() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tIsAbsolute() const; static Bool_tIsAuthority(const TString&); virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; static Bool_tIsFragment(const TString&); static Bool_tIsHierPart(const TString&); static Bool_tIsHost(const TString&); static Bool_tIsIpv4(const TString&); Bool_tTObject::IsOnHeap() const; static Bool_tIsPath(const TString&); static Bool_tIsPathAbempty(const TString&); static Bool_tIsPathAbsolute(const TString&); static Bool_tIsPathEmpty(const TString&); static Bool_tIsPathNoscheme(const TString&); static Bool_tIsPathRootless(const TString&); static Bool_tIsPort(const TString&); static Bool_tIsQuery(const TString&); Bool_tIsReference() const; static Bool_tIsRegName(const TString&); Bool_tIsRelative() const; static Bool_tIsR",MatchSource.WIKI,root/html532/TUri.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUri.html
https://root.cern/root/html532/TUri.html:3197,Modifiability,Inherit,InheritsFrom,3197,"bject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const TStringGetPath() const; const TStringGetPort() const; const TStringGetQuery() const; const TStringGetRelativePart() const; const TStringGetScheme() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const TStringGetUri() const; const TStringGetUserInfo() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tHasAuthority() const; Bool_tHasFragment() const; virtual ULong_tTObject::Hash() const; Bool_tHasHierPart() const; Bool_tHasHost() const; Bool_tHasPath() const; Bool_tHasPort() const; Bool_tHasQuery() const; Bool_tHasRelativePart() const; Bool_tHasScheme() const; Bool_tHasUserInfo() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tIsAbsolute() const; static Bool_tIsAuthority(const TString&); virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; static Bool_tIsFragment(const TString&); static Bool_tIsHierPart(const TString&); static Bool_tIsHost(const TString&); static Bool_tIsIpv4(const TString&); Bool_tTObject::IsOnHeap() const; static Bool_tIsPath(const TString&); static Bool_tIsPathAbempty(const TString&); static Bool_tIsPathAbsolute(const TString&); static Bool_tIsPathEmpty(const TString&); static Bool_tIsPathNoscheme(const TString&); static Bool_tIsPathRootless(const TString&); static Bool_tIsPort(const TString&); static Bool_tIsQuery(const TString&); Bool_tIsReference() const; static Bool_tIsRegName(const TString&); Bool_tIsRelative() const; static Bool_tIsRelativePart(const TString&); static Bool_tIsScheme(const TString&)",MatchSource.WIKI,root/html532/TUri.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUri.html
https://root.cern/root/html532/TUri.html:7991,Modifiability,Inherit,Inheritance,7991,"st; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TStringfFragment; Bool_tfHasFragment; Bool_tfHasHost; Bool_tfHasPath; Bool_tfHasPort; Bool_tfHasQuery; Bool_tfHasScheme; Bool_tfHasUserinfo; TStringfHostauthority/host: hostname or ip-address; TStringfPath; TStringfPortauthority/port: port number, normally 1-65535; TStringfQuery; TStringfScheme; TStringfUserinfoauthority/userinfo: user@password, ... Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUri(const TString& uri); Constructor that calls SetUri with a complete URI. TUri(const char* uri); Constructor that calls SetUri with a complete URI. TUri(const TUri& uri); TUri copy ctor. TUri & operator=(const TUri& rhs); TUri assignment operator. const TString GetUri() const; Returns the whole URI -; an implementation of chapter 5.3 component recomposition.; The result URI is composed out of the five basic parts. URI = scheme "":"" hier-part [ ""?"" query ] [ ""#"" fragment ]; hier-part = ""//"" authority path-abempty; / path-absolute; / path-rootless; / path-empty. const TString RemoveDotSegments(const TString& ); This functions implements the ""remove_dot_segments"" routine; of chapter 5.2.4 ""for interpreting and removing the; special '.' and '..' complete path segments from a; referenced path"". Bool_t IsAbsolute() const; Returns kTRUE if instance qualifies as absolute-URI; absolute-URI = scheme "":"" hier-part [ ""?"" query ]; cf. Appendix A.",MatchSource.WIKI,root/html532/TUri.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUri.html
https://root.cern/root/html532/TUri.html:8004,Modifiability,Inherit,Inherited,8004,"st; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TStringfFragment; Bool_tfHasFragment; Bool_tfHasHost; Bool_tfHasPath; Bool_tfHasPort; Bool_tfHasQuery; Bool_tfHasScheme; Bool_tfHasUserinfo; TStringfHostauthority/host: hostname or ip-address; TStringfPath; TStringfPortauthority/port: port number, normally 1-65535; TStringfQuery; TStringfScheme; TStringfUserinfoauthority/userinfo: user@password, ... Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUri(const TString& uri); Constructor that calls SetUri with a complete URI. TUri(const char* uri); Constructor that calls SetUri with a complete URI. TUri(const TUri& uri); TUri copy ctor. TUri & operator=(const TUri& rhs); TUri assignment operator. const TString GetUri() const; Returns the whole URI -; an implementation of chapter 5.3 component recomposition.; The result URI is composed out of the five basic parts. URI = scheme "":"" hier-part [ ""?"" query ] [ ""#"" fragment ]; hier-part = ""//"" authority path-abempty; / path-absolute; / path-rootless; / path-empty. const TString RemoveDotSegments(const TString& ); This functions implements the ""remove_dot_segments"" routine; of chapter 5.2.4 ""for interpreting and removing the; special '.' and '..' complete path segments from a; referenced path"". Bool_t IsAbsolute() const; Returns kTRUE if instance qualifies as absolute-URI; absolute-URI = scheme "":"" hier-part [ ""?"" query ]; cf. Appendix A.",MatchSource.WIKI,root/html532/TUri.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUri.html
https://root.cern/root/html532/TUri.html:11943,Modifiability,variab,variables,11943,"Bool_t SetPort(const TString& port); Set port component of URI:; port = *DIGIT. Bool_t SetPath(const TString& path); Set path component of URI:; path = path-abempty ; begins with ""/"" or is empty; / path-absolute ; begins with ""/"" but not ""//""; / path-noscheme ; begins with a non-colon segment; / path-rootless ; begins with a segment; / path-empty ; zero characters. Bool_t SetFragment(const TString& fragment); Set fragment component of URI:; fragment = *( pchar / ""/"" / ""?"" ). Bool_t IsFragment(const TString& ); Returns kTRUE if string qualifies as valid fragment component; fragment = *( pchar / ""/"" / ""?"" ). void Print(Option_t* option = """") const; Display function,; option ""d"" .. debug output; anything else .. simply print URI. void Reset(); Initialize this URI object.; Set all TString members to empty string,; set all Bool_t members to kFALSE. Bool_t SetUri(const TString& uri); Parse URI and set the member variables accordingly,; returns kTRUE if URI validates, and kFALSE otherwise:; URI = scheme "":"" hier-part [ ""?"" query ] [ ""#"" fragment ]; hier-part = ""//"" authority path-abempty; / path-absolute; / path-rootless; / path-empty. const TString GetHierPart() const; hier-part = ""//"" authority path-abempty; / path-absolute; / path-rootless; / path-empty. const TString GetRelativePart() const; relative-part = ""//"" authority path-abempty; / path-absolute; / path-noscheme; / path-empty. Bool_t SetHierPart(const TString& hier); returns hier-part component of URI; hier-part = ""//"" authority path-abempty; / path-absolute; / path-rootless; / path-empty. Bool_t IsHierPart(const TString& ); Returns kTRUE if string qualifies as hier-part:. hier-part = ""//"" authority path-abempty; / path-absolute; / path-rootless; / path-empty. Bool_t IsRelativePart(const TString& ); Returns kTRUE is string qualifies as relative-part:; relative-part = ""//"" authority path-abempty; / path-absolute; / path-noscheme; / path-empty. Bool_t SetRelativePart(const TString& ); Returns kTRUE is string qualifi",MatchSource.WIKI,root/html532/TUri.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUri.html
https://root.cern/root/html532/TUri.html:488,Security,validat,validating,488,". TUri. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TUri. class TUri: public TObject. TUri. This class represents a RFC 3986 compatible URI.; See http://rfc.net/rfc3986.html.; It provides member functions to set and return the different; the different parts of an URI. The functionality is that of; a validating parser. Function Members (Methods); public:. TUri(); TUri(const TUri& uri); TUri(const TString& uri); TUri(const char* uri); virtual~TUri(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const TStringGetAuthority() const; virtual Option_t*TObject::GetDrawOption() const; sta",MatchSource.WIKI,root/html532/TUri.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUri.html
https://root.cern/root/html532/TUri.html:2818,Security,Hash,Hash,2818,"bject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const TStringGetAuthority() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const TStringGetFragment() const; const TStringGetHierPart() const; const TStringGetHost() const; virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const TStringGetPath() const; const TStringGetPort() const; const TStringGetQuery() const; const TStringGetRelativePart() const; const TStringGetScheme() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const TStringGetUri() const; const TStringGetUserInfo() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tHasAuthority() const; Bool_tHasFragment() const; virtual ULong_tTObject::Hash() const; Bool_tHasHierPart() const; Bool_tHasHost() const; Bool_tHasPath() const; Bool_tHasPort() const; Bool_tHasQuery() const; Bool_tHasRelativePart() const; Bool_tHasScheme() const; Bool_tHasUserInfo() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tIsAbsolute() const; static Bool_tIsAuthority(const TString&); virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; static Bool_tIsFragment(const TString&); static Bool_tIsHierPart(const TString&); static Bool_tIsHost(const TString&); static Bool_tIsIpv4(const TString&); Bool_tTObject::IsOnHeap() const; static Bool_tIsPath(const TString&); static Bool_tIsPathAbempty(const TString&); static Bool_tIsPathAbsolute(const TString&);",MatchSource.WIKI,root/html532/TUri.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUri.html
https://root.cern/root/html532/TUri.html:7963,Security,password,password,7963,"; Int_tTObject::TestBits(UInt_t f) const; static TUriTransform(const TUri& reference, const TUri& base); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TStringfFragment; Bool_tfHasFragment; Bool_tfHasHost; Bool_tfHasPath; Bool_tfHasPort; Bool_tfHasQuery; Bool_tfHasScheme; Bool_tfHasUserinfo; TStringfHostauthority/host: hostname or ip-address; TStringfPath; TStringfPortauthority/port: port number, normally 1-65535; TStringfQuery; TStringfScheme; TStringfUserinfoauthority/userinfo: user@password, ... Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUri(const TString& uri); Constructor that calls SetUri with a complete URI. TUri(const char* uri); Constructor that calls SetUri with a complete URI. TUri(const TUri& uri); TUri copy ctor. TUri & operator=(const TUri& rhs); TUri assignment operator. const TString GetUri() const; Returns the whole URI -; an implementation of chapter 5.3 component recomposition.; The result URI is composed out of the five basic parts. URI = scheme "":"" hier-part [ ""?"" query ] [ ""#"" fragment ]; hier-part = ""//"" authority path-abempty; / path-absolute; / path-rootless; / path-empty. const TString RemoveDotSegments(const TString& ); This functions implements the ""remove_dot_segments"" routine; of chapter 5.2.4 ""for interpreting and removing the",MatchSource.WIKI,root/html532/TUri.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUri.html
https://root.cern/root/html532/TUri.html:11988,Security,validat,validates,11988,"Bool_t SetPort(const TString& port); Set port component of URI:; port = *DIGIT. Bool_t SetPath(const TString& path); Set path component of URI:; path = path-abempty ; begins with ""/"" or is empty; / path-absolute ; begins with ""/"" but not ""//""; / path-noscheme ; begins with a non-colon segment; / path-rootless ; begins with a segment; / path-empty ; zero characters. Bool_t SetFragment(const TString& fragment); Set fragment component of URI:; fragment = *( pchar / ""/"" / ""?"" ). Bool_t IsFragment(const TString& ); Returns kTRUE if string qualifies as valid fragment component; fragment = *( pchar / ""/"" / ""?"" ). void Print(Option_t* option = """") const; Display function,; option ""d"" .. debug output; anything else .. simply print URI. void Reset(); Initialize this URI object.; Set all TString members to empty string,; set all Bool_t members to kFALSE. Bool_t SetUri(const TString& uri); Parse URI and set the member variables accordingly,; returns kTRUE if URI validates, and kFALSE otherwise:; URI = scheme "":"" hier-part [ ""?"" query ] [ ""#"" fragment ]; hier-part = ""//"" authority path-abempty; / path-absolute; / path-rootless; / path-empty. const TString GetHierPart() const; hier-part = ""//"" authority path-abempty; / path-absolute; / path-rootless; / path-empty. const TString GetRelativePart() const; relative-part = ""//"" authority path-abempty; / path-absolute; / path-noscheme; / path-empty. Bool_t SetHierPart(const TString& hier); returns hier-part component of URI; hier-part = ""//"" authority path-abempty; / path-absolute; / path-rootless; / path-empty. Bool_t IsHierPart(const TString& ); Returns kTRUE if string qualifies as hier-part:. hier-part = ""//"" authority path-abempty; / path-absolute; / path-rootless; / path-empty. Bool_t IsRelativePart(const TString& ); Returns kTRUE is string qualifies as relative-part:; relative-part = ""//"" authority path-abempty; / path-absolute; / path-noscheme; / path-empty. Bool_t SetRelativePart(const TString& ); Returns kTRUE is string qualifi",MatchSource.WIKI,root/html532/TUri.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUri.html
https://root.cern/root/html532/TUri.html:17222,Security,HasH,HasHierPart,17222,"s target URI using; given a base URI.; This is an implementation of the pseudocode in chapter 5.2.2. const TString MergePaths(const TUri& reference, const TUri& base); RFC 3986, 5.3.2.; If the base URI has a defined authority component and an empty; path, then return a string consisting of ""/"" concatenated with the; reference's path; otherwise,; return a string consisting of the reference's path component; appended to all but the last segment of the base URI's path (i.e.,; excluding any characters after the right-most ""/"" in the base URI; path, or excluding the entire base URI path if it does not contain; any ""/"" characters). TUri(const TUri& uri). virtual ~TUri(); { }. const TString GetScheme() const; { return fScheme; }. const TString GetUserInfo() const; { return fUserinfo; }. const TString GetHost() const; { return fHost; }. const TString GetPort() const; { return fPort; }. const TString GetPath() const; { return fPath; }. const TString GetQuery() const; { return fQuery; }. const TString GetFragment() const; { return fFragment; }. Bool_t HasScheme() const; { return fHasScheme; }. Bool_t HasHierPart() const; { return IsHierPart(GetHierPart()); }. Bool_t HasAuthority() const; { return fHasHost; }. Bool_t HasUserInfo() const; { return fHasUserinfo; }. Bool_t HasHost() const; { return fHasHost; }. Bool_t HasPort() const; { return fHasPort; }. Bool_t HasPath() const; { return fHasPath; }. Bool_t HasQuery() const; { return fHasQuery; }. Bool_t HasFragment() const; { return fHasFragment; }. Bool_t HasRelativePart() const; { return IsRelativePart(GetRelativePart()); }. Bool_t IsSortable() const; { return kTRUE; }. » Author: Gerhard E. Bruckner 15/07/07 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TUri.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TUri.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUri.html
https://root.cern/root/html532/TUri.html:17394,Security,HasH,HasHost,17394,"s target URI using; given a base URI.; This is an implementation of the pseudocode in chapter 5.2.2. const TString MergePaths(const TUri& reference, const TUri& base); RFC 3986, 5.3.2.; If the base URI has a defined authority component and an empty; path, then return a string consisting of ""/"" concatenated with the; reference's path; otherwise,; return a string consisting of the reference's path component; appended to all but the last segment of the base URI's path (i.e.,; excluding any characters after the right-most ""/"" in the base URI; path, or excluding the entire base URI path if it does not contain; any ""/"" characters). TUri(const TUri& uri). virtual ~TUri(); { }. const TString GetScheme() const; { return fScheme; }. const TString GetUserInfo() const; { return fUserinfo; }. const TString GetHost() const; { return fHost; }. const TString GetPort() const; { return fPort; }. const TString GetPath() const; { return fPath; }. const TString GetQuery() const; { return fQuery; }. const TString GetFragment() const; { return fFragment; }. Bool_t HasScheme() const; { return fHasScheme; }. Bool_t HasHierPart() const; { return IsHierPart(GetHierPart()); }. Bool_t HasAuthority() const; { return fHasHost; }. Bool_t HasUserInfo() const; { return fHasUserinfo; }. Bool_t HasHost() const; { return fHasHost; }. Bool_t HasPort() const; { return fHasPort; }. Bool_t HasPath() const; { return fHasPath; }. Bool_t HasQuery() const; { return fHasQuery; }. Bool_t HasFragment() const; { return fHasFragment; }. Bool_t HasRelativePart() const; { return IsRelativePart(GetRelativePart()); }. Bool_t IsSortable() const; { return kTRUE; }. » Author: Gerhard E. Bruckner 15/07/07 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TUri.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TUri.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUri.html
https://root.cern/root/html532/TUri.html:6776,Testability,Test,TestBit,6776,"onst TStringPctDecode(const TString& source); static const TStringPctDecodeUnreserved(const TString& source); static const TStringPctEncode(const TString& source); static const TStringPctNormalise(const TString& source); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); static const TStringRemoveDotSegments(const TString&); voidReset(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); Bool_tSetAuthority(const TString& authority); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); Bool_tSetFragment(const TString& fragment); Bool_tSetHierPart(const TString& hier); Bool_tSetHost(const TString& host); static voidTObject::SetObjectStat(Bool_t stat); Bool_tSetPath(const TString& path); Bool_tSetPort(const TString& port); Bool_tSetQuery(const TString& path); Bool_tSetRelativePart(const TString&); Bool_tSetScheme(const TString& scheme); virtual voidTObject::SetUniqueID(UInt_t uid); Bool_tSetUri(const TString& uri); Bool_tSetUserInfo(const TString& userinfo); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; static TUriTransform(const TUri& reference, const TUri& base); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TUri.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUri.html
https://root.cern/root/html532/TUri.html:6815,Testability,Test,TestBits,6815,"onst TStringPctDecode(const TString& source); static const TStringPctDecodeUnreserved(const TString& source); static const TStringPctEncode(const TString& source); static const TStringPctNormalise(const TString& source); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); static const TStringRemoveDotSegments(const TString&); voidReset(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); Bool_tSetAuthority(const TString& authority); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); Bool_tSetFragment(const TString& fragment); Bool_tSetHierPart(const TString& hier); Bool_tSetHost(const TString& host); static voidTObject::SetObjectStat(Bool_t stat); Bool_tSetPath(const TString& path); Bool_tSetPort(const TString& port); Bool_tSetQuery(const TString& path); Bool_tSetRelativePart(const TString&); Bool_tSetScheme(const TString& scheme); virtual voidTObject::SetUniqueID(UInt_t uid); Bool_tSetUri(const TString& uri); Bool_tSetUserInfo(const TString& userinfo); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; static TUriTransform(const TUri& reference, const TUri& base); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TUri.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUri.html
https://root.cern/root/html532/TUri.html:883,Usability,Clear,Clear,883," TUri(); TUri(const TUri& uri); TUri(const TString& uri); TUri(const char* uri); virtual~TUri(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const TStringGetAuthority() const; virtual Option_t*TObject::GetDrawOption() const; sta",MatchSource.WIKI,root/html532/TUri.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUri.html
https://root.cern/root/html532/TUri.html:11742,Usability,simpl,simply,11742," userinfo = *( unreserved / pct-encoded / sub-delims / "":"" ); this equals to pchar without the '@' character. Bool_t SetHost(const TString& host); Set host component of URI:; RFC 3986: host = IP-literal / IPv4address / reg-name; implemented: host = IPv4address / reg-name. Bool_t SetPort(const TString& port); Set port component of URI:; port = *DIGIT. Bool_t SetPath(const TString& path); Set path component of URI:; path = path-abempty ; begins with ""/"" or is empty; / path-absolute ; begins with ""/"" but not ""//""; / path-noscheme ; begins with a non-colon segment; / path-rootless ; begins with a segment; / path-empty ; zero characters. Bool_t SetFragment(const TString& fragment); Set fragment component of URI:; fragment = *( pchar / ""/"" / ""?"" ). Bool_t IsFragment(const TString& ); Returns kTRUE if string qualifies as valid fragment component; fragment = *( pchar / ""/"" / ""?"" ). void Print(Option_t* option = """") const; Display function,; option ""d"" .. debug output; anything else .. simply print URI. void Reset(); Initialize this URI object.; Set all TString members to empty string,; set all Bool_t members to kFALSE. Bool_t SetUri(const TString& uri); Parse URI and set the member variables accordingly,; returns kTRUE if URI validates, and kFALSE otherwise:; URI = scheme "":"" hier-part [ ""?"" query ] [ ""#"" fragment ]; hier-part = ""//"" authority path-abempty; / path-absolute; / path-rootless; / path-empty. const TString GetHierPart() const; hier-part = ""//"" authority path-abempty; / path-absolute; / path-rootless; / path-empty. const TString GetRelativePart() const; relative-part = ""//"" authority path-abempty; / path-absolute; / path-noscheme; / path-empty. Bool_t SetHierPart(const TString& hier); returns hier-part component of URI; hier-part = ""//"" authority path-abempty; / path-absolute; / path-rootless; / path-empty. Bool_t IsHierPart(const TString& ); Returns kTRUE if string qualifies as hier-part:. hier-part = ""//"" authority path-abempty; / path-absolute; / path-rootless",MatchSource.WIKI,root/html532/TUri.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUri.html
https://root.cern/root/html532/TUrl.html:1429,Availability,Error,Error,1429," TUrl(); TUrl(const TUrl& url); TUrl(const char* url, Bool_t defaultIsFile = kFALSE); virtual~TUrl(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; voidCleanRelativePath(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetAnchor() const; virtual Option_t*TObject::GetDrawOption() const; st",MatchSource.WIKI,root/html532/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUrl.html
https://root.cern/root/html532/TUrl.html:1558,Availability,error,error,1558,"Url(const char* url, Bool_t defaultIsFile = kFALSE); virtual~TUrl(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; voidCleanRelativePath(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetAnchor() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetFile() const; const char*GetFileAndOptions() const; const char*GetHost() const; const char*GetHostFQDN() const; virtual const char*TObject::GetIconName() const; Int_tGetIntValueFromOptions(const char* key) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetOptions() const; const char*GetPasswd() const; Int_tGetPort() const; const char*GetProtocol(",MatchSource.WIKI,root/html532/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUrl.html
https://root.cern/root/html532/TUrl.html:1642,Availability,error,error,1642,"stractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; voidCleanRelativePath(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetAnchor() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetFile() const; const char*GetFileAndOptions() const; const char*GetHost() const; const char*GetHostFQDN() const; virtual const char*TObject::GetIconName() const; Int_tGetIntValueFromOptions(const char* key) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetOptions() const; const char*GetPasswd() const; Int_tGetPort() const; const char*GetProtocol() const; static TObjArray*GetSpecialProtocols(); virtual const char*TObject::GetTitl",MatchSource.WIKI,root/html532/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUrl.html
https://root.cern/root/html532/TUrl.html:6880,Integrability,protocol,protocols,6880," const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. voidFindFile(char* u, Bool_t stripDoubleSlash = kTRUE). Data Members; public:. enum EStatusBits { kUrlWithDefaultPort; kUrlHasDefaultPort; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TStringfAnchoranchor in object (after #); TStringfFileremote object; TStringfFileOA!file with option and anchor; TStringfHostremote host; TStringfHostFQ!fully qualified host name; TStringfOptionsoptions/search (after ?); TMap*fOptionsMap!map containing options key/value pairs; TStringfPasswdpassword; Int_tfPortport through which to contact remote server; TStringfProtocolprotocol: http, ftp, news, root, proof, ...; TStringfUrlfull URL; TStringfUseruser name; static THashList*fgHostFQDNslist of resolved host FQDNs; static TObjArray*fgSpecialProtocolslist of special protocols. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUrl(const char* url, Bool_t defaultIsFile = kFALSE); Parse url character string and split in its different subcomponents.; Use IsValid() to check if URL is legal. url: [proto://][user[:passwd]@]host[:port]/file.ext[?options][#anchor]. Known protocols: http, root, proof, ftp, news and any special protocols; defined in the rootrc Url.Special key.; The default protocol is ""http"", unless defaultIsFile is true in which; case the url is assumed to be of type ""file"".; If a passwd contains a @ it must be escaped by a \\, e.g.; ""pip@"" becomes ""pip\\@"". Default ports: http=80, root=1094, proof=1093, ftp=20, news=119.; Port #1093 has been assigned by IANA (www.iana.org) to proofd.; Port #1094 has been assigned by IANA (www.iana.org) to rootd. ~TUrl(); Cleanup. void SetUrl(const char* url, Bool_t defaultIsFile = kFALSE); Pars",MatchSource.WIKI,root/html532/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUrl.html
https://root.cern/root/html532/TUrl.html:7224,Integrability,protocol,protocols,7224,"y; kOverwrite; kWriteDelete; };. private:. TStringfAnchoranchor in object (after #); TStringfFileremote object; TStringfFileOA!file with option and anchor; TStringfHostremote host; TStringfHostFQ!fully qualified host name; TStringfOptionsoptions/search (after ?); TMap*fOptionsMap!map containing options key/value pairs; TStringfPasswdpassword; Int_tfPortport through which to contact remote server; TStringfProtocolprotocol: http, ftp, news, root, proof, ...; TStringfUrlfull URL; TStringfUseruser name; static THashList*fgHostFQDNslist of resolved host FQDNs; static TObjArray*fgSpecialProtocolslist of special protocols. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUrl(const char* url, Bool_t defaultIsFile = kFALSE); Parse url character string and split in its different subcomponents.; Use IsValid() to check if URL is legal. url: [proto://][user[:passwd]@]host[:port]/file.ext[?options][#anchor]. Known protocols: http, root, proof, ftp, news and any special protocols; defined in the rootrc Url.Special key.; The default protocol is ""http"", unless defaultIsFile is true in which; case the url is assumed to be of type ""file"".; If a passwd contains a @ it must be escaped by a \\, e.g.; ""pip@"" becomes ""pip\\@"". Default ports: http=80, root=1094, proof=1093, ftp=20, news=119.; Port #1093 has been assigned by IANA (www.iana.org) to proofd.; Port #1094 has been assigned by IANA (www.iana.org) to rootd. ~TUrl(); Cleanup. void SetUrl(const char* url, Bool_t defaultIsFile = kFALSE); Parse url character string and split in its different subcomponents.; Use IsValid() to check if URL is legal. url: [proto://][user[:passwd]@]host[:port]/file.ext[?options][#anchor]. Known protocols: http, root, proof, ftp, news and any special protocols; defined in the rootrc Url.Special key.; The default protocol is ""http"", unless defaultIsFile is true in which; case the url is assumed to be of type ""file"".; If a passwd contains a @ it must be escaped by a \",MatchSource.WIKI,root/html532/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUrl.html
https://root.cern/root/html532/TUrl.html:7280,Integrability,protocol,protocols,7280,"y; kOverwrite; kWriteDelete; };. private:. TStringfAnchoranchor in object (after #); TStringfFileremote object; TStringfFileOA!file with option and anchor; TStringfHostremote host; TStringfHostFQ!fully qualified host name; TStringfOptionsoptions/search (after ?); TMap*fOptionsMap!map containing options key/value pairs; TStringfPasswdpassword; Int_tfPortport through which to contact remote server; TStringfProtocolprotocol: http, ftp, news, root, proof, ...; TStringfUrlfull URL; TStringfUseruser name; static THashList*fgHostFQDNslist of resolved host FQDNs; static TObjArray*fgSpecialProtocolslist of special protocols. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUrl(const char* url, Bool_t defaultIsFile = kFALSE); Parse url character string and split in its different subcomponents.; Use IsValid() to check if URL is legal. url: [proto://][user[:passwd]@]host[:port]/file.ext[?options][#anchor]. Known protocols: http, root, proof, ftp, news and any special protocols; defined in the rootrc Url.Special key.; The default protocol is ""http"", unless defaultIsFile is true in which; case the url is assumed to be of type ""file"".; If a passwd contains a @ it must be escaped by a \\, e.g.; ""pip@"" becomes ""pip\\@"". Default ports: http=80, root=1094, proof=1093, ftp=20, news=119.; Port #1093 has been assigned by IANA (www.iana.org) to proofd.; Port #1094 has been assigned by IANA (www.iana.org) to rootd. ~TUrl(); Cleanup. void SetUrl(const char* url, Bool_t defaultIsFile = kFALSE); Parse url character string and split in its different subcomponents.; Use IsValid() to check if URL is legal. url: [proto://][user[:passwd]@]host[:port]/file.ext[?options][#anchor]. Known protocols: http, root, proof, ftp, news and any special protocols; defined in the rootrc Url.Special key.; The default protocol is ""http"", unless defaultIsFile is true in which; case the url is assumed to be of type ""file"".; If a passwd contains a @ it must be escaped by a \",MatchSource.WIKI,root/html532/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUrl.html
https://root.cern/root/html532/TUrl.html:7343,Integrability,protocol,protocol,7343,"ileOA!file with option and anchor; TStringfHostremote host; TStringfHostFQ!fully qualified host name; TStringfOptionsoptions/search (after ?); TMap*fOptionsMap!map containing options key/value pairs; TStringfPasswdpassword; Int_tfPortport through which to contact remote server; TStringfProtocolprotocol: http, ftp, news, root, proof, ...; TStringfUrlfull URL; TStringfUseruser name; static THashList*fgHostFQDNslist of resolved host FQDNs; static TObjArray*fgSpecialProtocolslist of special protocols. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUrl(const char* url, Bool_t defaultIsFile = kFALSE); Parse url character string and split in its different subcomponents.; Use IsValid() to check if URL is legal. url: [proto://][user[:passwd]@]host[:port]/file.ext[?options][#anchor]. Known protocols: http, root, proof, ftp, news and any special protocols; defined in the rootrc Url.Special key.; The default protocol is ""http"", unless defaultIsFile is true in which; case the url is assumed to be of type ""file"".; If a passwd contains a @ it must be escaped by a \\, e.g.; ""pip@"" becomes ""pip\\@"". Default ports: http=80, root=1094, proof=1093, ftp=20, news=119.; Port #1093 has been assigned by IANA (www.iana.org) to proofd.; Port #1094 has been assigned by IANA (www.iana.org) to rootd. ~TUrl(); Cleanup. void SetUrl(const char* url, Bool_t defaultIsFile = kFALSE); Parse url character string and split in its different subcomponents.; Use IsValid() to check if URL is legal. url: [proto://][user[:passwd]@]host[:port]/file.ext[?options][#anchor]. Known protocols: http, root, proof, ftp, news and any special protocols; defined in the rootrc Url.Special key.; The default protocol is ""http"", unless defaultIsFile is true in which; case the url is assumed to be of type ""file"".; If a passwd contains a @ it must be escaped by a \\, e.g.; ""pip@"" becomes ""pip\\@"". Default ports: http=80, root=1094, proof=1093, ftp=20, news=119.; Port #1093 has been a",MatchSource.WIKI,root/html532/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUrl.html
https://root.cern/root/html532/TUrl.html:7992,Integrability,protocol,protocols,7992," Parse url character string and split in its different subcomponents.; Use IsValid() to check if URL is legal. url: [proto://][user[:passwd]@]host[:port]/file.ext[?options][#anchor]. Known protocols: http, root, proof, ftp, news and any special protocols; defined in the rootrc Url.Special key.; The default protocol is ""http"", unless defaultIsFile is true in which; case the url is assumed to be of type ""file"".; If a passwd contains a @ it must be escaped by a \\, e.g.; ""pip@"" becomes ""pip\\@"". Default ports: http=80, root=1094, proof=1093, ftp=20, news=119.; Port #1093 has been assigned by IANA (www.iana.org) to proofd.; Port #1094 has been assigned by IANA (www.iana.org) to rootd. ~TUrl(); Cleanup. void SetUrl(const char* url, Bool_t defaultIsFile = kFALSE); Parse url character string and split in its different subcomponents.; Use IsValid() to check if URL is legal. url: [proto://][user[:passwd]@]host[:port]/file.ext[?options][#anchor]. Known protocols: http, root, proof, ftp, news and any special protocols; defined in the rootrc Url.Special key.; The default protocol is ""http"", unless defaultIsFile is true in which; case the url is assumed to be of type ""file"".; If a passwd contains a @ it must be escaped by a \\, e.g.; ""pip@"" becomes ""pip\\@"". Default ports: http=80, root=1094, proof=1093, ftp=20, news=119.; Port #1093 has been assigned by IANA (www.iana.org) to proofd.; Port #1094 has been assigned by IANA (www.iana.org) to rootd. void FindFile(char* u, Bool_t stripDoubleSlash = kTRUE); Find file and optionally anchor and options. TUrl(const TUrl& url); TUrl copt ctor. TUrl & operator=(const TUrl& rhs); TUrl assignment operator. const char * GetUrl(Bool_t withDeflt = kFALSE) const; Return full URL. If withDflt is kTRUE, explicitly add the port even; if it matches the default value for the URL protocol. const char * GetHostFQDN() const; Return fully qualified domain name of url host. If host cannot be; resolved or not valid return the host name as originally speci",MatchSource.WIKI,root/html532/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUrl.html
https://root.cern/root/html532/TUrl.html:8048,Integrability,protocol,protocols,8048," Parse url character string and split in its different subcomponents.; Use IsValid() to check if URL is legal. url: [proto://][user[:passwd]@]host[:port]/file.ext[?options][#anchor]. Known protocols: http, root, proof, ftp, news and any special protocols; defined in the rootrc Url.Special key.; The default protocol is ""http"", unless defaultIsFile is true in which; case the url is assumed to be of type ""file"".; If a passwd contains a @ it must be escaped by a \\, e.g.; ""pip@"" becomes ""pip\\@"". Default ports: http=80, root=1094, proof=1093, ftp=20, news=119.; Port #1093 has been assigned by IANA (www.iana.org) to proofd.; Port #1094 has been assigned by IANA (www.iana.org) to rootd. ~TUrl(); Cleanup. void SetUrl(const char* url, Bool_t defaultIsFile = kFALSE); Parse url character string and split in its different subcomponents.; Use IsValid() to check if URL is legal. url: [proto://][user[:passwd]@]host[:port]/file.ext[?options][#anchor]. Known protocols: http, root, proof, ftp, news and any special protocols; defined in the rootrc Url.Special key.; The default protocol is ""http"", unless defaultIsFile is true in which; case the url is assumed to be of type ""file"".; If a passwd contains a @ it must be escaped by a \\, e.g.; ""pip@"" becomes ""pip\\@"". Default ports: http=80, root=1094, proof=1093, ftp=20, news=119.; Port #1093 has been assigned by IANA (www.iana.org) to proofd.; Port #1094 has been assigned by IANA (www.iana.org) to rootd. void FindFile(char* u, Bool_t stripDoubleSlash = kTRUE); Find file and optionally anchor and options. TUrl(const TUrl& url); TUrl copt ctor. TUrl & operator=(const TUrl& rhs); TUrl assignment operator. const char * GetUrl(Bool_t withDeflt = kFALSE) const; Return full URL. If withDflt is kTRUE, explicitly add the port even; if it matches the default value for the URL protocol. const char * GetHostFQDN() const; Return fully qualified domain name of url host. If host cannot be; resolved or not valid return the host name as originally speci",MatchSource.WIKI,root/html532/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUrl.html
https://root.cern/root/html532/TUrl.html:8111,Integrability,protocol,protocol,8111,"o://][user[:passwd]@]host[:port]/file.ext[?options][#anchor]. Known protocols: http, root, proof, ftp, news and any special protocols; defined in the rootrc Url.Special key.; The default protocol is ""http"", unless defaultIsFile is true in which; case the url is assumed to be of type ""file"".; If a passwd contains a @ it must be escaped by a \\, e.g.; ""pip@"" becomes ""pip\\@"". Default ports: http=80, root=1094, proof=1093, ftp=20, news=119.; Port #1093 has been assigned by IANA (www.iana.org) to proofd.; Port #1094 has been assigned by IANA (www.iana.org) to rootd. ~TUrl(); Cleanup. void SetUrl(const char* url, Bool_t defaultIsFile = kFALSE); Parse url character string and split in its different subcomponents.; Use IsValid() to check if URL is legal. url: [proto://][user[:passwd]@]host[:port]/file.ext[?options][#anchor]. Known protocols: http, root, proof, ftp, news and any special protocols; defined in the rootrc Url.Special key.; The default protocol is ""http"", unless defaultIsFile is true in which; case the url is assumed to be of type ""file"".; If a passwd contains a @ it must be escaped by a \\, e.g.; ""pip@"" becomes ""pip\\@"". Default ports: http=80, root=1094, proof=1093, ftp=20, news=119.; Port #1093 has been assigned by IANA (www.iana.org) to proofd.; Port #1094 has been assigned by IANA (www.iana.org) to rootd. void FindFile(char* u, Bool_t stripDoubleSlash = kTRUE); Find file and optionally anchor and options. TUrl(const TUrl& url); TUrl copt ctor. TUrl & operator=(const TUrl& rhs); TUrl assignment operator. const char * GetUrl(Bool_t withDeflt = kFALSE) const; Return full URL. If withDflt is kTRUE, explicitly add the port even; if it matches the default value for the URL protocol. const char * GetHostFQDN() const; Return fully qualified domain name of url host. If host cannot be; resolved or not valid return the host name as originally specified. const char * GetFileAndOptions() const; Return the file and its options (the string specified behind the ?).; Conve",MatchSource.WIKI,root/html532/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUrl.html
https://root.cern/root/html532/TUrl.html:8862,Integrability,protocol,protocol,8862,"acter string and split in its different subcomponents.; Use IsValid() to check if URL is legal. url: [proto://][user[:passwd]@]host[:port]/file.ext[?options][#anchor]. Known protocols: http, root, proof, ftp, news and any special protocols; defined in the rootrc Url.Special key.; The default protocol is ""http"", unless defaultIsFile is true in which; case the url is assumed to be of type ""file"".; If a passwd contains a @ it must be escaped by a \\, e.g.; ""pip@"" becomes ""pip\\@"". Default ports: http=80, root=1094, proof=1093, ftp=20, news=119.; Port #1093 has been assigned by IANA (www.iana.org) to proofd.; Port #1094 has been assigned by IANA (www.iana.org) to rootd. void FindFile(char* u, Bool_t stripDoubleSlash = kTRUE); Find file and optionally anchor and options. TUrl(const TUrl& url); TUrl copt ctor. TUrl & operator=(const TUrl& rhs); TUrl assignment operator. const char * GetUrl(Bool_t withDeflt = kFALSE) const; Return full URL. If withDflt is kTRUE, explicitly add the port even; if it matches the default value for the URL protocol. const char * GetHostFQDN() const; Return fully qualified domain name of url host. If host cannot be; resolved or not valid return the host name as originally specified. const char * GetFileAndOptions() const; Return the file and its options (the string specified behind the ?).; Convenience function useful when the option is used to pass; authetication/access information for the specified file. void SetProtocol(const char* proto, Bool_t setDefaultPort = kFALSE); Set protocol and, optionally, change the port accordingly. Int_t Compare(const TObject* obj) const; Compare two urls as strings. void Print(Option_t* option = """") const; Print URL on stdout. TObjArray * GetSpecialProtocols(); Read the list of special protocols from the rootrc files.; These protocols will be parsed in a protocol and a file part,; no host or other info will be determined. This is typically; used for legacy file descriptions like: rfio:host:/path/file.root. void",MatchSource.WIKI,root/html532/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUrl.html
https://root.cern/root/html532/TUrl.html:9342,Integrability,protocol,protocol,9342,"94, proof=1093, ftp=20, news=119.; Port #1093 has been assigned by IANA (www.iana.org) to proofd.; Port #1094 has been assigned by IANA (www.iana.org) to rootd. void FindFile(char* u, Bool_t stripDoubleSlash = kTRUE); Find file and optionally anchor and options. TUrl(const TUrl& url); TUrl copt ctor. TUrl & operator=(const TUrl& rhs); TUrl assignment operator. const char * GetUrl(Bool_t withDeflt = kFALSE) const; Return full URL. If withDflt is kTRUE, explicitly add the port even; if it matches the default value for the URL protocol. const char * GetHostFQDN() const; Return fully qualified domain name of url host. If host cannot be; resolved or not valid return the host name as originally specified. const char * GetFileAndOptions() const; Return the file and its options (the string specified behind the ?).; Convenience function useful when the option is used to pass; authetication/access information for the specified file. void SetProtocol(const char* proto, Bool_t setDefaultPort = kFALSE); Set protocol and, optionally, change the port accordingly. Int_t Compare(const TObject* obj) const; Compare two urls as strings. void Print(Option_t* option = """") const; Print URL on stdout. TObjArray * GetSpecialProtocols(); Read the list of special protocols from the rootrc files.; These protocols will be parsed in a protocol and a file part,; no host or other info will be determined. This is typically; used for legacy file descriptions like: rfio:host:/path/file.root. void ParseOptions() const; Parse URL options into a key/value map. const char * GetValueFromOptions(const char* key) const; Return a value for a given key from the URL options.; Returns 0 in case key is not found. Int_t GetIntValueFromOptions(const char* key) const; Return a value for a given key from the URL options as an Int_t,; a missing key returns -1. void CleanRelativePath(); Recompute the path removing all relative directory jumps via '..'. TUrl(); { }. const char * GetProtocol() const; { return fProtocol;",MatchSource.WIKI,root/html532/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUrl.html
https://root.cern/root/html532/TUrl.html:9589,Integrability,protocol,protocols,9589," anchor and options. TUrl(const TUrl& url); TUrl copt ctor. TUrl & operator=(const TUrl& rhs); TUrl assignment operator. const char * GetUrl(Bool_t withDeflt = kFALSE) const; Return full URL. If withDflt is kTRUE, explicitly add the port even; if it matches the default value for the URL protocol. const char * GetHostFQDN() const; Return fully qualified domain name of url host. If host cannot be; resolved or not valid return the host name as originally specified. const char * GetFileAndOptions() const; Return the file and its options (the string specified behind the ?).; Convenience function useful when the option is used to pass; authetication/access information for the specified file. void SetProtocol(const char* proto, Bool_t setDefaultPort = kFALSE); Set protocol and, optionally, change the port accordingly. Int_t Compare(const TObject* obj) const; Compare two urls as strings. void Print(Option_t* option = """") const; Print URL on stdout. TObjArray * GetSpecialProtocols(); Read the list of special protocols from the rootrc files.; These protocols will be parsed in a protocol and a file part,; no host or other info will be determined. This is typically; used for legacy file descriptions like: rfio:host:/path/file.root. void ParseOptions() const; Parse URL options into a key/value map. const char * GetValueFromOptions(const char* key) const; Return a value for a given key from the URL options.; Returns 0 in case key is not found. Int_t GetIntValueFromOptions(const char* key) const; Return a value for a given key from the URL options as an Int_t,; a missing key returns -1. void CleanRelativePath(); Recompute the path removing all relative directory jumps via '..'. TUrl(); { }. const char * GetProtocol() const; { return fProtocol; }. const char * GetUser() const; { return fUser; }. const char * GetPasswd() const; { return fPasswd; }. const char * GetHost() const; { return fHost; }. const char * GetFile() const; { return fFile; }. const char * GetAnchor() const; { retur",MatchSource.WIKI,root/html532/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUrl.html
https://root.cern/root/html532/TUrl.html:9629,Integrability,protocol,protocols,9629,"assignment operator. const char * GetUrl(Bool_t withDeflt = kFALSE) const; Return full URL. If withDflt is kTRUE, explicitly add the port even; if it matches the default value for the URL protocol. const char * GetHostFQDN() const; Return fully qualified domain name of url host. If host cannot be; resolved or not valid return the host name as originally specified. const char * GetFileAndOptions() const; Return the file and its options (the string specified behind the ?).; Convenience function useful when the option is used to pass; authetication/access information for the specified file. void SetProtocol(const char* proto, Bool_t setDefaultPort = kFALSE); Set protocol and, optionally, change the port accordingly. Int_t Compare(const TObject* obj) const; Compare two urls as strings. void Print(Option_t* option = """") const; Print URL on stdout. TObjArray * GetSpecialProtocols(); Read the list of special protocols from the rootrc files.; These protocols will be parsed in a protocol and a file part,; no host or other info will be determined. This is typically; used for legacy file descriptions like: rfio:host:/path/file.root. void ParseOptions() const; Parse URL options into a key/value map. const char * GetValueFromOptions(const char* key) const; Return a value for a given key from the URL options.; Returns 0 in case key is not found. Int_t GetIntValueFromOptions(const char* key) const; Return a value for a given key from the URL options as an Int_t,; a missing key returns -1. void CleanRelativePath(); Recompute the path removing all relative directory jumps via '..'. TUrl(); { }. const char * GetProtocol() const; { return fProtocol; }. const char * GetUser() const; { return fUser; }. const char * GetPasswd() const; { return fPasswd; }. const char * GetHost() const; { return fHost; }. const char * GetFile() const; { return fFile; }. const char * GetAnchor() const; { return fAnchor; }. const char * GetOptions() const; { return fOptions; }. Int_t GetPort() const; { retur",MatchSource.WIKI,root/html532/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUrl.html
https://root.cern/root/html532/TUrl.html:9659,Integrability,protocol,protocol,9659,"assignment operator. const char * GetUrl(Bool_t withDeflt = kFALSE) const; Return full URL. If withDflt is kTRUE, explicitly add the port even; if it matches the default value for the URL protocol. const char * GetHostFQDN() const; Return fully qualified domain name of url host. If host cannot be; resolved or not valid return the host name as originally specified. const char * GetFileAndOptions() const; Return the file and its options (the string specified behind the ?).; Convenience function useful when the option is used to pass; authetication/access information for the specified file. void SetProtocol(const char* proto, Bool_t setDefaultPort = kFALSE); Set protocol and, optionally, change the port accordingly. Int_t Compare(const TObject* obj) const; Compare two urls as strings. void Print(Option_t* option = """") const; Print URL on stdout. TObjArray * GetSpecialProtocols(); Read the list of special protocols from the rootrc files.; These protocols will be parsed in a protocol and a file part,; no host or other info will be determined. This is typically; used for legacy file descriptions like: rfio:host:/path/file.root. void ParseOptions() const; Parse URL options into a key/value map. const char * GetValueFromOptions(const char* key) const; Return a value for a given key from the URL options.; Returns 0 in case key is not found. Int_t GetIntValueFromOptions(const char* key) const; Return a value for a given key from the URL options as an Int_t,; a missing key returns -1. void CleanRelativePath(); Recompute the path removing all relative directory jumps via '..'. TUrl(); { }. const char * GetProtocol() const; { return fProtocol; }. const char * GetUser() const; { return fUser; }. const char * GetPasswd() const; { return fPasswd; }. const char * GetHost() const; { return fHost; }. const char * GetFile() const; { return fFile; }. const char * GetAnchor() const; { return fAnchor; }. const char * GetOptions() const; { return fOptions; }. Int_t GetPort() const; { retur",MatchSource.WIKI,root/html532/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUrl.html
https://root.cern/root/html532/TUrl.html:3020,Modifiability,Inherit,InheritsFrom,3020,"orOnly(); const char*GetFile() const; const char*GetFileAndOptions() const; const char*GetHost() const; const char*GetHostFQDN() const; virtual const char*TObject::GetIconName() const; Int_tGetIntValueFromOptions(const char* key) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetOptions() const; const char*GetPasswd() const; Int_tGetPort() const; const char*GetProtocol() const; static TObjArray*GetSpecialProtocols(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const char*GetUrl(Bool_t withDeflt = kFALSE) const; const char*GetUser() const; const char*GetValueFromOptions(const char* key) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsSortable() const; Bool_tIsValid() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t",MatchSource.WIKI,root/html532/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUrl.html
https://root.cern/root/html532/TUrl.html:3086,Modifiability,Inherit,InheritsFrom,3086,"() const; const char*GetHost() const; const char*GetHostFQDN() const; virtual const char*TObject::GetIconName() const; Int_tGetIntValueFromOptions(const char* key) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetOptions() const; const char*GetPasswd() const; Int_tGetPort() const; const char*GetProtocol() const; static TObjArray*GetSpecialProtocols(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const char*GetUrl(Bool_t withDeflt = kFALSE) const; const char*GetUser() const; const char*GetValueFromOptions(const char* key) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsSortable() const; Bool_tIsValid() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TUrl&oper",MatchSource.WIKI,root/html532/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUrl.html
https://root.cern/root/html532/TUrl.html:6905,Modifiability,Inherit,Inheritance,6905,"_t stripDoubleSlash = kTRUE). Data Members; public:. enum EStatusBits { kUrlWithDefaultPort; kUrlHasDefaultPort; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TStringfAnchoranchor in object (after #); TStringfFileremote object; TStringfFileOA!file with option and anchor; TStringfHostremote host; TStringfHostFQ!fully qualified host name; TStringfOptionsoptions/search (after ?); TMap*fOptionsMap!map containing options key/value pairs; TStringfPasswdpassword; Int_tfPortport through which to contact remote server; TStringfProtocolprotocol: http, ftp, news, root, proof, ...; TStringfUrlfull URL; TStringfUseruser name; static THashList*fgHostFQDNslist of resolved host FQDNs; static TObjArray*fgSpecialProtocolslist of special protocols. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUrl(const char* url, Bool_t defaultIsFile = kFALSE); Parse url character string and split in its different subcomponents.; Use IsValid() to check if URL is legal. url: [proto://][user[:passwd]@]host[:port]/file.ext[?options][#anchor]. Known protocols: http, root, proof, ftp, news and any special protocols; defined in the rootrc Url.Special key.; The default protocol is ""http"", unless defaultIsFile is true in which; case the url is assumed to be of type ""file"".; If a passwd contains a @ it must be escaped by a \\, e.g.; ""pip@"" becomes ""pip\\@"". Default ports: http=80, root=1094, proof=1093, ftp=20, news=119.; Port #1093 has been assigned by IANA (www.iana.org) to proofd.; Port #1094 has been assigned by IANA (www.iana.org) to rootd. ~TUrl(); Cleanup. void SetUrl(const char* url, Bool_t defaultIsFile = kFALSE); Parse url character string and split in its different subcomponents.; Use IsValid() to check if URL is legal. url: [proto://][u",MatchSource.WIKI,root/html532/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUrl.html
https://root.cern/root/html532/TUrl.html:6918,Modifiability,Inherit,Inherited,6918,"_t stripDoubleSlash = kTRUE). Data Members; public:. enum EStatusBits { kUrlWithDefaultPort; kUrlHasDefaultPort; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TStringfAnchoranchor in object (after #); TStringfFileremote object; TStringfFileOA!file with option and anchor; TStringfHostremote host; TStringfHostFQ!fully qualified host name; TStringfOptionsoptions/search (after ?); TMap*fOptionsMap!map containing options key/value pairs; TStringfPasswdpassword; Int_tfPortport through which to contact remote server; TStringfProtocolprotocol: http, ftp, news, root, proof, ...; TStringfUrlfull URL; TStringfUseruser name; static THashList*fgHostFQDNslist of resolved host FQDNs; static TObjArray*fgSpecialProtocolslist of special protocols. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUrl(const char* url, Bool_t defaultIsFile = kFALSE); Parse url character string and split in its different subcomponents.; Use IsValid() to check if URL is legal. url: [proto://][user[:passwd]@]host[:port]/file.ext[?options][#anchor]. Known protocols: http, root, proof, ftp, news and any special protocols; defined in the rootrc Url.Special key.; The default protocol is ""http"", unless defaultIsFile is true in which; case the url is assumed to be of type ""file"".; If a passwd contains a @ it must be escaped by a \\, e.g.; ""pip@"" becomes ""pip\\@"". Default ports: http=80, root=1094, proof=1093, ftp=20, news=119.; Port #1093 has been assigned by IANA (www.iana.org) to proofd.; Port #1094 has been assigned by IANA (www.iana.org) to rootd. ~TUrl(); Cleanup. void SetUrl(const char* url, Bool_t defaultIsFile = kFALSE); Parse url character string and split in its different subcomponents.; Use IsValid() to check if URL is legal. url: [proto://][u",MatchSource.WIKI,root/html532/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUrl.html
https://root.cern/root/html532/TUrl.html:2910,Security,Hash,Hash,2910," const; const char*GetAnchor() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetFile() const; const char*GetFileAndOptions() const; const char*GetHost() const; const char*GetHostFQDN() const; virtual const char*TObject::GetIconName() const; Int_tGetIntValueFromOptions(const char* key) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetOptions() const; const char*GetPasswd() const; Int_tGetPort() const; const char*GetProtocol() const; static TObjArray*GetSpecialProtocols(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const char*GetUrl(Bool_t withDeflt = kFALSE) const; const char*GetUser() const; const char*GetValueFromOptions(const char* key) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsSortable() const; Bool_tIsValid() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObj",MatchSource.WIKI,root/html532/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUrl.html
https://root.cern/root/html532/TUrl.html:9226,Security,access,access,9226,"""file"".; If a passwd contains a @ it must be escaped by a \\, e.g.; ""pip@"" becomes ""pip\\@"". Default ports: http=80, root=1094, proof=1093, ftp=20, news=119.; Port #1093 has been assigned by IANA (www.iana.org) to proofd.; Port #1094 has been assigned by IANA (www.iana.org) to rootd. void FindFile(char* u, Bool_t stripDoubleSlash = kTRUE); Find file and optionally anchor and options. TUrl(const TUrl& url); TUrl copt ctor. TUrl & operator=(const TUrl& rhs); TUrl assignment operator. const char * GetUrl(Bool_t withDeflt = kFALSE) const; Return full URL. If withDflt is kTRUE, explicitly add the port even; if it matches the default value for the URL protocol. const char * GetHostFQDN() const; Return fully qualified domain name of url host. If host cannot be; resolved or not valid return the host name as originally specified. const char * GetFileAndOptions() const; Return the file and its options (the string specified behind the ?).; Convenience function useful when the option is used to pass; authetication/access information for the specified file. void SetProtocol(const char* proto, Bool_t setDefaultPort = kFALSE); Set protocol and, optionally, change the port accordingly. Int_t Compare(const TObject* obj) const; Compare two urls as strings. void Print(Option_t* option = """") const; Print URL on stdout. TObjArray * GetSpecialProtocols(); Read the list of special protocols from the rootrc files.; These protocols will be parsed in a protocol and a file part,; no host or other info will be determined. This is typically; used for legacy file descriptions like: rfio:host:/path/file.root. void ParseOptions() const; Parse URL options into a key/value map. const char * GetValueFromOptions(const char* key) const; Return a value for a given key from the URL options.; Returns 0 in case key is not found. Int_t GetIntValueFromOptions(const char* key) const; Return a value for a given key from the URL options as an Int_t,; a missing key returns -1. void CleanRelativePath(); Recompute ",MatchSource.WIKI,root/html532/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUrl.html
https://root.cern/root/html532/TUrl.html:5394,Testability,Test,TestBit,5394,":operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TUrl&operator=(const TUrl& rhs); virtual voidTObject::Paint(Option_t* option = """"); voidParseOptions() const; virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidSetAnchor(const char* anchor); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetFile(const char* file); voidSetHost(const char* host); static voidTObject::SetObjectStat(Bool_t stat); voidSetOptions(const char* opt); voidSetPasswd(const char* pw); voidSetPort(Int_t port); voidSetProtocol(const char* proto, Bool_t setDefaultPort = kFALSE); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetUrl(const char* url, Bool_t defaultIsFile = kFALSE); voidSetUser(const char* user); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUrl.html
https://root.cern/root/html532/TUrl.html:5433,Testability,Test,TestBits,5433,":operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TUrl&operator=(const TUrl& rhs); virtual voidTObject::Paint(Option_t* option = """"); voidParseOptions() const; virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidSetAnchor(const char* anchor); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetFile(const char* file); voidSetHost(const char* host); static voidTObject::SetObjectStat(Bool_t stat); voidSetOptions(const char* opt); voidSetPasswd(const char* pw); voidSetPort(Int_t port); voidSetProtocol(const char* proto, Bool_t setDefaultPort = kFALSE); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetUrl(const char* url, Bool_t defaultIsFile = kFALSE); voidSetUser(const char* user); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUrl.html
https://root.cern/root/html532/TUrl.html:898,Usability,Clear,Clear,898," TUrl(); TUrl(const TUrl& url); TUrl(const char* url, Bool_t defaultIsFile = kFALSE); virtual~TUrl(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; voidCleanRelativePath(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetAnchor() const; virtual Option_t*TObject::GetDrawOption() const; st",MatchSource.WIKI,root/html532/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUrl.html
https://root.cern/root/html532/TUUID.html:780,Integrability,Depend,Depending,780,". TUUID. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TUUID. class TUUID. TUUID. This class defines a UUID (Universally Unique IDentifier), also; known as GUIDs (Globally Unique IDentifier). A UUID is 128 bits; long, and if generated according to this algorithm, is either; guaranteed to be different from all other UUIDs/GUIDs generated; until 3400 A.D. or extremely likely to be different. UUIDs were; originally used in the Network Computing System (NCS) and; later in the Open Software Foundation's (OSF) Distributed Computing; Environment (DCE). Structure of universal unique IDs (UUIDs). Depending on the network data representation, the multi-; octet unsigned integer fields are subject to byte swapping; when communicated between dissimilar endian machines. | low 32 bits of time | 0-3 .fTimeLow; +-------------------------------+----; | mid 16 bits of time | 4-5 .fTimeMid; +; | vers. | hi 12 bits of time | 6-7 .fTimeHiAndVersion. |Res | clkSeqHi | 8 .fClockSeqHiAndReserved. | clkSeqLow | 9 .fClockSeqLow; +; | node ID | 10-15 .fNode. The adjusted time stamp is split into three fields, and the; clockSeq is split into two fields. The timestamp is a 60-bit value. For UUID version 1, this; is represented by Coordinated Universal Time (UTC/GMT) as; a count of 100-nanosecond intervals since 00:00:00.00,; 15 October 1582 (the date of Gregorian reform to the; Christian calendar). The version number is multiplexed in the 4 most significant; bits of the 'fTimeHiAndVersion' field. There are two defined; versions:; MSB <---; Version 4-Bit Code Description. | 1 0 0 0 1 DCE version, as specified herein.; | 2 0 0 1 0 DCE Security version, with; | embedded POSIX UIDs.; | 3 0 0 1 1 node id is a random value. Clock Sequence. The clock sequence value must be changed whenever:. The UUID generator detects tha",MatchSource.WIKI,root/html532/TUUID.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUUID.html
https://root.cern/root/html532/TUUID.html:6112,Integrability,interface,interface,6112,"_str); Set this UUID to the value specified in uuid ((which must be in; TUUID::AsString() format). TUUID(const char* uuid_str); Initialize a TUUID with uuid (which must be in TUUID::AsString() format). void FillBuffer(char*& buffer); Stream UUID into output buffer. void ReadBuffer(char*& buffer); Stream UUID from input buffer. void StreamerV1(TBuffer& b); Stream UUID from input buffer.; This function is for the exclusive use of TDirectory::Streamer() to; read a non-versioned version of TUUID. void Format(UShort_t clockseq, TUUID::uuid_time_t ts); Make a UUID from timestamp, clockseq and node id. void GetCurrentTime(TUUID::uuid_time_t* timestamp); Get current time as 60 bit 100ns ticks since whenever.; Compensate for the fact that real clock resolution is less; than 100ns. void GetSystemTime(TUUID::uuid_time_t* timestamp); Get system time with 100ns precision. Time is since Oct 15, 1582. void GetNodeIdentifier(); Get node identifier. Try first to get network address, if no; network interface try random info based on some machine parameters. void GetRandomInfo(UChar_t* seed); Get random info based on some machine parameters. void Print() const; Print UUID. const char * AsString() const; Return UUID as string. Copy string immediately since it will be reused. UShort_t Hash() const; Compute 16-bit hash value of the UUID. Int_t Compare(const TUUID& u) const; Compare two UUIDs ""lexically"" and return; -1 this is lexically before u; 0 this is equal to u; 1 this is lexically after u. TInetAddress GetHostAddress() const; Get address of host encoded in UUID. If host id is not an ethernet; address, but random info, then the returned TInetAddress is not valid. TDatime GetTime() const; Get time from UUID. void GetUUID(UChar_t* uuid) const; Return uuid in specified buffer (16 byte = 128 bits). void SetUUID(const char* uuid_str); Set this UUID to the value specified in uuid ((which must be in; TUUID::AsString() format). TUUID(). UInt_t GetUUIDNumber() const; { return fUUIDIndex; }. v",MatchSource.WIKI,root/html532/TUUID.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUUID.html
https://root.cern/root/html532/TUUID.html:4863,Modifiability,Inherit,Inheritance,4863,"voidReadBuffer(char*& buffer); voidSetUUID(const char* uuid_str); voidSetUUIDNumber(UInt_t index); virtual voidShowMembers(TMemberInspector& insp); Int_tSizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidStreamerV1(TBuffer& b). protected:. Int_tCmpTime(TUUID::uuid_time_t* t1, TUUID::uuid_time_t* t2); voidFormat(UShort_t clockseq, TUUID::uuid_time_t ts); voidGetCurrentTime(TUUID::uuid_time_t* timestamp); voidGetNodeIdentifier(); voidGetRandomInfo(UChar_t* seed); voidGetSystemTime(TUUID::uuid_time_t* timestamp); voidSetFromString(const char* uuid_str). Data Members; protected:. UChar_tfClockSeqHiAndReservedhigh 6 clock bits + 2 bits reserved; UChar_tfClockSeqLowlow 8 clock bits; UChar_tfNode[6]6 node id bytes; UShort_tfTimeHiAndVersionhigh 12 time bits + 4 UUID version bits; UInt_tfTimeLow60 bit time, lower 32 bits; UShort_tfTimeMidmiddle 16 time bits; UInt_tfUUIDIndex!index in the list of UUIDs in TProcessUUID. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUUID(); Create a UUID. ~TUUID(); delete this TUUID. Int_t CmpTime(TUUID::uuid_time_t* t1, TUUID::uuid_time_t* t2); Compare two time values. void SetFromString(const char* uuid_str); Set this UUID to the value specified in uuid ((which must be in; TUUID::AsString() format). TUUID(const char* uuid_str); Initialize a TUUID with uuid (which must be in TUUID::AsString() format). void FillBuffer(char*& buffer); Stream UUID into output buffer. void ReadBuffer(char*& buffer); Stream UUID from input buffer. void StreamerV1(TBuffer& b); Stream UUID from input buffer.; This function is for the exclusive use of TDirectory::Streamer() to; read a non-versioned version of TUUID. void Format(UShort_t clockseq, TUUID::uuid_time_t ts); Make a UUID from timestamp, clockseq and node id. void GetCurrentTime(TUUID::uuid_time_t* timestamp); Get current time as 60 bit 100ns ticks since whenever.; Compensate for the fact that real clock resolution is less; th",MatchSource.WIKI,root/html532/TUUID.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUUID.html
https://root.cern/root/html532/TUUID.html:4876,Modifiability,Inherit,Inherited,4876,"voidReadBuffer(char*& buffer); voidSetUUID(const char* uuid_str); voidSetUUIDNumber(UInt_t index); virtual voidShowMembers(TMemberInspector& insp); Int_tSizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidStreamerV1(TBuffer& b). protected:. Int_tCmpTime(TUUID::uuid_time_t* t1, TUUID::uuid_time_t* t2); voidFormat(UShort_t clockseq, TUUID::uuid_time_t ts); voidGetCurrentTime(TUUID::uuid_time_t* timestamp); voidGetNodeIdentifier(); voidGetRandomInfo(UChar_t* seed); voidGetSystemTime(TUUID::uuid_time_t* timestamp); voidSetFromString(const char* uuid_str). Data Members; protected:. UChar_tfClockSeqHiAndReservedhigh 6 clock bits + 2 bits reserved; UChar_tfClockSeqLowlow 8 clock bits; UChar_tfNode[6]6 node id bytes; UShort_tfTimeHiAndVersionhigh 12 time bits + 4 UUID version bits; UInt_tfTimeLow60 bit time, lower 32 bits; UShort_tfTimeMidmiddle 16 time bits; UInt_tfUUIDIndex!index in the list of UUIDs in TProcessUUID. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUUID(); Create a UUID. ~TUUID(); delete this TUUID. Int_t CmpTime(TUUID::uuid_time_t* t1, TUUID::uuid_time_t* t2); Compare two time values. void SetFromString(const char* uuid_str); Set this UUID to the value specified in uuid ((which must be in; TUUID::AsString() format). TUUID(const char* uuid_str); Initialize a TUUID with uuid (which must be in TUUID::AsString() format). void FillBuffer(char*& buffer); Stream UUID into output buffer. void ReadBuffer(char*& buffer); Stream UUID from input buffer. void StreamerV1(TBuffer& b); Stream UUID from input buffer.; This function is for the exclusive use of TDirectory::Streamer() to; read a non-versioned version of TUUID. void Format(UShort_t clockseq, TUUID::uuid_time_t ts); Make a UUID from timestamp, clockseq and node id. void GetCurrentTime(TUUID::uuid_time_t* timestamp); Get current time as 60 bit 100ns ticks since whenever.; Compensate for the fact that real clock resolution is less; th",MatchSource.WIKI,root/html532/TUUID.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUUID.html
https://root.cern/root/html532/TUUID.html:3230,Performance,perform,performance,3230," create a UUID. Each time a new UUID; is created, the current UTC is compared to the saved value; and if either the current value is less or the saved value; was lost, then the clock sequence is incremented modulo; 16,384, thus avoiding production of duplicted UUIDs. The clock sequence must be initialized to a random number; to minimize the correlation across system. This provides; maximum protection against node identifiers that may move; or switch from system to system rapidly. Clock Adjustment. UUIDs may be created at a rate greater than the system clock; resolution. Therefore, the system must also maintain an; adjustment value to be added to the lower-order bits of the; time. Logically, each time the system clock ticks, the; adjustment value is cleared. Every time a UUID is generated,; the current adjustment value is read and incremented, and; then added to the UTC time field of the UUID. Clock Overrun. The 100-nanosecond granularity of time should prove sufficient; even for bursts of UUID production in the next generation of; high-performance multiprocessors. If a system overruns the; clock adjustment by requesting too many UUIDs within a single; system clock tick, the UUID generator will stall until the; system clock catches up. Function Members (Methods); public:. TUUID(); TUUID(const char* uuid_str); TUUID(const TUUID&); virtual~TUUID(); const char*AsString() const; static TClass*Class(); Int_tCompare(const TUUID& u) const; voidFillBuffer(char*& buffer); TInetAddressGetHostAddress() const; TDatimeGetTime() const; voidGetUUID(UChar_t* uuid) const; UInt_tGetUUIDNumber() const; UShort_tHash() const; virtual TClass*IsA() const; TUUID&operator=(const TUUID&); voidPrint() const; voidReadBuffer(char*& buffer); voidSetUUID(const char* uuid_str); voidSetUUIDNumber(UInt_t index); virtual voidShowMembers(TMemberInspector& insp); Int_tSizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidStreamerV1(TBuffer& b). protected:. Int_tCmpTime(",MatchSource.WIKI,root/html532/TUUID.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUUID.html
https://root.cern/root/html532/TUUID.html:1990,Safety,detect,detects,1990,"id 16 bits of time | 4-5 .fTimeMid; +; | vers. | hi 12 bits of time | 6-7 .fTimeHiAndVersion. |Res | clkSeqHi | 8 .fClockSeqHiAndReserved. | clkSeqLow | 9 .fClockSeqLow; +; | node ID | 10-15 .fNode. The adjusted time stamp is split into three fields, and the; clockSeq is split into two fields. The timestamp is a 60-bit value. For UUID version 1, this; is represented by Coordinated Universal Time (UTC/GMT) as; a count of 100-nanosecond intervals since 00:00:00.00,; 15 October 1582 (the date of Gregorian reform to the; Christian calendar). The version number is multiplexed in the 4 most significant; bits of the 'fTimeHiAndVersion' field. There are two defined; versions:; MSB <---; Version 4-Bit Code Description. | 1 0 0 0 1 DCE version, as specified herein.; | 2 0 0 1 0 DCE Security version, with; | embedded POSIX UIDs.; | 3 0 0 1 1 node id is a random value. Clock Sequence. The clock sequence value must be changed whenever:. The UUID generator detects that the local value of UTC; has gone backward; this may be due to re-syncing of the system; clock. While a node is operational, the UUID service always saves; the last UTC used to create a UUID. Each time a new UUID; is created, the current UTC is compared to the saved value; and if either the current value is less or the saved value; was lost, then the clock sequence is incremented modulo; 16,384, thus avoiding production of duplicted UUIDs. The clock sequence must be initialized to a random number; to minimize the correlation across system. This provides; maximum protection against node identifiers that may move; or switch from system to system rapidly. Clock Adjustment. UUIDs may be created at a rate greater than the system clock; resolution. Therefore, the system must also maintain an; adjustment value to be added to the lower-order bits of the; time. Logically, each time the system clock ticks, the; adjustment value is cleared. Every time a UUID is generated,; the current adjustment value is read and incremented, a",MatchSource.WIKI,root/html532/TUUID.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUUID.html
https://root.cern/root/html532/TUUID.html:2406,Safety,avoid,avoiding,2406," fields. The timestamp is a 60-bit value. For UUID version 1, this; is represented by Coordinated Universal Time (UTC/GMT) as; a count of 100-nanosecond intervals since 00:00:00.00,; 15 October 1582 (the date of Gregorian reform to the; Christian calendar). The version number is multiplexed in the 4 most significant; bits of the 'fTimeHiAndVersion' field. There are two defined; versions:; MSB <---; Version 4-Bit Code Description. | 1 0 0 0 1 DCE version, as specified herein.; | 2 0 0 1 0 DCE Security version, with; | embedded POSIX UIDs.; | 3 0 0 1 1 node id is a random value. Clock Sequence. The clock sequence value must be changed whenever:. The UUID generator detects that the local value of UTC; has gone backward; this may be due to re-syncing of the system; clock. While a node is operational, the UUID service always saves; the last UTC used to create a UUID. Each time a new UUID; is created, the current UTC is compared to the saved value; and if either the current value is less or the saved value; was lost, then the clock sequence is incremented modulo; 16,384, thus avoiding production of duplicted UUIDs. The clock sequence must be initialized to a random number; to minimize the correlation across system. This provides; maximum protection against node identifiers that may move; or switch from system to system rapidly. Clock Adjustment. UUIDs may be created at a rate greater than the system clock; resolution. Therefore, the system must also maintain an; adjustment value to be added to the lower-order bits of the; time. Logically, each time the system clock ticks, the; adjustment value is cleared. Every time a UUID is generated,; the current adjustment value is read and incremented, and; then added to the UTC time field of the UUID. Clock Overrun. The 100-nanosecond granularity of time should prove sufficient; even for bursts of UUID production in the next generation of; high-performance multiprocessors. If a system overruns the; clock adjustment by requesting too",MatchSource.WIKI,root/html532/TUUID.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUUID.html
https://root.cern/root/html532/TUUID.html:1816,Security,Secur,Security,1816,"multi-; octet unsigned integer fields are subject to byte swapping; when communicated between dissimilar endian machines. | low 32 bits of time | 0-3 .fTimeLow; +-------------------------------+----; | mid 16 bits of time | 4-5 .fTimeMid; +; | vers. | hi 12 bits of time | 6-7 .fTimeHiAndVersion. |Res | clkSeqHi | 8 .fClockSeqHiAndReserved. | clkSeqLow | 9 .fClockSeqLow; +; | node ID | 10-15 .fNode. The adjusted time stamp is split into three fields, and the; clockSeq is split into two fields. The timestamp is a 60-bit value. For UUID version 1, this; is represented by Coordinated Universal Time (UTC/GMT) as; a count of 100-nanosecond intervals since 00:00:00.00,; 15 October 1582 (the date of Gregorian reform to the; Christian calendar). The version number is multiplexed in the 4 most significant; bits of the 'fTimeHiAndVersion' field. There are two defined; versions:; MSB <---; Version 4-Bit Code Description. | 1 0 0 0 1 DCE version, as specified herein.; | 2 0 0 1 0 DCE Security version, with; | embedded POSIX UIDs.; | 3 0 0 1 1 node id is a random value. Clock Sequence. The clock sequence value must be changed whenever:. The UUID generator detects that the local value of UTC; has gone backward; this may be due to re-syncing of the system; clock. While a node is operational, the UUID service always saves; the last UTC used to create a UUID. Each time a new UUID; is created, the current UTC is compared to the saved value; and if either the current value is less or the saved value; was lost, then the clock sequence is incremented modulo; 16,384, thus avoiding production of duplicted UUIDs. The clock sequence must be initialized to a random number; to minimize the correlation across system. This provides; maximum protection against node identifiers that may move; or switch from system to system rapidly. Clock Adjustment. UUIDs may be created at a rate greater than the system clock; resolution. Therefore, the system must also maintain an; adjustment value to be added t",MatchSource.WIKI,root/html532/TUUID.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUUID.html
https://root.cern/root/html532/TUUID.html:6401,Security,Hash,Hash,6401,"UID from input buffer. void StreamerV1(TBuffer& b); Stream UUID from input buffer.; This function is for the exclusive use of TDirectory::Streamer() to; read a non-versioned version of TUUID. void Format(UShort_t clockseq, TUUID::uuid_time_t ts); Make a UUID from timestamp, clockseq and node id. void GetCurrentTime(TUUID::uuid_time_t* timestamp); Get current time as 60 bit 100ns ticks since whenever.; Compensate for the fact that real clock resolution is less; than 100ns. void GetSystemTime(TUUID::uuid_time_t* timestamp); Get system time with 100ns precision. Time is since Oct 15, 1582. void GetNodeIdentifier(); Get node identifier. Try first to get network address, if no; network interface try random info based on some machine parameters. void GetRandomInfo(UChar_t* seed); Get random info based on some machine parameters. void Print() const; Print UUID. const char * AsString() const; Return UUID as string. Copy string immediately since it will be reused. UShort_t Hash() const; Compute 16-bit hash value of the UUID. Int_t Compare(const TUUID& u) const; Compare two UUIDs ""lexically"" and return; -1 this is lexically before u; 0 this is equal to u; 1 this is lexically after u. TInetAddress GetHostAddress() const; Get address of host encoded in UUID. If host id is not an ethernet; address, but random info, then the returned TInetAddress is not valid. TDatime GetTime() const; Get time from UUID. void GetUUID(UChar_t* uuid) const; Return uuid in specified buffer (16 byte = 128 bits). void SetUUID(const char* uuid_str); Set this UUID to the value specified in uuid ((which must be in; TUUID::AsString() format). TUUID(). UInt_t GetUUIDNumber() const; { return fUUIDIndex; }. void SetUUIDNumber(UInt_t index); { fUUIDIndex = index; }. Int_t Sizeof() const; { return 18; }. » Author: Fons Rademakers 30/9/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TUUID.h 27658 2009-02-28 05:34:57Z pcanal $ » Last generated: 2011-11-03 20:23; T",MatchSource.WIKI,root/html532/TUUID.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUUID.html
https://root.cern/root/html532/TUUID.html:6430,Security,hash,hash,6430,"UID from input buffer. void StreamerV1(TBuffer& b); Stream UUID from input buffer.; This function is for the exclusive use of TDirectory::Streamer() to; read a non-versioned version of TUUID. void Format(UShort_t clockseq, TUUID::uuid_time_t ts); Make a UUID from timestamp, clockseq and node id. void GetCurrentTime(TUUID::uuid_time_t* timestamp); Get current time as 60 bit 100ns ticks since whenever.; Compensate for the fact that real clock resolution is less; than 100ns. void GetSystemTime(TUUID::uuid_time_t* timestamp); Get system time with 100ns precision. Time is since Oct 15, 1582. void GetNodeIdentifier(); Get node identifier. Try first to get network address, if no; network interface try random info based on some machine parameters. void GetRandomInfo(UChar_t* seed); Get random info based on some machine parameters. void Print() const; Print UUID. const char * AsString() const; Return UUID as string. Copy string immediately since it will be reused. UShort_t Hash() const; Compute 16-bit hash value of the UUID. Int_t Compare(const TUUID& u) const; Compare two UUIDs ""lexically"" and return; -1 this is lexically before u; 0 this is equal to u; 1 this is lexically after u. TInetAddress GetHostAddress() const; Get address of host encoded in UUID. If host id is not an ethernet; address, but random info, then the returned TInetAddress is not valid. TDatime GetTime() const; Get time from UUID. void GetUUID(UChar_t* uuid) const; Return uuid in specified buffer (16 byte = 128 bits). void SetUUID(const char* uuid_str); Set this UUID to the value specified in uuid ((which must be in; TUUID::AsString() format). TUUID(). UInt_t GetUUIDNumber() const; { return fUUIDIndex; }. void SetUUIDNumber(UInt_t index); { fUUIDIndex = index; }. Int_t Sizeof() const; { return 18; }. » Author: Fons Rademakers 30/9/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TUUID.h 27658 2009-02-28 05:34:57Z pcanal $ » Last generated: 2011-11-03 20:23; T",MatchSource.WIKI,root/html532/TUUID.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUUID.html
https://root.cern/root/html532/TUUID.html:2867,Testability,Log,Logically,2867,"ock Sequence. The clock sequence value must be changed whenever:. The UUID generator detects that the local value of UTC; has gone backward; this may be due to re-syncing of the system; clock. While a node is operational, the UUID service always saves; the last UTC used to create a UUID. Each time a new UUID; is created, the current UTC is compared to the saved value; and if either the current value is less or the saved value; was lost, then the clock sequence is incremented modulo; 16,384, thus avoiding production of duplicted UUIDs. The clock sequence must be initialized to a random number; to minimize the correlation across system. This provides; maximum protection against node identifiers that may move; or switch from system to system rapidly. Clock Adjustment. UUIDs may be created at a rate greater than the system clock; resolution. Therefore, the system must also maintain an; adjustment value to be added to the lower-order bits of the; time. Logically, each time the system clock ticks, the; adjustment value is cleared. Every time a UUID is generated,; the current adjustment value is read and incremented, and; then added to the UTC time field of the UUID. Clock Overrun. The 100-nanosecond granularity of time should prove sufficient; even for bursts of UUID production in the next generation of; high-performance multiprocessors. If a system overruns the; clock adjustment by requesting too many UUIDs within a single; system clock tick, the UUID generator will stall until the; system clock catches up. Function Members (Methods); public:. TUUID(); TUUID(const char* uuid_str); TUUID(const TUUID&); virtual~TUUID(); const char*AsString() const; static TClass*Class(); Int_tCompare(const TUUID& u) const; voidFillBuffer(char*& buffer); TInetAddressGetHostAddress() const; TDatimeGetTime() const; voidGetUUID(UChar_t* uuid) const; UInt_tGetUUIDNumber() const; UShort_tHash() const; virtual TClass*IsA() const; TUUID&operator=(const TUUID&); voidPrint() const; voidReadBuffer(cha",MatchSource.WIKI,root/html532/TUUID.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUUID.html
https://root.cern/root/html532/TUUID.html:341,Usability,GUID,GUIDs,341,". TUUID. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TUUID. class TUUID. TUUID. This class defines a UUID (Universally Unique IDentifier), also; known as GUIDs (Globally Unique IDentifier). A UUID is 128 bits; long, and if generated according to this algorithm, is either; guaranteed to be different from all other UUIDs/GUIDs generated; until 3400 A.D. or extremely likely to be different. UUIDs were; originally used in the Network Computing System (NCS) and; later in the Open Software Foundation's (OSF) Distributed Computing; Environment (DCE). Structure of universal unique IDs (UUIDs). Depending on the network data representation, the multi-; octet unsigned integer fields are subject to byte swapping; when communicated between dissimilar endian machines. | low 32 bits of time | 0-3 .fTimeLow; +-------------------------------+----; | mid 16 bits of time | 4-5 .fTimeMid; +; | vers. | hi 12 bits of time | 6-7 .fTimeHiAndVersion. |Res | clkSeqHi | 8 .fClockSeqHiAndReserved. | clkSeqLow | 9 .fClockSeqLow; +; | node ID | 10-15 .fNode. The adjusted time stamp is split into three fields, and the; clockSeq is split into two fields. The timestamp is a 60-bit value. For UUID version 1, this; is represented by Coordinated Universal Time (UTC/GMT) as; a count of 100-nanosecond intervals since 00:00:00.00,; 15 October 1582 (the date of Gregorian reform to the; Christian calendar). The version number is multiplexed in the 4 most significant; bits of the 'fTimeHiAndVersion' field. There are two defined; versions:; MSB <---; Version 4-Bit Code Description. | 1 0 0 0 1 DCE version, as specified herein.; | 2 0 0 1 0 DCE Security version, with; | embedded POSIX UIDs.; | 3 0 0 1 1 node id is a random value. Clock Sequence. The clock sequence value must be changed whenever:. The UUID generator detects tha",MatchSource.WIKI,root/html532/TUUID.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUUID.html
https://root.cern/root/html532/TUUID.html:508,Usability,GUID,GUIDs,508,". TUUID. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TUUID. class TUUID. TUUID. This class defines a UUID (Universally Unique IDentifier), also; known as GUIDs (Globally Unique IDentifier). A UUID is 128 bits; long, and if generated according to this algorithm, is either; guaranteed to be different from all other UUIDs/GUIDs generated; until 3400 A.D. or extremely likely to be different. UUIDs were; originally used in the Network Computing System (NCS) and; later in the Open Software Foundation's (OSF) Distributed Computing; Environment (DCE). Structure of universal unique IDs (UUIDs). Depending on the network data representation, the multi-; octet unsigned integer fields are subject to byte swapping; when communicated between dissimilar endian machines. | low 32 bits of time | 0-3 .fTimeLow; +-------------------------------+----; | mid 16 bits of time | 4-5 .fTimeMid; +; | vers. | hi 12 bits of time | 6-7 .fTimeHiAndVersion. |Res | clkSeqHi | 8 .fClockSeqHiAndReserved. | clkSeqLow | 9 .fClockSeqLow; +; | node ID | 10-15 .fNode. The adjusted time stamp is split into three fields, and the; clockSeq is split into two fields. The timestamp is a 60-bit value. For UUID version 1, this; is represented by Coordinated Universal Time (UTC/GMT) as; a count of 100-nanosecond intervals since 00:00:00.00,; 15 October 1582 (the date of Gregorian reform to the; Christian calendar). The version number is multiplexed in the 4 most significant; bits of the 'fTimeHiAndVersion' field. There are two defined; versions:; MSB <---; Version 4-Bit Code Description. | 1 0 0 0 1 DCE version, as specified herein.; | 2 0 0 1 0 DCE Security version, with; | embedded POSIX UIDs.; | 3 0 0 1 1 node id is a random value. Clock Sequence. The clock sequence value must be changed whenever:. The UUID generator detects tha",MatchSource.WIKI,root/html532/TUUID.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUUID.html
https://root.cern/root/html532/TUUID.html:2937,Usability,clear,cleared,2937,"ock Sequence. The clock sequence value must be changed whenever:. The UUID generator detects that the local value of UTC; has gone backward; this may be due to re-syncing of the system; clock. While a node is operational, the UUID service always saves; the last UTC used to create a UUID. Each time a new UUID; is created, the current UTC is compared to the saved value; and if either the current value is less or the saved value; was lost, then the clock sequence is incremented modulo; 16,384, thus avoiding production of duplicted UUIDs. The clock sequence must be initialized to a random number; to minimize the correlation across system. This provides; maximum protection against node identifiers that may move; or switch from system to system rapidly. Clock Adjustment. UUIDs may be created at a rate greater than the system clock; resolution. Therefore, the system must also maintain an; adjustment value to be added to the lower-order bits of the; time. Logically, each time the system clock ticks, the; adjustment value is cleared. Every time a UUID is generated,; the current adjustment value is read and incremented, and; then added to the UTC time field of the UUID. Clock Overrun. The 100-nanosecond granularity of time should prove sufficient; even for bursts of UUID production in the next generation of; high-performance multiprocessors. If a system overruns the; clock adjustment by requesting too many UUIDs within a single; system clock tick, the UUID generator will stall until the; system clock catches up. Function Members (Methods); public:. TUUID(); TUUID(const char* uuid_str); TUUID(const TUUID&); virtual~TUUID(); const char*AsString() const; static TClass*Class(); Int_tCompare(const TUUID& u) const; voidFillBuffer(char*& buffer); TInetAddressGetHostAddress() const; TDatimeGetTime() const; voidGetUUID(UChar_t* uuid) const; UInt_tGetUUIDNumber() const; UShort_tHash() const; virtual TClass*IsA() const; TUUID&operator=(const TUUID&); voidPrint() const; voidReadBuffer(cha",MatchSource.WIKI,root/html532/TUUID.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TUUID.html
https://root.cern/root/html532/TVector2.html:1269,Availability,Error,Error,1269," TVector2(); TVector2(Double_t* s); TVector2(const TVector2&); TVector2(Double_t x0, Double_t y0); virtual~TVector2(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDeltaPhi(const TVector2& v) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const",MatchSource.WIKI,root/html532/TVector2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVector2.html
https://root.cern/root/html532/TVector2.html:1398,Availability,error,error,1398,"e_t x0, Double_t y0); virtual~TVector2(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDeltaPhi(const TVector2& v) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html532/TVector2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVector2.html
https://root.cern/root/html532/TVector2.html:1482,Availability,error,error,1482,"thod) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDeltaPhi(const TVector2& v) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html532/TVector2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVector2.html
https://root.cern/root/html532/TVector2.html:2362,Modifiability,Inherit,InheritsFrom,2362,"d, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; Double_tMod() const; Double_tMod2() const; TVector2Norm(const TVector2& v) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::op",MatchSource.WIKI,root/html532/TVector2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVector2.html
https://root.cern/root/html532/TVector2.html:2428,Modifiability,Inherit,InheritsFrom,2428,"cute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; Double_tMod() const; Double_tMod2() const; TVector2Norm(const TVector2& v) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size",MatchSource.WIKI,root/html532/TVector2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVector2.html
https://root.cern/root/html532/TVector2.html:5942,Modifiability,Inherit,Inheritance,5942,"or(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TVector2Unit() const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; Double_tX() const; Double_tY() const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_tfXcomponents of the vector; Double_tfY. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVector2(); constructor. TVector2(Double_t* s); constructor. TVector2(Double_t x0, Double_t y0); constructor. ~TVector2(). Double_t Mod() const; return modulo of this vector. TVector2 Unit() const; return module normalized to 1. Double_t Phi() const; return vector phi. Double_t Phi_0_2pi(Double_t x); (static function) returns phi angle in the interval [0,2*PI). Double_t Phi_mpi_pi(Double_t x); (static function) returns phi angle in the interval [-PI,PI). TVector2 Rotate(Double_t phi) const; rotation by phi. void SetMagPhi(Double_t mag, Double_t phi); set vector using mag and phi. void Streamer(TBuffer& b); Stream an object of class TVector2. void Print(Option_t* option = """") const; print vector parameters. Double_t DeltaPhi(const TVector2& v) const; { return Phi_mpi_pi(Phi()-v.Phi()); }. TVector2 Ort() const; { return Unit(); }. TVector2 Proj(const TVector2& v) const; { return v*(((*this)*v)/v.Mod2()); }. TVector2 Norm(const TVector2& ",MatchSource.WIKI,root/html532/TVector2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVector2.html
https://root.cern/root/html532/TVector2.html:5955,Modifiability,Inherit,Inherited,5955,"or(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TVector2Unit() const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; Double_tX() const; Double_tY() const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_tfXcomponents of the vector; Double_tfY. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVector2(); constructor. TVector2(Double_t* s); constructor. TVector2(Double_t x0, Double_t y0); constructor. ~TVector2(). Double_t Mod() const; return modulo of this vector. TVector2 Unit() const; return module normalized to 1. Double_t Phi() const; return vector phi. Double_t Phi_0_2pi(Double_t x); (static function) returns phi angle in the interval [0,2*PI). Double_t Phi_mpi_pi(Double_t x); (static function) returns phi angle in the interval [-PI,PI). TVector2 Rotate(Double_t phi) const; rotation by phi. void SetMagPhi(Double_t mag, Double_t phi); set vector using mag and phi. void Streamer(TBuffer& b); Stream an object of class TVector2. void Print(Option_t* option = """") const; print vector parameters. Double_t DeltaPhi(const TVector2& v) const; { return Phi_mpi_pi(Phi()-v.Phi()); }. TVector2 Ort() const; { return Unit(); }. TVector2 Proj(const TVector2& v) const; { return v*(((*this)*v)/v.Mod2()); }. TVector2 Norm(const TVector2& ",MatchSource.WIKI,root/html532/TVector2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVector2.html
https://root.cern/root/html532/TVector2.html:2252,Security,Hash,Hash,2252,"l voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; Double_tMod() const; Double_tMod2() const; TVector2Norm(const TVector2& v) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); s",MatchSource.WIKI,root/html532/TVector2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVector2.html
https://root.cern/root/html532/TVector2.html:5032,Testability,Test,TestBit,5032,"ct::operator new[](size_t sz, void* vp); Double_toperator*=(TVector2 const& v); TVector2&operator*=(Double_t s); Double_toperator*=(const TVector2& v); TVector2&operator+=(TVector2 const& v); TVector2&operator-=(TVector2 const& v); TVector2&operator/=(Double_t s); TVector2&operator=(TVector2 const& v); TVector2Ort() const; virtual voidTObject::Paint(Option_t* option = """"); Double_tPhi() const; static Double_tPhi_0_2pi(Double_t x); static Double_tPhi_mpi_pi(Double_t x); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; TVector2Proj(const TVector2& v) const; Double_tPx() const; Double_tPy() const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); TVector2Rotate(Double_t phi) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidSet(const TVector2& v); voidSet(Double_t x0, Double_t y0); voidSet(float x0, float y0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetMagPhi(Double_t mag, Double_t phi); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TVector2Unit() const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; Double_tX() const; Double_tY() const.",MatchSource.WIKI,root/html532/TVector2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVector2.html
https://root.cern/root/html532/TVector2.html:5071,Testability,Test,TestBits,5071,"ct::operator new[](size_t sz, void* vp); Double_toperator*=(TVector2 const& v); TVector2&operator*=(Double_t s); Double_toperator*=(const TVector2& v); TVector2&operator+=(TVector2 const& v); TVector2&operator-=(TVector2 const& v); TVector2&operator/=(Double_t s); TVector2&operator=(TVector2 const& v); TVector2Ort() const; virtual voidTObject::Paint(Option_t* option = """"); Double_tPhi() const; static Double_tPhi_0_2pi(Double_t x); static Double_tPhi_mpi_pi(Double_t x); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; TVector2Proj(const TVector2& v) const; Double_tPx() const; Double_tPy() const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); TVector2Rotate(Double_t phi) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidSet(const TVector2& v); voidSet(Double_t x0, Double_t y0); voidSet(float x0, float y0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetMagPhi(Double_t mag, Double_t phi); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TVector2Unit() const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; Double_tX() const; Double_tY() const.",MatchSource.WIKI,root/html532/TVector2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVector2.html
https://root.cern/root/html532/TVector2.html:686,Usability,Clear,Clear,686," TVector2(); TVector2(Double_t* s); TVector2(const TVector2&); TVector2(Double_t x0, Double_t y0); virtual~TVector2(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDeltaPhi(const TVector2& v) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const",MatchSource.WIKI,root/html532/TVector2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVector2.html
https://root.cern/root/html532/TVector3.html:5553,Availability,Error,Error,5553,"; Double_tAngle(const TVector3&) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; Double_tCosTheta() const; TVector3Cross(const TVector3& p) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDeltaPhi(const TVector3& v) const; Double_tDeltaR(const TVector3&) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Double_tDot(const TVector3& p) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; Double_tDrEtaPhi(const TVector3& v) const; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tEta() const; TVector2EtaPhiVector() const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; voidGetXYZ(Double_t* carray) const; voidGetX",MatchSource.WIKI,root/html532/TVector3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVector3.html
https://root.cern/root/html532/TVector3.html:5733,Availability,error,error,5733,"Object::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; Double_tCosTheta() const; TVector3Cross(const TVector3& p) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDeltaPhi(const TVector3& v) const; Double_tDeltaR(const TVector3&) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Double_tDot(const TVector3& p) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; Double_tDrEtaPhi(const TVector3& v) const; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tEta() const; TVector2EtaPhiVector() const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; voidGetXYZ(Double_t* carray) const; voidGetXYZ(Float_t* carray) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt",MatchSource.WIKI,root/html532/TVector3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVector3.html
https://root.cern/root/html532/TVector3.html:5817,Availability,error,error,5817,"ct*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; Double_tCosTheta() const; TVector3Cross(const TVector3& p) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDeltaPhi(const TVector3& v) const; Double_tDeltaR(const TVector3&) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Double_tDot(const TVector3& p) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; Double_tDrEtaPhi(const TVector3& v) const; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tEta() const; TVector2EtaPhiVector() const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; voidGetXYZ(Double_t* carray) const; voidGetXYZ(Float_t* carray) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual B",MatchSource.WIKI,root/html532/TVector3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVector3.html
https://root.cern/root/html532/TVector3.html:955,Modifiability,variab,variables,955,". TVector3. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » PHYSICS; » TVector3. class TVector3: public TObject. The Physics Vector package ; -* ========================== ; -* The Physics Vector package consists of five classes: ; -* - TVector2 ; -* - TVector3 ; -* - TRotation ; -* - TLorentzVector ; -* - TLorentzRotation ; -* It is a combination of CLHEPs Vector package written by ; -* Leif Lonnblad, Andreas Nilsson and Evgueni Tcherniaev ; -* and a ROOT package written by Pasha Murat. ; -* for CLHEP see: http://wwwinfo.cern.ch/asd/lhc++/clhep/ ; *. . TVector3; TVector3 is a general three vector class, which can be used for; the description of different vectors in 3D. Declaration / Access to the components; TVector3 has been implemented as a vector of three Double_t; variables, representing the cartesian coordinates. By default all components; are initialized to zero:;   TVector3 v1;        //; v1 = (0,0,0);   TVector3 v2(1);     // v2 = (1,0,0);   TVector3 v3(1,2,3); // v3 = (1,2,3);   TVector3 v4(v2);    // v4 = v2; It is also possible (but not recommended) to initialize a TVector3; with a Double_t or Float_t C array.; You can get the basic components either by name or by index using operator():;   xx = v1.X();    or    xx =; v1(0);;   yy = v1.Y();         ; yy = v1(1);;   zz = v1.Z();         ; zz = v1(2);; The memberfunctions SetX(), SetY(), SetZ(); and SetXYZ() allow to set the components:;   v1.SetX(1.); v1.SetY(2.); v1.SetZ(3.);;   v1.SetXYZ(1.,2.,3.);;  . Noncartesian coordinates; To get information on the TVector3 in spherical (rho,phi,theta); or cylindrical (z,r,theta) coordinates, the; the member functions Mag() (=magnitude=rho in spherical coordinates),; Mag2(), Theta(), CosTheta(), Phi(),; Perp() (the transverse component=r in cylindrical coordinates),; Perp2() can be used:;   Dou",MatchSource.WIKI,root/html532/TVector3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVector3.html
https://root.cern/root/html532/TVector3.html:6768,Modifiability,Inherit,InheritsFrom,6768,"TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; voidGetXYZ(Double_t* carray) const; voidGetXYZ(Float_t* carray) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; Double_tMag() const; Double_tMag2() const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*T",MatchSource.WIKI,root/html532/TVector3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVector3.html
https://root.cern/root/html532/TVector3.html:6834,Modifiability,Inherit,InheritsFrom,6834,"dTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; voidGetXYZ(Double_t* carray) const; voidGetXYZ(Float_t* carray) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; Double_tMag() const; Double_tMag2() const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](si",MatchSource.WIKI,root/html532/TVector3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVector3.html
https://root.cern/root/html532/TVector3.html:11107,Modifiability,Inherit,Inheritance,11107,"st; TVector3&Transform(const TRotation&); TVector3Unit() const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; Double_tx() const; Double_tX() const; TVector2XYvector() const; Double_ty() const; Double_tY() const; Double_tz() const; Double_tZ() const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Double_tfX; Double_tfY; Double_tfZ. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVector3(const TVector3& ); {}. TVector3(Double_t x = 0.0, Double_t y = 0.0, Double_t z = 0.0); {}. TVector3(const Double_t* ); {}. TVector3(const Float_t* ); {}. ~TVector3(); {}. TVector3 & Transform(const TRotation& ); transform this vector with a TRotation. Double_t Angle(const TVector3& ) const; return the angle w.r.t. another 3-vector. Double_t Mag() const; return the magnitude (rho in spherical coordinate system). Double_t Perp() const; return the transverse component (R in cylindrical coordinate system). Double_t Perp(const TVector3& ) const; return the transverse component (R in cylindrical coordinate system). Double_t Phi() const; return the azimuth angle. returns phi from -pi to pi. Double_t Theta() const; return the polar angle. TVector3 Unit() const; return unit vector parallel to this. void RotateX(Double_t ); rotate vector around X. void RotateY(Double_t ); rotate vector around Y. void RotateZ(Double_t ); rotate vector ar",MatchSource.WIKI,root/html532/TVector3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVector3.html
https://root.cern/root/html532/TVector3.html:11120,Modifiability,Inherit,Inherited,11120,"st; TVector3&Transform(const TRotation&); TVector3Unit() const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; Double_tx() const; Double_tX() const; TVector2XYvector() const; Double_ty() const; Double_tY() const; Double_tz() const; Double_tZ() const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Double_tfX; Double_tfY; Double_tfZ. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVector3(const TVector3& ); {}. TVector3(Double_t x = 0.0, Double_t y = 0.0, Double_t z = 0.0); {}. TVector3(const Double_t* ); {}. TVector3(const Float_t* ); {}. ~TVector3(); {}. TVector3 & Transform(const TRotation& ); transform this vector with a TRotation. Double_t Angle(const TVector3& ) const; return the angle w.r.t. another 3-vector. Double_t Mag() const; return the magnitude (rho in spherical coordinate system). Double_t Perp() const; return the transverse component (R in cylindrical coordinate system). Double_t Perp(const TVector3& ) const; return the transverse component (R in cylindrical coordinate system). Double_t Phi() const; return the azimuth angle. returns phi from -pi to pi. Double_t Theta() const; return the polar angle. TVector3 Unit() const; return unit vector parallel to this. void RotateX(Double_t ); rotate vector around X. void RotateY(Double_t ); rotate vector around Y. void RotateZ(Double_t ); rotate vector ar",MatchSource.WIKI,root/html532/TVector3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVector3.html
https://root.cern/root/html532/TVector3.html:868,Security,Access,Access,868,". TVector3. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » PHYSICS; » TVector3. class TVector3: public TObject. The Physics Vector package ; -* ========================== ; -* The Physics Vector package consists of five classes: ; -* - TVector2 ; -* - TVector3 ; -* - TRotation ; -* - TLorentzVector ; -* - TLorentzRotation ; -* It is a combination of CLHEPs Vector package written by ; -* Leif Lonnblad, Andreas Nilsson and Evgueni Tcherniaev ; -* and a ROOT package written by Pasha Murat. ; -* for CLHEP see: http://wwwinfo.cern.ch/asd/lhc++/clhep/ ; *. . TVector3; TVector3 is a general three vector class, which can be used for; the description of different vectors in 3D. Declaration / Access to the components; TVector3 has been implemented as a vector of three Double_t; variables, representing the cartesian coordinates. By default all components; are initialized to zero:;   TVector3 v1;        //; v1 = (0,0,0);   TVector3 v2(1);     // v2 = (1,0,0);   TVector3 v3(1,2,3); // v3 = (1,2,3);   TVector3 v4(v2);    // v4 = v2; It is also possible (but not recommended) to initialize a TVector3; with a Double_t or Float_t C array.; You can get the basic components either by name or by index using operator():;   xx = v1.X();    or    xx =; v1(0);;   yy = v1.Y();         ; yy = v1(1);;   zz = v1.Z();         ; zz = v1(2);; The memberfunctions SetX(), SetY(), SetZ(); and SetXYZ() allow to set the components:;   v1.SetX(1.); v1.SetY(2.); v1.SetZ(3.);;   v1.SetXYZ(1.,2.,3.);;  . Noncartesian coordinates; To get information on the TVector3 in spherical (rho,phi,theta); or cylindrical (z,r,theta) coordinates, the; the member functions Mag() (=magnitude=rho in spherical coordinates),; Mag2(), Theta(), CosTheta(), Phi(),; Perp() (the transverse component=r in cylindrical coordinates),; Perp2() can be used:;   Dou",MatchSource.WIKI,root/html532/TVector3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVector3.html
https://root.cern/root/html532/TVector3.html:6658,Security,Hash,Hash,6658,"tual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; voidGetXYZ(Double_t* carray) const; voidGetXYZ(Float_t* carray) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; Double_tMag() const; Double_tMag2() const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](vo",MatchSource.WIKI,root/html532/TVector3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVector3.html
https://root.cern/root/html532/TVector3.html:10048,Testability,Test,TestBit,10048," Double_tPt(const TVector3& p) const; Double_tPx() const; Double_tPy() const; Double_tPz() const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidRotate(Double_t, const TVector3&); voidRotateUz(const TVector3&); voidRotateX(Double_t); voidRotateY(Double_t); voidRotateZ(Double_t); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetMag(Double_t ma); voidSetMagThetaPhi(Double_t mag, Double_t theta, Double_t phi); static voidTObject::SetObjectStat(Bool_t stat); voidSetPerp(Double_t r); voidSetPhi(Double_t); voidSetPtEtaPhi(Double_t pt, Double_t eta, Double_t phi); voidSetPtThetaPhi(Double_t pt, Double_t theta, Double_t phi); voidSetTheta(Double_t); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetX(Double_t xx); voidSetXYZ(Double_t xx, Double_t yy, Double_t zz); voidSetY(Double_t yy); voidSetZ(Double_t zz); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Double_tTheta() const; TVector3&Transform(const TRotation&); TVector3Unit() const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; Double_tx() const; Double_tX() const; TVector2XYvector() const; Double_ty() const; Double_tY() const; Double_tz() const; Double_tZ() const.",MatchSource.WIKI,root/html532/TVector3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVector3.html
https://root.cern/root/html532/TVector3.html:10087,Testability,Test,TestBits,10087," Double_tPt(const TVector3& p) const; Double_tPx() const; Double_tPy() const; Double_tPz() const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidRotate(Double_t, const TVector3&); voidRotateUz(const TVector3&); voidRotateX(Double_t); voidRotateY(Double_t); voidRotateZ(Double_t); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetMag(Double_t ma); voidSetMagThetaPhi(Double_t mag, Double_t theta, Double_t phi); static voidTObject::SetObjectStat(Bool_t stat); voidSetPerp(Double_t r); voidSetPhi(Double_t); voidSetPtEtaPhi(Double_t pt, Double_t eta, Double_t phi); voidSetPtThetaPhi(Double_t pt, Double_t theta, Double_t phi); voidSetTheta(Double_t); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetX(Double_t xx); voidSetXYZ(Double_t xx, Double_t yy, Double_t zz); voidSetY(Double_t yy); voidSetZ(Double_t zz); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Double_tTheta() const; TVector3&Transform(const TRotation&); TVector3Unit() const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; Double_tx() const; Double_tX() const; TVector2XYvector() const; Double_ty() const; Double_tY() const; Double_tz() const; Double_tZ() const.",MatchSource.WIKI,root/html532/TVector3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVector3.html
https://root.cern/root/html532/TVector3.html:12330,Testability,log,log,12330,"ector3(); {}. TVector3 & Transform(const TRotation& ); transform this vector with a TRotation. Double_t Angle(const TVector3& ) const; return the angle w.r.t. another 3-vector. Double_t Mag() const; return the magnitude (rho in spherical coordinate system). Double_t Perp() const; return the transverse component (R in cylindrical coordinate system). Double_t Perp(const TVector3& ) const; return the transverse component (R in cylindrical coordinate system). Double_t Phi() const; return the azimuth angle. returns phi from -pi to pi. Double_t Theta() const; return the polar angle. TVector3 Unit() const; return unit vector parallel to this. void RotateX(Double_t ); rotate vector around X. void RotateY(Double_t ); rotate vector around Y. void RotateZ(Double_t ); rotate vector around Z. void Rotate(Double_t , const TVector3& ); rotate vector. void RotateUz(const TVector3& ); NewUzVector must be normalized !. Double_t PseudoRapidity() const; Double_t m = Mag();; return 0.5*log( (m+fZ)/(m-fZ) );; guard against Pt=0. void SetPtEtaPhi(Double_t pt, Double_t eta, Double_t phi); set Pt, Eta and Phi. void SetPtThetaPhi(Double_t pt, Double_t theta, Double_t phi); set Pt, Theta and Phi. void SetTheta(Double_t ); Set theta keeping mag and phi constant (BaBar). void SetPhi(Double_t ); Set phi keeping mag and theta constant (BaBar). Double_t DeltaR(const TVector3& ) const; return deltaR with respect to v. void SetMagThetaPhi(Double_t mag, Double_t theta, Double_t phi); setter with mag, theta, phi. void Streamer(TBuffer& b); Stream an object of class TVector3. void Print(Option_t* option = """") const; print vector parameters. Double_t & operator[](int i); { return operator()(i); }. Double_t operator[](int i) const; { return operator()(i); }. Double_t x() const; { return fX; }. Double_t y() const; { return fY; }. Double_t z() const; { return fZ; }. Double_t X() const; { return fX; }. Double_t Y() const; { return fY; }. Double_t Z() const; { return fZ; }. Double_t Px() const; { return fX; ",MatchSource.WIKI,root/html532/TVector3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVector3.html
https://root.cern/root/html532/TVector3.html:4784,Usability,Clear,Clear,4784,,MatchSource.WIKI,root/html532/TVector3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVector3.html
https://root.cern/root/html532/TVectorT_double_.html:549,Availability,avail,available,549,". TVectorT<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TVectorT<double>. class TVectorT<double>: public TObject. TVectorT. Template class of Vectors in the linear algebra package. Unless otherwise specified, vector indices always start with 0,; spanning up to the specified limit-1. For (n) vectors where n <= kSizeMax (5 currently) storage space is; available on the stack, thus avoiding expensive allocation/; deallocation of heap space . However, this introduces of course; kSizeMax overhead for each vector object . If this is an issue; recompile with a new appropriate value (>=0) for kSizeMax. Another way to assign and store vector data is through Use; see for instance stressLinear.cxx file . Note that Constructors/assignments exists for all different matrix; views. For usage examples see $ROOTSYS/test/stressLinear.cxx. This class is also known as (typedefs to this class)TVectorT<Double_t>, TVectorD. Function Members (Methods); public:. TVectorT<double>(); TVectorT<double>(Int_t n); TVectorT<double>(const TVectorT<double>& another); TVectorT<double>(const TMatrixTRow_const<double>& mr); TVectorT<double>(const TMatrixTColumn_const<double>& mc); TVectorT<double>(const TMatrixTDiag_const<double>& md); TVectorT<double>(const TVectorT<float>& another); TVectorT<double>(Int_t lwb, Int_t upb); TVectorT<double>(Int_t n, const double* elements); TVectorT<double>(Int_t lwb, Int_t upb, const double* elements); virtual~TVectorT<double>(); TVectorT<double>&Abs(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TVectorT<double>& v); voidAdd(const TVectorT<double>& v1, const TVectorT<double>& v2); voidAddSomeConstant(double val, const TVectorT<double>& select); virtual voidTObject::AppendPad(Option_t* option = """"); TVectorT<double>&Apply(const TElementActionT<double>&",MatchSource.WIKI,root/html532/TVectorT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVectorT_double_.html
https://root.cern/root/html532/TVectorT_double_.html:2737,Availability,Error,Error,2737," TVectorT<double>& v); voidAdd(const TVectorT<double>& v1, const TVectorT<double>& v2); voidAddSomeConstant(double val, const TVectorT<double>& select); virtual voidTObject::AppendPad(Option_t* option = """"); TVectorT<double>&Apply(const TElementActionT<double>& action); TVectorT<double>&Apply(const TElementPosActionT<double>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetLwb() const; double*GetMatrixArray(); const double*GetMatrixArray() const; virtual const char*TObject::GetName() const; Int_tGetNoElements() const; Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TVectorT<double>GetSub(Int_t row_lwb, Int_t row_upb",MatchSource.WIKI,root/html532/TVectorT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVectorT_double_.html
https://root.cern/root/html532/TVectorT_double_.html:2866,Availability,error,error,2866,"ctorT<double>& select); virtual voidTObject::AppendPad(Option_t* option = """"); TVectorT<double>&Apply(const TElementActionT<double>& action); TVectorT<double>&Apply(const TElementPosActionT<double>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetLwb() const; double*GetMatrixArray(); const double*GetMatrixArray() const; virtual const char*TObject::GetName() const; Int_tGetNoElements() const; Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TVectorT<double>GetSub(Int_t row_lwb, Int_t row_upb, Option_t* option = ""S"") const; TVectorT<double>&GetSub(Int_t row_lwb, Int_t row_upb, TVectorT<double>& target, Option_t* option",MatchSource.WIKI,root/html532/TVectorT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVectorT_double_.html
https://root.cern/root/html532/TVectorT_double_.html:2950,Availability,error,error,2950,"orT<double>&Apply(const TElementActionT<double>& action); TVectorT<double>&Apply(const TElementPosActionT<double>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetLwb() const; double*GetMatrixArray(); const double*GetMatrixArray() const; virtual const char*TObject::GetName() const; Int_tGetNoElements() const; Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TVectorT<double>GetSub(Int_t row_lwb, Int_t row_upb, Option_t* option = ""S"") const; TVectorT<double>&GetSub(Int_t row_lwb, Int_t row_upb, TVectorT<double>& target, Option_t* option = ""S"") const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::",MatchSource.WIKI,root/html532/TVectorT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVectorT_double_.html
https://root.cern/root/html532/TVectorT_double_.html:10659,Energy Efficiency,Allocate,Allocate,10659,"ouble*fElements[fNrows] elements themselves; Bool_tfIsOwner!default kTRUE, when Use array kFALSE; Int_tfNrowsnumber of rows; Int_tfRowLwblower bound of the row index. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TVectorT<Element> Delete_m(Int_t size, double*& ); Delete data pointer m, if it was assigned on the heap. Element* TVectorT<Element> New_m(Int_t size); Return data pointer . if requested size <= kSizeMax, assign pointer; to the stack space. void TVectorT<Element> Add(const TVectorT<double>& v); Add vector v to this vector. void TVectorT<Element> Add(const TVectorT<double>& v1, const TVectorT<double>& v2); Set this vector to v1+v2. Int_t TVectorT<Element> Memcpy_m(double* newp, const double* oldp, Int_t copySize, Int_t newSize, Int_t oldSize); Copy copySize doubles from *oldp to *newp . However take care of the; situation where both pointers are assigned to the same stack space. void TVectorT<Element> Allocate(Int_t nrows, Int_t row_lwb = 0, Int_t init = 0); Allocate new vector. Arguments are number of rows and row; lowerbound (0 default). TVectorT<Element> &TVectorT<Element> ResizeTo(Int_t lwb, Int_t upb); Resize the vector to [lwb:upb] .; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleleted. TVectorT<Element> &TVectorT<Element> Use(Int_t lwb, Int_t upb, double* data); Use the array data to fill the vector lwb..upb]. TVectorT<Element> &TVectorT<Element> GetSub(Int_t row_lwb, Int_t row_upb, TVectorT<double>& target, Option_t* option = ""S"") const; Get subvector [row_lwb..row_upb]; The indexing range of the; returned vector depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb+1] (default); else : return [row_lwb..row_upb]. TVectorT<Element> &TVectorT<Element> SetSub(Int_t row_lwb, const TVectorT<double>& source); Insert vector source starting at [row_lwb], thereby overwriting the part; [row_lwb..row_l",MatchSource.WIKI,root/html532/TVectorT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVectorT_double_.html
https://root.cern/root/html532/TVectorT_double_.html:10717,Energy Efficiency,Allocate,Allocate,10717,"ouble*fElements[fNrows] elements themselves; Bool_tfIsOwner!default kTRUE, when Use array kFALSE; Int_tfNrowsnumber of rows; Int_tfRowLwblower bound of the row index. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TVectorT<Element> Delete_m(Int_t size, double*& ); Delete data pointer m, if it was assigned on the heap. Element* TVectorT<Element> New_m(Int_t size); Return data pointer . if requested size <= kSizeMax, assign pointer; to the stack space. void TVectorT<Element> Add(const TVectorT<double>& v); Add vector v to this vector. void TVectorT<Element> Add(const TVectorT<double>& v1, const TVectorT<double>& v2); Set this vector to v1+v2. Int_t TVectorT<Element> Memcpy_m(double* newp, const double* oldp, Int_t copySize, Int_t newSize, Int_t oldSize); Copy copySize doubles from *oldp to *newp . However take care of the; situation where both pointers are assigned to the same stack space. void TVectorT<Element> Allocate(Int_t nrows, Int_t row_lwb = 0, Int_t init = 0); Allocate new vector. Arguments are number of rows and row; lowerbound (0 default). TVectorT<Element> &TVectorT<Element> ResizeTo(Int_t lwb, Int_t upb); Resize the vector to [lwb:upb] .; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleleted. TVectorT<Element> &TVectorT<Element> Use(Int_t lwb, Int_t upb, double* data); Use the array data to fill the vector lwb..upb]. TVectorT<Element> &TVectorT<Element> GetSub(Int_t row_lwb, Int_t row_upb, TVectorT<double>& target, Option_t* option = ""S"") const; Get subvector [row_lwb..row_upb]; The indexing range of the; returned vector depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb+1] (default); else : return [row_lwb..row_upb]. TVectorT<Element> &TVectorT<Element> SetSub(Int_t row_lwb, const TVectorT<double>& source); Insert vector source starting at [row_lwb], thereby overwriting the part; [row_lwb..row_l",MatchSource.WIKI,root/html532/TVectorT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVectorT_double_.html
https://root.cern/root/html532/TVectorT_double_.html:11381,Integrability,depend,depends,11381,"tor to v1+v2. Int_t TVectorT<Element> Memcpy_m(double* newp, const double* oldp, Int_t copySize, Int_t newSize, Int_t oldSize); Copy copySize doubles from *oldp to *newp . However take care of the; situation where both pointers are assigned to the same stack space. void TVectorT<Element> Allocate(Int_t nrows, Int_t row_lwb = 0, Int_t init = 0); Allocate new vector. Arguments are number of rows and row; lowerbound (0 default). TVectorT<Element> &TVectorT<Element> ResizeTo(Int_t lwb, Int_t upb); Resize the vector to [lwb:upb] .; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleleted. TVectorT<Element> &TVectorT<Element> Use(Int_t lwb, Int_t upb, double* data); Use the array data to fill the vector lwb..upb]. TVectorT<Element> &TVectorT<Element> GetSub(Int_t row_lwb, Int_t row_upb, TVectorT<double>& target, Option_t* option = ""S"") const; Get subvector [row_lwb..row_upb]; The indexing range of the; returned vector depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb+1] (default); else : return [row_lwb..row_upb]. TVectorT<Element> &TVectorT<Element> SetSub(Int_t row_lwb, const TVectorT<double>& source); Insert vector source starting at [row_lwb], thereby overwriting the part; [row_lwb..row_lwb+nrows_source];. TVectorT<Element> &TVectorT<Element> Zero(); Set vector elements to zero. TVectorT<Element> &TVectorT<Element> Abs(); Take an absolute value of a vector, i.e. apply Abs() to each element. TVectorT<Element> &TVectorT<Element> Sqr(); Square each element of the vector. TVectorT<Element> &TVectorT<Element> Sqrt(); Take square root of all elements. TVectorT<Element> &TVectorT<Element> Invert(); v[i] = 1/v[i]. TVectorT<Element> &TVectorT<Element> SelectNonZeros(const TVectorT<double>& select); Keep only element as selected through array select non-zero. Element TVectorT<Element> Norm1() const; Compute the 1-norm of the vector SUM{ |v[i]| }. Element TVectorT<Elemen",MatchSource.WIKI,root/html532/TVectorT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVectorT_double_.html
https://root.cern/root/html532/TVectorT_double_.html:4180,Modifiability,Inherit,InheritsFrom,4180,"ct::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetLwb() const; double*GetMatrixArray(); const double*GetMatrixArray() const; virtual const char*TObject::GetName() const; Int_tGetNoElements() const; Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TVectorT<double>GetSub(Int_t row_lwb, Int_t row_upb, Option_t* option = ""S"") const; TVectorT<double>&GetSub(Int_t row_lwb, Int_t row_upb, TVectorT<double>& target, Option_t* option = ""S"") const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Int_tGetUpb() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidInvalidate(); TVectorT<double>&Invert(); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tIsOwner() const; virtual Bool_tTObject::IsSortable() const; Bool_tIsValid() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidMakeValid(); Bool_tMatchesNonZeroPattern(const TVectorT<double>& select); doubleMax() const; voidTObject::MayNotUse(const char* method) const; doubleMin() const; Int_tNonZeros() const; doubleNorm1() const; doubleNorm2Sqr() const; doubleNormInf() const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static ",MatchSource.WIKI,root/html532/TVectorT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVectorT_double_.html
https://root.cern/root/html532/TVectorT_double_.html:4246,Modifiability,Inherit,InheritsFrom,4246,"::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetLwb() const; double*GetMatrixArray(); const double*GetMatrixArray() const; virtual const char*TObject::GetName() const; Int_tGetNoElements() const; Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TVectorT<double>GetSub(Int_t row_lwb, Int_t row_upb, Option_t* option = ""S"") const; TVectorT<double>&GetSub(Int_t row_lwb, Int_t row_upb, TVectorT<double>& target, Option_t* option = ""S"") const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Int_tGetUpb() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidInvalidate(); TVectorT<double>&Invert(); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tIsOwner() const; virtual Bool_tTObject::IsSortable() const; Bool_tIsValid() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidMakeValid(); Bool_tMatchesNonZeroPattern(const TVectorT<double>& select); doubleMax() const; voidTObject::MayNotUse(const char* method) const; doubleMin() const; Int_tNonZeros() const; doubleNorm1() const; doubleNorm2Sqr() const; doubleNormInf() const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObj",MatchSource.WIKI,root/html532/TVectorT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVectorT_double_.html
https://root.cern/root/html532/TVectorT_double_.html:9867,Modifiability,Inherit,Inheritance,9867,"fsize = 0) const; TVectorT<double>&Zero(). protected:. voidAllocate(Int_t nrows, Int_t row_lwb = 0, Int_t init = 0); voidDelete_m(Int_t size, double*&); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); Int_tMemcpy_m(double* newp, const double* oldp, Int_t copySize, Int_t newSize, Int_t oldSize); double*New_m(Int_t size). Data Members; public:. enum { kSizeMax; kWorkMax; };; enum EVectorStatusBits { kStatus; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. doublefDataStack[5]! data container; double*fElements[fNrows] elements themselves; Bool_tfIsOwner!default kTRUE, when Use array kFALSE; Int_tfNrowsnumber of rows; Int_tfRowLwblower bound of the row index. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TVectorT<Element> Delete_m(Int_t size, double*& ); Delete data pointer m, if it was assigned on the heap. Element* TVectorT<Element> New_m(Int_t size); Return data pointer . if requested size <= kSizeMax, assign pointer; to the stack space. void TVectorT<Element> Add(const TVectorT<double>& v); Add vector v to this vector. void TVectorT<Element> Add(const TVectorT<double>& v1, const TVectorT<double>& v2); Set this vector to v1+v2. Int_t TVectorT<Element> Memcpy_m(double* newp, const double* oldp, Int_t copySize, Int_t newSize, Int_t oldSize); Copy copySize doubles from *oldp to *newp . However take care of the; situation where both pointers are assigned to the same stack space. void TVectorT<Element> Allocate(Int_t nrows, Int_t row_lwb = 0, Int_t init = 0); Allocate new vector. Arguments are number of rows and row; lowerbound (0 default). TVectorT<Element> &TVectorT<Element> ResizeTo(Int_t lwb, Int_t upb); Resize the vector to [lw",MatchSource.WIKI,root/html532/TVectorT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVectorT_double_.html
https://root.cern/root/html532/TVectorT_double_.html:9880,Modifiability,Inherit,Inherited,9880,"fsize = 0) const; TVectorT<double>&Zero(). protected:. voidAllocate(Int_t nrows, Int_t row_lwb = 0, Int_t init = 0); voidDelete_m(Int_t size, double*&); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); Int_tMemcpy_m(double* newp, const double* oldp, Int_t copySize, Int_t newSize, Int_t oldSize); double*New_m(Int_t size). Data Members; public:. enum { kSizeMax; kWorkMax; };; enum EVectorStatusBits { kStatus; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. doublefDataStack[5]! data container; double*fElements[fNrows] elements themselves; Bool_tfIsOwner!default kTRUE, when Use array kFALSE; Int_tfNrowsnumber of rows; Int_tfRowLwblower bound of the row index. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TVectorT<Element> Delete_m(Int_t size, double*& ); Delete data pointer m, if it was assigned on the heap. Element* TVectorT<Element> New_m(Int_t size); Return data pointer . if requested size <= kSizeMax, assign pointer; to the stack space. void TVectorT<Element> Add(const TVectorT<double>& v); Add vector v to this vector. void TVectorT<Element> Add(const TVectorT<double>& v1, const TVectorT<double>& v2); Set this vector to v1+v2. Int_t TVectorT<Element> Memcpy_m(double* newp, const double* oldp, Int_t copySize, Int_t newSize, Int_t oldSize); Copy copySize doubles from *oldp to *newp . However take care of the; situation where both pointers are assigned to the same stack space. void TVectorT<Element> Allocate(Int_t nrows, Int_t row_lwb = 0, Int_t init = 0); Allocate new vector. Arguments are number of rows and row; lowerbound (0 default). TVectorT<Element> &TVectorT<Element> ResizeTo(Int_t lwb, Int_t upb); Resize the vector to [lw",MatchSource.WIKI,root/html532/TVectorT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVectorT_double_.html
https://root.cern/root/html532/TVectorT_double_.html:578,Safety,avoid,avoiding,578,". TVectorT<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TVectorT<double>. class TVectorT<double>: public TObject. TVectorT. Template class of Vectors in the linear algebra package. Unless otherwise specified, vector indices always start with 0,; spanning up to the specified limit-1. For (n) vectors where n <= kSizeMax (5 currently) storage space is; available on the stack, thus avoiding expensive allocation/; deallocation of heap space . However, this introduces of course; kSizeMax overhead for each vector object . If this is an issue; recompile with a new appropriate value (>=0) for kSizeMax. Another way to assign and store vector data is through Use; see for instance stressLinear.cxx file . Note that Constructors/assignments exists for all different matrix; views. For usage examples see $ROOTSYS/test/stressLinear.cxx. This class is also known as (typedefs to this class)TVectorT<Double_t>, TVectorD. Function Members (Methods); public:. TVectorT<double>(); TVectorT<double>(Int_t n); TVectorT<double>(const TVectorT<double>& another); TVectorT<double>(const TMatrixTRow_const<double>& mr); TVectorT<double>(const TMatrixTColumn_const<double>& mc); TVectorT<double>(const TMatrixTDiag_const<double>& md); TVectorT<double>(const TVectorT<float>& another); TVectorT<double>(Int_t lwb, Int_t upb); TVectorT<double>(Int_t n, const double* elements); TVectorT<double>(Int_t lwb, Int_t upb, const double* elements); virtual~TVectorT<double>(); TVectorT<double>&Abs(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TVectorT<double>& v); voidAdd(const TVectorT<double>& v1, const TVectorT<double>& v2); voidAddSomeConstant(double val, const TVectorT<double>& select); virtual voidTObject::AppendPad(Option_t* option = """"); TVectorT<double>&Apply(const TElementActionT<double>&",MatchSource.WIKI,root/html532/TVectorT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVectorT_double_.html
https://root.cern/root/html532/TVectorT_double_.html:4070,Security,Hash,Hash,4070,"hod, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetLwb() const; double*GetMatrixArray(); const double*GetMatrixArray() const; virtual const char*TObject::GetName() const; Int_tGetNoElements() const; Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TVectorT<double>GetSub(Int_t row_lwb, Int_t row_upb, Option_t* option = ""S"") const; TVectorT<double>&GetSub(Int_t row_lwb, Int_t row_upb, TVectorT<double>& target, Option_t* option = ""S"") const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Int_tGetUpb() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidInvalidate(); TVectorT<double>&Invert(); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tIsOwner() const; virtual Bool_tTObject::IsSortable() const; Bool_tIsValid() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidMakeValid(); Bool_tMatchesNonZeroPattern(const TVectorT<double>& select); doubleMax() const; voidTObject::MayNotUse(const char* method) const; doubleMin() const; Int_tNonZeros() const; doubleNorm1() const; doubleNorm2Sqr() const; doubleNormInf() const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method,",MatchSource.WIKI,root/html532/TVectorT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVectorT_double_.html
https://root.cern/root/html532/TVectorT_double_.html:17455,Security,Access,Access,17455,"rrent element is known. void TVectorT<Element> Draw(Option_t* option = """"); Draw this vector; The histogram is named ""TVectorT"" by default and no title. void TVectorT<Element> Print(Option_t* option = """") const; Print the vector as a list of elements. void TVectorT<Element> Streamer(TBuffer& b); Stream an object of class TVectorT. template<class Element> inline TVectorT<Element> &TVectorT<Element> Use(Int_t n, double* data); { return Use(0,n-1,data); }. template<class Element> inline const TVectorT<Element> &TVectorT<Element> Use(Int_t n, const double* data) const; { return Use(0,n-1,data); }. template<class Element> inline TVectorT<Element> &TVectorT<Element> Use(TVectorT<double>& v). template<class Element> inline const TVectorT<Element> &TVectorT<Element> Use(const TVectorT<double>& v) const. template<class Element> inline TVectorT<Element> TVectorT<Element> GetSub(Int_t row_lwb, Int_t row_upb, Option_t* option = ""S"") const. template<class Element> inline const Element &TVectorT<Element> operator()(Int_t ind) const; Access a vector element. template<class Element> inline Element &TVectorT<Element> operator()(Int_t ind); Access a vector element. Int_t GetLwb() const; { return fRowLwb; }. Int_t GetUpb() const; { return fNrows+fRowLwb-1; }. Int_t GetNrows() const; { return fNrows; }. Int_t GetNoElements() const; { return fNrows; }. Element * GetMatrixArray(); { return fElements; }. const Element * GetMatrixArray() const; { return fElements; }. void Invalidate(); { SetBit(kStatus); }. void MakeValid(); { ResetBit(kStatus); }. Bool_t IsValid() const; { return !TestBit(kStatus); }. Bool_t IsOwner() const; { return fIsOwner; }. void SetElements(const double* elements). TVectorT<Element> & Shift(Int_t row_shift); { fRowLwb += row_shift; return *this; }. TVectorT<Element> & ResizeTo(Int_t lwb, Int_t upb). TVectorT<Element> & ResizeTo(Int_t n); { return ResizeTo(0,n-1); }. TVectorT<Element> & Use(Int_t lwb, Int_t upb, double* data). const Element & operator[](Int_t index) ",MatchSource.WIKI,root/html532/TVectorT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVectorT_double_.html
https://root.cern/root/html532/TVectorT_double_.html:17561,Security,Access,Access,17561,"amed ""TVectorT"" by default and no title. void TVectorT<Element> Print(Option_t* option = """") const; Print the vector as a list of elements. void TVectorT<Element> Streamer(TBuffer& b); Stream an object of class TVectorT. template<class Element> inline TVectorT<Element> &TVectorT<Element> Use(Int_t n, double* data); { return Use(0,n-1,data); }. template<class Element> inline const TVectorT<Element> &TVectorT<Element> Use(Int_t n, const double* data) const; { return Use(0,n-1,data); }. template<class Element> inline TVectorT<Element> &TVectorT<Element> Use(TVectorT<double>& v). template<class Element> inline const TVectorT<Element> &TVectorT<Element> Use(const TVectorT<double>& v) const. template<class Element> inline TVectorT<Element> TVectorT<Element> GetSub(Int_t row_lwb, Int_t row_upb, Option_t* option = ""S"") const. template<class Element> inline const Element &TVectorT<Element> operator()(Int_t ind) const; Access a vector element. template<class Element> inline Element &TVectorT<Element> operator()(Int_t ind); Access a vector element. Int_t GetLwb() const; { return fRowLwb; }. Int_t GetUpb() const; { return fNrows+fRowLwb-1; }. Int_t GetNrows() const; { return fNrows; }. Int_t GetNoElements() const; { return fNrows; }. Element * GetMatrixArray(); { return fElements; }. const Element * GetMatrixArray() const; { return fElements; }. void Invalidate(); { SetBit(kStatus); }. void MakeValid(); { ResetBit(kStatus); }. Bool_t IsValid() const; { return !TestBit(kStatus); }. Bool_t IsOwner() const; { return fIsOwner; }. void SetElements(const double* elements). TVectorT<Element> & Shift(Int_t row_shift); { fRowLwb += row_shift; return *this; }. TVectorT<Element> & ResizeTo(Int_t lwb, Int_t upb). TVectorT<Element> & ResizeTo(Int_t n); { return ResizeTo(0,n-1); }. TVectorT<Element> & Use(Int_t lwb, Int_t upb, double* data). const Element & operator[](Int_t index) const; { return (*this)(index); }. Element & operator[](Int_t index); { return (*this)(index); }. void Clear(Opt",MatchSource.WIKI,root/html532/TVectorT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVectorT_double_.html
https://root.cern/root/html532/TVectorT_double_.html:1006,Testability,test,test,1006,". TVectorT<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TVectorT<double>. class TVectorT<double>: public TObject. TVectorT. Template class of Vectors in the linear algebra package. Unless otherwise specified, vector indices always start with 0,; spanning up to the specified limit-1. For (n) vectors where n <= kSizeMax (5 currently) storage space is; available on the stack, thus avoiding expensive allocation/; deallocation of heap space . However, this introduces of course; kSizeMax overhead for each vector object . If this is an issue; recompile with a new appropriate value (>=0) for kSizeMax. Another way to assign and store vector data is through Use; see for instance stressLinear.cxx file . Note that Constructors/assignments exists for all different matrix; views. For usage examples see $ROOTSYS/test/stressLinear.cxx. This class is also known as (typedefs to this class)TVectorT<Double_t>, TVectorD. Function Members (Methods); public:. TVectorT<double>(); TVectorT<double>(Int_t n); TVectorT<double>(const TVectorT<double>& another); TVectorT<double>(const TMatrixTRow_const<double>& mr); TVectorT<double>(const TMatrixTColumn_const<double>& mc); TVectorT<double>(const TMatrixTDiag_const<double>& md); TVectorT<double>(const TVectorT<float>& another); TVectorT<double>(Int_t lwb, Int_t upb); TVectorT<double>(Int_t n, const double* elements); TVectorT<double>(Int_t lwb, Int_t upb, const double* elements); virtual~TVectorT<double>(); TVectorT<double>&Abs(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TVectorT<double>& v); voidAdd(const TVectorT<double>& v1, const TVectorT<double>& v2); voidAddSomeConstant(double val, const TVectorT<double>& select); virtual voidTObject::AppendPad(Option_t* option = """"); TVectorT<double>&Apply(const TElementActionT<double>&",MatchSource.WIKI,root/html532/TVectorT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVectorT_double_.html
https://root.cern/root/html532/TVectorT_double_.html:8201,Testability,Test,TestBit,8201,"_t& seed); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); TVectorT<double>&ResizeTo(Int_t n); TVectorT<double>&ResizeTo(const TVectorT<double>& v); TVectorT<double>&ResizeTo(Int_t lwb, Int_t upb); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TVectorT<double>&SelectNonZeros(const TVectorT<double>& select); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetElements(const double* elements); static voidTObject::SetObjectStat(Bool_t stat); TVectorT<double>&SetSub(Int_t row_lwb, const TVectorT<double>& source); virtual voidTObject::SetUniqueID(UInt_t uid); TVectorT<double>&Shift(Int_t row_shift); virtual voidShowMembers(TMemberInspector& insp); Bool_tSomePositive(const TVectorT<double>& select); TVectorT<double>&Sqr(); TVectorT<double>&Sqrt(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); doubleSum() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TVectorT<double>&Use(TVectorT<double>& v); const TVectorT<double>&Use(const TVectorT<double>& v) const; TVectorT<double>&Use(Int_t n, double* data); const TVectorT<double>&Use(Int_t n, const double* data) const; TVectorT<double>&Use(Int_t lwb, Int_t upb, double* data); const TVectorT<double>&Use(Int_t lwb, Int_t upb, const double* data) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; TVectorT<double>&Zero().",MatchSource.WIKI,root/html532/TVectorT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVectorT_double_.html
https://root.cern/root/html532/TVectorT_double_.html:8240,Testability,Test,TestBits,8240,"_t& seed); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); TVectorT<double>&ResizeTo(Int_t n); TVectorT<double>&ResizeTo(const TVectorT<double>& v); TVectorT<double>&ResizeTo(Int_t lwb, Int_t upb); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TVectorT<double>&SelectNonZeros(const TVectorT<double>& select); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetElements(const double* elements); static voidTObject::SetObjectStat(Bool_t stat); TVectorT<double>&SetSub(Int_t row_lwb, const TVectorT<double>& source); virtual voidTObject::SetUniqueID(UInt_t uid); TVectorT<double>&Shift(Int_t row_shift); virtual voidShowMembers(TMemberInspector& insp); Bool_tSomePositive(const TVectorT<double>& select); TVectorT<double>&Sqr(); TVectorT<double>&Sqrt(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); doubleSum() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TVectorT<double>&Use(TVectorT<double>& v); const TVectorT<double>&Use(const TVectorT<double>& v) const; TVectorT<double>&Use(Int_t n, double* data); const TVectorT<double>&Use(Int_t n, const double* data) const; TVectorT<double>&Use(Int_t lwb, Int_t upb, double* data); const TVectorT<double>&Use(Int_t lwb, Int_t upb, const double* data) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; TVectorT<double>&Zero().",MatchSource.WIKI,root/html532/TVectorT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVectorT_double_.html
https://root.cern/root/html532/TVectorT_double_.html:18005,Testability,Test,TestBit,18005,"nt> Use(Int_t n, double* data); { return Use(0,n-1,data); }. template<class Element> inline const TVectorT<Element> &TVectorT<Element> Use(Int_t n, const double* data) const; { return Use(0,n-1,data); }. template<class Element> inline TVectorT<Element> &TVectorT<Element> Use(TVectorT<double>& v). template<class Element> inline const TVectorT<Element> &TVectorT<Element> Use(const TVectorT<double>& v) const. template<class Element> inline TVectorT<Element> TVectorT<Element> GetSub(Int_t row_lwb, Int_t row_upb, Option_t* option = ""S"") const. template<class Element> inline const Element &TVectorT<Element> operator()(Int_t ind) const; Access a vector element. template<class Element> inline Element &TVectorT<Element> operator()(Int_t ind); Access a vector element. Int_t GetLwb() const; { return fRowLwb; }. Int_t GetUpb() const; { return fNrows+fRowLwb-1; }. Int_t GetNrows() const; { return fNrows; }. Int_t GetNoElements() const; { return fNrows; }. Element * GetMatrixArray(); { return fElements; }. const Element * GetMatrixArray() const; { return fElements; }. void Invalidate(); { SetBit(kStatus); }. void MakeValid(); { ResetBit(kStatus); }. Bool_t IsValid() const; { return !TestBit(kStatus); }. Bool_t IsOwner() const; { return fIsOwner; }. void SetElements(const double* elements). TVectorT<Element> & Shift(Int_t row_shift); { fRowLwb += row_shift; return *this; }. TVectorT<Element> & ResizeTo(Int_t lwb, Int_t upb). TVectorT<Element> & ResizeTo(Int_t n); { return ResizeTo(0,n-1); }. TVectorT<Element> & Use(Int_t lwb, Int_t upb, double* data). const Element & operator[](Int_t index) const; { return (*this)(index); }. Element & operator[](Int_t index); { return (*this)(index); }. void Clear(Option_t* = """"). » Last changed: root/matrix:$Id: TVectorT.h 39086 2011-05-04 09:36:17Z moneta $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TVectorT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVectorT_double_.html
https://root.cern/root/html532/TVectorT_double_.html:18523,Usability,Clear,Clear,18523,"nt> Use(Int_t n, double* data); { return Use(0,n-1,data); }. template<class Element> inline const TVectorT<Element> &TVectorT<Element> Use(Int_t n, const double* data) const; { return Use(0,n-1,data); }. template<class Element> inline TVectorT<Element> &TVectorT<Element> Use(TVectorT<double>& v). template<class Element> inline const TVectorT<Element> &TVectorT<Element> Use(const TVectorT<double>& v) const. template<class Element> inline TVectorT<Element> TVectorT<Element> GetSub(Int_t row_lwb, Int_t row_upb, Option_t* option = ""S"") const. template<class Element> inline const Element &TVectorT<Element> operator()(Int_t ind) const; Access a vector element. template<class Element> inline Element &TVectorT<Element> operator()(Int_t ind); Access a vector element. Int_t GetLwb() const; { return fRowLwb; }. Int_t GetUpb() const; { return fNrows+fRowLwb-1; }. Int_t GetNrows() const; { return fNrows; }. Int_t GetNoElements() const; { return fNrows; }. Element * GetMatrixArray(); { return fElements; }. const Element * GetMatrixArray() const; { return fElements; }. void Invalidate(); { SetBit(kStatus); }. void MakeValid(); { ResetBit(kStatus); }. Bool_t IsValid() const; { return !TestBit(kStatus); }. Bool_t IsOwner() const; { return fIsOwner; }. void SetElements(const double* elements). TVectorT<Element> & Shift(Int_t row_shift); { fRowLwb += row_shift; return *this; }. TVectorT<Element> & ResizeTo(Int_t lwb, Int_t upb). TVectorT<Element> & ResizeTo(Int_t n); { return ResizeTo(0,n-1); }. TVectorT<Element> & Use(Int_t lwb, Int_t upb, double* data). const Element & operator[](Int_t index) const; { return (*this)(index); }. Element & operator[](Int_t index); { return (*this)(index); }. void Clear(Option_t* = """"). » Last changed: root/matrix:$Id: TVectorT.h 39086 2011-05-04 09:36:17Z moneta $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TVectorT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVectorT_double_.html
https://root.cern/root/html532/TVectorT_float_.html:546,Availability,avail,available,546,". TVectorT<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TVectorT<float>. class TVectorT<float>: public TObject. TVectorT. Template class of Vectors in the linear algebra package. Unless otherwise specified, vector indices always start with 0,; spanning up to the specified limit-1. For (n) vectors where n <= kSizeMax (5 currently) storage space is; available on the stack, thus avoiding expensive allocation/; deallocation of heap space . However, this introduces of course; kSizeMax overhead for each vector object . If this is an issue; recompile with a new appropriate value (>=0) for kSizeMax. Another way to assign and store vector data is through Use; see for instance stressLinear.cxx file . Note that Constructors/assignments exists for all different matrix; views. For usage examples see $ROOTSYS/test/stressLinear.cxx. This class is also known as (typedefs to this class)TVectorT<Float_t>, TVectorF, TVector. Function Members (Methods); public:. TVectorT<float>(); TVectorT<float>(Int_t n); TVectorT<float>(const TVectorT<float>& another); TVectorT<float>(const TMatrixTRow_const<float>& mr); TVectorT<float>(const TMatrixTColumn_const<float>& mc); TVectorT<float>(const TMatrixTDiag_const<float>& md); TVectorT<float>(const TVectorT<double>& another); TVectorT<float>(Int_t lwb, Int_t upb); TVectorT<float>(Int_t n, const float* elements); TVectorT<float>(Int_t lwb, Int_t upb, const float* elements); virtual~TVectorT<float>(); TVectorT<float>&Abs(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TVectorT<float>& v); voidAdd(const TVectorT<float>& v1, const TVectorT<float>& v2); voidAddSomeConstant(float val, const TVectorT<float>& select); virtual voidTObject::AppendPad(Option_t* option = """"); TVectorT<float>&Apply(const TElementActionT<float>& action); TVectorT<",MatchSource.WIKI,root/html532/TVectorT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVectorT_float_.html
https://root.cern/root/html532/TVectorT_float_.html:2716,Availability,Error,Error,2716,"Add(const TVectorT<float>& v); voidAdd(const TVectorT<float>& v1, const TVectorT<float>& v2); voidAddSomeConstant(float val, const TVectorT<float>& select); virtual voidTObject::AppendPad(Option_t* option = """"); TVectorT<float>&Apply(const TElementActionT<float>& action); TVectorT<float>&Apply(const TElementPosActionT<float>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetLwb() const; float*GetMatrixArray(); const float*GetMatrixArray() const; virtual const char*TObject::GetName() const; Int_tGetNoElements() const; Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TVectorT<float>GetSub(Int_t row_lwb, Int_t row_upb, O",MatchSource.WIKI,root/html532/TVectorT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVectorT_float_.html
https://root.cern/root/html532/TVectorT_float_.html:2845,Availability,error,error,2845,"t TVectorT<float>& select); virtual voidTObject::AppendPad(Option_t* option = """"); TVectorT<float>&Apply(const TElementActionT<float>& action); TVectorT<float>&Apply(const TElementPosActionT<float>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetLwb() const; float*GetMatrixArray(); const float*GetMatrixArray() const; virtual const char*TObject::GetName() const; Int_tGetNoElements() const; Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TVectorT<float>GetSub(Int_t row_lwb, Int_t row_upb, Option_t* option = ""S"") const; TVectorT<float>&GetSub(Int_t row_lwb, Int_t row_upb, TVectorT<float>& target, Option_t* option = ""S",MatchSource.WIKI,root/html532/TVectorT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVectorT_float_.html
https://root.cern/root/html532/TVectorT_float_.html:2929,Availability,error,error,2929,"VectorT<float>&Apply(const TElementActionT<float>& action); TVectorT<float>&Apply(const TElementPosActionT<float>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetLwb() const; float*GetMatrixArray(); const float*GetMatrixArray() const; virtual const char*TObject::GetName() const; Int_tGetNoElements() const; Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TVectorT<float>GetSub(Int_t row_lwb, Int_t row_upb, Option_t* option = ""S"") const; TVectorT<float>&GetSub(Int_t row_lwb, Int_t row_upb, TVectorT<float>& target, Option_t* option = ""S"") const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUn",MatchSource.WIKI,root/html532/TVectorT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVectorT_float_.html
https://root.cern/root/html532/TVectorT_float_.html:10545,Energy Efficiency,Allocate,Allocate,10545,"iner; float*fElements[fNrows] elements themselves; Bool_tfIsOwner!default kTRUE, when Use array kFALSE; Int_tfNrowsnumber of rows; Int_tfRowLwblower bound of the row index. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TVectorT<Element> Delete_m(Int_t size, float*& ); Delete data pointer m, if it was assigned on the heap. Element* TVectorT<Element> New_m(Int_t size); Return data pointer . if requested size <= kSizeMax, assign pointer; to the stack space. void TVectorT<Element> Add(const TVectorT<float>& v); Add vector v to this vector. void TVectorT<Element> Add(const TVectorT<float>& v1, const TVectorT<float>& v2); Set this vector to v1+v2. Int_t TVectorT<Element> Memcpy_m(float* newp, const float* oldp, Int_t copySize, Int_t newSize, Int_t oldSize); Copy copySize doubles from *oldp to *newp . However take care of the; situation where both pointers are assigned to the same stack space. void TVectorT<Element> Allocate(Int_t nrows, Int_t row_lwb = 0, Int_t init = 0); Allocate new vector. Arguments are number of rows and row; lowerbound (0 default). TVectorT<Element> &TVectorT<Element> ResizeTo(Int_t lwb, Int_t upb); Resize the vector to [lwb:upb] .; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleleted. TVectorT<Element> &TVectorT<Element> Use(Int_t lwb, Int_t upb, float* data); Use the array data to fill the vector lwb..upb]. TVectorT<Element> &TVectorT<Element> GetSub(Int_t row_lwb, Int_t row_upb, TVectorT<float>& target, Option_t* option = ""S"") const; Get subvector [row_lwb..row_upb]; The indexing range of the; returned vector depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb+1] (default); else : return [row_lwb..row_upb]. TVectorT<Element> &TVectorT<Element> SetSub(Int_t row_lwb, const TVectorT<float>& source); Insert vector source starting at [row_lwb], thereby overwriting the part; [row_lwb..row_lwb+",MatchSource.WIKI,root/html532/TVectorT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVectorT_float_.html
https://root.cern/root/html532/TVectorT_float_.html:10603,Energy Efficiency,Allocate,Allocate,10603,"iner; float*fElements[fNrows] elements themselves; Bool_tfIsOwner!default kTRUE, when Use array kFALSE; Int_tfNrowsnumber of rows; Int_tfRowLwblower bound of the row index. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TVectorT<Element> Delete_m(Int_t size, float*& ); Delete data pointer m, if it was assigned on the heap. Element* TVectorT<Element> New_m(Int_t size); Return data pointer . if requested size <= kSizeMax, assign pointer; to the stack space. void TVectorT<Element> Add(const TVectorT<float>& v); Add vector v to this vector. void TVectorT<Element> Add(const TVectorT<float>& v1, const TVectorT<float>& v2); Set this vector to v1+v2. Int_t TVectorT<Element> Memcpy_m(float* newp, const float* oldp, Int_t copySize, Int_t newSize, Int_t oldSize); Copy copySize doubles from *oldp to *newp . However take care of the; situation where both pointers are assigned to the same stack space. void TVectorT<Element> Allocate(Int_t nrows, Int_t row_lwb = 0, Int_t init = 0); Allocate new vector. Arguments are number of rows and row; lowerbound (0 default). TVectorT<Element> &TVectorT<Element> ResizeTo(Int_t lwb, Int_t upb); Resize the vector to [lwb:upb] .; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleleted. TVectorT<Element> &TVectorT<Element> Use(Int_t lwb, Int_t upb, float* data); Use the array data to fill the vector lwb..upb]. TVectorT<Element> &TVectorT<Element> GetSub(Int_t row_lwb, Int_t row_upb, TVectorT<float>& target, Option_t* option = ""S"") const; Get subvector [row_lwb..row_upb]; The indexing range of the; returned vector depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb+1] (default); else : return [row_lwb..row_upb]. TVectorT<Element> &TVectorT<Element> SetSub(Int_t row_lwb, const TVectorT<float>& source); Insert vector source starting at [row_lwb], thereby overwriting the part; [row_lwb..row_lwb+",MatchSource.WIKI,root/html532/TVectorT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVectorT_float_.html
https://root.cern/root/html532/TVectorT_float_.html:11265,Integrability,depend,depends,11265," vector to v1+v2. Int_t TVectorT<Element> Memcpy_m(float* newp, const float* oldp, Int_t copySize, Int_t newSize, Int_t oldSize); Copy copySize doubles from *oldp to *newp . However take care of the; situation where both pointers are assigned to the same stack space. void TVectorT<Element> Allocate(Int_t nrows, Int_t row_lwb = 0, Int_t init = 0); Allocate new vector. Arguments are number of rows and row; lowerbound (0 default). TVectorT<Element> &TVectorT<Element> ResizeTo(Int_t lwb, Int_t upb); Resize the vector to [lwb:upb] .; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleleted. TVectorT<Element> &TVectorT<Element> Use(Int_t lwb, Int_t upb, float* data); Use the array data to fill the vector lwb..upb]. TVectorT<Element> &TVectorT<Element> GetSub(Int_t row_lwb, Int_t row_upb, TVectorT<float>& target, Option_t* option = ""S"") const; Get subvector [row_lwb..row_upb]; The indexing range of the; returned vector depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb+1] (default); else : return [row_lwb..row_upb]. TVectorT<Element> &TVectorT<Element> SetSub(Int_t row_lwb, const TVectorT<float>& source); Insert vector source starting at [row_lwb], thereby overwriting the part; [row_lwb..row_lwb+nrows_source];. TVectorT<Element> &TVectorT<Element> Zero(); Set vector elements to zero. TVectorT<Element> &TVectorT<Element> Abs(); Take an absolute value of a vector, i.e. apply Abs() to each element. TVectorT<Element> &TVectorT<Element> Sqr(); Square each element of the vector. TVectorT<Element> &TVectorT<Element> Sqrt(); Take square root of all elements. TVectorT<Element> &TVectorT<Element> Invert(); v[i] = 1/v[i]. TVectorT<Element> &TVectorT<Element> SelectNonZeros(const TVectorT<float>& select); Keep only element as selected through array select non-zero. Element TVectorT<Element> Norm1() const; Compute the 1-norm of the vector SUM{ |v[i]| }. Element TVectorT<Element>",MatchSource.WIKI,root/html532/TVectorT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVectorT_float_.html
https://root.cern/root/html532/TVectorT_float_.html:4154,Modifiability,Inherit,InheritsFrom,4154,"TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetLwb() const; float*GetMatrixArray(); const float*GetMatrixArray() const; virtual const char*TObject::GetName() const; Int_tGetNoElements() const; Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TVectorT<float>GetSub(Int_t row_lwb, Int_t row_upb, Option_t* option = ""S"") const; TVectorT<float>&GetSub(Int_t row_lwb, Int_t row_upb, TVectorT<float>& target, Option_t* option = ""S"") const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Int_tGetUpb() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidInvalidate(); TVectorT<float>&Invert(); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tIsOwner() const; virtual Bool_tTObject::IsSortable() const; Bool_tIsValid() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidMakeValid(); Bool_tMatchesNonZeroPattern(const TVectorT<float>& select); floatMax() const; voidTObject::MayNotUse(const char* method) const; floatMin() const; Int_tNonZeros() const; floatNorm1() const; floatNorm2Sqr() const; floatNormInf() const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTOb",MatchSource.WIKI,root/html532/TVectorT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVectorT_float_.html
https://root.cern/root/html532/TVectorT_float_.html:4220,Modifiability,Inherit,InheritsFrom,4220,"bject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetLwb() const; float*GetMatrixArray(); const float*GetMatrixArray() const; virtual const char*TObject::GetName() const; Int_tGetNoElements() const; Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TVectorT<float>GetSub(Int_t row_lwb, Int_t row_upb, Option_t* option = ""S"") const; TVectorT<float>&GetSub(Int_t row_lwb, Int_t row_upb, TVectorT<float>& target, Option_t* option = ""S"") const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Int_tGetUpb() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidInvalidate(); TVectorT<float>&Invert(); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tIsOwner() const; virtual Bool_tTObject::IsSortable() const; Bool_tIsValid() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidMakeValid(); Bool_tMatchesNonZeroPattern(const TVectorT<float>& select); floatMax() const; voidTObject::MayNotUse(const char* method) const; floatMin() const; Int_tNonZeros() const; floatNorm1() const; floatNorm2Sqr() const; floatNormInf() const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::op",MatchSource.WIKI,root/html532/TVectorT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVectorT_float_.html
https://root.cern/root/html532/TVectorT_float_.html:9759,Modifiability,Inherit,Inheritance,9759,"nt_t bufsize = 0) const; TVectorT<float>&Zero(). protected:. voidAllocate(Int_t nrows, Int_t row_lwb = 0, Int_t init = 0); voidDelete_m(Int_t size, float*&); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); Int_tMemcpy_m(float* newp, const float* oldp, Int_t copySize, Int_t newSize, Int_t oldSize); float*New_m(Int_t size). Data Members; public:. enum { kSizeMax; kWorkMax; };; enum EVectorStatusBits { kStatus; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. floatfDataStack[5]! data container; float*fElements[fNrows] elements themselves; Bool_tfIsOwner!default kTRUE, when Use array kFALSE; Int_tfNrowsnumber of rows; Int_tfRowLwblower bound of the row index. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TVectorT<Element> Delete_m(Int_t size, float*& ); Delete data pointer m, if it was assigned on the heap. Element* TVectorT<Element> New_m(Int_t size); Return data pointer . if requested size <= kSizeMax, assign pointer; to the stack space. void TVectorT<Element> Add(const TVectorT<float>& v); Add vector v to this vector. void TVectorT<Element> Add(const TVectorT<float>& v1, const TVectorT<float>& v2); Set this vector to v1+v2. Int_t TVectorT<Element> Memcpy_m(float* newp, const float* oldp, Int_t copySize, Int_t newSize, Int_t oldSize); Copy copySize doubles from *oldp to *newp . However take care of the; situation where both pointers are assigned to the same stack space. void TVectorT<Element> Allocate(Int_t nrows, Int_t row_lwb = 0, Int_t init = 0); Allocate new vector. Arguments are number of rows and row; lowerbound (0 default). TVectorT<Element> &TVectorT<Element> ResizeTo(Int_t lwb, Int_t upb); Resize the vector to [lwb:upb]",MatchSource.WIKI,root/html532/TVectorT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVectorT_float_.html
https://root.cern/root/html532/TVectorT_float_.html:9772,Modifiability,Inherit,Inherited,9772,"nt_t bufsize = 0) const; TVectorT<float>&Zero(). protected:. voidAllocate(Int_t nrows, Int_t row_lwb = 0, Int_t init = 0); voidDelete_m(Int_t size, float*&); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); Int_tMemcpy_m(float* newp, const float* oldp, Int_t copySize, Int_t newSize, Int_t oldSize); float*New_m(Int_t size). Data Members; public:. enum { kSizeMax; kWorkMax; };; enum EVectorStatusBits { kStatus; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. floatfDataStack[5]! data container; float*fElements[fNrows] elements themselves; Bool_tfIsOwner!default kTRUE, when Use array kFALSE; Int_tfNrowsnumber of rows; Int_tfRowLwblower bound of the row index. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TVectorT<Element> Delete_m(Int_t size, float*& ); Delete data pointer m, if it was assigned on the heap. Element* TVectorT<Element> New_m(Int_t size); Return data pointer . if requested size <= kSizeMax, assign pointer; to the stack space. void TVectorT<Element> Add(const TVectorT<float>& v); Add vector v to this vector. void TVectorT<Element> Add(const TVectorT<float>& v1, const TVectorT<float>& v2); Set this vector to v1+v2. Int_t TVectorT<Element> Memcpy_m(float* newp, const float* oldp, Int_t copySize, Int_t newSize, Int_t oldSize); Copy copySize doubles from *oldp to *newp . However take care of the; situation where both pointers are assigned to the same stack space. void TVectorT<Element> Allocate(Int_t nrows, Int_t row_lwb = 0, Int_t init = 0); Allocate new vector. Arguments are number of rows and row; lowerbound (0 default). TVectorT<Element> &TVectorT<Element> ResizeTo(Int_t lwb, Int_t upb); Resize the vector to [lwb:upb]",MatchSource.WIKI,root/html532/TVectorT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVectorT_float_.html
https://root.cern/root/html532/TVectorT_float_.html:575,Safety,avoid,avoiding,575,". TVectorT<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TVectorT<float>. class TVectorT<float>: public TObject. TVectorT. Template class of Vectors in the linear algebra package. Unless otherwise specified, vector indices always start with 0,; spanning up to the specified limit-1. For (n) vectors where n <= kSizeMax (5 currently) storage space is; available on the stack, thus avoiding expensive allocation/; deallocation of heap space . However, this introduces of course; kSizeMax overhead for each vector object . If this is an issue; recompile with a new appropriate value (>=0) for kSizeMax. Another way to assign and store vector data is through Use; see for instance stressLinear.cxx file . Note that Constructors/assignments exists for all different matrix; views. For usage examples see $ROOTSYS/test/stressLinear.cxx. This class is also known as (typedefs to this class)TVectorT<Float_t>, TVectorF, TVector. Function Members (Methods); public:. TVectorT<float>(); TVectorT<float>(Int_t n); TVectorT<float>(const TVectorT<float>& another); TVectorT<float>(const TMatrixTRow_const<float>& mr); TVectorT<float>(const TMatrixTColumn_const<float>& mc); TVectorT<float>(const TMatrixTDiag_const<float>& md); TVectorT<float>(const TVectorT<double>& another); TVectorT<float>(Int_t lwb, Int_t upb); TVectorT<float>(Int_t n, const float* elements); TVectorT<float>(Int_t lwb, Int_t upb, const float* elements); virtual~TVectorT<float>(); TVectorT<float>&Abs(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TVectorT<float>& v); voidAdd(const TVectorT<float>& v1, const TVectorT<float>& v2); voidAddSomeConstant(float val, const TVectorT<float>& select); virtual voidTObject::AppendPad(Option_t* option = """"); TVectorT<float>&Apply(const TElementActionT<float>& action); TVectorT<",MatchSource.WIKI,root/html532/TVectorT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVectorT_float_.html
https://root.cern/root/html532/TVectorT_float_.html:4044,Security,Hash,Hash,4044,"* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetLwb() const; float*GetMatrixArray(); const float*GetMatrixArray() const; virtual const char*TObject::GetName() const; Int_tGetNoElements() const; Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TVectorT<float>GetSub(Int_t row_lwb, Int_t row_upb, Option_t* option = ""S"") const; TVectorT<float>&GetSub(Int_t row_lwb, Int_t row_upb, TVectorT<float>& target, Option_t* option = ""S"") const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Int_tGetUpb() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidInvalidate(); TVectorT<float>&Invert(); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tIsOwner() const; virtual Bool_tTObject::IsSortable() const; Bool_tIsValid() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidMakeValid(); Bool_tMatchesNonZeroPattern(const TVectorT<float>& select); floatMax() const; voidTObject::MayNotUse(const char* method) const; floatMin() const; Int_tNonZeros() const; floatNorm1() const; floatNorm2Sqr() const; floatNormInf() const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const ",MatchSource.WIKI,root/html532/TVectorT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVectorT_float_.html
https://root.cern/root/html532/TVectorT_float_.html:17321,Security,Access,Access,17321,"e current element is known. void TVectorT<Element> Draw(Option_t* option = """"); Draw this vector; The histogram is named ""TVectorT"" by default and no title. void TVectorT<Element> Print(Option_t* option = """") const; Print the vector as a list of elements. void TVectorT<Element> Streamer(TBuffer& b); Stream an object of class TVectorT. template<class Element> inline TVectorT<Element> &TVectorT<Element> Use(Int_t n, float* data); { return Use(0,n-1,data); }. template<class Element> inline const TVectorT<Element> &TVectorT<Element> Use(Int_t n, const float* data) const; { return Use(0,n-1,data); }. template<class Element> inline TVectorT<Element> &TVectorT<Element> Use(TVectorT<float>& v). template<class Element> inline const TVectorT<Element> &TVectorT<Element> Use(const TVectorT<float>& v) const. template<class Element> inline TVectorT<Element> TVectorT<Element> GetSub(Int_t row_lwb, Int_t row_upb, Option_t* option = ""S"") const. template<class Element> inline const Element &TVectorT<Element> operator()(Int_t ind) const; Access a vector element. template<class Element> inline Element &TVectorT<Element> operator()(Int_t ind); Access a vector element. Int_t GetLwb() const; { return fRowLwb; }. Int_t GetUpb() const; { return fNrows+fRowLwb-1; }. Int_t GetNrows() const; { return fNrows; }. Int_t GetNoElements() const; { return fNrows; }. Element * GetMatrixArray(); { return fElements; }. const Element * GetMatrixArray() const; { return fElements; }. void Invalidate(); { SetBit(kStatus); }. void MakeValid(); { ResetBit(kStatus); }. Bool_t IsValid() const; { return !TestBit(kStatus); }. Bool_t IsOwner() const; { return fIsOwner; }. void SetElements(const float* elements). TVectorT<Element> & Shift(Int_t row_shift); { fRowLwb += row_shift; return *this; }. TVectorT<Element> & ResizeTo(Int_t lwb, Int_t upb). TVectorT<Element> & ResizeTo(Int_t n); { return ResizeTo(0,n-1); }. TVectorT<Element> & Use(Int_t lwb, Int_t upb, float* data). const Element & operator[](Int_t index) co",MatchSource.WIKI,root/html532/TVectorT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVectorT_float_.html
https://root.cern/root/html532/TVectorT_float_.html:17427,Security,Access,Access,17427,"is named ""TVectorT"" by default and no title. void TVectorT<Element> Print(Option_t* option = """") const; Print the vector as a list of elements. void TVectorT<Element> Streamer(TBuffer& b); Stream an object of class TVectorT. template<class Element> inline TVectorT<Element> &TVectorT<Element> Use(Int_t n, float* data); { return Use(0,n-1,data); }. template<class Element> inline const TVectorT<Element> &TVectorT<Element> Use(Int_t n, const float* data) const; { return Use(0,n-1,data); }. template<class Element> inline TVectorT<Element> &TVectorT<Element> Use(TVectorT<float>& v). template<class Element> inline const TVectorT<Element> &TVectorT<Element> Use(const TVectorT<float>& v) const. template<class Element> inline TVectorT<Element> TVectorT<Element> GetSub(Int_t row_lwb, Int_t row_upb, Option_t* option = ""S"") const. template<class Element> inline const Element &TVectorT<Element> operator()(Int_t ind) const; Access a vector element. template<class Element> inline Element &TVectorT<Element> operator()(Int_t ind); Access a vector element. Int_t GetLwb() const; { return fRowLwb; }. Int_t GetUpb() const; { return fNrows+fRowLwb-1; }. Int_t GetNrows() const; { return fNrows; }. Int_t GetNoElements() const; { return fNrows; }. Element * GetMatrixArray(); { return fElements; }. const Element * GetMatrixArray() const; { return fElements; }. void Invalidate(); { SetBit(kStatus); }. void MakeValid(); { ResetBit(kStatus); }. Bool_t IsValid() const; { return !TestBit(kStatus); }. Bool_t IsOwner() const; { return fIsOwner; }. void SetElements(const float* elements). TVectorT<Element> & Shift(Int_t row_shift); { fRowLwb += row_shift; return *this; }. TVectorT<Element> & ResizeTo(Int_t lwb, Int_t upb). TVectorT<Element> & ResizeTo(Int_t n); { return ResizeTo(0,n-1); }. TVectorT<Element> & Use(Int_t lwb, Int_t upb, float* data). const Element & operator[](Int_t index) const; { return (*this)(index); }. Element & operator[](Int_t index); { return (*this)(index); }. void Clear(Optio",MatchSource.WIKI,root/html532/TVectorT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVectorT_float_.html
https://root.cern/root/html532/TVectorT_float_.html:1003,Testability,test,test,1003,". TVectorT<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TVectorT<float>. class TVectorT<float>: public TObject. TVectorT. Template class of Vectors in the linear algebra package. Unless otherwise specified, vector indices always start with 0,; spanning up to the specified limit-1. For (n) vectors where n <= kSizeMax (5 currently) storage space is; available on the stack, thus avoiding expensive allocation/; deallocation of heap space . However, this introduces of course; kSizeMax overhead for each vector object . If this is an issue; recompile with a new appropriate value (>=0) for kSizeMax. Another way to assign and store vector data is through Use; see for instance stressLinear.cxx file . Note that Constructors/assignments exists for all different matrix; views. For usage examples see $ROOTSYS/test/stressLinear.cxx. This class is also known as (typedefs to this class)TVectorT<Float_t>, TVectorF, TVector. Function Members (Methods); public:. TVectorT<float>(); TVectorT<float>(Int_t n); TVectorT<float>(const TVectorT<float>& another); TVectorT<float>(const TMatrixTRow_const<float>& mr); TVectorT<float>(const TMatrixTColumn_const<float>& mc); TVectorT<float>(const TMatrixTDiag_const<float>& md); TVectorT<float>(const TVectorT<double>& another); TVectorT<float>(Int_t lwb, Int_t upb); TVectorT<float>(Int_t n, const float* elements); TVectorT<float>(Int_t lwb, Int_t upb, const float* elements); virtual~TVectorT<float>(); TVectorT<float>&Abs(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TVectorT<float>& v); voidAdd(const TVectorT<float>& v1, const TVectorT<float>& v2); voidAddSomeConstant(float val, const TVectorT<float>& select); virtual voidTObject::AppendPad(Option_t* option = """"); TVectorT<float>&Apply(const TElementActionT<float>& action); TVectorT<",MatchSource.WIKI,root/html532/TVectorT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVectorT_float_.html
https://root.cern/root/html532/TVectorT_float_.html:8112,Testability,Test,TestBit,8112,"t alpha, float beta, Double_t& seed); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); TVectorT<float>&ResizeTo(Int_t n); TVectorT<float>&ResizeTo(const TVectorT<float>& v); TVectorT<float>&ResizeTo(Int_t lwb, Int_t upb); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TVectorT<float>&SelectNonZeros(const TVectorT<float>& select); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetElements(const float* elements); static voidTObject::SetObjectStat(Bool_t stat); TVectorT<float>&SetSub(Int_t row_lwb, const TVectorT<float>& source); virtual voidTObject::SetUniqueID(UInt_t uid); TVectorT<float>&Shift(Int_t row_shift); virtual voidShowMembers(TMemberInspector& insp); Bool_tSomePositive(const TVectorT<float>& select); TVectorT<float>&Sqr(); TVectorT<float>&Sqrt(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); floatSum() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TVectorT<float>&Use(TVectorT<float>& v); const TVectorT<float>&Use(const TVectorT<float>& v) const; TVectorT<float>&Use(Int_t n, float* data); const TVectorT<float>&Use(Int_t n, const float* data) const; TVectorT<float>&Use(Int_t lwb, Int_t upb, float* data); const TVectorT<float>&Use(Int_t lwb, Int_t upb, const float* data) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; TVectorT<float>&Zero().",MatchSource.WIKI,root/html532/TVectorT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVectorT_float_.html
https://root.cern/root/html532/TVectorT_float_.html:8151,Testability,Test,TestBits,8151,"t alpha, float beta, Double_t& seed); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); TVectorT<float>&ResizeTo(Int_t n); TVectorT<float>&ResizeTo(const TVectorT<float>& v); TVectorT<float>&ResizeTo(Int_t lwb, Int_t upb); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TVectorT<float>&SelectNonZeros(const TVectorT<float>& select); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetElements(const float* elements); static voidTObject::SetObjectStat(Bool_t stat); TVectorT<float>&SetSub(Int_t row_lwb, const TVectorT<float>& source); virtual voidTObject::SetUniqueID(UInt_t uid); TVectorT<float>&Shift(Int_t row_shift); virtual voidShowMembers(TMemberInspector& insp); Bool_tSomePositive(const TVectorT<float>& select); TVectorT<float>&Sqr(); TVectorT<float>&Sqrt(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); floatSum() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TVectorT<float>&Use(TVectorT<float>& v); const TVectorT<float>&Use(const TVectorT<float>& v) const; TVectorT<float>&Use(Int_t n, float* data); const TVectorT<float>&Use(Int_t n, const float* data) const; TVectorT<float>&Use(Int_t lwb, Int_t upb, float* data); const TVectorT<float>&Use(Int_t lwb, Int_t upb, const float* data) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; TVectorT<float>&Zero().",MatchSource.WIKI,root/html532/TVectorT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVectorT_float_.html
https://root.cern/root/html532/TVectorT_float_.html:17871,Testability,Test,TestBit,17871,"<Element> Use(Int_t n, float* data); { return Use(0,n-1,data); }. template<class Element> inline const TVectorT<Element> &TVectorT<Element> Use(Int_t n, const float* data) const; { return Use(0,n-1,data); }. template<class Element> inline TVectorT<Element> &TVectorT<Element> Use(TVectorT<float>& v). template<class Element> inline const TVectorT<Element> &TVectorT<Element> Use(const TVectorT<float>& v) const. template<class Element> inline TVectorT<Element> TVectorT<Element> GetSub(Int_t row_lwb, Int_t row_upb, Option_t* option = ""S"") const. template<class Element> inline const Element &TVectorT<Element> operator()(Int_t ind) const; Access a vector element. template<class Element> inline Element &TVectorT<Element> operator()(Int_t ind); Access a vector element. Int_t GetLwb() const; { return fRowLwb; }. Int_t GetUpb() const; { return fNrows+fRowLwb-1; }. Int_t GetNrows() const; { return fNrows; }. Int_t GetNoElements() const; { return fNrows; }. Element * GetMatrixArray(); { return fElements; }. const Element * GetMatrixArray() const; { return fElements; }. void Invalidate(); { SetBit(kStatus); }. void MakeValid(); { ResetBit(kStatus); }. Bool_t IsValid() const; { return !TestBit(kStatus); }. Bool_t IsOwner() const; { return fIsOwner; }. void SetElements(const float* elements). TVectorT<Element> & Shift(Int_t row_shift); { fRowLwb += row_shift; return *this; }. TVectorT<Element> & ResizeTo(Int_t lwb, Int_t upb). TVectorT<Element> & ResizeTo(Int_t n); { return ResizeTo(0,n-1); }. TVectorT<Element> & Use(Int_t lwb, Int_t upb, float* data). const Element & operator[](Int_t index) const; { return (*this)(index); }. Element & operator[](Int_t index); { return (*this)(index); }. void Clear(Option_t* = """"). » Last changed: root/matrix:$Id: TVectorT.h 39086 2011-05-04 09:36:17Z moneta $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TVectorT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVectorT_float_.html
https://root.cern/root/html532/TVectorT_float_.html:18387,Usability,Clear,Clear,18387,"<Element> Use(Int_t n, float* data); { return Use(0,n-1,data); }. template<class Element> inline const TVectorT<Element> &TVectorT<Element> Use(Int_t n, const float* data) const; { return Use(0,n-1,data); }. template<class Element> inline TVectorT<Element> &TVectorT<Element> Use(TVectorT<float>& v). template<class Element> inline const TVectorT<Element> &TVectorT<Element> Use(const TVectorT<float>& v) const. template<class Element> inline TVectorT<Element> TVectorT<Element> GetSub(Int_t row_lwb, Int_t row_upb, Option_t* option = ""S"") const. template<class Element> inline const Element &TVectorT<Element> operator()(Int_t ind) const; Access a vector element. template<class Element> inline Element &TVectorT<Element> operator()(Int_t ind); Access a vector element. Int_t GetLwb() const; { return fRowLwb; }. Int_t GetUpb() const; { return fNrows+fRowLwb-1; }. Int_t GetNrows() const; { return fNrows; }. Int_t GetNoElements() const; { return fNrows; }. Element * GetMatrixArray(); { return fElements; }. const Element * GetMatrixArray() const; { return fElements; }. void Invalidate(); { SetBit(kStatus); }. void MakeValid(); { ResetBit(kStatus); }. Bool_t IsValid() const; { return !TestBit(kStatus); }. Bool_t IsOwner() const; { return fIsOwner; }. void SetElements(const float* elements). TVectorT<Element> & Shift(Int_t row_shift); { fRowLwb += row_shift; return *this; }. TVectorT<Element> & ResizeTo(Int_t lwb, Int_t upb). TVectorT<Element> & ResizeTo(Int_t n); { return ResizeTo(0,n-1); }. TVectorT<Element> & Use(Int_t lwb, Int_t upb, float* data). const Element & operator[](Int_t index) const; { return (*this)(index); }. Element & operator[](Int_t index); { return (*this)(index); }. void Clear(Option_t* = """"). » Last changed: root/matrix:$Id: TVectorT.h 39086 2011-05-04 09:36:17Z moneta $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TVectorT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVectorT_float_.html
https://root.cern/root/html532/TView.html:444,Availability,avail,available,444,". TView. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GPAD; » TView. class TView: public TObject, public TAttLine. See TView3D; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TView(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdjustScales(TVirtualPad* pad = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidAxisVertex(Double_t ang, Double_t* av, Int_t& ix1, Int_t& ix2, Int_t& iy1, Int_t& iy2, Int_t& iz1, Int_t& iz2); virtual voidTObject::Browse(TBrowser* b); virtual voidCentered(); virtual voidCentered3DImages(TVirtualPad* pad = 0); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static TView*CreateView(Int_t system = 1, const Double_t* rmin = 0, const Double_t* rmax = 0); virtual voidDefinePerspectiveView(); virtual voidDefineViewDirection(const Double_t* s, const Double_t* c, Double_t cosphi, Double_t sinphi, Double_t costhe, Double_t sinthe, Double_t cospsi, Double_t sinpsi, Double_t* tnorm, Double_t* tback); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawOutlineCube(TList* outline, Double_t* rmin, Double_t* rmax); virtual voidT",MatchSource.WIKI,root/html532/TView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TView.html
https://root.cern/root/html532/TView.html:2049,Availability,Error,Error,2049,"newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static TView*CreateView(Int_t system = 1, const Double_t* rmin = 0, const Double_t* rmax = 0); virtual voidDefinePerspectiveView(); virtual voidDefineViewDirection(const Double_t* s, const Double_t* c, Double_t cosphi, Double_t sinphi, Double_t costhe, Double_t sinthe, Double_t cospsi, Double_t sinpsi, Double_t* tnorm, Double_t* tback); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawOutlineCube(TList* outline, Double_t* rmin, Double_t* rmax); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExecuteRotateView(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFindNormal(Double_t x, Double_t y, Double_t z, Double_t& zn); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFindPhiSectors(Int_t iopt, Int_t& kphi, Double_t* aphi, Int_t& iphi1, Int_t& iphi2); virtual voidFindScope(Double_t* scale, Double_t* center, Int_t& irep); virtual voidFindThetaSectors(Int_t iopt, Double_t phi, Int_t& kth, Double_t* ath, Int_t& ith1, Int_t& ith2); virtual voidFront(); virtual voidFrontView(TVirtualPad* pad = 0); virtual Bool_tGetAutoRange(); virtual In",MatchSource.WIKI,root/html532/TView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TView.html
https://root.cern/root/html532/TView.html:2178,Availability,error,error,2178,"tatic TView*CreateView(Int_t system = 1, const Double_t* rmin = 0, const Double_t* rmax = 0); virtual voidDefinePerspectiveView(); virtual voidDefineViewDirection(const Double_t* s, const Double_t* c, Double_t cosphi, Double_t sinphi, Double_t costhe, Double_t sinthe, Double_t cospsi, Double_t sinpsi, Double_t* tnorm, Double_t* tback); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawOutlineCube(TList* outline, Double_t* rmin, Double_t* rmax); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExecuteRotateView(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFindNormal(Double_t x, Double_t y, Double_t z, Double_t& zn); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFindPhiSectors(Int_t iopt, Int_t& kphi, Double_t* aphi, Int_t& iphi1, Int_t& iphi2); virtual voidFindScope(Double_t* scale, Double_t* center, Int_t& irep); virtual voidFindThetaSectors(Int_t iopt, Double_t phi, Int_t& kth, Double_t* ath, Int_t& ith1, Int_t& ith2); virtual voidFront(); virtual voidFrontView(TVirtualPad* pad = 0); virtual Bool_tGetAutoRange(); virtual Int_tGetDistancetoAxis(Int_t axis, Int_t px, Int_t py, Double_t& ratio); virtual Double_tGetDproj() const; virtual Option_t*TObject",MatchSource.WIKI,root/html532/TView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TView.html
https://root.cern/root/html532/TView.html:2262,Availability,error,error,2262,"max = 0); virtual voidDefinePerspectiveView(); virtual voidDefineViewDirection(const Double_t* s, const Double_t* c, Double_t cosphi, Double_t sinphi, Double_t costhe, Double_t sinthe, Double_t cospsi, Double_t sinpsi, Double_t* tnorm, Double_t* tback); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawOutlineCube(TList* outline, Double_t* rmin, Double_t* rmax); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExecuteRotateView(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFindNormal(Double_t x, Double_t y, Double_t z, Double_t& zn); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFindPhiSectors(Int_t iopt, Int_t& kphi, Double_t* aphi, Int_t& iphi1, Int_t& iphi2); virtual voidFindScope(Double_t* scale, Double_t* center, Int_t& irep); virtual voidFindThetaSectors(Int_t iopt, Double_t phi, Int_t& kth, Double_t* ath, Int_t& ith1, Int_t& ith2); virtual voidFront(); virtual voidFrontView(TVirtualPad* pad = 0); virtual Bool_tGetAutoRange(); virtual Int_tGetDistancetoAxis(Int_t axis, Int_t px, Int_t py, Double_t& ratio); virtual Double_tGetDproj() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tGetDvi",MatchSource.WIKI,root/html532/TView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TView.html
https://root.cern/root/html532/TView.html:13777,Deployability,Toggle,ToggleRulers,13777,"y2, const Double_t* z1, const Double_t* z2). void SetDefaultWindow(). void SetDview(Double_t dview). void SetDproj(Double_t dproj). void SetLatitude(Double_t latitude). void SetLongitude(Double_t longitude). void SetPsi(Double_t psi). void SetOutlineToCube(). void SetParallel(). void SetPerspective(). void SetRange(const Double_t* min, const Double_t* max). void SetRange(Double_t x0, Double_t y0, Double_t z0, Double_t x1, Double_t y1, Double_t z1, Int_t flag = 0). void SetSystem(Int_t system). void SetView(Double_t longitude, Double_t latitude, Double_t psi, Int_t& irep). void SetViewChanged(Bool_t flag = kTRUE). void SetWindow(Double_t u0, Double_t v0, Double_t du, Double_t dv). void WCtoNDC(const Float_t* pw, Float_t* pn). void WCtoNDC(const Double_t* pw, Double_t* pn). void MoveFocus(Double_t* center, Double_t dx, Double_t dy, Double_t dz, Int_t nsteps = 10, Double_t dlong = 0, Double_t dlat = 0, Double_t dpsi = 0); --. void MoveWindow(Char_t option). void AdjustScales(TVirtualPad* pad = 0). void Centered3DImages(TVirtualPad* pad = 0). void Centered(). void FrontView(TVirtualPad* pad = 0). void Front(). void ZoomIn(). void ZoomOut(). void ZoomView(TVirtualPad* pad = 0, Double_t zoomFactor = 1.25). void UnzoomView(TVirtualPad* pad = 0, Double_t unZoomFactor = 1.25). void RotateView(Double_t phi, Double_t theta, TVirtualPad* pad = 0). void SideView(TVirtualPad* pad = 0). void Side(). void TopView(TVirtualPad* pad = 0). void Top(). void ToggleRulers(TVirtualPad* pad = 0). void ShowAxis(). void ToggleZoom(TVirtualPad* pad = 0). void ZoomMove(). void Zoom(). void UnZoom(). » Author: Rene Brun, Nenad Buncic, Evgueni Tcherniaev, Olivier Couet 18/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gpad:$Id: TView.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TView.html
https://root.cern/root/html532/TView.html:13835,Deployability,Toggle,ToggleZoom,13835,"y2, const Double_t* z1, const Double_t* z2). void SetDefaultWindow(). void SetDview(Double_t dview). void SetDproj(Double_t dproj). void SetLatitude(Double_t latitude). void SetLongitude(Double_t longitude). void SetPsi(Double_t psi). void SetOutlineToCube(). void SetParallel(). void SetPerspective(). void SetRange(const Double_t* min, const Double_t* max). void SetRange(Double_t x0, Double_t y0, Double_t z0, Double_t x1, Double_t y1, Double_t z1, Int_t flag = 0). void SetSystem(Int_t system). void SetView(Double_t longitude, Double_t latitude, Double_t psi, Int_t& irep). void SetViewChanged(Bool_t flag = kTRUE). void SetWindow(Double_t u0, Double_t v0, Double_t du, Double_t dv). void WCtoNDC(const Float_t* pw, Float_t* pn). void WCtoNDC(const Double_t* pw, Double_t* pn). void MoveFocus(Double_t* center, Double_t dx, Double_t dy, Double_t dz, Int_t nsteps = 10, Double_t dlong = 0, Double_t dlat = 0, Double_t dpsi = 0); --. void MoveWindow(Char_t option). void AdjustScales(TVirtualPad* pad = 0). void Centered3DImages(TVirtualPad* pad = 0). void Centered(). void FrontView(TVirtualPad* pad = 0). void Front(). void ZoomIn(). void ZoomOut(). void ZoomView(TVirtualPad* pad = 0, Double_t zoomFactor = 1.25). void UnzoomView(TVirtualPad* pad = 0, Double_t unZoomFactor = 1.25). void RotateView(Double_t phi, Double_t theta, TVirtualPad* pad = 0). void SideView(TVirtualPad* pad = 0). void Side(). void TopView(TVirtualPad* pad = 0). void Top(). void ToggleRulers(TVirtualPad* pad = 0). void ShowAxis(). void ToggleZoom(TVirtualPad* pad = 0). void ZoomMove(). void Zoom(). void UnZoom(). » Author: Rene Brun, Nenad Buncic, Evgueni Tcherniaev, Olivier Couet 18/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gpad:$Id: TView.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TView.html
https://root.cern/root/html532/TView.html:4529,Modifiability,Inherit,InheritsFrom,4529,"rtual Double_tGetLongitude(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TSeqCollection*GetOutline(); virtual Double_tGetPsi(); virtual voidGetRange(Float_t* min, Float_t* max); virtual voidGetRange(Double_t* min, Double_t* max); virtual Double_t*GetRmax(); virtual Double_t*GetRmin(); virtual Int_tGetSystem(); virtual Double_t*GetTback(); virtual const char*TObject::GetTitle() const; virtual Double_t*GetTN(); virtual Double_t*GetTnorm(); virtual UInt_tTObject::GetUniqueID() const; virtual voidGetWindow(Double_t& u0, Double_t& v0, Double_t& du, Double_t& dv) const; virtual Double_tGetWindowHeight() const; virtual Double_tGetWindowWidth() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tIsClippedNDC(Double_t* p) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsPerspective() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tIsViewChanged() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttLine::Modify(); virtual voidMoveFocus(Double_t* center, Double_t dx, Double_t dy, Double_t dz, Int_t nsteps = 10, Double_t dlong = 0, Double_t dlat = 0, Double_t dpsi = 0); virtual voidMoveViewCommand(Char_t chCode, Int_t count = 1); virtual voidMoveWindow(Char_t option); virtual voidNDCtoWC(const Float_t* pn, Float_t* pw); virtual voidNDCtoWC(con",MatchSource.WIKI,root/html532/TView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TView.html
https://root.cern/root/html532/TView.html:4595,Modifiability,Inherit,InheritsFrom,4595,") const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TSeqCollection*GetOutline(); virtual Double_tGetPsi(); virtual voidGetRange(Float_t* min, Float_t* max); virtual voidGetRange(Double_t* min, Double_t* max); virtual Double_t*GetRmax(); virtual Double_t*GetRmin(); virtual Int_tGetSystem(); virtual Double_t*GetTback(); virtual const char*TObject::GetTitle() const; virtual Double_t*GetTN(); virtual Double_t*GetTnorm(); virtual UInt_tTObject::GetUniqueID() const; virtual voidGetWindow(Double_t& u0, Double_t& v0, Double_t& du, Double_t& dv) const; virtual Double_tGetWindowHeight() const; virtual Double_tGetWindowWidth() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tIsClippedNDC(Double_t* p) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsPerspective() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tIsViewChanged() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttLine::Modify(); virtual voidMoveFocus(Double_t* center, Double_t dx, Double_t dy, Double_t dz, Int_t nsteps = 10, Double_t dlong = 0, Double_t dlat = 0, Double_t dpsi = 0); virtual voidMoveViewCommand(Char_t chCode, Int_t count = 1); virtual voidMoveWindow(Char_t option); virtual voidNDCtoWC(const Float_t* pn, Float_t* pw); virtual voidNDCtoWC(const Double_t* pn, Double_t* pw); virtual voidNormalWCtoNDC(const Fl",MatchSource.WIKI,root/html532/TView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TView.html
https://root.cern/root/html532/TView.html:10165,Modifiability,Inherit,Inheritance,10165,"t* pw, Float_t* pn); virtual voidWCtoNDC(const Double_t* pw, Double_t* pn); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidZoom(); virtual voidZoomIn(); virtual voidZoomMove(); virtual voidZoomOut(); virtual voidZoomView(TVirtualPad* pad = 0, Double_t zoomFactor = 1.25). protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TView * CreateView(Int_t system = 1, const Double_t* rmin = 0, const Double_t* rmax = 0); Create a concrete default 3-d view via the plug-in manager. virtual ~TView(); {}. void DefinePerspectiveView(). void AxisVertex(Double_t ang, Double_t* av, Int_t& ix1, Int_t& ix2, Int_t& iy1, Int_t& iy2, Int_t& iz1, Int_t& iz2). void DefineViewDirection(const Double_t* s, const Double_t* c, Double_t cosphi, Double_t sinphi, Double_t costhe, Double_t sinthe, Double_t cospsi, Double_t sinpsi, Double_t* tnorm, Double_t* tback). void ExecuteEvent(Int_t event, Int_t px, Int_t py). void ExecuteRotateView(Int_t event, Int_t px, Int_t py). void FindScope(Double_t* scale, Double_t* center, Int_t& irep). Int_t GetDistancetoAxis(Int_t axis, Int_t px, Int_t py, Double_t& ratio). Double_t GetDview() const. Double_t GetDproj() const. Double_t GetExtent() const. Bool_t GetAutoRange(). Double_t GetLatitude(). Double_t GetLongitude(). Double_t GetPsi(). void GetRa",MatchSource.WIKI,root/html532/TView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TView.html
https://root.cern/root/html532/TView.html:10178,Modifiability,Inherit,Inherited,10178,"t* pw, Float_t* pn); virtual voidWCtoNDC(const Double_t* pw, Double_t* pn); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidZoom(); virtual voidZoomIn(); virtual voidZoomMove(); virtual voidZoomOut(); virtual voidZoomView(TVirtualPad* pad = 0, Double_t zoomFactor = 1.25). protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TView * CreateView(Int_t system = 1, const Double_t* rmin = 0, const Double_t* rmax = 0); Create a concrete default 3-d view via the plug-in manager. virtual ~TView(); {}. void DefinePerspectiveView(). void AxisVertex(Double_t ang, Double_t* av, Int_t& ix1, Int_t& ix2, Int_t& iy1, Int_t& iy2, Int_t& iz1, Int_t& iz2). void DefineViewDirection(const Double_t* s, const Double_t* c, Double_t cosphi, Double_t sinphi, Double_t costhe, Double_t sinthe, Double_t cospsi, Double_t sinpsi, Double_t* tnorm, Double_t* tback). void ExecuteEvent(Int_t event, Int_t px, Int_t py). void ExecuteRotateView(Int_t event, Int_t px, Int_t py). void FindScope(Double_t* scale, Double_t* center, Int_t& irep). Int_t GetDistancetoAxis(Int_t axis, Int_t px, Int_t py, Double_t& ratio). Double_t GetDview() const. Double_t GetDproj() const. Double_t GetExtent() const. Bool_t GetAutoRange(). Double_t GetLatitude(). Double_t GetLongitude(). Double_t GetPsi(). void GetRa",MatchSource.WIKI,root/html532/TView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TView.html
https://root.cern/root/html532/TView.html:10375,Modifiability,plug-in,plug-in,10375,"* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidZoom(); virtual voidZoomIn(); virtual voidZoomMove(); virtual voidZoomOut(); virtual voidZoomView(TVirtualPad* pad = 0, Double_t zoomFactor = 1.25). protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TView * CreateView(Int_t system = 1, const Double_t* rmin = 0, const Double_t* rmax = 0); Create a concrete default 3-d view via the plug-in manager. virtual ~TView(); {}. void DefinePerspectiveView(). void AxisVertex(Double_t ang, Double_t* av, Int_t& ix1, Int_t& ix2, Int_t& iy1, Int_t& iy2, Int_t& iz1, Int_t& iz2). void DefineViewDirection(const Double_t* s, const Double_t* c, Double_t cosphi, Double_t sinphi, Double_t costhe, Double_t sinthe, Double_t cospsi, Double_t sinpsi, Double_t* tnorm, Double_t* tback). void ExecuteEvent(Int_t event, Int_t px, Int_t py). void ExecuteRotateView(Int_t event, Int_t px, Int_t py). void FindScope(Double_t* scale, Double_t* center, Int_t& irep). Int_t GetDistancetoAxis(Int_t axis, Int_t px, Int_t py, Double_t& ratio). Double_t GetDview() const. Double_t GetDproj() const. Double_t GetExtent() const. Bool_t GetAutoRange(). Double_t GetLatitude(). Double_t GetLongitude(). Double_t GetPsi(). void GetRange(Float_t* min, Float_t* max). void GetRange(Double_t* min, Double_t* max). Double_t * GetRmax(). Double_t * Ge",MatchSource.WIKI,root/html532/TView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TView.html
https://root.cern/root/html532/TView.html:4419,Security,Hash,Hash,4419,"ineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Double_tGetLongitude(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TSeqCollection*GetOutline(); virtual Double_tGetPsi(); virtual voidGetRange(Float_t* min, Float_t* max); virtual voidGetRange(Double_t* min, Double_t* max); virtual Double_t*GetRmax(); virtual Double_t*GetRmin(); virtual Int_tGetSystem(); virtual Double_t*GetTback(); virtual const char*TObject::GetTitle() const; virtual Double_t*GetTN(); virtual Double_t*GetTnorm(); virtual UInt_tTObject::GetUniqueID() const; virtual voidGetWindow(Double_t& u0, Double_t& v0, Double_t& du, Double_t& dv) const; virtual Double_tGetWindowHeight() const; virtual Double_tGetWindowWidth() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tIsClippedNDC(Double_t* p) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsPerspective() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tIsViewChanged() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttLine::Modify(); virtual voidMoveFocus(Double_t* center, Double_t dx, Double_t dy, Double_t dz, Int_t nsteps = 10, Double_t dlong = 0, Double_t dlat = 0, Double_t dpsi = 0); virtual voidMoveViewCommand(Char_t chCode, Int_t count = 1); v",MatchSource.WIKI,root/html532/TView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TView.html
https://root.cern/root/html532/TView.html:8723,Testability,Test,TestBit,8723,"orange = kTRUE); virtual voidSetAxisNDC(const Double_t* x1, const Double_t* x2, const Double_t* y1, const Double_t* y2, const Double_t* z1, const Double_t* z2); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetDefaultWindow(); virtual voidSetDproj(Double_t dproj); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetDview(Double_t dview); virtual voidSetLatitude(Double_t latitude); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidSetLongitude(Double_t longitude); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOutlineToCube(); virtual voidSetParallel(); virtual voidSetPerspective(); virtual voidSetPsi(Double_t psi); virtual voidSetRange(const Double_t* min, const Double_t* max); virtual voidSetRange(Double_t x0, Double_t y0, Double_t z0, Double_t x1, Double_t y1, Double_t z1, Int_t flag = 0); virtual voidSetSystem(Int_t system); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetView(Double_t longitude, Double_t latitude, Double_t psi, Int_t& irep); virtual voidSetViewChanged(Bool_t flag = kTRUE); virtual voidSetWindow(Double_t u0, Double_t v0, Double_t du, Double_t dv); virtual voidShowAxis(); virtual voidShowMembers(TMemberInspector& insp); virtual voidSide(); virtual voidSideView(TVirtualPad* pad = 0); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidToggleRulers(TVirtualPad* pad = 0); virtual voidToggleZoom(TVirtualPad* pad = 0); virtual voidTop(); virtual voidTopView(TVirtualPad* pad = 0); virtual voidUnZoom(); virtual voidUnzoomView(TVirtualPad* pad = 0, Double_t unZoomFactor = 1.",MatchSource.WIKI,root/html532/TView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TView.html
https://root.cern/root/html532/TView.html:8762,Testability,Test,TestBits,8762,"orange = kTRUE); virtual voidSetAxisNDC(const Double_t* x1, const Double_t* x2, const Double_t* y1, const Double_t* y2, const Double_t* z1, const Double_t* z2); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetDefaultWindow(); virtual voidSetDproj(Double_t dproj); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetDview(Double_t dview); virtual voidSetLatitude(Double_t latitude); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidSetLongitude(Double_t longitude); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOutlineToCube(); virtual voidSetParallel(); virtual voidSetPerspective(); virtual voidSetPsi(Double_t psi); virtual voidSetRange(const Double_t* min, const Double_t* max); virtual voidSetRange(Double_t x0, Double_t y0, Double_t z0, Double_t x1, Double_t y1, Double_t z1, Int_t flag = 0); virtual voidSetSystem(Int_t system); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetView(Double_t longitude, Double_t latitude, Double_t psi, Int_t& irep); virtual voidSetViewChanged(Bool_t flag = kTRUE); virtual voidSetWindow(Double_t u0, Double_t v0, Double_t du, Double_t dv); virtual voidShowAxis(); virtual voidShowMembers(TMemberInspector& insp); virtual voidSide(); virtual voidSideView(TVirtualPad* pad = 0); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidToggleRulers(TVirtualPad* pad = 0); virtual voidToggleZoom(TVirtualPad* pad = 0); virtual voidTop(); virtual voidTopView(TVirtualPad* pad = 0); virtual voidUnZoom(); virtual voidUnzoomView(TVirtualPad* pad = 0, Double_t unZoomFactor = 1.",MatchSource.WIKI,root/html532/TView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TView.html
https://root.cern/root/html532/TView.html:986,Usability,Clear,Clear,986," virtual~TView(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdjustScales(TVirtualPad* pad = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidAxisVertex(Double_t ang, Double_t* av, Int_t& ix1, Int_t& ix2, Int_t& iy1, Int_t& iy2, Int_t& iz1, Int_t& iz2); virtual voidTObject::Browse(TBrowser* b); virtual voidCentered(); virtual voidCentered3DImages(TVirtualPad* pad = 0); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static TView*CreateView(Int_t system = 1, const Double_t* rmin = 0, const Double_t* rmax = 0); virtual voidDefinePerspectiveView(); virtual voidDefineViewDirection(const Double_t* s, const Double_t* c, Double_t cosphi, Double_t sinphi, Double_t costhe, Double_t sinthe, Double_t cospsi, Double_t sinpsi, Double_t* tnorm, Double_t* tback); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawOutlineCube(TList* outline, Double_t* rmin, Double_t* rmax); virtual voidT",MatchSource.WIKI,root/html532/TView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TView.html
https://root.cern/root/html532/TView3D.html:1075,Availability,avail,available,1075,"rchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » TView3D. class TView3D: public TView. The 3D view class; This package was originally written by Evgueni Tcherniaev from IHEP/Protvino. The original Fortran implementation was adapted to HIGZ/PAW by Olivier Couet and; Evgueni Tcherniaev. This View class is a subset of the original system. It has been converted to a; C++ class by Rene Brun. TView3D creates a 3-D view in the current pad. In this 3D view Lego and Surface; plots can be drawn and also 3D polyline and markers. Most of the time a TView3D; is created automatically when a 3D object needs to be painted in a pad (for; instance a Lego or a Surface plot). In some case a TView3D should be explicitly. For instance to paint a 3D simple; scene composed of simple objects like polylines and polymarkers.; The following macro gives an example:. Several coordinate systems are available:. Cartesian; Polar; Cylindrical; Spherical; PseudoRapidity/Phi. . Function Members (Methods); public:. TView3D(); TView3D(Int_t system, const Double_t* rmin, const Double_t* rmax); virtual~TView3D(); voidTObject::AbstractMethod(const char* method) const; static voidAdjustPad(TVirtualPad* pad = 0); virtual voidAdjustScales(TVirtualPad* pad = 0)MENU ; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidAxisVertex(Double_t ang, Double_t* av, Int_t& ix1, Int_t& ix2, Int_t& iy1, Int_t& iy2, Int_t& iz1, Int_t& iz2); virtual voidTObject::Browse(TBrowser* b); virtual voidCentered()MENU ; virtual voidCentered3DImages(TVirtualPad* pad = 0); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static TView*TView::CreateView(Int_t syst",MatchSource.WIKI,root/html532/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TView3D.html
https://root.cern/root/html532/TView3D.html:2900,Availability,Error,Error,2900," = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static TView*TView::CreateView(Int_t system = 1, const Double_t* rmin = 0, const Double_t* rmax = 0); virtual voidDefinePerspectiveView(); virtual voidDefineViewDirection(const Double_t* s, const Double_t* c, Double_t cosphi, Double_t sinphi, Double_t costhe, Double_t sinthe, Double_t cospsi, Double_t sinpsi, Double_t* tnorm, Double_t* tback); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawOutlineCube(TList* outline, Double_t* rmin, Double_t* rmax); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExecuteRotateView(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFindNormal(Double_t x, Double_t y, Double_t z, Double_t& zn); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFindPhiSectors(Int_t iopt, Int_t& kphi, Double_t* aphi, Int_t& iphi1, Int_t& iphi2); virtual voidFindScope(Double_t* scale, Double_t* center, Int_t& irep); virtual voidFindThetaSectors(Int_t iopt, Double_t phi, Int_t& kth, Double_t* ath, Int_t& ith1, Int_t& ith2); virtual voidFront()MENU ; virtual voidFrontView(TVirtualPad* pad = 0); virtual Bool_tGetAutoRange(); virtu",MatchSource.WIKI,root/html532/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TView3D.html
https://root.cern/root/html532/TView3D.html:3029,Availability,error,error,3029,"View*TView::CreateView(Int_t system = 1, const Double_t* rmin = 0, const Double_t* rmax = 0); virtual voidDefinePerspectiveView(); virtual voidDefineViewDirection(const Double_t* s, const Double_t* c, Double_t cosphi, Double_t sinphi, Double_t costhe, Double_t sinthe, Double_t cospsi, Double_t sinpsi, Double_t* tnorm, Double_t* tback); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawOutlineCube(TList* outline, Double_t* rmin, Double_t* rmax); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExecuteRotateView(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFindNormal(Double_t x, Double_t y, Double_t z, Double_t& zn); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFindPhiSectors(Int_t iopt, Int_t& kphi, Double_t* aphi, Int_t& iphi1, Int_t& iphi2); virtual voidFindScope(Double_t* scale, Double_t* center, Int_t& irep); virtual voidFindThetaSectors(Int_t iopt, Double_t phi, Int_t& kth, Double_t* ath, Int_t& ith1, Int_t& ith2); virtual voidFront()MENU ; virtual voidFrontView(TVirtualPad* pad = 0); virtual Bool_tGetAutoRange(); virtual Int_tGetDistancetoAxis(Int_t axis, Int_t px, Int_t py, Double_t& ratio); virtual Double_tGetDproj() const; virtual Option_t*TO",MatchSource.WIKI,root/html532/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TView3D.html
https://root.cern/root/html532/TView3D.html:3113,Availability,error,error,3113,"max = 0); virtual voidDefinePerspectiveView(); virtual voidDefineViewDirection(const Double_t* s, const Double_t* c, Double_t cosphi, Double_t sinphi, Double_t costhe, Double_t sinthe, Double_t cospsi, Double_t sinpsi, Double_t* tnorm, Double_t* tback); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawOutlineCube(TList* outline, Double_t* rmin, Double_t* rmax); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExecuteRotateView(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFindNormal(Double_t x, Double_t y, Double_t z, Double_t& zn); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFindPhiSectors(Int_t iopt, Int_t& kphi, Double_t* aphi, Int_t& iphi1, Int_t& iphi2); virtual voidFindScope(Double_t* scale, Double_t* center, Int_t& irep); virtual voidFindThetaSectors(Int_t iopt, Double_t phi, Int_t& kth, Double_t* ath, Int_t& ith1, Int_t& ith2); virtual voidFront()MENU ; virtual voidFrontView(TVirtualPad* pad = 0); virtual Bool_tGetAutoRange(); virtual Int_tGetDistancetoAxis(Int_t axis, Int_t px, Int_t py, Double_t& ratio); virtual Double_tGetDproj() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tG",MatchSource.WIKI,root/html532/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TView3D.html
https://root.cern/root/html532/TView3D.html:15650,Availability,down,down,15650,"costhe, Double_t sinthe, Double_t cospsi, Double_t sinpsi, Double_t* tnorm, Double_t* tback); Define view direction (in spherical coordinates). Compute transformation matrix from world coordinates; to normalised coordinates (-1 to +1). Input: S(3) - scale factors; C(3) - centre of scope; COSPHI - longitude COS; SINPHI - longitude SIN; COSTHE - latitude COS (angle between +Z and view direc.); SINTHE - latitude SIN; COSPSI - screen plane rotation angle COS; SINPSI - screen plane rotation angle SIN. void DrawOutlineCube(TList* outline, Double_t* rmin, Double_t* rmax); Draw the outline of a cube while rotating a 3-d object in the pad. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. void ExecuteRotateView(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function is called when a object is clicked with the locator. If Left button clicked in the object area, while the button is kept down; the cube representing the surrounding frame for the corresponding; new latitude and longitude position is drawn. void FindNormal(Double_t x, Double_t y, Double_t z, Double_t& zn); Find Z component of NORMAL in normalized coordinates. Input: X - X-component of NORMAL; Y - Y-component of NORMAL; Z - Z-component of NORMAL. Output: ZN - Z-component of NORMAL in normalized coordinates. void FindPhiSectors(Int_t iopt, Int_t& kphi, Double_t* aphi, Int_t& iphi1, Int_t& iphi2); Find critical PHI sectors. Input: IOPT - options: 1 - from BACK to FRONT 'BF'; 2 - from FRONT to BACK 'FB'; KPHI - number of phi sectors; APHI(*) - PHI separators (modified internally). Output: IPHI1 - initial sector; IPHI2 - final sector. void FindThetaSectors(Int_t iopt, Double_t phi, Int_t& kth, Double_t* ath, Int_t& ith1, Int_t& ith2); Find critical THETA sectors for given PHI sector. Input: IOPT - options: 1 - from BACK to FRONT 'BF'; 2 - from FRONT to BACK 'FB'; PHI - PHI sector; KTH - number of THETA sectors; ATH(*) - THETA separato",MatchSource.WIKI,root/html532/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TView3D.html
https://root.cern/root/html532/TView3D.html:16941,Availability,error,error,16941," of NORMAL; Y - Y-component of NORMAL; Z - Z-component of NORMAL. Output: ZN - Z-component of NORMAL in normalized coordinates. void FindPhiSectors(Int_t iopt, Int_t& kphi, Double_t* aphi, Int_t& iphi1, Int_t& iphi2); Find critical PHI sectors. Input: IOPT - options: 1 - from BACK to FRONT 'BF'; 2 - from FRONT to BACK 'FB'; KPHI - number of phi sectors; APHI(*) - PHI separators (modified internally). Output: IPHI1 - initial sector; IPHI2 - final sector. void FindThetaSectors(Int_t iopt, Double_t phi, Int_t& kth, Double_t* ath, Int_t& ith1, Int_t& ith2); Find critical THETA sectors for given PHI sector. Input: IOPT - options: 1 - from BACK to FRONT 'BF'; 2 - from FRONT to BACK 'FB'; PHI - PHI sector; KTH - number of THETA sectors; ATH(*) - THETA separators (modified internally). Output: ITH1 - initial sector; ITH2 - final sector. void FindScope(Double_t* scale, Double_t* center, Int_t& irep); Find centre of a MIN-MAX scope and scale factors. Output: SCALE(3) - scale factors; CENTER(3) - centre; IREP - reply (-1 if error in min-max). Int_t GetDistancetoAxis(Int_t axis, Int_t px, Int_t py, Double_t& ratio); Return distance to axis from point px,py. Algorithm:. A(x1,y1) P B(x2,y2); ------------------------------------------------; I; I; I; I; M(x,y). Let us call a = distance AM A=a**2; b = distance BM B=b**2; c = distance AB C=c**2; d = distance PM D=d**2; u = distance AP U=u**2; v = distance BP V=v**2 c = u + v. D = A - U; D = B - V = B -(c-u)**2; ==> u = (A -B +C)/2c. Double_t GetExtent() const; Get maximum view extent. void GetRange(Float_t* min, Float_t* max); Get Range function. void GetRange(Double_t* min, Double_t* max); Get Range function. void GetWindow(Double_t& u0, Double_t& v0, Double_t& du, Double_t& dv) const; Get current window extent. Bool_t IsClippedNDC(Double_t* p) const; Check if point is clipped in perspective view. void NDCtoWC(const Float_t* pn, Float_t* pw); Transfer point from normalized to world coordinates. Input: PN(3) - point in world coordina",MatchSource.WIKI,root/html532/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TView3D.html
https://root.cern/root/html532/TView3D.html:20363,Availability,error,error,20363,"-------+; (x,y,z) (X,y,z). void SetParallel(); Set the parallel option (default). void SetPerspective(); Set perspective option. void SetRange(const Double_t* min, const Double_t* max); Set Range function. void SetRange(Double_t x0, Double_t y0, Double_t z0, Double_t x1, Double_t y1, Double_t z1, Int_t flag = 0); Set 3-D View range. Input: x0, y0, z0 are minimum coordinates; x1, y1, z1 are maximum coordinates. flag values are: 0 (set always) <- default; 1 (shrink view); 2 (expand view). void SetWindow(Double_t u0, Double_t v0, Double_t du, Double_t dv); Set viewing window. void SetView(Double_t longitude, Double_t latitude, Double_t psi, Int_t& irep); Set view parameters. void ResizePad(); Recompute window for perspective view. void ResetView(Double_t longitude, Double_t latitude, Double_t psi, Int_t& irep); Set view direction (in spherical coordinates). Input PHI - longitude; THETA - latitude (angle between +Z and view direction); PSI - rotation in screen plane. Output: IREP - reply (-1 if error in min-max). Errors: error in min-max scope. void WCtoNDC(const Float_t* pw, Float_t* pn); Transfer point from world to normalized coordinates. Input: PW(3) - point in world coordinate system; PN(3) - point in normalized coordinate system. void WCtoNDC(const Double_t* pw, Double_t* pn); Transfer point from world to normalized coordinates. Input: PW(3) - point in world coordinate system; PN(3) - point in normalized coordinate system. void AdjustPad(TVirtualPad* pad = 0); Force the current pad to be updated. void RotateView(Double_t phi, Double_t theta, TVirtualPad* pad = 0); API to rotate view and adjust the pad provided it the current one. void SideView(TVirtualPad* pad = 0); Set to side view. void FrontView(TVirtualPad* pad = 0); Set to front view. void TopView(TVirtualPad* pad = 0); Set to top view. void ToggleRulers(TVirtualPad* pad = 0); Turn on /off 3D axis. void ToggleZoom(TVirtualPad* pad = 0); Turn on /off the interactive option to; Zoom / Move / Change attributes of",MatchSource.WIKI,root/html532/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TView3D.html
https://root.cern/root/html532/TView3D.html:20382,Availability,Error,Errors,20382,"lel(); Set the parallel option (default). void SetPerspective(); Set perspective option. void SetRange(const Double_t* min, const Double_t* max); Set Range function. void SetRange(Double_t x0, Double_t y0, Double_t z0, Double_t x1, Double_t y1, Double_t z1, Int_t flag = 0); Set 3-D View range. Input: x0, y0, z0 are minimum coordinates; x1, y1, z1 are maximum coordinates. flag values are: 0 (set always) <- default; 1 (shrink view); 2 (expand view). void SetWindow(Double_t u0, Double_t v0, Double_t du, Double_t dv); Set viewing window. void SetView(Double_t longitude, Double_t latitude, Double_t psi, Int_t& irep); Set view parameters. void ResizePad(); Recompute window for perspective view. void ResetView(Double_t longitude, Double_t latitude, Double_t psi, Int_t& irep); Set view direction (in spherical coordinates). Input PHI - longitude; THETA - latitude (angle between +Z and view direction); PSI - rotation in screen plane. Output: IREP - reply (-1 if error in min-max). Errors: error in min-max scope. void WCtoNDC(const Float_t* pw, Float_t* pn); Transfer point from world to normalized coordinates. Input: PW(3) - point in world coordinate system; PN(3) - point in normalized coordinate system. void WCtoNDC(const Double_t* pw, Double_t* pn); Transfer point from world to normalized coordinates. Input: PW(3) - point in world coordinate system; PN(3) - point in normalized coordinate system. void AdjustPad(TVirtualPad* pad = 0); Force the current pad to be updated. void RotateView(Double_t phi, Double_t theta, TVirtualPad* pad = 0); API to rotate view and adjust the pad provided it the current one. void SideView(TVirtualPad* pad = 0); Set to side view. void FrontView(TVirtualPad* pad = 0); Set to front view. void TopView(TVirtualPad* pad = 0); Set to top view. void ToggleRulers(TVirtualPad* pad = 0); Turn on /off 3D axis. void ToggleZoom(TVirtualPad* pad = 0); Turn on /off the interactive option to; Zoom / Move / Change attributes of 3D axis correspond this view. void Adj",MatchSource.WIKI,root/html532/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TView3D.html
https://root.cern/root/html532/TView3D.html:20390,Availability,error,error,20390,"lel(); Set the parallel option (default). void SetPerspective(); Set perspective option. void SetRange(const Double_t* min, const Double_t* max); Set Range function. void SetRange(Double_t x0, Double_t y0, Double_t z0, Double_t x1, Double_t y1, Double_t z1, Int_t flag = 0); Set 3-D View range. Input: x0, y0, z0 are minimum coordinates; x1, y1, z1 are maximum coordinates. flag values are: 0 (set always) <- default; 1 (shrink view); 2 (expand view). void SetWindow(Double_t u0, Double_t v0, Double_t du, Double_t dv); Set viewing window. void SetView(Double_t longitude, Double_t latitude, Double_t psi, Int_t& irep); Set view parameters. void ResizePad(); Recompute window for perspective view. void ResetView(Double_t longitude, Double_t latitude, Double_t psi, Int_t& irep); Set view direction (in spherical coordinates). Input PHI - longitude; THETA - latitude (angle between +Z and view direction); PSI - rotation in screen plane. Output: IREP - reply (-1 if error in min-max). Errors: error in min-max scope. void WCtoNDC(const Float_t* pw, Float_t* pn); Transfer point from world to normalized coordinates. Input: PW(3) - point in world coordinate system; PN(3) - point in normalized coordinate system. void WCtoNDC(const Double_t* pw, Double_t* pn); Transfer point from world to normalized coordinates. Input: PW(3) - point in world coordinate system; PN(3) - point in normalized coordinate system. void AdjustPad(TVirtualPad* pad = 0); Force the current pad to be updated. void RotateView(Double_t phi, Double_t theta, TVirtualPad* pad = 0); API to rotate view and adjust the pad provided it the current one. void SideView(TVirtualPad* pad = 0); Set to side view. void FrontView(TVirtualPad* pad = 0); Set to front view. void TopView(TVirtualPad* pad = 0); Set to top view. void ToggleRulers(TVirtualPad* pad = 0); Turn on /off 3D axis. void ToggleZoom(TVirtualPad* pad = 0); Turn on /off the interactive option to; Zoom / Move / Change attributes of 3D axis correspond this view. void Adj",MatchSource.WIKI,root/html532/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TView3D.html
https://root.cern/root/html532/TView3D.html:22234,Availability,down,down,22234,"(TVirtualPad* pad = 0); Turn on /off 3D axis. void ToggleZoom(TVirtualPad* pad = 0); Turn on /off the interactive option to; Zoom / Move / Change attributes of 3D axis correspond this view. void AdjustScales(TVirtualPad* pad = 0); Adjust all sides of view in respect of the biggest one. void Centered3DImages(TVirtualPad* pad = 0); Move view into the center of the scene. void UnzoomView(TVirtualPad* pad = 0, Double_t unZoomFactor = 1.25); unZOOM this view. void ZoomView(TVirtualPad* pad = 0, Double_t zoomFactor = 1.25); ZOOM this view. void MoveFocus(Double_t* center, Double_t dx, Double_t dy, Double_t dz, Int_t nsteps = 10, Double_t dlong = 0, Double_t dlat = 0, Double_t dpsi = 0); Move focus to a different box position and extent in nsteps. Perform; rotation with dlat,dlong,dpsi at each step. void MoveViewCommand(Char_t chCode, Int_t count = 1); 'a' increase scale factor (clip cube borders); 's' decrease scale factor (clip cube borders). void MoveWindow(Char_t option); Move view window :; l,L - left; h,H - right; u,U - down; i,I - up. void ZoomIn(); Zoom in. void ZoomOut(); Zoom out. void Streamer(TBuffer& b); Stream an object of class TView3D. void Centered(); {Centered3DImages();}. void Front(); {FrontView();}. void ShowAxis(); {ToggleRulers(); }. void Side(); {SideView();}. void Top(); {TopView();}. void ZoomMove(); {ToggleZoom();}. void Zoom(); {ZoomView();}. void UnZoom(); {UnzoomView();}. Double_t GetDview() const; {return fDview;}. Double_t GetDproj() const; {return fDproj;}. Bool_t GetAutoRange(); {return fAutoRange;}. Double_t GetLatitude(); {return fLatitude;}. Double_t GetLongitude(); {return fLongitude;}. Double_t GetPsi(); {return fPsi;}. Double_t * GetRmax(); {return fRmax;}. Double_t * GetRmin(); {return fRmin;}. TSeqCollection * GetOutline(); {return fOutline; }. Double_t * GetTback(); {return fTback;}. Double_t * GetTN(); {return fTN;}. Double_t * GetTnorm(); {return fTnorm;}. Int_t GetSystem(); {return fSystem;}. Double_t GetWindowWidth() const; {re",MatchSource.WIKI,root/html532/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TView3D.html
https://root.cern/root/html532/TView3D.html:20872,Deployability,update,updated,20872,"view). void SetWindow(Double_t u0, Double_t v0, Double_t du, Double_t dv); Set viewing window. void SetView(Double_t longitude, Double_t latitude, Double_t psi, Int_t& irep); Set view parameters. void ResizePad(); Recompute window for perspective view. void ResetView(Double_t longitude, Double_t latitude, Double_t psi, Int_t& irep); Set view direction (in spherical coordinates). Input PHI - longitude; THETA - latitude (angle between +Z and view direction); PSI - rotation in screen plane. Output: IREP - reply (-1 if error in min-max). Errors: error in min-max scope. void WCtoNDC(const Float_t* pw, Float_t* pn); Transfer point from world to normalized coordinates. Input: PW(3) - point in world coordinate system; PN(3) - point in normalized coordinate system. void WCtoNDC(const Double_t* pw, Double_t* pn); Transfer point from world to normalized coordinates. Input: PW(3) - point in world coordinate system; PN(3) - point in normalized coordinate system. void AdjustPad(TVirtualPad* pad = 0); Force the current pad to be updated. void RotateView(Double_t phi, Double_t theta, TVirtualPad* pad = 0); API to rotate view and adjust the pad provided it the current one. void SideView(TVirtualPad* pad = 0); Set to side view. void FrontView(TVirtualPad* pad = 0); Set to front view. void TopView(TVirtualPad* pad = 0); Set to top view. void ToggleRulers(TVirtualPad* pad = 0); Turn on /off 3D axis. void ToggleZoom(TVirtualPad* pad = 0); Turn on /off the interactive option to; Zoom / Move / Change attributes of 3D axis correspond this view. void AdjustScales(TVirtualPad* pad = 0); Adjust all sides of view in respect of the biggest one. void Centered3DImages(TVirtualPad* pad = 0); Move view into the center of the scene. void UnzoomView(TVirtualPad* pad = 0, Double_t unZoomFactor = 1.25); unZOOM this view. void ZoomView(TVirtualPad* pad = 0, Double_t zoomFactor = 1.25); ZOOM this view. void MoveFocus(Double_t* center, Double_t dx, Double_t dy, Double_t dz, Int_t nsteps = 10, Double_t dlon",MatchSource.WIKI,root/html532/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TView3D.html
https://root.cern/root/html532/TView3D.html:21187,Deployability,Toggle,ToggleRulers,21187,"ordinates). Input PHI - longitude; THETA - latitude (angle between +Z and view direction); PSI - rotation in screen plane. Output: IREP - reply (-1 if error in min-max). Errors: error in min-max scope. void WCtoNDC(const Float_t* pw, Float_t* pn); Transfer point from world to normalized coordinates. Input: PW(3) - point in world coordinate system; PN(3) - point in normalized coordinate system. void WCtoNDC(const Double_t* pw, Double_t* pn); Transfer point from world to normalized coordinates. Input: PW(3) - point in world coordinate system; PN(3) - point in normalized coordinate system. void AdjustPad(TVirtualPad* pad = 0); Force the current pad to be updated. void RotateView(Double_t phi, Double_t theta, TVirtualPad* pad = 0); API to rotate view and adjust the pad provided it the current one. void SideView(TVirtualPad* pad = 0); Set to side view. void FrontView(TVirtualPad* pad = 0); Set to front view. void TopView(TVirtualPad* pad = 0); Set to top view. void ToggleRulers(TVirtualPad* pad = 0); Turn on /off 3D axis. void ToggleZoom(TVirtualPad* pad = 0); Turn on /off the interactive option to; Zoom / Move / Change attributes of 3D axis correspond this view. void AdjustScales(TVirtualPad* pad = 0); Adjust all sides of view in respect of the biggest one. void Centered3DImages(TVirtualPad* pad = 0); Move view into the center of the scene. void UnzoomView(TVirtualPad* pad = 0, Double_t unZoomFactor = 1.25); unZOOM this view. void ZoomView(TVirtualPad* pad = 0, Double_t zoomFactor = 1.25); ZOOM this view. void MoveFocus(Double_t* center, Double_t dx, Double_t dy, Double_t dz, Int_t nsteps = 10, Double_t dlong = 0, Double_t dlat = 0, Double_t dpsi = 0); Move focus to a different box position and extent in nsteps. Perform; rotation with dlat,dlong,dpsi at each step. void MoveViewCommand(Char_t chCode, Int_t count = 1); 'a' increase scale factor (clip cube borders); 's' decrease scale factor (clip cube borders). void MoveWindow(Char_t option); Move view window :; l,L - left",MatchSource.WIKI,root/html532/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TView3D.html
https://root.cern/root/html532/TView3D.html:21250,Deployability,Toggle,ToggleZoom,21250,"n in screen plane. Output: IREP - reply (-1 if error in min-max). Errors: error in min-max scope. void WCtoNDC(const Float_t* pw, Float_t* pn); Transfer point from world to normalized coordinates. Input: PW(3) - point in world coordinate system; PN(3) - point in normalized coordinate system. void WCtoNDC(const Double_t* pw, Double_t* pn); Transfer point from world to normalized coordinates. Input: PW(3) - point in world coordinate system; PN(3) - point in normalized coordinate system. void AdjustPad(TVirtualPad* pad = 0); Force the current pad to be updated. void RotateView(Double_t phi, Double_t theta, TVirtualPad* pad = 0); API to rotate view and adjust the pad provided it the current one. void SideView(TVirtualPad* pad = 0); Set to side view. void FrontView(TVirtualPad* pad = 0); Set to front view. void TopView(TVirtualPad* pad = 0); Set to top view. void ToggleRulers(TVirtualPad* pad = 0); Turn on /off 3D axis. void ToggleZoom(TVirtualPad* pad = 0); Turn on /off the interactive option to; Zoom / Move / Change attributes of 3D axis correspond this view. void AdjustScales(TVirtualPad* pad = 0); Adjust all sides of view in respect of the biggest one. void Centered3DImages(TVirtualPad* pad = 0); Move view into the center of the scene. void UnzoomView(TVirtualPad* pad = 0, Double_t unZoomFactor = 1.25); unZOOM this view. void ZoomView(TVirtualPad* pad = 0, Double_t zoomFactor = 1.25); ZOOM this view. void MoveFocus(Double_t* center, Double_t dx, Double_t dy, Double_t dz, Int_t nsteps = 10, Double_t dlong = 0, Double_t dlat = 0, Double_t dpsi = 0); Move focus to a different box position and extent in nsteps. Perform; rotation with dlat,dlong,dpsi at each step. void MoveViewCommand(Char_t chCode, Int_t count = 1); 'a' increase scale factor (clip cube borders); 's' decrease scale factor (clip cube borders). void MoveWindow(Char_t option); Move view window :; l,L - left; h,H - right; u,U - down; i,I - up. void ZoomIn(); Zoom in. void ZoomOut(); Zoom out. void Streamer(TB",MatchSource.WIKI,root/html532/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TView3D.html
https://root.cern/root/html532/TView3D.html:22450,Deployability,Toggle,ToggleRulers,22450," view in respect of the biggest one. void Centered3DImages(TVirtualPad* pad = 0); Move view into the center of the scene. void UnzoomView(TVirtualPad* pad = 0, Double_t unZoomFactor = 1.25); unZOOM this view. void ZoomView(TVirtualPad* pad = 0, Double_t zoomFactor = 1.25); ZOOM this view. void MoveFocus(Double_t* center, Double_t dx, Double_t dy, Double_t dz, Int_t nsteps = 10, Double_t dlong = 0, Double_t dlat = 0, Double_t dpsi = 0); Move focus to a different box position and extent in nsteps. Perform; rotation with dlat,dlong,dpsi at each step. void MoveViewCommand(Char_t chCode, Int_t count = 1); 'a' increase scale factor (clip cube borders); 's' decrease scale factor (clip cube borders). void MoveWindow(Char_t option); Move view window :; l,L - left; h,H - right; u,U - down; i,I - up. void ZoomIn(); Zoom in. void ZoomOut(); Zoom out. void Streamer(TBuffer& b); Stream an object of class TView3D. void Centered(); {Centered3DImages();}. void Front(); {FrontView();}. void ShowAxis(); {ToggleRulers(); }. void Side(); {SideView();}. void Top(); {TopView();}. void ZoomMove(); {ToggleZoom();}. void Zoom(); {ZoomView();}. void UnZoom(); {UnzoomView();}. Double_t GetDview() const; {return fDview;}. Double_t GetDproj() const; {return fDproj;}. Bool_t GetAutoRange(); {return fAutoRange;}. Double_t GetLatitude(); {return fLatitude;}. Double_t GetLongitude(); {return fLongitude;}. Double_t GetPsi(); {return fPsi;}. Double_t * GetRmax(); {return fRmax;}. Double_t * GetRmin(); {return fRmin;}. TSeqCollection * GetOutline(); {return fOutline; }. Double_t * GetTback(); {return fTback;}. Double_t * GetTN(); {return fTN;}. Double_t * GetTnorm(); {return fTnorm;}. Int_t GetSystem(); {return fSystem;}. Double_t GetWindowWidth() const; {return 0.5*(fUVcoord[1]-fUVcoord[0]);}. Double_t GetWindowHeight() const; {return 0.5*(fUVcoord[3]-fUVcoord[2]);}. Bool_t IsPerspective() const; {return TestBit(kPerspective);}. Bool_t IsViewChanged() const; {return fChanged;}. void SetAutoRange(Bool_t",MatchSource.WIKI,root/html532/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TView3D.html
https://root.cern/root/html532/TView3D.html:22541,Deployability,Toggle,ToggleZoom,22541,"w into the center of the scene. void UnzoomView(TVirtualPad* pad = 0, Double_t unZoomFactor = 1.25); unZOOM this view. void ZoomView(TVirtualPad* pad = 0, Double_t zoomFactor = 1.25); ZOOM this view. void MoveFocus(Double_t* center, Double_t dx, Double_t dy, Double_t dz, Int_t nsteps = 10, Double_t dlong = 0, Double_t dlat = 0, Double_t dpsi = 0); Move focus to a different box position and extent in nsteps. Perform; rotation with dlat,dlong,dpsi at each step. void MoveViewCommand(Char_t chCode, Int_t count = 1); 'a' increase scale factor (clip cube borders); 's' decrease scale factor (clip cube borders). void MoveWindow(Char_t option); Move view window :; l,L - left; h,H - right; u,U - down; i,I - up. void ZoomIn(); Zoom in. void ZoomOut(); Zoom out. void Streamer(TBuffer& b); Stream an object of class TView3D. void Centered(); {Centered3DImages();}. void Front(); {FrontView();}. void ShowAxis(); {ToggleRulers(); }. void Side(); {SideView();}. void Top(); {TopView();}. void ZoomMove(); {ToggleZoom();}. void Zoom(); {ZoomView();}. void UnZoom(); {UnzoomView();}. Double_t GetDview() const; {return fDview;}. Double_t GetDproj() const; {return fDproj;}. Bool_t GetAutoRange(); {return fAutoRange;}. Double_t GetLatitude(); {return fLatitude;}. Double_t GetLongitude(); {return fLongitude;}. Double_t GetPsi(); {return fPsi;}. Double_t * GetRmax(); {return fRmax;}. Double_t * GetRmin(); {return fRmin;}. TSeqCollection * GetOutline(); {return fOutline; }. Double_t * GetTback(); {return fTback;}. Double_t * GetTN(); {return fTN;}. Double_t * GetTnorm(); {return fTnorm;}. Int_t GetSystem(); {return fSystem;}. Double_t GetWindowWidth() const; {return 0.5*(fUVcoord[1]-fUVcoord[0]);}. Double_t GetWindowHeight() const; {return 0.5*(fUVcoord[3]-fUVcoord[2]);}. Bool_t IsPerspective() const; {return TestBit(kPerspective);}. Bool_t IsViewChanged() const; {return fChanged;}. void SetAutoRange(Bool_t autorange = kTRUE); {fAutoRange=autorange;}. void SetDview(Double_t dview); {fDview=dvie",MatchSource.WIKI,root/html532/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TView3D.html
https://root.cern/root/html532/TView3D.html:418,Energy Efficiency,adapt,adapted,418,". TView3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » TView3D. class TView3D: public TView. The 3D view class; This package was originally written by Evgueni Tcherniaev from IHEP/Protvino. The original Fortran implementation was adapted to HIGZ/PAW by Olivier Couet and; Evgueni Tcherniaev. This View class is a subset of the original system. It has been converted to a; C++ class by Rene Brun. TView3D creates a 3-D view in the current pad. In this 3D view Lego and Surface; plots can be drawn and also 3D polyline and markers. Most of the time a TView3D; is created automatically when a 3D object needs to be painted in a pad (for; instance a Lego or a Surface plot). In some case a TView3D should be explicitly. For instance to paint a 3D simple; scene composed of simple objects like polylines and polymarkers.; The following macro gives an example:. Several coordinate systems are available:. Cartesian; Polar; Cylindrical; Spherical; PseudoRapidity/Phi. . Function Members (Methods); public:. TView3D(); TView3D(Int_t system, const Double_t* rmin, const Double_t* rmax); virtual~TView3D(); voidTObject::AbstractMethod(const char* method) const; static voidAdjustPad(TVirtualPad* pad = 0); virtual voidAdjustScales(TVirtualPad* pad = 0)MENU ; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidAxisVertex(Double_t ang, Double_t* av, Int_t& ix1, Int_t& ix2, Int_t& iy1, Int_t& iy2, Int_t& iz1, Int_t& iz2); virtual voidTObject::Browse(TBrowser* b); virtual voidCentered()MENU ; virtual voidCentered3DImages(TVirtualPad* pad = 0); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(T",MatchSource.WIKI,root/html532/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TView3D.html
https://root.cern/root/html532/TView3D.html:12517,Integrability,depend,depending,12517,"; Double_tfLongitudeView angle longitude; TSeqCollection*fOutlineCollection of outline's objects; Double_tfPsiView angle psi; Double_tfRmax[3]Upper limits of object; Double_tfRmin[3]Lower limits of object; Int_tfSystemCoordinate system; Double_tfTB[16]; Double_tfTN[16]; Double_tfTback[16]Back transformation matrix; Double_tfTnorm[16]Transformation matrix; Double_tfUVcoord[4]Viewing window limits; Double_tfUpixpad X size in pixels; Double_tfVpixpad Y size in pixels; Double_tfX1[3]First coordinate of X axis; Double_tfX2[3]Second coordinate of X axis; Double_tfY1[3]First coordinate of Y axis; Double_tfY2[3]Second coordinate of Y axis; Double_tfZ1[3]First coordinate of Z axis; Double_tfZ2[3]Second coordinate of Z axis. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TView3D(); Default constructor. TView3D(Int_t system, const Double_t* rmin, const Double_t* rmax); TView3D constructor. Creates a 3-D view in the current pad; rmin[3], rmax[3] are the limits of the object depending on; the selected coordinate system. Before drawing a 3-D object in a pad, a 3-D view must be created.; Note that a view is automatically created when drawing legos or surfaces. The coordinate system is selected via system:; system = 1 Cartesian; system = 2 Polar; system = 3 Cylindrical; system = 4 Spherical; system = 5 PseudoRapidity/Phi. TView3D(const TView3D& ); Copy constructor. TView3D& operator=(const TView3D& ); Assignment operator. ~TView3D(); TView3D default destructor. void AxisVertex(Double_t ang, Double_t* av, Int_t& ix1, Int_t& ix2, Int_t& iy1, Int_t& iy2, Int_t& iz1, Int_t& iz2); Define axis vertices. Input ANG - angle between X and Y axis. Output: AV(3,8) - axis vertices; IX1 - 1st point of X-axis; IX2 - 2nd point of X-axis; IY1 - 1st point of Y-axis; IY2 - 2nd point of Y-axis; IZ1 - 1st point of Z-axis; IZ2 - 2nd point of Z-axis. 8 6; / \ /|\; 5 / \ 7 5 / | \ 7; |\ /| | | |; THETA < 90 | \6/ | THETA > 90 | /2\ |; (Top view) | | | (Bottom vie",MatchSource.WIKI,root/html532/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TView3D.html
https://root.cern/root/html532/TView3D.html:418,Modifiability,adapt,adapted,418,". TView3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » TView3D. class TView3D: public TView. The 3D view class; This package was originally written by Evgueni Tcherniaev from IHEP/Protvino. The original Fortran implementation was adapted to HIGZ/PAW by Olivier Couet and; Evgueni Tcherniaev. This View class is a subset of the original system. It has been converted to a; C++ class by Rene Brun. TView3D creates a 3-D view in the current pad. In this 3D view Lego and Surface; plots can be drawn and also 3D polyline and markers. Most of the time a TView3D; is created automatically when a 3D object needs to be painted in a pad (for; instance a Lego or a Surface plot). In some case a TView3D should be explicitly. For instance to paint a 3D simple; scene composed of simple objects like polylines and polymarkers.; The following macro gives an example:. Several coordinate systems are available:. Cartesian; Polar; Cylindrical; Spherical; PseudoRapidity/Phi. . Function Members (Methods); public:. TView3D(); TView3D(Int_t system, const Double_t* rmin, const Double_t* rmax); virtual~TView3D(); voidTObject::AbstractMethod(const char* method) const; static voidAdjustPad(TVirtualPad* pad = 0); virtual voidAdjustScales(TVirtualPad* pad = 0)MENU ; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidAxisVertex(Double_t ang, Double_t* av, Int_t& ix1, Int_t& ix2, Int_t& iy1, Int_t& iy2, Int_t& iz1, Int_t& iz2); virtual voidTObject::Browse(TBrowser* b); virtual voidCentered()MENU ; virtual voidCentered3DImages(TVirtualPad* pad = 0); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(T",MatchSource.WIKI,root/html532/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TView3D.html
https://root.cern/root/html532/TView3D.html:5385,Modifiability,Inherit,InheritsFrom,5385,"rtual Double_tGetLongitude(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TSeqCollection*GetOutline(); virtual Double_tGetPsi(); virtual voidGetRange(Float_t* min, Float_t* max); virtual voidGetRange(Double_t* min, Double_t* max); virtual Double_t*GetRmax(); virtual Double_t*GetRmin(); virtual Int_tGetSystem(); virtual Double_t*GetTback(); virtual const char*TObject::GetTitle() const; virtual Double_t*GetTN(); virtual Double_t*GetTnorm(); virtual UInt_tTObject::GetUniqueID() const; virtual voidGetWindow(Double_t& u0, Double_t& v0, Double_t& du, Double_t& dv) const; virtual Double_tGetWindowHeight() const; virtual Double_tGetWindowWidth() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tIsClippedNDC(Double_t* p) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsPerspective() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tIsViewChanged() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttLine::Modify(); virtual voidMoveFocus(Double_t* center, Double_t dx, Double_t dy, Double_t dz, Int_t nsteps = 10, Double_t dlong = 0, Double_t dlat = 0, Double_t dpsi = 0); virtual voidMoveViewCommand(Char_t chCode, Int_t count = 1); virtual voidMoveWindow(Char_t option); virtual voidNDCtoWC(const Float_t* pn, Float_t* pw); virtual voidNDCtoWC(con",MatchSource.WIKI,root/html532/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TView3D.html
https://root.cern/root/html532/TView3D.html:5451,Modifiability,Inherit,InheritsFrom,5451,") const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TSeqCollection*GetOutline(); virtual Double_tGetPsi(); virtual voidGetRange(Float_t* min, Float_t* max); virtual voidGetRange(Double_t* min, Double_t* max); virtual Double_t*GetRmax(); virtual Double_t*GetRmin(); virtual Int_tGetSystem(); virtual Double_t*GetTback(); virtual const char*TObject::GetTitle() const; virtual Double_t*GetTN(); virtual Double_t*GetTnorm(); virtual UInt_tTObject::GetUniqueID() const; virtual voidGetWindow(Double_t& u0, Double_t& v0, Double_t& du, Double_t& dv) const; virtual Double_tGetWindowHeight() const; virtual Double_tGetWindowWidth() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tIsClippedNDC(Double_t* p) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsPerspective() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tIsViewChanged() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttLine::Modify(); virtual voidMoveFocus(Double_t* center, Double_t dx, Double_t dy, Double_t dz, Int_t nsteps = 10, Double_t dlong = 0, Double_t dlat = 0, Double_t dpsi = 0); virtual voidMoveViewCommand(Char_t chCode, Int_t count = 1); virtual voidMoveWindow(Char_t option); virtual voidNDCtoWC(const Float_t* pn, Float_t* pw); virtual voidNDCtoWC(const Double_t* pn, Double_t* pw); virtual voidNormalWCtoNDC(const Fl",MatchSource.WIKI,root/html532/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TView3D.html
https://root.cern/root/html532/TView3D.html:12235,Modifiability,Inherit,Inheritance,12235,"projDistance from COP to projection plane; Double_tfDviewDistance from COP to COV; Double_tfLatitudeView angle latitude; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Double_tfLongitudeView angle longitude; TSeqCollection*fOutlineCollection of outline's objects; Double_tfPsiView angle psi; Double_tfRmax[3]Upper limits of object; Double_tfRmin[3]Lower limits of object; Int_tfSystemCoordinate system; Double_tfTB[16]; Double_tfTN[16]; Double_tfTback[16]Back transformation matrix; Double_tfTnorm[16]Transformation matrix; Double_tfUVcoord[4]Viewing window limits; Double_tfUpixpad X size in pixels; Double_tfVpixpad Y size in pixels; Double_tfX1[3]First coordinate of X axis; Double_tfX2[3]Second coordinate of X axis; Double_tfY1[3]First coordinate of Y axis; Double_tfY2[3]Second coordinate of Y axis; Double_tfZ1[3]First coordinate of Z axis; Double_tfZ2[3]Second coordinate of Z axis. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TView3D(); Default constructor. TView3D(Int_t system, const Double_t* rmin, const Double_t* rmax); TView3D constructor. Creates a 3-D view in the current pad; rmin[3], rmax[3] are the limits of the object depending on; the selected coordinate system. Before drawing a 3-D object in a pad, a 3-D view must be created.; Note that a view is automatically created when drawing legos or surfaces. The coordinate system is selected via system:; system = 1 Cartesian; system = 2 Polar; system = 3 Cylindrical; system = 4 Spherical; system = 5 PseudoRapidity/Phi. TView3D(const TView3D& ); Copy constructor. TView3D& operator=(const TView3D& ); Assignment operator. ~TView3D(); TView3D default destructor. void AxisVertex(Double_t ang, Double_t* av, Int_t& ix1, Int_t& ix2, Int_t& iy1, Int_t& iy2, Int_t& iz1, Int_t& iz2); Define axis vertices. Input ANG - angle between X and Y axis. Output: AV(3,8) - axis vertices; IX1 - 1st point of X-axis; IX2 - 2nd po",MatchSource.WIKI,root/html532/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TView3D.html
https://root.cern/root/html532/TView3D.html:12248,Modifiability,Inherit,Inherited,12248,"projDistance from COP to projection plane; Double_tfDviewDistance from COP to COV; Double_tfLatitudeView angle latitude; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Double_tfLongitudeView angle longitude; TSeqCollection*fOutlineCollection of outline's objects; Double_tfPsiView angle psi; Double_tfRmax[3]Upper limits of object; Double_tfRmin[3]Lower limits of object; Int_tfSystemCoordinate system; Double_tfTB[16]; Double_tfTN[16]; Double_tfTback[16]Back transformation matrix; Double_tfTnorm[16]Transformation matrix; Double_tfUVcoord[4]Viewing window limits; Double_tfUpixpad X size in pixels; Double_tfVpixpad Y size in pixels; Double_tfX1[3]First coordinate of X axis; Double_tfX2[3]Second coordinate of X axis; Double_tfY1[3]First coordinate of Y axis; Double_tfY2[3]Second coordinate of Y axis; Double_tfZ1[3]First coordinate of Z axis; Double_tfZ2[3]Second coordinate of Z axis. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TView3D(); Default constructor. TView3D(Int_t system, const Double_t* rmin, const Double_t* rmax); TView3D constructor. Creates a 3-D view in the current pad; rmin[3], rmax[3] are the limits of the object depending on; the selected coordinate system. Before drawing a 3-D object in a pad, a 3-D view must be created.; Note that a view is automatically created when drawing legos or surfaces. The coordinate system is selected via system:; system = 1 Cartesian; system = 2 Polar; system = 3 Cylindrical; system = 4 Spherical; system = 5 PseudoRapidity/Phi. TView3D(const TView3D& ); Copy constructor. TView3D& operator=(const TView3D& ); Assignment operator. ~TView3D(); TView3D default destructor. void AxisVertex(Double_t ang, Double_t* av, Int_t& ix1, Int_t& ix2, Int_t& iy1, Int_t& iy2, Int_t& iz1, Int_t& iz2); Define axis vertices. Input ANG - angle between X and Y axis. Output: AV(3,8) - axis vertices; IX1 - 1st point of X-axis; IX2 - 2nd po",MatchSource.WIKI,root/html532/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TView3D.html
https://root.cern/root/html532/TView3D.html:21950,Performance,Perform,Perform,21950,"just the pad provided it the current one. void SideView(TVirtualPad* pad = 0); Set to side view. void FrontView(TVirtualPad* pad = 0); Set to front view. void TopView(TVirtualPad* pad = 0); Set to top view. void ToggleRulers(TVirtualPad* pad = 0); Turn on /off 3D axis. void ToggleZoom(TVirtualPad* pad = 0); Turn on /off the interactive option to; Zoom / Move / Change attributes of 3D axis correspond this view. void AdjustScales(TVirtualPad* pad = 0); Adjust all sides of view in respect of the biggest one. void Centered3DImages(TVirtualPad* pad = 0); Move view into the center of the scene. void UnzoomView(TVirtualPad* pad = 0, Double_t unZoomFactor = 1.25); unZOOM this view. void ZoomView(TVirtualPad* pad = 0, Double_t zoomFactor = 1.25); ZOOM this view. void MoveFocus(Double_t* center, Double_t dx, Double_t dy, Double_t dz, Int_t nsteps = 10, Double_t dlong = 0, Double_t dlat = 0, Double_t dpsi = 0); Move focus to a different box position and extent in nsteps. Perform; rotation with dlat,dlong,dpsi at each step. void MoveViewCommand(Char_t chCode, Int_t count = 1); 'a' increase scale factor (clip cube borders); 's' decrease scale factor (clip cube borders). void MoveWindow(Char_t option); Move view window :; l,L - left; h,H - right; u,U - down; i,I - up. void ZoomIn(); Zoom in. void ZoomOut(); Zoom out. void Streamer(TBuffer& b); Stream an object of class TView3D. void Centered(); {Centered3DImages();}. void Front(); {FrontView();}. void ShowAxis(); {ToggleRulers(); }. void Side(); {SideView();}. void Top(); {TopView();}. void ZoomMove(); {ToggleZoom();}. void Zoom(); {ZoomView();}. void UnZoom(); {UnzoomView();}. Double_t GetDview() const; {return fDview;}. Double_t GetDproj() const; {return fDproj;}. Bool_t GetAutoRange(); {return fAutoRange;}. Double_t GetLatitude(); {return fLatitude;}. Double_t GetLongitude(); {return fLongitude;}. Double_t GetPsi(); {return fPsi;}. Double_t * GetRmax(); {return fRmax;}. Double_t * GetRmin(); {return fRmin;}. TSeqCollection * Ge",MatchSource.WIKI,root/html532/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TView3D.html
https://root.cern/root/html532/TView3D.html:5275,Security,Hash,Hash,5275,"ineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Double_tGetLongitude(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TSeqCollection*GetOutline(); virtual Double_tGetPsi(); virtual voidGetRange(Float_t* min, Float_t* max); virtual voidGetRange(Double_t* min, Double_t* max); virtual Double_t*GetRmax(); virtual Double_t*GetRmin(); virtual Int_tGetSystem(); virtual Double_t*GetTback(); virtual const char*TObject::GetTitle() const; virtual Double_t*GetTN(); virtual Double_t*GetTnorm(); virtual UInt_tTObject::GetUniqueID() const; virtual voidGetWindow(Double_t& u0, Double_t& v0, Double_t& du, Double_t& dv) const; virtual Double_tGetWindowHeight() const; virtual Double_tGetWindowWidth() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tIsClippedNDC(Double_t* p) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsPerspective() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tIsViewChanged() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttLine::Modify(); virtual voidMoveFocus(Double_t* center, Double_t dx, Double_t dy, Double_t dz, Int_t nsteps = 10, Double_t dlong = 0, Double_t dlat = 0, Double_t dpsi = 0); virtual voidMoveViewCommand(Char_t chCode, Int_t count = 1); v",MatchSource.WIKI,root/html532/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TView3D.html
https://root.cern/root/html532/TView3D.html:9568,Testability,Test,TestBit,9568,"etAxisNDC(const Double_t* x1, const Double_t* x2, const Double_t* y1, const Double_t* y2, const Double_t* z1, const Double_t* z2); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetDefaultWindow(); virtual voidSetDproj(Double_t dproj); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetDview(Double_t dview); virtual voidSetLatitude(Double_t latitude); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidSetLongitude(Double_t longitude); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOutlineToCube(); virtual voidSetParallel()MENU ; virtual voidSetPerspective()MENU ; virtual voidSetPsi(Double_t psi); virtual voidSetRange(const Double_t* min, const Double_t* max); virtual voidSetRange(Double_t x0, Double_t y0, Double_t z0, Double_t x1, Double_t y1, Double_t z1, Int_t flag = 0); virtual voidSetSystem(Int_t system); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetView(Double_t longitude, Double_t latitude, Double_t psi, Int_t& irep); virtual voidSetViewChanged(Bool_t flag = kTRUE); virtual voidSetWindow(Double_t u0, Double_t v0, Double_t du, Double_t dv); virtual voidShowAxis()MENU ; virtual voidShowMembers(TMemberInspector& insp); virtual voidSide()MENU ; virtual voidSideView(TVirtualPad* pad = 0); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidToggleRulers(TVirtualPad* pad = 0); virtual voidToggleZoom(TVirtualPad* pad = 0); virtual voidTop()MENU ; virtual voidTopView(TVirtualPad* pad = 0); virtual voidUnZoom()MENU ; virtual voidUnzoomView(TVirtualPad* pad = 0, Double_t unZoomFactor = 1.",MatchSource.WIKI,root/html532/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TView3D.html
https://root.cern/root/html532/TView3D.html:9607,Testability,Test,TestBits,9607,"etAxisNDC(const Double_t* x1, const Double_t* x2, const Double_t* y1, const Double_t* y2, const Double_t* z1, const Double_t* z2); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetDefaultWindow(); virtual voidSetDproj(Double_t dproj); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetDview(Double_t dview); virtual voidSetLatitude(Double_t latitude); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidSetLongitude(Double_t longitude); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOutlineToCube(); virtual voidSetParallel()MENU ; virtual voidSetPerspective()MENU ; virtual voidSetPsi(Double_t psi); virtual voidSetRange(const Double_t* min, const Double_t* max); virtual voidSetRange(Double_t x0, Double_t y0, Double_t z0, Double_t x1, Double_t y1, Double_t z1, Int_t flag = 0); virtual voidSetSystem(Int_t system); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetView(Double_t longitude, Double_t latitude, Double_t psi, Int_t& irep); virtual voidSetViewChanged(Bool_t flag = kTRUE); virtual voidSetWindow(Double_t u0, Double_t v0, Double_t du, Double_t dv); virtual voidShowAxis()MENU ; virtual voidShowMembers(TMemberInspector& insp); virtual voidSide()MENU ; virtual voidSideView(TVirtualPad* pad = 0); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidToggleRulers(TVirtualPad* pad = 0); virtual voidToggleZoom(TVirtualPad* pad = 0); virtual voidTop()MENU ; virtual voidTopView(TVirtualPad* pad = 0); virtual voidUnZoom()MENU ; virtual voidUnzoomView(TVirtualPad* pad = 0, Double_t unZoomFactor = 1.",MatchSource.WIKI,root/html532/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TView3D.html
https://root.cern/root/html532/TView3D.html:23351,Testability,Test,TestBit,23351," - down; i,I - up. void ZoomIn(); Zoom in. void ZoomOut(); Zoom out. void Streamer(TBuffer& b); Stream an object of class TView3D. void Centered(); {Centered3DImages();}. void Front(); {FrontView();}. void ShowAxis(); {ToggleRulers(); }. void Side(); {SideView();}. void Top(); {TopView();}. void ZoomMove(); {ToggleZoom();}. void Zoom(); {ZoomView();}. void UnZoom(); {UnzoomView();}. Double_t GetDview() const; {return fDview;}. Double_t GetDproj() const; {return fDproj;}. Bool_t GetAutoRange(); {return fAutoRange;}. Double_t GetLatitude(); {return fLatitude;}. Double_t GetLongitude(); {return fLongitude;}. Double_t GetPsi(); {return fPsi;}. Double_t * GetRmax(); {return fRmax;}. Double_t * GetRmin(); {return fRmin;}. TSeqCollection * GetOutline(); {return fOutline; }. Double_t * GetTback(); {return fTback;}. Double_t * GetTN(); {return fTN;}. Double_t * GetTnorm(); {return fTnorm;}. Int_t GetSystem(); {return fSystem;}. Double_t GetWindowWidth() const; {return 0.5*(fUVcoord[1]-fUVcoord[0]);}. Double_t GetWindowHeight() const; {return 0.5*(fUVcoord[3]-fUVcoord[2]);}. Bool_t IsPerspective() const; {return TestBit(kPerspective);}. Bool_t IsViewChanged() const; {return fChanged;}. void SetAutoRange(Bool_t autorange = kTRUE); {fAutoRange=autorange;}. void SetDview(Double_t dview); {fDview=dview;}. void SetDproj(Double_t dproj); {fDproj=dproj;}. void SetLatitude(Double_t latitude); {fLatitude = latitude;}. void SetLongitude(Double_t longitude); {fLongitude = longitude;}. void SetPsi(Double_t psi); {fPsi = psi;}. void SetSystem(Int_t system); {fSystem = system;}. void SetViewChanged(Bool_t flag = kTRUE); {fChanged = flag;}. » Author: Rene Brun 19/02/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/g3d:$Id: TView3D.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TView3D.html
https://root.cern/root/html532/TView3D.html:931,Usability,simpl,simple,931,". TView3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » TView3D. class TView3D: public TView. The 3D view class; This package was originally written by Evgueni Tcherniaev from IHEP/Protvino. The original Fortran implementation was adapted to HIGZ/PAW by Olivier Couet and; Evgueni Tcherniaev. This View class is a subset of the original system. It has been converted to a; C++ class by Rene Brun. TView3D creates a 3-D view in the current pad. In this 3D view Lego and Surface; plots can be drawn and also 3D polyline and markers. Most of the time a TView3D; is created automatically when a 3D object needs to be painted in a pad (for; instance a Lego or a Surface plot). In some case a TView3D should be explicitly. For instance to paint a 3D simple; scene composed of simple objects like polylines and polymarkers.; The following macro gives an example:. Several coordinate systems are available:. Cartesian; Polar; Cylindrical; Spherical; PseudoRapidity/Phi. . Function Members (Methods); public:. TView3D(); TView3D(Int_t system, const Double_t* rmin, const Double_t* rmax); virtual~TView3D(); voidTObject::AbstractMethod(const char* method) const; static voidAdjustPad(TVirtualPad* pad = 0); virtual voidAdjustScales(TVirtualPad* pad = 0)MENU ; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidAxisVertex(Double_t ang, Double_t* av, Int_t& ix1, Int_t& ix2, Int_t& iy1, Int_t& iy2, Int_t& iz1, Int_t& iz2); virtual voidTObject::Browse(TBrowser* b); virtual voidCentered()MENU ; virtual voidCentered3DImages(TVirtualPad* pad = 0); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(T",MatchSource.WIKI,root/html532/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TView3D.html
https://root.cern/root/html532/TView3D.html:957,Usability,simpl,simple,957,". TView3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » TView3D. class TView3D: public TView. The 3D view class; This package was originally written by Evgueni Tcherniaev from IHEP/Protvino. The original Fortran implementation was adapted to HIGZ/PAW by Olivier Couet and; Evgueni Tcherniaev. This View class is a subset of the original system. It has been converted to a; C++ class by Rene Brun. TView3D creates a 3-D view in the current pad. In this 3D view Lego and Surface; plots can be drawn and also 3D polyline and markers. Most of the time a TView3D; is created automatically when a 3D object needs to be painted in a pad (for; instance a Lego or a Surface plot). In some case a TView3D should be explicitly. For instance to paint a 3D simple; scene composed of simple objects like polylines and polymarkers.; The following macro gives an example:. Several coordinate systems are available:. Cartesian; Polar; Cylindrical; Spherical; PseudoRapidity/Phi. . Function Members (Methods); public:. TView3D(); TView3D(Int_t system, const Double_t* rmin, const Double_t* rmax); virtual~TView3D(); voidTObject::AbstractMethod(const char* method) const; static voidAdjustPad(TVirtualPad* pad = 0); virtual voidAdjustScales(TVirtualPad* pad = 0)MENU ; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidAxisVertex(Double_t ang, Double_t* av, Int_t& ix1, Int_t& ix2, Int_t& iy1, Int_t& iy2, Int_t& iz1, Int_t& iz2); virtual voidTObject::Browse(TBrowser* b); virtual voidCentered()MENU ; virtual voidCentered3DImages(TVirtualPad* pad = 0); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(T",MatchSource.WIKI,root/html532/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TView3D.html
https://root.cern/root/html532/TView3D.html:1830,Usability,Clear,Clear,1830," TView3D(); TView3D(Int_t system, const Double_t* rmin, const Double_t* rmax); virtual~TView3D(); voidTObject::AbstractMethod(const char* method) const; static voidAdjustPad(TVirtualPad* pad = 0); virtual voidAdjustScales(TVirtualPad* pad = 0)MENU ; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidAxisVertex(Double_t ang, Double_t* av, Int_t& ix1, Int_t& ix2, Int_t& iy1, Int_t& iy2, Int_t& iz1, Int_t& iz2); virtual voidTObject::Browse(TBrowser* b); virtual voidCentered()MENU ; virtual voidCentered3DImages(TVirtualPad* pad = 0); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(T",MatchSource.WIKI,root/html532/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TView3D.html
https://root.cern/root/html532/TViewer3DPad.html:1732,Availability,Error,Error,1732,"t TBuffer3D& buffer, Bool_t* addChildren = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBeginScene(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tBuildingScene() const; virtual Bool_tTVirtualViewer3D::CanLoopOnPrimitives() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseComposite(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTVirtualViewer3D::DrawViewer(); virtual voidTObject::Dump() constMENU ; virtual voidEndScene(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtua",MatchSource.WIKI,root/html532/TViewer3DPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TViewer3DPad.html
https://root.cern/root/html532/TViewer3DPad.html:1861,Availability,error,error,1861,"irtual voidTObject::Browse(TBrowser* b); virtual Bool_tBuildingScene() const; virtual Bool_tTVirtualViewer3D::CanLoopOnPrimitives() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseComposite(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTVirtualViewer3D::DrawViewer(); virtual voidTObject::Dump() constMENU ; virtual voidEndScene(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html532/TViewer3DPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TViewer3DPad.html
https://root.cern/root/html532/TViewer3DPad.html:1945,Availability,error,error,1945,"l Bool_tTVirtualViewer3D::CanLoopOnPrimitives() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseComposite(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTVirtualViewer3D::DrawViewer(); virtual voidTObject::Dump() constMENU ; virtual voidEndScene(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html532/TViewer3DPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TViewer3DPad.html
https://root.cern/root/html532/TViewer3DPad.html:327,Integrability,interface,interface,327,". TViewer3DPad. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GPAD; » TViewer3DPad. class TViewer3DPad: public TVirtualViewer3D. Provides 3D viewer interface (TVirtualViewer3D) support on a pad.; Will be merged with TView / TView3D eventually. Function Members (Methods); public:. TViewer3DPad(TVirtualPad& pad); virtual~TViewer3DPad(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddCompositeOp(UInt_t operation); virtual Int_tAddObject(const TBuffer3D& buffer, Bool_t* addChildren = 0); virtual Int_tAddObject(UInt_t placedID, const TBuffer3D& buffer, Bool_t* addChildren = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBeginScene(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tBuildingScene() const; virtual Bool_tTVirtualViewer3D::CanLoopOnPrimitives() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseComposite(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTVirtualViewer3D::DrawViewer(); virtual voidTObject::Dump() constMENU ; virtual voidEndScene(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t even",MatchSource.WIKI,root/html532/TViewer3DPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TViewer3DPad.html
https://root.cern/root/html532/TViewer3DPad.html:2825,Modifiability,Inherit,InheritsFrom,2825,"d, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); virtual voidTVirtualViewer3D::ObjectPaint(TObject*, Option_t* = """"); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Bool_tOpenComposite(const TBuffer3D& buffer, Bool_t* addChildren = 0); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, ",MatchSource.WIKI,root/html532/TViewer3DPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TViewer3DPad.html
https://root.cern/root/html532/TViewer3DPad.html:2891,Modifiability,Inherit,InheritsFrom,2891,"cute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); virtual voidTVirtualViewer3D::ObjectPaint(TObject*, Option_t* = """"); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Bool_tOpenComposite(const TBuffer3D& buffer, Bool_t* addChildren = 0); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::op",MatchSource.WIKI,root/html532/TViewer3DPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TViewer3DPad.html
https://root.cern/root/html532/TViewer3DPad.html:6309,Modifiability,Inherit,Inheritance,6309,"seCurrentStyle(); static TVirtualViewer3D*TVirtualViewer3D::Viewer3D(TVirtualPad* pad = 0, Option_t* type = """"); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TViewer3DPad(const TViewer3DPad&); TViewer3DPad&operator=(const TViewer3DPad&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Bool_tfBuildingis scene being built?; TVirtualPad&fPadthe pad we paint into. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t PreferLocalFrame() const; Indicates if we prefer positions in local frame. Always false - pad; drawing is always done in master frame. void BeginScene(); Open a scene on the viewer. void EndScene(); Close the scene on the viewer. Int_t AddObject(const TBuffer3D& buffer, Bool_t* addChildren = 0); Add an 3D object described by the buffer to the viewer. Returns flags; to indicate:; i) if extra sections of the buffer need completing.; ii) if child objects of the buffer object should be added (always true). Int_t AddObject(UInt_t placedID, const TBuffer3D& buffer, Bool_t* addChildren = 0); We don't support placed ID shapes - ID is discarded. Bool_t OpenComposite(const TBuffer3D& buffer, Bool_t* addChildren = 0); Composite shapes not supported on this viewer currently - ignore.; Will result in a set of individual component shapes. void CloseComposite(); {}. void AddCompositeOp(UInt_t operation); {}. TViewer3DPad(const TViewer3DPad& );",MatchSource.WIKI,root/html532/TViewer3DPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TViewer3DPad.html
https://root.cern/root/html532/TViewer3DPad.html:6322,Modifiability,Inherit,Inherited,6322,"seCurrentStyle(); static TVirtualViewer3D*TVirtualViewer3D::Viewer3D(TVirtualPad* pad = 0, Option_t* type = """"); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TViewer3DPad(const TViewer3DPad&); TViewer3DPad&operator=(const TViewer3DPad&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Bool_tfBuildingis scene being built?; TVirtualPad&fPadthe pad we paint into. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t PreferLocalFrame() const; Indicates if we prefer positions in local frame. Always false - pad; drawing is always done in master frame. void BeginScene(); Open a scene on the viewer. void EndScene(); Close the scene on the viewer. Int_t AddObject(const TBuffer3D& buffer, Bool_t* addChildren = 0); Add an 3D object described by the buffer to the viewer. Returns flags; to indicate:; i) if extra sections of the buffer need completing.; ii) if child objects of the buffer object should be added (always true). Int_t AddObject(UInt_t placedID, const TBuffer3D& buffer, Bool_t* addChildren = 0); We don't support placed ID shapes - ID is discarded. Bool_t OpenComposite(const TBuffer3D& buffer, Bool_t* addChildren = 0); Composite shapes not supported on this viewer currently - ignore.; Will result in a set of individual component shapes. void CloseComposite(); {}. void AddCompositeOp(UInt_t operation); {}. TViewer3DPad(const TViewer3DPad& );",MatchSource.WIKI,root/html532/TViewer3DPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TViewer3DPad.html
https://root.cern/root/html532/TViewer3DPad.html:2715,Security,Hash,Hash,2715,"l voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); virtual voidTVirtualViewer3D::ObjectPaint(TObject*, Option_t* = """"); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Bool_tOpenComposite(const TBuffer3D& buffer, Bool_t* addChildren = 0); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* p",MatchSource.WIKI,root/html532/TViewer3DPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TViewer3DPad.html
https://root.cern/root/html532/TViewer3DPad.html:5247,Testability,Test,TestBit,5247," delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTVirtualViewer3D::PadPaint(TVirtualPad*); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual Bool_tPreferLocalFrame() const; virtual voidTObject::Print(Option_t* option = """") const; virtual voidTVirtualViewer3D::PrintObjects(); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTVirtualViewer3D::ResetCameras(); virtual voidTVirtualViewer3D::ResetCamerasAfterNextUpdate(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual TObject*TVirtualViewer3D::SelectObject(Int_t, Int_t); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); static TVirtualViewer3D*TVirtualViewer3D::Viewer3D(TVirtualPad* pad = 0, Option_t* type = """"); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TViewer3DPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TViewer3DPad.html
https://root.cern/root/html532/TViewer3DPad.html:5286,Testability,Test,TestBits,5286," delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTVirtualViewer3D::PadPaint(TVirtualPad*); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual Bool_tPreferLocalFrame() const; virtual voidTObject::Print(Option_t* option = """") const; virtual voidTVirtualViewer3D::PrintObjects(); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTVirtualViewer3D::ResetCameras(); virtual voidTVirtualViewer3D::ResetCamerasAfterNextUpdate(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual TObject*TVirtualViewer3D::SelectObject(Int_t, Int_t); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); static TVirtualViewer3D*TVirtualViewer3D::Viewer3D(TVirtualPad* pad = 0, Option_t* type = """"); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TViewer3DPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TViewer3DPad.html
https://root.cern/root/html532/TViewer3DPad.html:1094,Usability,Clear,Clear,1094," TViewer3DPad(TVirtualPad& pad); virtual~TViewer3DPad(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddCompositeOp(UInt_t operation); virtual Int_tAddObject(const TBuffer3D& buffer, Bool_t* addChildren = 0); virtual Int_tAddObject(UInt_t placedID, const TBuffer3D& buffer, Bool_t* addChildren = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBeginScene(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tBuildingScene() const; virtual Bool_tTVirtualViewer3D::CanLoopOnPrimitives() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseComposite(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTVirtualViewer3D::DrawViewer(); virtual voidTObject::Dump() constMENU ; virtual voidEndScene(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t even",MatchSource.WIKI,root/html532/TViewer3DPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TViewer3DPad.html
https://root.cern/root/html532/TViewerX3D.html:1922,Availability,Error,Error,1922,"buffer, Bool_t* addChildren = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBeginScene(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tBuildingScene() const; virtual Bool_tTVirtualViewer3D::CanLoopOnPrimitives() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidClose(); virtual voidCloseComposite(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTVirtualViewer3D::DrawViewer(); virtual voidTObject::Dump() constMENU ; virtual voidEndScene(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; Int_tExecCommand(Int_t px, Int_t py, char command); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; voidGetPosition(Float_t& longitude, Float_t& latitude, Float_t& psi); virtual const char*TObject::GetTitle() const; virtual UInt_tTOb",MatchSource.WIKI,root/html532/TViewerX3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TViewerX3D.html
https://root.cern/root/html532/TViewerX3D.html:2103,Availability,error,error,2103,"ene() const; virtual Bool_tTVirtualViewer3D::CanLoopOnPrimitives() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidClose(); virtual voidCloseComposite(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTVirtualViewer3D::DrawViewer(); virtual voidTObject::Dump() constMENU ; virtual voidEndScene(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; Int_tExecCommand(Int_t px, Int_t py, char command); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; voidGetPosition(Float_t& longitude, Float_t& latitude, Float_t& psi); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; voidIconify(); virtual voidTObject::Info(const char* method, cons",MatchSource.WIKI,root/html532/TViewerX3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TViewerX3D.html
https://root.cern/root/html532/TViewerX3D.html:2187,Availability,error,error,2187,"ass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidClose(); virtual voidCloseComposite(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTVirtualViewer3D::DrawViewer(); virtual voidTObject::Dump() constMENU ; virtual voidEndScene(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; Int_tExecCommand(Int_t px, Int_t py, char command); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; voidGetPosition(Float_t& longitude, Float_t& latitude, Float_t& psi); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; voidIconify(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) co",MatchSource.WIKI,root/html532/TViewerX3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TViewerX3D.html
https://root.cern/root/html532/TViewerX3D.html:8964,Availability,down,down,8964,"OOT X3D viewer. void Close(); Close X3D Viewer. void CreateViewer(const char* name); Create the actual canvas. void InitX3DWindow(); Setup geometry and initialize X3D. void BeginScene(); The x3d viewer cannot rebuild a scene once created. void EndScene(); The x3d viewer cannot rebuild a scene once created. Int_t AddObject(const TBuffer3D& buffer, Bool_t* addChildren = 0); The x3d viewer cannot rebuild a scene once created. Int_t AddObject(UInt_t placedID, const TBuffer3D& buffer, Bool_t* addChildren = 0); We don't support placed IDs - discard. void PaintPolyMarker(const TBuffer3D& buffer) const; Paint 3D PolyMarker. Int_t ExecCommand(Int_t px, Int_t py, char command); This function may be called from a script to animate an X3D picture; px, py mouse position; command = 0 --- move to px,py; = w --- wireframe mode; = e --- hidden line mode; = r --- hidden surface mode; = u --- move object down; = i --- move object up; = o --- toggle controls style; = s --- toggle stereo display; = d --- toggle blue stereo view; = f --- toggle double buffer; = h --- move object right; = j --- move object forward; = k --- move object backward; = l --- move object left; = x a --- rotate about x; = y b --- rotate about y; = z c --- rotate about z; = 1 2 3 --- autorotate about x; = 4 5 6 --- autorotate about y; = 7 8 9 --- autorotate about z; = [ ] { } --- adjust focus; Example:. {; gSystem->Load(""libX3d"");; TCanvas *c1 = new TCanvas(""c1"");; TFile *f = new TFile(""hsimple.root"");; TTree *ntuple = (TTree*)f->Get(""ntuple"");; ntuple->SetMarkerColor(kYellow);; ntuple->Draw(""px:py:pz"");; TViewerX3D *x3d = new TViewerX3D(c1,"""");; for (Int_t i=0;i<500;i++) {; Int_t px = i%500;; Int_t py = (2*i)%200;; x3d->ExecCommand(px,py,0); //rotate; if (i%20 >10) x3d->ExecCommand(px,py,'j'); //zoom; if (i%20 <10) x3d->ExecCommand(px,py,'k'); //unzoom; }; }. void GetPosition(Float_t& longitude, Float_t& latitude, Float_t& psi); Get position. void DeleteX3DWindow(); Close X3D window. void Update(); Update X3D vie",MatchSource.WIKI,root/html532/TViewerX3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TViewerX3D.html
https://root.cern/root/html532/TViewerX3D.html:9002,Deployability,toggle,toggle,9002,"OOT X3D viewer. void Close(); Close X3D Viewer. void CreateViewer(const char* name); Create the actual canvas. void InitX3DWindow(); Setup geometry and initialize X3D. void BeginScene(); The x3d viewer cannot rebuild a scene once created. void EndScene(); The x3d viewer cannot rebuild a scene once created. Int_t AddObject(const TBuffer3D& buffer, Bool_t* addChildren = 0); The x3d viewer cannot rebuild a scene once created. Int_t AddObject(UInt_t placedID, const TBuffer3D& buffer, Bool_t* addChildren = 0); We don't support placed IDs - discard. void PaintPolyMarker(const TBuffer3D& buffer) const; Paint 3D PolyMarker. Int_t ExecCommand(Int_t px, Int_t py, char command); This function may be called from a script to animate an X3D picture; px, py mouse position; command = 0 --- move to px,py; = w --- wireframe mode; = e --- hidden line mode; = r --- hidden surface mode; = u --- move object down; = i --- move object up; = o --- toggle controls style; = s --- toggle stereo display; = d --- toggle blue stereo view; = f --- toggle double buffer; = h --- move object right; = j --- move object forward; = k --- move object backward; = l --- move object left; = x a --- rotate about x; = y b --- rotate about y; = z c --- rotate about z; = 1 2 3 --- autorotate about x; = 4 5 6 --- autorotate about y; = 7 8 9 --- autorotate about z; = [ ] { } --- adjust focus; Example:. {; gSystem->Load(""libX3d"");; TCanvas *c1 = new TCanvas(""c1"");; TFile *f = new TFile(""hsimple.root"");; TTree *ntuple = (TTree*)f->Get(""ntuple"");; ntuple->SetMarkerColor(kYellow);; ntuple->Draw(""px:py:pz"");; TViewerX3D *x3d = new TViewerX3D(c1,"""");; for (Int_t i=0;i<500;i++) {; Int_t px = i%500;; Int_t py = (2*i)%200;; x3d->ExecCommand(px,py,0); //rotate; if (i%20 >10) x3d->ExecCommand(px,py,'j'); //zoom; if (i%20 <10) x3d->ExecCommand(px,py,'k'); //unzoom; }; }. void GetPosition(Float_t& longitude, Float_t& latitude, Float_t& psi); Get position. void DeleteX3DWindow(); Close X3D window. void Update(); Update X3D vie",MatchSource.WIKI,root/html532/TViewerX3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TViewerX3D.html
https://root.cern/root/html532/TViewerX3D.html:9033,Deployability,toggle,toggle,9033,"OOT X3D viewer. void Close(); Close X3D Viewer. void CreateViewer(const char* name); Create the actual canvas. void InitX3DWindow(); Setup geometry and initialize X3D. void BeginScene(); The x3d viewer cannot rebuild a scene once created. void EndScene(); The x3d viewer cannot rebuild a scene once created. Int_t AddObject(const TBuffer3D& buffer, Bool_t* addChildren = 0); The x3d viewer cannot rebuild a scene once created. Int_t AddObject(UInt_t placedID, const TBuffer3D& buffer, Bool_t* addChildren = 0); We don't support placed IDs - discard. void PaintPolyMarker(const TBuffer3D& buffer) const; Paint 3D PolyMarker. Int_t ExecCommand(Int_t px, Int_t py, char command); This function may be called from a script to animate an X3D picture; px, py mouse position; command = 0 --- move to px,py; = w --- wireframe mode; = e --- hidden line mode; = r --- hidden surface mode; = u --- move object down; = i --- move object up; = o --- toggle controls style; = s --- toggle stereo display; = d --- toggle blue stereo view; = f --- toggle double buffer; = h --- move object right; = j --- move object forward; = k --- move object backward; = l --- move object left; = x a --- rotate about x; = y b --- rotate about y; = z c --- rotate about z; = 1 2 3 --- autorotate about x; = 4 5 6 --- autorotate about y; = 7 8 9 --- autorotate about z; = [ ] { } --- adjust focus; Example:. {; gSystem->Load(""libX3d"");; TCanvas *c1 = new TCanvas(""c1"");; TFile *f = new TFile(""hsimple.root"");; TTree *ntuple = (TTree*)f->Get(""ntuple"");; ntuple->SetMarkerColor(kYellow);; ntuple->Draw(""px:py:pz"");; TViewerX3D *x3d = new TViewerX3D(c1,"""");; for (Int_t i=0;i<500;i++) {; Int_t px = i%500;; Int_t py = (2*i)%200;; x3d->ExecCommand(px,py,0); //rotate; if (i%20 >10) x3d->ExecCommand(px,py,'j'); //zoom; if (i%20 <10) x3d->ExecCommand(px,py,'k'); //unzoom; }; }. void GetPosition(Float_t& longitude, Float_t& latitude, Float_t& psi); Get position. void DeleteX3DWindow(); Close X3D window. void Update(); Update X3D vie",MatchSource.WIKI,root/html532/TViewerX3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TViewerX3D.html
https://root.cern/root/html532/TViewerX3D.html:9064,Deployability,toggle,toggle,9064,"OOT X3D viewer. void Close(); Close X3D Viewer. void CreateViewer(const char* name); Create the actual canvas. void InitX3DWindow(); Setup geometry and initialize X3D. void BeginScene(); The x3d viewer cannot rebuild a scene once created. void EndScene(); The x3d viewer cannot rebuild a scene once created. Int_t AddObject(const TBuffer3D& buffer, Bool_t* addChildren = 0); The x3d viewer cannot rebuild a scene once created. Int_t AddObject(UInt_t placedID, const TBuffer3D& buffer, Bool_t* addChildren = 0); We don't support placed IDs - discard. void PaintPolyMarker(const TBuffer3D& buffer) const; Paint 3D PolyMarker. Int_t ExecCommand(Int_t px, Int_t py, char command); This function may be called from a script to animate an X3D picture; px, py mouse position; command = 0 --- move to px,py; = w --- wireframe mode; = e --- hidden line mode; = r --- hidden surface mode; = u --- move object down; = i --- move object up; = o --- toggle controls style; = s --- toggle stereo display; = d --- toggle blue stereo view; = f --- toggle double buffer; = h --- move object right; = j --- move object forward; = k --- move object backward; = l --- move object left; = x a --- rotate about x; = y b --- rotate about y; = z c --- rotate about z; = 1 2 3 --- autorotate about x; = 4 5 6 --- autorotate about y; = 7 8 9 --- autorotate about z; = [ ] { } --- adjust focus; Example:. {; gSystem->Load(""libX3d"");; TCanvas *c1 = new TCanvas(""c1"");; TFile *f = new TFile(""hsimple.root"");; TTree *ntuple = (TTree*)f->Get(""ntuple"");; ntuple->SetMarkerColor(kYellow);; ntuple->Draw(""px:py:pz"");; TViewerX3D *x3d = new TViewerX3D(c1,"""");; for (Int_t i=0;i<500;i++) {; Int_t px = i%500;; Int_t py = (2*i)%200;; x3d->ExecCommand(px,py,0); //rotate; if (i%20 >10) x3d->ExecCommand(px,py,'j'); //zoom; if (i%20 <10) x3d->ExecCommand(px,py,'k'); //unzoom; }; }. void GetPosition(Float_t& longitude, Float_t& latitude, Float_t& psi); Get position. void DeleteX3DWindow(); Close X3D window. void Update(); Update X3D vie",MatchSource.WIKI,root/html532/TViewerX3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TViewerX3D.html
https://root.cern/root/html532/TViewerX3D.html:9097,Deployability,toggle,toggle,9097,"OOT X3D viewer. void Close(); Close X3D Viewer. void CreateViewer(const char* name); Create the actual canvas. void InitX3DWindow(); Setup geometry and initialize X3D. void BeginScene(); The x3d viewer cannot rebuild a scene once created. void EndScene(); The x3d viewer cannot rebuild a scene once created. Int_t AddObject(const TBuffer3D& buffer, Bool_t* addChildren = 0); The x3d viewer cannot rebuild a scene once created. Int_t AddObject(UInt_t placedID, const TBuffer3D& buffer, Bool_t* addChildren = 0); We don't support placed IDs - discard. void PaintPolyMarker(const TBuffer3D& buffer) const; Paint 3D PolyMarker. Int_t ExecCommand(Int_t px, Int_t py, char command); This function may be called from a script to animate an X3D picture; px, py mouse position; command = 0 --- move to px,py; = w --- wireframe mode; = e --- hidden line mode; = r --- hidden surface mode; = u --- move object down; = i --- move object up; = o --- toggle controls style; = s --- toggle stereo display; = d --- toggle blue stereo view; = f --- toggle double buffer; = h --- move object right; = j --- move object forward; = k --- move object backward; = l --- move object left; = x a --- rotate about x; = y b --- rotate about y; = z c --- rotate about z; = 1 2 3 --- autorotate about x; = 4 5 6 --- autorotate about y; = 7 8 9 --- autorotate about z; = [ ] { } --- adjust focus; Example:. {; gSystem->Load(""libX3d"");; TCanvas *c1 = new TCanvas(""c1"");; TFile *f = new TFile(""hsimple.root"");; TTree *ntuple = (TTree*)f->Get(""ntuple"");; ntuple->SetMarkerColor(kYellow);; ntuple->Draw(""px:py:pz"");; TViewerX3D *x3d = new TViewerX3D(c1,"""");; for (Int_t i=0;i<500;i++) {; Int_t px = i%500;; Int_t py = (2*i)%200;; x3d->ExecCommand(px,py,0); //rotate; if (i%20 >10) x3d->ExecCommand(px,py,'j'); //zoom; if (i%20 <10) x3d->ExecCommand(px,py,'k'); //unzoom; }; }. void GetPosition(Float_t& longitude, Float_t& latitude, Float_t& psi); Get position. void DeleteX3DWindow(); Close X3D window. void Update(); Update X3D vie",MatchSource.WIKI,root/html532/TViewerX3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TViewerX3D.html
https://root.cern/root/html532/TViewerX3D.html:10041,Deployability,Update,Update,10041,"ay; = d --- toggle blue stereo view; = f --- toggle double buffer; = h --- move object right; = j --- move object forward; = k --- move object backward; = l --- move object left; = x a --- rotate about x; = y b --- rotate about y; = z c --- rotate about z; = 1 2 3 --- autorotate about x; = 4 5 6 --- autorotate about y; = 7 8 9 --- autorotate about z; = [ ] { } --- adjust focus; Example:. {; gSystem->Load(""libX3d"");; TCanvas *c1 = new TCanvas(""c1"");; TFile *f = new TFile(""hsimple.root"");; TTree *ntuple = (TTree*)f->Get(""ntuple"");; ntuple->SetMarkerColor(kYellow);; ntuple->Draw(""px:py:pz"");; TViewerX3D *x3d = new TViewerX3D(c1,"""");; for (Int_t i=0;i<500;i++) {; Int_t px = i%500;; Int_t py = (2*i)%200;; x3d->ExecCommand(px,py,0); //rotate; if (i%20 >10) x3d->ExecCommand(px,py,'j'); //zoom; if (i%20 <10) x3d->ExecCommand(px,py,'k'); //unzoom; }; }. void GetPosition(Float_t& longitude, Float_t& latitude, Float_t& psi); Get position. void DeleteX3DWindow(); Close X3D window. void Update(); Update X3D viewer. Bool_t ProcessFrameMessage(Long_t msg, Long_t parm1, Long_t parm2); Handle menu and other command generated by the user. Bool_t HandleContainerButton(Event_t* ev); After button release get current position and update associated pad. TViewerX3D(TVirtualPad* pad). void Iconify(); { }. void Show(); { fMainFrame->MapRaised(); }. Bool_t PreferLocalFrame() const; TVirtualViewer3D interface. { return kFALSE; }. Bool_t BuildingScene() const; { return fBuildingScene; }. Bool_t OpenComposite(const TBuffer3D& , Bool_t* = 0); Composite shapes not supported on this viewer currently - ignore.; Will result in a set of component shapes. { return kTRUE; }. void CloseComposite(); {}. void AddCompositeOp(UInt_t ); {}. » Author: Rene Brun 05/09/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/x3d:$Id: TViewerX3D.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions",MatchSource.WIKI,root/html532/TViewerX3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TViewerX3D.html
https://root.cern/root/html532/TViewerX3D.html:10051,Deployability,Update,Update,10051,"ay; = d --- toggle blue stereo view; = f --- toggle double buffer; = h --- move object right; = j --- move object forward; = k --- move object backward; = l --- move object left; = x a --- rotate about x; = y b --- rotate about y; = z c --- rotate about z; = 1 2 3 --- autorotate about x; = 4 5 6 --- autorotate about y; = 7 8 9 --- autorotate about z; = [ ] { } --- adjust focus; Example:. {; gSystem->Load(""libX3d"");; TCanvas *c1 = new TCanvas(""c1"");; TFile *f = new TFile(""hsimple.root"");; TTree *ntuple = (TTree*)f->Get(""ntuple"");; ntuple->SetMarkerColor(kYellow);; ntuple->Draw(""px:py:pz"");; TViewerX3D *x3d = new TViewerX3D(c1,"""");; for (Int_t i=0;i<500;i++) {; Int_t px = i%500;; Int_t py = (2*i)%200;; x3d->ExecCommand(px,py,0); //rotate; if (i%20 >10) x3d->ExecCommand(px,py,'j'); //zoom; if (i%20 <10) x3d->ExecCommand(px,py,'k'); //unzoom; }; }. void GetPosition(Float_t& longitude, Float_t& latitude, Float_t& psi); Get position. void DeleteX3DWindow(); Close X3D window. void Update(); Update X3D viewer. Bool_t ProcessFrameMessage(Long_t msg, Long_t parm1, Long_t parm2); Handle menu and other command generated by the user. Bool_t HandleContainerButton(Event_t* ev); After button release get current position and update associated pad. TViewerX3D(TVirtualPad* pad). void Iconify(); { }. void Show(); { fMainFrame->MapRaised(); }. Bool_t PreferLocalFrame() const; TVirtualViewer3D interface. { return kFALSE; }. Bool_t BuildingScene() const; { return fBuildingScene; }. Bool_t OpenComposite(const TBuffer3D& , Bool_t* = 0); Composite shapes not supported on this viewer currently - ignore.; Will result in a set of component shapes. { return kTRUE; }. void CloseComposite(); {}. void AddCompositeOp(UInt_t ); {}. » Author: Rene Brun 05/09/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/x3d:$Id: TViewerX3D.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions",MatchSource.WIKI,root/html532/TViewerX3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TViewerX3D.html
https://root.cern/root/html532/TViewerX3D.html:10247,Deployability,release,release,10247,"ct right; = j --- move object forward; = k --- move object backward; = l --- move object left; = x a --- rotate about x; = y b --- rotate about y; = z c --- rotate about z; = 1 2 3 --- autorotate about x; = 4 5 6 --- autorotate about y; = 7 8 9 --- autorotate about z; = [ ] { } --- adjust focus; Example:. {; gSystem->Load(""libX3d"");; TCanvas *c1 = new TCanvas(""c1"");; TFile *f = new TFile(""hsimple.root"");; TTree *ntuple = (TTree*)f->Get(""ntuple"");; ntuple->SetMarkerColor(kYellow);; ntuple->Draw(""px:py:pz"");; TViewerX3D *x3d = new TViewerX3D(c1,"""");; for (Int_t i=0;i<500;i++) {; Int_t px = i%500;; Int_t py = (2*i)%200;; x3d->ExecCommand(px,py,0); //rotate; if (i%20 >10) x3d->ExecCommand(px,py,'j'); //zoom; if (i%20 <10) x3d->ExecCommand(px,py,'k'); //unzoom; }; }. void GetPosition(Float_t& longitude, Float_t& latitude, Float_t& psi); Get position. void DeleteX3DWindow(); Close X3D window. void Update(); Update X3D viewer. Bool_t ProcessFrameMessage(Long_t msg, Long_t parm1, Long_t parm2); Handle menu and other command generated by the user. Bool_t HandleContainerButton(Event_t* ev); After button release get current position and update associated pad. TViewerX3D(TVirtualPad* pad). void Iconify(); { }. void Show(); { fMainFrame->MapRaised(); }. Bool_t PreferLocalFrame() const; TVirtualViewer3D interface. { return kFALSE; }. Bool_t BuildingScene() const; { return fBuildingScene; }. Bool_t OpenComposite(const TBuffer3D& , Bool_t* = 0); Composite shapes not supported on this viewer currently - ignore.; Will result in a set of component shapes. { return kTRUE; }. void CloseComposite(); {}. void AddCompositeOp(UInt_t ); {}. » Author: Rene Brun 05/09/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/x3d:$Id: TViewerX3D.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TViewerX3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TViewerX3D.html
https://root.cern/root/html532/TViewerX3D.html:10280,Deployability,update,update,10280,"ct right; = j --- move object forward; = k --- move object backward; = l --- move object left; = x a --- rotate about x; = y b --- rotate about y; = z c --- rotate about z; = 1 2 3 --- autorotate about x; = 4 5 6 --- autorotate about y; = 7 8 9 --- autorotate about z; = [ ] { } --- adjust focus; Example:. {; gSystem->Load(""libX3d"");; TCanvas *c1 = new TCanvas(""c1"");; TFile *f = new TFile(""hsimple.root"");; TTree *ntuple = (TTree*)f->Get(""ntuple"");; ntuple->SetMarkerColor(kYellow);; ntuple->Draw(""px:py:pz"");; TViewerX3D *x3d = new TViewerX3D(c1,"""");; for (Int_t i=0;i<500;i++) {; Int_t px = i%500;; Int_t py = (2*i)%200;; x3d->ExecCommand(px,py,0); //rotate; if (i%20 >10) x3d->ExecCommand(px,py,'j'); //zoom; if (i%20 <10) x3d->ExecCommand(px,py,'k'); //unzoom; }; }. void GetPosition(Float_t& longitude, Float_t& latitude, Float_t& psi); Get position. void DeleteX3DWindow(); Close X3D window. void Update(); Update X3D viewer. Bool_t ProcessFrameMessage(Long_t msg, Long_t parm1, Long_t parm2); Handle menu and other command generated by the user. Bool_t HandleContainerButton(Event_t* ev); After button release get current position and update associated pad. TViewerX3D(TVirtualPad* pad). void Iconify(); { }. void Show(); { fMainFrame->MapRaised(); }. Bool_t PreferLocalFrame() const; TVirtualViewer3D interface. { return kFALSE; }. Bool_t BuildingScene() const; { return fBuildingScene; }. Bool_t OpenComposite(const TBuffer3D& , Bool_t* = 0); Composite shapes not supported on this viewer currently - ignore.; Will result in a set of component shapes. { return kTRUE; }. void CloseComposite(); {}. void AddCompositeOp(UInt_t ); {}. » Author: Rene Brun 05/09/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/x3d:$Id: TViewerX3D.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TViewerX3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TViewerX3D.html
https://root.cern/root/html532/TViewerX3D.html:317,Integrability,interface,interface,317,". TViewerX3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » X3D; » TViewerX3D. class TViewerX3D: public TVirtualViewer3D. TViewerX3D. C++ interface to the X3D viewer. Function Members (Methods); public:. TViewerX3D(TVirtualPad* pad); TViewerX3D(const TViewerX3D&); TViewerX3D(TVirtualPad* pad, Option_t* option, const char* title = ""X3D Viewer"", UInt_t width = 800, UInt_t height = 600); TViewerX3D(TVirtualPad* pad, Option_t* option, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height); virtual~TViewerX3D(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddCompositeOp(UInt_t); virtual Int_tAddObject(const TBuffer3D& buffer, Bool_t* addChildren = 0); virtual Int_tAddObject(UInt_t placedID, const TBuffer3D& buffer, Bool_t* addChildren = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBeginScene(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tBuildingScene() const; virtual Bool_tTVirtualViewer3D::CanLoopOnPrimitives() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidClose(); virtual voidCloseComposite(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTVirtualViewer3D::DrawViewer(); virtual voidTObject::Dump() constMENU ; virtual voidEndScene(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; Int_tExecCommand(Int_t px,",MatchSource.WIKI,root/html532/TViewerX3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TViewerX3D.html
https://root.cern/root/html532/TViewerX3D.html:10447,Integrability,interface,interface,10447,"ct right; = j --- move object forward; = k --- move object backward; = l --- move object left; = x a --- rotate about x; = y b --- rotate about y; = z c --- rotate about z; = 1 2 3 --- autorotate about x; = 4 5 6 --- autorotate about y; = 7 8 9 --- autorotate about z; = [ ] { } --- adjust focus; Example:. {; gSystem->Load(""libX3d"");; TCanvas *c1 = new TCanvas(""c1"");; TFile *f = new TFile(""hsimple.root"");; TTree *ntuple = (TTree*)f->Get(""ntuple"");; ntuple->SetMarkerColor(kYellow);; ntuple->Draw(""px:py:pz"");; TViewerX3D *x3d = new TViewerX3D(c1,"""");; for (Int_t i=0;i<500;i++) {; Int_t px = i%500;; Int_t py = (2*i)%200;; x3d->ExecCommand(px,py,0); //rotate; if (i%20 >10) x3d->ExecCommand(px,py,'j'); //zoom; if (i%20 <10) x3d->ExecCommand(px,py,'k'); //unzoom; }; }. void GetPosition(Float_t& longitude, Float_t& latitude, Float_t& psi); Get position. void DeleteX3DWindow(); Close X3D window. void Update(); Update X3D viewer. Bool_t ProcessFrameMessage(Long_t msg, Long_t parm1, Long_t parm2); Handle menu and other command generated by the user. Bool_t HandleContainerButton(Event_t* ev); After button release get current position and update associated pad. TViewerX3D(TVirtualPad* pad). void Iconify(); { }. void Show(); { fMainFrame->MapRaised(); }. Bool_t PreferLocalFrame() const; TVirtualViewer3D interface. { return kFALSE; }. Bool_t BuildingScene() const; { return fBuildingScene; }. Bool_t OpenComposite(const TBuffer3D& , Bool_t* = 0); Composite shapes not supported on this viewer currently - ignore.; Will result in a set of component shapes. { return kTRUE; }. void CloseComposite(); {}. void AddCompositeOp(UInt_t ); {}. » Author: Rene Brun 05/09/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/x3d:$Id: TViewerX3D.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TViewerX3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TViewerX3D.html
https://root.cern/root/html532/TViewerX3D.html:3152,Modifiability,Inherit,InheritsFrom,3152,"d, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; voidGetPosition(Float_t& longitude, Float_t& latitude, Float_t& psi); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; voidIconify(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); virtual voidTVirtualViewer3D::ObjectPaint(TObject*, Option_t* = """"); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Bool_tOpenComposite(const TBuffer3D&, Bool_t* = 0); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TOb",MatchSource.WIKI,root/html532/TViewerX3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TViewerX3D.html
https://root.cern/root/html532/TViewerX3D.html:3218,Modifiability,Inherit,InheritsFrom,3218,"uteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; voidGetPosition(Float_t& longitude, Float_t& latitude, Float_t& psi); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; voidIconify(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); virtual voidTVirtualViewer3D::ObjectPaint(TObject*, Option_t* = """"); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Bool_tOpenComposite(const TBuffer3D&, Bool_t* = 0); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t s",MatchSource.WIKI,root/html532/TViewerX3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TViewerX3D.html
https://root.cern/root/html532/TViewerX3D.html:7626,Modifiability,Inherit,Inheritance,7626,"dObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Bool_tfBuildingSceneRebuilding 3D scene; TGCanvas*fCanvascanvas widget; TGLayoutHints*fCanvasLayoutlayout for canvas widget; TX3DContainer*fContainercontainer containing X3D window; TGPopupMenu*fFileMenufile menu; UInt_tfHeightviewer height; TGPopupMenu*fHelpMenuhelp menu; TX3DFrame*fMainFramethe main GUI frame; TGMenuBar*fMenuBarmenubar; TGLayoutHints*fMenuBarHelpLayoutlayout hint for help menu in menubar; TGLayoutHints*fMenuBarItemLayoutlayout hints for menu in menubar; TGLayoutHints*fMenuBarLayoutmenubar layout hints; TStringfOptionoption string to be passed to X3D; TVirtualPad*fPadpad we are attached to; TViewerX3D::EPassfPass; TStringfTitleviewer title; UInt_tfWidthviewer width; Window_tfX3DWinX3D window; Int_tfXPosviewer X position; Int_tfYPosviewer Y position; static Bool_tfgCreatedTViewerX3D is a singleton. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TViewerX3D(TVirtualPad* pad); Create ROOT X3D viewer. TViewerX3D(TVirtualPad* pad, Option_t* option, const char* title = ""X3D Viewer"", UInt_t width = 800, UInt_t height = 600); Create ROOT X3D viewer. TViewerX3D(TVirtualPad* pad, Option_t* option, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height); Create ROOT X3D viewer. ~TViewerX3D(); Delete ROOT X3D viewer. void Close(); Close X3D Viewer. void CreateViewer(const char* name); Create the actual canvas. void InitX3DWindow(); Setup geometry and initialize X3D. void BeginScene(); The x3d viewer cannot rebuild a scene once created. void EndScene(); The x3d viewer cannot rebuild a scene once created. Int_t AddObject(const TBuffer3D& buffer, Bool_t* addChildren = 0); The x3d viewer cannot rebuild a scene once created. Int_t AddObject(UInt_t placedID, const TBuffer3D& buffer, Bool_t* addChildren = 0); We don't support placed IDs - discard. void PaintPolyMarker(const TBuffer3D&",MatchSource.WIKI,root/html532/TViewerX3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TViewerX3D.html
https://root.cern/root/html532/TViewerX3D.html:7639,Modifiability,Inherit,Inherited,7639,"dObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Bool_tfBuildingSceneRebuilding 3D scene; TGCanvas*fCanvascanvas widget; TGLayoutHints*fCanvasLayoutlayout for canvas widget; TX3DContainer*fContainercontainer containing X3D window; TGPopupMenu*fFileMenufile menu; UInt_tfHeightviewer height; TGPopupMenu*fHelpMenuhelp menu; TX3DFrame*fMainFramethe main GUI frame; TGMenuBar*fMenuBarmenubar; TGLayoutHints*fMenuBarHelpLayoutlayout hint for help menu in menubar; TGLayoutHints*fMenuBarItemLayoutlayout hints for menu in menubar; TGLayoutHints*fMenuBarLayoutmenubar layout hints; TStringfOptionoption string to be passed to X3D; TVirtualPad*fPadpad we are attached to; TViewerX3D::EPassfPass; TStringfTitleviewer title; UInt_tfWidthviewer width; Window_tfX3DWinX3D window; Int_tfXPosviewer X position; Int_tfYPosviewer Y position; static Bool_tfgCreatedTViewerX3D is a singleton. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TViewerX3D(TVirtualPad* pad); Create ROOT X3D viewer. TViewerX3D(TVirtualPad* pad, Option_t* option, const char* title = ""X3D Viewer"", UInt_t width = 800, UInt_t height = 600); Create ROOT X3D viewer. TViewerX3D(TVirtualPad* pad, Option_t* option, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height); Create ROOT X3D viewer. ~TViewerX3D(); Delete ROOT X3D viewer. void Close(); Close X3D Viewer. void CreateViewer(const char* name); Create the actual canvas. void InitX3DWindow(); Setup geometry and initialize X3D. void BeginScene(); The x3d viewer cannot rebuild a scene once created. void EndScene(); The x3d viewer cannot rebuild a scene once created. Int_t AddObject(const TBuffer3D& buffer, Bool_t* addChildren = 0); The x3d viewer cannot rebuild a scene once created. Int_t AddObject(UInt_t placedID, const TBuffer3D& buffer, Bool_t* addChildren = 0); We don't support placed IDs - discard. void PaintPolyMarker(const TBuffer3D&",MatchSource.WIKI,root/html532/TViewerX3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TViewerX3D.html
https://root.cern/root/html532/TViewerX3D.html:9455,Performance,Load,Load,9455,"d. Int_t AddObject(UInt_t placedID, const TBuffer3D& buffer, Bool_t* addChildren = 0); We don't support placed IDs - discard. void PaintPolyMarker(const TBuffer3D& buffer) const; Paint 3D PolyMarker. Int_t ExecCommand(Int_t px, Int_t py, char command); This function may be called from a script to animate an X3D picture; px, py mouse position; command = 0 --- move to px,py; = w --- wireframe mode; = e --- hidden line mode; = r --- hidden surface mode; = u --- move object down; = i --- move object up; = o --- toggle controls style; = s --- toggle stereo display; = d --- toggle blue stereo view; = f --- toggle double buffer; = h --- move object right; = j --- move object forward; = k --- move object backward; = l --- move object left; = x a --- rotate about x; = y b --- rotate about y; = z c --- rotate about z; = 1 2 3 --- autorotate about x; = 4 5 6 --- autorotate about y; = 7 8 9 --- autorotate about z; = [ ] { } --- adjust focus; Example:. {; gSystem->Load(""libX3d"");; TCanvas *c1 = new TCanvas(""c1"");; TFile *f = new TFile(""hsimple.root"");; TTree *ntuple = (TTree*)f->Get(""ntuple"");; ntuple->SetMarkerColor(kYellow);; ntuple->Draw(""px:py:pz"");; TViewerX3D *x3d = new TViewerX3D(c1,"""");; for (Int_t i=0;i<500;i++) {; Int_t px = i%500;; Int_t py = (2*i)%200;; x3d->ExecCommand(px,py,0); //rotate; if (i%20 >10) x3d->ExecCommand(px,py,'j'); //zoom; if (i%20 <10) x3d->ExecCommand(px,py,'k'); //unzoom; }; }. void GetPosition(Float_t& longitude, Float_t& latitude, Float_t& psi); Get position. void DeleteX3DWindow(); Close X3D window. void Update(); Update X3D viewer. Bool_t ProcessFrameMessage(Long_t msg, Long_t parm1, Long_t parm2); Handle menu and other command generated by the user. Bool_t HandleContainerButton(Event_t* ev); After button release get current position and update associated pad. TViewerX3D(TVirtualPad* pad). void Iconify(); { }. void Show(); { fMainFrame->MapRaised(); }. Bool_t PreferLocalFrame() const; TVirtualViewer3D interface. { return kFALSE; }. Bool_t Buil",MatchSource.WIKI,root/html532/TViewerX3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TViewerX3D.html
https://root.cern/root/html532/TViewerX3D.html:3027,Security,Hash,Hash,3027,"rtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; voidGetPosition(Float_t& longitude, Float_t& latitude, Float_t& psi); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; voidIconify(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); virtual voidTVirtualViewer3D::ObjectPaint(TObject*, Option_t* = """"); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Bool_tOpenComposite(const TBuffer3D&, Bool_t* = 0); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, ",MatchSource.WIKI,root/html532/TViewerX3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TViewerX3D.html
https://root.cern/root/html532/TViewerX3D.html:5727,Testability,Test,TestBit,5727,"bject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TViewerX3D&operator=(const TViewerX3D&); virtual voidTVirtualViewer3D::PadPaint(TVirtualPad*); virtual voidTObject::Paint(Option_t* option = """"); voidPaintPolyMarker(const TBuffer3D& buffer) const; virtual voidTObject::Pop(); virtual Bool_tPreferLocalFrame() const; virtual voidTObject::Print(Option_t* option = """") const; virtual voidTVirtualViewer3D::PrintObjects(); Bool_tProcessFrameMessage(Long_t msg, Long_t parm1, Long_t parm2); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTVirtualViewer3D::ResetCameras(); virtual voidTVirtualViewer3D::ResetCamerasAfterNextUpdate(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual TObject*TVirtualViewer3D::SelectObject(Int_t, Int_t); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); voidShow(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidUpdate(); virtual voidTObject::UseCurrentStyle(); static TVirtualViewer3D*TVirtualViewer3D::Viewer3D(TVirtualPad* pad = 0, Option_t* type = """"); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TViewerX3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TViewerX3D.html
https://root.cern/root/html532/TViewerX3D.html:5766,Testability,Test,TestBits,5766,"bject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TViewerX3D&operator=(const TViewerX3D&); virtual voidTVirtualViewer3D::PadPaint(TVirtualPad*); virtual voidTObject::Paint(Option_t* option = """"); voidPaintPolyMarker(const TBuffer3D& buffer) const; virtual voidTObject::Pop(); virtual Bool_tPreferLocalFrame() const; virtual voidTObject::Print(Option_t* option = """") const; virtual voidTVirtualViewer3D::PrintObjects(); Bool_tProcessFrameMessage(Long_t msg, Long_t parm1, Long_t parm2); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTVirtualViewer3D::ResetCameras(); virtual voidTVirtualViewer3D::ResetCamerasAfterNextUpdate(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual TObject*TVirtualViewer3D::SelectObject(Int_t, Int_t); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); voidShow(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidUpdate(); virtual voidTObject::UseCurrentStyle(); static TVirtualViewer3D*TVirtualViewer3D::Viewer3D(TVirtualPad* pad = 0, Option_t* type = """"); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TViewerX3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TViewerX3D.html
https://root.cern/root/html532/TViewerX3D.html:1271,Usability,Clear,Clear,1271," TViewerX3D(TVirtualPad* pad); TViewerX3D(const TViewerX3D&); TViewerX3D(TVirtualPad* pad, Option_t* option, const char* title = ""X3D Viewer"", UInt_t width = 800, UInt_t height = 600); TViewerX3D(TVirtualPad* pad, Option_t* option, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height); virtual~TViewerX3D(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddCompositeOp(UInt_t); virtual Int_tAddObject(const TBuffer3D& buffer, Bool_t* addChildren = 0); virtual Int_tAddObject(UInt_t placedID, const TBuffer3D& buffer, Bool_t* addChildren = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBeginScene(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tBuildingScene() const; virtual Bool_tTVirtualViewer3D::CanLoopOnPrimitives() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidClose(); virtual voidCloseComposite(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTVirtualViewer3D::DrawViewer(); virtual voidTObject::Dump() constMENU ; virtual voidEndScene(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; Int_tExecCommand(Int_t px,",MatchSource.WIKI,root/html532/TViewerX3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TViewerX3D.html
https://root.cern/root/html532/TVirtualArray.html:271,Integrability,Wrap,Wrapper,271,". TVirtualArray. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TVirtualArray. class TVirtualArray. TVirtualArray. Wrapper around an object and giving indirect access to its content; even if the object is not of a class in the Cint/Reflex dictionary. Function Members (Methods); public:. TVirtualArray(const TVirtualArray&); TVirtualArray(TClass* cl, UInt_t size); ~TVirtualArray(); TClass*GetClass(); char*GetObjectAt(UInt_t ind) const; TVirtualArray&operator=(const TVirtualArray&); char*operator[](UInt_t ind) const; voidSetSize(UInt_t size). Data Members; public:. char*fArray[fSize] ; UInt_tfCapacity; TClassReffClass; UInt_tfSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualArray(TClass* cl, UInt_t size); {}. ~TVirtualArray(); { if (fClass) fClass->DeleteArray( fArray ); }. TClass * GetClass(); { return fClass; }. char * operator[](UInt_t ind) const; { return GetObjectAt(ind); }. char * GetObjectAt(UInt_t ind) const; { return fArray+fClass->Size()*ind; }. void SetSize(UInt_t size); Set the used size of this array to 'size'. If size is greater than the existing; capacity, reallocate the array BUT no data is preserved. » Author: Philippe Canal July, 2008 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id: TVirtualArray.h 41520 2011-10-20 17:10:04Z pcanal $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TVirtualArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualArray.html
https://root.cern/root/html532/TVirtualArray.html:807,Modifiability,Inherit,Inheritance,807,". TVirtualArray. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TVirtualArray. class TVirtualArray. TVirtualArray. Wrapper around an object and giving indirect access to its content; even if the object is not of a class in the Cint/Reflex dictionary. Function Members (Methods); public:. TVirtualArray(const TVirtualArray&); TVirtualArray(TClass* cl, UInt_t size); ~TVirtualArray(); TClass*GetClass(); char*GetObjectAt(UInt_t ind) const; TVirtualArray&operator=(const TVirtualArray&); char*operator[](UInt_t ind) const; voidSetSize(UInt_t size). Data Members; public:. char*fArray[fSize] ; UInt_tfCapacity; TClassReffClass; UInt_tfSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualArray(TClass* cl, UInt_t size); {}. ~TVirtualArray(); { if (fClass) fClass->DeleteArray( fArray ); }. TClass * GetClass(); { return fClass; }. char * operator[](UInt_t ind) const; { return GetObjectAt(ind); }. char * GetObjectAt(UInt_t ind) const; { return fArray+fClass->Size()*ind; }. void SetSize(UInt_t size); Set the used size of this array to 'size'. If size is greater than the existing; capacity, reallocate the array BUT no data is preserved. » Author: Philippe Canal July, 2008 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id: TVirtualArray.h 41520 2011-10-20 17:10:04Z pcanal $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TVirtualArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualArray.html
https://root.cern/root/html532/TVirtualArray.html:820,Modifiability,Inherit,Inherited,820,". TVirtualArray. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TVirtualArray. class TVirtualArray. TVirtualArray. Wrapper around an object and giving indirect access to its content; even if the object is not of a class in the Cint/Reflex dictionary. Function Members (Methods); public:. TVirtualArray(const TVirtualArray&); TVirtualArray(TClass* cl, UInt_t size); ~TVirtualArray(); TClass*GetClass(); char*GetObjectAt(UInt_t ind) const; TVirtualArray&operator=(const TVirtualArray&); char*operator[](UInt_t ind) const; voidSetSize(UInt_t size). Data Members; public:. char*fArray[fSize] ; UInt_tfCapacity; TClassReffClass; UInt_tfSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualArray(TClass* cl, UInt_t size); {}. ~TVirtualArray(); { if (fClass) fClass->DeleteArray( fArray ); }. TClass * GetClass(); { return fClass; }. char * operator[](UInt_t ind) const; { return GetObjectAt(ind); }. char * GetObjectAt(UInt_t ind) const; { return fArray+fClass->Size()*ind; }. void SetSize(UInt_t size); Set the used size of this array to 'size'. If size is greater than the existing; capacity, reallocate the array BUT no data is preserved. » Author: Philippe Canal July, 2008 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id: TVirtualArray.h 41520 2011-10-20 17:10:04Z pcanal $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TVirtualArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualArray.html
https://root.cern/root/html532/TVirtualArray.html:316,Security,access,access,316,". TVirtualArray. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TVirtualArray. class TVirtualArray. TVirtualArray. Wrapper around an object and giving indirect access to its content; even if the object is not of a class in the Cint/Reflex dictionary. Function Members (Methods); public:. TVirtualArray(const TVirtualArray&); TVirtualArray(TClass* cl, UInt_t size); ~TVirtualArray(); TClass*GetClass(); char*GetObjectAt(UInt_t ind) const; TVirtualArray&operator=(const TVirtualArray&); char*operator[](UInt_t ind) const; voidSetSize(UInt_t size). Data Members; public:. char*fArray[fSize] ; UInt_tfCapacity; TClassReffClass; UInt_tfSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualArray(TClass* cl, UInt_t size); {}. ~TVirtualArray(); { if (fClass) fClass->DeleteArray( fArray ); }. TClass * GetClass(); { return fClass; }. char * operator[](UInt_t ind) const; { return GetObjectAt(ind); }. char * GetObjectAt(UInt_t ind) const; { return fArray+fClass->Size()*ind; }. void SetSize(UInt_t size); Set the used size of this array to 'size'. If size is greater than the existing; capacity, reallocate the array BUT no data is preserved. » Author: Philippe Canal July, 2008 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id: TVirtualArray.h 41520 2011-10-20 17:10:04Z pcanal $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TVirtualArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualArray.html
https://root.cern/root/html532/TVirtualAuth.html:456,Availability,avail,available,456,". TVirtualAuth. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualAuth. class TVirtualAuth. TVirtualAuth. Abstract interface for client authentication code. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualAuth(); virtual TSecContext*Authenticate(TSocket*, const char* host, const char* user, Option_t* options); static TClass*Class(); virtual Int_tClientVersion(); virtual voidErrorMsg(const char* where, Int_t ecode); virtual TClass*IsA() const; virtual const char*Name(); TVirtualAuth&operator=(const TVirtualAuth&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualAuth(); { }. TSecContext * Authenticate(TSocket* , const char* host, const char* user, Option_t* options). void ErrorMsg(const char* where, Int_t ecode). const char * Name(). » Author: G. Ganis 08/07/05 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: Thu Nov 3 20:24:07 2011 » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TVirtualAuth.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualAuth.html
https://root.cern/root/html532/TVirtualAuth.html:1157,Availability,Error,ErrorMsg,1157,". TVirtualAuth. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualAuth. class TVirtualAuth. TVirtualAuth. Abstract interface for client authentication code. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualAuth(); virtual TSecContext*Authenticate(TSocket*, const char* host, const char* user, Option_t* options); static TClass*Class(); virtual Int_tClientVersion(); virtual voidErrorMsg(const char* where, Int_t ecode); virtual TClass*IsA() const; virtual const char*Name(); TVirtualAuth&operator=(const TVirtualAuth&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualAuth(); { }. TSecContext * Authenticate(TSocket* , const char* host, const char* user, Option_t* options). void ErrorMsg(const char* where, Int_t ecode). const char * Name(). » Author: G. Ganis 08/07/05 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: Thu Nov 3 20:24:07 2011 » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TVirtualAuth.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualAuth.html
https://root.cern/root/html532/TVirtualAuth.html:280,Integrability,interface,interface,280,". TVirtualAuth. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualAuth. class TVirtualAuth. TVirtualAuth. Abstract interface for client authentication code. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualAuth(); virtual TSecContext*Authenticate(TSocket*, const char* host, const char* user, Option_t* options); static TClass*Class(); virtual Int_tClientVersion(); virtual voidErrorMsg(const char* where, Int_t ecode); virtual TClass*IsA() const; virtual const char*Name(); TVirtualAuth&operator=(const TVirtualAuth&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualAuth(); { }. TSecContext * Authenticate(TSocket* , const char* host, const char* user, Option_t* options). void ErrorMsg(const char* where, Int_t ecode). const char * Name(). » Author: G. Ganis 08/07/05 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: Thu Nov 3 20:24:07 2011 » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TVirtualAuth.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualAuth.html
https://root.cern/root/html532/TVirtualAuth.html:951,Modifiability,Inherit,Inheritance,951,". TVirtualAuth. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualAuth. class TVirtualAuth. TVirtualAuth. Abstract interface for client authentication code. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualAuth(); virtual TSecContext*Authenticate(TSocket*, const char* host, const char* user, Option_t* options); static TClass*Class(); virtual Int_tClientVersion(); virtual voidErrorMsg(const char* where, Int_t ecode); virtual TClass*IsA() const; virtual const char*Name(); TVirtualAuth&operator=(const TVirtualAuth&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualAuth(); { }. TSecContext * Authenticate(TSocket* , const char* host, const char* user, Option_t* options). void ErrorMsg(const char* where, Int_t ecode). const char * Name(). » Author: G. Ganis 08/07/05 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: Thu Nov 3 20:24:07 2011 » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TVirtualAuth.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualAuth.html
https://root.cern/root/html532/TVirtualAuth.html:964,Modifiability,Inherit,Inherited,964,". TVirtualAuth. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualAuth. class TVirtualAuth. TVirtualAuth. Abstract interface for client authentication code. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualAuth(); virtual TSecContext*Authenticate(TSocket*, const char* host, const char* user, Option_t* options); static TClass*Class(); virtual Int_tClientVersion(); virtual voidErrorMsg(const char* where, Int_t ecode); virtual TClass*IsA() const; virtual const char*Name(); TVirtualAuth&operator=(const TVirtualAuth&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualAuth(); { }. TSecContext * Authenticate(TSocket* , const char* host, const char* user, Option_t* options). void ErrorMsg(const char* where, Int_t ecode). const char * Name(). » Author: G. Ganis 08/07/05 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: Thu Nov 3 20:24:07 2011 » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TVirtualAuth.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualAuth.html
https://root.cern/root/html532/TVirtualAuth.html:301,Security,authenticat,authentication,301,". TVirtualAuth. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualAuth. class TVirtualAuth. TVirtualAuth. Abstract interface for client authentication code. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualAuth(); virtual TSecContext*Authenticate(TSocket*, const char* host, const char* user, Option_t* options); static TClass*Class(); virtual Int_tClientVersion(); virtual voidErrorMsg(const char* where, Int_t ecode); virtual TClass*IsA() const; virtual const char*Name(); TVirtualAuth&operator=(const TVirtualAuth&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualAuth(); { }. TSecContext * Authenticate(TSocket* , const char* host, const char* user, Option_t* options). void ErrorMsg(const char* where, Int_t ecode). const char * Name(). » Author: G. Ganis 08/07/05 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: Thu Nov 3 20:24:07 2011 » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TVirtualAuth.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualAuth.html
https://root.cern/root/html532/TVirtualAuth.html:534,Security,Authenticat,Authenticate,534,". TVirtualAuth. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualAuth. class TVirtualAuth. TVirtualAuth. Abstract interface for client authentication code. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualAuth(); virtual TSecContext*Authenticate(TSocket*, const char* host, const char* user, Option_t* options); static TClass*Class(); virtual Int_tClientVersion(); virtual voidErrorMsg(const char* where, Int_t ecode); virtual TClass*IsA() const; virtual const char*Name(); TVirtualAuth&operator=(const TVirtualAuth&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualAuth(); { }. TSecContext * Authenticate(TSocket* , const char* host, const char* user, Option_t* options). void ErrorMsg(const char* where, Int_t ecode). const char * Name(). » Author: G. Ganis 08/07/05 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: Thu Nov 3 20:24:07 2011 » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TVirtualAuth.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualAuth.html
https://root.cern/root/html532/TVirtualAuth.html:1072,Security,Authenticat,Authenticate,1072,". TVirtualAuth. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualAuth. class TVirtualAuth. TVirtualAuth. Abstract interface for client authentication code. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualAuth(); virtual TSecContext*Authenticate(TSocket*, const char* host, const char* user, Option_t* options); static TClass*Class(); virtual Int_tClientVersion(); virtual voidErrorMsg(const char* where, Int_t ecode); virtual TClass*IsA() const; virtual const char*Name(); TVirtualAuth&operator=(const TVirtualAuth&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualAuth(); { }. TSecContext * Authenticate(TSocket* , const char* host, const char* user, Option_t* options). void ErrorMsg(const char* where, Int_t ecode). const char * Name(). » Author: G. Ganis 08/07/05 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: Thu Nov 3 20:24:07 2011 » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TVirtualAuth.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualAuth.html
https://root.cern/root/html532/TVirtualBranchBrowsable.html:3076,Availability,Error,Error,3076,,MatchSource.WIKI,root/html532/TVirtualBranchBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualBranchBrowsable.html
https://root.cern/root/html532/TVirtualBranchBrowsable.html:3205,Availability,error,error,3205,"TVirtualBranchBrowsable(const TVirtualBranchBrowsable&); virtual~TVirtualBranchBrowsable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); static Int_tFillListOfBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const TBranch*GetBranch() const; TClass*GetClassType() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetIconName() const; TList*GetLeaves() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const TVirtualBranchBrowsable*GetParent() const; voidGetScope(TString& scope)",MatchSource.WIKI,root/html532/TVirtualBranchBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualBranchBrowsable.html
https://root.cern/root/html532/TVirtualBranchBrowsable.html:3289,Availability,error,error,3289,"able(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); static Int_tFillListOfBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const TBranch*GetBranch() const; TClass*GetClassType() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetIconName() const; TList*GetLeaves() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const TVirtualBranchBrowsable*GetParent() const; voidGetScope(TString& scope) const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqu",MatchSource.WIKI,root/html532/TVirtualBranchBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualBranchBrowsable.html
https://root.cern/root/html532/TVirtualBranchBrowsable.html:9590,Availability,down,down,9590,"ables_t>fgGeneratorslist of MethodCreateListOfBrowsables_t called by CreateListOfBrowsables; static Bool_tfgGeneratorsSethave we set the generators yet? empty is not good enough - user might have removed them. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualBranchBrowsable(const TBranch* b, TClass* type, Bool_t typeIsPointer, const TVirtualBranchBrowsable* parent = 0); constructor setting all members according to parameters. ~TVirtualBranchBrowsable(); Destructor. Delete our leaves. void Browse(TBrowser* b); Calls TTree::Draw on the method if return type is not a class;; otherwise expands returned object's ""folder"". Int_t FillListOfBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); Askes all registered generators to fill their browsables into; the list. The browsables are generated for a given parent,; or (if 0), for a given branch. The branch is passed down to; leaves of TVirtualBranchBrowsable, too, as we need to access; the branch's TTree to be able to traw. TClass* GetCollectionContainedType(const TBranch* b, const TVirtualBranchBrowsable* parent, TClass*& contained); Check whether the branch (or the parent) contains a collection.; If it does, set ""contained"" to the contained type (if we can; retrieve it) and return the TClass for the collection. Set; ""contained"" to the branch's (or parent's) contained object's; class for non-collections, returning 0. Only one of ""branch"" or ""parent"" can ge given (depending on whether; we are creating browsable objects for a branch or for another; browsable object). TList* GetLeaves() const; Return list of leaves. If not set up yet we'll create them. void GetScope(TString& scope) const; Returns the full name for TTree::Draw to draw *this.; Recursively appends, starting at the top TBranch,; all method / object names with proper reference operators (->, .); depending on fTypeIsPointer. void RegisterDefaultGenerators(); Adds the default genera",MatchSource.WIKI,root/html532/TVirtualBranchBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualBranchBrowsable.html
https://root.cern/root/html532/TVirtualBranchBrowsable.html:10149,Integrability,depend,depending,10149," Browse(TBrowser* b); Calls TTree::Draw on the method if return type is not a class;; otherwise expands returned object's ""folder"". Int_t FillListOfBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); Askes all registered generators to fill their browsables into; the list. The browsables are generated for a given parent,; or (if 0), for a given branch. The branch is passed down to; leaves of TVirtualBranchBrowsable, too, as we need to access; the branch's TTree to be able to traw. TClass* GetCollectionContainedType(const TBranch* b, const TVirtualBranchBrowsable* parent, TClass*& contained); Check whether the branch (or the parent) contains a collection.; If it does, set ""contained"" to the contained type (if we can; retrieve it) and return the TClass for the collection. Set; ""contained"" to the branch's (or parent's) contained object's; class for non-collections, returning 0. Only one of ""branch"" or ""parent"" can ge given (depending on whether; we are creating browsable objects for a branch or for another; browsable object). TList* GetLeaves() const; Return list of leaves. If not set up yet we'll create them. void GetScope(TString& scope) const; Returns the full name for TTree::Draw to draw *this.; Recursively appends, starting at the top TBranch,; all method / object names with proper reference operators (->, .); depending on fTypeIsPointer. void RegisterDefaultGenerators(); Adds the default generators. The user can remove any of them as follows:; TMethodBrowsable::Unregister();; which will cause the browser not to show any methods. void RegisterGenerator(TVirtualBranchBrowsable::MethodCreateListOfBrowsables_t generator); Adds a generator to be called when browsing branches.; Called by the Register method, which should be implemented; for all derived classes (see e.g. TMethodBrowsable::Register()). void UnregisterGenerator(TVirtualBranchBrowsable::MethodCreateListOfBrowsables_t generator); Removes a generator from the list of gene",MatchSource.WIKI,root/html532/TVirtualBranchBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualBranchBrowsable.html
https://root.cern/root/html532/TVirtualBranchBrowsable.html:10548,Integrability,depend,depending,10548," branch. The branch is passed down to; leaves of TVirtualBranchBrowsable, too, as we need to access; the branch's TTree to be able to traw. TClass* GetCollectionContainedType(const TBranch* b, const TVirtualBranchBrowsable* parent, TClass*& contained); Check whether the branch (or the parent) contains a collection.; If it does, set ""contained"" to the contained type (if we can; retrieve it) and return the TClass for the collection. Set; ""contained"" to the branch's (or parent's) contained object's; class for non-collections, returning 0. Only one of ""branch"" or ""parent"" can ge given (depending on whether; we are creating browsable objects for a branch or for another; browsable object). TList* GetLeaves() const; Return list of leaves. If not set up yet we'll create them. void GetScope(TString& scope) const; Returns the full name for TTree::Draw to draw *this.; Recursively appends, starting at the top TBranch,; all method / object names with proper reference operators (->, .); depending on fTypeIsPointer. void RegisterDefaultGenerators(); Adds the default generators. The user can remove any of them as follows:; TMethodBrowsable::Unregister();; which will cause the browser not to show any methods. void RegisterGenerator(TVirtualBranchBrowsable::MethodCreateListOfBrowsables_t generator); Adds a generator to be called when browsing branches.; Called by the Register method, which should be implemented; for all derived classes (see e.g. TMethodBrowsable::Register()). void UnregisterGenerator(TVirtualBranchBrowsable::MethodCreateListOfBrowsables_t generator); Removes a generator from the list of generators to be called when; browsing branches. The user can remove any of the generators as follows:; TMethodBrowsable::Unregister();; which will cause the browser not to show any methods. const char * GetIconName() const; return icon shown when browsing a TVirtualBranchBrowsable. Bool_t IsFolder() const; check whether we have sub-elements. const TBranch* GetBranch() const; return th",MatchSource.WIKI,root/html532/TVirtualBranchBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualBranchBrowsable.html
https://root.cern/root/html532/TVirtualBranchBrowsable.html:439,Modifiability,extend,extend,439,". TVirtualBranchBrowsable. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TVirtualBranchBrowsable. class TVirtualBranchBrowsable: public TNamed. TVirtualBranchBrowsable is a base class (not really abstract, but useless; by itself) for helper objects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branc",MatchSource.WIKI,root/html532/TVirtualBranchBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualBranchBrowsable.html
https://root.cern/root/html532/TVirtualBranchBrowsable.html:4489,Modifiability,Inherit,InheritsFrom,4489,"c Int_tFillListOfBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const TBranch*GetBranch() const; TClass*GetClassType() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetIconName() const; TList*GetLeaves() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const TVirtualBranchBrowsable*GetParent() const; voidGetScope(TString& scope) const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::opera",MatchSource.WIKI,root/html532/TVirtualBranchBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualBranchBrowsable.html
https://root.cern/root/html532/TVirtualBranchBrowsable.html:4555,Modifiability,Inherit,InheritsFrom,4555,"nst TVirtualBranchBrowsable* parent = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const TBranch*GetBranch() const; TClass*GetClassType() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetIconName() const; TList*GetLeaves() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const TVirtualBranchBrowsable*GetParent() const; voidGetScope(TString& scope) const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNa",MatchSource.WIKI,root/html532/TVirtualBranchBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualBranchBrowsable.html
https://root.cern/root/html532/TVirtualBranchBrowsable.html:8857,Modifiability,Inherit,Inheritance,8857,":. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. const TBranch*fBranchpointer to the branch element representing the top object; TClass*fClasspointer to TClass representing our type (i.e. return type for methods), 0 if basic type; TList*fLeavespointer to leaves; const TVirtualBranchBrowsable*fParentparent method if this method is member of a returned class; Bool_tfTypeIsPointerreturn type is pointer to class; static list<MethodCreateListOfBrowsables_t>fgGeneratorslist of MethodCreateListOfBrowsables_t called by CreateListOfBrowsables; static Bool_tfgGeneratorsSethave we set the generators yet? empty is not good enough - user might have removed them. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualBranchBrowsable(const TBranch* b, TClass* type, Bool_t typeIsPointer, const TVirtualBranchBrowsable* parent = 0); constructor setting all members according to parameters. ~TVirtualBranchBrowsable(); Destructor. Delete our leaves. void Browse(TBrowser* b); Calls TTree::Draw on the method if return type is not a class;; otherwise expands returned object's ""folder"". Int_t FillListOfBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); Askes all registered generators to fill their browsables into; the list. The browsables are generated for a given parent,; or (if 0), for a given branch. The branch is passed down to; leaves of TVirtualBranchBrowsable, too, as we need to access; the branch's TTree to be able to traw. TClass* GetCollectionContainedType(const TBranch* b, const TVirtualBranchBrowsable* parent, TClass*& contained); Check whether the branch (or the parent) contains a collection.; If it",MatchSource.WIKI,root/html532/TVirtualBranchBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualBranchBrowsable.html
https://root.cern/root/html532/TVirtualBranchBrowsable.html:8870,Modifiability,Inherit,Inherited,8870,":. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. const TBranch*fBranchpointer to the branch element representing the top object; TClass*fClasspointer to TClass representing our type (i.e. return type for methods), 0 if basic type; TList*fLeavespointer to leaves; const TVirtualBranchBrowsable*fParentparent method if this method is member of a returned class; Bool_tfTypeIsPointerreturn type is pointer to class; static list<MethodCreateListOfBrowsables_t>fgGeneratorslist of MethodCreateListOfBrowsables_t called by CreateListOfBrowsables; static Bool_tfgGeneratorsSethave we set the generators yet? empty is not good enough - user might have removed them. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualBranchBrowsable(const TBranch* b, TClass* type, Bool_t typeIsPointer, const TVirtualBranchBrowsable* parent = 0); constructor setting all members according to parameters. ~TVirtualBranchBrowsable(); Destructor. Delete our leaves. void Browse(TBrowser* b); Calls TTree::Draw on the method if return type is not a class;; otherwise expands returned object's ""folder"". Int_t FillListOfBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); Askes all registered generators to fill their browsables into; the list. The browsables are generated for a given parent,; or (if 0), for a given branch. The branch is passed down to; leaves of TVirtualBranchBrowsable, too, as we need to access; the branch's TTree to be able to traw. TClass* GetCollectionContainedType(const TBranch* b, const TVirtualBranchBrowsable* parent, TClass*& contained); Check whether the branch (or the parent) contains a collection.; If it",MatchSource.WIKI,root/html532/TVirtualBranchBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualBranchBrowsable.html
https://root.cern/root/html532/TVirtualBranchBrowsable.html:1166,Performance,cache,cached,1166,"s. ROOT; » TREE; » TREE; » TVirtualBranchBrowsable. class TVirtualBranchBrowsable: public TNamed. TVirtualBranchBrowsable is a base class (not really abstract, but useless; by itself) for helper objects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. TVirtualBranchBrowsable",MatchSource.WIKI,root/html532/TVirtualBranchBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualBranchBrowsable.html
https://root.cern/root/html532/TVirtualBranchBrowsable.html:1227,Performance,cache,cached,1227,"s. ROOT; » TREE; » TREE; » TVirtualBranchBrowsable. class TVirtualBranchBrowsable: public TNamed. TVirtualBranchBrowsable is a base class (not really abstract, but useless; by itself) for helper objects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. TVirtualBranchBrowsable",MatchSource.WIKI,root/html532/TVirtualBranchBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualBranchBrowsable.html
https://root.cern/root/html532/TVirtualBranchBrowsable.html:4379,Security,Hash,Hash,4379,"TObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); static Int_tFillListOfBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const TBranch*GetBranch() const; TClass*GetClassType() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetIconName() const; TList*GetLeaves() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const TVirtualBranchBrowsable*GetParent() const; voidGetScope(TString& scope) const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t ",MatchSource.WIKI,root/html532/TVirtualBranchBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualBranchBrowsable.html
https://root.cern/root/html532/TVirtualBranchBrowsable.html:9653,Security,access,access,9653,"ables_t>fgGeneratorslist of MethodCreateListOfBrowsables_t called by CreateListOfBrowsables; static Bool_tfgGeneratorsSethave we set the generators yet? empty is not good enough - user might have removed them. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualBranchBrowsable(const TBranch* b, TClass* type, Bool_t typeIsPointer, const TVirtualBranchBrowsable* parent = 0); constructor setting all members according to parameters. ~TVirtualBranchBrowsable(); Destructor. Delete our leaves. void Browse(TBrowser* b); Calls TTree::Draw on the method if return type is not a class;; otherwise expands returned object's ""folder"". Int_t FillListOfBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); Askes all registered generators to fill their browsables into; the list. The browsables are generated for a given parent,; or (if 0), for a given branch. The branch is passed down to; leaves of TVirtualBranchBrowsable, too, as we need to access; the branch's TTree to be able to traw. TClass* GetCollectionContainedType(const TBranch* b, const TVirtualBranchBrowsable* parent, TClass*& contained); Check whether the branch (or the parent) contains a collection.; If it does, set ""contained"" to the contained type (if we can; retrieve it) and return the TClass for the collection. Set; ""contained"" to the branch's (or parent's) contained object's; class for non-collections, returning 0. Only one of ""branch"" or ""parent"" can ge given (depending on whether; we are creating browsable objects for a branch or for another; browsable object). TList* GetLeaves() const; Return list of leaves. If not set up yet we'll create them. void GetScope(TString& scope) const; Returns the full name for TTree::Draw to draw *this.; Recursively appends, starting at the top TBranch,; all method / object names with proper reference operators (->, .); depending on fTypeIsPointer. void RegisterDefaultGenerators(); Adds the default genera",MatchSource.WIKI,root/html532/TVirtualBranchBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualBranchBrowsable.html
https://root.cern/root/html532/TVirtualBranchBrowsable.html:6706,Testability,Test,TestBit,6706,"const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTypeIsPointer() const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TVirtualBranchBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualBranchBrowsable.html
https://root.cern/root/html532/TVirtualBranchBrowsable.html:6745,Testability,Test,TestBits,6745,"const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTypeIsPointer() const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TVirtualBranchBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualBranchBrowsable.html
https://root.cern/root/html532/TVirtualBranchBrowsable.html:1414,Usability,simpl,simple,1414,"ects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. TVirtualBranchBrowsable(const TVirtualBranchBrowsable&); virtual~TVirtualBranchBrowsable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(T",MatchSource.WIKI,root/html532/TVirtualBranchBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualBranchBrowsable.html
https://root.cern/root/html532/TVirtualBranchBrowsable.html:2533,Usability,Clear,Clear,2533,,MatchSource.WIKI,root/html532/TVirtualBranchBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualBranchBrowsable.html
https://root.cern/root/html532/TVirtualCollectionProxy.html:701,Availability,avail,available,701,". TVirtualCollectionProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TVirtualCollectionProxy. class TVirtualCollectionProxy. TVirtualCollectionProxy. Virtual interface of a proxy object for a collection class; In particular this is used to implement splitting, emulation,; and TTreeFormula access to STL containers. This class is also known as (typedefs to this class)TCollectionProxyFactory::Proxy_t. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualCollectionProxy(); virtual void*Allocate(UInt_t n, Bool_t forceDelete); virtual void*At(UInt_t idx); virtual voidClear(const char* opt = """"); virtual voidCommit(void*); virtual voidDeleteArray(void* p, Bool_t dtorOnly = kFALSE); virtual voidDestructor(void* p, Bool_t dtorOnly = kFALSE); virtual TVirtualCollectionProxy*Generate() const; virtual TClass*GetCollectionClass(); virtual Int_tGetCollectionType(); virtual TStreamerInfoActions::TActionSequence*GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); virtual TVirtualCollectionProxy::CopyIterator_tGetFunctionCopyIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::CreateIterators_tGetFunctionCreateIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteIterator_tGetFunctionDeleteIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteTwoIterators_tGetFunctionDeleteTwoIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::Next_tGetFunctionNext(Bool_t read = kTRUE); virtual ULong_tGetIncrement(); virtual Int_tGetProperties(); virtual TStreamerInfoActions::TActionSequence*GetReadMemberWiseActions(Int_t version); virtual EDataTypeGetType(); virtual TClass*GetValueClass(); virtual TStreamerInfoActions::TActionSequence*G",MatchSource.WIKI,root/html532/TVirtualCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualCollectionProxy.html
https://root.cern/root/html532/TVirtualCollectionProxy.html:783,Energy Efficiency,Allocate,Allocate,783,"y_t. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualCollectionProxy(); virtual void*Allocate(UInt_t n, Bool_t forceDelete); virtual void*At(UInt_t idx); virtual voidClear(const char* opt = """"); virtual voidCommit(void*); virtual voidDeleteArray(void* p, Bool_t dtorOnly = kFALSE); virtual voidDestructor(void* p, Bool_t dtorOnly = kFALSE); virtual TVirtualCollectionProxy*Generate() const; virtual TClass*GetCollectionClass(); virtual Int_tGetCollectionType(); virtual TStreamerInfoActions::TActionSequence*GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); virtual TVirtualCollectionProxy::CopyIterator_tGetFunctionCopyIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::CreateIterators_tGetFunctionCreateIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteIterator_tGetFunctionDeleteIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteTwoIterators_tGetFunctionDeleteTwoIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::Next_tGetFunctionNext(Bool_t read = kTRUE); virtual ULong_tGetIncrement(); virtual Int_tGetProperties(); virtual TStreamerInfoActions::TActionSequence*GetReadMemberWiseActions(Int_t version); virtual EDataTypeGetType(); virtual TClass*GetValueClass(); virtual TStreamerInfoActions::TActionSequence*GetWriteMemberWiseActions(); virtual Bool_tHasPointers() const; virtual void*New() const; virtual void*New(void* arena) const; virtual void*NewArray(Int_t nElements) const; virtual void*NewArray(Int_t nElements, void* arena) const; char*operator[](UInt_t idx) const; virtual voidPopProxy(); virtual voidPushProxy(void* objectstart); virtual UInt_tSize() const; virtual UInt_tSizeof() const. protected:. virtual voidSetValueClass(TClass* newcl). private:. TVirtualCollectionProxy&operator=(const TVirtualCollectionProxy&). Data Members; public:. enum EProperty { ",MatchSource.WIKI,root/html532/TVirtualCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualCollectionProxy.html
https://root.cern/root/html532/TVirtualCollectionProxy.html:4647,Energy Efficiency,Allocate,Allocate,4647,"y(Int_t nElements, void* arena) const; Execute the container constructor. void Destructor(void* p, Bool_t dtorOnly = kFALSE); Execute the container destructor. void DeleteArray(void* p, Bool_t dtorOnly = kFALSE); Execute the container array destructor. UInt_t Sizeof() const; Return the sizeof the collection object. void PushProxy(void* objectstart); Set the address of the container being proxied and keep track of the previous one. void PopProxy(); Reset the address of the container being proxied to the previous container. Bool_t HasPointers() const; Return true if the content is of type 'pointer to'. TClass * GetValueClass(); Return a pointer to the TClass representing the content. EDataType GetType(); If the content is a simple numerical value, return its type (see TDataType). void * At(UInt_t idx); Return the address of the value at index 'idx'. void Clear(const char* opt = """"); Clear the container. UInt_t Size() const; Return the current size of the container. void* Allocate(UInt_t n, Bool_t forceDelete). void Commit(void* ). char * operator[](UInt_t idx) const; { return (char*)(const_cast<TVirtualCollectionProxy*>(this))->At(idx); }. TStreamerInfoActions::TActionSequence * GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); MemberWise actions. TStreamerInfoActions::TActionSequence * GetReadMemberWiseActions(Int_t version). TStreamerInfoActions::TActionSequence * GetWriteMemberWiseActions(). CreateIterators_t GetFunctionCreateIterators(Bool_t read = kTRUE); begin_arena and end_arena should contain the location of a memory arena of size fgIteratorSize.; If the collection iterator are of that size or less, the iterators will be constructed in place in those location (new with placement); Otherwise the iterators will be allocated via a regular new and their address returned by modifying the value of begin_arena and end_arena. CopyIterator_t GetFunctionCopyIterator(Bool_t read = kTRUE); Copy the iterator source, into dest. dest should contain the loc",MatchSource.WIKI,root/html532/TVirtualCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualCollectionProxy.html
https://root.cern/root/html532/TVirtualCollectionProxy.html:5430,Energy Efficiency,allocate,allocated,5430,"ple numerical value, return its type (see TDataType). void * At(UInt_t idx); Return the address of the value at index 'idx'. void Clear(const char* opt = """"); Clear the container. UInt_t Size() const; Return the current size of the container. void* Allocate(UInt_t n, Bool_t forceDelete). void Commit(void* ). char * operator[](UInt_t idx) const; { return (char*)(const_cast<TVirtualCollectionProxy*>(this))->At(idx); }. TStreamerInfoActions::TActionSequence * GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); MemberWise actions. TStreamerInfoActions::TActionSequence * GetReadMemberWiseActions(Int_t version). TStreamerInfoActions::TActionSequence * GetWriteMemberWiseActions(). CreateIterators_t GetFunctionCreateIterators(Bool_t read = kTRUE); begin_arena and end_arena should contain the location of a memory arena of size fgIteratorSize.; If the collection iterator are of that size or less, the iterators will be constructed in place in those location (new with placement); Otherwise the iterators will be allocated via a regular new and their address returned by modifying the value of begin_arena and end_arena. CopyIterator_t GetFunctionCopyIterator(Bool_t read = kTRUE); Copy the iterator source, into dest. dest should contain the location of a memory arena of size fgIteratorSize.; If the collection iterator is of that size or less, the iterator will be constructed in place in this location (new with placement); Otherwise the iterator will be allocated via a regular new and its address returned by modifying the value of dest. Next_t GetFunctionNext(Bool_t read = kTRUE); iter and end should be pointers to respectively an iterator to be incremented and the result of collection.end(); If the iterator has not reached the end of the collection, 'Next' increment the iterator 'iter' and return 0 if; the iterator reached the end.; If the end was not reached, 'Next' returns the address of the content pointed to by the iterator before the; incrementation ; if the co",MatchSource.WIKI,root/html532/TVirtualCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualCollectionProxy.html
https://root.cern/root/html532/TVirtualCollectionProxy.html:5876,Energy Efficiency,allocate,allocated,5876,"ions::TActionSequence * GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); MemberWise actions. TStreamerInfoActions::TActionSequence * GetReadMemberWiseActions(Int_t version). TStreamerInfoActions::TActionSequence * GetWriteMemberWiseActions(). CreateIterators_t GetFunctionCreateIterators(Bool_t read = kTRUE); begin_arena and end_arena should contain the location of a memory arena of size fgIteratorSize.; If the collection iterator are of that size or less, the iterators will be constructed in place in those location (new with placement); Otherwise the iterators will be allocated via a regular new and their address returned by modifying the value of begin_arena and end_arena. CopyIterator_t GetFunctionCopyIterator(Bool_t read = kTRUE); Copy the iterator source, into dest. dest should contain the location of a memory arena of size fgIteratorSize.; If the collection iterator is of that size or less, the iterator will be constructed in place in this location (new with placement); Otherwise the iterator will be allocated via a regular new and its address returned by modifying the value of dest. Next_t GetFunctionNext(Bool_t read = kTRUE); iter and end should be pointers to respectively an iterator to be incremented and the result of collection.end(); If the iterator has not reached the end of the collection, 'Next' increment the iterator 'iter' and return 0 if; the iterator reached the end.; If the end was not reached, 'Next' returns the address of the content pointed to by the iterator before the; incrementation ; if the collection contains pointers, 'Next' will return the value of the pointer. DeleteIterator_t GetFunctionDeleteIterator(Bool_t read = kTRUE). DeleteTwoIterators_t GetFunctionDeleteTwoIterators(Bool_t read = kTRUE); If the size of the iterator is greater than fgIteratorArenaSize, call delete on the addresses,; Otherwise just call the iterator's destructor. » Author: Philippe Canal 20/08/2003 » Copyright (C) 1995-2003, Rene Brun, Fons Rad",MatchSource.WIKI,root/html532/TVirtualCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualCollectionProxy.html
https://root.cern/root/html532/TVirtualCollectionProxy.html:323,Integrability,interface,interface,323,". TVirtualCollectionProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TVirtualCollectionProxy. class TVirtualCollectionProxy. TVirtualCollectionProxy. Virtual interface of a proxy object for a collection class; In particular this is used to implement splitting, emulation,; and TTreeFormula access to STL containers. This class is also known as (typedefs to this class)TCollectionProxyFactory::Proxy_t. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualCollectionProxy(); virtual void*Allocate(UInt_t n, Bool_t forceDelete); virtual void*At(UInt_t idx); virtual voidClear(const char* opt = """"); virtual voidCommit(void*); virtual voidDeleteArray(void* p, Bool_t dtorOnly = kFALSE); virtual voidDestructor(void* p, Bool_t dtorOnly = kFALSE); virtual TVirtualCollectionProxy*Generate() const; virtual TClass*GetCollectionClass(); virtual Int_tGetCollectionType(); virtual TStreamerInfoActions::TActionSequence*GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); virtual TVirtualCollectionProxy::CopyIterator_tGetFunctionCopyIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::CreateIterators_tGetFunctionCreateIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteIterator_tGetFunctionDeleteIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteTwoIterators_tGetFunctionDeleteTwoIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::Next_tGetFunctionNext(Bool_t read = kTRUE); virtual ULong_tGetIncrement(); virtual Int_tGetProperties(); virtual TStreamerInfoActions::TActionSequence*GetReadMemberWiseActions(Int_t version); virtual EDataTypeGetType(); virtual TClass*GetValueClass(); virtual TStreamerInfoActions::TActionSequence*G",MatchSource.WIKI,root/html532/TVirtualCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualCollectionProxy.html
https://root.cern/root/html532/TVirtualCollectionProxy.html:2777,Modifiability,Inherit,Inheritance,2777,"s(); virtual TStreamerInfoActions::TActionSequence*GetReadMemberWiseActions(Int_t version); virtual EDataTypeGetType(); virtual TClass*GetValueClass(); virtual TStreamerInfoActions::TActionSequence*GetWriteMemberWiseActions(); virtual Bool_tHasPointers() const; virtual void*New() const; virtual void*New(void* arena) const; virtual void*NewArray(Int_t nElements) const; virtual void*NewArray(Int_t nElements, void* arena) const; char*operator[](UInt_t idx) const; virtual voidPopProxy(); virtual voidPushProxy(void* objectstart); virtual UInt_tSize() const; virtual UInt_tSizeof() const. protected:. virtual voidSetValueClass(TClass* newcl). private:. TVirtualCollectionProxy&operator=(const TVirtualCollectionProxy&). Data Members; public:. enum EProperty { kIsInitialized; kIsAssociative; kIsEmulated; kNeedDelete; };. public:. static const Int_tfgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassReffClass; UInt_tfProperties. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualCollectionProxy& operator=(const TVirtualCollectionProxy& ). void SetValueClass(TClass* newcl). TVirtualCollectionProxy* Generate() const. virtual ~TVirtualCollectionProxy(); {}. TClass * GetCollectionClass(); Return a pointer to the TClass representing the container. { return fClass; }. Int_t GetCollectionType(); Return the type of collection see TClassEdit::ESTLType. ULong_t GetIncrement(); Return the offset between two consecutive value_types (memory layout). Int_t GetProperties(); Return miscallenous properties of the proxy see TVirtualCollectionProxy::EProperty. { return fProperties; }. void * New() const; Return a new container object. void * New(void* arena) const; Execute the container constructor. void * NewArray(Int_t nElements) const; Return a new container object. void * NewArray(Int_t nElements, void* arena) const; Execute the container constructor. void Destructor(void* p, Bool_t dtorOnly = kFALSE); Execute the co",MatchSource.WIKI,root/html532/TVirtualCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualCollectionProxy.html
https://root.cern/root/html532/TVirtualCollectionProxy.html:2790,Modifiability,Inherit,Inherited,2790,"s(); virtual TStreamerInfoActions::TActionSequence*GetReadMemberWiseActions(Int_t version); virtual EDataTypeGetType(); virtual TClass*GetValueClass(); virtual TStreamerInfoActions::TActionSequence*GetWriteMemberWiseActions(); virtual Bool_tHasPointers() const; virtual void*New() const; virtual void*New(void* arena) const; virtual void*NewArray(Int_t nElements) const; virtual void*NewArray(Int_t nElements, void* arena) const; char*operator[](UInt_t idx) const; virtual voidPopProxy(); virtual voidPushProxy(void* objectstart); virtual UInt_tSize() const; virtual UInt_tSizeof() const. protected:. virtual voidSetValueClass(TClass* newcl). private:. TVirtualCollectionProxy&operator=(const TVirtualCollectionProxy&). Data Members; public:. enum EProperty { kIsInitialized; kIsAssociative; kIsEmulated; kNeedDelete; };. public:. static const Int_tfgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassReffClass; UInt_tfProperties. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualCollectionProxy& operator=(const TVirtualCollectionProxy& ). void SetValueClass(TClass* newcl). TVirtualCollectionProxy* Generate() const. virtual ~TVirtualCollectionProxy(); {}. TClass * GetCollectionClass(); Return a pointer to the TClass representing the container. { return fClass; }. Int_t GetCollectionType(); Return the type of collection see TClassEdit::ESTLType. ULong_t GetIncrement(); Return the offset between two consecutive value_types (memory layout). Int_t GetProperties(); Return miscallenous properties of the proxy see TVirtualCollectionProxy::EProperty. { return fProperties; }. void * New() const; Return a new container object. void * New(void* arena) const; Execute the container constructor. void * NewArray(Int_t nElements) const; Return a new container object. void * NewArray(Int_t nElements, void* arena) const; Execute the container constructor. void Destructor(void* p, Bool_t dtorOnly = kFALSE); Execute the co",MatchSource.WIKI,root/html532/TVirtualCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualCollectionProxy.html
https://root.cern/root/html532/TVirtualCollectionProxy.html:455,Security,access,access,455,". TVirtualCollectionProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TVirtualCollectionProxy. class TVirtualCollectionProxy. TVirtualCollectionProxy. Virtual interface of a proxy object for a collection class; In particular this is used to implement splitting, emulation,; and TTreeFormula access to STL containers. This class is also known as (typedefs to this class)TCollectionProxyFactory::Proxy_t. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualCollectionProxy(); virtual void*Allocate(UInt_t n, Bool_t forceDelete); virtual void*At(UInt_t idx); virtual voidClear(const char* opt = """"); virtual voidCommit(void*); virtual voidDeleteArray(void* p, Bool_t dtorOnly = kFALSE); virtual voidDestructor(void* p, Bool_t dtorOnly = kFALSE); virtual TVirtualCollectionProxy*Generate() const; virtual TClass*GetCollectionClass(); virtual Int_tGetCollectionType(); virtual TStreamerInfoActions::TActionSequence*GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); virtual TVirtualCollectionProxy::CopyIterator_tGetFunctionCopyIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::CreateIterators_tGetFunctionCreateIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteIterator_tGetFunctionDeleteIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteTwoIterators_tGetFunctionDeleteTwoIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::Next_tGetFunctionNext(Bool_t read = kTRUE); virtual ULong_tGetIncrement(); virtual Int_tGetProperties(); virtual TStreamerInfoActions::TActionSequence*GetReadMemberWiseActions(Int_t version); virtual EDataTypeGetType(); virtual TClass*GetValueClass(); virtual TStreamerInfoActions::TActionSequence*G",MatchSource.WIKI,root/html532/TVirtualCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualCollectionProxy.html
https://root.cern/root/html532/TVirtualCollectionProxy.html:4395,Usability,simpl,simple,4395,"irtualCollectionProxy::EProperty. { return fProperties; }. void * New() const; Return a new container object. void * New(void* arena) const; Execute the container constructor. void * NewArray(Int_t nElements) const; Return a new container object. void * NewArray(Int_t nElements, void* arena) const; Execute the container constructor. void Destructor(void* p, Bool_t dtorOnly = kFALSE); Execute the container destructor. void DeleteArray(void* p, Bool_t dtorOnly = kFALSE); Execute the container array destructor. UInt_t Sizeof() const; Return the sizeof the collection object. void PushProxy(void* objectstart); Set the address of the container being proxied and keep track of the previous one. void PopProxy(); Reset the address of the container being proxied to the previous container. Bool_t HasPointers() const; Return true if the content is of type 'pointer to'. TClass * GetValueClass(); Return a pointer to the TClass representing the content. EDataType GetType(); If the content is a simple numerical value, return its type (see TDataType). void * At(UInt_t idx); Return the address of the value at index 'idx'. void Clear(const char* opt = """"); Clear the container. UInt_t Size() const; Return the current size of the container. void* Allocate(UInt_t n, Bool_t forceDelete). void Commit(void* ). char * operator[](UInt_t idx) const; { return (char*)(const_cast<TVirtualCollectionProxy*>(this))->At(idx); }. TStreamerInfoActions::TActionSequence * GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); MemberWise actions. TStreamerInfoActions::TActionSequence * GetReadMemberWiseActions(Int_t version). TStreamerInfoActions::TActionSequence * GetWriteMemberWiseActions(). CreateIterators_t GetFunctionCreateIterators(Bool_t read = kTRUE); begin_arena and end_arena should contain the location of a memory arena of size fgIteratorSize.; If the collection iterator are of that size or less, the iterators will be constructed in place in those location (new with placement); Othe",MatchSource.WIKI,root/html532/TVirtualCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualCollectionProxy.html
https://root.cern/root/html532/TVirtualCollectionProxy.html:4528,Usability,Clear,Clear,4528,"e the container constructor. void * NewArray(Int_t nElements) const; Return a new container object. void * NewArray(Int_t nElements, void* arena) const; Execute the container constructor. void Destructor(void* p, Bool_t dtorOnly = kFALSE); Execute the container destructor. void DeleteArray(void* p, Bool_t dtorOnly = kFALSE); Execute the container array destructor. UInt_t Sizeof() const; Return the sizeof the collection object. void PushProxy(void* objectstart); Set the address of the container being proxied and keep track of the previous one. void PopProxy(); Reset the address of the container being proxied to the previous container. Bool_t HasPointers() const; Return true if the content is of type 'pointer to'. TClass * GetValueClass(); Return a pointer to the TClass representing the content. EDataType GetType(); If the content is a simple numerical value, return its type (see TDataType). void * At(UInt_t idx); Return the address of the value at index 'idx'. void Clear(const char* opt = """"); Clear the container. UInt_t Size() const; Return the current size of the container. void* Allocate(UInt_t n, Bool_t forceDelete). void Commit(void* ). char * operator[](UInt_t idx) const; { return (char*)(const_cast<TVirtualCollectionProxy*>(this))->At(idx); }. TStreamerInfoActions::TActionSequence * GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); MemberWise actions. TStreamerInfoActions::TActionSequence * GetReadMemberWiseActions(Int_t version). TStreamerInfoActions::TActionSequence * GetWriteMemberWiseActions(). CreateIterators_t GetFunctionCreateIterators(Bool_t read = kTRUE); begin_arena and end_arena should contain the location of a memory arena of size fgIteratorSize.; If the collection iterator are of that size or less, the iterators will be constructed in place in those location (new with placement); Otherwise the iterators will be allocated via a regular new and their address returned by modifying the value of begin_arena and end_arena. CopyIterator",MatchSource.WIKI,root/html532/TVirtualCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualCollectionProxy.html
https://root.cern/root/html532/TVirtualCollectionProxy.html:4557,Usability,Clear,Clear,4557,"e the container constructor. void * NewArray(Int_t nElements) const; Return a new container object. void * NewArray(Int_t nElements, void* arena) const; Execute the container constructor. void Destructor(void* p, Bool_t dtorOnly = kFALSE); Execute the container destructor. void DeleteArray(void* p, Bool_t dtorOnly = kFALSE); Execute the container array destructor. UInt_t Sizeof() const; Return the sizeof the collection object. void PushProxy(void* objectstart); Set the address of the container being proxied and keep track of the previous one. void PopProxy(); Reset the address of the container being proxied to the previous container. Bool_t HasPointers() const; Return true if the content is of type 'pointer to'. TClass * GetValueClass(); Return a pointer to the TClass representing the content. EDataType GetType(); If the content is a simple numerical value, return its type (see TDataType). void * At(UInt_t idx); Return the address of the value at index 'idx'. void Clear(const char* opt = """"); Clear the container. UInt_t Size() const; Return the current size of the container. void* Allocate(UInt_t n, Bool_t forceDelete). void Commit(void* ). char * operator[](UInt_t idx) const; { return (char*)(const_cast<TVirtualCollectionProxy*>(this))->At(idx); }. TStreamerInfoActions::TActionSequence * GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); MemberWise actions. TStreamerInfoActions::TActionSequence * GetReadMemberWiseActions(Int_t version). TStreamerInfoActions::TActionSequence * GetWriteMemberWiseActions(). CreateIterators_t GetFunctionCreateIterators(Bool_t read = kTRUE); begin_arena and end_arena should contain the location of a memory arena of size fgIteratorSize.; If the collection iterator are of that size or less, the iterators will be constructed in place in those location (new with placement); Otherwise the iterators will be allocated via a regular new and their address returned by modifying the value of begin_arena and end_arena. CopyIterator",MatchSource.WIKI,root/html532/TVirtualCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualCollectionProxy.html
https://root.cern/root/html532/TVirtualDragManager.html:1991,Modifiability,Inherit,Inheritance,1991,"IgnoreEvent(Event_t*); static TVirtualDragManager*Instance(); virtual TClass*IsA() const; Bool_tIsDragging() const; Bool_tIsDropping() const; Bool_tIsMoveWaiting() const; Bool_tIsPasting() const; TVirtualDragManager&operator=(const TVirtualDragManager&); virtual voidSetEditable(Bool_t); virtual voidSetPasteFrame(TGFrame* f); virtual voidSetSource(TGFrame* f); virtual voidSetTarget(TGFrame* f); virtual voidShowMembers(TMemberInspector& insp); virtual Bool_tStartDrag(TGFrame* = 0, Int_t = 0, Int_t = 0); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. virtual voidInit(). Data Members; protected:. EDragTypefDragTypedragging type; Bool_tfDraggingin dragging mode?; Bool_tfDroppingdrop is in progress; TGFrame*fFrameUnderframe under drag; Bool_tfMoveWaitingkTRUE if source is clicked but not moved; TGFrame*fPasteFrame; Bool_tfPastingpaste action is in progress; TGFrame*fSourceframe being dragged; TGFrame*fTargetdrop target. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualDragManager(); Constructor. TVirtualDragManager * Instance(); Load plugin and create drag manager object. void Init(); Initialization. TVirtualDragManager(). virtual ~TVirtualDragManager(); {}. EDragType GetEDragType() const; { return fDragType; }. Bool_t IsMoveWaiting() const; { return fMoveWaiting; }. Bool_t IsDragging() const; { return fDragging; }. Bool_t IsDropping() const; { return fDropping; }. Bool_t IsPasting() const; { return fPasting; }. TGFrame * GetTarget() const; { return fTarget; }. TGFrame * GetSource() const; { return fSource; }. TGFrame * GetFrameUnder() const; { return fFrameUnder; }. TGFrame * GetPasteFrame() const; { return fPasteFrame; }. void SetTarget(TGFrame* f); { fTarget = f; }. void SetSource(TGFrame* f); { fSource = f; }. void SetPasteFrame(TGFrame* f); { fPasteFrame = f; }. Bool_t StartDrag(TGFrame* = 0, Int_t = 0, Int_t = 0); { return kFALSE; }. Bool_t EndDrag(); { return kFALSE; }. Bool_t Drop();",MatchSource.WIKI,root/html532/TVirtualDragManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualDragManager.html
https://root.cern/root/html532/TVirtualDragManager.html:2004,Modifiability,Inherit,Inherited,2004,"IgnoreEvent(Event_t*); static TVirtualDragManager*Instance(); virtual TClass*IsA() const; Bool_tIsDragging() const; Bool_tIsDropping() const; Bool_tIsMoveWaiting() const; Bool_tIsPasting() const; TVirtualDragManager&operator=(const TVirtualDragManager&); virtual voidSetEditable(Bool_t); virtual voidSetPasteFrame(TGFrame* f); virtual voidSetSource(TGFrame* f); virtual voidSetTarget(TGFrame* f); virtual voidShowMembers(TMemberInspector& insp); virtual Bool_tStartDrag(TGFrame* = 0, Int_t = 0, Int_t = 0); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. virtual voidInit(). Data Members; protected:. EDragTypefDragTypedragging type; Bool_tfDraggingin dragging mode?; Bool_tfDroppingdrop is in progress; TGFrame*fFrameUnderframe under drag; Bool_tfMoveWaitingkTRUE if source is clicked but not moved; TGFrame*fPasteFrame; Bool_tfPastingpaste action is in progress; TGFrame*fSourceframe being dragged; TGFrame*fTargetdrop target. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualDragManager(); Constructor. TVirtualDragManager * Instance(); Load plugin and create drag manager object. void Init(); Initialization. TVirtualDragManager(). virtual ~TVirtualDragManager(); {}. EDragType GetEDragType() const; { return fDragType; }. Bool_t IsMoveWaiting() const; { return fMoveWaiting; }. Bool_t IsDragging() const; { return fDragging; }. Bool_t IsDropping() const; { return fDropping; }. Bool_t IsPasting() const; { return fPasting; }. TGFrame * GetTarget() const; { return fTarget; }. TGFrame * GetSource() const; { return fSource; }. TGFrame * GetFrameUnder() const; { return fFrameUnder; }. TGFrame * GetPasteFrame() const; { return fPasteFrame; }. void SetTarget(TGFrame* f); { fTarget = f; }. void SetSource(TGFrame* f); { fSource = f; }. void SetPasteFrame(TGFrame* f); { fPasteFrame = f; }. Bool_t StartDrag(TGFrame* = 0, Int_t = 0, Int_t = 0); { return kFALSE; }. Bool_t EndDrag(); { return kFALSE; }. Bool_t Drop();",MatchSource.WIKI,root/html532/TVirtualDragManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualDragManager.html
https://root.cern/root/html532/TVirtualDragManager.html:2143,Modifiability,plugin,plugin,2143,"opping() const; Bool_tIsMoveWaiting() const; Bool_tIsPasting() const; TVirtualDragManager&operator=(const TVirtualDragManager&); virtual voidSetEditable(Bool_t); virtual voidSetPasteFrame(TGFrame* f); virtual voidSetSource(TGFrame* f); virtual voidSetTarget(TGFrame* f); virtual voidShowMembers(TMemberInspector& insp); virtual Bool_tStartDrag(TGFrame* = 0, Int_t = 0, Int_t = 0); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. virtual voidInit(). Data Members; protected:. EDragTypefDragTypedragging type; Bool_tfDraggingin dragging mode?; Bool_tfDroppingdrop is in progress; TGFrame*fFrameUnderframe under drag; Bool_tfMoveWaitingkTRUE if source is clicked but not moved; TGFrame*fPasteFrame; Bool_tfPastingpaste action is in progress; TGFrame*fSourceframe being dragged; TGFrame*fTargetdrop target. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualDragManager(); Constructor. TVirtualDragManager * Instance(); Load plugin and create drag manager object. void Init(); Initialization. TVirtualDragManager(). virtual ~TVirtualDragManager(); {}. EDragType GetEDragType() const; { return fDragType; }. Bool_t IsMoveWaiting() const; { return fMoveWaiting; }. Bool_t IsDragging() const; { return fDragging; }. Bool_t IsDropping() const; { return fDropping; }. Bool_t IsPasting() const; { return fPasting; }. TGFrame * GetTarget() const; { return fTarget; }. TGFrame * GetSource() const; { return fSource; }. TGFrame * GetFrameUnder() const; { return fFrameUnder; }. TGFrame * GetPasteFrame() const; { return fPasteFrame; }. void SetTarget(TGFrame* f); { fTarget = f; }. void SetSource(TGFrame* f); { fSource = f; }. void SetPasteFrame(TGFrame* f); { fPasteFrame = f; }. Bool_t StartDrag(TGFrame* = 0, Int_t = 0, Int_t = 0); { return kFALSE; }. Bool_t EndDrag(); { return kFALSE; }. Bool_t Drop(); { return kFALSE; }. Bool_t Cancel(Bool_t = kTRUE); { return kFALSE; }. Bool_t HandleEvent(Event_t* ); { return kFALSE; }. Bo",MatchSource.WIKI,root/html532/TVirtualDragManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualDragManager.html
https://root.cern/root/html532/TVirtualDragManager.html:2138,Performance,Load,Load,2138,"opping() const; Bool_tIsMoveWaiting() const; Bool_tIsPasting() const; TVirtualDragManager&operator=(const TVirtualDragManager&); virtual voidSetEditable(Bool_t); virtual voidSetPasteFrame(TGFrame* f); virtual voidSetSource(TGFrame* f); virtual voidSetTarget(TGFrame* f); virtual voidShowMembers(TMemberInspector& insp); virtual Bool_tStartDrag(TGFrame* = 0, Int_t = 0, Int_t = 0); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. virtual voidInit(). Data Members; protected:. EDragTypefDragTypedragging type; Bool_tfDraggingin dragging mode?; Bool_tfDroppingdrop is in progress; TGFrame*fFrameUnderframe under drag; Bool_tfMoveWaitingkTRUE if source is clicked but not moved; TGFrame*fPasteFrame; Bool_tfPastingpaste action is in progress; TGFrame*fSourceframe being dragged; TGFrame*fTargetdrop target. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualDragManager(); Constructor. TVirtualDragManager * Instance(); Load plugin and create drag manager object. void Init(); Initialization. TVirtualDragManager(). virtual ~TVirtualDragManager(); {}. EDragType GetEDragType() const; { return fDragType; }. Bool_t IsMoveWaiting() const; { return fMoveWaiting; }. Bool_t IsDragging() const; { return fDragging; }. Bool_t IsDropping() const; { return fDropping; }. Bool_t IsPasting() const; { return fPasting; }. TGFrame * GetTarget() const; { return fTarget; }. TGFrame * GetSource() const; { return fSource; }. TGFrame * GetFrameUnder() const; { return fFrameUnder; }. TGFrame * GetPasteFrame() const; { return fPasteFrame; }. void SetTarget(TGFrame* f); { fTarget = f; }. void SetSource(TGFrame* f); { fSource = f; }. void SetPasteFrame(TGFrame* f); { fPasteFrame = f; }. Bool_t StartDrag(TGFrame* = 0, Int_t = 0, Int_t = 0); { return kFALSE; }. Bool_t EndDrag(); { return kFALSE; }. Bool_t Drop(); { return kFALSE; }. Bool_t Cancel(Bool_t = kTRUE); { return kFALSE; }. Bool_t HandleEvent(Event_t* ); { return kFALSE; }. Bo",MatchSource.WIKI,root/html532/TVirtualDragManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualDragManager.html
https://root.cern/root/html532/TVirtualFFT.html:667,Availability,Avail,Available,667,". TVirtualFFT. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualFFT. class TVirtualFFT: public TObject. TVirtualFFT. TVirtualFFT is an interface class for Fast Fourier Transforms. The default FFT library is FFTW. To use it, FFTW3 library should already; be installed, and ROOT should be have fftw3 module enabled, with the directories; of fftw3 include file and library specified (see installation instructions).; Function SetDefaultFFT() allows to change the default library. Available transform types:; FFT:; - ""C2CFORWARD"" - a complex input/output discrete Fourier transform (DFT); in one or more dimensions, -1 in the exponent; - ""C2CBACKWARD""- a complex input/output discrete Fourier transform (DFT); in one or more dimensions, +1 in the exponent; - ""R2C"" - a real-input/complex-output discrete Fourier transform (DFT); in one or more dimensions,; - ""C2R"" - inverse transforms to ""R2C"", taking complex input; (storing the non-redundant half of a logically Hermitian array); to real output; - ""R2HC"" - a real-input DFT with output in ¡Èhalfcomplex¡É format,; i.e. real and imaginary parts for a transform of size n stored as; r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1; - ""HC2R"" - computes the reverse of FFTW_R2HC, above; - ""DHT"" - computes a discrete Hartley transform. Sine/cosine transforms:; Different types of transforms are specified by parameter kind of the SineCosine() static; function. 4 different kinds of sine and cosine transforms are available; DCT-I (REDFT00 in FFTW3 notation)- kind=0; DCT-II (REDFT01 in FFTW3 notation)- kind=1; DCT-III(REDFT10 in FFTW3 notation)- kind=2; DCT-IV (REDFT11 in FFTW3 notation)- kind=3; DST-I (RODFT00 in FFTW3 notation)- kind=4; DST-II (RODFT01 in FFTW3 notation)- kind=5; DST-III(RODFT10 in FFTW3 notation)- kind=6; DST-IV (RODFT11 in FFTW3 notation)- k",MatchSource.WIKI,root/html532/TVirtualFFT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualFFT.html
https://root.cern/root/html532/TVirtualFFT.html:1121,Availability,redundant,redundant,1121,". TVirtualFFT. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualFFT. class TVirtualFFT: public TObject. TVirtualFFT. TVirtualFFT is an interface class for Fast Fourier Transforms. The default FFT library is FFTW. To use it, FFTW3 library should already; be installed, and ROOT should be have fftw3 module enabled, with the directories; of fftw3 include file and library specified (see installation instructions).; Function SetDefaultFFT() allows to change the default library. Available transform types:; FFT:; - ""C2CFORWARD"" - a complex input/output discrete Fourier transform (DFT); in one or more dimensions, -1 in the exponent; - ""C2CBACKWARD""- a complex input/output discrete Fourier transform (DFT); in one or more dimensions, +1 in the exponent; - ""R2C"" - a real-input/complex-output discrete Fourier transform (DFT); in one or more dimensions,; - ""C2R"" - inverse transforms to ""R2C"", taking complex input; (storing the non-redundant half of a logically Hermitian array); to real output; - ""R2HC"" - a real-input DFT with output in ¡Èhalfcomplex¡É format,; i.e. real and imaginary parts for a transform of size n stored as; r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1; - ""HC2R"" - computes the reverse of FFTW_R2HC, above; - ""DHT"" - computes a discrete Hartley transform. Sine/cosine transforms:; Different types of transforms are specified by parameter kind of the SineCosine() static; function. 4 different kinds of sine and cosine transforms are available; DCT-I (REDFT00 in FFTW3 notation)- kind=0; DCT-II (REDFT01 in FFTW3 notation)- kind=1; DCT-III(REDFT10 in FFTW3 notation)- kind=2; DCT-IV (REDFT11 in FFTW3 notation)- kind=3; DST-I (RODFT00 in FFTW3 notation)- kind=4; DST-II (RODFT01 in FFTW3 notation)- kind=5; DST-III(RODFT10 in FFTW3 notation)- kind=6; DST-IV (RODFT11 in FFTW3 notation)- k",MatchSource.WIKI,root/html532/TVirtualFFT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualFFT.html
https://root.cern/root/html532/TVirtualFFT.html:1647,Availability,avail,available,1647,"utput discrete Fourier transform (DFT); in one or more dimensions, +1 in the exponent; - ""R2C"" - a real-input/complex-output discrete Fourier transform (DFT); in one or more dimensions,; - ""C2R"" - inverse transforms to ""R2C"", taking complex input; (storing the non-redundant half of a logically Hermitian array); to real output; - ""R2HC"" - a real-input DFT with output in ¡Èhalfcomplex¡É format,; i.e. real and imaginary parts for a transform of size n stored as; r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1; - ""HC2R"" - computes the reverse of FFTW_R2HC, above; - ""DHT"" - computes a discrete Hartley transform. Sine/cosine transforms:; Different types of transforms are specified by parameter kind of the SineCosine() static; function. 4 different kinds of sine and cosine transforms are available; DCT-I (REDFT00 in FFTW3 notation)- kind=0; DCT-II (REDFT01 in FFTW3 notation)- kind=1; DCT-III(REDFT10 in FFTW3 notation)- kind=2; DCT-IV (REDFT11 in FFTW3 notation)- kind=3; DST-I (RODFT00 in FFTW3 notation)- kind=4; DST-II (RODFT01 in FFTW3 notation)- kind=5; DST-III(RODFT10 in FFTW3 notation)- kind=6; DST-IV (RODFT11 in FFTW3 notation)- kind=7; Formulas and detailed descriptions can be found in the chapter; ""What FFTW really computes"" of the FFTW manual. NOTE: FFTW computes unnormalized transforms, so doing a transform, followed by its; inverse will give the original array, multiplied by normalization constant; (transform size(N) for FFT, 2*(N-1) for DCT-I, 2*(N+1) for DST-I, 2*N for; other sine/cosine transforms). How to use it:; Call to the static function FFT returns a pointer to a fast fourier transform; with requested parameters. Call to the static function SineCosine returns a; pointer to a sine or cosine transform with requested parameters. Example:; {; Int_t N = 10; Double_t *in = new Double_t[N];; TVirtualFFT *fftr2c = TVirtualFFT::FFT(1, &N, ""R2C"");; fftr2c->SetPoints(in);; fftr2c->Transform();; Double_t re, im;; for (Int_t i=0; i<N; i++); fftr2c->GetPointComplex(i, r",MatchSource.WIKI,root/html532/TVirtualFFT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualFFT.html
https://root.cern/root/html532/TVirtualFFT.html:3111,Availability,avail,available,3111,"the FFTW manual. NOTE: FFTW computes unnormalized transforms, so doing a transform, followed by its; inverse will give the original array, multiplied by normalization constant; (transform size(N) for FFT, 2*(N-1) for DCT-I, 2*(N+1) for DST-I, 2*N for; other sine/cosine transforms). How to use it:; Call to the static function FFT returns a pointer to a fast fourier transform; with requested parameters. Call to the static function SineCosine returns a; pointer to a sine or cosine transform with requested parameters. Example:; {; Int_t N = 10; Double_t *in = new Double_t[N];; TVirtualFFT *fftr2c = TVirtualFFT::FFT(1, &N, ""R2C"");; fftr2c->SetPoints(in);; fftr2c->Transform();; Double_t re, im;; for (Int_t i=0; i<N; i++); fftr2c->GetPointComplex(i, re, im);. fftr2c->SetPoints(in2);. fftr2c->SetPoints(in3);. }; Different options are explained in the function comments. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualFFT(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual void",MatchSource.WIKI,root/html532/TVirtualFFT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualFFT.html
https://root.cern/root/html532/TVirtualFFT.html:3951,Availability,Error,Error,3951,,MatchSource.WIKI,root/html532/TVirtualFFT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualFFT.html
https://root.cern/root/html532/TVirtualFFT.html:4080,Availability,error,error,4080,,MatchSource.WIKI,root/html532/TVirtualFFT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualFFT.html
https://root.cern/root/html532/TVirtualFFT.html:4164,Availability,error,error,4164," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; static TVirtualFFT*FFT(Int_t ndim, Int_t* n, Option_t* option); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualFFT*GetCurrentTransform(); static const char*GetDefaultFFT(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_t*GetN() const; virtual const char*TObject::GetName() const; virtual Int_tGetNdim() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual voidGetPointComplex(Int_t ipoint, Double_t& re, Double_t& im, Bool_t fromInput = kFALSE) const; virtual voidGetPointComplex(const Int_t* ipoint, Double_t& re, Double_t& im, Bool_t fromInput =",MatchSource.WIKI,root/html532/TVirtualFFT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualFFT.html
https://root.cern/root/html532/TVirtualFFT.html:9992,Availability,Avail,Available,9992,"lete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. static TStringfgDefaultdefault transformer; static TVirtualFFT*fgFFTcurrent transformer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TVirtualFFT(); destructor. TVirtualFFT* FFT(Int_t ndim, Int_t* n, Option_t* option); Returns a pointer to the FFT of requested size and type.; Parameters:; -ndim : number of transform dimensions; -n : sizes of each dimension (an array at least ndim long); -option : consists of 3 parts - flag option and an option to create a new TVirtualFFT; 1) transform type option:; Available transform types are:; C2CForward, C2CBackward, C2R, R2C, R2HC, HC2R, DHT; see class description for details; 2) flag option: choosing how much time should be spent in planning the transform:; Possible options:; ""ES"" (from ""estimate"") - no time in preparing the transform,; but probably sub-optimal performance; ""M"" (from ""measure"") - some time spend in finding the optimal way; to do the transform; ""P"" (from ""patient"") - more time spend in finding the optimal way; to do the transform; ""EX"" (from ""exhaustive"") - the most optimal way is found; This option should be chosen depending on how many transforms of the; same size and type are going to be done.; Planning is only done once, for the first transform of this size and type.; 3) option allowing to choose between the global fgFFT and a new TVirtualFFT object; """" - default, changes and returns the global fgFFT variable; ""K"" (from ""keep"")- without touching the global fgFFT,; creates and returns a new TVirtualFFT*. User is then responsible for deleting it.; Examples of valid options: ""R2C ES K"", ""C2CF M"", ""DHT P K"", etc. TVirtualFFT* SineCosine(Int_t ndim, Int_t* n, Int_t* r2rkind, Option_t* option); Returns a pointer to a sine or cosine transfor",MatchSource.WIKI,root/html532/TVirtualFFT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualFFT.html
https://root.cern/root/html532/TVirtualFFT.html:11451,Availability,avail,available,11451," 3) option allowing to choose between the global fgFFT and a new TVirtualFFT object; """" - default, changes and returns the global fgFFT variable; ""K"" (from ""keep"")- without touching the global fgFFT,; creates and returns a new TVirtualFFT*. User is then responsible for deleting it.; Examples of valid options: ""R2C ES K"", ""C2CF M"", ""DHT P K"", etc. TVirtualFFT* SineCosine(Int_t ndim, Int_t* n, Int_t* r2rkind, Option_t* option); Returns a pointer to a sine or cosine transform of requested size and kind. Parameters:; -ndim : number of transform dimensions; -n : sizes of each dimension (an array at least ndim long); -r2rkind : transform kind for each dimension; 4 different kinds of sine and cosine transforms are available; DCT-I - kind=0; DCT-II - kind=1; DCT-III - kind=2; DCT-IV - kind=3; DST-I - kind=4; DST-II - kind=5; DST-III - kind=6; DST-IV - kind=7; -option : consists of 2 parts - flag option and an option to create a new TVirtualFFT; - flag option: choosing how much time should be spent in planning the transform:; Possible options:; ""ES"" (from ""estimate"") - no time in preparing the transform,; but probably sub-optimal performance; ""M"" (from ""measure"") - some time spend in finding the optimal way; to do the transform; ""P"" (from ""patient"") - more time spend in finding the optimal way; to do the transform; ""EX"" (from ""exhaustive"") - the most optimal way is found; This option should be chosen depending on how many transforms of the; same size and type are going to be done.; Planning is only done once, for the first transform of this size and type.; - option allowing to choose between the global fgFFT and a new TVirtualFFT object; """" - default, changes and returns the global fgFFT variable; ""K"" (from ""keep"")- without touching the global fgFFT,; creates and returns a new TVirtualFFT*. User is then responsible for deleting it.; Examples of valid options: ""ES K"", ""EX"", etc. TVirtualFFT* GetCurrentTransform(); static: return current fgFFT. void SetTransform(TVirtualFFT* ff",MatchSource.WIKI,root/html532/TVirtualFFT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualFFT.html
https://root.cern/root/html532/TVirtualFFT.html:447,Deployability,install,installed,447,". TVirtualFFT. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualFFT. class TVirtualFFT: public TObject. TVirtualFFT. TVirtualFFT is an interface class for Fast Fourier Transforms. The default FFT library is FFTW. To use it, FFTW3 library should already; be installed, and ROOT should be have fftw3 module enabled, with the directories; of fftw3 include file and library specified (see installation instructions).; Function SetDefaultFFT() allows to change the default library. Available transform types:; FFT:; - ""C2CFORWARD"" - a complex input/output discrete Fourier transform (DFT); in one or more dimensions, -1 in the exponent; - ""C2CBACKWARD""- a complex input/output discrete Fourier transform (DFT); in one or more dimensions, +1 in the exponent; - ""R2C"" - a real-input/complex-output discrete Fourier transform (DFT); in one or more dimensions,; - ""C2R"" - inverse transforms to ""R2C"", taking complex input; (storing the non-redundant half of a logically Hermitian array); to real output; - ""R2HC"" - a real-input DFT with output in ¡Èhalfcomplex¡É format,; i.e. real and imaginary parts for a transform of size n stored as; r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1; - ""HC2R"" - computes the reverse of FFTW_R2HC, above; - ""DHT"" - computes a discrete Hartley transform. Sine/cosine transforms:; Different types of transforms are specified by parameter kind of the SineCosine() static; function. 4 different kinds of sine and cosine transforms are available; DCT-I (REDFT00 in FFTW3 notation)- kind=0; DCT-II (REDFT01 in FFTW3 notation)- kind=1; DCT-III(REDFT10 in FFTW3 notation)- kind=2; DCT-IV (REDFT11 in FFTW3 notation)- kind=3; DST-I (RODFT00 in FFTW3 notation)- kind=4; DST-II (RODFT01 in FFTW3 notation)- kind=5; DST-III(RODFT10 in FFTW3 notation)- kind=6; DST-IV (RODFT11 in FFTW3 notation)- k",MatchSource.WIKI,root/html532/TVirtualFFT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualFFT.html
https://root.cern/root/html532/TVirtualFFT.html:575,Deployability,install,installation,575,". TVirtualFFT. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualFFT. class TVirtualFFT: public TObject. TVirtualFFT. TVirtualFFT is an interface class for Fast Fourier Transforms. The default FFT library is FFTW. To use it, FFTW3 library should already; be installed, and ROOT should be have fftw3 module enabled, with the directories; of fftw3 include file and library specified (see installation instructions).; Function SetDefaultFFT() allows to change the default library. Available transform types:; FFT:; - ""C2CFORWARD"" - a complex input/output discrete Fourier transform (DFT); in one or more dimensions, -1 in the exponent; - ""C2CBACKWARD""- a complex input/output discrete Fourier transform (DFT); in one or more dimensions, +1 in the exponent; - ""R2C"" - a real-input/complex-output discrete Fourier transform (DFT); in one or more dimensions,; - ""C2R"" - inverse transforms to ""R2C"", taking complex input; (storing the non-redundant half of a logically Hermitian array); to real output; - ""R2HC"" - a real-input DFT with output in ¡Èhalfcomplex¡É format,; i.e. real and imaginary parts for a transform of size n stored as; r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1; - ""HC2R"" - computes the reverse of FFTW_R2HC, above; - ""DHT"" - computes a discrete Hartley transform. Sine/cosine transforms:; Different types of transforms are specified by parameter kind of the SineCosine() static; function. 4 different kinds of sine and cosine transforms are available; DCT-I (REDFT00 in FFTW3 notation)- kind=0; DCT-II (REDFT01 in FFTW3 notation)- kind=1; DCT-III(REDFT10 in FFTW3 notation)- kind=2; DCT-IV (REDFT11 in FFTW3 notation)- kind=3; DST-I (RODFT00 in FFTW3 notation)- kind=4; DST-II (RODFT01 in FFTW3 notation)- kind=5; DST-III(RODFT10 in FFTW3 notation)- kind=6; DST-IV (RODFT11 in FFTW3 notation)- k",MatchSource.WIKI,root/html532/TVirtualFFT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualFFT.html
https://root.cern/root/html532/TVirtualFFT.html:325,Integrability,interface,interface,325,". TVirtualFFT. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualFFT. class TVirtualFFT: public TObject. TVirtualFFT. TVirtualFFT is an interface class for Fast Fourier Transforms. The default FFT library is FFTW. To use it, FFTW3 library should already; be installed, and ROOT should be have fftw3 module enabled, with the directories; of fftw3 include file and library specified (see installation instructions).; Function SetDefaultFFT() allows to change the default library. Available transform types:; FFT:; - ""C2CFORWARD"" - a complex input/output discrete Fourier transform (DFT); in one or more dimensions, -1 in the exponent; - ""C2CBACKWARD""- a complex input/output discrete Fourier transform (DFT); in one or more dimensions, +1 in the exponent; - ""R2C"" - a real-input/complex-output discrete Fourier transform (DFT); in one or more dimensions,; - ""C2R"" - inverse transforms to ""R2C"", taking complex input; (storing the non-redundant half of a logically Hermitian array); to real output; - ""R2HC"" - a real-input DFT with output in ¡Èhalfcomplex¡É format,; i.e. real and imaginary parts for a transform of size n stored as; r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1; - ""HC2R"" - computes the reverse of FFTW_R2HC, above; - ""DHT"" - computes a discrete Hartley transform. Sine/cosine transforms:; Different types of transforms are specified by parameter kind of the SineCosine() static; function. 4 different kinds of sine and cosine transforms are available; DCT-I (REDFT00 in FFTW3 notation)- kind=0; DCT-II (REDFT01 in FFTW3 notation)- kind=1; DCT-III(REDFT10 in FFTW3 notation)- kind=2; DCT-IV (REDFT11 in FFTW3 notation)- kind=3; DST-I (RODFT00 in FFTW3 notation)- kind=4; DST-II (RODFT01 in FFTW3 notation)- kind=5; DST-III(RODFT10 in FFTW3 notation)- kind=6; DST-IV (RODFT11 in FFTW3 notation)- k",MatchSource.WIKI,root/html532/TVirtualFFT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualFFT.html
https://root.cern/root/html532/TVirtualFFT.html:10576,Integrability,depend,depending,10576,"lete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. static TStringfgDefaultdefault transformer; static TVirtualFFT*fgFFTcurrent transformer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TVirtualFFT(); destructor. TVirtualFFT* FFT(Int_t ndim, Int_t* n, Option_t* option); Returns a pointer to the FFT of requested size and type.; Parameters:; -ndim : number of transform dimensions; -n : sizes of each dimension (an array at least ndim long); -option : consists of 3 parts - flag option and an option to create a new TVirtualFFT; 1) transform type option:; Available transform types are:; C2CForward, C2CBackward, C2R, R2C, R2HC, HC2R, DHT; see class description for details; 2) flag option: choosing how much time should be spent in planning the transform:; Possible options:; ""ES"" (from ""estimate"") - no time in preparing the transform,; but probably sub-optimal performance; ""M"" (from ""measure"") - some time spend in finding the optimal way; to do the transform; ""P"" (from ""patient"") - more time spend in finding the optimal way; to do the transform; ""EX"" (from ""exhaustive"") - the most optimal way is found; This option should be chosen depending on how many transforms of the; same size and type are going to be done.; Planning is only done once, for the first transform of this size and type.; 3) option allowing to choose between the global fgFFT and a new TVirtualFFT object; """" - default, changes and returns the global fgFFT variable; ""K"" (from ""keep"")- without touching the global fgFFT,; creates and returns a new TVirtualFFT*. User is then responsible for deleting it.; Examples of valid options: ""R2C ES K"", ""C2CF M"", ""DHT P K"", etc. TVirtualFFT* SineCosine(Int_t ndim, Int_t* n, Int_t* r2rkind, Option_t* option); Returns a pointer to a sine or cosine transfor",MatchSource.WIKI,root/html532/TVirtualFFT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualFFT.html
https://root.cern/root/html532/TVirtualFFT.html:12149,Integrability,depend,depending,12149," 3) option allowing to choose between the global fgFFT and a new TVirtualFFT object; """" - default, changes and returns the global fgFFT variable; ""K"" (from ""keep"")- without touching the global fgFFT,; creates and returns a new TVirtualFFT*. User is then responsible for deleting it.; Examples of valid options: ""R2C ES K"", ""C2CF M"", ""DHT P K"", etc. TVirtualFFT* SineCosine(Int_t ndim, Int_t* n, Int_t* r2rkind, Option_t* option); Returns a pointer to a sine or cosine transform of requested size and kind. Parameters:; -ndim : number of transform dimensions; -n : sizes of each dimension (an array at least ndim long); -r2rkind : transform kind for each dimension; 4 different kinds of sine and cosine transforms are available; DCT-I - kind=0; DCT-II - kind=1; DCT-III - kind=2; DCT-IV - kind=3; DST-I - kind=4; DST-II - kind=5; DST-III - kind=6; DST-IV - kind=7; -option : consists of 2 parts - flag option and an option to create a new TVirtualFFT; - flag option: choosing how much time should be spent in planning the transform:; Possible options:; ""ES"" (from ""estimate"") - no time in preparing the transform,; but probably sub-optimal performance; ""M"" (from ""measure"") - some time spend in finding the optimal way; to do the transform; ""P"" (from ""patient"") - more time spend in finding the optimal way; to do the transform; ""EX"" (from ""exhaustive"") - the most optimal way is found; This option should be chosen depending on how many transforms of the; same size and type are going to be done.; Planning is only done once, for the first transform of this size and type.; - option allowing to choose between the global fgFFT and a new TVirtualFFT object; """" - default, changes and returns the global fgFFT variable; ""K"" (from ""keep"")- without touching the global fgFFT,; creates and returns a new TVirtualFFT*. User is then responsible for deleting it.; Examples of valid options: ""ES K"", ""EX"", etc. TVirtualFFT* GetCurrentTransform(); static: return current fgFFT. void SetTransform(TVirtualFFT* ff",MatchSource.WIKI,root/html532/TVirtualFFT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualFFT.html
https://root.cern/root/html532/TVirtualFFT.html:6033,Modifiability,Inherit,InheritsFrom,6033,"ool_t fromInput = kFALSE) const; virtual voidGetPointComplex(const Int_t* ipoint, Double_t& re, Double_t& im, Bool_t fromInput = kFALSE) const; virtual Double_tGetPointReal(Int_t ipoint, Bool_t fromInput = kFALSE) const; virtual Double_tGetPointReal(const Int_t* ipoint, Bool_t fromInput = kFALSE) const; virtual voidGetPoints(Double_t* data, Bool_t fromInput = kFALSE) const; virtual voidGetPointsComplex(Double_t* data, Bool_t fromInput = kFALSE) const; virtual voidGetPointsComplex(Double_t* re, Double_t* im, Bool_t fromInput = kFALSE) const; virtual Double_t*GetPointsReal(Bool_t fromInput = kFALSE) const; virtual Int_tGetSign() const; virtual const char*TObject::GetTitle() const; virtual Option_t*GetTransformFlag() const; virtual Option_t*GetType() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidInit(Option_t* flag, Int_t sign, const Int_t* kind); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tIsInplace() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); ",MatchSource.WIKI,root/html532/TVirtualFFT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualFFT.html
https://root.cern/root/html532/TVirtualFFT.html:6099,Modifiability,Inherit,InheritsFrom,6099," Int_t* ipoint, Double_t& re, Double_t& im, Bool_t fromInput = kFALSE) const; virtual Double_tGetPointReal(Int_t ipoint, Bool_t fromInput = kFALSE) const; virtual Double_tGetPointReal(const Int_t* ipoint, Bool_t fromInput = kFALSE) const; virtual voidGetPoints(Double_t* data, Bool_t fromInput = kFALSE) const; virtual voidGetPointsComplex(Double_t* data, Bool_t fromInput = kFALSE) const; virtual voidGetPointsComplex(Double_t* re, Double_t* im, Bool_t fromInput = kFALSE) const; virtual Double_t*GetPointsReal(Bool_t fromInput = kFALSE) const; virtual Int_tGetSign() const; virtual const char*TObject::GetTitle() const; virtual Option_t*GetTransformFlag() const; virtual Option_t*GetType() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidInit(Option_t* flag, Int_t sign, const Int_t* kind); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tIsInplace() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::ope",MatchSource.WIKI,root/html532/TVirtualFFT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualFFT.html
https://root.cern/root/html532/TVirtualFFT.html:9544,Modifiability,Inherit,Inheritance,9544,"st char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTransform(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. static TStringfgDefaultdefault transformer; static TVirtualFFT*fgFFTcurrent transformer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TVirtualFFT(); destructor. TVirtualFFT* FFT(Int_t ndim, Int_t* n, Option_t* option); Returns a pointer to the FFT of requested size and type.; Parameters:; -ndim : number of transform dimensions; -n : sizes of each dimension (an array at least ndim long); -option : consists of 3 parts - flag option and an option to create a new TVirtualFFT; 1) transform type option:; Available transform types are:; C2CForward, C2CBackward, C2R, R2C, R2HC, HC2R, DHT; see class description for details; 2) flag option: choosing how much time should be spent in planning the transform:; Possible options:; ""ES"" (from ""estimate"") - no time in preparing the transform,; but probably sub-optimal performance; ""M"" (from ""measure"") - some time spend in finding the optimal way; to do the transform; ""P"" (from ""patient"") - more time spend in finding the optimal way; to do the transform; ""EX"" (from ""exhaustive"") - the most optimal way is found; This option should be c",MatchSource.WIKI,root/html532/TVirtualFFT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualFFT.html
https://root.cern/root/html532/TVirtualFFT.html:9557,Modifiability,Inherit,Inherited,9557,"st char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTransform(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. static TStringfgDefaultdefault transformer; static TVirtualFFT*fgFFTcurrent transformer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TVirtualFFT(); destructor. TVirtualFFT* FFT(Int_t ndim, Int_t* n, Option_t* option); Returns a pointer to the FFT of requested size and type.; Parameters:; -ndim : number of transform dimensions; -n : sizes of each dimension (an array at least ndim long); -option : consists of 3 parts - flag option and an option to create a new TVirtualFFT; 1) transform type option:; Available transform types are:; C2CForward, C2CBackward, C2R, R2C, R2HC, HC2R, DHT; see class description for details; 2) flag option: choosing how much time should be spent in planning the transform:; Possible options:; ""ES"" (from ""estimate"") - no time in preparing the transform,; but probably sub-optimal performance; ""M"" (from ""measure"") - some time spend in finding the optimal way; to do the transform; ""P"" (from ""patient"") - more time spend in finding the optimal way; to do the transform; ""EX"" (from ""exhaustive"") - the most optimal way is found; This option should be c",MatchSource.WIKI,root/html532/TVirtualFFT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualFFT.html
https://root.cern/root/html532/TVirtualFFT.html:10870,Modifiability,variab,variable,10870,"ray at least ndim long); -option : consists of 3 parts - flag option and an option to create a new TVirtualFFT; 1) transform type option:; Available transform types are:; C2CForward, C2CBackward, C2R, R2C, R2HC, HC2R, DHT; see class description for details; 2) flag option: choosing how much time should be spent in planning the transform:; Possible options:; ""ES"" (from ""estimate"") - no time in preparing the transform,; but probably sub-optimal performance; ""M"" (from ""measure"") - some time spend in finding the optimal way; to do the transform; ""P"" (from ""patient"") - more time spend in finding the optimal way; to do the transform; ""EX"" (from ""exhaustive"") - the most optimal way is found; This option should be chosen depending on how many transforms of the; same size and type are going to be done.; Planning is only done once, for the first transform of this size and type.; 3) option allowing to choose between the global fgFFT and a new TVirtualFFT object; """" - default, changes and returns the global fgFFT variable; ""K"" (from ""keep"")- without touching the global fgFFT,; creates and returns a new TVirtualFFT*. User is then responsible for deleting it.; Examples of valid options: ""R2C ES K"", ""C2CF M"", ""DHT P K"", etc. TVirtualFFT* SineCosine(Int_t ndim, Int_t* n, Int_t* r2rkind, Option_t* option); Returns a pointer to a sine or cosine transform of requested size and kind. Parameters:; -ndim : number of transform dimensions; -n : sizes of each dimension (an array at least ndim long); -r2rkind : transform kind for each dimension; 4 different kinds of sine and cosine transforms are available; DCT-I - kind=0; DCT-II - kind=1; DCT-III - kind=2; DCT-IV - kind=3; DST-I - kind=4; DST-II - kind=5; DST-III - kind=6; DST-IV - kind=7; -option : consists of 2 parts - flag option and an option to create a new TVirtualFFT; - flag option: choosing how much time should be spent in planning the transform:; Possible options:; ""ES"" (from ""estimate"") - no time in preparing the transform,; but pr",MatchSource.WIKI,root/html532/TVirtualFFT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualFFT.html
https://root.cern/root/html532/TVirtualFFT.html:12442,Modifiability,variab,variable,12442,"nd cosine transforms are available; DCT-I - kind=0; DCT-II - kind=1; DCT-III - kind=2; DCT-IV - kind=3; DST-I - kind=4; DST-II - kind=5; DST-III - kind=6; DST-IV - kind=7; -option : consists of 2 parts - flag option and an option to create a new TVirtualFFT; - flag option: choosing how much time should be spent in planning the transform:; Possible options:; ""ES"" (from ""estimate"") - no time in preparing the transform,; but probably sub-optimal performance; ""M"" (from ""measure"") - some time spend in finding the optimal way; to do the transform; ""P"" (from ""patient"") - more time spend in finding the optimal way; to do the transform; ""EX"" (from ""exhaustive"") - the most optimal way is found; This option should be chosen depending on how many transforms of the; same size and type are going to be done.; Planning is only done once, for the first transform of this size and type.; - option allowing to choose between the global fgFFT and a new TVirtualFFT object; """" - default, changes and returns the global fgFFT variable; ""K"" (from ""keep"")- without touching the global fgFFT,; creates and returns a new TVirtualFFT*. User is then responsible for deleting it.; Examples of valid options: ""ES K"", ""EX"", etc. TVirtualFFT* GetCurrentTransform(); static: return current fgFFT. void SetTransform(TVirtualFFT* fft); static: set the current transfrom to parameter. const char * GetDefaultFFT(); static: return the name of the default fft. void SetDefaultFFT(const char* name = """"); static: set name of default fft. Int_t * GetN() const. Int_t GetNdim() const. Option_t * GetType() const. Int_t GetSign() const. Option_t * GetTransformFlag() const. void Init(Option_t* flag, Int_t sign, const Int_t* kind). Bool_t IsInplace() const. void GetPoints(Double_t* data, Bool_t fromInput = kFALSE) const. Double_t GetPointReal(Int_t ipoint, Bool_t fromInput = kFALSE) const. Double_t GetPointReal(const Int_t* ipoint, Bool_t fromInput = kFALSE) const. void GetPointComplex(Int_t ipoint, Double_t& re, Double_t& i",MatchSource.WIKI,root/html532/TVirtualFFT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualFFT.html
https://root.cern/root/html532/TVirtualFFT.html:10300,Performance,perform,performance,10300,"lete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. static TStringfgDefaultdefault transformer; static TVirtualFFT*fgFFTcurrent transformer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TVirtualFFT(); destructor. TVirtualFFT* FFT(Int_t ndim, Int_t* n, Option_t* option); Returns a pointer to the FFT of requested size and type.; Parameters:; -ndim : number of transform dimensions; -n : sizes of each dimension (an array at least ndim long); -option : consists of 3 parts - flag option and an option to create a new TVirtualFFT; 1) transform type option:; Available transform types are:; C2CForward, C2CBackward, C2R, R2C, R2HC, HC2R, DHT; see class description for details; 2) flag option: choosing how much time should be spent in planning the transform:; Possible options:; ""ES"" (from ""estimate"") - no time in preparing the transform,; but probably sub-optimal performance; ""M"" (from ""measure"") - some time spend in finding the optimal way; to do the transform; ""P"" (from ""patient"") - more time spend in finding the optimal way; to do the transform; ""EX"" (from ""exhaustive"") - the most optimal way is found; This option should be chosen depending on how many transforms of the; same size and type are going to be done.; Planning is only done once, for the first transform of this size and type.; 3) option allowing to choose between the global fgFFT and a new TVirtualFFT object; """" - default, changes and returns the global fgFFT variable; ""K"" (from ""keep"")- without touching the global fgFFT,; creates and returns a new TVirtualFFT*. User is then responsible for deleting it.; Examples of valid options: ""R2C ES K"", ""C2CF M"", ""DHT P K"", etc. TVirtualFFT* SineCosine(Int_t ndim, Int_t* n, Int_t* r2rkind, Option_t* option); Returns a pointer to a sine or cosine transfor",MatchSource.WIKI,root/html532/TVirtualFFT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualFFT.html
https://root.cern/root/html532/TVirtualFFT.html:11873,Performance,perform,performance,11873," 3) option allowing to choose between the global fgFFT and a new TVirtualFFT object; """" - default, changes and returns the global fgFFT variable; ""K"" (from ""keep"")- without touching the global fgFFT,; creates and returns a new TVirtualFFT*. User is then responsible for deleting it.; Examples of valid options: ""R2C ES K"", ""C2CF M"", ""DHT P K"", etc. TVirtualFFT* SineCosine(Int_t ndim, Int_t* n, Int_t* r2rkind, Option_t* option); Returns a pointer to a sine or cosine transform of requested size and kind. Parameters:; -ndim : number of transform dimensions; -n : sizes of each dimension (an array at least ndim long); -r2rkind : transform kind for each dimension; 4 different kinds of sine and cosine transforms are available; DCT-I - kind=0; DCT-II - kind=1; DCT-III - kind=2; DCT-IV - kind=3; DST-I - kind=4; DST-II - kind=5; DST-III - kind=6; DST-IV - kind=7; -option : consists of 2 parts - flag option and an option to create a new TVirtualFFT; - flag option: choosing how much time should be spent in planning the transform:; Possible options:; ""ES"" (from ""estimate"") - no time in preparing the transform,; but probably sub-optimal performance; ""M"" (from ""measure"") - some time spend in finding the optimal way; to do the transform; ""P"" (from ""patient"") - more time spend in finding the optimal way; to do the transform; ""EX"" (from ""exhaustive"") - the most optimal way is found; This option should be chosen depending on how many transforms of the; same size and type are going to be done.; Planning is only done once, for the first transform of this size and type.; - option allowing to choose between the global fgFFT and a new TVirtualFFT object; """" - default, changes and returns the global fgFFT variable; ""K"" (from ""keep"")- without touching the global fgFFT,; creates and returns a new TVirtualFFT*. User is then responsible for deleting it.; Examples of valid options: ""ES K"", ""EX"", etc. TVirtualFFT* GetCurrentTransform(); static: return current fgFFT. void SetTransform(TVirtualFFT* ff",MatchSource.WIKI,root/html532/TVirtualFFT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualFFT.html
https://root.cern/root/html532/TVirtualFFT.html:1121,Safety,redund,redundant,1121,". TVirtualFFT. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualFFT. class TVirtualFFT: public TObject. TVirtualFFT. TVirtualFFT is an interface class for Fast Fourier Transforms. The default FFT library is FFTW. To use it, FFTW3 library should already; be installed, and ROOT should be have fftw3 module enabled, with the directories; of fftw3 include file and library specified (see installation instructions).; Function SetDefaultFFT() allows to change the default library. Available transform types:; FFT:; - ""C2CFORWARD"" - a complex input/output discrete Fourier transform (DFT); in one or more dimensions, -1 in the exponent; - ""C2CBACKWARD""- a complex input/output discrete Fourier transform (DFT); in one or more dimensions, +1 in the exponent; - ""R2C"" - a real-input/complex-output discrete Fourier transform (DFT); in one or more dimensions,; - ""C2R"" - inverse transforms to ""R2C"", taking complex input; (storing the non-redundant half of a logically Hermitian array); to real output; - ""R2HC"" - a real-input DFT with output in ¡Èhalfcomplex¡É format,; i.e. real and imaginary parts for a transform of size n stored as; r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1; - ""HC2R"" - computes the reverse of FFTW_R2HC, above; - ""DHT"" - computes a discrete Hartley transform. Sine/cosine transforms:; Different types of transforms are specified by parameter kind of the SineCosine() static; function. 4 different kinds of sine and cosine transforms are available; DCT-I (REDFT00 in FFTW3 notation)- kind=0; DCT-II (REDFT01 in FFTW3 notation)- kind=1; DCT-III(REDFT10 in FFTW3 notation)- kind=2; DCT-IV (REDFT11 in FFTW3 notation)- kind=3; DST-I (RODFT00 in FFTW3 notation)- kind=4; DST-II (RODFT01 in FFTW3 notation)- kind=5; DST-III(RODFT10 in FFTW3 notation)- kind=6; DST-IV (RODFT11 in FFTW3 notation)- k",MatchSource.WIKI,root/html532/TVirtualFFT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualFFT.html
https://root.cern/root/html532/TVirtualFFT.html:5923,Security,Hash,Hash,5923,"rtual Option_t*TObject::GetOption() const; virtual voidGetPointComplex(Int_t ipoint, Double_t& re, Double_t& im, Bool_t fromInput = kFALSE) const; virtual voidGetPointComplex(const Int_t* ipoint, Double_t& re, Double_t& im, Bool_t fromInput = kFALSE) const; virtual Double_tGetPointReal(Int_t ipoint, Bool_t fromInput = kFALSE) const; virtual Double_tGetPointReal(const Int_t* ipoint, Bool_t fromInput = kFALSE) const; virtual voidGetPoints(Double_t* data, Bool_t fromInput = kFALSE) const; virtual voidGetPointsComplex(Double_t* data, Bool_t fromInput = kFALSE) const; virtual voidGetPointsComplex(Double_t* re, Double_t* im, Bool_t fromInput = kFALSE) const; virtual Double_t*GetPointsReal(Bool_t fromInput = kFALSE) const; virtual Int_tGetSign() const; virtual const char*TObject::GetTitle() const; virtual Option_t*GetTransformFlag() const; virtual Option_t*GetType() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidInit(Option_t* flag, Int_t sign, const Int_t* kind); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tIsInplace() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete",MatchSource.WIKI,root/html532/TVirtualFFT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualFFT.html
https://root.cern/root/html532/TVirtualFFT.html:1141,Testability,log,logically,1141,". TVirtualFFT. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualFFT. class TVirtualFFT: public TObject. TVirtualFFT. TVirtualFFT is an interface class for Fast Fourier Transforms. The default FFT library is FFTW. To use it, FFTW3 library should already; be installed, and ROOT should be have fftw3 module enabled, with the directories; of fftw3 include file and library specified (see installation instructions).; Function SetDefaultFFT() allows to change the default library. Available transform types:; FFT:; - ""C2CFORWARD"" - a complex input/output discrete Fourier transform (DFT); in one or more dimensions, -1 in the exponent; - ""C2CBACKWARD""- a complex input/output discrete Fourier transform (DFT); in one or more dimensions, +1 in the exponent; - ""R2C"" - a real-input/complex-output discrete Fourier transform (DFT); in one or more dimensions,; - ""C2R"" - inverse transforms to ""R2C"", taking complex input; (storing the non-redundant half of a logically Hermitian array); to real output; - ""R2HC"" - a real-input DFT with output in ¡Èhalfcomplex¡É format,; i.e. real and imaginary parts for a transform of size n stored as; r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1; - ""HC2R"" - computes the reverse of FFTW_R2HC, above; - ""DHT"" - computes a discrete Hartley transform. Sine/cosine transforms:; Different types of transforms are specified by parameter kind of the SineCosine() static; function. 4 different kinds of sine and cosine transforms are available; DCT-I (REDFT00 in FFTW3 notation)- kind=0; DCT-II (REDFT01 in FFTW3 notation)- kind=1; DCT-III(REDFT10 in FFTW3 notation)- kind=2; DCT-IV (REDFT11 in FFTW3 notation)- kind=3; DST-I (RODFT00 in FFTW3 notation)- kind=4; DST-II (RODFT01 in FFTW3 notation)- kind=5; DST-III(RODFT10 in FFTW3 notation)- kind=6; DST-IV (RODFT11 in FFTW3 notation)- k",MatchSource.WIKI,root/html532/TVirtualFFT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualFFT.html
https://root.cern/root/html532/TVirtualFFT.html:8628,Testability,Test,TestBit,8628,":operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TVirtualFFT&operator=(const TVirtualFFT&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidSetDefaultFFT(const char* name = """"); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoint(Int_t ipoint, Double_t re, Double_t im = 0); virtual voidSetPoint(const Int_t* ipoint, Double_t re, Double_t im = 0); virtual voidSetPointComplex(Int_t ipoint, TComplex& c); virtual voidSetPoints(const Double_t* data); virtual voidSetPointsComplex(const Double_t* re, const Double_t* im); static voidSetTransform(TVirtualFFT* fft); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); static TVirtualFFT*SineCosine(Int_t ndim, Int_t* n, Int_t* r2rkind, Option_t* option); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTransform(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TVirtualFFT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualFFT.html
https://root.cern/root/html532/TVirtualFFT.html:8667,Testability,Test,TestBits,8667,":operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TVirtualFFT&operator=(const TVirtualFFT&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidSetDefaultFFT(const char* name = """"); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoint(Int_t ipoint, Double_t re, Double_t im = 0); virtual voidSetPoint(const Int_t* ipoint, Double_t re, Double_t im = 0); virtual voidSetPointComplex(Int_t ipoint, TComplex& c); virtual voidSetPoints(const Double_t* data); virtual voidSetPointsComplex(const Double_t* re, const Double_t* im); static voidSetTransform(TVirtualFFT* fft); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); static TVirtualFFT*SineCosine(Int_t ndim, Int_t* n, Int_t* r2rkind, Option_t* option); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTransform(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TVirtualFFT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualFFT.html
https://root.cern/root/html532/TVirtualFFT.html:3411,Usability,Clear,Clear,3411,,MatchSource.WIKI,root/html532/TVirtualFFT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualFFT.html
https://root.cern/root/html532/TVirtualFitter.html:473,Availability,avail,available,473,". TVirtualFitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » TVirtualFitter. class TVirtualFitter: public TNamed. Abstract Base Class for Fitting. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualFitter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual Int_tExecuteCommand(const char* command, Double_t* args, Int_t nargs); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVir",MatchSource.WIKI,root/html532/TVirtualFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualFitter.html
https://root.cern/root/html532/TVirtualFitter.html:1373,Availability,Error,Error,1373,"itting. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualFitter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual Int_tExecuteCommand(const char* command, Double_t* args, Int_t nargs); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualFitter*Fitter(TObject* obj, Int_t maxpar = 25); virtual voidFixParameter(Int_t ipar); virtual voidGetConfidenceIntervals(TObject* obj, Double_t cl = 0.95); virtual voidGetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, Double_t* ci, Double_t cl = 0.95); virtual Double_t*GetCovarianceMatrix() const; virtual Double",MatchSource.WIKI,root/html532/TVirtualFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualFitter.html
https://root.cern/root/html532/TVirtualFitter.html:1502,Availability,error,error,1502,"itting. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualFitter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual Int_tExecuteCommand(const char* command, Double_t* args, Int_t nargs); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualFitter*Fitter(TObject* obj, Int_t maxpar = 25); virtual voidFixParameter(Int_t ipar); virtual voidGetConfidenceIntervals(TObject* obj, Double_t cl = 0.95); virtual voidGetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, Double_t* ci, Double_t cl = 0.95); virtual Double_t*GetCovarianceMatrix() const; virtual Double",MatchSource.WIKI,root/html532/TVirtualFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualFitter.html
https://root.cern/root/html532/TVirtualFitter.html:1586,Availability,error,error,1586,"itting. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualFitter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual Int_tExecuteCommand(const char* command, Double_t* args, Int_t nargs); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualFitter*Fitter(TObject* obj, Int_t maxpar = 25); virtual voidFixParameter(Int_t ipar); virtual voidGetConfidenceIntervals(TObject* obj, Double_t cl = 0.95); virtual voidGetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, Double_t* ci, Double_t cl = 0.95); virtual Double_t*GetCovarianceMatrix() const; virtual Double",MatchSource.WIKI,root/html532/TVirtualFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualFitter.html
https://root.cern/root/html532/TVirtualFitter.html:10448,Availability,Error,Error,10448,"TVirtualFitter& operator=(const TVirtualFitter& tvf); assignment operator. ~TVirtualFitter(); Cleanup virtual fitter. TVirtualFitter * Fitter(TObject* obj, Int_t maxpar = 25); Static function returning a pointer to the current fitter.; If the fitter does not exist, the default TFitter is created.; Don't delete the returned fitter object, it will be re-used. void GetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, Double_t* ci, Double_t cl = 0.95); return confidence intervals in array x of dimension ndim; implemented in TFitter and TLinearFitter. void GetConfidenceIntervals(TObject* obj, Double_t cl = 0.95); return confidence intervals in TObject obj; implemented in TFitter and TLinearFitter. const char * GetDefaultFitter(); static: return the name of the default fitter. TVirtualFitter * GetFitter(); static: return the current Fitter. Int_t GetMaxIterations(); static: Return the maximum number of iterations; actually max number of function calls. Double_t GetErrorDef(); static: Return the Error Definition. Double_t GetPrecision(); static: Return the fit relative precision. void SetDefaultFitter(const char* name = """"); static: set name of default fitter. void SetFitter(TVirtualFitter* fitter, Int_t maxpar = 25); Static function to set an alternative fitter. void SetFCN(void (*fcn)(Int_t &, Double_t *, Double_t &f, Double_t *, Int_t)); To set the address of the minimization objective function; called by the native compiler (see function below when called by CINT). Double_t * SetCache(Int_t npoints, Int_t psize); Initialize the cache array; npoints is the number of points to be stored (or already stored) in the cache; psize is the number of elements per point. if (npoints*psize > fCacheSize) the existing cache is deleted; and a new array is created.; The function returns a pointer to the cache. void SetFCN(void* fcn); To set the address of the minimization objective function. this function is called by CINT instead of the function above. void SetMaxIterations(",MatchSource.WIKI,root/html532/TVirtualFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualFitter.html
https://root.cern/root/html532/TVirtualFitter.html:11732,Availability,Error,Error,11732,"t *, Double_t &f, Double_t *, Int_t)); To set the address of the minimization objective function; called by the native compiler (see function below when called by CINT). Double_t * SetCache(Int_t npoints, Int_t psize); Initialize the cache array; npoints is the number of points to be stored (or already stored) in the cache; psize is the number of elements per point. if (npoints*psize > fCacheSize) the existing cache is deleted; and a new array is created.; The function returns a pointer to the cache. void SetFCN(void* fcn); To set the address of the minimization objective function. this function is called by CINT instead of the function above. void SetMaxIterations(Int_t niter = 5000); static: Set the maximum number of function calls for the minimization algorithm; For example for MIGRAD this is the maxcalls value passed as first argument; (see http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html ). void SetErrorDef(Double_t errdef = 1); static: Set the Error Definition (default=1); For Minuit this is the value passed with the ""SET ERR"" command; (see http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html). void SetPrecision(Double_t prec = 1e-6); static: Set the tolerance used in the minimization algorithm; For example for MIGRAD this is tolerance value passed as second argument; (see http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html ). Double_t Chisquare(Int_t npar, Double_t* params) const. void Clear(Option_t* option = """"). Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs). void FixParameter(Int_t ipar). Double_t * GetCovarianceMatrix() const. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const. FCNFunc_t GetFCN(); { return fFCN; }. Foption_t GetFitOption() const; {return fOption;}. TMethodCall * GetMethodCall() const; {return fMethodCall;}. Int_t GetNumberTotalParameters() const. Int_t GetNumberFreeParameters() const. TOb",MatchSource.WIKI,root/html532/TVirtualFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualFitter.html
https://root.cern/root/html532/TVirtualFitter.html:11946,Availability,toler,tolerance,11946,"ize the cache array; npoints is the number of points to be stored (or already stored) in the cache; psize is the number of elements per point. if (npoints*psize > fCacheSize) the existing cache is deleted; and a new array is created.; The function returns a pointer to the cache. void SetFCN(void* fcn); To set the address of the minimization objective function. this function is called by CINT instead of the function above. void SetMaxIterations(Int_t niter = 5000); static: Set the maximum number of function calls for the minimization algorithm; For example for MIGRAD this is the maxcalls value passed as first argument; (see http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html ). void SetErrorDef(Double_t errdef = 1); static: Set the Error Definition (default=1); For Minuit this is the value passed with the ""SET ERR"" command; (see http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html). void SetPrecision(Double_t prec = 1e-6); static: Set the tolerance used in the minimization algorithm; For example for MIGRAD this is tolerance value passed as second argument; (see http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html ). Double_t Chisquare(Int_t npar, Double_t* params) const. void Clear(Option_t* option = """"). Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs). void FixParameter(Int_t ipar). Double_t * GetCovarianceMatrix() const. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const. FCNFunc_t GetFCN(); { return fFCN; }. Foption_t GetFitOption() const; {return fOption;}. TMethodCall * GetMethodCall() const; {return fMethodCall;}. Int_t GetNumberTotalParameters() const. Int_t GetNumberFreeParameters() const. TObject * GetObjectFit() const; {return fObjectFit;}. Double_t GetParError(Int_t ipar) const. Double_t GetParameter(Int_t ipar) const. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Do",MatchSource.WIKI,root/html532/TVirtualFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualFitter.html
https://root.cern/root/html532/TVirtualFitter.html:12023,Availability,toler,tolerance,12023,"ize the cache array; npoints is the number of points to be stored (or already stored) in the cache; psize is the number of elements per point. if (npoints*psize > fCacheSize) the existing cache is deleted; and a new array is created.; The function returns a pointer to the cache. void SetFCN(void* fcn); To set the address of the minimization objective function. this function is called by CINT instead of the function above. void SetMaxIterations(Int_t niter = 5000); static: Set the maximum number of function calls for the minimization algorithm; For example for MIGRAD this is the maxcalls value passed as first argument; (see http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html ). void SetErrorDef(Double_t errdef = 1); static: Set the Error Definition (default=1); For Minuit this is the value passed with the ""SET ERR"" command; (see http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html). void SetPrecision(Double_t prec = 1e-6); static: Set the tolerance used in the minimization algorithm; For example for MIGRAD this is tolerance value passed as second argument; (see http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html ). Double_t Chisquare(Int_t npar, Double_t* params) const. void Clear(Option_t* option = """"). Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs). void FixParameter(Int_t ipar). Double_t * GetCovarianceMatrix() const. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const. FCNFunc_t GetFCN(); { return fFCN; }. Foption_t GetFitOption() const; {return fOption;}. TMethodCall * GetMethodCall() const; {return fMethodCall;}. Int_t GetNumberTotalParameters() const. Int_t GetNumberFreeParameters() const. TObject * GetObjectFit() const; {return fObjectFit;}. Double_t GetParError(Int_t ipar) const. Double_t GetParameter(Int_t ipar) const. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Do",MatchSource.WIKI,root/html532/TVirtualFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualFitter.html
https://root.cern/root/html532/TVirtualFitter.html:13583,Deployability,Release,ReleaseParameter,13583,"tion() const; {return fOption;}. TMethodCall * GetMethodCall() const; {return fMethodCall;}. Int_t GetNumberTotalParameters() const. Int_t GetNumberFreeParameters() const. TObject * GetObjectFit() const; {return fObjectFit;}. Double_t GetParError(Int_t ipar) const. Double_t GetParameter(Int_t ipar) const. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const. const char * GetParName(Int_t ipar) const. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const. Double_t GetSumLog(Int_t i). TObject * GetUserFunc() const; {return fUserFunc;}. Int_t GetXfirst() const; {return fXfirst;}. Int_t GetXlast() const; {return fXlast;}. Int_t GetYfirst() const; {return fYfirst;}. Int_t GetYlast() const; {return fYlast;}. Int_t GetZfirst() const; {return fZfirst;}. Int_t GetZlast() const; {return fZlast;}. Bool_t IsFixed(Int_t ipar) const. void PrintResults(Int_t level, Double_t amin) const. void ReleaseParameter(Int_t ipar). void SetFitMethod(const char* name). void SetFitOption(Foption_t option); {fOption = option;}. void SetObjectFit(TObject* obj); {fObjectFit = obj;}. Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh). void SetUserFunc(TObject* userfunc); {fUserFunc = userfunc;}. void SetXfirst(Int_t first); {fXfirst = first;}. void SetXlast(Int_t last); {fXlast = last;}. void SetYfirst(Int_t first); {fYfirst = first;}. void SetYlast(Int_t last); {fYlast = last;}. void SetZfirst(Int_t first); {fZfirst = first;}. void SetZlast(Int_t last); {fZlast = last;}. » Author: Rene Brun 31/08/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/mathcore:$Id: TVirtualFitter.h 25927 2008-10-22 23:42:01Z rdm $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TVirtualFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualFitter.html
https://root.cern/root/html532/TVirtualFitter.html:4146,Modifiability,Inherit,InheritsFrom,4146,"ctStat(); virtual Option_t*TObject::GetOption() const; virtual Double_tGetParameter(Int_t ipar) const; virtual Int_tGetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; virtual Double_tGetParError(Int_t ipar) const; virtual const char*GetParName(Int_t ipar) const; static Double_tGetPrecision(); virtual Int_tGetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; virtual Double_tGetSumLog(Int_t i); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual TObject*GetUserFunc() const; virtual Int_tGetXfirst() const; virtual Int_tGetXlast() const; virtual Int_tGetYfirst() const; virtual Int_tGetYlast() const; virtual Int_tGetZfirst() const; virtual Int_tGetZlast() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFixed(Int_t ipar) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObje",MatchSource.WIKI,root/html532/TVirtualFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualFitter.html
https://root.cern/root/html532/TVirtualFitter.html:4212,Modifiability,Inherit,InheritsFrom,4212,"ble_tGetParameter(Int_t ipar) const; virtual Int_tGetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; virtual Double_tGetParError(Int_t ipar) const; virtual const char*GetParName(Int_t ipar) const; static Double_tGetPrecision(); virtual Int_tGetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; virtual Double_tGetSumLog(Int_t i); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual TObject*GetUserFunc() const; virtual Int_tGetXfirst() const; virtual Int_tGetXlast() const; virtual Int_tGetYfirst() const; virtual Int_tGetYlast() const; virtual Int_tGetZfirst() const; virtual Int_tGetZlast() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFixed(Int_t ipar) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t",MatchSource.WIKI,root/html532/TVirtualFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualFitter.html
https://root.cern/root/html532/TVirtualFitter.html:9357,Modifiability,Inherit,Inheritance,9357,"; TMethodCall*fMethodCallPointer to MethodCall in case of interpreted function; TStringTNamed::fNameobject identifier; Int_tfNpointsNumber of points to fit; TObject*fObjectFitpointer to object being fitted; Foption_tfOptionstruct with the fit options; Int_tfPointSizeNumber of words per point in the cache; TStringTNamed::fTitleobject title; TObject*fUserFuncpointer to user theoretical function (a TF1*); Int_tfXfirstfirst bin on X axis; Int_tfXlastlast bin on X axis; Int_tfYfirstfirst bin on Y axis; Int_tfYlastlast bin on Y axis; Int_tfZfirstfirst bin on Z axis; Int_tfZlastlast bin on Z axis; static TStringfgDefaultname of the default fitter (""Minuit"",""Fumili"",etc); static Double_tfgErrorDefError definition (default=1); static TVirtualFitter*fgFitterCurrent fitter (default TFitter); static Int_tfgMaxiterMaximum number of iterations; static Int_tfgMaxparMaximum number of fit parameters for current fitter; static Double_tfgPrecisionmaximum precision. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualFitter& operator=(const TVirtualFitter& tvf); assignment operator. ~TVirtualFitter(); Cleanup virtual fitter. TVirtualFitter * Fitter(TObject* obj, Int_t maxpar = 25); Static function returning a pointer to the current fitter.; If the fitter does not exist, the default TFitter is created.; Don't delete the returned fitter object, it will be re-used. void GetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, Double_t* ci, Double_t cl = 0.95); return confidence intervals in array x of dimension ndim; implemented in TFitter and TLinearFitter. void GetConfidenceIntervals(TObject* obj, Double_t cl = 0.95); return confidence intervals in TObject obj; implemented in TFitter and TLinearFitter. const char * GetDefaultFitter(); static: return the name of the default fitter. TVirtualFitter * GetFitter(); static: return the current Fitter. Int_t GetMaxIterations(); static: Return the maximum number of iterations; actually max numb",MatchSource.WIKI,root/html532/TVirtualFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualFitter.html
https://root.cern/root/html532/TVirtualFitter.html:9370,Modifiability,Inherit,Inherited,9370,"; TMethodCall*fMethodCallPointer to MethodCall in case of interpreted function; TStringTNamed::fNameobject identifier; Int_tfNpointsNumber of points to fit; TObject*fObjectFitpointer to object being fitted; Foption_tfOptionstruct with the fit options; Int_tfPointSizeNumber of words per point in the cache; TStringTNamed::fTitleobject title; TObject*fUserFuncpointer to user theoretical function (a TF1*); Int_tfXfirstfirst bin on X axis; Int_tfXlastlast bin on X axis; Int_tfYfirstfirst bin on Y axis; Int_tfYlastlast bin on Y axis; Int_tfZfirstfirst bin on Z axis; Int_tfZlastlast bin on Z axis; static TStringfgDefaultname of the default fitter (""Minuit"",""Fumili"",etc); static Double_tfgErrorDefError definition (default=1); static TVirtualFitter*fgFitterCurrent fitter (default TFitter); static Int_tfgMaxiterMaximum number of iterations; static Int_tfgMaxparMaximum number of fit parameters for current fitter; static Double_tfgPrecisionmaximum precision. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualFitter& operator=(const TVirtualFitter& tvf); assignment operator. ~TVirtualFitter(); Cleanup virtual fitter. TVirtualFitter * Fitter(TObject* obj, Int_t maxpar = 25); Static function returning a pointer to the current fitter.; If the fitter does not exist, the default TFitter is created.; Don't delete the returned fitter object, it will be re-used. void GetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, Double_t* ci, Double_t cl = 0.95); return confidence intervals in array x of dimension ndim; implemented in TFitter and TLinearFitter. void GetConfidenceIntervals(TObject* obj, Double_t cl = 0.95); return confidence intervals in TObject obj; implemented in TFitter and TLinearFitter. const char * GetDefaultFitter(); static: return the name of the default fitter. TVirtualFitter * GetFitter(); static: return the current Fitter. Int_t GetMaxIterations(); static: Return the maximum number of iterations; actually max numb",MatchSource.WIKI,root/html532/TVirtualFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualFitter.html
https://root.cern/root/html532/TVirtualFitter.html:8682,Performance,cache,cache,8682,"ject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TVirtualFitter&operator=(const TVirtualFitter& tvf). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*fCache[fCacheSize] array of points data (fNpoints*fPointSize < fCacheSize words); Int_tfCacheSizeSize of the fCache array; voidfFCN; TMethodCall*fMethodCallPointer to MethodCall in case of interpreted function; TStringTNamed::fNameobject identifier; Int_tfNpointsNumber of points to fit; TObject*fObjectFitpointer to object being fitted; Foption_tfOptionstruct with the fit options; Int_tfPointSizeNumber of words per point in the cache; TStringTNamed::fTitleobject title; TObject*fUserFuncpointer to user theoretical function (a TF1*); Int_tfXfirstfirst bin on X axis; Int_tfXlastlast bin on X axis; Int_tfYfirstfirst bin on Y axis; Int_tfYlastlast bin on Y axis; Int_tfZfirstfirst bin on Z axis; Int_tfZlastlast bin on Z axis; static TStringfgDefaultname of the default fitter (""Minuit"",""Fumili"",etc); static Double_tfgErrorDefError definition (default=1); static TVirtualFitter*fgFitterCurrent fitter (default TFitter); static Int_tfgMaxiterMaximum number of iterations; static Int_tfgMaxparMaximum number of fit parameters for current fitter; static Double_tfgPrecisionmaximum precision. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualFitter& operator=(const TVirtualFitter& tvf); assignment operator. ~TVirtualFitter(); Cleanup virtual fitter. TVirtualFitter * Fitter(TObject* obj, Int_t maxpar = 25); Static function returning a pointer to the current fitter.; If the fitter does not exist, the default TFitter is created.; Don't delete the returned fitter object, it will be re-used",MatchSource.WIKI,root/html532/TVirtualFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualFitter.html
https://root.cern/root/html532/TVirtualFitter.html:10995,Performance,cache,cache,10995,"ect* obj, Double_t cl = 0.95); return confidence intervals in TObject obj; implemented in TFitter and TLinearFitter. const char * GetDefaultFitter(); static: return the name of the default fitter. TVirtualFitter * GetFitter(); static: return the current Fitter. Int_t GetMaxIterations(); static: Return the maximum number of iterations; actually max number of function calls. Double_t GetErrorDef(); static: Return the Error Definition. Double_t GetPrecision(); static: Return the fit relative precision. void SetDefaultFitter(const char* name = """"); static: set name of default fitter. void SetFitter(TVirtualFitter* fitter, Int_t maxpar = 25); Static function to set an alternative fitter. void SetFCN(void (*fcn)(Int_t &, Double_t *, Double_t &f, Double_t *, Int_t)); To set the address of the minimization objective function; called by the native compiler (see function below when called by CINT). Double_t * SetCache(Int_t npoints, Int_t psize); Initialize the cache array; npoints is the number of points to be stored (or already stored) in the cache; psize is the number of elements per point. if (npoints*psize > fCacheSize) the existing cache is deleted; and a new array is created.; The function returns a pointer to the cache. void SetFCN(void* fcn); To set the address of the minimization objective function. this function is called by CINT instead of the function above. void SetMaxIterations(Int_t niter = 5000); static: Set the maximum number of function calls for the minimization algorithm; For example for MIGRAD this is the maxcalls value passed as first argument; (see http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html ). void SetErrorDef(Double_t errdef = 1); static: Set the Error Definition (default=1); For Minuit this is the value passed with the ""SET ERR"" command; (see http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html). void SetPrecision(Double_t prec = 1e-6); static: Set the tolerance used in the minimization algorithm; For example for MIGRAD this is toleran",MatchSource.WIKI,root/html532/TVirtualFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualFitter.html
https://root.cern/root/html532/TVirtualFitter.html:11080,Performance,cache,cache,11080,"ect* obj, Double_t cl = 0.95); return confidence intervals in TObject obj; implemented in TFitter and TLinearFitter. const char * GetDefaultFitter(); static: return the name of the default fitter. TVirtualFitter * GetFitter(); static: return the current Fitter. Int_t GetMaxIterations(); static: Return the maximum number of iterations; actually max number of function calls. Double_t GetErrorDef(); static: Return the Error Definition. Double_t GetPrecision(); static: Return the fit relative precision. void SetDefaultFitter(const char* name = """"); static: set name of default fitter. void SetFitter(TVirtualFitter* fitter, Int_t maxpar = 25); Static function to set an alternative fitter. void SetFCN(void (*fcn)(Int_t &, Double_t *, Double_t &f, Double_t *, Int_t)); To set the address of the minimization objective function; called by the native compiler (see function below when called by CINT). Double_t * SetCache(Int_t npoints, Int_t psize); Initialize the cache array; npoints is the number of points to be stored (or already stored) in the cache; psize is the number of elements per point. if (npoints*psize > fCacheSize) the existing cache is deleted; and a new array is created.; The function returns a pointer to the cache. void SetFCN(void* fcn); To set the address of the minimization objective function. this function is called by CINT instead of the function above. void SetMaxIterations(Int_t niter = 5000); static: Set the maximum number of function calls for the minimization algorithm; For example for MIGRAD this is the maxcalls value passed as first argument; (see http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html ). void SetErrorDef(Double_t errdef = 1); static: Set the Error Definition (default=1); For Minuit this is the value passed with the ""SET ERR"" command; (see http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html). void SetPrecision(Double_t prec = 1e-6); static: Set the tolerance used in the minimization algorithm; For example for MIGRAD this is toleran",MatchSource.WIKI,root/html532/TVirtualFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualFitter.html
https://root.cern/root/html532/TVirtualFitter.html:11175,Performance,cache,cache,11175,"r(); static: return the name of the default fitter. TVirtualFitter * GetFitter(); static: return the current Fitter. Int_t GetMaxIterations(); static: Return the maximum number of iterations; actually max number of function calls. Double_t GetErrorDef(); static: Return the Error Definition. Double_t GetPrecision(); static: Return the fit relative precision. void SetDefaultFitter(const char* name = """"); static: set name of default fitter. void SetFitter(TVirtualFitter* fitter, Int_t maxpar = 25); Static function to set an alternative fitter. void SetFCN(void (*fcn)(Int_t &, Double_t *, Double_t &f, Double_t *, Int_t)); To set the address of the minimization objective function; called by the native compiler (see function below when called by CINT). Double_t * SetCache(Int_t npoints, Int_t psize); Initialize the cache array; npoints is the number of points to be stored (or already stored) in the cache; psize is the number of elements per point. if (npoints*psize > fCacheSize) the existing cache is deleted; and a new array is created.; The function returns a pointer to the cache. void SetFCN(void* fcn); To set the address of the minimization objective function. this function is called by CINT instead of the function above. void SetMaxIterations(Int_t niter = 5000); static: Set the maximum number of function calls for the minimization algorithm; For example for MIGRAD this is the maxcalls value passed as first argument; (see http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html ). void SetErrorDef(Double_t errdef = 1); static: Set the Error Definition (default=1); For Minuit this is the value passed with the ""SET ERR"" command; (see http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html). void SetPrecision(Double_t prec = 1e-6); static: Set the tolerance used in the minimization algorithm; For example for MIGRAD this is tolerance value passed as second argument; (see http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html ). Double_t Chisquare(Int_t npar, Double_t* para",MatchSource.WIKI,root/html532/TVirtualFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualFitter.html
https://root.cern/root/html532/TVirtualFitter.html:11260,Performance,cache,cache,11260,"GetFitter(); static: return the current Fitter. Int_t GetMaxIterations(); static: Return the maximum number of iterations; actually max number of function calls. Double_t GetErrorDef(); static: Return the Error Definition. Double_t GetPrecision(); static: Return the fit relative precision. void SetDefaultFitter(const char* name = """"); static: set name of default fitter. void SetFitter(TVirtualFitter* fitter, Int_t maxpar = 25); Static function to set an alternative fitter. void SetFCN(void (*fcn)(Int_t &, Double_t *, Double_t &f, Double_t *, Int_t)); To set the address of the minimization objective function; called by the native compiler (see function below when called by CINT). Double_t * SetCache(Int_t npoints, Int_t psize); Initialize the cache array; npoints is the number of points to be stored (or already stored) in the cache; psize is the number of elements per point. if (npoints*psize > fCacheSize) the existing cache is deleted; and a new array is created.; The function returns a pointer to the cache. void SetFCN(void* fcn); To set the address of the minimization objective function. this function is called by CINT instead of the function above. void SetMaxIterations(Int_t niter = 5000); static: Set the maximum number of function calls for the minimization algorithm; For example for MIGRAD this is the maxcalls value passed as first argument; (see http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html ). void SetErrorDef(Double_t errdef = 1); static: Set the Error Definition (default=1); For Minuit this is the value passed with the ""SET ERR"" command; (see http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html). void SetPrecision(Double_t prec = 1e-6); static: Set the tolerance used in the minimization algorithm; For example for MIGRAD this is tolerance value passed as second argument; (see http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html ). Double_t Chisquare(Int_t npar, Double_t* params) const. void Clear(Option_t* option = """"). Int_t ExecuteCommand(c",MatchSource.WIKI,root/html532/TVirtualFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualFitter.html
https://root.cern/root/html532/TVirtualFitter.html:4036,Security,Hash,Hash,4036,"GetObjectFit() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Double_tGetParameter(Int_t ipar) const; virtual Int_tGetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; virtual Double_tGetParError(Int_t ipar) const; virtual const char*GetParName(Int_t ipar) const; static Double_tGetPrecision(); virtual Int_tGetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; virtual Double_tGetSumLog(Int_t i); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual TObject*GetUserFunc() const; virtual Int_tGetXfirst() const; virtual Int_tGetXlast() const; virtual Int_tGetYfirst() const; virtual Int_tGetYlast() const; virtual Int_tGetZfirst() const; virtual Int_tGetZlast() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFixed(Int_t ipar) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ",MatchSource.WIKI,root/html532/TVirtualFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualFitter.html
https://root.cern/root/html532/TVirtualFitter.html:7401,Testability,Test,TestBit,7401,"""); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual Double_t*SetCache(Int_t npoints, Int_t psize); static voidSetDefaultFitter(const char* name = """"); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidSetErrorDef(Double_t errdef = 1); virtual voidSetFCN(void* fcn); virtual voidSetFCN(void (*)(Int_t&, Double_t*, Double_t&f, Double_t*, Int_t) fcn); virtual voidSetFitMethod(const char* name); virtual voidSetFitOption(Foption_t option); static voidSetFitter(TVirtualFitter* fitter, Int_t maxpar = 25); static voidSetMaxIterations(Int_t niter = 5000); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidSetObjectFit(TObject* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual Int_tSetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); static voidSetPrecision(Double_t prec = 1e-6); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetUserFunc(TObject* userfunc); virtual voidSetXfirst(Int_t first); virtual voidSetXlast(Int_t last); virtual voidSetYfirst(Int_t first); virtual voidSetYlast(Int_t last); virtual voidSetZfirst(Int_t first); virtual voidSetZlast(Int_t last); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TVirtualFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualFitter.html
https://root.cern/root/html532/TVirtualFitter.html:7440,Testability,Test,TestBits,7440,"""); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual Double_t*SetCache(Int_t npoints, Int_t psize); static voidSetDefaultFitter(const char* name = """"); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidSetErrorDef(Double_t errdef = 1); virtual voidSetFCN(void* fcn); virtual voidSetFCN(void (*)(Int_t&, Double_t*, Double_t&f, Double_t*, Int_t) fcn); virtual voidSetFitMethod(const char* name); virtual voidSetFitOption(Foption_t option); static voidSetFitter(TVirtualFitter* fitter, Int_t maxpar = 25); static voidSetMaxIterations(Int_t niter = 5000); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidSetObjectFit(TObject* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual Int_tSetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); static voidSetPrecision(Double_t prec = 1e-6); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetUserFunc(TObject* userfunc); virtual voidSetXfirst(Int_t first); virtual voidSetXlast(Int_t last); virtual voidSetYfirst(Int_t first); virtual voidSetYlast(Int_t last); virtual voidSetZfirst(Int_t first); virtual voidSetZlast(Int_t last); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TVirtualFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualFitter.html
https://root.cern/root/html532/TVirtualFitter.html:12191,Usability,Clear,Clear,12191," array is created.; The function returns a pointer to the cache. void SetFCN(void* fcn); To set the address of the minimization objective function. this function is called by CINT instead of the function above. void SetMaxIterations(Int_t niter = 5000); static: Set the maximum number of function calls for the minimization algorithm; For example for MIGRAD this is the maxcalls value passed as first argument; (see http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html ). void SetErrorDef(Double_t errdef = 1); static: Set the Error Definition (default=1); For Minuit this is the value passed with the ""SET ERR"" command; (see http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html). void SetPrecision(Double_t prec = 1e-6); static: Set the tolerance used in the minimization algorithm; For example for MIGRAD this is tolerance value passed as second argument; (see http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html ). Double_t Chisquare(Int_t npar, Double_t* params) const. void Clear(Option_t* option = """"). Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs). void FixParameter(Int_t ipar). Double_t * GetCovarianceMatrix() const. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const. FCNFunc_t GetFCN(); { return fFCN; }. Foption_t GetFitOption() const; {return fOption;}. TMethodCall * GetMethodCall() const; {return fMethodCall;}. Int_t GetNumberTotalParameters() const. Int_t GetNumberFreeParameters() const. TObject * GetObjectFit() const; {return fObjectFit;}. Double_t GetParError(Int_t ipar) const. Double_t GetParameter(Int_t ipar) const. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const. const char * GetParName(Int_t ipar) const. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const. Double_t GetSumLog(Int_t i). TObject * GetUserFunc(",MatchSource.WIKI,root/html532/TVirtualFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualFitter.html
https://root.cern/root/html532/TVirtualGeoPainter.html:496,Availability,avail,available,496,". TVirtualGeoPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TVirtualGeoPainter. class TVirtualGeoPainter: public TObject. TVirtualGeoPainter. ABC for geometry painters. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualGeoPainter(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddSize3D(Int_t numpoints, Int_t numsegs, Int_t numpolys); virtual TVirtualGeoTrack*AddTrack(Int_t id, Int_t pdgcode, TObject* particle); virtual voidAddTrackPoint(Double_t* point, Double_t* box, Bool_t reset = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBombTranslation(const Double_t* tr, Double_t* bombtr); virtual voidTObject::Browse(TBrowser* b); virtual voidCheckBoundaryErrors(Int_t ntracks = 1000000, Double_t radius = -1.); virtual voidCheckBoundaryReference(Int_t icheck = -1); virtual voidCheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const; virtual voidCheckGeometryFull(Bool_t checkoverlaps = kTRUE, Bool_t checkcrossings = kTRUE, Int_t nrays = 10000, const Double_t* vertex = NULL); virtual voidCheckOverlaps(const TGeoVolume* vol, Double_t ovlp = 0.1, Option_t* option = """") const; virtual voidCheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); virtual voidCheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual Int_tCountVisibleNodes(); virtual v",MatchSource.WIKI,root/html532/TVirtualGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGeoPainter.html
https://root.cern/root/html532/TVirtualGeoPainter.html:2923,Availability,Error,Error,2923,"t::Copy(TObject& object) const; virtual Int_tCountVisibleNodes(); virtual voidDefaultAngles(); virtual voidDefaultColors(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Int_tDistanceToPrimitiveVol(TGeoVolume* vol, Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidDrawBatemanSol(TGeoBatemanSol* sol, Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawCurrentPoint(Int_t color); virtual voidDrawOnly(Option_t* option = """"); virtual voidDrawOverlap(void* ovlp, Option_t* option = """"); virtual voidDrawPanel(); virtual voidDrawPath(const char* path); virtual voidDrawShape(TGeoShape* shape, Option_t* option = """"); virtual voidDrawVolume(TGeoVolume* vol, Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidEditGeometry(Option_t* option = """"); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidEstimateCameraMove(Double_t, Double_t, Double_t*, Double_t*); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExecuteManagerEvent(TGeoManager* geom, Int_t event, Int_t px, Int_t py); virtual voidExecuteShapeEvent(TGeoShape* shape, Int_t event, Int_t px, Int_t py); virtual voidExecuteVolumeEvent(TGeoVolume* volume, Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualGeoPainter*GeoPainter(); virtual voidGetBombFactors(Double_t& bombx, Double_t& bomby, Double_t& bombz, Double_t& bombr) const; virtual Int_tGetBombMode() const; virtual In",MatchSource.WIKI,root/html532/TVirtualGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGeoPainter.html
https://root.cern/root/html532/TVirtualGeoPainter.html:3126,Availability,error,error,3126,"DistancetoPrimitive(Int_t px, Int_t py); virtual Int_tDistanceToPrimitiveVol(TGeoVolume* vol, Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidDrawBatemanSol(TGeoBatemanSol* sol, Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawCurrentPoint(Int_t color); virtual voidDrawOnly(Option_t* option = """"); virtual voidDrawOverlap(void* ovlp, Option_t* option = """"); virtual voidDrawPanel(); virtual voidDrawPath(const char* path); virtual voidDrawShape(TGeoShape* shape, Option_t* option = """"); virtual voidDrawVolume(TGeoVolume* vol, Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidEditGeometry(Option_t* option = """"); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidEstimateCameraMove(Double_t, Double_t, Double_t*, Double_t*); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExecuteManagerEvent(TGeoManager* geom, Int_t event, Int_t px, Int_t py); virtual voidExecuteShapeEvent(TGeoShape* shape, Int_t event, Int_t px, Int_t py); virtual voidExecuteVolumeEvent(TGeoVolume* volume, Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualGeoPainter*GeoPainter(); virtual voidGetBombFactors(Double_t& bombx, Double_t& bomby, Double_t& bombz, Double_t& bombr) const; virtual Int_tGetBombMode() const; virtual Int_tGetColor(Int_t base, Float_t light) const; virtual TGeoVolume*GetDrawnVolume() const; virtual Option_t*TObject::GetDrawOption() const; virtual const char*GetDrawPath() const; static Long_tTObject::Get",MatchSource.WIKI,root/html532/TVirtualGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGeoPainter.html
https://root.cern/root/html532/TVirtualGeoPainter.html:3210,Availability,error,error,3210,"ume* vol, Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidDrawBatemanSol(TGeoBatemanSol* sol, Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawCurrentPoint(Int_t color); virtual voidDrawOnly(Option_t* option = """"); virtual voidDrawOverlap(void* ovlp, Option_t* option = """"); virtual voidDrawPanel(); virtual voidDrawPath(const char* path); virtual voidDrawShape(TGeoShape* shape, Option_t* option = """"); virtual voidDrawVolume(TGeoVolume* vol, Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidEditGeometry(Option_t* option = """"); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidEstimateCameraMove(Double_t, Double_t, Double_t*, Double_t*); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExecuteManagerEvent(TGeoManager* geom, Int_t event, Int_t px, Int_t py); virtual voidExecuteShapeEvent(TGeoShape* shape, Int_t event, Int_t px, Int_t py); virtual voidExecuteVolumeEvent(TGeoVolume* volume, Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualGeoPainter*GeoPainter(); virtual voidGetBombFactors(Double_t& bombx, Double_t& bomby, Double_t& bombz, Double_t& bombr) const; virtual Int_tGetBombMode() const; virtual Int_tGetColor(Int_t base, Float_t light) const; virtual TGeoVolume*GetDrawnVolume() const; virtual Option_t*TObject::GetDrawOption() const; virtual const char*GetDrawPath() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObj",MatchSource.WIKI,root/html532/TVirtualGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGeoPainter.html
https://root.cern/root/html532/TVirtualGeoPainter.html:11259,Availability,CheckPoint,CheckPoint,11259,"p; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. static TVirtualGeoPainter*fgGeoPainterPointer to class painter. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TVirtualGeoPainter(); -*-*Geometry painter default destructor; *-* ===================================. TVirtualGeoPainter * GeoPainter(); Static function returning a pointer to the geometry painter.; The painter will paint objects from the specified geometry.; If the geometry painter does not exist a default painter is created. void SetPainter(const TVirtualGeoPainter* painter); Static function to set an alternative histogram painter. void AddSize3D(Int_t numpoints, Int_t numsegs, Int_t numpolys). TVirtualGeoTrack * AddTrack(Int_t id, Int_t pdgcode, TObject* particle). void AddTrackPoint(Double_t* point, Double_t* box, Bool_t reset = kFALSE). void BombTranslation(const Double_t* tr, Double_t* bombtr). void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"). void CheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option). void CheckBoundaryErrors(Int_t ntracks = 1000000, Double_t radius = -1.). void CheckBoundaryReference(Int_t icheck = -1). void CheckGeometryFull(Bool_t checkoverlaps = kTRUE, Bool_t checkcrossings = kTRUE, Int_t nrays = 10000, const Double_t* vertex = NULL). void CheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const. void CheckOverlaps(const TGeoVolume* vol, Double_t ovlp = 0.1, Option_t* option = """") const. Int_t CountVisibleNodes(). void DefaultAngles(). void DefaultColors(). Int_t DistanceToPrimitiveVol(TGeoVolume* vol, Int_t px, Int_t py). void Draw(Option_t* option = """"). void DrawBatemanSol(TGeoBatemanSol* sol, Option_t* option = """"). void DrawShape(TGeoShape* shape, Option_t* option = """"). void DrawOnly(Option_t* option = """"). void DrawOverlap(void* ovlp, Option_t* option = """"). void DrawCurrentPoint(Int_t color). void Draw",MatchSource.WIKI,root/html532/TVirtualGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGeoPainter.html
https://root.cern/root/html532/TVirtualGeoPainter.html:5959,Deployability,update,update,5959,,MatchSource.WIKI,root/html532/TVirtualGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGeoPainter.html
https://root.cern/root/html532/TVirtualGeoPainter.html:5075,Modifiability,Inherit,InheritsFrom,5075,"ame) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualGeoPainter*GeoPainter(); virtual voidGetBombFactors(Double_t& bombx, Double_t& bomby, Double_t& bombz, Double_t& bombr) const; virtual Int_tGetBombMode() const; virtual Int_tGetColor(Int_t base, Float_t light) const; virtual TGeoVolume*GetDrawnVolume() const; virtual Option_t*TObject::GetDrawOption() const; virtual const char*GetDrawPath() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual Int_tGetNsegments() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual TGeoVolume*GetTopVolume() const; virtual UInt_tTObject::GetUniqueID() const; virtual voidGetViewAngles(Double_t&, Double_t&, Double_t&); virtual Double_t*GetViewBox(); virtual Int_tGetVisLevel() const; virtual Int_tGetVisOption() const; virtual const char*GetVolumeInfo(const TGeoVolume* volume, Int_t px, Int_t py) const; virtual voidGrabFocus(Int_t nfr = 0, Double_t dlong = 0, Double_t dlat = 0, Double_t dpsi = 0); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsExplodedView() const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsPaintingShape() const; virtual Bool_tIsRaytracing() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual TH2F*LegoPlot(Int_t ntheta = 60, Double_t themin = 0.",MatchSource.WIKI,root/html532/TVirtualGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGeoPainter.html
https://root.cern/root/html532/TVirtualGeoPainter.html:5141,Modifiability,Inherit,InheritsFrom,5141,"ame) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualGeoPainter*GeoPainter(); virtual voidGetBombFactors(Double_t& bombx, Double_t& bomby, Double_t& bombz, Double_t& bombr) const; virtual Int_tGetBombMode() const; virtual Int_tGetColor(Int_t base, Float_t light) const; virtual TGeoVolume*GetDrawnVolume() const; virtual Option_t*TObject::GetDrawOption() const; virtual const char*GetDrawPath() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual Int_tGetNsegments() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual TGeoVolume*GetTopVolume() const; virtual UInt_tTObject::GetUniqueID() const; virtual voidGetViewAngles(Double_t&, Double_t&, Double_t&); virtual Double_t*GetViewBox(); virtual Int_tGetVisLevel() const; virtual Int_tGetVisOption() const; virtual const char*GetVolumeInfo(const TGeoVolume* volume, Int_t px, Int_t py) const; virtual voidGrabFocus(Int_t nfr = 0, Double_t dlong = 0, Double_t dlat = 0, Double_t dpsi = 0); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsExplodedView() const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsPaintingShape() const; virtual Bool_tIsRaytracing() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual TH2F*LegoPlot(Int_t ntheta = 60, Double_t themin = 0.",MatchSource.WIKI,root/html532/TVirtualGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGeoPainter.html
https://root.cern/root/html532/TVirtualGeoPainter.html:8322,Modifiability,plugin,plugin,8322,"t); virtual voidSetBombFactors(Double_t bombx = 1.3, Double_t bomby = 1.3, Double_t bombz = 1.3, Double_t bombr = 1.3); virtual voidSetCheckedNode(TGeoNode* node); virtual voidSetClippingShape(TGeoShape* shape); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetExplodedView(Int_t iopt = 0); virtual voidSetGeoManager(TGeoManager* geom); virtual voidSetIteratorPlugin(TGeoIteratorPlugin* plugin); virtual voidSetNmeshPoints(Int_t npoints); virtual voidSetNsegments(Int_t nseg = 20); static voidTObject::SetObjectStat(Bool_t stat); static voidSetPainter(const TVirtualGeoPainter* painter); virtual voidSetRaytracing(Bool_t flag = kTRUE); virtual voidSetTopVisible(Bool_t vis = kTRUE); virtual voidSetTopVolume(TGeoVolume* vol); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetVisLevel(Int_t level = 3); virtual voidSetVisOption(Int_t option = 0); virtual Int_tShapeDistancetoPrimitive(const TGeoShape* shape, Int_t numpoints, Int_t px, Int_t py) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTest(Int_t npoints, Option_t* option); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTestOverlaps(const char* path); virtual Bool_tTestVoxels(TGeoVolume* vol); virtual voidUnbombTranslation(const Double_t* tr, Double_t* bombtr); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Double_tWeight(Double_t precision, Option_t* option = ""v""); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidT",MatchSource.WIKI,root/html532/TVirtualGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGeoPainter.html
https://root.cern/root/html532/TVirtualGeoPainter.html:10464,Modifiability,Inherit,Inheritance,10464,"const; virtual Double_tWeight(Double_t precision, Option_t* option = ""v""); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum EGeoVisLevel { kGeoVisLevel; };; enum EGeoVisOption { kGeoVisDefault; kGeoVisLeaves; kGeoVisOnly; kGeoVisBranch; kGeoVisChanged; };; enum EGeoBombOption { kGeoNoBomb; kGeoBombXYZ; kGeoBombCyl; kGeoBombSph; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. static TVirtualGeoPainter*fgGeoPainterPointer to class painter. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TVirtualGeoPainter(); -*-*Geometry painter default destructor; *-* ===================================. TVirtualGeoPainter * GeoPainter(); Static function returning a pointer to the geometry painter.; The painter will paint objects from the specified geometry.; If the geometry painter does not exist a default painter is created. void SetPainter(const TVirtualGeoPainter* painter); Static function to set an alternative histogram painter. void AddSize3D(Int_t numpoints, Int_t numsegs, Int_t numpolys). TVirtualGeoTrack * AddTrack(Int_t id, Int_t pdgcode, TObject* particle). void AddTrackPoint(Double_t* point, Double_t* box, Bool_t reset = kFALSE). void BombTranslation(const Double_t* tr, Double_t* bombtr). void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"). void CheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option). void CheckBoundaryErrors(Int_t ntracks = 1000000, Double_t radius",MatchSource.WIKI,root/html532/TVirtualGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGeoPainter.html
https://root.cern/root/html532/TVirtualGeoPainter.html:10477,Modifiability,Inherit,Inherited,10477,"const; virtual Double_tWeight(Double_t precision, Option_t* option = ""v""); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum EGeoVisLevel { kGeoVisLevel; };; enum EGeoVisOption { kGeoVisDefault; kGeoVisLeaves; kGeoVisOnly; kGeoVisBranch; kGeoVisChanged; };; enum EGeoBombOption { kGeoNoBomb; kGeoBombXYZ; kGeoBombCyl; kGeoBombSph; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. static TVirtualGeoPainter*fgGeoPainterPointer to class painter. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TVirtualGeoPainter(); -*-*Geometry painter default destructor; *-* ===================================. TVirtualGeoPainter * GeoPainter(); Static function returning a pointer to the geometry painter.; The painter will paint objects from the specified geometry.; If the geometry painter does not exist a default painter is created. void SetPainter(const TVirtualGeoPainter* painter); Static function to set an alternative histogram painter. void AddSize3D(Int_t numpoints, Int_t numsegs, Int_t numpolys). TVirtualGeoTrack * AddTrack(Int_t id, Int_t pdgcode, TObject* particle). void AddTrackPoint(Double_t* point, Double_t* box, Bool_t reset = kFALSE). void BombTranslation(const Double_t* tr, Double_t* bombtr). void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"). void CheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option). void CheckBoundaryErrors(Int_t ntracks = 1000000, Double_t radius",MatchSource.WIKI,root/html532/TVirtualGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGeoPainter.html
https://root.cern/root/html532/TVirtualGeoPainter.html:14660,Modifiability,plugin,plugin,14660,"tion_t* option = """"). void OpProgress(const char* opname, Long64_t current, Long64_t size, TStopwatch* watch = 0, Bool_t last = kFALSE, Bool_t refresh = kFALSE). void Paint(Option_t* option = """"). void PaintNode(TGeoNode* node, Option_t* option = """", TGeoMatrix* global = 0). void PaintShape(TGeoShape* shape, Option_t* option = """"). void PaintOverlap(void* ovlp, Option_t* option = """"). void PrintOverlaps() const. void PaintVolume(TGeoVolume* vol, Option_t* option = """", TGeoMatrix* global = 0). void RandomPoints(const TGeoVolume* vol, Int_t npoints, Option_t* option = """"). void RandomRays(Int_t nrays, Double_t startx, Double_t starty, Double_t startz). void Raytrace(Option_t* option = """"). TGeoNode * SamplePoints(Int_t npoints, Double_t& dist, Double_t epsil, const char* g3path). void SetBombFactors(Double_t bombx = 1.3, Double_t bomby = 1.3, Double_t bombz = 1.3, Double_t bombr = 1.3). void SetExplodedView(Int_t iopt = 0). void SetGeoManager(TGeoManager* geom). void SetIteratorPlugin(TGeoIteratorPlugin* plugin). void SetCheckedNode(TGeoNode* node). void SetNsegments(Int_t nseg = 20). void SetNmeshPoints(Int_t npoints). void SetRaytracing(Bool_t flag = kTRUE). void SetTopVisible(Bool_t vis = kTRUE). void SetTopVolume(TGeoVolume* vol). void SetVisLevel(Int_t level = 3). void SetVisOption(Int_t option = 0). Int_t ShapeDistancetoPrimitive(const TGeoShape* shape, Int_t numpoints, Int_t px, Int_t py) const. void Test(Int_t npoints, Option_t* option). void TestOverlaps(const char* path). Bool_t TestVoxels(TGeoVolume* vol). void UnbombTranslation(const Double_t* tr, Double_t* bombtr). Double_t Weight(Double_t precision, Option_t* option = ""v""). » Author: Andrei Gheata 11/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id: TVirtualGeoPainter.h 39018 2011-04-25 09:38:31Z agheata $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in genera",MatchSource.WIKI,root/html532/TVirtualGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGeoPainter.html
https://root.cern/root/html532/TVirtualGeoPainter.html:4965,Security,Hash,Hash,4965,"ame) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualGeoPainter*GeoPainter(); virtual voidGetBombFactors(Double_t& bombx, Double_t& bomby, Double_t& bombz, Double_t& bombr) const; virtual Int_tGetBombMode() const; virtual Int_tGetColor(Int_t base, Float_t light) const; virtual TGeoVolume*GetDrawnVolume() const; virtual Option_t*TObject::GetDrawOption() const; virtual const char*GetDrawPath() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual Int_tGetNsegments() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual TGeoVolume*GetTopVolume() const; virtual UInt_tTObject::GetUniqueID() const; virtual voidGetViewAngles(Double_t&, Double_t&, Double_t&); virtual Double_t*GetViewBox(); virtual Int_tGetVisLevel() const; virtual Int_tGetVisOption() const; virtual const char*GetVolumeInfo(const TGeoVolume* volume, Int_t px, Int_t py) const; virtual voidGrabFocus(Int_t nfr = 0, Double_t dlong = 0, Double_t dlat = 0, Double_t dpsi = 0); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsExplodedView() const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsPaintingShape() const; virtual Bool_tIsRaytracing() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual TH2F*LegoPlot(Int_t ntheta = 60, Double_t themin = 0.",MatchSource.WIKI,root/html532/TVirtualGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGeoPainter.html
https://root.cern/root/html532/TVirtualGeoPainter.html:1630,Testability,test,testNo,1630,"1, Option_t* option = """") const; virtual voidCheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); virtual voidCheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual Int_tCountVisibleNodes(); virtual v",MatchSource.WIKI,root/html532/TVirtualGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGeoPainter.html
https://root.cern/root/html532/TVirtualGeoPainter.html:9159,Testability,Test,TestBit,9159,"t); virtual voidSetBombFactors(Double_t bombx = 1.3, Double_t bomby = 1.3, Double_t bombz = 1.3, Double_t bombr = 1.3); virtual voidSetCheckedNode(TGeoNode* node); virtual voidSetClippingShape(TGeoShape* shape); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetExplodedView(Int_t iopt = 0); virtual voidSetGeoManager(TGeoManager* geom); virtual voidSetIteratorPlugin(TGeoIteratorPlugin* plugin); virtual voidSetNmeshPoints(Int_t npoints); virtual voidSetNsegments(Int_t nseg = 20); static voidTObject::SetObjectStat(Bool_t stat); static voidSetPainter(const TVirtualGeoPainter* painter); virtual voidSetRaytracing(Bool_t flag = kTRUE); virtual voidSetTopVisible(Bool_t vis = kTRUE); virtual voidSetTopVolume(TGeoVolume* vol); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetVisLevel(Int_t level = 3); virtual voidSetVisOption(Int_t option = 0); virtual Int_tShapeDistancetoPrimitive(const TGeoShape* shape, Int_t numpoints, Int_t px, Int_t py) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTest(Int_t npoints, Option_t* option); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTestOverlaps(const char* path); virtual Bool_tTestVoxels(TGeoVolume* vol); virtual voidUnbombTranslation(const Double_t* tr, Double_t* bombtr); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Double_tWeight(Double_t precision, Option_t* option = ""v""); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidT",MatchSource.WIKI,root/html532/TVirtualGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGeoPainter.html
https://root.cern/root/html532/TVirtualGeoPainter.html:9198,Testability,Test,TestBits,9198,"t); virtual voidSetBombFactors(Double_t bombx = 1.3, Double_t bomby = 1.3, Double_t bombz = 1.3, Double_t bombr = 1.3); virtual voidSetCheckedNode(TGeoNode* node); virtual voidSetClippingShape(TGeoShape* shape); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetExplodedView(Int_t iopt = 0); virtual voidSetGeoManager(TGeoManager* geom); virtual voidSetIteratorPlugin(TGeoIteratorPlugin* plugin); virtual voidSetNmeshPoints(Int_t npoints); virtual voidSetNsegments(Int_t nseg = 20); static voidTObject::SetObjectStat(Bool_t stat); static voidSetPainter(const TVirtualGeoPainter* painter); virtual voidSetRaytracing(Bool_t flag = kTRUE); virtual voidSetTopVisible(Bool_t vis = kTRUE); virtual voidSetTopVolume(TGeoVolume* vol); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetVisLevel(Int_t level = 3); virtual voidSetVisOption(Int_t option = 0); virtual Int_tShapeDistancetoPrimitive(const TGeoShape* shape, Int_t numpoints, Int_t px, Int_t py) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTest(Int_t npoints, Option_t* option); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTestOverlaps(const char* path); virtual Bool_tTestVoxels(TGeoVolume* vol); virtual voidUnbombTranslation(const Double_t* tr, Double_t* bombtr); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Double_tWeight(Double_t precision, Option_t* option = ""v""); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidT",MatchSource.WIKI,root/html532/TVirtualGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGeoPainter.html
https://root.cern/root/html532/TVirtualGeoPainter.html:11382,Testability,test,testNo,11382,"d:. static TVirtualGeoPainter*fgGeoPainterPointer to class painter. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TVirtualGeoPainter(); -*-*Geometry painter default destructor; *-* ===================================. TVirtualGeoPainter * GeoPainter(); Static function returning a pointer to the geometry painter.; The painter will paint objects from the specified geometry.; If the geometry painter does not exist a default painter is created. void SetPainter(const TVirtualGeoPainter* painter); Static function to set an alternative histogram painter. void AddSize3D(Int_t numpoints, Int_t numsegs, Int_t numpolys). TVirtualGeoTrack * AddTrack(Int_t id, Int_t pdgcode, TObject* particle). void AddTrackPoint(Double_t* point, Double_t* box, Bool_t reset = kFALSE). void BombTranslation(const Double_t* tr, Double_t* bombtr). void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"). void CheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option). void CheckBoundaryErrors(Int_t ntracks = 1000000, Double_t radius = -1.). void CheckBoundaryReference(Int_t icheck = -1). void CheckGeometryFull(Bool_t checkoverlaps = kTRUE, Bool_t checkcrossings = kTRUE, Int_t nrays = 10000, const Double_t* vertex = NULL). void CheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const. void CheckOverlaps(const TGeoVolume* vol, Double_t ovlp = 0.1, Option_t* option = """") const. Int_t CountVisibleNodes(). void DefaultAngles(). void DefaultColors(). Int_t DistanceToPrimitiveVol(TGeoVolume* vol, Int_t px, Int_t py). void Draw(Option_t* option = """"). void DrawBatemanSol(TGeoBatemanSol* sol, Option_t* option = """"). void DrawShape(TGeoShape* shape, Option_t* option = """"). void DrawOnly(Option_t* option = """"). void DrawOverlap(void* ovlp, Option_t* option = """"). void DrawCurrentPoint(Int_t color). void DrawPanel(). void DrawPath(const char* path). void DrawVolume(TGeoVolume* vol, Option_t* o",MatchSource.WIKI,root/html532/TVirtualGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGeoPainter.html
https://root.cern/root/html532/TVirtualGeoPainter.html:15071,Testability,Test,Test,15071,"const char* opname, Long64_t current, Long64_t size, TStopwatch* watch = 0, Bool_t last = kFALSE, Bool_t refresh = kFALSE). void Paint(Option_t* option = """"). void PaintNode(TGeoNode* node, Option_t* option = """", TGeoMatrix* global = 0). void PaintShape(TGeoShape* shape, Option_t* option = """"). void PaintOverlap(void* ovlp, Option_t* option = """"). void PrintOverlaps() const. void PaintVolume(TGeoVolume* vol, Option_t* option = """", TGeoMatrix* global = 0). void RandomPoints(const TGeoVolume* vol, Int_t npoints, Option_t* option = """"). void RandomRays(Int_t nrays, Double_t startx, Double_t starty, Double_t startz). void Raytrace(Option_t* option = """"). TGeoNode * SamplePoints(Int_t npoints, Double_t& dist, Double_t epsil, const char* g3path). void SetBombFactors(Double_t bombx = 1.3, Double_t bomby = 1.3, Double_t bombz = 1.3, Double_t bombr = 1.3). void SetExplodedView(Int_t iopt = 0). void SetGeoManager(TGeoManager* geom). void SetIteratorPlugin(TGeoIteratorPlugin* plugin). void SetCheckedNode(TGeoNode* node). void SetNsegments(Int_t nseg = 20). void SetNmeshPoints(Int_t npoints). void SetRaytracing(Bool_t flag = kTRUE). void SetTopVisible(Bool_t vis = kTRUE). void SetTopVolume(TGeoVolume* vol). void SetVisLevel(Int_t level = 3). void SetVisOption(Int_t option = 0). Int_t ShapeDistancetoPrimitive(const TGeoShape* shape, Int_t numpoints, Int_t px, Int_t py) const. void Test(Int_t npoints, Option_t* option). void TestOverlaps(const char* path). Bool_t TestVoxels(TGeoVolume* vol). void UnbombTranslation(const Double_t* tr, Double_t* bombtr). Double_t Weight(Double_t precision, Option_t* option = ""v""). » Author: Andrei Gheata 11/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id: TVirtualGeoPainter.h 39018 2011-04-25 09:38:31Z agheata $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TVirtualGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGeoPainter.html
https://root.cern/root/html532/TVirtualGeoPainter.html:15115,Testability,Test,TestOverlaps,15115,"const char* opname, Long64_t current, Long64_t size, TStopwatch* watch = 0, Bool_t last = kFALSE, Bool_t refresh = kFALSE). void Paint(Option_t* option = """"). void PaintNode(TGeoNode* node, Option_t* option = """", TGeoMatrix* global = 0). void PaintShape(TGeoShape* shape, Option_t* option = """"). void PaintOverlap(void* ovlp, Option_t* option = """"). void PrintOverlaps() const. void PaintVolume(TGeoVolume* vol, Option_t* option = """", TGeoMatrix* global = 0). void RandomPoints(const TGeoVolume* vol, Int_t npoints, Option_t* option = """"). void RandomRays(Int_t nrays, Double_t startx, Double_t starty, Double_t startz). void Raytrace(Option_t* option = """"). TGeoNode * SamplePoints(Int_t npoints, Double_t& dist, Double_t epsil, const char* g3path). void SetBombFactors(Double_t bombx = 1.3, Double_t bomby = 1.3, Double_t bombz = 1.3, Double_t bombr = 1.3). void SetExplodedView(Int_t iopt = 0). void SetGeoManager(TGeoManager* geom). void SetIteratorPlugin(TGeoIteratorPlugin* plugin). void SetCheckedNode(TGeoNode* node). void SetNsegments(Int_t nseg = 20). void SetNmeshPoints(Int_t npoints). void SetRaytracing(Bool_t flag = kTRUE). void SetTopVisible(Bool_t vis = kTRUE). void SetTopVolume(TGeoVolume* vol). void SetVisLevel(Int_t level = 3). void SetVisOption(Int_t option = 0). Int_t ShapeDistancetoPrimitive(const TGeoShape* shape, Int_t numpoints, Int_t px, Int_t py) const. void Test(Int_t npoints, Option_t* option). void TestOverlaps(const char* path). Bool_t TestVoxels(TGeoVolume* vol). void UnbombTranslation(const Double_t* tr, Double_t* bombtr). Double_t Weight(Double_t precision, Option_t* option = ""v""). » Author: Andrei Gheata 11/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id: TVirtualGeoPainter.h 39018 2011-04-25 09:38:31Z agheata $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TVirtualGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGeoPainter.html
https://root.cern/root/html532/TVirtualGeoPainter.html:15154,Testability,Test,TestVoxels,15154,"const char* opname, Long64_t current, Long64_t size, TStopwatch* watch = 0, Bool_t last = kFALSE, Bool_t refresh = kFALSE). void Paint(Option_t* option = """"). void PaintNode(TGeoNode* node, Option_t* option = """", TGeoMatrix* global = 0). void PaintShape(TGeoShape* shape, Option_t* option = """"). void PaintOverlap(void* ovlp, Option_t* option = """"). void PrintOverlaps() const. void PaintVolume(TGeoVolume* vol, Option_t* option = """", TGeoMatrix* global = 0). void RandomPoints(const TGeoVolume* vol, Int_t npoints, Option_t* option = """"). void RandomRays(Int_t nrays, Double_t startx, Double_t starty, Double_t startz). void Raytrace(Option_t* option = """"). TGeoNode * SamplePoints(Int_t npoints, Double_t& dist, Double_t epsil, const char* g3path). void SetBombFactors(Double_t bombx = 1.3, Double_t bomby = 1.3, Double_t bombz = 1.3, Double_t bombr = 1.3). void SetExplodedView(Int_t iopt = 0). void SetGeoManager(TGeoManager* geom). void SetIteratorPlugin(TGeoIteratorPlugin* plugin). void SetCheckedNode(TGeoNode* node). void SetNsegments(Int_t nseg = 20). void SetNmeshPoints(Int_t npoints). void SetRaytracing(Bool_t flag = kTRUE). void SetTopVisible(Bool_t vis = kTRUE). void SetTopVolume(TGeoVolume* vol). void SetVisLevel(Int_t level = 3). void SetVisOption(Int_t option = 0). Int_t ShapeDistancetoPrimitive(const TGeoShape* shape, Int_t numpoints, Int_t px, Int_t py) const. void Test(Int_t npoints, Option_t* option). void TestOverlaps(const char* path). Bool_t TestVoxels(TGeoVolume* vol). void UnbombTranslation(const Double_t* tr, Double_t* bombtr). Double_t Weight(Double_t precision, Option_t* option = ""v""). » Author: Andrei Gheata 11/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id: TVirtualGeoPainter.h 39018 2011-04-25 09:38:31Z agheata $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TVirtualGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGeoPainter.html
https://root.cern/root/html532/TVirtualGeoPainter.html:1764,Usability,Clear,Clear,1764,"1, Option_t* option = """") const; virtual voidCheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); virtual voidCheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual Int_tCountVisibleNodes(); virtual v",MatchSource.WIKI,root/html532/TVirtualGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGeoPainter.html
https://root.cern/root/html532/TVirtualGeoTrack.html:755,Availability,avail,available,755,". TVirtualGeoTrack. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TVirtualGeoTrack. class TVirtualGeoTrack: public TObject, public TGeoAtt, public TAttLine, public TAttMarker. TVirtualGeoTrack - Base class for user-defined tracks attached to a geometry.; Tracks are 3D objects made of points and they store a; pointer to a TParticle. The geometry manager holds a list; of all tracks that will be deleted on destruction of; gGeoManager. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualGeoTrack(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAddDaughter(TVirtualGeoTrack* other); virtual TVirtualGeoTrack*AddDaughter(Int_t id, Int_t pdgcode, TObject* particle = 0); virtual voidAddPoint(Double_t x, Double_t y, Double_t z, Double_t t); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const",MatchSource.WIKI,root/html532/TVirtualGeoTrack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGeoTrack.html
https://root.cern/root/html532/TVirtualGeoTrack.html:1914,Availability,Error,Error,1914,"her); virtual TVirtualGeoTrack*AddDaughter(Int_t id, Int_t pdgcode, TObject* particle = 0); virtual voidAddPoint(Double_t x, Double_t y, Double_t z, Double_t t); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TVirtualGeoTrack*FindTrackWithId(Int_t id) const; TVirtualGeoTrack*GetDaughter(Int_t index) const; virtual Int_tGetDaughterId(Int_t index) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const Double_t*GetFirstPoint() const; virtual const char*TObject::GetIconName() const; Int_tGetId() const; const Double_t*GetLastPoint() const; Int_tGetLastPoint(Double_t& x, Double_t& y, Double_t& z, Double_t& t) const; virtual Color_tTAttLine::GetLineColor() const; virt",MatchSource.WIKI,root/html532/TVirtualGeoTrack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGeoTrack.html
https://root.cern/root/html532/TVirtualGeoTrack.html:2043,Availability,error,error,2043,"le_t y, Double_t z, Double_t t); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TVirtualGeoTrack*FindTrackWithId(Int_t id) const; TVirtualGeoTrack*GetDaughter(Int_t index) const; virtual Int_tGetDaughterId(Int_t index) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const Double_t*GetFirstPoint() const; virtual const char*TObject::GetIconName() const; Int_tGetId() const; const Double_t*GetLastPoint() const; Int_tGetLastPoint(Double_t& x, Double_t& y, Double_t& z, Double_t& t) const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerCol",MatchSource.WIKI,root/html532/TVirtualGeoTrack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGeoTrack.html
https://root.cern/root/html532/TVirtualGeoTrack.html:2127,Availability,error,error,2127,"""); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TVirtualGeoTrack*FindTrackWithId(Int_t id) const; TVirtualGeoTrack*GetDaughter(Int_t index) const; virtual Int_tGetDaughterId(Int_t index) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const Double_t*GetFirstPoint() const; virtual const char*TObject::GetIconName() const; Int_tGetId() const; const Double_t*GetLastPoint() const; Int_tGetLastPoint(Double_t& x, Double_t& y, Double_t& z, Double_t& t) const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMark",MatchSource.WIKI,root/html532/TVirtualGeoTrack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGeoTrack.html
https://root.cern/root/html532/TVirtualGeoTrack.html:3987,Modifiability,Inherit,InheritsFrom,3987,"idth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; TVirtualGeoTrack*GetMother() const; TObject*GetMotherParticle() const; virtual const char*GetName() const; Int_tGetNdaughters() const; virtual Int_tGetNpoints() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetParentId() const; TObject*GetParticle() const; Int_tGetPDG() const; virtual const Double_t*GetPoint(Int_t i) const; virtual Int_tGetPoint(Int_t i, Double_t& x, Double_t& y, Double_t& z, Double_t& t) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; Bool_tHasPoints() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTGeoAtt::IsActive() const; Bool_tTGeoAtt::IsActiveDaughters() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tIsInTimeRange() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTGeoAtt::IsVisBranch() const; Bool_tTGeoAtt::IsVisContainers() const; Bool_tTGeoAtt::IsVisDaughters() const; Bool_tTGeoAtt::IsVisible() const; Bool_tTGeoAtt::IsVisLeaves() const; Bool_tTGeoAtt::IsVisOnly() const; Bool_tTGeoAtt::IsVisRaytrace() const; Bool_tTGeoAtt::IsVisStreamed() const; Bool_tTGeoAtt::IsVisTouched() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttLine::Modify(); virtual Bool_tTObj",MatchSource.WIKI,root/html532/TVirtualGeoTrack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGeoTrack.html
https://root.cern/root/html532/TVirtualGeoTrack.html:4053,Modifiability,Inherit,InheritsFrom,4053,"irtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; TVirtualGeoTrack*GetMother() const; TObject*GetMotherParticle() const; virtual const char*GetName() const; Int_tGetNdaughters() const; virtual Int_tGetNpoints() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetParentId() const; TObject*GetParticle() const; Int_tGetPDG() const; virtual const Double_t*GetPoint(Int_t i) const; virtual Int_tGetPoint(Int_t i, Double_t& x, Double_t& y, Double_t& z, Double_t& t) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; Bool_tHasPoints() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTGeoAtt::IsActive() const; Bool_tTGeoAtt::IsActiveDaughters() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tIsInTimeRange() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTGeoAtt::IsVisBranch() const; Bool_tTGeoAtt::IsVisContainers() const; Bool_tTGeoAtt::IsVisDaughters() const; Bool_tTGeoAtt::IsVisible() const; Bool_tTGeoAtt::IsVisLeaves() const; Bool_tTGeoAtt::IsVisOnly() const; Bool_tTGeoAtt::IsVisRaytrace() const; Bool_tTGeoAtt::IsVisStreamed() const; Bool_tTGeoAtt::IsVisTouched() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttLine::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const cha",MatchSource.WIKI,root/html532/TVirtualGeoTrack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGeoTrack.html
https://root.cern/root/html532/TVirtualGeoTrack.html:10108,Modifiability,Inherit,Inheritance,10108,"erwrite; kWriteDelete; };; enum TGeoAtt::[unnamed] { kBitMask; };; enum TGeoAtt::EGeoVisibilityAtt { kVisOverride; kVisNone; kVisThis; kVisDaughters; kVisOneLevel; kVisStreamed; kVisTouched; kVisOnScreen; kVisContainers; kVisOnly; kVisBranch; kVisRaytrace; };; enum TGeoAtt::EGeoActivityAtt { kActOverride; kActNone; kActThis; kActDaughters; };; enum TGeoAtt::EGeoOptimizationAtt { kUseBoundingBox; kUseVoxels; kUseGsord; };; enum TGeoAtt::EGeoSavePrimitiveAtt { kSavePrimitiveAtt; kSaveNodesAtt; };. protected:. UInt_tTGeoAtt::fGeoAttoption flags; Int_tfIdtrack id; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tfPDGtrack pdg code; TVirtualGeoTrack*fParentid of parent; TObject*fParticleparticle for this track; TObjArray*fTracksdaughter tracks. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualGeoTrack& operator=(const TVirtualGeoTrack& ); Assignment operator. NOT TO BE CALLED. ~TVirtualGeoTrack(); Destructor. TVirtualGeoTrack * FindTrackWithId(Int_t id) const; Recursively search through this track for a daughter; particle (at any depth) with the specified id. const char * GetName() const; Get the PDG name. Bool_t IsInTimeRange() const; True if track TOF range overlaps with time interval of TGeoManager. void SetName(const char* name); Set a default name for this track. TVirtualGeoTrack * AddDaughter(Int_t id, Int_t pdgcode, TObject* particle = 0). Int_t AddDaughter(TVirtualGeoTrack* other). void AddPoint(Double_t x, Double_t y, Double_t z, Double_t t). Int_t GetId() const; {return fId;}. Int_t GetDaughterId(Int_t index) const; {return GetDaughter(index)->GetId();}. TVirtualGeoTrack * GetDaughter(Int_t index) const; {return (TVirtualGeoTrack*)fTracks->At(index);}. TVirtualGeoTrack * GetMother() const; {return fParent;",MatchSource.WIKI,root/html532/TVirtualGeoTrack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGeoTrack.html
https://root.cern/root/html532/TVirtualGeoTrack.html:10121,Modifiability,Inherit,Inherited,10121,"erwrite; kWriteDelete; };; enum TGeoAtt::[unnamed] { kBitMask; };; enum TGeoAtt::EGeoVisibilityAtt { kVisOverride; kVisNone; kVisThis; kVisDaughters; kVisOneLevel; kVisStreamed; kVisTouched; kVisOnScreen; kVisContainers; kVisOnly; kVisBranch; kVisRaytrace; };; enum TGeoAtt::EGeoActivityAtt { kActOverride; kActNone; kActThis; kActDaughters; };; enum TGeoAtt::EGeoOptimizationAtt { kUseBoundingBox; kUseVoxels; kUseGsord; };; enum TGeoAtt::EGeoSavePrimitiveAtt { kSavePrimitiveAtt; kSaveNodesAtt; };. protected:. UInt_tTGeoAtt::fGeoAttoption flags; Int_tfIdtrack id; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tfPDGtrack pdg code; TVirtualGeoTrack*fParentid of parent; TObject*fParticleparticle for this track; TObjArray*fTracksdaughter tracks. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualGeoTrack& operator=(const TVirtualGeoTrack& ); Assignment operator. NOT TO BE CALLED. ~TVirtualGeoTrack(); Destructor. TVirtualGeoTrack * FindTrackWithId(Int_t id) const; Recursively search through this track for a daughter; particle (at any depth) with the specified id. const char * GetName() const; Get the PDG name. Bool_t IsInTimeRange() const; True if track TOF range overlaps with time interval of TGeoManager. void SetName(const char* name); Set a default name for this track. TVirtualGeoTrack * AddDaughter(Int_t id, Int_t pdgcode, TObject* particle = 0). Int_t AddDaughter(TVirtualGeoTrack* other). void AddPoint(Double_t x, Double_t y, Double_t z, Double_t t). Int_t GetId() const; {return fId;}. Int_t GetDaughterId(Int_t index) const; {return GetDaughter(index)->GetId();}. TVirtualGeoTrack * GetDaughter(Int_t index) const; {return (TVirtualGeoTrack*)fTracks->At(index);}. TVirtualGeoTrack * GetMother() const; {return fParent;",MatchSource.WIKI,root/html532/TVirtualGeoTrack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGeoTrack.html
https://root.cern/root/html532/TVirtualGeoTrack.html:3852,Security,Hash,Hash,3852,"& t) const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; TVirtualGeoTrack*GetMother() const; TObject*GetMotherParticle() const; virtual const char*GetName() const; Int_tGetNdaughters() const; virtual Int_tGetNpoints() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetParentId() const; TObject*GetParticle() const; Int_tGetPDG() const; virtual const Double_t*GetPoint(Int_t i) const; virtual Int_tGetPoint(Int_t i, Double_t& x, Double_t& y, Double_t& z, Double_t& t) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; Bool_tHasPoints() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTGeoAtt::IsActive() const; Bool_tTGeoAtt::IsActiveDaughters() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tIsInTimeRange() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTGeoAtt::IsVisBranch() const; Bool_tTGeoAtt::IsVisContainers() const; Bool_tTGeoAtt::IsVisDaughters() const; Bool_tTGeoAtt::IsVisible() const; Bool_tTGeoAtt::IsVisLeaves() const; Bool_tTGeoAtt::IsVisOnly() const; Bool_tTGeoAtt::IsVisRaytrace() const; Bool_tTGeoAtt::IsVisStreamed() const; Bool_tTGeoAtt::IsVisTouched() const; Bool_tTObject::IsZombie() const; virtual voidTOb",MatchSource.WIKI,root/html532/TVirtualGeoTrack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGeoTrack.html
https://root.cern/root/html532/TVirtualGeoTrack.html:8288,Testability,Test,TestAttBit,8288,"set); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetId(Int_t id); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidTAttMarker::SetMarkerAttributes()MENU ; virtual voidTAttMarker::SetMarkerColor(Color_t tcolor = 1); virtual voidTAttMarker::SetMarkerSize(Size_t msize = 1); virtual voidTAttMarker::SetMarkerStyle(Style_t mstyle = 1); voidSetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); voidTGeoAtt::SetOptimization(Option_t* option); voidSetParent(TVirtualGeoTrack* parent); virtual voidSetParticle(TObject* particle); virtual voidSetPDG(Int_t pdgcode); virtual voidTObject::SetUniqueID(UInt_t uid); voidTGeoAtt::SetVisBranch(); virtual voidTGeoAtt::SetVisContainers(Bool_t flag = kTRUE); voidTGeoAtt::SetVisDaughters(Bool_t vis = kTRUE); virtual voidTGeoAtt::SetVisibility(Bool_t vis = kTRUE); virtual voidTGeoAtt::SetVisLeaves(Bool_t flag = kTRUE); virtual voidTGeoAtt::SetVisOnly(Bool_t flag = kTRUE); voidTGeoAtt::SetVisRaytrace(Bool_t flag = kTRUE); voidTGeoAtt::SetVisStreamed(Bool_t vis = kTRUE); voidTGeoAtt::SetVisTouched(Bool_t vis = kTRUE); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTGeoAtt::TestAttBit(UInt_t f) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TVirtualGeoTrack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGeoTrack.html
https://root.cern/root/html532/TVirtualGeoTrack.html:8331,Testability,Test,TestBit,8331,"set); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetId(Int_t id); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidTAttMarker::SetMarkerAttributes()MENU ; virtual voidTAttMarker::SetMarkerColor(Color_t tcolor = 1); virtual voidTAttMarker::SetMarkerSize(Size_t msize = 1); virtual voidTAttMarker::SetMarkerStyle(Style_t mstyle = 1); voidSetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); voidTGeoAtt::SetOptimization(Option_t* option); voidSetParent(TVirtualGeoTrack* parent); virtual voidSetParticle(TObject* particle); virtual voidSetPDG(Int_t pdgcode); virtual voidTObject::SetUniqueID(UInt_t uid); voidTGeoAtt::SetVisBranch(); virtual voidTGeoAtt::SetVisContainers(Bool_t flag = kTRUE); voidTGeoAtt::SetVisDaughters(Bool_t vis = kTRUE); virtual voidTGeoAtt::SetVisibility(Bool_t vis = kTRUE); virtual voidTGeoAtt::SetVisLeaves(Bool_t flag = kTRUE); virtual voidTGeoAtt::SetVisOnly(Bool_t flag = kTRUE); voidTGeoAtt::SetVisRaytrace(Bool_t flag = kTRUE); voidTGeoAtt::SetVisStreamed(Bool_t vis = kTRUE); voidTGeoAtt::SetVisTouched(Bool_t vis = kTRUE); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTGeoAtt::TestAttBit(UInt_t f) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TVirtualGeoTrack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGeoTrack.html
https://root.cern/root/html532/TVirtualGeoTrack.html:8370,Testability,Test,TestBits,8370,"set); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetId(Int_t id); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidTAttMarker::SetMarkerAttributes()MENU ; virtual voidTAttMarker::SetMarkerColor(Color_t tcolor = 1); virtual voidTAttMarker::SetMarkerSize(Size_t msize = 1); virtual voidTAttMarker::SetMarkerStyle(Style_t mstyle = 1); voidSetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); voidTGeoAtt::SetOptimization(Option_t* option); voidSetParent(TVirtualGeoTrack* parent); virtual voidSetParticle(TObject* particle); virtual voidSetPDG(Int_t pdgcode); virtual voidTObject::SetUniqueID(UInt_t uid); voidTGeoAtt::SetVisBranch(); virtual voidTGeoAtt::SetVisContainers(Bool_t flag = kTRUE); voidTGeoAtt::SetVisDaughters(Bool_t vis = kTRUE); virtual voidTGeoAtt::SetVisibility(Bool_t vis = kTRUE); virtual voidTGeoAtt::SetVisLeaves(Bool_t flag = kTRUE); virtual voidTGeoAtt::SetVisOnly(Bool_t flag = kTRUE); voidTGeoAtt::SetVisRaytrace(Bool_t flag = kTRUE); voidTGeoAtt::SetVisStreamed(Bool_t vis = kTRUE); voidTGeoAtt::SetVisTouched(Bool_t vis = kTRUE); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTGeoAtt::TestAttBit(UInt_t f) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TVirtualGeoTrack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGeoTrack.html
https://root.cern/root/html532/TVirtualGeoTrack.html:1267,Usability,Clear,Clear,1267," virtual~TVirtualGeoTrack(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAddDaughter(TVirtualGeoTrack* other); virtual TVirtualGeoTrack*AddDaughter(Int_t id, Int_t pdgcode, TObject* particle = 0); virtual voidAddPoint(Double_t x, Double_t y, Double_t z, Double_t t); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const",MatchSource.WIKI,root/html532/TVirtualGeoTrack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGeoTrack.html
https://root.cern/root/html532/TVirtualGLManip.html:496,Availability,avail,available,496,". TVirtualGLManip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualGLManip. class TVirtualGLManip. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualGLManip(); static TClass*Class(); virtual TClass*IsA() const; TVirtualGLManip&operator=(const TVirtualGLManip&); virtual Bool_tSelect(const TGLCamera& camera, const TGLRect& rect, const TGLBoundingBox& sceneBox); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualGLManip(); {}. Bool_t Select(const TGLCamera& camera, const TGLRect& rect, const TGLBoundingBox& sceneBox). » Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TVirtualGL.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TVirtualGLManip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGLManip.html
https://root.cern/root/html532/TVirtualGLManip.html:923,Availability,avail,available,923,". TVirtualGLManip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualGLManip. class TVirtualGLManip. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualGLManip(); static TClass*Class(); virtual TClass*IsA() const; TVirtualGLManip&operator=(const TVirtualGLManip&); virtual Bool_tSelect(const TGLCamera& camera, const TGLRect& rect, const TGLBoundingBox& sceneBox); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualGLManip(); {}. Bool_t Select(const TGLCamera& camera, const TGLRect& rect, const TGLBoundingBox& sceneBox). » Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TVirtualGL.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TVirtualGLManip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGLManip.html
https://root.cern/root/html532/TVirtualGLManip.html:370,Integrability,interface,interface,370,". TVirtualGLManip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualGLManip. class TVirtualGLManip. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualGLManip(); static TClass*Class(); virtual TClass*IsA() const; TVirtualGLManip&operator=(const TVirtualGLManip&); virtual Bool_tSelect(const TGLCamera& camera, const TGLRect& rect, const TGLBoundingBox& sceneBox); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualGLManip(); {}. Bool_t Select(const TGLCamera& camera, const TGLRect& rect, const TGLBoundingBox& sceneBox). » Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TVirtualGL.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TVirtualGLManip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGLManip.html
https://root.cern/root/html532/TVirtualGLManip.html:380,Integrability,protocol,protocol,380,". TVirtualGLManip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualGLManip. class TVirtualGLManip. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualGLManip(); static TClass*Class(); virtual TClass*IsA() const; TVirtualGLManip&operator=(const TVirtualGLManip&); virtual Bool_tSelect(const TGLCamera& camera, const TGLRect& rect, const TGLBoundingBox& sceneBox); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualGLManip(); {}. Bool_t Select(const TGLCamera& camera, const TGLRect& rect, const TGLBoundingBox& sceneBox). » Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TVirtualGL.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TVirtualGLManip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGLManip.html
https://root.cern/root/html532/TVirtualGLManip.html:596,Integrability,interface,interface,596,". TVirtualGLManip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualGLManip. class TVirtualGLManip. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualGLManip(); static TClass*Class(); virtual TClass*IsA() const; TVirtualGLManip&operator=(const TVirtualGLManip&); virtual Bool_tSelect(const TGLCamera& camera, const TGLRect& rect, const TGLBoundingBox& sceneBox); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualGLManip(); {}. Bool_t Select(const TGLCamera& camera, const TGLRect& rect, const TGLBoundingBox& sceneBox). » Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TVirtualGL.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TVirtualGLManip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGLManip.html
https://root.cern/root/html532/TVirtualGLManip.html:1317,Modifiability,Inherit,Inheritance,1317,". TVirtualGLManip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualGLManip. class TVirtualGLManip. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualGLManip(); static TClass*Class(); virtual TClass*IsA() const; TVirtualGLManip&operator=(const TVirtualGLManip&); virtual Bool_tSelect(const TGLCamera& camera, const TGLRect& rect, const TGLBoundingBox& sceneBox); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualGLManip(); {}. Bool_t Select(const TGLCamera& camera, const TGLRect& rect, const TGLBoundingBox& sceneBox). » Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TVirtualGL.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TVirtualGLManip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGLManip.html
https://root.cern/root/html532/TVirtualGLManip.html:1330,Modifiability,Inherit,Inherited,1330,". TVirtualGLManip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualGLManip. class TVirtualGLManip. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualGLManip(); static TClass*Class(); virtual TClass*IsA() const; TVirtualGLManip&operator=(const TVirtualGLManip&); virtual Bool_tSelect(const TGLCamera& camera, const TGLRect& rect, const TGLBoundingBox& sceneBox); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualGLManip(); {}. Bool_t Select(const TGLCamera& camera, const TGLRect& rect, const TGLBoundingBox& sceneBox). » Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TVirtualGL.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TVirtualGLManip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGLManip.html
https://root.cern/root/html532/TVirtualGLPainter.html:502,Availability,avail,available,502,". TVirtualGLPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualGLPainter. class TVirtualGLPainter. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualGLPainter(); static TClass*Class(); virtual char*GetPlotInfo(Int_t px, Int_t py); virtual TClass*IsA() const; TVirtualGLPainter&operator=(const TVirtualGLPainter&); virtual voidPaint(); virtual voidPan(Int_t px, Int_t py); virtual Bool_tPlotSelected(Int_t px, Int_t py); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualGLPainter(); {}. void Paint(). void Pan(Int_t px, Int_t py). Bool_t PlotSelected(Int_t px, Int_t py); Used by status bar in a canvas. char * GetPlotInfo(Int_t px, Int_t py). » Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TVirtualGL.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please ",MatchSource.WIKI,root/html532/TVirtualGLPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGLPainter.html
https://root.cern/root/html532/TVirtualGLPainter.html:929,Availability,avail,available,929,". TVirtualGLPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualGLPainter. class TVirtualGLPainter. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualGLPainter(); static TClass*Class(); virtual char*GetPlotInfo(Int_t px, Int_t py); virtual TClass*IsA() const; TVirtualGLPainter&operator=(const TVirtualGLPainter&); virtual voidPaint(); virtual voidPan(Int_t px, Int_t py); virtual Bool_tPlotSelected(Int_t px, Int_t py); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualGLPainter(); {}. void Paint(). void Pan(Int_t px, Int_t py). Bool_t PlotSelected(Int_t px, Int_t py); Used by status bar in a canvas. char * GetPlotInfo(Int_t px, Int_t py). » Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TVirtualGL.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please ",MatchSource.WIKI,root/html532/TVirtualGLPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGLPainter.html
https://root.cern/root/html532/TVirtualGLPainter.html:376,Integrability,interface,interface,376,". TVirtualGLPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualGLPainter. class TVirtualGLPainter. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualGLPainter(); static TClass*Class(); virtual char*GetPlotInfo(Int_t px, Int_t py); virtual TClass*IsA() const; TVirtualGLPainter&operator=(const TVirtualGLPainter&); virtual voidPaint(); virtual voidPan(Int_t px, Int_t py); virtual Bool_tPlotSelected(Int_t px, Int_t py); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualGLPainter(); {}. void Paint(). void Pan(Int_t px, Int_t py). Bool_t PlotSelected(Int_t px, Int_t py); Used by status bar in a canvas. char * GetPlotInfo(Int_t px, Int_t py). » Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TVirtualGL.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please ",MatchSource.WIKI,root/html532/TVirtualGLPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGLPainter.html
https://root.cern/root/html532/TVirtualGLPainter.html:386,Integrability,protocol,protocol,386,". TVirtualGLPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualGLPainter. class TVirtualGLPainter. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualGLPainter(); static TClass*Class(); virtual char*GetPlotInfo(Int_t px, Int_t py); virtual TClass*IsA() const; TVirtualGLPainter&operator=(const TVirtualGLPainter&); virtual voidPaint(); virtual voidPan(Int_t px, Int_t py); virtual Bool_tPlotSelected(Int_t px, Int_t py); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualGLPainter(); {}. void Paint(). void Pan(Int_t px, Int_t py). Bool_t PlotSelected(Int_t px, Int_t py); Used by status bar in a canvas. char * GetPlotInfo(Int_t px, Int_t py). » Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TVirtualGL.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please ",MatchSource.WIKI,root/html532/TVirtualGLPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGLPainter.html
https://root.cern/root/html532/TVirtualGLPainter.html:602,Integrability,interface,interface,602,". TVirtualGLPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualGLPainter. class TVirtualGLPainter. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualGLPainter(); static TClass*Class(); virtual char*GetPlotInfo(Int_t px, Int_t py); virtual TClass*IsA() const; TVirtualGLPainter&operator=(const TVirtualGLPainter&); virtual voidPaint(); virtual voidPan(Int_t px, Int_t py); virtual Bool_tPlotSelected(Int_t px, Int_t py); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualGLPainter(); {}. void Paint(). void Pan(Int_t px, Int_t py). Bool_t PlotSelected(Int_t px, Int_t py); Used by status bar in a canvas. char * GetPlotInfo(Int_t px, Int_t py). » Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TVirtualGL.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please ",MatchSource.WIKI,root/html532/TVirtualGLPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGLPainter.html
https://root.cern/root/html532/TVirtualGLPainter.html:1381,Modifiability,Inherit,Inheritance,1381,"ks:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualGLPainter. class TVirtualGLPainter. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualGLPainter(); static TClass*Class(); virtual char*GetPlotInfo(Int_t px, Int_t py); virtual TClass*IsA() const; TVirtualGLPainter&operator=(const TVirtualGLPainter&); virtual voidPaint(); virtual voidPan(Int_t px, Int_t py); virtual Bool_tPlotSelected(Int_t px, Int_t py); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualGLPainter(); {}. void Paint(). void Pan(Int_t px, Int_t py). Bool_t PlotSelected(Int_t px, Int_t py); Used by status bar in a canvas. char * GetPlotInfo(Int_t px, Int_t py). » Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TVirtualGL.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TVirtualGLPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGLPainter.html
https://root.cern/root/html532/TVirtualGLPainter.html:1394,Modifiability,Inherit,Inherited,1394,"ks:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualGLPainter. class TVirtualGLPainter. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualGLPainter(); static TClass*Class(); virtual char*GetPlotInfo(Int_t px, Int_t py); virtual TClass*IsA() const; TVirtualGLPainter&operator=(const TVirtualGLPainter&); virtual voidPaint(); virtual voidPan(Int_t px, Int_t py); virtual Bool_tPlotSelected(Int_t px, Int_t py); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualGLPainter(); {}. void Paint(). void Pan(Int_t px, Int_t py). Bool_t PlotSelected(Int_t px, Int_t py); Used by status bar in a canvas. char * GetPlotInfo(Int_t px, Int_t py). » Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TVirtualGL.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TVirtualGLPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGLPainter.html
https://root.cern/root/html532/TVirtualGraphPainter.html:525,Availability,avail,available,525,". TVirtualGraphPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TVirtualGraphPainter. class TVirtualGraphPainter: public TObject. TVirtualGraphPainter is an abstract interface to a histogram painter. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualGraphPainter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Int_tDistancetoPrimitiveHelper(TGraph* theGraph, Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawPanelHelper(TGraph* theGraph); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExecuteEventHelper(TGraph* theGraph, Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name",MatchSource.WIKI,root/html532/TVirtualGraphPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGraphPainter.html
https://root.cern/root/html532/TVirtualGraphPainter.html:1499,Availability,Error,Error,1499," virtual~TVirtualGraphPainter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Int_tDistancetoPrimitiveHelper(TGraph* theGraph, Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawPanelHelper(TGraph* theGraph); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExecuteEventHelper(TGraph* theGraph, Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name",MatchSource.WIKI,root/html532/TVirtualGraphPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGraphPainter.html
https://root.cern/root/html532/TVirtualGraphPainter.html:1628,Availability,error,error,1628,"method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Int_tDistancetoPrimitiveHelper(TGraph* theGraph, Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawPanelHelper(TGraph* theGraph); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExecuteEventHelper(TGraph* theGraph, Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual char*GetObjectInfoHelper(TGraph* theGraph, Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; static TVirtualGraphPainter*GetPainter(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject",MatchSource.WIKI,root/html532/TVirtualGraphPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGraphPainter.html
https://root.cern/root/html532/TVirtualGraphPainter.html:1712,Availability,error,error,1712,"bject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Int_tDistancetoPrimitiveHelper(TGraph* theGraph, Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawPanelHelper(TGraph* theGraph); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExecuteEventHelper(TGraph* theGraph, Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual char*GetObjectInfoHelper(TGraph* theGraph, Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; static TVirtualGraphPainter*GetPainter(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObj",MatchSource.WIKI,root/html532/TVirtualGraphPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGraphPainter.html
https://root.cern/root/html532/TVirtualGraphPainter.html:357,Integrability,interface,interface,357,". TVirtualGraphPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TVirtualGraphPainter. class TVirtualGraphPainter: public TObject. TVirtualGraphPainter is an abstract interface to a histogram painter. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualGraphPainter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Int_tDistancetoPrimitiveHelper(TGraph* theGraph, Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawPanelHelper(TGraph* theGraph); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExecuteEventHelper(TGraph* theGraph, Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name",MatchSource.WIKI,root/html532/TVirtualGraphPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGraphPainter.html
https://root.cern/root/html532/TVirtualGraphPainter.html:2795,Modifiability,Inherit,InheritsFrom,2795,"oidExecuteEventHelper(TGraph* theGraph, Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual char*GetObjectInfoHelper(TGraph* theGraph, Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; static TVirtualGraphPainter*GetPainter(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TOb",MatchSource.WIKI,root/html532/TVirtualGraphPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGraphPainter.html
https://root.cern/root/html532/TVirtualGraphPainter.html:2861,Modifiability,Inherit,InheritsFrom,2861,"_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual char*GetObjectInfoHelper(TGraph* theGraph, Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; static TVirtualGraphPainter*GetPainter(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TVirtualGraphPainter&op",MatchSource.WIKI,root/html532/TVirtualGraphPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGraphPainter.html
https://root.cern/root/html532/TVirtualGraphPainter.html:6078,Modifiability,Inherit,Inheritance,6078,"irtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. static TVirtualGraphPainter*fgPainterPointer to class painter. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualGraphPainter * GetPainter(); Static function returning a pointer to the current graph painter.; If the graph painter does not exist a default painter (singleton) is created. void SetPainter(TVirtualGraphPainter* painter); Static function to set an alternative histogram painter. virtual ~TVirtualGraphPainter(); { }. Int_t DistancetoPrimitiveHelper(TGraph* theGraph, Int_t px, Int_t py). void DrawPanelHelper(TGraph* theGraph). void ExecuteEventHelper(TGraph* theGraph, Int_t event, Int_t px, Int_t py). char * GetObjectInfoHelper(TGraph* theGraph, Int_t px, Int_t py) const. void PaintHelper(TGraph* theGraph, Option_t* option). void PaintGraph(TGraph* theGraph, Int_t npoints, const Double_t* x, const Double_t* y, Option_t* chopt). void PaintGrapHist(TGraph* theGraph, Int_t npoints, const Double_t* x, const Double_t* y, Option_t* chopt). void PaintStats(TGraph* theGraph, TF1* fit). » Author: Olivier Couet 20/05/08 » Copyright (C) 1995",MatchSource.WIKI,root/html532/TVirtualGraphPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGraphPainter.html
https://root.cern/root/html532/TVirtualGraphPainter.html:6091,Modifiability,Inherit,Inherited,6091,"irtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. static TVirtualGraphPainter*fgPainterPointer to class painter. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualGraphPainter * GetPainter(); Static function returning a pointer to the current graph painter.; If the graph painter does not exist a default painter (singleton) is created. void SetPainter(TVirtualGraphPainter* painter); Static function to set an alternative histogram painter. virtual ~TVirtualGraphPainter(); { }. Int_t DistancetoPrimitiveHelper(TGraph* theGraph, Int_t px, Int_t py). void DrawPanelHelper(TGraph* theGraph). void ExecuteEventHelper(TGraph* theGraph, Int_t event, Int_t px, Int_t py). char * GetObjectInfoHelper(TGraph* theGraph, Int_t px, Int_t py) const. void PaintHelper(TGraph* theGraph, Option_t* option). void PaintGraph(TGraph* theGraph, Int_t npoints, const Double_t* x, const Double_t* y, Option_t* chopt). void PaintGrapHist(TGraph* theGraph, Int_t npoints, const Double_t* x, const Double_t* y, Option_t* chopt). void PaintStats(TGraph* theGraph, TF1* fit). » Author: Olivier Couet 20/05/08 » Copyright (C) 1995",MatchSource.WIKI,root/html532/TVirtualGraphPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGraphPainter.html
https://root.cern/root/html532/TVirtualGraphPainter.html:2685,Security,Hash,Hash,2685,"ObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExecuteEventHelper(TGraph* theGraph, Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual char*GetObjectInfoHelper(TGraph* theGraph, Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; static TVirtualGraphPainter*GetPainter(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator ",MatchSource.WIKI,root/html532/TVirtualGraphPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGraphPainter.html
https://root.cern/root/html532/TVirtualGraphPainter.html:5215,Testability,Test,TestBit,5215,"perator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TVirtualGraphPainter&operator=(const TVirtualGraphPainter&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidPaintGraph(TGraph* theGraph, Int_t npoints, const Double_t* x, const Double_t* y, Option_t* chopt); virtual voidPaintGrapHist(TGraph* theGraph, Int_t npoints, const Double_t* x, const Double_t* y, Option_t* chopt); virtual voidPaintHelper(TGraph* theGraph, Option_t* option); virtual voidPaintStats(TGraph* theGraph, TF1* fit); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); static voidSetPainter(TVirtualGraphPainter* painter); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TVirtualGraphPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGraphPainter.html
https://root.cern/root/html532/TVirtualGraphPainter.html:5254,Testability,Test,TestBits,5254,"perator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TVirtualGraphPainter&operator=(const TVirtualGraphPainter&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidPaintGraph(TGraph* theGraph, Int_t npoints, const Double_t* x, const Double_t* y, Option_t* chopt); virtual voidPaintGrapHist(TGraph* theGraph, Int_t npoints, const Double_t* x, const Double_t* y, Option_t* chopt); virtual voidPaintHelper(TGraph* theGraph, Option_t* option); virtual voidPaintStats(TGraph* theGraph, TF1* fit); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); static voidSetPainter(TVirtualGraphPainter* painter); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TVirtualGraphPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGraphPainter.html
https://root.cern/root/html532/TVirtualGraphPainter.html:834,Usability,Clear,Clear,834," virtual~TVirtualGraphPainter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Int_tDistancetoPrimitiveHelper(TGraph* theGraph, Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawPanelHelper(TGraph* theGraph); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExecuteEventHelper(TGraph* theGraph, Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name",MatchSource.WIKI,root/html532/TVirtualGraphPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualGraphPainter.html
https://root.cern/root/html532/TVirtualHistPainter.html:521,Availability,avail,available,521,". TVirtualHistPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TVirtualHistPainter. class TVirtualHistPainter: public TObject. TVirtualHistPainter is an abstract interface to a histogram painter. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualHistPainter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawPanel(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TList*GetContourList(Double_t contour) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOn",MatchSource.WIKI,root/html532/TVirtualHistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualHistPainter.html
https://root.cern/root/html532/TVirtualHistPainter.html:1385,Availability,Error,Error,1385," virtual~TVirtualHistPainter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawPanel(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TList*GetContourList(Double_t contour) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOn",MatchSource.WIKI,root/html532/TVirtualHistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualHistPainter.html
https://root.cern/root/html532/TVirtualHistPainter.html:1514,Availability,error,error,1514," virtual~TVirtualHistPainter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawPanel(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TList*GetContourList(Double_t contour) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOn",MatchSource.WIKI,root/html532/TVirtualHistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualHistPainter.html
https://root.cern/root/html532/TVirtualHistPainter.html:1598,Availability,error,error,1598,"stractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawPanel(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TList*GetContourList(Double_t contour) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TList*GetStack() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; static TVirtualHistPainter*HistPainter(TH1* obj); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::Inher",MatchSource.WIKI,root/html532/TVirtualHistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualHistPainter.html
https://root.cern/root/html532/TVirtualHistPainter.html:353,Integrability,interface,interface,353,". TVirtualHistPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TVirtualHistPainter. class TVirtualHistPainter: public TObject. TVirtualHistPainter is an abstract interface to a histogram painter. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualHistPainter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawPanel(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TList*GetContourList(Double_t contour) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOn",MatchSource.WIKI,root/html532/TVirtualHistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualHistPainter.html
https://root.cern/root/html532/TVirtualHistPainter.html:2596,Modifiability,Inherit,InheritsFrom,2596,"r = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TList*GetContourList(Double_t contour) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TList*GetStack() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; static TVirtualHistPainter*HistPainter(TH1* obj); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tIsInside(Int_t x, Int_t y); virtual Bool_tIsInside(Double_t x, Double_t y); Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; virtual Int_tMakeCuts(char* cutsopt); voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObj",MatchSource.WIKI,root/html532/TVirtualHistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualHistPainter.html
https://root.cern/root/html532/TVirtualHistPainter.html:2662,Modifiability,Inherit,InheritsFrom,2662," virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TList*GetContourList(Double_t contour) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TList*GetStack() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; static TVirtualHistPainter*HistPainter(TH1* obj); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tIsInside(Int_t x, Int_t y); virtual Bool_tIsInside(Double_t x, Double_t y); Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; virtual Int_tMakeCuts(char* cutsopt); voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz",MatchSource.WIKI,root/html532/TVirtualHistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualHistPainter.html
https://root.cern/root/html532/TVirtualHistPainter.html:5879,Modifiability,Inherit,Inheritance,5879,"voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. static TClass*fgPainterPointer to class painter. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualHistPainter * HistPainter(TH1* obj); Static function returning a pointer to the current histogram painter.; The painter will paint the specified obj. If the histogram painter; does not exist a default painter is created. void SetPainter(const char* painter); Static function to set an alternative histogram painter. virtual ~TVirtualHistPainter(); { }. Int_t DistancetoPrimitive(Int_t px, Int_t py). void DrawPanel(). void ExecuteEvent(Int_t event, Int_t px, Int_t py). TList * GetContourList(Double_t contour) const. char * GetObjectInfo(Int_t px, Int_t py) const. TList * GetStack() const. Bool_t IsInside(Int_t x, Int_t y). Bool_t IsInside(Double_t x, Double_t y). void Paint(Option_t* option = """"). void PaintStat(Int_t dostat, TF1* fit). void ProcessMessage(const char* mess, const TObject* obj). void SetHistogram(TH1* h). void SetStack(TList* stack). Int_t MakeCuts(char* cutsopt). void SetShowProjection(const char* option, Int_t nbi",MatchSource.WIKI,root/html532/TVirtualHistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualHistPainter.html
https://root.cern/root/html532/TVirtualHistPainter.html:5892,Modifiability,Inherit,Inherited,5892,"voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. static TClass*fgPainterPointer to class painter. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualHistPainter * HistPainter(TH1* obj); Static function returning a pointer to the current histogram painter.; The painter will paint the specified obj. If the histogram painter; does not exist a default painter is created. void SetPainter(const char* painter); Static function to set an alternative histogram painter. virtual ~TVirtualHistPainter(); { }. Int_t DistancetoPrimitive(Int_t px, Int_t py). void DrawPanel(). void ExecuteEvent(Int_t event, Int_t px, Int_t py). TList * GetContourList(Double_t contour) const. char * GetObjectInfo(Int_t px, Int_t py) const. TList * GetStack() const. Bool_t IsInside(Int_t x, Int_t y). Bool_t IsInside(Double_t x, Double_t y). void Paint(Option_t* option = """"). void PaintStat(Int_t dostat, TF1* fit). void ProcessMessage(const char* mess, const TObject* obj). void SetHistogram(TH1* h). void SetStack(TList* stack). Int_t MakeCuts(char* cutsopt). void SetShowProjection(const char* option, Int_t nbi",MatchSource.WIKI,root/html532/TVirtualHistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualHistPainter.html
https://root.cern/root/html532/TVirtualHistPainter.html:2436,Security,Hash,Hash,2436,"virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TList*GetContourList(Double_t contour) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TList*GetStack() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; static TVirtualHistPainter*HistPainter(TH1* obj); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tIsInside(Int_t x, Int_t y); virtual Bool_tIsInside(Double_t x, Double_t y); Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; virtual Int_tMakeCuts(char* cutsopt); voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTO",MatchSource.WIKI,root/html532/TVirtualHistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualHistPainter.html
https://root.cern/root/html532/TVirtualHistPainter.html:5030,Testability,Test,TestBit,5030,"bject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TVirtualHistPainter&operator=(const TVirtualHistPainter&); virtual voidPaint(Option_t* option = """"); virtual voidPaintStat(Int_t dostat, TF1* fit); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidProcessMessage(const char* mess, const TObject* obj); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetHistogram(TH1* h); static voidTObject::SetObjectStat(Bool_t stat); static voidSetPainter(const char* painter); virtual voidSetShowProjection(const char* option, Int_t nbins); virtual voidSetStack(TList* stack); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TVirtualHistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualHistPainter.html
https://root.cern/root/html532/TVirtualHistPainter.html:5069,Testability,Test,TestBits,5069,"bject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TVirtualHistPainter&operator=(const TVirtualHistPainter&); virtual voidPaint(Option_t* option = """"); virtual voidPaintStat(Int_t dostat, TF1* fit); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidProcessMessage(const char* mess, const TObject* obj); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetHistogram(TH1* h); static voidTObject::SetObjectStat(Bool_t stat); static voidSetPainter(const char* painter); virtual voidSetShowProjection(const char* option, Int_t nbins); virtual voidSetStack(TList* stack); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TVirtualHistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualHistPainter.html
https://root.cern/root/html532/TVirtualHistPainter.html:829,Usability,Clear,Clear,829," virtual~TVirtualHistPainter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawPanel(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TList*GetContourList(Double_t contour) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOn",MatchSource.WIKI,root/html532/TVirtualHistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualHistPainter.html
https://root.cern/root/html532/TVirtualIndex.html:468,Availability,avail,available,468,". TVirtualIndex. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TVirtualIndex. class TVirtualIndex: public TNamed. Abstract interface for Tree Index. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualIndex(); voidTObject::AbstractMethod(const char* method) const; virtual voidAppend(const TVirtualIndex*, Bool_t delaySort = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly",MatchSource.WIKI,root/html532/TVirtualIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualIndex.html
https://root.cern/root/html532/TVirtualIndex.html:1381,Availability,Error,Error,1381," virtual~TVirtualIndex(); voidTObject::AbstractMethod(const char* method) const; virtual voidAppend(const TVirtualIndex*, Bool_t delaySort = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly",MatchSource.WIKI,root/html532/TVirtualIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualIndex.html
https://root.cern/root/html532/TVirtualIndex.html:1510,Availability,error,error,1510,"rtualIndex(); voidTObject::AbstractMethod(const char* method) const; virtual voidAppend(const TVirtualIndex*, Bool_t delaySort = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetEntryNumberFriend(const TTree*); virtual Long64_tGetEntryNumberWithBestIndex(Int_t major, Int_t minor) const; virtual Long64_tGetEntryNumberWithIndex(Int_t major, Int_t minor) const; virtual const char*TObject::GetIconName() const; virtual const char*GetMajorName() const; virtual const char*GetMinorName() const; virtual Long64_tGetN() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat();",MatchSource.WIKI,root/html532/TVirtualIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualIndex.html
https://root.cern/root/html532/TVirtualIndex.html:1594,Availability,error,error,1594,"end(const TVirtualIndex*, Bool_t delaySort = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetEntryNumberFriend(const TTree*); virtual Long64_tGetEntryNumberWithBestIndex(Int_t major, Int_t minor) const; virtual Long64_tGetEntryNumberWithIndex(Int_t major, Int_t minor) const; virtual const char*TObject::GetIconName() const; virtual const char*GetMajorName() const; virtual const char*GetMinorName() const; virtual Long64_tGetN() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() ",MatchSource.WIKI,root/html532/TVirtualIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualIndex.html
https://root.cern/root/html532/TVirtualIndex.html:6568,Deployability,Update,UpdateFormulaLeaves,6568,"StreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUpdateFormulaLeaves(const TTree* parent); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; TTree*fTree! pointer to Tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TVirtualIndex(). void Append(const TVirtualIndex* , Bool_t delaySort = kFALSE). Long64_t GetEntryNumberFriend(const TTree* ). Long64_t GetEntryNumberWithIndex(Int_t major, Int_t minor) const. Long64_t GetEntryNumberWithBestIndex(Int_t major, Int_t minor) const. const char * GetMajorName() const. const char * GetMinorName() const. Long64_t GetN() const. TTree * GetTree() const; {return fTree;}. void UpdateFormulaLeaves(const TTree* parent). void SetTree(const TTree* T). » Author: Rene Brun 05/07/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TVirtualIndex.h 38496 2011-03-18 10:04:01Z pcanal $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TVirtualIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualIndex.html
https://root.cern/root/html532/TVirtualIndex.html:308,Integrability,interface,interface,308,". TVirtualIndex. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TVirtualIndex. class TVirtualIndex: public TNamed. Abstract interface for Tree Index. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualIndex(); voidTObject::AbstractMethod(const char* method) const; virtual voidAppend(const TVirtualIndex*, Bool_t delaySort = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly",MatchSource.WIKI,root/html532/TVirtualIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualIndex.html
https://root.cern/root/html532/TVirtualIndex.html:2863,Modifiability,Inherit,InheritsFrom,2863,"ct*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetEntryNumberFriend(const TTree*); virtual Long64_tGetEntryNumberWithBestIndex(Int_t major, Int_t minor) const; virtual Long64_tGetEntryNumberWithIndex(Int_t major, Int_t minor) const; virtual const char*TObject::GetIconName() const; virtual const char*GetMajorName() const; virtual const char*GetMinorName() const; virtual Long64_tGetN() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual TTree*GetTree() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObje",MatchSource.WIKI,root/html532/TVirtualIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualIndex.html
https://root.cern/root/html532/TVirtualIndex.html:2929,Modifiability,Inherit,InheritsFrom,2929,"*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetEntryNumberFriend(const TTree*); virtual Long64_tGetEntryNumberWithBestIndex(Int_t major, Int_t minor) const; virtual Long64_tGetEntryNumberWithIndex(Int_t major, Int_t minor) const; virtual const char*TObject::GetIconName() const; virtual const char*GetMajorName() const; virtual const char*GetMinorName() const; virtual Long64_tGetN() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual TTree*GetTree() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TVirtualIndex&operator=(c",MatchSource.WIKI,root/html532/TVirtualIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualIndex.html
https://root.cern/root/html532/TVirtualIndex.html:6088,Modifiability,Inherit,Inheritance,6088,"StreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUpdateFormulaLeaves(const TTree* parent); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; TTree*fTree! pointer to Tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TVirtualIndex(). void Append(const TVirtualIndex* , Bool_t delaySort = kFALSE). Long64_t GetEntryNumberFriend(const TTree* ). Long64_t GetEntryNumberWithIndex(Int_t major, Int_t minor) const. Long64_t GetEntryNumberWithBestIndex(Int_t major, Int_t minor) const. const char * GetMajorName() const. const char * GetMinorName() const. Long64_t GetN() const. TTree * GetTree() const; {return fTree;}. void UpdateFormulaLeaves(const TTree* parent). void SetTree(const TTree* T). » Author: Rene Brun 05/07/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TVirtualIndex.h 38496 2011-03-18 10:04:01Z pcanal $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TVirtualIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualIndex.html
https://root.cern/root/html532/TVirtualIndex.html:6101,Modifiability,Inherit,Inherited,6101,"StreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUpdateFormulaLeaves(const TTree* parent); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; TTree*fTree! pointer to Tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TVirtualIndex(). void Append(const TVirtualIndex* , Bool_t delaySort = kFALSE). Long64_t GetEntryNumberFriend(const TTree* ). Long64_t GetEntryNumberWithIndex(Int_t major, Int_t minor) const. Long64_t GetEntryNumberWithBestIndex(Int_t major, Int_t minor) const. const char * GetMajorName() const. const char * GetMinorName() const. Long64_t GetN() const. TTree * GetTree() const; {return fTree;}. void UpdateFormulaLeaves(const TTree* parent). void SetTree(const TTree* T). » Author: Rene Brun 05/07/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TVirtualIndex.h 38496 2011-03-18 10:04:01Z pcanal $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TVirtualIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualIndex.html
https://root.cern/root/html532/TVirtualIndex.html:2753,Security,Hash,Hash,2753," voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetEntryNumberFriend(const TTree*); virtual Long64_tGetEntryNumberWithBestIndex(Int_t major, Int_t minor) const; virtual Long64_tGetEntryNumberWithIndex(Int_t major, Int_t minor) const; virtual const char*TObject::GetIconName() const; virtual const char*GetMajorName() const; virtual const char*GetMinorName() const; virtual Long64_tGetN() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual TTree*GetTree() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator ne",MatchSource.WIKI,root/html532/TVirtualIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualIndex.html
https://root.cern/root/html532/TVirtualIndex.html:5128,Testability,Test,TestBit,5128," delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TVirtualIndex&operator=(const TVirtualIndex&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidSetTree(const TTree* T); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUpdateFormulaLeaves(const TTree* parent); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TVirtualIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualIndex.html
https://root.cern/root/html532/TVirtualIndex.html:5167,Testability,Test,TestBits,5167," delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TVirtualIndex&operator=(const TVirtualIndex&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidSetTree(const TTree* T); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUpdateFormulaLeaves(const TTree* parent); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TVirtualIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualIndex.html
https://root.cern/root/html532/TVirtualIndex.html:838,Usability,Clear,Clear,838," virtual~TVirtualIndex(); voidTObject::AbstractMethod(const char* method) const; virtual voidAppend(const TVirtualIndex*, Bool_t delaySort = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly",MatchSource.WIKI,root/html532/TVirtualIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualIndex.html
https://root.cern/root/html532/TVirtualIsAProxy.html:440,Availability,avail,available,440,". TVirtualIsAProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TVirtualIsAProxy. class TVirtualIsAProxy. TClass. Virtual IsAProxy base class. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualIsAProxy(); virtual TClass*operator()(const void* obj); TVirtualIsAProxy&operator=(const TVirtualIsAProxy&); virtual voidSetClass(TClass* cl). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualIsAProxy(); { }. void SetClass(TClass* cl). TClass* operator()(const void* obj). » Author: Markus Frank 20/05/2005 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: TVirtualIsAProxy.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TVirtualIsAProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualIsAProxy.html
https://root.cern/root/html532/TVirtualIsAProxy.html:647,Modifiability,Inherit,Inheritance,647,". TVirtualIsAProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TVirtualIsAProxy. class TVirtualIsAProxy. TClass. Virtual IsAProxy base class. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualIsAProxy(); virtual TClass*operator()(const void* obj); TVirtualIsAProxy&operator=(const TVirtualIsAProxy&); virtual voidSetClass(TClass* cl). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualIsAProxy(); { }. void SetClass(TClass* cl). TClass* operator()(const void* obj). » Author: Markus Frank 20/05/2005 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: TVirtualIsAProxy.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TVirtualIsAProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualIsAProxy.html
https://root.cern/root/html532/TVirtualIsAProxy.html:660,Modifiability,Inherit,Inherited,660,". TVirtualIsAProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TVirtualIsAProxy. class TVirtualIsAProxy. TClass. Virtual IsAProxy base class. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualIsAProxy(); virtual TClass*operator()(const void* obj); TVirtualIsAProxy&operator=(const TVirtualIsAProxy&); virtual voidSetClass(TClass* cl). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualIsAProxy(); { }. void SetClass(TClass* cl). TClass* operator()(const void* obj). » Author: Markus Frank 20/05/2005 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: TVirtualIsAProxy.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TVirtualIsAProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualIsAProxy.html
https://root.cern/root/html532/TVirtualMagField.html:1035,Availability,avail,available,1035,"inks:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TVirtualMagField. class TVirtualMagField: public TNamed. TVirtualMagField - ABC for magnetic field. Derived classes are encouraged to; use the TVirtualMagField named constructor and must implement the method:; Field(const Double_t *x, Double_t *B). A field object can be made global via:; TGlobalMagField::Instance()->SetField(field) [1]; A field which is made global is owned by the field manager. The used is not; allowed to delete it directly anymore (otherwise a Fatal() is issued). Global; field can be deleted by calling [1] with a different argument (which can be; NULL). Otherwise the global field is deleted together with the field manager. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualMagField(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtu",MatchSource.WIKI,root/html532/TVirtualMagField.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMagField.html
https://root.cern/root/html532/TVirtualMagField.html:1882,Availability,Error,Error,1882," virtual~TVirtualMagField(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* param",MatchSource.WIKI,root/html532/TVirtualMagField.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMagField.html
https://root.cern/root/html532/TVirtualMagField.html:2011,Availability,error,error,2011," virtual~TVirtualMagField(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* param",MatchSource.WIKI,root/html532/TVirtualMagField.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMagField.html
https://root.cern/root/html532/TVirtualMagField.html:2095,Availability,error,error,2095,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidField(const Double_t* x, Double_t* B); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* cla",MatchSource.WIKI,root/html532/TVirtualMagField.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMagField.html
https://root.cern/root/html532/TVirtualMagField.html:3070,Modifiability,Inherit,InheritsFrom,3070,"ay* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidField(const Double_t* x, Double_t* B); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObje",MatchSource.WIKI,root/html532/TVirtualMagField.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMagField.html
https://root.cern/root/html532/TVirtualMagField.html:3136,Modifiability,Inherit,InheritsFrom,3136,"nt_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidField(const Double_t* x, Double_t* B); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TVirtualMagField&operator",MatchSource.WIKI,root/html532/TVirtualMagField.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMagField.html
https://root.cern/root/html532/TVirtualMagField.html:6180,Modifiability,Inherit,Inheritance,6180,"ect::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TVirtualMagField(); Destructor. Unregisters the field. void Field(const Double_t* x, Double_t* B). TGeoUniformMagField& operator=(const TVirtualMagField& ). » Last changed: root/geom:$Id: TVirtualMagField.h 27106 2009-01-09 07:55:28Z brun $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TVirtualMagField.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMagField.html
https://root.cern/root/html532/TVirtualMagField.html:6193,Modifiability,Inherit,Inherited,6193,"ect::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TVirtualMagField(); Destructor. Unregisters the field. void Field(const Double_t* x, Double_t* B). TGeoUniformMagField& operator=(const TVirtualMagField& ). » Last changed: root/geom:$Id: TVirtualMagField.h 27106 2009-01-09 07:55:28Z brun $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TVirtualMagField.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMagField.html
https://root.cern/root/html532/TVirtualMagField.html:2960,Security,Hash,Hash,2960,"e(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidField(const Double_t* x, Double_t* B); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator ne",MatchSource.WIKI,root/html532/TVirtualMagField.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMagField.html
https://root.cern/root/html532/TVirtualMagField.html:5304,Testability,Test,TestBit,5304,"onst char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TVirtualMagField&operator=(const TVirtualMagField&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TVirtualMagField.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMagField.html
https://root.cern/root/html532/TVirtualMagField.html:5343,Testability,Test,TestBits,5343,"onst char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TVirtualMagField&operator=(const TVirtualMagField&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TVirtualMagField.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMagField.html
https://root.cern/root/html532/TVirtualMagField.html:1339,Usability,Clear,Clear,1339," virtual~TVirtualMagField(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* param",MatchSource.WIKI,root/html532/TVirtualMagField.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMagField.html
https://root.cern/root/html532/TVirtualMC.html:949,Availability,avail,available,949,". TVirtualMC. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » VMC; » TVirtualMC. class TVirtualMC: public TNamed. Virtual MC provides a virtual interface to Monte Carlo.; It enables the user to build a virtual Monte Carlo application; independent of any actual underlying Monte Carlo implementation itself. A user will have to implement a class derived from the abstract; Monte Carlo application class, and provide functions like; ConstructGeometry(), BeginEvent(), FinishEvent(), ... .; The concrete Monte Carlo (Geant3, Geant4) is selected at run time -; when processing a ROOT macro where the concrete Monte Carlo is instantiated. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualMC(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidBuildPhysics(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCurrentBoundaryNormal(Double_t& x, Double_t& y, Double_t& z) const; virtual Int_tCurrentEvent() const; virtual Int_tCurrentMaterial(Float_t& a, Float_t& z, Float_t& dens, Float_t& radl, Float_t& absl) const; virtual Int_tCurrentMedium() const; virtual Int_tCurrentVolID(Int_t& copyNo) const; virtual const char*CurrentVolName() const; virtual Int_tCurrentVolOffID(Int_t off, Int_t& copyNo) const; virtual const char*CurrentVolOffName(Int_t off) const; virtual const char*CurrentVolPath(); virtual Bool_tDefineIon(co",MatchSource.WIKI,root/html532/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMC.html
https://root.cern/root/html532/TVirtualMC.html:3197,Availability,Error,Error,3197,,MatchSource.WIKI,root/html532/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMC.html
https://root.cern/root/html532/TVirtualMC.html:3356,Availability,error,error,3356,,MatchSource.WIKI,root/html532/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMC.html
https://root.cern/root/html532/TVirtualMC.html:3440,Availability,error,error,3440,,MatchSource.WIKI,root/html532/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMC.html
https://root.cern/root/html532/TVirtualMC.html:27954,Availability,error,error,27954,"me identifier id. Int_t MediumId(const char* mediumName) const; Return the unique numeric identifier for medium name mediumName. Int_t NofVolumes() const; Return total number of volumes in the geometry. Int_t VolId2Mate(Int_t id) const; Return material number for a given volume id. Int_t NofVolDaughters(const char* volName) const; Return number of daughters of the volume specified by volName. const char* VolDaughterName(const char* volName, Int_t i) const; Return the name of i-th daughter of the volume specified by volName. Int_t VolDaughterCopyNo(const char* volName, Int_t i) const; Return the copyNo of i-th daughter of the volume specified by volName. Bool_t SetCut(const char* cutName, Double_t cutValue). methods for physics management. set methods. Set transport cuts for particles. Bool_t SetProcess(const char* flagName, Int_t flagValue); Set process control. Bool_t DefineParticle(Int_t pdg, const char* name, TMCParticleType mcType, Double_t mass, Double_t charge, Double_t lifetime); Set a user defined particle; Function is ignored if particle with specified pdg; already exists and error report is printed.; pdg PDG encoding; name particle name; mcType VMC Particle type; mass mass [GeV]; charge charge [eplus]; lifetime time of life [s]; pType particle type as in Geant4; width width [GeV]; iSpin spin; iParity parity; iConjugation conjugation; iIsospin isospin; iIsospinZ isospin - #rd component; gParity gParity; lepton lepton number; baryon baryon number; stable stability; shortlived is shorlived?; subType particle subType as in Geant4; antiEncoding anti encoding; magMoment magnetic moment; excitation excitation energy [GeV]. Bool_t DefineIon(const char* name, Int_t Z, Int_t A, Int_t Q, Double_t excEnergy, Double_t mass = 0.); Set a user defined particle; Function is ignored if particle with specified pdg; already exists and error report is printed.; pdg PDG encoding; name particle name; mcType VMC Particle type; mass mass [GeV]; charge charge [eplus]; lifetime time",MatchSource.WIKI,root/html532/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMC.html
https://root.cern/root/html532/TVirtualMC.html:28709,Availability,error,error,28709,"st char* flagName, Int_t flagValue); Set process control. Bool_t DefineParticle(Int_t pdg, const char* name, TMCParticleType mcType, Double_t mass, Double_t charge, Double_t lifetime); Set a user defined particle; Function is ignored if particle with specified pdg; already exists and error report is printed.; pdg PDG encoding; name particle name; mcType VMC Particle type; mass mass [GeV]; charge charge [eplus]; lifetime time of life [s]; pType particle type as in Geant4; width width [GeV]; iSpin spin; iParity parity; iConjugation conjugation; iIsospin isospin; iIsospinZ isospin - #rd component; gParity gParity; lepton lepton number; baryon baryon number; stable stability; shortlived is shorlived?; subType particle subType as in Geant4; antiEncoding anti encoding; magMoment magnetic moment; excitation excitation energy [GeV]. Bool_t DefineIon(const char* name, Int_t Z, Int_t A, Int_t Q, Double_t excEnergy, Double_t mass = 0.); Set a user defined particle; Function is ignored if particle with specified pdg; already exists and error report is printed.; pdg PDG encoding; name particle name; mcType VMC Particle type; mass mass [GeV]; charge charge [eplus]; lifetime time of life [s]; pType particle type as in Geant4; width width [GeV]; iSpin spin; iParity parity; iConjugation conjugation; iIsospin isospin; iIsospinZ isospin - #rd component; gParity gParity; lepton lepton number; baryon baryon number; stable stability; shortlived is shorlived?; subType particle subType as in Geant4; antiEncoding anti encoding; magMoment magnetic moment; excitation excitation energy [GeV]; Set a user defined ion.; name ion name; Z atomic number; A atomic mass; Q charge [eplus}; excitation excitation energy [GeV]; mass mass [GeV] (if not specified by user, approximative; mass is calculated). Double_t Xsec(char* , Double_t , Int_t , Int_t ); Set a user phase space decay for a particle; pdg particle PDG encoding; bratios the array with branching ratios (in %); mode[6][3] the array with daughter",MatchSource.WIKI,root/html532/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMC.html
https://root.cern/root/html532/TVirtualMC.html:35282,Availability,alive,alive,35282,"rn the charge of the track currently transported. Double_t TrackMass() const; Return the mass of the track currently transported. Double_t Etot() const; Return the total energy of the current track. Bool_t IsNewTrack() const. get methods - track status. Return true when the track performs the first step. Bool_t IsTrackInside() const; Return true if the track is not at the boundary of the current volume. Bool_t IsTrackEntering() const; Return true if this is the first step of the track in the current volume. Bool_t IsTrackExiting() const; Return true if this is the last step of the track in the current volume. Bool_t IsTrackOut() const; Return true if the track is out of the setup. Bool_t IsTrackDisappeared() const; Return true if the current particle has disappeared; either because it decayed or because it underwent; an inelastic collision. Bool_t IsTrackStop() const; Return true if the track energy has fallen below the threshold. Bool_t IsTrackAlive() const; Return true if the current particle is alive and will continue to be; transported. Int_t NSecondaries() const. get methods - secondaries. Return the number of secondary particles generated in the current step. void GetSecondary(Int_t isec, Int_t& particleId, TLorentzVector& position, TLorentzVector& momentum); Return the parameters of the secondary track number isec produced; in the current step. Int_t StepProcesses(TArrayI& proc) const; Return the VMC code of the process that has produced the secondary; particles in the current step; Return the array of the VMC code of the processes active in the current; step. Bool_t SecondariesAreOrdered() const; Return the information about the transport order needed by the stack. void Init(). Control methods. Initialize MC. void BuildPhysics(); Initialize MC physics. void ProcessEvent(); Process one event; Deprecated. Bool_t ProcessRun(Int_t nevent); Process one run and return true if run has finished successfully,; return false in other cases (run aborted by user). void I",MatchSource.WIKI,root/html532/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMC.html
https://root.cern/root/html532/TVirtualMC.html:16584,Deployability,release,release,16584,"lMC(). Destructor. TVirtualMC * GetMC(); static: return virtual MC object. void SetStack(TVirtualMCStack* stack). Set particles stack. void SetExternalDecayer(TVirtualMCDecayer* decayer). Set external decayer. void SetRandom(TRandom* random). Set random number generator. void SetMagField(TVirtualMagField* field). Set magnetic field. Bool_t CurrentBoundaryNormal(Double_t& x, Double_t& y, Double_t& z) const; If track is on a geometry boundary, fill the normal vector of the crossing; volume surface and return true, return false otherwise. Bool_t GetMaterial(Int_t imat, TString& name, Double_t& a, Double_t& z, Double_t& density, Double_t& radl, Double_t& inter, TArrayD& par); Return the material parameters for the material specified by; the material Id. Bool_t IsRootGeometrySupported() const. methods for building/management of geometry. Info about supporting geometry defined via Root. { return kFALSE; }. void Gfmate(Int_t imat, char* name, Float_t& a, Float_t& z, Float_t& dens, Float_t& radl, Float_t& absl, Float_t* ubuf, Int_t& nbuf); make this function =0 with next release. functions from GCONS. Return parameters for material specified by material number imat; Deprecated - replaced with GetMaterial(). void Gckmat(Int_t imed, char* name); Return parameters for material specified by material number imat; (in double precision); Deprecated - replaced with GetMaterial(); Check the parameters of a tracking medium; Deprecated. void Material(Int_t& kmat, const char* name, Double_t a, Double_t z, Double_t dens, Double_t radl, Double_t absl, Float_t* buf, Int_t nwbuf); Define a material; kmat number assigned to the material; name material name; a atomic mass in au; z atomic number; dens density in g/cm3; absl absorption length in cm;; if >=0 it is ignored and the program; calculates it, if <0. -absl is taken; radl radiation length in cm; if >=0 it is ignored and the program; calculates it, if <0. -radl is taken; buf pointer to an array of user words; nwbuf number of user words. ",MatchSource.WIKI,root/html532/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMC.html
https://root.cern/root/html532/TVirtualMC.html:18897,Deployability,continuous,continuous,18897," given kind into the molecule of the compound.; In this case, wmat in output is changed to relative; weights. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Float_t* ubuf, Int_t nbuf); The same as previous but in double precision; Define a medium.; kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field:; - ifield = 0 if no magnetic field;; - ifield = -1 if user decision in guswim;; - ifield = 1 if tracking performed with g3rkuta;; - ifield = 2 if tracking performed with g3helix;; - ifield = 3 if tracking performed with g3helx3.; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm); ubuf pointer to an array of user words; nbuf number of user words. void Matrix(Int_t& krot, Double_t thetaX, Double_t phiX, Double_t thetaY, Double_t phiY, Double_t thetaZ, Double_t phiZ); The same as previous but in double precision; Define a rotation matrix; krot rotation matrix number assigned; thetaX polar angle for axis X; phiX azimuthal angle for axis X; thetaY polar angle for axis Y; phiY azimuthal angle for axis Y; thetaZ polar angle for axis Z; phiZ azimuthal angle for axis Z. Int_t Gsvolu(const char* name, const char* shape, Int_t nmed, Float_t* upar, Int_t np); Change the value of cut or mechanism param; to a new value parval for tracking medium itmed.; In Geant3, the data structure JTMED contains the standard tracking; parameters (CUTS and flags to control the physics processes) which; are used by default for all tracking media.; It is possible to redefine individually with this function any of these; parameters for a given tracking medium.; itmed tracking medium number; param is a char",MatchSource.WIKI,root/html532/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMC.html
https://root.cern/root/html532/TVirtualMC.html:2348,Energy Efficiency,charge,charge,2348,"TNamed::Copy(TObject& named) const; virtual Bool_tCurrentBoundaryNormal(Double_t& x, Double_t& y, Double_t& z) const; virtual Int_tCurrentEvent() const; virtual Int_tCurrentMaterial(Float_t& a, Float_t& z, Float_t& dens, Float_t& radl, Float_t& absl) const; virtual Int_tCurrentMedium() const; virtual Int_tCurrentVolID(Int_t& copyNo) const; virtual const char*CurrentVolName() const; virtual Int_tCurrentVolOffID(Int_t off, Int_t& copyNo) const; virtual const char*CurrentVolOffName(Int_t off) const; virtual const char*CurrentVolPath(); virtual Bool_tDefineIon(const char* name, Int_t Z, Int_t A, Int_t Q, Double_t excEnergy, Double_t mass = 0.); virtual voidDefineOpSurface(const char* name, EMCOpSurfaceModel model, EMCOpSurfaceType surfaceType, EMCOpSurfaceFinish surfaceFinish, Double_t sigmaAlpha); virtual Bool_tDefineParticle(Int_t pdg, const char* name, TMCParticleType mcType, Double_t mass, Double_t charge, Double_t lifetime); virtual Bool_tDefineParticle(Int_t pdg, const char* name, TMCParticleType mcType, Double_t mass, Double_t charge, Double_t lifetime, const TString& pType, Double_t width, Int_t iSpin, Int_t iParity, Int_t iConjugation, Int_t iIsospin, Int_t iIsospinZ, Int_t gParity, Int_t lepton, Int_t baryon, Bool_t stable, Bool_t shortlived = kFALSE, const TString& subType = """", Int_t antiEncoding = 0, Double_t magMoment = 0.0, Double_t excitation = 0.0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual Double_tEdep() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEtot() const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int",MatchSource.WIKI,root/html532/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMC.html
https://root.cern/root/html532/TVirtualMC.html:2482,Energy Efficiency,charge,charge,2482,"TNamed::Copy(TObject& named) const; virtual Bool_tCurrentBoundaryNormal(Double_t& x, Double_t& y, Double_t& z) const; virtual Int_tCurrentEvent() const; virtual Int_tCurrentMaterial(Float_t& a, Float_t& z, Float_t& dens, Float_t& radl, Float_t& absl) const; virtual Int_tCurrentMedium() const; virtual Int_tCurrentVolID(Int_t& copyNo) const; virtual const char*CurrentVolName() const; virtual Int_tCurrentVolOffID(Int_t off, Int_t& copyNo) const; virtual const char*CurrentVolOffName(Int_t off) const; virtual const char*CurrentVolPath(); virtual Bool_tDefineIon(const char* name, Int_t Z, Int_t A, Int_t Q, Double_t excEnergy, Double_t mass = 0.); virtual voidDefineOpSurface(const char* name, EMCOpSurfaceModel model, EMCOpSurfaceType surfaceType, EMCOpSurfaceFinish surfaceFinish, Double_t sigmaAlpha); virtual Bool_tDefineParticle(Int_t pdg, const char* name, TMCParticleType mcType, Double_t mass, Double_t charge, Double_t lifetime); virtual Bool_tDefineParticle(Int_t pdg, const char* name, TMCParticleType mcType, Double_t mass, Double_t charge, Double_t lifetime, const TString& pType, Double_t width, Int_t iSpin, Int_t iParity, Int_t iConjugation, Int_t iIsospin, Int_t iIsospinZ, Int_t gParity, Int_t lepton, Int_t baryon, Bool_t stable, Bool_t shortlived = kFALSE, const TString& subType = """", Int_t antiEncoding = 0, Double_t magMoment = 0.0, Double_t excitation = 0.0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual Double_tEdep() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEtot() const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int",MatchSource.WIKI,root/html532/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMC.html
https://root.cern/root/html532/TVirtualMC.html:18820,Energy Efficiency,energy,energy,18820,"ach basic material in the mixture. If nlmat < 0 then wmat contains the number of atoms; of a given kind into the molecule of the compound.; In this case, wmat in output is changed to relative; weights. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Float_t* ubuf, Int_t nbuf); The same as previous but in double precision; Define a medium.; kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field:; - ifield = 0 if no magnetic field;; - ifield = -1 if user decision in guswim;; - ifield = 1 if tracking performed with g3rkuta;; - ifield = 2 if tracking performed with g3helix;; - ifield = 3 if tracking performed with g3helx3.; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm); ubuf pointer to an array of user words; nbuf number of user words. void Matrix(Int_t& krot, Double_t thetaX, Double_t phiX, Double_t thetaY, Double_t phiY, Double_t thetaZ, Double_t phiZ); The same as previous but in double precision; Define a rotation matrix; krot rotation matrix number assigned; thetaX polar angle for axis X; phiX azimuthal angle for axis X; thetaY polar angle for axis Y; phiY azimuthal angle for axis Y; thetaZ polar angle for axis Z; phiZ azimuthal angle for axis Z. Int_t Gsvolu(const char* name, const char* shape, Int_t nmed, Float_t* upar, Int_t np); Change the value of cut or mechanism param; to a new value parval for tracking medium itmed.; In Geant3, the data structure JTMED contains the standard tracking; parameters (CUTS and flags to control the physics processes) which; are used by default for all tracking media.; It is possible to redefine individually with this function any of th",MatchSource.WIKI,root/html532/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMC.html
https://root.cern/root/html532/TVirtualMC.html:27826,Energy Efficiency,charge,charge,27826,"me identifier id. Int_t MediumId(const char* mediumName) const; Return the unique numeric identifier for medium name mediumName. Int_t NofVolumes() const; Return total number of volumes in the geometry. Int_t VolId2Mate(Int_t id) const; Return material number for a given volume id. Int_t NofVolDaughters(const char* volName) const; Return number of daughters of the volume specified by volName. const char* VolDaughterName(const char* volName, Int_t i) const; Return the name of i-th daughter of the volume specified by volName. Int_t VolDaughterCopyNo(const char* volName, Int_t i) const; Return the copyNo of i-th daughter of the volume specified by volName. Bool_t SetCut(const char* cutName, Double_t cutValue). methods for physics management. set methods. Set transport cuts for particles. Bool_t SetProcess(const char* flagName, Int_t flagValue); Set process control. Bool_t DefineParticle(Int_t pdg, const char* name, TMCParticleType mcType, Double_t mass, Double_t charge, Double_t lifetime); Set a user defined particle; Function is ignored if particle with specified pdg; already exists and error report is printed.; pdg PDG encoding; name particle name; mcType VMC Particle type; mass mass [GeV]; charge charge [eplus]; lifetime time of life [s]; pType particle type as in Geant4; width width [GeV]; iSpin spin; iParity parity; iConjugation conjugation; iIsospin isospin; iIsospinZ isospin - #rd component; gParity gParity; lepton lepton number; baryon baryon number; stable stability; shortlived is shorlived?; subType particle subType as in Geant4; antiEncoding anti encoding; magMoment magnetic moment; excitation excitation energy [GeV]. Bool_t DefineIon(const char* name, Int_t Z, Int_t A, Int_t Q, Double_t excEnergy, Double_t mass = 0.); Set a user defined particle; Function is ignored if particle with specified pdg; already exists and error report is printed.; pdg PDG encoding; name particle name; mcType VMC Particle type; mass mass [GeV]; charge charge [eplus]; lifetime time",MatchSource.WIKI,root/html532/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMC.html
https://root.cern/root/html532/TVirtualMC.html:28061,Energy Efficiency,charge,charge,28061,"lName. const char* VolDaughterName(const char* volName, Int_t i) const; Return the name of i-th daughter of the volume specified by volName. Int_t VolDaughterCopyNo(const char* volName, Int_t i) const; Return the copyNo of i-th daughter of the volume specified by volName. Bool_t SetCut(const char* cutName, Double_t cutValue). methods for physics management. set methods. Set transport cuts for particles. Bool_t SetProcess(const char* flagName, Int_t flagValue); Set process control. Bool_t DefineParticle(Int_t pdg, const char* name, TMCParticleType mcType, Double_t mass, Double_t charge, Double_t lifetime); Set a user defined particle; Function is ignored if particle with specified pdg; already exists and error report is printed.; pdg PDG encoding; name particle name; mcType VMC Particle type; mass mass [GeV]; charge charge [eplus]; lifetime time of life [s]; pType particle type as in Geant4; width width [GeV]; iSpin spin; iParity parity; iConjugation conjugation; iIsospin isospin; iIsospinZ isospin - #rd component; gParity gParity; lepton lepton number; baryon baryon number; stable stability; shortlived is shorlived?; subType particle subType as in Geant4; antiEncoding anti encoding; magMoment magnetic moment; excitation excitation energy [GeV]. Bool_t DefineIon(const char* name, Int_t Z, Int_t A, Int_t Q, Double_t excEnergy, Double_t mass = 0.); Set a user defined particle; Function is ignored if particle with specified pdg; already exists and error report is printed.; pdg PDG encoding; name particle name; mcType VMC Particle type; mass mass [GeV]; charge charge [eplus]; lifetime time of life [s]; pType particle type as in Geant4; width width [GeV]; iSpin spin; iParity parity; iConjugation conjugation; iIsospin isospin; iIsospinZ isospin - #rd component; gParity gParity; lepton lepton number; baryon baryon number; stable stability; shortlived is shorlived?; subType particle subType as in Geant4; antiEncoding anti encoding; magMoment magnetic moment; excitation excita",MatchSource.WIKI,root/html532/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMC.html
https://root.cern/root/html532/TVirtualMC.html:28068,Energy Efficiency,charge,charge,28068,"lName. const char* VolDaughterName(const char* volName, Int_t i) const; Return the name of i-th daughter of the volume specified by volName. Int_t VolDaughterCopyNo(const char* volName, Int_t i) const; Return the copyNo of i-th daughter of the volume specified by volName. Bool_t SetCut(const char* cutName, Double_t cutValue). methods for physics management. set methods. Set transport cuts for particles. Bool_t SetProcess(const char* flagName, Int_t flagValue); Set process control. Bool_t DefineParticle(Int_t pdg, const char* name, TMCParticleType mcType, Double_t mass, Double_t charge, Double_t lifetime); Set a user defined particle; Function is ignored if particle with specified pdg; already exists and error report is printed.; pdg PDG encoding; name particle name; mcType VMC Particle type; mass mass [GeV]; charge charge [eplus]; lifetime time of life [s]; pType particle type as in Geant4; width width [GeV]; iSpin spin; iParity parity; iConjugation conjugation; iIsospin isospin; iIsospinZ isospin - #rd component; gParity gParity; lepton lepton number; baryon baryon number; stable stability; shortlived is shorlived?; subType particle subType as in Geant4; antiEncoding anti encoding; magMoment magnetic moment; excitation excitation energy [GeV]. Bool_t DefineIon(const char* name, Int_t Z, Int_t A, Int_t Q, Double_t excEnergy, Double_t mass = 0.); Set a user defined particle; Function is ignored if particle with specified pdg; already exists and error report is printed.; pdg PDG encoding; name particle name; mcType VMC Particle type; mass mass [GeV]; charge charge [eplus]; lifetime time of life [s]; pType particle type as in Geant4; width width [GeV]; iSpin spin; iParity parity; iConjugation conjugation; iIsospin isospin; iIsospinZ isospin - #rd component; gParity gParity; lepton lepton number; baryon baryon number; stable stability; shortlived is shorlived?; subType particle subType as in Geant4; antiEncoding anti encoding; magMoment magnetic moment; excitation excita",MatchSource.WIKI,root/html532/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMC.html
https://root.cern/root/html532/TVirtualMC.html:28492,Energy Efficiency,energy,energy,28492,"lName. const char* VolDaughterName(const char* volName, Int_t i) const; Return the name of i-th daughter of the volume specified by volName. Int_t VolDaughterCopyNo(const char* volName, Int_t i) const; Return the copyNo of i-th daughter of the volume specified by volName. Bool_t SetCut(const char* cutName, Double_t cutValue). methods for physics management. set methods. Set transport cuts for particles. Bool_t SetProcess(const char* flagName, Int_t flagValue); Set process control. Bool_t DefineParticle(Int_t pdg, const char* name, TMCParticleType mcType, Double_t mass, Double_t charge, Double_t lifetime); Set a user defined particle; Function is ignored if particle with specified pdg; already exists and error report is printed.; pdg PDG encoding; name particle name; mcType VMC Particle type; mass mass [GeV]; charge charge [eplus]; lifetime time of life [s]; pType particle type as in Geant4; width width [GeV]; iSpin spin; iParity parity; iConjugation conjugation; iIsospin isospin; iIsospinZ isospin - #rd component; gParity gParity; lepton lepton number; baryon baryon number; stable stability; shortlived is shorlived?; subType particle subType as in Geant4; antiEncoding anti encoding; magMoment magnetic moment; excitation excitation energy [GeV]. Bool_t DefineIon(const char* name, Int_t Z, Int_t A, Int_t Q, Double_t excEnergy, Double_t mass = 0.); Set a user defined particle; Function is ignored if particle with specified pdg; already exists and error report is printed.; pdg PDG encoding; name particle name; mcType VMC Particle type; mass mass [GeV]; charge charge [eplus]; lifetime time of life [s]; pType particle type as in Geant4; width width [GeV]; iSpin spin; iParity parity; iConjugation conjugation; iIsospin isospin; iIsospinZ isospin - #rd component; gParity gParity; lepton lepton number; baryon baryon number; stable stability; shortlived is shorlived?; subType particle subType as in Geant4; antiEncoding anti encoding; magMoment magnetic moment; excitation excita",MatchSource.WIKI,root/html532/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMC.html
https://root.cern/root/html532/TVirtualMC.html:28816,Energy Efficiency,charge,charge,28816,"cle name; mcType VMC Particle type; mass mass [GeV]; charge charge [eplus]; lifetime time of life [s]; pType particle type as in Geant4; width width [GeV]; iSpin spin; iParity parity; iConjugation conjugation; iIsospin isospin; iIsospinZ isospin - #rd component; gParity gParity; lepton lepton number; baryon baryon number; stable stability; shortlived is shorlived?; subType particle subType as in Geant4; antiEncoding anti encoding; magMoment magnetic moment; excitation excitation energy [GeV]. Bool_t DefineIon(const char* name, Int_t Z, Int_t A, Int_t Q, Double_t excEnergy, Double_t mass = 0.); Set a user defined particle; Function is ignored if particle with specified pdg; already exists and error report is printed.; pdg PDG encoding; name particle name; mcType VMC Particle type; mass mass [GeV]; charge charge [eplus]; lifetime time of life [s]; pType particle type as in Geant4; width width [GeV]; iSpin spin; iParity parity; iConjugation conjugation; iIsospin isospin; iIsospinZ isospin - #rd component; gParity gParity; lepton lepton number; baryon baryon number; stable stability; shortlived is shorlived?; subType particle subType as in Geant4; antiEncoding anti encoding; magMoment magnetic moment; excitation excitation energy [GeV]; Set a user defined ion.; name ion name; Z atomic number; A atomic mass; Q charge [eplus}; excitation excitation energy [GeV]; mass mass [GeV] (if not specified by user, approximative; mass is calculated). Double_t Xsec(char* , Double_t , Int_t , Int_t ); Set a user phase space decay for a particle; pdg particle PDG encoding; bratios the array with branching ratios (in %); mode[6][3] the array with daughters particles PDG codes for each; decay channel; Calculate X-sections; (Geant3 only); Deprecated. Int_t IdFromPDG(Int_t pdg) const. particle table usage. Return MC specific code from a PDG and pseudo ENDF code (pdg). Int_t PDGFromId(Int_t id) const; Return PDG code and pseudo ENDF code from MC specific code (id). TString ParticleName(Int_t",MatchSource.WIKI,root/html532/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMC.html
https://root.cern/root/html532/TVirtualMC.html:28823,Energy Efficiency,charge,charge,28823,"cle name; mcType VMC Particle type; mass mass [GeV]; charge charge [eplus]; lifetime time of life [s]; pType particle type as in Geant4; width width [GeV]; iSpin spin; iParity parity; iConjugation conjugation; iIsospin isospin; iIsospinZ isospin - #rd component; gParity gParity; lepton lepton number; baryon baryon number; stable stability; shortlived is shorlived?; subType particle subType as in Geant4; antiEncoding anti encoding; magMoment magnetic moment; excitation excitation energy [GeV]. Bool_t DefineIon(const char* name, Int_t Z, Int_t A, Int_t Q, Double_t excEnergy, Double_t mass = 0.); Set a user defined particle; Function is ignored if particle with specified pdg; already exists and error report is printed.; pdg PDG encoding; name particle name; mcType VMC Particle type; mass mass [GeV]; charge charge [eplus]; lifetime time of life [s]; pType particle type as in Geant4; width width [GeV]; iSpin spin; iParity parity; iConjugation conjugation; iIsospin isospin; iIsospinZ isospin - #rd component; gParity gParity; lepton lepton number; baryon baryon number; stable stability; shortlived is shorlived?; subType particle subType as in Geant4; antiEncoding anti encoding; magMoment magnetic moment; excitation excitation energy [GeV]; Set a user defined ion.; name ion name; Z atomic number; A atomic mass; Q charge [eplus}; excitation excitation energy [GeV]; mass mass [GeV] (if not specified by user, approximative; mass is calculated). Double_t Xsec(char* , Double_t , Int_t , Int_t ); Set a user phase space decay for a particle; pdg particle PDG encoding; bratios the array with branching ratios (in %); mode[6][3] the array with daughters particles PDG codes for each; decay channel; Calculate X-sections; (Geant3 only); Deprecated. Int_t IdFromPDG(Int_t pdg) const. particle table usage. Return MC specific code from a PDG and pseudo ENDF code (pdg). Int_t PDGFromId(Int_t id) const; Return PDG code and pseudo ENDF code from MC specific code (id). TString ParticleName(Int_t",MatchSource.WIKI,root/html532/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMC.html
https://root.cern/root/html532/TVirtualMC.html:29247,Energy Efficiency,energy,energy,29247,"cle name; mcType VMC Particle type; mass mass [GeV]; charge charge [eplus]; lifetime time of life [s]; pType particle type as in Geant4; width width [GeV]; iSpin spin; iParity parity; iConjugation conjugation; iIsospin isospin; iIsospinZ isospin - #rd component; gParity gParity; lepton lepton number; baryon baryon number; stable stability; shortlived is shorlived?; subType particle subType as in Geant4; antiEncoding anti encoding; magMoment magnetic moment; excitation excitation energy [GeV]. Bool_t DefineIon(const char* name, Int_t Z, Int_t A, Int_t Q, Double_t excEnergy, Double_t mass = 0.); Set a user defined particle; Function is ignored if particle with specified pdg; already exists and error report is printed.; pdg PDG encoding; name particle name; mcType VMC Particle type; mass mass [GeV]; charge charge [eplus]; lifetime time of life [s]; pType particle type as in Geant4; width width [GeV]; iSpin spin; iParity parity; iConjugation conjugation; iIsospin isospin; iIsospinZ isospin - #rd component; gParity gParity; lepton lepton number; baryon baryon number; stable stability; shortlived is shorlived?; subType particle subType as in Geant4; antiEncoding anti encoding; magMoment magnetic moment; excitation excitation energy [GeV]; Set a user defined ion.; name ion name; Z atomic number; A atomic mass; Q charge [eplus}; excitation excitation energy [GeV]; mass mass [GeV] (if not specified by user, approximative; mass is calculated). Double_t Xsec(char* , Double_t , Int_t , Int_t ); Set a user phase space decay for a particle; pdg particle PDG encoding; bratios the array with branching ratios (in %); mode[6][3] the array with daughters particles PDG codes for each; decay channel; Calculate X-sections; (Geant3 only); Deprecated. Int_t IdFromPDG(Int_t pdg) const. particle table usage. Return MC specific code from a PDG and pseudo ENDF code (pdg). Int_t PDGFromId(Int_t id) const; Return PDG code and pseudo ENDF code from MC specific code (id). TString ParticleName(Int_t",MatchSource.WIKI,root/html532/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMC.html
https://root.cern/root/html532/TVirtualMC.html:29335,Energy Efficiency,charge,charge,29335,"; subType particle subType as in Geant4; antiEncoding anti encoding; magMoment magnetic moment; excitation excitation energy [GeV]. Bool_t DefineIon(const char* name, Int_t Z, Int_t A, Int_t Q, Double_t excEnergy, Double_t mass = 0.); Set a user defined particle; Function is ignored if particle with specified pdg; already exists and error report is printed.; pdg PDG encoding; name particle name; mcType VMC Particle type; mass mass [GeV]; charge charge [eplus]; lifetime time of life [s]; pType particle type as in Geant4; width width [GeV]; iSpin spin; iParity parity; iConjugation conjugation; iIsospin isospin; iIsospinZ isospin - #rd component; gParity gParity; lepton lepton number; baryon baryon number; stable stability; shortlived is shorlived?; subType particle subType as in Geant4; antiEncoding anti encoding; magMoment magnetic moment; excitation excitation energy [GeV]; Set a user defined ion.; name ion name; Z atomic number; A atomic mass; Q charge [eplus}; excitation excitation energy [GeV]; mass mass [GeV] (if not specified by user, approximative; mass is calculated). Double_t Xsec(char* , Double_t , Int_t , Int_t ); Set a user phase space decay for a particle; pdg particle PDG encoding; bratios the array with branching ratios (in %); mode[6][3] the array with daughters particles PDG codes for each; decay channel; Calculate X-sections; (Geant3 only); Deprecated. Int_t IdFromPDG(Int_t pdg) const. particle table usage. Return MC specific code from a PDG and pseudo ENDF code (pdg). Int_t PDGFromId(Int_t id) const; Return PDG code and pseudo ENDF code from MC specific code (id). TString ParticleName(Int_t pdg) const. get methods. Return name of the particle specified by pdg. Double_t ParticleMass(Int_t pdg) const; Return mass of the particle specified by pdg. Double_t ParticleCharge(Int_t pdg) const; Return charge (in e units) of the particle specified by pdg. Double_t ParticleLifeTime(Int_t pdg) const; Return life time of the particle specified by pdg. TMCParticl",MatchSource.WIKI,root/html532/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMC.html
https://root.cern/root/html532/TVirtualMC.html:29373,Energy Efficiency,energy,energy,29373,"; subType particle subType as in Geant4; antiEncoding anti encoding; magMoment magnetic moment; excitation excitation energy [GeV]. Bool_t DefineIon(const char* name, Int_t Z, Int_t A, Int_t Q, Double_t excEnergy, Double_t mass = 0.); Set a user defined particle; Function is ignored if particle with specified pdg; already exists and error report is printed.; pdg PDG encoding; name particle name; mcType VMC Particle type; mass mass [GeV]; charge charge [eplus]; lifetime time of life [s]; pType particle type as in Geant4; width width [GeV]; iSpin spin; iParity parity; iConjugation conjugation; iIsospin isospin; iIsospinZ isospin - #rd component; gParity gParity; lepton lepton number; baryon baryon number; stable stability; shortlived is shorlived?; subType particle subType as in Geant4; antiEncoding anti encoding; magMoment magnetic moment; excitation excitation energy [GeV]; Set a user defined ion.; name ion name; Z atomic number; A atomic mass; Q charge [eplus}; excitation excitation energy [GeV]; mass mass [GeV] (if not specified by user, approximative; mass is calculated). Double_t Xsec(char* , Double_t , Int_t , Int_t ); Set a user phase space decay for a particle; pdg particle PDG encoding; bratios the array with branching ratios (in %); mode[6][3] the array with daughters particles PDG codes for each; decay channel; Calculate X-sections; (Geant3 only); Deprecated. Int_t IdFromPDG(Int_t pdg) const. particle table usage. Return MC specific code from a PDG and pseudo ENDF code (pdg). Int_t PDGFromId(Int_t id) const; Return PDG code and pseudo ENDF code from MC specific code (id). TString ParticleName(Int_t pdg) const. get methods. Return name of the particle specified by pdg. Double_t ParticleMass(Int_t pdg) const; Return mass of the particle specified by pdg. Double_t ParticleCharge(Int_t pdg) const; Return charge (in e units) of the particle specified by pdg. Double_t ParticleLifeTime(Int_t pdg) const; Return life time of the particle specified by pdg. TMCParticl",MatchSource.WIKI,root/html532/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMC.html
https://root.cern/root/html532/TVirtualMC.html:30216,Energy Efficiency,charge,charge,30216,"moment; excitation excitation energy [GeV]; Set a user defined ion.; name ion name; Z atomic number; A atomic mass; Q charge [eplus}; excitation excitation energy [GeV]; mass mass [GeV] (if not specified by user, approximative; mass is calculated). Double_t Xsec(char* , Double_t , Int_t , Int_t ); Set a user phase space decay for a particle; pdg particle PDG encoding; bratios the array with branching ratios (in %); mode[6][3] the array with daughters particles PDG codes for each; decay channel; Calculate X-sections; (Geant3 only); Deprecated. Int_t IdFromPDG(Int_t pdg) const. particle table usage. Return MC specific code from a PDG and pseudo ENDF code (pdg). Int_t PDGFromId(Int_t id) const; Return PDG code and pseudo ENDF code from MC specific code (id). TString ParticleName(Int_t pdg) const. get methods. Return name of the particle specified by pdg. Double_t ParticleMass(Int_t pdg) const; Return mass of the particle specified by pdg. Double_t ParticleCharge(Int_t pdg) const; Return charge (in e units) of the particle specified by pdg. Double_t ParticleLifeTime(Int_t pdg) const; Return life time of the particle specified by pdg. TMCParticleType ParticleMCType(Int_t pdg) const; Return VMC type of the particle specified by pdg. void StopTrack(). methods for step management. action methods. Stop the transport of the current particle and skip to the next. void StopEvent(); Stop simulation of the current event and skip to the next. void StopRun(); Stop simulation of the current event and set the abort run flag to true. void SetMaxStep(Double_t ). set methods. Set the maximum step allowed till the particle is in the current medium. void SetMaxNStep(Int_t ); Set the maximum number of steps till the particle is in the current medium. void SetUserDecay(Int_t pdg); Force the decays of particles to be done with Pythia; and not with the Geant routines. void ForceDecayTime(Float_t ); Force the decay time of the current particle. Int_t CurrentVolID(Int_t& copyNo) const. tracking ",MatchSource.WIKI,root/html532/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMC.html
https://root.cern/root/html532/TVirtualMC.html:34083,Energy Efficiency,energy,energy,34083,"d in the current medium. void TrackPosition(TLorentzVector& position) const. get methods; tracking particle; dynamic properties. Return the current position in the master reference frame of the; track being transported. void TrackPosition(Double_t& x, Double_t& y, Double_t& z) const; Return the current position in the master reference frame of the; track being transported. void TrackMomentum(TLorentzVector& momentum) const; Return the direction and the momentum (GeV/c) of the track; currently being transported. void TrackMomentum(Double_t& px, Double_t& py, Double_t& pz, Double_t& etot) const; Return the direction and the momentum (GeV/c) of the track; currently being transported. Double_t TrackStep() const; Return the length in centimeters of the current step (in cm). Double_t TrackLength() const; Return the length of the current track from its origin (in cm). Double_t TrackTime() const; Return the current time of flight of the track being transported. Double_t Edep() const; Return the energy lost in the current step. Int_t TrackPid() const. get methods; tracking particle; static properties. Return the PDG of the particle transported. Double_t TrackCharge() const; Return the charge of the track currently transported. Double_t TrackMass() const; Return the mass of the track currently transported. Double_t Etot() const; Return the total energy of the current track. Bool_t IsNewTrack() const. get methods - track status. Return true when the track performs the first step. Bool_t IsTrackInside() const; Return true if the track is not at the boundary of the current volume. Bool_t IsTrackEntering() const; Return true if this is the first step of the track in the current volume. Bool_t IsTrackExiting() const; Return true if this is the last step of the track in the current volume. Bool_t IsTrackOut() const; Return true if the track is out of the setup. Bool_t IsTrackDisappeared() const; Return true if the current particle has disappeared; either because it decayed or becaus",MatchSource.WIKI,root/html532/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMC.html
https://root.cern/root/html532/TVirtualMC.html:34276,Energy Efficiency,charge,charge,34276,"track being transported. void TrackPosition(Double_t& x, Double_t& y, Double_t& z) const; Return the current position in the master reference frame of the; track being transported. void TrackMomentum(TLorentzVector& momentum) const; Return the direction and the momentum (GeV/c) of the track; currently being transported. void TrackMomentum(Double_t& px, Double_t& py, Double_t& pz, Double_t& etot) const; Return the direction and the momentum (GeV/c) of the track; currently being transported. Double_t TrackStep() const; Return the length in centimeters of the current step (in cm). Double_t TrackLength() const; Return the length of the current track from its origin (in cm). Double_t TrackTime() const; Return the current time of flight of the track being transported. Double_t Edep() const; Return the energy lost in the current step. Int_t TrackPid() const. get methods; tracking particle; static properties. Return the PDG of the particle transported. Double_t TrackCharge() const; Return the charge of the track currently transported. Double_t TrackMass() const; Return the mass of the track currently transported. Double_t Etot() const; Return the total energy of the current track. Bool_t IsNewTrack() const. get methods - track status. Return true when the track performs the first step. Bool_t IsTrackInside() const; Return true if the track is not at the boundary of the current volume. Bool_t IsTrackEntering() const; Return true if this is the first step of the track in the current volume. Bool_t IsTrackExiting() const; Return true if this is the last step of the track in the current volume. Bool_t IsTrackOut() const; Return true if the track is out of the setup. Bool_t IsTrackDisappeared() const; Return true if the current particle has disappeared; either because it decayed or because it underwent; an inelastic collision. Bool_t IsTrackStop() const; Return true if the track energy has fallen below the threshold. Bool_t IsTrackAlive() const; Return true if the current partic",MatchSource.WIKI,root/html532/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMC.html
https://root.cern/root/html532/TVirtualMC.html:34439,Energy Efficiency,energy,energy,34439,"track being transported. void TrackMomentum(TLorentzVector& momentum) const; Return the direction and the momentum (GeV/c) of the track; currently being transported. void TrackMomentum(Double_t& px, Double_t& py, Double_t& pz, Double_t& etot) const; Return the direction and the momentum (GeV/c) of the track; currently being transported. Double_t TrackStep() const; Return the length in centimeters of the current step (in cm). Double_t TrackLength() const; Return the length of the current track from its origin (in cm). Double_t TrackTime() const; Return the current time of flight of the track being transported. Double_t Edep() const; Return the energy lost in the current step. Int_t TrackPid() const. get methods; tracking particle; static properties. Return the PDG of the particle transported. Double_t TrackCharge() const; Return the charge of the track currently transported. Double_t TrackMass() const; Return the mass of the track currently transported. Double_t Etot() const; Return the total energy of the current track. Bool_t IsNewTrack() const. get methods - track status. Return true when the track performs the first step. Bool_t IsTrackInside() const; Return true if the track is not at the boundary of the current volume. Bool_t IsTrackEntering() const; Return true if this is the first step of the track in the current volume. Bool_t IsTrackExiting() const; Return true if this is the last step of the track in the current volume. Bool_t IsTrackOut() const; Return true if the track is out of the setup. Bool_t IsTrackDisappeared() const; Return true if the current particle has disappeared; either because it decayed or because it underwent; an inelastic collision. Bool_t IsTrackStop() const; Return true if the track energy has fallen below the threshold. Bool_t IsTrackAlive() const; Return true if the current particle is alive and will continue to be; transported. Int_t NSecondaries() const. get methods - secondaries. Return the number of secondary particles generated i",MatchSource.WIKI,root/html532/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMC.html
https://root.cern/root/html532/TVirtualMC.html:35175,Energy Efficiency,energy,energy,35175,"cle; static properties. Return the PDG of the particle transported. Double_t TrackCharge() const; Return the charge of the track currently transported. Double_t TrackMass() const; Return the mass of the track currently transported. Double_t Etot() const; Return the total energy of the current track. Bool_t IsNewTrack() const. get methods - track status. Return true when the track performs the first step. Bool_t IsTrackInside() const; Return true if the track is not at the boundary of the current volume. Bool_t IsTrackEntering() const; Return true if this is the first step of the track in the current volume. Bool_t IsTrackExiting() const; Return true if this is the last step of the track in the current volume. Bool_t IsTrackOut() const; Return true if the track is out of the setup. Bool_t IsTrackDisappeared() const; Return true if the current particle has disappeared; either because it decayed or because it underwent; an inelastic collision. Bool_t IsTrackStop() const; Return true if the track energy has fallen below the threshold. Bool_t IsTrackAlive() const; Return true if the current particle is alive and will continue to be; transported. Int_t NSecondaries() const. get methods - secondaries. Return the number of secondary particles generated in the current step. void GetSecondary(Int_t isec, Int_t& particleId, TLorentzVector& position, TLorentzVector& momentum); Return the parameters of the secondary track number isec produced; in the current step. Int_t StepProcesses(TArrayI& proc) const; Return the VMC code of the process that has produced the secondary; particles in the current step; Return the array of the VMC code of the processes active in the current; step. Bool_t SecondariesAreOrdered() const; Return the information about the transport order needed by the stack. void Init(). Control methods. Initialize MC. void BuildPhysics(); Initialize MC physics. void ProcessEvent(); Process one event; Deprecated. Bool_t ProcessRun(Int_t nevent); Process one run and re",MatchSource.WIKI,root/html532/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMC.html
https://root.cern/root/html532/TVirtualMC.html:325,Integrability,interface,interface,325,". TVirtualMC. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » VMC; » TVirtualMC. class TVirtualMC: public TNamed. Virtual MC provides a virtual interface to Monte Carlo.; It enables the user to build a virtual Monte Carlo application; independent of any actual underlying Monte Carlo implementation itself. A user will have to implement a class derived from the abstract; Monte Carlo application class, and provide functions like; ConstructGeometry(), BeginEvent(), FinishEvent(), ... .; The concrete Monte Carlo (Geant3, Geant4) is selected at run time -; when processing a ROOT macro where the concrete Monte Carlo is instantiated. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualMC(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidBuildPhysics(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCurrentBoundaryNormal(Double_t& x, Double_t& y, Double_t& z) const; virtual Int_tCurrentEvent() const; virtual Int_tCurrentMaterial(Float_t& a, Float_t& z, Float_t& dens, Float_t& radl, Float_t& absl) const; virtual Int_tCurrentMedium() const; virtual Int_tCurrentVolID(Int_t& copyNo) const; virtual const char*CurrentVolName() const; virtual Int_tCurrentVolOffID(Int_t off, Int_t& copyNo) const; virtual const char*CurrentVolOffName(Int_t off) const; virtual const char*CurrentVolPath(); virtual Bool_tDefineIon(co",MatchSource.WIKI,root/html532/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMC.html
https://root.cern/root/html532/TVirtualMC.html:31081,Integrability,rout,routines,31081,"ds. Return name of the particle specified by pdg. Double_t ParticleMass(Int_t pdg) const; Return mass of the particle specified by pdg. Double_t ParticleCharge(Int_t pdg) const; Return charge (in e units) of the particle specified by pdg. Double_t ParticleLifeTime(Int_t pdg) const; Return life time of the particle specified by pdg. TMCParticleType ParticleMCType(Int_t pdg) const; Return VMC type of the particle specified by pdg. void StopTrack(). methods for step management. action methods. Stop the transport of the current particle and skip to the next. void StopEvent(); Stop simulation of the current event and skip to the next. void StopRun(); Stop simulation of the current event and set the abort run flag to true. void SetMaxStep(Double_t ). set methods. Set the maximum step allowed till the particle is in the current medium. void SetMaxNStep(Int_t ); Set the maximum number of steps till the particle is in the current medium. void SetUserDecay(Int_t pdg); Force the decays of particles to be done with Pythia; and not with the Geant routines. void ForceDecayTime(Float_t ); Force the decay time of the current particle. Int_t CurrentVolID(Int_t& copyNo) const. tracking volume(s). Return the current volume ID and copy number. Int_t CurrentVolOffID(Int_t off, Int_t& copyNo) const; Return the current volume off upward in the geometrical tree; ID and copy number. const char* CurrentVolName() const; Return the current volume name. const char* CurrentVolOffName(Int_t off) const; Return the current volume off upward in the geometrical tree; name and copy number'; if name=0 no name is returned. const char* CurrentVolPath(); Return the path in geometry tree for the current volume. Int_t CurrentMaterial(Float_t& a, Float_t& z, Float_t& dens, Float_t& radl, Float_t& absl) const; Return the parameters of the current material during transport. Int_t CurrentEvent() const; Return the number of the current medium; new function (to replace GetMedium() const); Return the number of the ",MatchSource.WIKI,root/html532/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMC.html
https://root.cern/root/html532/TVirtualMC.html:7347,Modifiability,Inherit,InheritsFrom,7347,"tual voidGsord(const char* name, Int_t iax); virtual voidGspos(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, const char* konly = ""ONLY""); virtual voidGsposp(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, const char* konly, Float_t* upar, Int_t np); virtual voidGsposp(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, const char* konly, Double_t* upar, Int_t np); virtual voidGstpar(Int_t itmed, const char* param, Double_t parval); virtual Int_tGsvolu(const char* name, const char* shape, Int_t nmed, Float_t* upar, Int_t np); virtual Int_tGsvolu(const char* name, const char* shape, Int_t nmed, Double_t* upar, Int_t np); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual Int_tIdFromPDG(Int_t pdg) const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidInit(); virtual voidInitLego(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tIsCollectTracks() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tIsNewTrack() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsRootGeometrySupported() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tIsTrackAlive() const; virtual Bool_tIsTrackDisappeared() const; virtual Bool_tIsTrackEntering() const; virtual Bool_tIsTrackExiting() const; virtual Bool_tIsTrackInside() const; virtual Bool_tIsTrackOut() const; virtual Bool_tIsTrackStop() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; virtual voidMaterial(Int_t& kmat, const char* name, Double_t a, Double_t z, Double_t dens, Double_t radl, Double_",MatchSource.WIKI,root/html532/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMC.html
https://root.cern/root/html532/TVirtualMC.html:7413,Modifiability,Inherit,InheritsFrom,7413,"st char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, const char* konly = ""ONLY""); virtual voidGsposp(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, const char* konly, Float_t* upar, Int_t np); virtual voidGsposp(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, const char* konly, Double_t* upar, Int_t np); virtual voidGstpar(Int_t itmed, const char* param, Double_t parval); virtual Int_tGsvolu(const char* name, const char* shape, Int_t nmed, Float_t* upar, Int_t np); virtual Int_tGsvolu(const char* name, const char* shape, Int_t nmed, Double_t* upar, Int_t np); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual Int_tIdFromPDG(Int_t pdg) const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidInit(); virtual voidInitLego(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tIsCollectTracks() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tIsNewTrack() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsRootGeometrySupported() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tIsTrackAlive() const; virtual Bool_tIsTrackDisappeared() const; virtual Bool_tIsTrackEntering() const; virtual Bool_tIsTrackExiting() const; virtual Bool_tIsTrackInside() const; virtual Bool_tIsTrackOut() const; virtual Bool_tIsTrackStop() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; virtual voidMaterial(Int_t& kmat, const char* name, Double_t a, Double_t z, Double_t dens, Double_t radl, Double_t absl, Float_t* buf, Int_t nwbuf); virtual voidMaterial(Int_t& km",MatchSource.WIKI,root/html532/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMC.html
https://root.cern/root/html532/TVirtualMC.html:15419,Modifiability,Inherit,Inheritance,15419," char* filnam, const char* topvol, Int_t number, Int_t nlevel); virtual Double_tXsec(char*, Double_t, Int_t, Int_t). protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TVirtualMC&operator=(const TVirtualMC&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TVirtualMCApplication*fApplication! User MC application; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TVirtualMCDecayer*fDecayer! External decayer; TVirtualMagField*fMagField! Magnetic field; TRandom*fRandom! Random number generator; TVirtualMCStack*fStack! Particles stack; static TVirtualMC*fgMCMonte Carlo singleton instance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TVirtualMC(). Destructor. TVirtualMC * GetMC(); static: return virtual MC object. void SetStack(TVirtualMCStack* stack). Set particles stack. void SetExternalDecayer(TVirtualMCDecayer* decayer). Set external decayer. void SetRandom(TRandom* random). Set random number generator. void SetMagField(TVirtualMagField* field). Set magnetic field. Bool_t CurrentBoundaryNormal(Double_t& x, Double_t& y, Double_t& z) const; If track is on a geometry boundary, fill the normal vector of the crossing; volume surface and return true, return false otherwise. Bool_t GetMaterial(Int_t imat, TString& name, Double_t& a, Double_t& z, Double_t& density, Double_t& radl, Double_t& inter, TArrayD& par); Return the material parameters for the material specified by; the material Id. Bool_t IsRootGeometrySupported() const. methods for building/management of geometry. Info about supporting geometry defined via Root. { return kFALSE; }. void Gfmate(Int_t imat, cha",MatchSource.WIKI,root/html532/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMC.html
https://root.cern/root/html532/TVirtualMC.html:15432,Modifiability,Inherit,Inherited,15432," char* filnam, const char* topvol, Int_t number, Int_t nlevel); virtual Double_tXsec(char*, Double_t, Int_t, Int_t). protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TVirtualMC&operator=(const TVirtualMC&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TVirtualMCApplication*fApplication! User MC application; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TVirtualMCDecayer*fDecayer! External decayer; TVirtualMagField*fMagField! Magnetic field; TRandom*fRandom! Random number generator; TVirtualMCStack*fStack! Particles stack; static TVirtualMC*fgMCMonte Carlo singleton instance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TVirtualMC(). Destructor. TVirtualMC * GetMC(); static: return virtual MC object. void SetStack(TVirtualMCStack* stack). Set particles stack. void SetExternalDecayer(TVirtualMCDecayer* decayer). Set external decayer. void SetRandom(TRandom* random). Set random number generator. void SetMagField(TVirtualMagField* field). Set magnetic field. Bool_t CurrentBoundaryNormal(Double_t& x, Double_t& y, Double_t& z) const; If track is on a geometry boundary, fill the normal vector of the crossing; volume surface and return true, return false otherwise. Bool_t GetMaterial(Int_t imat, TString& name, Double_t& a, Double_t& z, Double_t& density, Double_t& radl, Double_t& inter, TArrayD& par); Return the material parameters for the material specified by; the material Id. Bool_t IsRootGeometrySupported() const. methods for building/management of geometry. Info about supporting geometry defined via Root. { return kFALSE; }. void Gfmate(Int_t imat, cha",MatchSource.WIKI,root/html532/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMC.html
https://root.cern/root/html532/TVirtualMC.html:19951,Modifiability,variab,variable,19951,"of user words; nbuf number of user words. void Matrix(Int_t& krot, Double_t thetaX, Double_t phiX, Double_t thetaY, Double_t phiY, Double_t thetaZ, Double_t phiZ); The same as previous but in double precision; Define a rotation matrix; krot rotation matrix number assigned; thetaX polar angle for axis X; phiX azimuthal angle for axis X; thetaY polar angle for axis Y; phiY azimuthal angle for axis Y; thetaZ polar angle for axis Z; phiZ azimuthal angle for axis Z. Int_t Gsvolu(const char* name, const char* shape, Int_t nmed, Float_t* upar, Int_t np); Change the value of cut or mechanism param; to a new value parval for tracking medium itmed.; In Geant3, the data structure JTMED contains the standard tracking; parameters (CUTS and flags to control the physics processes) which; are used by default for all tracking media.; It is possible to redefine individually with this function any of these; parameters for a given tracking medium.; itmed tracking medium number; param is a character string (variable name); parval must be given as a floating point. functions from GGEOM. Create a new volume; name Volume name; shape Volume type; nmed Tracking medium number; np Number of shape parameters; upar Vector containing shape parameters. void Gsdvn(const char* name, const char* mother, Int_t ndiv, Int_t iaxis); The same as previous but in double precision; Create a new volume by dividing an existing one.; It divides a previously defined volume; name Volume name; mother Mother volume name; ndiv Number of divisions; iaxis Axis value:; X,Y,Z of CAXIS will be translated to 1,2,3 for IAXIS. void Gsdvt(const char* name, const char* mother, Double_t step, Int_t iaxis, Int_t numed, Int_t ndvmx); Create a new volume by dividing an existing one.; Divide mother into ndiv divisions called name; along axis iaxis starting at coordinate value c0i.; The new volume created will be medium number numed.; Create a new volume by dividing an existing one; Divide mother into divisions called name along; a",MatchSource.WIKI,root/html532/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMC.html
https://root.cern/root/html532/TVirtualMC.html:18565,Performance,perform,performed,18565,". void Mixture(Int_t& kmat, const char* name, Float_t* a, Float_t* z, Double_t dens, Int_t nlmat, Float_t* wmat); The same as previous but in double precision; Define mixture or compound; with a number kmat composed by the basic nlmat materials defined; by arrays a, z and wmat. If nlmat > 0 then wmat contains the proportion by; weights of each basic material in the mixture. If nlmat < 0 then wmat contains the number of atoms; of a given kind into the molecule of the compound.; In this case, wmat in output is changed to relative; weights. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Float_t* ubuf, Int_t nbuf); The same as previous but in double precision; Define a medium.; kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field:; - ifield = 0 if no magnetic field;; - ifield = -1 if user decision in guswim;; - ifield = 1 if tracking performed with g3rkuta;; - ifield = 2 if tracking performed with g3helix;; - ifield = 3 if tracking performed with g3helx3.; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm); ubuf pointer to an array of user words; nbuf number of user words. void Matrix(Int_t& krot, Double_t thetaX, Double_t phiX, Double_t thetaY, Double_t phiY, Double_t thetaZ, Double_t phiZ); The same as previous but in double precision; Define a rotation matrix; krot rotation matrix number assigned; thetaX polar angle for axis X; phiX azimuthal angle for axis X; thetaY polar angle for axis Y; phiY azimuthal angle for axis Y; thetaZ polar angle for axis Z; phiZ azimuthal angle for axis Z. Int_t Gsvolu(const char* name, const char* shape, Int_t nmed, Float_t* upar, Int_t np); C",MatchSource.WIKI,root/html532/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMC.html
https://root.cern/root/html532/TVirtualMC.html:18615,Performance,perform,performed,18615,". void Mixture(Int_t& kmat, const char* name, Float_t* a, Float_t* z, Double_t dens, Int_t nlmat, Float_t* wmat); The same as previous but in double precision; Define mixture or compound; with a number kmat composed by the basic nlmat materials defined; by arrays a, z and wmat. If nlmat > 0 then wmat contains the proportion by; weights of each basic material in the mixture. If nlmat < 0 then wmat contains the number of atoms; of a given kind into the molecule of the compound.; In this case, wmat in output is changed to relative; weights. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Float_t* ubuf, Int_t nbuf); The same as previous but in double precision; Define a medium.; kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field:; - ifield = 0 if no magnetic field;; - ifield = -1 if user decision in guswim;; - ifield = 1 if tracking performed with g3rkuta;; - ifield = 2 if tracking performed with g3helix;; - ifield = 3 if tracking performed with g3helx3.; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm); ubuf pointer to an array of user words; nbuf number of user words. void Matrix(Int_t& krot, Double_t thetaX, Double_t phiX, Double_t thetaY, Double_t phiY, Double_t thetaZ, Double_t phiZ); The same as previous but in double precision; Define a rotation matrix; krot rotation matrix number assigned; thetaX polar angle for axis X; phiX azimuthal angle for axis X; thetaY polar angle for axis Y; phiY azimuthal angle for axis Y; thetaZ polar angle for axis Z; phiZ azimuthal angle for axis Z. Int_t Gsvolu(const char* name, const char* shape, Int_t nmed, Float_t* upar, Int_t np); C",MatchSource.WIKI,root/html532/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMC.html
https://root.cern/root/html532/TVirtualMC.html:18665,Performance,perform,performed,18665,". void Mixture(Int_t& kmat, const char* name, Float_t* a, Float_t* z, Double_t dens, Int_t nlmat, Float_t* wmat); The same as previous but in double precision; Define mixture or compound; with a number kmat composed by the basic nlmat materials defined; by arrays a, z and wmat. If nlmat > 0 then wmat contains the proportion by; weights of each basic material in the mixture. If nlmat < 0 then wmat contains the number of atoms; of a given kind into the molecule of the compound.; In this case, wmat in output is changed to relative; weights. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Float_t* ubuf, Int_t nbuf); The same as previous but in double precision; Define a medium.; kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field:; - ifield = 0 if no magnetic field;; - ifield = -1 if user decision in guswim;; - ifield = 1 if tracking performed with g3rkuta;; - ifield = 2 if tracking performed with g3helix;; - ifield = 3 if tracking performed with g3helx3.; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm); ubuf pointer to an array of user words; nbuf number of user words. void Matrix(Int_t& krot, Double_t thetaX, Double_t phiX, Double_t thetaY, Double_t phiY, Double_t thetaZ, Double_t phiZ); The same as previous but in double precision; Define a rotation matrix; krot rotation matrix number assigned; thetaX polar angle for axis X; phiX azimuthal angle for axis X; thetaY polar angle for axis Y; phiY azimuthal angle for axis Y; thetaZ polar angle for axis Z; phiZ azimuthal angle for axis Z. Int_t Gsvolu(const char* name, const char* shape, Int_t nmed, Float_t* upar, Int_t np); C",MatchSource.WIKI,root/html532/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMC.html
https://root.cern/root/html532/TVirtualMC.html:21249,Performance,perform,performed,21249,", const char* mother, Int_t ndiv, Int_t iaxis); The same as previous but in double precision; Create a new volume by dividing an existing one.; It divides a previously defined volume; name Volume name; mother Mother volume name; ndiv Number of divisions; iaxis Axis value:; X,Y,Z of CAXIS will be translated to 1,2,3 for IAXIS. void Gsdvt(const char* name, const char* mother, Double_t step, Int_t iaxis, Int_t numed, Int_t ndvmx); Create a new volume by dividing an existing one.; Divide mother into ndiv divisions called name; along axis iaxis starting at coordinate value c0i.; The new volume created will be medium number numed.; Create a new volume by dividing an existing one; Divide mother into divisions called name along; axis iaxis in steps of step. If not exactly divisible; will make as many as possible and will center them; with respect to the mother. Divisions will have medium; number numed. If numed is 0, numed of mother is taken.; ndvmx is the expected maximum number of divisions; (If 0, no protection tests are performed in Geant3). void Gsord(const char* name, Int_t iax); Create a new volume by dividing an existing one; Divides mother into divisions called name along; axis iaxis starting at coordinate value c0 with step; size step.; The new volume created will have medium number numed.; If numed is 0, numed of mother is taken.; ndvmx is the expected maximum number of divisions; (If 0, no protection tests are performed in Geant3); Flag volume name whose contents will have to be ordered; along axis iax, by setting the search flag to -iax; (Geant3 only). void Gspos(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, const char* konly = ""ONLY""); Position a volume into an existing one.; It positions a previously defined volume in the mother.; name Volume name; nr Copy number of the volume; mother Mother volume name; x X coord. of the volume in mother ref. sys.; y Y coord. of the volume in mother ref. sys.; z Z coord. of th",MatchSource.WIKI,root/html532/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMC.html
https://root.cern/root/html532/TVirtualMC.html:21655,Performance,perform,performed,21655,"xisting one.; Divide mother into ndiv divisions called name; along axis iaxis starting at coordinate value c0i.; The new volume created will be medium number numed.; Create a new volume by dividing an existing one; Divide mother into divisions called name along; axis iaxis in steps of step. If not exactly divisible; will make as many as possible and will center them; with respect to the mother. Divisions will have medium; number numed. If numed is 0, numed of mother is taken.; ndvmx is the expected maximum number of divisions; (If 0, no protection tests are performed in Geant3). void Gsord(const char* name, Int_t iax); Create a new volume by dividing an existing one; Divides mother into divisions called name along; axis iaxis starting at coordinate value c0 with step; size step.; The new volume created will have medium number numed.; If numed is 0, numed of mother is taken.; ndvmx is the expected maximum number of divisions; (If 0, no protection tests are performed in Geant3); Flag volume name whose contents will have to be ordered; along axis iax, by setting the search flag to -iax; (Geant3 only). void Gspos(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, const char* konly = ""ONLY""); Position a volume into an existing one.; It positions a previously defined volume in the mother.; name Volume name; nr Copy number of the volume; mother Mother volume name; x X coord. of the volume in mother ref. sys.; y Y coord. of the volume in mother ref. sys.; z Z coord. of the volume in mother ref. sys.; irot Rotation matrix number w.r.t. mother ref. sys.; konly ONLY/MANY flag. void Gsposp(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, const char* konly, Double_t* upar, Int_t np); Place a copy of generic volume name with user number; nr inside mother, with its parameters upar(1..np); The same as previous but in double precision. void SetCerenkov(Int_t itmed, Int_t npckov, Float_t* ppcko",MatchSource.WIKI,root/html532/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMC.html
https://root.cern/root/html532/TVirtualMC.html:34550,Performance,perform,performs,34550,"GeV/c) of the track; currently being transported. void TrackMomentum(Double_t& px, Double_t& py, Double_t& pz, Double_t& etot) const; Return the direction and the momentum (GeV/c) of the track; currently being transported. Double_t TrackStep() const; Return the length in centimeters of the current step (in cm). Double_t TrackLength() const; Return the length of the current track from its origin (in cm). Double_t TrackTime() const; Return the current time of flight of the track being transported. Double_t Edep() const; Return the energy lost in the current step. Int_t TrackPid() const. get methods; tracking particle; static properties. Return the PDG of the particle transported. Double_t TrackCharge() const; Return the charge of the track currently transported. Double_t TrackMass() const; Return the mass of the track currently transported. Double_t Etot() const; Return the total energy of the current track. Bool_t IsNewTrack() const. get methods - track status. Return true when the track performs the first step. Bool_t IsTrackInside() const; Return true if the track is not at the boundary of the current volume. Bool_t IsTrackEntering() const; Return true if this is the first step of the track in the current volume. Bool_t IsTrackExiting() const; Return true if this is the last step of the track in the current volume. Bool_t IsTrackOut() const; Return true if the track is out of the setup. Bool_t IsTrackDisappeared() const; Return true if the current particle has disappeared; either because it decayed or because it underwent; an inelastic collision. Bool_t IsTrackStop() const; Return true if the track energy has fallen below the threshold. Bool_t IsTrackAlive() const; Return true if the current particle is alive and will continue to be; transported. Int_t NSecondaries() const. get methods - secondaries. Return the number of secondary particles generated in the current step. void GetSecondary(Int_t isec, Int_t& particleId, TLorentzVector& position, TLorentzVector& mome",MatchSource.WIKI,root/html532/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMC.html
https://root.cern/root/html532/TVirtualMC.html:23248,Safety,Detect,Detection,23248,"lume in mother ref. sys.; y Y coord. of the volume in mother ref. sys.; z Z coord. of the volume in mother ref. sys.; irot Rotation matrix number w.r.t. mother ref. sys.; konly ONLY/MANY flag. void Gsposp(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, const char* konly, Double_t* upar, Int_t np); Place a copy of generic volume name with user number; nr inside mother, with its parameters upar(1..np); The same as previous but in double precision. void SetCerenkov(Int_t itmed, Int_t npckov, Float_t* ppckov, Float_t* absco, Float_t* effic, Float_t* rindex); Helper function for resolving MANY.; Specify the ONLY volume that overlaps with the; specified MANY and has to be substracted.; (Geant4 only); Define the tables for UV photon tracking in medium itmed.; Please note that it is the user's responsibility to; provide all the coefficients:; itmed Tracking medium number; npckov Number of bins of each table; ppckov Value of photon momentum (in GeV); absco Absorption coefficients; dielectric: absorption length in cm; metals : absorption fraction (0<=x<=1); effic Detection efficiency for UV photons; rindex Refraction index (if=0 metal). void DefineOpSurface(const char* name, EMCOpSurfaceModel model, EMCOpSurfaceType surfaceType, EMCOpSurfaceFinish surfaceFinish, Double_t sigmaAlpha); The same as previous but in double precision. functions for definition of surfaces; and material properties for optical physics. Define the optical surface; name surface name; model selection of model (see #EMCOpSurfaceModel values); surfaceType surface type (see #EMCOpSurfaceType values); surfaceFinish surface quality (see #EMCOpSurfaceType values); sigmaAlpha an unified model surface parameter; (Geant4 only). void SetSkinSurface(const char* name, const char* volName, const char* opSurfaceName); Define the optical surface border; name border surface name; vol1Name first volume name; vol1CopyNo first volume copy number; vol2Name second volume name; v",MatchSource.WIKI,root/html532/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMC.html
https://root.cern/root/html532/TVirtualMC.html:26063,Safety,detect,detector,26063,"momentum (in GeV); values property values; (Geant4 only). functions for access to geometry. Return the transformation matrix between the volume specified by; the path volumePath and the top or master volume. Bool_t GetMaterial(Int_t imat, TString& name, Double_t& a, Double_t& z, Double_t& density, Double_t& radl, Double_t& inter, TArrayD& par); Return the name of the shape (shapeType) and its parameters par; for the volume specified by the path volumePath .; Return the material parameters for the material specified by; the material Id - NEW. Bool_t GetMedium(const TString& volumeName, TString& name, Int_t& imed, Int_t& nmat, Int_t& isvol, Int_t& ifield, Double_t& fieldm, Double_t& tmaxfd, Double_t& stemax, Double_t& deemax, Double_t& epsil, Double_t& stmin, TArrayD& par); Return the material parameters for the volume specified by; the volumeName.; Return the medium parameters for the volume specified by the; volumeName. void SetRootGeometry(); Write out the geometry of the detector in EUCLID file format; filnam file name - will be with the extension .euc *; topvol volume name of the starting node; number copy number of topvol (relevant for gsposp); nlevel number of levels in the tree structure; to be written out, starting from topvol; (Geant3 only); Deprecated; Set geometry from Root (built via TGeo). void SetUserParameters(Bool_t isUserParameters); Activate the parameters defined in tracking media; (DEEMAX, STMIN, STEMAX), which are, be default, ignored.; In Geant4 case, only STEMAX is taken into account.; In FLUKA, all tracking media parameters are ignored. Int_t VolId(const char* volName) const. get methods. Return the unique numeric identifier for volume name volName. const char* VolName(Int_t id) const; Return the volume name for a given volume identifier id. Int_t MediumId(const char* mediumName) const; Return the unique numeric identifier for medium name mediumName. Int_t NofVolumes() const; Return total number of volumes in the geometry. Int_t VolId2Mate(Int",MatchSource.WIKI,root/html532/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMC.html
https://root.cern/root/html532/TVirtualMC.html:30734,Safety,abort,abort,30734,"nel; Calculate X-sections; (Geant3 only); Deprecated. Int_t IdFromPDG(Int_t pdg) const. particle table usage. Return MC specific code from a PDG and pseudo ENDF code (pdg). Int_t PDGFromId(Int_t id) const; Return PDG code and pseudo ENDF code from MC specific code (id). TString ParticleName(Int_t pdg) const. get methods. Return name of the particle specified by pdg. Double_t ParticleMass(Int_t pdg) const; Return mass of the particle specified by pdg. Double_t ParticleCharge(Int_t pdg) const; Return charge (in e units) of the particle specified by pdg. Double_t ParticleLifeTime(Int_t pdg) const; Return life time of the particle specified by pdg. TMCParticleType ParticleMCType(Int_t pdg) const; Return VMC type of the particle specified by pdg. void StopTrack(). methods for step management. action methods. Stop the transport of the current particle and skip to the next. void StopEvent(); Stop simulation of the current event and skip to the next. void StopRun(); Stop simulation of the current event and set the abort run flag to true. void SetMaxStep(Double_t ). set methods. Set the maximum step allowed till the particle is in the current medium. void SetMaxNStep(Int_t ); Set the maximum number of steps till the particle is in the current medium. void SetUserDecay(Int_t pdg); Force the decays of particles to be done with Pythia; and not with the Geant routines. void ForceDecayTime(Float_t ); Force the decay time of the current particle. Int_t CurrentVolID(Int_t& copyNo) const. tracking volume(s). Return the current volume ID and copy number. Int_t CurrentVolOffID(Int_t off, Int_t& copyNo) const; Return the current volume off upward in the geometrical tree; ID and copy number. const char* CurrentVolName() const; Return the current volume name. const char* CurrentVolOffName(Int_t off) const; Return the current volume off upward in the geometrical tree; name and copy number'; if name=0 no name is returned. const char* CurrentVolPath(); Return the path in geometry tree for th",MatchSource.WIKI,root/html532/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMC.html
https://root.cern/root/html532/TVirtualMC.html:36245,Safety,abort,aborted,36245,"ue if the track energy has fallen below the threshold. Bool_t IsTrackAlive() const; Return true if the current particle is alive and will continue to be; transported. Int_t NSecondaries() const. get methods - secondaries. Return the number of secondary particles generated in the current step. void GetSecondary(Int_t isec, Int_t& particleId, TLorentzVector& position, TLorentzVector& momentum); Return the parameters of the secondary track number isec produced; in the current step. Int_t StepProcesses(TArrayI& proc) const; Return the VMC code of the process that has produced the secondary; particles in the current step; Return the array of the VMC code of the processes active in the current; step. Bool_t SecondariesAreOrdered() const; Return the information about the transport order needed by the stack. void Init(). Control methods. Initialize MC. void BuildPhysics(); Initialize MC physics. void ProcessEvent(); Process one event; Deprecated. Bool_t ProcessRun(Int_t nevent); Process one run and return true if run has finished successfully,; return false in other cases (run aborted by user). void InitLego(); Set switches for lego transport. void SetCollectTracks(Bool_t collectTracks); (In)Activate collecting TGeo tracks. Bool_t IsCollectTracks() const; Return the info if collecting tracks is activated. TVirtualMCStack* GetStack() const. Get methods. Return the particle stack. { return fStack; }. TVirtualMCDecayer* GetDecayer() const; Return the external decayer. { return fDecayer; }. TRandom* GetRandom() const; Return the random number generator. { return fRandom; }. TVirtualMagField* GetMagField() const; Return the magnetic field. { return fMagField; }. TVirtualMC & operator=(const TVirtualMC& ). » Last changed: root/vmc:$Name: $:$Id: TVirtualMC.h 38344 2011-03-09 17:03:14Z ivana $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMC.html
https://root.cern/root/html532/TVirtualMC.html:7196,Security,Hash,Hash,7196,"Int_t numed, Int_t ndvmx); virtual voidGsdvt2(const char* name, const char* mother, Double_t step, Int_t iaxis, Double_t c0, Int_t numed, Int_t ndvmx); virtual voidGsord(const char* name, Int_t iax); virtual voidGspos(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, const char* konly = ""ONLY""); virtual voidGsposp(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, const char* konly, Float_t* upar, Int_t np); virtual voidGsposp(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, const char* konly, Double_t* upar, Int_t np); virtual voidGstpar(Int_t itmed, const char* param, Double_t parval); virtual Int_tGsvolu(const char* name, const char* shape, Int_t nmed, Float_t* upar, Int_t np); virtual Int_tGsvolu(const char* name, const char* shape, Int_t nmed, Double_t* upar, Int_t np); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual Int_tIdFromPDG(Int_t pdg) const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidInit(); virtual voidInitLego(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tIsCollectTracks() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tIsNewTrack() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsRootGeometrySupported() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tIsTrackAlive() const; virtual Bool_tIsTrackDisappeared() const; virtual Bool_tIsTrackEntering() const; virtual Bool_tIsTrackExiting() const; virtual Bool_tIsTrackInside() const; virtual Bool_tIsTrackOut() const; virtual Bool_tIsTrackStop() const; Bool_tTObject::IsZombie() const; virtual voi",MatchSource.WIKI,root/html532/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMC.html
https://root.cern/root/html532/TVirtualMC.html:25147,Security,access,access,25147,"olume copy number; opSurfaceName name of optical surface which this border belongs to; (Geant4 only); Define the optical skin surface; name skin surface name; volName volume name; opSurfaceName name of optical surface which this border belongs to; (Geant4 only). void SetMaterialProperty(Int_t itmed, const char* propertyName, Double_t value); Define material property via a table of values; itmed tracking medium id; propertyName property name; np number of bins of the table; pp value of photon momentum (in GeV); values property values; (Geant4 only); Define material property via a value; itmed tracking medium id; propertyName property name; value property value; (Geant4 only). Bool_t GetTransformation(const TString& volumePath, TGeoHMatrix& matrix); Define optical surface property via a table of values; surfaceName optical surface name; propertyName property name; np number of bins of the table; pp value of photon momentum (in GeV); values property values; (Geant4 only). functions for access to geometry. Return the transformation matrix between the volume specified by; the path volumePath and the top or master volume. Bool_t GetMaterial(Int_t imat, TString& name, Double_t& a, Double_t& z, Double_t& density, Double_t& radl, Double_t& inter, TArrayD& par); Return the name of the shape (shapeType) and its parameters par; for the volume specified by the path volumePath .; Return the material parameters for the material specified by; the material Id - NEW. Bool_t GetMedium(const TString& volumeName, TString& name, Int_t& imed, Int_t& nmat, Int_t& isvol, Int_t& ifield, Double_t& fieldm, Double_t& tmaxfd, Double_t& stemax, Double_t& deemax, Double_t& epsil, Double_t& stmin, TArrayD& par); Return the material parameters for the volume specified by; the volumeName.; Return the medium parameters for the volume specified by the; volumeName. void SetRootGeometry(); Write out the geometry of the detector in EUCLID file format; filnam file name - will be with the extension .euc *; ",MatchSource.WIKI,root/html532/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMC.html
https://root.cern/root/html532/TVirtualMC.html:13289,Testability,Test,TestBit,13289,"d::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual Bool_tSetProcess(const char* flagName, Int_t flagValue); virtual voidSetRandom(TRandom* random); virtual voidSetRootGeometry(); virtual voidSetSkinSurface(const char* name, const char* volName, const char* opSurfaceName); virtual voidSetStack(TVirtualMCStack* stack); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetUserDecay(Int_t pdg); virtual voidSetUserParameters(Bool_t isUserParameters); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual Int_tStepProcesses(TArrayI& proc) const; virtual voidStopEvent(); virtual voidStopRun(); virtual voidStopTrack(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Double_tTrackCharge() const; virtual Double_tTrackLength() const; virtual Double_tTrackMass() const; virtual voidTrackMomentum(TLorentzVector& momentum) const; virtual voidTrackMomentum(Double_t& px, Double_t& py, Double_t& pz, Double_t& etot) const; virtual Int_tTrackPid() const; virtual voidTrackPosition(TLorentzVector& position) const; virtual voidTrackPosition(Double_t& x, Double_t& y, Double_t& z) const; virtual Double_tTrackStep() const; virtual Double_tTrackTime() const; virtual voidTObject::UseCurrentStyle(); virtual Int_tVolDaughterCopyNo(const char* volName, Int_t i) const; virtual const char*VolDaughterName(const char* volName, Int_t i) const; virtual Int_tVolId(const char* volName) const; virtual Int_tVolId2Mate(Int_t id) const; virtual const char*VolName(Int_t id) const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t opti",MatchSource.WIKI,root/html532/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMC.html
https://root.cern/root/html532/TVirtualMC.html:13328,Testability,Test,TestBits,13328,"ual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual Bool_tSetProcess(const char* flagName, Int_t flagValue); virtual voidSetRandom(TRandom* random); virtual voidSetRootGeometry(); virtual voidSetSkinSurface(const char* name, const char* volName, const char* opSurfaceName); virtual voidSetStack(TVirtualMCStack* stack); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetUserDecay(Int_t pdg); virtual voidSetUserParameters(Bool_t isUserParameters); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual Int_tStepProcesses(TArrayI& proc) const; virtual voidStopEvent(); virtual voidStopRun(); virtual voidStopTrack(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Double_tTrackCharge() const; virtual Double_tTrackLength() const; virtual Double_tTrackMass() const; virtual voidTrackMomentum(TLorentzVector& momentum) const; virtual voidTrackMomentum(Double_t& px, Double_t& py, Double_t& pz, Double_t& etot) const; virtual Int_tTrackPid() const; virtual voidTrackPosition(TLorentzVector& position) const; virtual voidTrackPosition(Double_t& x, Double_t& y, Double_t& z) const; virtual Double_tTrackStep() const; virtual Double_tTrackTime() const; virtual voidTObject::UseCurrentStyle(); virtual Int_tVolDaughterCopyNo(const char* volName, Int_t i) const; virtual const char*VolDaughterName(const char* volName, Int_t i) const; virtual Int_tVolId(const char* volName) const; virtual Int_tVolId2Mate(Int_t id) const; virtual const char*VolName(Int_t id) const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_",MatchSource.WIKI,root/html532/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMC.html
https://root.cern/root/html532/TVirtualMC.html:21239,Testability,test,tests,21239,", const char* mother, Int_t ndiv, Int_t iaxis); The same as previous but in double precision; Create a new volume by dividing an existing one.; It divides a previously defined volume; name Volume name; mother Mother volume name; ndiv Number of divisions; iaxis Axis value:; X,Y,Z of CAXIS will be translated to 1,2,3 for IAXIS. void Gsdvt(const char* name, const char* mother, Double_t step, Int_t iaxis, Int_t numed, Int_t ndvmx); Create a new volume by dividing an existing one.; Divide mother into ndiv divisions called name; along axis iaxis starting at coordinate value c0i.; The new volume created will be medium number numed.; Create a new volume by dividing an existing one; Divide mother into divisions called name along; axis iaxis in steps of step. If not exactly divisible; will make as many as possible and will center them; with respect to the mother. Divisions will have medium; number numed. If numed is 0, numed of mother is taken.; ndvmx is the expected maximum number of divisions; (If 0, no protection tests are performed in Geant3). void Gsord(const char* name, Int_t iax); Create a new volume by dividing an existing one; Divides mother into divisions called name along; axis iaxis starting at coordinate value c0 with step; size step.; The new volume created will have medium number numed.; If numed is 0, numed of mother is taken.; ndvmx is the expected maximum number of divisions; (If 0, no protection tests are performed in Geant3); Flag volume name whose contents will have to be ordered; along axis iax, by setting the search flag to -iax; (Geant3 only). void Gspos(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, const char* konly = ""ONLY""); Position a volume into an existing one.; It positions a previously defined volume in the mother.; name Volume name; nr Copy number of the volume; mother Mother volume name; x X coord. of the volume in mother ref. sys.; y Y coord. of the volume in mother ref. sys.; z Z coord. of th",MatchSource.WIKI,root/html532/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMC.html
https://root.cern/root/html532/TVirtualMC.html:21645,Testability,test,tests,21645,"xisting one.; Divide mother into ndiv divisions called name; along axis iaxis starting at coordinate value c0i.; The new volume created will be medium number numed.; Create a new volume by dividing an existing one; Divide mother into divisions called name along; axis iaxis in steps of step. If not exactly divisible; will make as many as possible and will center them; with respect to the mother. Divisions will have medium; number numed. If numed is 0, numed of mother is taken.; ndvmx is the expected maximum number of divisions; (If 0, no protection tests are performed in Geant3). void Gsord(const char* name, Int_t iax); Create a new volume by dividing an existing one; Divides mother into divisions called name along; axis iaxis starting at coordinate value c0 with step; size step.; The new volume created will have medium number numed.; If numed is 0, numed of mother is taken.; ndvmx is the expected maximum number of divisions; (If 0, no protection tests are performed in Geant3); Flag volume name whose contents will have to be ordered; along axis iax, by setting the search flag to -iax; (Geant3 only). void Gspos(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, const char* konly = ""ONLY""); Position a volume into an existing one.; It positions a previously defined volume in the mother.; name Volume name; nr Copy number of the volume; mother Mother volume name; x X coord. of the volume in mother ref. sys.; y Y coord. of the volume in mother ref. sys.; z Z coord. of the volume in mother ref. sys.; irot Rotation matrix number w.r.t. mother ref. sys.; konly ONLY/MANY flag. void Gsposp(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, const char* konly, Double_t* upar, Int_t np); Place a copy of generic volume name with user number; nr inside mother, with its parameters upar(1..np); The same as previous but in double precision. void SetCerenkov(Int_t itmed, Int_t npckov, Float_t* ppcko",MatchSource.WIKI,root/html532/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMC.html
https://root.cern/root/html532/TVirtualMC.html:1275,Usability,Clear,Clear,1275,"d from the abstract; Monte Carlo application class, and provide functions like; ConstructGeometry(), BeginEvent(), FinishEvent(), ... .; The concrete Monte Carlo (Geant3, Geant4) is selected at run time -; when processing a ROOT macro where the concrete Monte Carlo is instantiated. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualMC(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidBuildPhysics(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCurrentBoundaryNormal(Double_t& x, Double_t& y, Double_t& z) const; virtual Int_tCurrentEvent() const; virtual Int_tCurrentMaterial(Float_t& a, Float_t& z, Float_t& dens, Float_t& radl, Float_t& absl) const; virtual Int_tCurrentMedium() const; virtual Int_tCurrentVolID(Int_t& copyNo) const; virtual const char*CurrentVolName() const; virtual Int_tCurrentVolOffID(Int_t off, Int_t& copyNo) const; virtual const char*CurrentVolOffName(Int_t off) const; virtual const char*CurrentVolPath(); virtual Bool_tDefineIon(const char* name, Int_t Z, Int_t A, Int_t Q, Double_t excEnergy, Double_t mass = 0.); virtual voidDefineOpSurface(const char* name, EMCOpSurfaceModel model, EMCOpSurfaceType surfaceType, EMCOpSurfaceFinish surfaceFinish, Double_t sigmaAlpha); virtual Bool_tDefineParticle(Int_t pdg, const char* name, TMCParticleType mcType, Double_t mass, Double_t charge, Double_t lifetime); virtual Bool_tDefineParticle(Int_t pdg, const char* name, TMCParticleType mcType, Double_t mass, Double_t charge, Double_t lifetime, const TString& pType, D",MatchSource.WIKI,root/html532/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMC.html
https://root.cern/root/html532/TVirtualMCApplication.html:507,Availability,avail,available,507,". TVirtualMCApplication. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » VMC; » TVirtualMCApplication. class TVirtualMCApplication: public TNamed. Interface to a user Monte Carlo application. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualMCApplication(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddIons(); virtual voidAddParticles(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBeginEvent(); virtual voidBeginPrimary(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidConstructGeometry(); virtual voidConstructOpGeometry(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidField(const Double_t* x, Double_t* b) const; virtual voidTNamed::FillBuffer(char*& buffer)",MatchSource.WIKI,root/html532/TVirtualMCApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCApplication.html
https://root.cern/root/html532/TVirtualMCApplication.html:1532,Availability,Error,Error,1532," virtual~TVirtualMCApplication(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddIons(); virtual voidAddParticles(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBeginEvent(); virtual voidBeginPrimary(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidConstructGeometry(); virtual voidConstructOpGeometry(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidField(const Double_t* x, Double_t* b) const; virtual voidTNamed::FillBuffer(char*& buffer)",MatchSource.WIKI,root/html532/TVirtualMCApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCApplication.html
https://root.cern/root/html532/TVirtualMCApplication.html:1661,Availability,error,error,1661,"AddParticles(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBeginEvent(); virtual voidBeginPrimary(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidConstructGeometry(); virtual voidConstructOpGeometry(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidField(const Double_t* x, Double_t* b) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFinishEvent(); virtual voidFinishPrimary(); virtual voidGeaneStepping(); virtual voidGeneratePrimaries(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virt",MatchSource.WIKI,root/html532/TVirtualMCApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCApplication.html
https://root.cern/root/html532/TVirtualMCApplication.html:1745,Availability,error,error,1745,"eginEvent(); virtual voidBeginPrimary(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidConstructGeometry(); virtual voidConstructOpGeometry(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidField(const Double_t* x, Double_t* b) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFinishEvent(); virtual voidFinishPrimary(); virtual voidGeaneStepping(); virtual voidGeneratePrimaries(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; ",MatchSource.WIKI,root/html532/TVirtualMCApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCApplication.html
https://root.cern/root/html532/TVirtualMCApplication.html:328,Integrability,Interface,Interface,328,". TVirtualMCApplication. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » VMC; » TVirtualMCApplication. class TVirtualMCApplication: public TNamed. Interface to a user Monte Carlo application. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualMCApplication(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddIons(); virtual voidAddParticles(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBeginEvent(); virtual voidBeginPrimary(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidConstructGeometry(); virtual voidConstructOpGeometry(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidField(const Double_t* x, Double_t* b) const; virtual voidTNamed::FillBuffer(char*& buffer)",MatchSource.WIKI,root/html532/TVirtualMCApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCApplication.html
https://root.cern/root/html532/TVirtualMCApplication.html:2844,Modifiability,Inherit,InheritsFrom,2844,"l(const char* method, const char* msgfmt) const; virtual voidField(const Double_t* x, Double_t* b) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFinishEvent(); virtual voidFinishPrimary(); virtual voidGeaneStepping(); virtual voidGeneratePrimaries(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidInitGeometry(); virtual voidTObject::Inspect() constMENU ; static TVirtualMCApplication*Instance(); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tMisalignGeometry(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz",MatchSource.WIKI,root/html532/TVirtualMCApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCApplication.html
https://root.cern/root/html532/TVirtualMCApplication.html:2910,Modifiability,Inherit,InheritsFrom,2910,"(const Double_t* x, Double_t* b) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFinishEvent(); virtual voidFinishPrimary(); virtual voidGeaneStepping(); virtual voidGeneratePrimaries(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidInitGeometry(); virtual voidTObject::Inspect() constMENU ; static TVirtualMCApplication*Instance(); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tMisalignGeometry(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::",MatchSource.WIKI,root/html532/TVirtualMCApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCApplication.html
https://root.cern/root/html532/TVirtualMCApplication.html:6285,Modifiability,Inherit,Inheritance,6285,"s(UInt_t f) const; virtual Double_tTrackingRmax() const; virtual Double_tTrackingZmax() const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. static TVirtualMCApplication*fgInstancesingleton instance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TVirtualMCApplication(). Destructor. TVirtualMCApplication* Instance(). Static access method. void Field(const Double_t* x, Double_t* b) const; No magnetic field. void ConstructGeometry(). methods. Construct user geometry. Bool_t MisalignGeometry(); Misalign user geometry (optional). {return kFALSE;}. void ConstructOpGeometry(); Define parameters for optical processes (optional). {}. void InitGeometry(); Initialize geometry; (Usually used to define sensitive volumes IDs). void AddParticles(); Add user defined particles (optional). {}. void AddIons(); Add user defined ions (optional). {}. void GeneratePrimaries(); Generate primary particles. void BeginEvent(); Define actions at the beginning of the event. void BeginPrimary(); Define actions at the beginning of the primary track. void PreTrack(); Define actions at the beginning of each track. void Stepping(); Define action at each step. void PostTrack(); Define actions at the end of eac",MatchSource.WIKI,root/html532/TVirtualMCApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCApplication.html
https://root.cern/root/html532/TVirtualMCApplication.html:6298,Modifiability,Inherit,Inherited,6298,"s(UInt_t f) const; virtual Double_tTrackingRmax() const; virtual Double_tTrackingZmax() const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. static TVirtualMCApplication*fgInstancesingleton instance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TVirtualMCApplication(). Destructor. TVirtualMCApplication* Instance(). Static access method. void Field(const Double_t* x, Double_t* b) const; No magnetic field. void ConstructGeometry(). methods. Construct user geometry. Bool_t MisalignGeometry(); Misalign user geometry (optional). {return kFALSE;}. void ConstructOpGeometry(); Define parameters for optical processes (optional). {}. void InitGeometry(); Initialize geometry; (Usually used to define sensitive volumes IDs). void AddParticles(); Add user defined particles (optional). {}. void AddIons(); Add user defined ions (optional). {}. void GeneratePrimaries(); Generate primary particles. void BeginEvent(); Define actions at the beginning of the event. void BeginPrimary(); Define actions at the beginning of the primary track. void PreTrack(); Define actions at the beginning of each track. void Stepping(); Define action at each step. void PostTrack(); Define actions at the end of eac",MatchSource.WIKI,root/html532/TVirtualMCApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCApplication.html
https://root.cern/root/html532/TVirtualMCApplication.html:2734,Security,Hash,Hash,2734,", Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidField(const Double_t* x, Double_t* b) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFinishEvent(); virtual voidFinishPrimary(); virtual voidGeaneStepping(); virtual voidGeneratePrimaries(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidInitGeometry(); virtual voidTObject::Inspect() constMENU ; static TVirtualMCApplication*Instance(); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tMisalignGeometry(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator del",MatchSource.WIKI,root/html532/TVirtualMCApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCApplication.html
https://root.cern/root/html532/TVirtualMCApplication.html:6442,Security,access,access,6442,"virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. static TVirtualMCApplication*fgInstancesingleton instance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TVirtualMCApplication(). Destructor. TVirtualMCApplication* Instance(). Static access method. void Field(const Double_t* x, Double_t* b) const; No magnetic field. void ConstructGeometry(). methods. Construct user geometry. Bool_t MisalignGeometry(); Misalign user geometry (optional). {return kFALSE;}. void ConstructOpGeometry(); Define parameters for optical processes (optional). {}. void InitGeometry(); Initialize geometry; (Usually used to define sensitive volumes IDs). void AddParticles(); Add user defined particles (optional). {}. void AddIons(); Add user defined ions (optional). {}. void GeneratePrimaries(); Generate primary particles. void BeginEvent(); Define actions at the beginning of the event. void BeginPrimary(); Define actions at the beginning of the primary track. void PreTrack(); Define actions at the beginning of each track. void Stepping(); Define action at each step. void PostTrack(); Define actions at the end of each track. void FinishPrimary(); Define actions at the end of the primary track. void FinishEvent(); Define actions at the end of the ev",MatchSource.WIKI,root/html532/TVirtualMCApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCApplication.html
https://root.cern/root/html532/TVirtualMCApplication.html:5264,Testability,Test,TestBit,5264,"p); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TVirtualMCApplication&operator=(const TVirtualMCApplication&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPostTrack(); virtual voidPreTrack(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStepping(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Double_tTrackingRmax() const; virtual Double_tTrackingZmax() const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TVirtualMCApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCApplication.html
https://root.cern/root/html532/TVirtualMCApplication.html:5303,Testability,Test,TestBits,5303,"p); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TVirtualMCApplication&operator=(const TVirtualMCApplication&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPostTrack(); virtual voidPreTrack(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStepping(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Double_tTrackingRmax() const; virtual Double_tTrackingZmax() const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TVirtualMCApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCApplication.html
https://root.cern/root/html532/TVirtualMCApplication.html:921,Usability,Clear,Clear,921," virtual~TVirtualMCApplication(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddIons(); virtual voidAddParticles(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBeginEvent(); virtual voidBeginPrimary(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidConstructGeometry(); virtual voidConstructOpGeometry(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidField(const Double_t* x, Double_t* b) const; virtual voidTNamed::FillBuffer(char*& buffer)",MatchSource.WIKI,root/html532/TVirtualMCApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCApplication.html
https://root.cern/root/html532/TVirtualMCDecayer.html:594,Availability,avail,available,594,". TVirtualMCDecayer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » EG; » TVirtualMCDecayer. class TVirtualMCDecayer: public TObject. Abstract base class for particle decays.; Clients are the transport code and the primary particle generators; This is an abstract base class !. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualMCDecayer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecay(Int_t idpart, TLorentzVector* p); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidForceD",MatchSource.WIKI,root/html532/TVirtualMCDecayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCDecayer.html
https://root.cern/root/html532/TVirtualMCDecayer.html:1492,Availability,Error,Error,1492," virtual~TVirtualMCDecayer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecay(Int_t idpart, TLorentzVector* p); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidForceD",MatchSource.WIKI,root/html532/TVirtualMCDecayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCDecayer.html
https://root.cern/root/html532/TVirtualMCDecayer.html:1621,Availability,error,error,1621," virtual~TVirtualMCDecayer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecay(Int_t idpart, TLorentzVector* p); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidForceD",MatchSource.WIKI,root/html532/TVirtualMCDecayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCDecayer.html
https://root.cern/root/html532/TVirtualMCDecayer.html:1705,Availability,error,error,1705,"st; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecay(Int_t idpart, TLorentzVector* p); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidForceDecay(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Float_tGetLifetime(Int_t kf); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Float_tGetPartialBranchingRatio(Int_t ipart); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual Int_tImportParticles(TClonesArray* particles); virtual voidTObject::Info(const char* method, ",MatchSource.WIKI,root/html532/TVirtualMCDecayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCDecayer.html
https://root.cern/root/html532/TVirtualMCDecayer.html:2758,Modifiability,Inherit,InheritsFrom,2758,"Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidForceDecay(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Float_tGetLifetime(Int_t kf); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Float_tGetPartialBranchingRatio(Int_t ipart); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual Int_tImportParticles(TClonesArray* particles); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidInit(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](",MatchSource.WIKI,root/html532/TVirtualMCDecayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCDecayer.html
https://root.cern/root/html532/TVirtualMCDecayer.html:2824,Modifiability,Inherit,InheritsFrom,2824,", const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidForceDecay(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Float_tGetLifetime(Int_t kf); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Float_tGetPartialBranchingRatio(Int_t ipart); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual Int_tImportParticles(TClonesArray* particles); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidInit(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TVi",MatchSource.WIKI,root/html532/TVirtualMCDecayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCDecayer.html
https://root.cern/root/html532/TVirtualMCDecayer.html:5657,Modifiability,Inherit,Inheritance,5657,"t(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetForceDecay(Int_t type); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualMCDecayer(); {;}. void Init(). void Decay(Int_t idpart, TLorentzVector* p). Int_t ImportParticles(TClonesArray* particles). void SetForceDecay(Int_t type). void ForceDecay(). Float_t GetPartialBranchingRatio(Int_t ipart). Float_t GetLifetime(Int_t kf). void ReadDecayTable(). » Author: Andreas Morsch 13/04/2002 » Copyright (C) 2006, Rene Brun and Fons Rademakers. *; » Last changed: root/eg:$Id: TVirtualMCDecayer.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TVirtualMCDecayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCDecayer.html
https://root.cern/root/html532/TVirtualMCDecayer.html:5670,Modifiability,Inherit,Inherited,5670,"t(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetForceDecay(Int_t type); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualMCDecayer(); {;}. void Init(). void Decay(Int_t idpart, TLorentzVector* p). Int_t ImportParticles(TClonesArray* particles). void SetForceDecay(Int_t type). void ForceDecay(). Float_t GetPartialBranchingRatio(Int_t ipart). Float_t GetLifetime(Int_t kf). void ReadDecayTable(). » Author: Andreas Morsch 13/04/2002 » Copyright (C) 2006, Rene Brun and Fons Rademakers. *; » Last changed: root/eg:$Id: TVirtualMCDecayer.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TVirtualMCDecayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCDecayer.html
https://root.cern/root/html532/TVirtualMCDecayer.html:2593,Security,Hash,Hash,2593,"onst char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidForceDecay(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Float_tGetLifetime(Int_t kf); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Float_tGetPartialBranchingRatio(Int_t ipart); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual Int_tImportParticles(TClonesArray* particles); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidInit(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static v",MatchSource.WIKI,root/html532/TVirtualMCDecayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCDecayer.html
https://root.cern/root/html532/TVirtualMCDecayer.html:4867,Testability,Test,TestBit,4867," option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TVirtualMCDecayer&operator=(const TVirtualMCDecayer&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidReadDecayTable(); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetForceDecay(Int_t type); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TVirtualMCDecayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCDecayer.html
https://root.cern/root/html532/TVirtualMCDecayer.html:4906,Testability,Test,TestBits,4906," option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TVirtualMCDecayer&operator=(const TVirtualMCDecayer&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidReadDecayTable(); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetForceDecay(Int_t type); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TVirtualMCDecayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCDecayer.html
https://root.cern/root/html532/TVirtualMCDecayer.html:900,Usability,Clear,Clear,900," virtual~TVirtualMCDecayer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecay(Int_t idpart, TLorentzVector* p); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidForceD",MatchSource.WIKI,root/html532/TVirtualMCDecayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCDecayer.html
https://root.cern/root/html532/TVirtualMCGeometry.html:540,Availability,avail,available,540,". TVirtualMCGeometry. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » VMC; » TVirtualMCGeometry. class TVirtualMCGeometry: public TNamed. Virtual MCGeometry provides a virtual interface to Monte Carlo; geometry construction. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualMCGeometry(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::Get",MatchSource.WIKI,root/html532/TVirtualMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCGeometry.html
https://root.cern/root/html532/TVirtualMCGeometry.html:1389,Availability,Error,Error,1389," virtual~TVirtualMCGeometry(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::Get",MatchSource.WIKI,root/html532/TVirtualMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCGeometry.html
https://root.cern/root/html532/TVirtualMCGeometry.html:1518,Availability,error,error,1518," virtual~TVirtualMCGeometry(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::Get",MatchSource.WIKI,root/html532/TVirtualMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCGeometry.html
https://root.cern/root/html532/TVirtualMCGeometry.html:1602,Availability,error,error,1602,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Bool_tGetMaterial(const TString& volumeName, TString& name, Int_t& imat, Double_t& a, Double_t& z, Double_t& density, Double_t& radl, Double_t& inter, TArrayD& par); virtual Bool_tGetMedium(const TString& volumeName, TString& name, Int_t& imed, Int_t& nmat, Int_t& isvol, Int_t& ifield, Double_t& fieldm, Double_t& tmaxfd, Double_t& stemax, Double_t& deemax, Double_t& epsil, Double_t& stmin, TArrayD& par); virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject",MatchSource.WIKI,root/html532/TVirtualMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCGeometry.html
https://root.cern/root/html532/TVirtualMCGeometry.html:10953,Deployability,continuous,continuous,10953,"wmat contains the number of atoms; of a given kind into the molecule of the compound.; In this case, wmat in output is changed to relative; weights. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Float_t* ubuf, Int_t nbuf); The same as previous but in double precision; Define a medium.; kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field:; - ifield = 0 if no magnetic field;; - ifield = -1 if user decision in guswim;; - ifield = 1 if tracking performed with g3rkuta;; - ifield = 2 if tracking; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm); ubuf pointer to an array of user words; nbuf number of user words; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Matrix(Int_t& krot, Double_t thetaX, Double_t phiX, Double_t thetaY, Double_t phiY, Double_t thetaZ, Double_t phiZ); The same as previous but in double precision; Define a rotation matrix; krot rotation matrix number assigned; thetaX polar angle for axis X; phiX azimuthal angle for axis X; thetaY polar angle for axis Y; phiY azimuthal angle for axis Y; thetaZ polar angle for axis Z; phiZ azimuthal angle for axis Z. Int_t Gsvolu(const char* name, const char* shape, Int_t nmed, Double_t* upar, Int_t np). functions from GGEOM. Create a new volume; name Volume name; shape Volume type; nmed Tracking medium number; np Number of shape parameters; upar Vector containing shape parameters; The same as previous but in double precision. void Gsdvn2(const char* name, const char* mother, Int_t ndiv, Int_t iaxis, Double_t c0i, Int_t numed); Create a new volume by dividing an existing one.; It divides a previ",MatchSource.WIKI,root/html532/TVirtualMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCGeometry.html
https://root.cern/root/html532/TVirtualMCGeometry.html:10876,Energy Efficiency,energy,energy,10876," and wmat. If nlmat > 0 then wmat contains the proportion by; weights of each basic material in the mixture. If nlmat < 0 then wmat contains the number of atoms; of a given kind into the molecule of the compound.; In this case, wmat in output is changed to relative; weights. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Float_t* ubuf, Int_t nbuf); The same as previous but in double precision; Define a medium.; kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field:; - ifield = 0 if no magnetic field;; - ifield = -1 if user decision in guswim;; - ifield = 1 if tracking performed with g3rkuta;; - ifield = 2 if tracking; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm); ubuf pointer to an array of user words; nbuf number of user words; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Matrix(Int_t& krot, Double_t thetaX, Double_t phiX, Double_t thetaY, Double_t phiY, Double_t thetaZ, Double_t phiZ); The same as previous but in double precision; Define a rotation matrix; krot rotation matrix number assigned; thetaX polar angle for axis X; phiX azimuthal angle for axis X; thetaY polar angle for axis Y; phiY azimuthal angle for axis Y; thetaZ polar angle for axis Z; phiZ azimuthal angle for axis Z. Int_t Gsvolu(const char* name, const char* shape, Int_t nmed, Double_t* upar, Int_t np). functions from GGEOM. Create a new volume; name Volume name; shape Volume type; nmed Tracking medium number; np Number of shape parameters; upar Vector containing shape parameters; The same as previous but in double precision. void Gsdvn2(const char* name, const char* mo",MatchSource.WIKI,root/html532/TVirtualMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCGeometry.html
https://root.cern/root/html532/TVirtualMCGeometry.html:357,Integrability,interface,interface,357,". TVirtualMCGeometry. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » VMC; » TVirtualMCGeometry. class TVirtualMCGeometry: public TNamed. Virtual MCGeometry provides a virtual interface to Monte Carlo; geometry construction. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualMCGeometry(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::Get",MatchSource.WIKI,root/html532/TVirtualMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCGeometry.html
https://root.cern/root/html532/TVirtualMCGeometry.html:4309,Modifiability,Inherit,InheritsFrom,4309,"(const char* name, const char* mother, Double_t step, Int_t iaxis, Double_t c0, Int_t numed, Int_t ndvmx); virtual voidGsord(const char* name, Int_t iax); virtual voidGspos(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, const char* konly = ""ONLY""); virtual voidGsposp(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, const char* konly, Float_t* upar, Int_t np); virtual voidGsposp(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, const char* konly, Double_t* upar, Int_t np); virtual Int_tGsvolu(const char* name, const char* shape, Int_t nmed, Float_t* upar, Int_t np); virtual Int_tGsvolu(const char* name, const char* shape, Int_t nmed, Double_t* upar, Int_t np); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; virtual voidMaterial(Int_t& kmat, const char* name, Double_t a, Double_t z, Double_t dens, Double_t radl, Double_t absl, Float_t* buf, Int_t nwbuf); virtual voidMaterial(Int_t& kmat, const char* name, Double_t a, Double_t z, Double_t dens, Double_t radl, Double_t absl, Double_t* buf, Int_t nwbuf); virtual voidMatrix(Int_t& krot, Double_t thetaX, Double_t phiX, Double_t thetaY, Double_t phiY, Double_t thetaZ, Double_t phiZ); voidTObject::MayNotUse(const char* method) const; virtual voidMedium(Int_t& kmed, const char* name, Int_t nmat",MatchSource.WIKI,root/html532/TVirtualMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCGeometry.html
https://root.cern/root/html532/TVirtualMCGeometry.html:4375,Modifiability,Inherit,InheritsFrom,4375," Double_t c0, Int_t numed, Int_t ndvmx); virtual voidGsord(const char* name, Int_t iax); virtual voidGspos(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, const char* konly = ""ONLY""); virtual voidGsposp(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, const char* konly, Float_t* upar, Int_t np); virtual voidGsposp(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, const char* konly, Double_t* upar, Int_t np); virtual Int_tGsvolu(const char* name, const char* shape, Int_t nmed, Float_t* upar, Int_t np); virtual Int_tGsvolu(const char* name, const char* shape, Int_t nmed, Double_t* upar, Int_t np); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; virtual voidMaterial(Int_t& kmat, const char* name, Double_t a, Double_t z, Double_t dens, Double_t radl, Double_t absl, Float_t* buf, Int_t nwbuf); virtual voidMaterial(Int_t& kmat, const char* name, Double_t a, Double_t z, Double_t dens, Double_t radl, Double_t absl, Double_t* buf, Int_t nwbuf); virtual voidMatrix(Int_t& krot, Double_t thetaX, Double_t phiX, Double_t thetaY, Double_t phiY, Double_t thetaZ, Double_t phiZ); voidTObject::MayNotUse(const char* method) const; virtual voidMedium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Dou",MatchSource.WIKI,root/html532/TVirtualMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCGeometry.html
https://root.cern/root/html532/TVirtualMCGeometry.html:8942,Modifiability,Inherit,Inheritance,8942,"nt_t i) const; virtual Int_tVolId(const char* volName) const; virtual Int_tVolId2Mate(Int_t id) const; virtual const char*VolName(Int_t id) const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TVirtualMCGeometry&operator=(const TVirtualMCGeometry&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TVirtualMCGeometry(). Destructor. void Material(Int_t& kmat, const char* name, Double_t a, Double_t z, Double_t dens, Double_t radl, Double_t absl, Float_t* buf, Int_t nwbuf). detector composition. Define a material; kmat number assigned to the material; name material name; a atomic mass in au; z atomic number; dens density in g/cm3; absl absorption length in cm;; if >=0 it is ignored and the program; calculates it, if <0. -absl is taken; radl radiation length in cm; if >=0 it is ignored and the program; calculates it, if <0. -radl is taken; buf pointer to an array of user words; nwbuf number of user words. void Mixture(Int_t& kmat, const char* name, Float_t* a, Float_t* z, Double_t dens, Int_t nlmat, Float_t* wmat); The same as previous but in double precision; Define mixture or compound; with a number kmat composed by the basic nlmat materials defined; by arrays a, z and wmat. If nlmat > 0 then wmat contains the proportion by; weigh",MatchSource.WIKI,root/html532/TVirtualMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCGeometry.html
https://root.cern/root/html532/TVirtualMCGeometry.html:8955,Modifiability,Inherit,Inherited,8955,"nt_t i) const; virtual Int_tVolId(const char* volName) const; virtual Int_tVolId2Mate(Int_t id) const; virtual const char*VolName(Int_t id) const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TVirtualMCGeometry&operator=(const TVirtualMCGeometry&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TVirtualMCGeometry(). Destructor. void Material(Int_t& kmat, const char* name, Double_t a, Double_t z, Double_t dens, Double_t radl, Double_t absl, Float_t* buf, Int_t nwbuf). detector composition. Define a material; kmat number assigned to the material; name material name; a atomic mass in au; z atomic number; dens density in g/cm3; absl absorption length in cm;; if >=0 it is ignored and the program; calculates it, if <0. -absl is taken; radl radiation length in cm; if >=0 it is ignored and the program; calculates it, if <0. -radl is taken; buf pointer to an array of user words; nwbuf number of user words. void Mixture(Int_t& kmat, const char* name, Float_t* a, Float_t* z, Double_t dens, Int_t nlmat, Float_t* wmat); The same as previous but in double precision; Define mixture or compound; with a number kmat composed by the basic nlmat materials defined; by arrays a, z and wmat. If nlmat > 0 then wmat contains the proportion by; weigh",MatchSource.WIKI,root/html532/TVirtualMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCGeometry.html
https://root.cern/root/html532/TVirtualMCGeometry.html:10695,Performance,perform,performed,10695,"ds; nwbuf number of user words. void Mixture(Int_t& kmat, const char* name, Float_t* a, Float_t* z, Double_t dens, Int_t nlmat, Float_t* wmat); The same as previous but in double precision; Define mixture or compound; with a number kmat composed by the basic nlmat materials defined; by arrays a, z and wmat. If nlmat > 0 then wmat contains the proportion by; weights of each basic material in the mixture. If nlmat < 0 then wmat contains the number of atoms; of a given kind into the molecule of the compound.; In this case, wmat in output is changed to relative; weights. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Float_t* ubuf, Int_t nbuf); The same as previous but in double precision; Define a medium.; kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field:; - ifield = 0 if no magnetic field;; - ifield = -1 if user decision in guswim;; - ifield = 1 if tracking performed with g3rkuta;; - ifield = 2 if tracking; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm); ubuf pointer to an array of user words; nbuf number of user words; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Matrix(Int_t& krot, Double_t thetaX, Double_t phiX, Double_t thetaY, Double_t phiY, Double_t thetaZ, Double_t phiZ); The same as previous but in double precision; Define a rotation matrix; krot rotation matrix number assigned; thetaX polar angle for axis X; phiX azimuthal angle for axis X; thetaY polar angle for axis Y; phiY azimuthal angle for axis Y; thetaZ polar angle for axis Z; phiZ azimuthal angle for axis Z. Int_t Gsvolu(const char* name, const char* shape, Int_t nmed,",MatchSource.WIKI,root/html532/TVirtualMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCGeometry.html
https://root.cern/root/html532/TVirtualMCGeometry.html:11047,Performance,perform,performed,11047,"wmat contains the number of atoms; of a given kind into the molecule of the compound.; In this case, wmat in output is changed to relative; weights. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Float_t* ubuf, Int_t nbuf); The same as previous but in double precision; Define a medium.; kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field:; - ifield = 0 if no magnetic field;; - ifield = -1 if user decision in guswim;; - ifield = 1 if tracking performed with g3rkuta;; - ifield = 2 if tracking; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm); ubuf pointer to an array of user words; nbuf number of user words; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Matrix(Int_t& krot, Double_t thetaX, Double_t phiX, Double_t thetaY, Double_t phiY, Double_t thetaZ, Double_t phiZ); The same as previous but in double precision; Define a rotation matrix; krot rotation matrix number assigned; thetaX polar angle for axis X; phiX azimuthal angle for axis X; thetaY polar angle for axis Y; phiY azimuthal angle for axis Y; thetaZ polar angle for axis Z; phiZ azimuthal angle for axis Z. Int_t Gsvolu(const char* name, const char* shape, Int_t nmed, Double_t* upar, Int_t np). functions from GGEOM. Create a new volume; name Volume name; shape Volume type; nmed Tracking medium number; np Number of shape parameters; upar Vector containing shape parameters; The same as previous but in double precision. void Gsdvn2(const char* name, const char* mother, Int_t ndiv, Int_t iaxis, Double_t c0i, Int_t numed); Create a new volume by dividing an existing one.; It divides a previ",MatchSource.WIKI,root/html532/TVirtualMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCGeometry.html
https://root.cern/root/html532/TVirtualMCGeometry.html:11094,Performance,perform,performed,11094,"wmat contains the number of atoms; of a given kind into the molecule of the compound.; In this case, wmat in output is changed to relative; weights. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Float_t* ubuf, Int_t nbuf); The same as previous but in double precision; Define a medium.; kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field:; - ifield = 0 if no magnetic field;; - ifield = -1 if user decision in guswim;; - ifield = 1 if tracking performed with g3rkuta;; - ifield = 2 if tracking; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm); ubuf pointer to an array of user words; nbuf number of user words; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Matrix(Int_t& krot, Double_t thetaX, Double_t phiX, Double_t thetaY, Double_t phiY, Double_t thetaZ, Double_t phiZ); The same as previous but in double precision; Define a rotation matrix; krot rotation matrix number assigned; thetaX polar angle for axis X; phiX azimuthal angle for axis X; thetaY polar angle for axis Y; phiY azimuthal angle for axis Y; thetaZ polar angle for axis Z; phiZ azimuthal angle for axis Z. Int_t Gsvolu(const char* name, const char* shape, Int_t nmed, Double_t* upar, Int_t np). functions from GGEOM. Create a new volume; name Volume name; shape Volume type; nmed Tracking medium number; np Number of shape parameters; upar Vector containing shape parameters; The same as previous but in double precision. void Gsdvn2(const char* name, const char* mother, Int_t ndiv, Int_t iaxis, Double_t c0i, Int_t numed); Create a new volume by dividing an existing one.; It divides a previ",MatchSource.WIKI,root/html532/TVirtualMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCGeometry.html
https://root.cern/root/html532/TVirtualMCGeometry.html:12913,Performance,perform,performed,12913,"eate a new volume by dividing an existing one.; It divides a previously defined volume; name Volume name; mother Mother volume name; ndiv Number of divisions; iaxis Axis value:; X,Y,Z of CAXIS will be translated to 1,2,3 for IAXIS.; Create a new volume by dividing an existing one.; Divide mother into ndiv divisions called name; along axis iaxis starting at coordinate value c0i.; The new volume created will be medium number numed. void Gsdvt2(const char* name, const char* mother, Double_t step, Int_t iaxis, Double_t c0, Int_t numed, Int_t ndvmx); Create a new volume by dividing an existing one; Divide mother into divisions called name along; axis iaxis in steps of step. If not exactly divisible; will make as many as possible and will center them; with respect to the mother. Divisions will have medium; number numed. If numed is 0, numed of mother is taken.; ndvmx is the expected maximum number of divisions; (If 0, no protection tests are performed in Geant3); Create a new volume by dividing an existing one; Divides mother into divisions called name along; axis iaxis starting at coordinate value c0 with step; size step.; The new volume created will have medium number numed.; If numed is 0, numed of mother is taken.; ndvmx is the expected maximum number of divisions; (If 0, no protection tests are performed in Geant3). void Gspos(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, const char* konly = ""ONLY""); Flag volume name whose contents will have to be ordered; along axis iax, by setting the search flag to -iax; (Geant3 only); Position a volume into an existing one.; It positions a previously defined volume in the mother.; name Volume name; nr Copy number of the volume; mother Mother volume name; x X coord. of the volume in mother ref. sys.; y Y coord. of the volume in mother ref. sys.; z Z coord. of the volume in mother ref. sys.; irot Rotation matrix number w.r.t. mother ref. sys.; konly ONLY/MANY flag. void Gsposp(const",MatchSource.WIKI,root/html532/TVirtualMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCGeometry.html
https://root.cern/root/html532/TVirtualMCGeometry.html:13278,Performance,perform,performed,13278,"Divide mother into ndiv divisions called name; along axis iaxis starting at coordinate value c0i.; The new volume created will be medium number numed. void Gsdvt2(const char* name, const char* mother, Double_t step, Int_t iaxis, Double_t c0, Int_t numed, Int_t ndvmx); Create a new volume by dividing an existing one; Divide mother into divisions called name along; axis iaxis in steps of step. If not exactly divisible; will make as many as possible and will center them; with respect to the mother. Divisions will have medium; number numed. If numed is 0, numed of mother is taken.; ndvmx is the expected maximum number of divisions; (If 0, no protection tests are performed in Geant3); Create a new volume by dividing an existing one; Divides mother into divisions called name along; axis iaxis starting at coordinate value c0 with step; size step.; The new volume created will have medium number numed.; If numed is 0, numed of mother is taken.; ndvmx is the expected maximum number of divisions; (If 0, no protection tests are performed in Geant3). void Gspos(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, const char* konly = ""ONLY""); Flag volume name whose contents will have to be ordered; along axis iax, by setting the search flag to -iax; (Geant3 only); Position a volume into an existing one.; It positions a previously defined volume in the mother.; name Volume name; nr Copy number of the volume; mother Mother volume name; x X coord. of the volume in mother ref. sys.; y Y coord. of the volume in mother ref. sys.; z Z coord. of the volume in mother ref. sys.; irot Rotation matrix number w.r.t. mother ref. sys.; konly ONLY/MANY flag. void Gsposp(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, const char* konly, Double_t* upar, Int_t np); Place a copy of generic volume name with user number; nr inside mother, with its parameters upar(1..np); The same as previous but in double precisi",MatchSource.WIKI,root/html532/TVirtualMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCGeometry.html
https://root.cern/root/html532/TVirtualMCGeometry.html:9196,Safety,detect,detector,9196,"ject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TVirtualMCGeometry&operator=(const TVirtualMCGeometry&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TVirtualMCGeometry(). Destructor. void Material(Int_t& kmat, const char* name, Double_t a, Double_t z, Double_t dens, Double_t radl, Double_t absl, Float_t* buf, Int_t nwbuf). detector composition. Define a material; kmat number assigned to the material; name material name; a atomic mass in au; z atomic number; dens density in g/cm3; absl absorption length in cm;; if >=0 it is ignored and the program; calculates it, if <0. -absl is taken; radl radiation length in cm; if >=0 it is ignored and the program; calculates it, if <0. -radl is taken; buf pointer to an array of user words; nwbuf number of user words. void Mixture(Int_t& kmat, const char* name, Float_t* a, Float_t* z, Double_t dens, Int_t nlmat, Float_t* wmat); The same as previous but in double precision; Define mixture or compound; with a number kmat composed by the basic nlmat materials defined; by arrays a, z and wmat. If nlmat > 0 then wmat contains the proportion by; weights of each basic material in the mixture. If nlmat < 0 then wmat contains the number of atoms; of a given kind into the molecule of the compound.; In this case, wmat in output is changed to relative; weights. void Medium(Int_t& kmed, cons",MatchSource.WIKI,root/html532/TVirtualMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCGeometry.html
https://root.cern/root/html532/TVirtualMCGeometry.html:4199,Security,Hash,Hash,4199,"vt(const char* name, const char* mother, Double_t step, Int_t iaxis, Int_t numed, Int_t ndvmx); virtual voidGsdvt2(const char* name, const char* mother, Double_t step, Int_t iaxis, Double_t c0, Int_t numed, Int_t ndvmx); virtual voidGsord(const char* name, Int_t iax); virtual voidGspos(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, const char* konly = ""ONLY""); virtual voidGsposp(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, const char* konly, Float_t* upar, Int_t np); virtual voidGsposp(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, const char* konly, Double_t* upar, Int_t np); virtual Int_tGsvolu(const char* name, const char* shape, Int_t nmed, Float_t* upar, Int_t np); virtual Int_tGsvolu(const char* name, const char* shape, Int_t nmed, Double_t* upar, Int_t np); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; virtual voidMaterial(Int_t& kmat, const char* name, Double_t a, Double_t z, Double_t dens, Double_t radl, Double_t absl, Float_t* buf, Int_t nwbuf); virtual voidMaterial(Int_t& kmat, const char* name, Double_t a, Double_t z, Double_t dens, Double_t radl, Double_t absl, Double_t* buf, Int_t nwbuf); virtual voidMatrix(Int_t& krot, Double_t thetaX, Double_t phiX, Double_t thetaY, Double_t phiY, Double_t thetaZ, Double_t phi",MatchSource.WIKI,root/html532/TVirtualMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCGeometry.html
https://root.cern/root/html532/TVirtualMCGeometry.html:14482,Security,access,access,14482,"ordered; along axis iax, by setting the search flag to -iax; (Geant3 only); Position a volume into an existing one.; It positions a previously defined volume in the mother.; name Volume name; nr Copy number of the volume; mother Mother volume name; x X coord. of the volume in mother ref. sys.; y Y coord. of the volume in mother ref. sys.; z Z coord. of the volume in mother ref. sys.; irot Rotation matrix number w.r.t. mother ref. sys.; konly ONLY/MANY flag. void Gsposp(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, const char* konly, Double_t* upar, Int_t np); Place a copy of generic volume name with user number; nr inside mother, with its parameters upar(1..np); The same as previous but in double precision. Bool_t GetTransformation(const TString& volumePath, TGeoHMatrix& matrix); Helper function for resolving MANY.; Specify the ONLY volume that overlaps with the; specified MANY and has to be substracted.; (Geant4 only). functions for access to geometry. Return the transformation matrix between the volume specified by; the path volumePath and the top or master volume. Bool_t GetMaterial(const TString& volumeName, TString& name, Int_t& imat, Double_t& a, Double_t& z, Double_t& density, Double_t& radl, Double_t& inter, TArrayD& par); Return the name of the shape (shapeType) and its parameters par; for the volume specified by the path volumePath .; Return the material parameters for the volume specified by; the volumeName. Int_t VolId(const char* volName) const; Return the medium parameters for the volume specified by the; volumeName.; functions for drawing; virtual void DrawOneSpec(const char* name) = 0;; virtual void Gsatt(const char* name, const char* att, Int_t val) = 0;; virtual void Gdraw(const char*,Double_t theta = 30, Double_t phi = 30,; Double_t psi = 0, Double_t u0 = 10, Double_t v0 = 10,; Double_t ul = 0.01, Double_t vl = 0.01) = 0;; Euclid; virtual void WriteEuclid(const char*, const char*, Int_t, Int_t) = 0",MatchSource.WIKI,root/html532/TVirtualMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCGeometry.html
https://root.cern/root/html532/TVirtualMCGeometry.html:7737,Testability,Test,TestBit,7737," voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual Int_tVolDaughterCopyNo(const char* volName, Int_t i) const; virtual const char*VolDaughterName(const char* volName, Int_t i) const; virtual Int_tVolId(const char* volName) const; virtual Int_tVolId2Mate(Int_t id) const; virtual const char*VolName(Int_t id) const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TVirtualMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCGeometry.html
https://root.cern/root/html532/TVirtualMCGeometry.html:7776,Testability,Test,TestBits,7776," voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual Int_tVolDaughterCopyNo(const char* volName, Int_t i) const; virtual const char*VolDaughterName(const char* volName, Int_t i) const; virtual Int_tVolId(const char* volName) const; virtual Int_tVolId2Mate(Int_t id) const; virtual const char*VolName(Int_t id) const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TVirtualMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCGeometry.html
https://root.cern/root/html532/TVirtualMCGeometry.html:12903,Testability,test,tests,12903,"eate a new volume by dividing an existing one.; It divides a previously defined volume; name Volume name; mother Mother volume name; ndiv Number of divisions; iaxis Axis value:; X,Y,Z of CAXIS will be translated to 1,2,3 for IAXIS.; Create a new volume by dividing an existing one.; Divide mother into ndiv divisions called name; along axis iaxis starting at coordinate value c0i.; The new volume created will be medium number numed. void Gsdvt2(const char* name, const char* mother, Double_t step, Int_t iaxis, Double_t c0, Int_t numed, Int_t ndvmx); Create a new volume by dividing an existing one; Divide mother into divisions called name along; axis iaxis in steps of step. If not exactly divisible; will make as many as possible and will center them; with respect to the mother. Divisions will have medium; number numed. If numed is 0, numed of mother is taken.; ndvmx is the expected maximum number of divisions; (If 0, no protection tests are performed in Geant3); Create a new volume by dividing an existing one; Divides mother into divisions called name along; axis iaxis starting at coordinate value c0 with step; size step.; The new volume created will have medium number numed.; If numed is 0, numed of mother is taken.; ndvmx is the expected maximum number of divisions; (If 0, no protection tests are performed in Geant3). void Gspos(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, const char* konly = ""ONLY""); Flag volume name whose contents will have to be ordered; along axis iax, by setting the search flag to -iax; (Geant3 only); Position a volume into an existing one.; It positions a previously defined volume in the mother.; name Volume name; nr Copy number of the volume; mother Mother volume name; x X coord. of the volume in mother ref. sys.; y Y coord. of the volume in mother ref. sys.; z Z coord. of the volume in mother ref. sys.; irot Rotation matrix number w.r.t. mother ref. sys.; konly ONLY/MANY flag. void Gsposp(const",MatchSource.WIKI,root/html532/TVirtualMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCGeometry.html
https://root.cern/root/html532/TVirtualMCGeometry.html:13268,Testability,test,tests,13268,"Divide mother into ndiv divisions called name; along axis iaxis starting at coordinate value c0i.; The new volume created will be medium number numed. void Gsdvt2(const char* name, const char* mother, Double_t step, Int_t iaxis, Double_t c0, Int_t numed, Int_t ndvmx); Create a new volume by dividing an existing one; Divide mother into divisions called name along; axis iaxis in steps of step. If not exactly divisible; will make as many as possible and will center them; with respect to the mother. Divisions will have medium; number numed. If numed is 0, numed of mother is taken.; ndvmx is the expected maximum number of divisions; (If 0, no protection tests are performed in Geant3); Create a new volume by dividing an existing one; Divides mother into divisions called name along; axis iaxis starting at coordinate value c0 with step; size step.; The new volume created will have medium number numed.; If numed is 0, numed of mother is taken.; ndvmx is the expected maximum number of divisions; (If 0, no protection tests are performed in Geant3). void Gspos(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, const char* konly = ""ONLY""); Flag volume name whose contents will have to be ordered; along axis iax, by setting the search flag to -iax; (Geant3 only); Position a volume into an existing one.; It positions a previously defined volume in the mother.; name Volume name; nr Copy number of the volume; mother Mother volume name; x X coord. of the volume in mother ref. sys.; y Y coord. of the volume in mother ref. sys.; z Z coord. of the volume in mother ref. sys.; irot Rotation matrix number w.r.t. mother ref. sys.; konly ONLY/MANY flag. void Gsposp(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, const char* konly, Double_t* upar, Int_t np); Place a copy of generic volume name with user number; nr inside mother, with its parameters upar(1..np); The same as previous but in double precisi",MatchSource.WIKI,root/html532/TVirtualMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCGeometry.html
https://root.cern/root/html532/TVirtualMCGeometry.html:846,Usability,Clear,Clear,846," virtual~TVirtualMCGeometry(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::Get",MatchSource.WIKI,root/html532/TVirtualMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCGeometry.html
https://root.cern/root/html532/TVirtualMCStack.html:490,Availability,avail,available,490,". TVirtualMCStack. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » VMC; » TVirtualMCStack. class TVirtualMCStack: public TObject. Interface to a user defined particles stack. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualMCStack(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetCurrentParentTrackNumber() const; virtual TParticle*GetCurrentTrack() const; virtual Int_tGetCurrentTrackNumber() const; virtual Option_t*TObject::GetDrawOption",MatchSource.WIKI,root/html532/TVirtualMCStack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCStack.html
https://root.cern/root/html532/TVirtualMCStack.html:1334,Availability,Error,Error,1334," virtual~TVirtualMCStack(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetCurrentParentTrackNumber() const; virtual TParticle*GetCurrentTrack() const; virtual Int_tGetCurrentTrackNumber() const; virtual Option_t*TObject::GetDrawOption",MatchSource.WIKI,root/html532/TVirtualMCStack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCStack.html
https://root.cern/root/html532/TVirtualMCStack.html:1463,Availability,error,error,1463," virtual~TVirtualMCStack(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetCurrentParentTrackNumber() const; virtual TParticle*GetCurrentTrack() const; virtual Int_tGetCurrentTrackNumber() const; virtual Option_t*TObject::GetDrawOption",MatchSource.WIKI,root/html532/TVirtualMCStack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCStack.html
https://root.cern/root/html532/TVirtualMCStack.html:1547,Availability,error,error,1547," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetCurrentParentTrackNumber() const; virtual TParticle*GetCurrentTrack() const; virtual Int_tGetCurrentTrackNumber() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual Int_tGetNprimary() const; virtual Int_tGetNtrack() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObj",MatchSource.WIKI,root/html532/TVirtualMCStack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCStack.html
https://root.cern/root/html532/TVirtualMCStack.html:6472,Energy Efficiency,energy,energy,6472,"evel, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TVirtualMCStack(); {}. void PushTrack(Int_t toBeDone, Int_t parent, Int_t pdg, Double_t px, Double_t py, Double_t pz, Double_t e, Double_t vx, Double_t vy, Double_t vz, Double_t tof, Double_t polx, Double_t poly, Double_t polz, TMCProcess mech, Int_t& ntr, Double_t weight, Int_t is). Methods for stacking. Create a new particle and push into stack;; toBeDone - 1 if particles should go to tracking, 0 otherwise; parent - number of the parent track, -1 if track is primary; pdg - PDG encoding; px, py, pz - particle momentum [GeV/c]; e - total energy [GeV]; vx, vy, vz - position [cm]; tof - time of flight [s]; polx, poly, polz - polarization; mech - creator process VMC code; ntr - track number (is filled by the stack; weight - particle weight; is - generation status code. TParticle* PopPrimaryForTracking(Int_t i); The stack has to provide two pop mechanisms:; The first pop mechanism required.; Pop all particles with toBeDone = 1, both primaries and seconadies; The second pop mechanism required.; Pop only primary particles with toBeDone = 1, stacking of secondaries; is done by MC. void SetCurrentTrack(Int_t trackNumber). Set methods. Set the current track number. Int_t GetNtrack() const. Get methods. Total number of tracks. Int_t GetNprimary() const; Total number of primary tracks. TParticle* GetCurrentTrack() const; Current track particle. Int_t GetCurrentTrackNumber() const; Current track number. Int_t GetCurrentParentTrackNumber() const; Number of the parent of the current track. » Last changed: root/vmc:$Id: TVirtualMC",MatchSource.WIKI,root/html532/TVirtualMCStack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCStack.html
https://root.cern/root/html532/TVirtualMCStack.html:311,Integrability,Interface,Interface,311,". TVirtualMCStack. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » VMC; » TVirtualMCStack. class TVirtualMCStack: public TObject. Interface to a user defined particles stack. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualMCStack(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetCurrentParentTrackNumber() const; virtual TParticle*GetCurrentTrack() const; virtual Int_tGetCurrentTrackNumber() const; virtual Option_t*TObject::GetDrawOption",MatchSource.WIKI,root/html532/TVirtualMCStack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCStack.html
https://root.cern/root/html532/TVirtualMCStack.html:2630,Modifiability,Inherit,InheritsFrom,2630,"oidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetCurrentParentTrackNumber() const; virtual TParticle*GetCurrentTrack() const; virtual Int_tGetCurrentTrackNumber() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual Int_tGetNprimary() const; virtual Int_tGetNtrack() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TOb",MatchSource.WIKI,root/html532/TVirtualMCStack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCStack.html
https://root.cern/root/html532/TVirtualMCStack.html:2696,Modifiability,Inherit,InheritsFrom,2696,"irtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetCurrentParentTrackNumber() const; virtual TParticle*GetCurrentTrack() const; virtual Int_tGetCurrentTrackNumber() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual Int_tGetNprimary() const; virtual Int_tGetNtrack() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TVirtualMCStack&operato",MatchSource.WIKI,root/html532/TVirtualMCStack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCStack.html
https://root.cern/root/html532/TVirtualMCStack.html:5850,Modifiability,Inherit,Inheritance,5850,"TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TVirtualMCStack(); {}. void PushTrack(Int_t toBeDone, Int_t parent, Int_t pdg, Double_t px, Double_t py, Double_t pz, Double_t e, Double_t vx, Double_t vy, Double_t vz, Double_t tof, Double_t polx, Double_t poly, Double_t polz, TMCProcess mech, Int_t& ntr, Double_t weight, Int_t is). Methods for stacking. Create a new particle and push into stack;; toBeDone - 1 if particles should go to tracking, 0 otherwise; parent - number of the parent track, -1 if track is primary; pdg - PDG encoding; px, py, pz - particle momentum [GeV/c]; e - total energy [GeV]; vx, vy, vz - position [cm]; tof - time of flight [s]; polx, poly, polz - polarization; mech - creator process VMC code; ntr - track number (is filled by the stack; weight - particle weight; is - generation status code. TParticle* PopPrimaryForTracking(Int_t i); The stack has to provide two pop mechanisms:; The first pop mechanism required.; Pop all particles with toBeDone = 1, both prima",MatchSource.WIKI,root/html532/TVirtualMCStack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCStack.html
https://root.cern/root/html532/TVirtualMCStack.html:5863,Modifiability,Inherit,Inherited,5863,"TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TVirtualMCStack(); {}. void PushTrack(Int_t toBeDone, Int_t parent, Int_t pdg, Double_t px, Double_t py, Double_t pz, Double_t e, Double_t vx, Double_t vy, Double_t vz, Double_t tof, Double_t polx, Double_t poly, Double_t polz, TMCProcess mech, Int_t& ntr, Double_t weight, Int_t is). Methods for stacking. Create a new particle and push into stack;; toBeDone - 1 if particles should go to tracking, 0 otherwise; parent - number of the parent track, -1 if track is primary; pdg - PDG encoding; px, py, pz - particle momentum [GeV/c]; e - total energy [GeV]; vx, vy, vz - position [cm]; tof - time of flight [s]; polx, poly, polz - polarization; mech - creator process VMC code; ntr - track number (is filled by the stack; weight - particle weight; is - generation status code. TParticle* PopPrimaryForTracking(Int_t i); The stack has to provide two pop mechanisms:; The first pop mechanism required.; Pop all particles with toBeDone = 1, both prima",MatchSource.WIKI,root/html532/TVirtualMCStack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCStack.html
https://root.cern/root/html532/TVirtualMCStack.html:2520,Security,Hash,Hash,2520,"ObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetCurrentParentTrackNumber() const; virtual TParticle*GetCurrentTrack() const; virtual Int_tGetCurrentTrackNumber() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual Int_tGetNprimary() const; virtual Int_tGetNtrack() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator ",MatchSource.WIKI,root/html532/TVirtualMCStack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCStack.html
https://root.cern/root/html532/TVirtualMCStack.html:5060,Testability,Test,TestBit,5060,"lete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TVirtualMCStack&operator=(const TVirtualMCStack&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual TParticle*PopNextTrack(Int_t& itrack); virtual TParticle*PopPrimaryForTracking(Int_t i); virtual voidTObject::Print(Option_t* option = """") const; virtual voidPushTrack(Int_t toBeDone, Int_t parent, Int_t pdg, Double_t px, Double_t py, Double_t pz, Double_t e, Double_t vx, Double_t vy, Double_t vz, Double_t tof, Double_t polx, Double_t poly, Double_t polz, TMCProcess mech, Int_t& ntr, Double_t weight, Int_t is); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetCurrentTrack(Int_t trackNumber); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TVirtualMCStack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCStack.html
https://root.cern/root/html532/TVirtualMCStack.html:5099,Testability,Test,TestBits,5099,"lete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TVirtualMCStack&operator=(const TVirtualMCStack&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual TParticle*PopNextTrack(Int_t& itrack); virtual TParticle*PopPrimaryForTracking(Int_t i); virtual voidTObject::Print(Option_t* option = """") const; virtual voidPushTrack(Int_t toBeDone, Int_t parent, Int_t pdg, Double_t px, Double_t py, Double_t pz, Double_t e, Double_t vx, Double_t vy, Double_t vz, Double_t tof, Double_t polx, Double_t poly, Double_t polz, TMCProcess mech, Int_t& ntr, Double_t weight, Int_t is); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetCurrentTrack(Int_t trackNumber); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TVirtualMCStack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCStack.html
https://root.cern/root/html532/TVirtualMCStack.html:794,Usability,Clear,Clear,794," virtual~TVirtualMCStack(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetCurrentParentTrackNumber() const; virtual TParticle*GetCurrentTrack() const; virtual Int_tGetCurrentTrackNumber() const; virtual Option_t*TObject::GetDrawOption",MatchSource.WIKI,root/html532/TVirtualMCStack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMCStack.html
https://root.cern/root/html532/TVirtualMonitoringReader.html:1417,Availability,Error,Error,1417," TVirtualMonitoringReader(const char* = """"); TVirtualMonitoringReader(const TVirtualMonitoringReader&); virtual~TVirtualMonitoringReader(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteMap(TMap*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidDumpResult(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() cons",MatchSource.WIKI,root/html532/TVirtualMonitoringReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMonitoringReader.html
https://root.cern/root/html532/TVirtualMonitoringReader.html:1546,Availability,error,error,1546,"VirtualMonitoringReader(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteMap(TMap*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidDumpResult(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidGetLastValues(const char*, const char*, const char*, const char*, Bool_t = kFALSE); virtual TMap*GetMap(); virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual voidGetValues(const char*, const char*, const char*,",MatchSource.WIKI,root/html532/TVirtualMonitoringReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMonitoringReader.html
https://root.cern/root/html532/TVirtualMonitoringReader.html:1630,Availability,error,error,1630,"rtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteMap(TMap*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidDumpResult(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidGetLastValues(const char*, const char*, const char*, const char*, Bool_t = kFALSE); virtual TMap*GetMap(); virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual voidGetValues(const char*, const char*, const char*, const char*, Long_t, Long_t, Bool_t = kFALSE); virtual Bool_tTObject::HandleTimer(T",MatchSource.WIKI,root/html532/TVirtualMonitoringReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMonitoringReader.html
https://root.cern/root/html532/TVirtualMonitoringReader.html:388,Energy Efficiency,Monitor,Monitoring,388,". TVirtualMonitoringReader. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualMonitoringReader. class TVirtualMonitoringReader: public TNamed. TVirtualMonitoring. Provides the interface for externel Monitoring. Function Members (Methods); public:. TVirtualMonitoringReader(const char* = """"); TVirtualMonitoringReader(const TVirtualMonitoringReader&); virtual~TVirtualMonitoringReader(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteMap(TMap*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidDumpResult(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() cons",MatchSource.WIKI,root/html532/TVirtualMonitoringReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMonitoringReader.html
https://root.cern/root/html532/TVirtualMonitoringReader.html:365,Integrability,interface,interface,365,". TVirtualMonitoringReader. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualMonitoringReader. class TVirtualMonitoringReader: public TNamed. TVirtualMonitoring. Provides the interface for externel Monitoring. Function Members (Methods); public:. TVirtualMonitoringReader(const char* = """"); TVirtualMonitoringReader(const TVirtualMonitoringReader&); virtual~TVirtualMonitoringReader(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteMap(TMap*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidDumpResult(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() cons",MatchSource.WIKI,root/html532/TVirtualMonitoringReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMonitoringReader.html
https://root.cern/root/html532/TVirtualMonitoringReader.html:2781,Modifiability,Inherit,InheritsFrom,2781,"tual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidGetLastValues(const char*, const char*, const char*, const char*, Bool_t = kFALSE); virtual TMap*GetMap(); virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual voidGetValues(const char*, const char*, const char*, const char*, Long_t, Long_t, Bool_t = kFALSE); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObje",MatchSource.WIKI,root/html532/TVirtualMonitoringReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMonitoringReader.html
https://root.cern/root/html532/TVirtualMonitoringReader.html:2847,Modifiability,Inherit,InheritsFrom,2847,"t::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidGetLastValues(const char*, const char*, const char*, const char*, Bool_t = kFALSE); virtual TMap*GetMap(); virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual voidGetValues(const char*, const char*, const char*, const char*, Long_t, Long_t, Bool_t = kFALSE); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TVirtualMonitoringReader&",MatchSource.WIKI,root/html532/TVirtualMonitoringReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMonitoringReader.html
https://root.cern/root/html532/TVirtualMonitoringReader.html:6008,Modifiability,Inherit,Inheritance,6008,"r& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualMonitoringWriter& operator=(const TVirtualMonitoringReader& ). TVirtualMonitoringReader(const char* = """"); { }. virtual ~TVirtualMonitoringReader(); { }. void DumpResult(); { MayNotUse(""DumpResult""); }. void GetValues(const char* , const char* , const char* , const char* , Long_t , Long_t , Bool_t = kFALSE); { MayNotUse(""GetValues""); }. void GetLastValues(const char* , const char* , const char* , const char* , Bool_t = kFALSE); { MayNotUse(""GetLastValues""); }. void ProxyValues(const char* , const char* , const char* , const char* , Long_t , Long_t , Long_t ); { MayNotUse(""ProxyValues""); }. TMap * GetMap(); { MayNotUse(""GetMap""); return 0; }. void DeleteMap(TMap* ); { MayNotUse(""DeleteMap""); }. » Author: Andreas-Joachim Peters 15/05/2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TVirtualMonitoring.h 23209 2008-04-14 13:25:09Z rdm $ » Last generated: 2011-11-03 20:24; This page ha",MatchSource.WIKI,root/html532/TVirtualMonitoringReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMonitoringReader.html
https://root.cern/root/html532/TVirtualMonitoringReader.html:6021,Modifiability,Inherit,Inherited,6021,"r& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualMonitoringWriter& operator=(const TVirtualMonitoringReader& ). TVirtualMonitoringReader(const char* = """"); { }. virtual ~TVirtualMonitoringReader(); { }. void DumpResult(); { MayNotUse(""DumpResult""); }. void GetValues(const char* , const char* , const char* , const char* , Long_t , Long_t , Bool_t = kFALSE); { MayNotUse(""GetValues""); }. void GetLastValues(const char* , const char* , const char* , const char* , Bool_t = kFALSE); { MayNotUse(""GetLastValues""); }. void ProxyValues(const char* , const char* , const char* , const char* , Long_t , Long_t , Long_t ); { MayNotUse(""ProxyValues""); }. TMap * GetMap(); { MayNotUse(""GetMap""); return 0; }. void DeleteMap(TMap* ); { MayNotUse(""DeleteMap""); }. » Author: Andreas-Joachim Peters 15/05/2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TVirtualMonitoring.h 23209 2008-04-14 13:25:09Z rdm $ » Last generated: 2011-11-03 20:24; This page ha",MatchSource.WIKI,root/html532/TVirtualMonitoringReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMonitoringReader.html
https://root.cern/root/html532/TVirtualMonitoringReader.html:2671,Security,Hash,Hash,2671,"nt(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidGetLastValues(const char*, const char*, const char*, const char*, Bool_t = kFALSE); virtual TMap*GetMap(); virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual voidGetValues(const char*, const char*, const char*, const char*, Long_t, Long_t, Bool_t = kFALSE); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator ne",MatchSource.WIKI,root/html532/TVirtualMonitoringReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMonitoringReader.html
https://root.cern/root/html532/TVirtualMonitoringReader.html:5132,Testability,Test,TestBit,5132,"Object::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TVirtualMonitoringReader&operator=(const TVirtualMonitoringReader&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual voidProxyValues(const char*, const char*, const char*, const char*, Long_t, Long_t, Long_t); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TVirtualMonitoringReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMonitoringReader.html
https://root.cern/root/html532/TVirtualMonitoringReader.html:5171,Testability,Test,TestBits,5171,"Object::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TVirtualMonitoringReader&operator=(const TVirtualMonitoringReader&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual voidProxyValues(const char*, const char*, const char*, const char*, Long_t, Long_t, Long_t); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TVirtualMonitoringReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMonitoringReader.html
https://root.cern/root/html532/TVirtualMonitoringReader.html:818,Usability,Clear,Clear,818," TVirtualMonitoringReader(const char* = """"); TVirtualMonitoringReader(const TVirtualMonitoringReader&); virtual~TVirtualMonitoringReader(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteMap(TMap*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidDumpResult(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() cons",MatchSource.WIKI,root/html532/TVirtualMonitoringReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMonitoringReader.html
https://root.cern/root/html532/TVirtualMonitoringWriter.html:1346,Availability,Error,Error,1346," TVirtualMonitoringWriter(); TVirtualMonitoringWriter(const char* name, Double_t value); virtual~TVirtualMonitoringWriter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::Get",MatchSource.WIKI,root/html532/TVirtualMonitoringWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMonitoringWriter.html
https://root.cern/root/html532/TVirtualMonitoringWriter.html:1475,Availability,error,error,1475,"oringWriter(const char* name, Double_t value); virtual~TVirtualMonitoringWriter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObj",MatchSource.WIKI,root/html532/TVirtualMonitoringWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMonitoringWriter.html
https://root.cern/root/html532/TVirtualMonitoringWriter.html:1559,Availability,error,error,1559,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(",MatchSource.WIKI,root/html532/TVirtualMonitoringWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMonitoringWriter.html
https://root.cern/root/html532/TVirtualMonitoringWriter.html:388,Energy Efficiency,Monitor,Monitoring,388,". TVirtualMonitoringWriter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualMonitoringWriter. class TVirtualMonitoringWriter: public TNamed. TVirtualMonitoring. Provides the interface for externel Monitoring. Function Members (Methods); public:. TVirtualMonitoringWriter(); TVirtualMonitoringWriter(const char* name, Double_t value); virtual~TVirtualMonitoringWriter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::Get",MatchSource.WIKI,root/html532/TVirtualMonitoringWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMonitoringWriter.html
https://root.cern/root/html532/TVirtualMonitoringWriter.html:6423,Energy Efficiency,monitor,monitor,6423,"t); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TVirtualMonitoringWriter(const TVirtualMonitoringWriter&); TVirtualMonitoringWriter&operator=(const TVirtualMonitoringWriter&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; TList*fTmpOpenPhasesTo store open phases when there is not yet an object. private:. Double_tfValuedouble monitor value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualMonitoringWriter(const TVirtualMonitoringWriter& ). TVirtualMonitoringWriter& operator=(const TVirtualMonitoringWriter& ). TVirtualMonitoringWriter(); { }. TVirtualMonitoringWriter(const char* name, Double_t value); { }. virtual ~TVirtualMonitoringWriter(); { if (fTmpOpenPhases) delete fTmpOpenPhases; }. Bool_t SendFileCloseEvent(TFile* ); TFile related info. In general they are gathered and sent only sometimes as summaries. { MayNotUse(""SendFileCloseEvent""); return kFALSE; }. Bool_t SendFileReadProgress(TFile* ); { MayNotUse(""SendFileReadProgress""); return kFALSE; }. Bool_t SendFileWriteProgress(TFile* ); { MayNotUse(""SendFileWriteProgress""); return kFALSE; }. Bool_t SendParameters(TList* , const char* = 0); { MayNotUse(""SendParameters""); return kFALSE; }. Bool_t SendInfoTime(); { MayNotUse(""SendInfoTime""); return kFALSE; }. Bool_t SendInfoUser(const char* = 0); { MayN",MatchSource.WIKI,root/html532/TVirtualMonitoringWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMonitoringWriter.html
https://root.cern/root/html532/TVirtualMonitoringWriter.html:365,Integrability,interface,interface,365,". TVirtualMonitoringWriter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualMonitoringWriter. class TVirtualMonitoringWriter: public TNamed. TVirtualMonitoring. Provides the interface for externel Monitoring. Function Members (Methods); public:. TVirtualMonitoringWriter(); TVirtualMonitoringWriter(const char* name, Double_t value); virtual~TVirtualMonitoringWriter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::Get",MatchSource.WIKI,root/html532/TVirtualMonitoringWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMonitoringWriter.html
https://root.cern/root/html532/TVirtualMonitoringWriter.html:2483,Modifiability,Inherit,InheritsFrom,2483,"rtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObje",MatchSource.WIKI,root/html532/TVirtualMonitoringWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMonitoringWriter.html
https://root.cern/root/html532/TVirtualMonitoringWriter.html:2549,Modifiability,Inherit,InheritsFrom,2549,"_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Pain",MatchSource.WIKI,root/html532/TVirtualMonitoringWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMonitoringWriter.html
https://root.cern/root/html532/TVirtualMonitoringWriter.html:6452,Modifiability,Inherit,Inheritance,6452," char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TVirtualMonitoringWriter(const TVirtualMonitoringWriter&); TVirtualMonitoringWriter&operator=(const TVirtualMonitoringWriter&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; TList*fTmpOpenPhasesTo store open phases when there is not yet an object. private:. Double_tfValuedouble monitor value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualMonitoringWriter(const TVirtualMonitoringWriter& ). TVirtualMonitoringWriter& operator=(const TVirtualMonitoringWriter& ). TVirtualMonitoringWriter(); { }. TVirtualMonitoringWriter(const char* name, Double_t value); { }. virtual ~TVirtualMonitoringWriter(); { if (fTmpOpenPhases) delete fTmpOpenPhases; }. Bool_t SendFileCloseEvent(TFile* ); TFile related info. In general they are gathered and sent only sometimes as summaries. { MayNotUse(""SendFileCloseEvent""); return kFALSE; }. Bool_t SendFileReadProgress(TFile* ); { MayNotUse(""SendFileReadProgress""); return kFALSE; }. Bool_t SendFileWriteProgress(TFile* ); { MayNotUse(""SendFileWriteProgress""); return kFALSE; }. Bool_t SendParameters(TList* , const char* = 0); { MayNotUse(""SendParameters""); return kFALSE; }. Bool_t SendInfoTime(); { MayNotUse(""SendInfoTime""); return kFALSE; }. Bool_t SendInfoUser(const char* = 0); { MayNotUse(""SendInfoUser""); return kFALSE; }. Bool_t SendInfoDes",MatchSource.WIKI,root/html532/TVirtualMonitoringWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMonitoringWriter.html
https://root.cern/root/html532/TVirtualMonitoringWriter.html:6465,Modifiability,Inherit,Inherited,6465," char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TVirtualMonitoringWriter(const TVirtualMonitoringWriter&); TVirtualMonitoringWriter&operator=(const TVirtualMonitoringWriter&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; TList*fTmpOpenPhasesTo store open phases when there is not yet an object. private:. Double_tfValuedouble monitor value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualMonitoringWriter(const TVirtualMonitoringWriter& ). TVirtualMonitoringWriter& operator=(const TVirtualMonitoringWriter& ). TVirtualMonitoringWriter(); { }. TVirtualMonitoringWriter(const char* name, Double_t value); { }. virtual ~TVirtualMonitoringWriter(); { if (fTmpOpenPhases) delete fTmpOpenPhases; }. Bool_t SendFileCloseEvent(TFile* ); TFile related info. In general they are gathered and sent only sometimes as summaries. { MayNotUse(""SendFileCloseEvent""); return kFALSE; }. Bool_t SendFileReadProgress(TFile* ); { MayNotUse(""SendFileReadProgress""); return kFALSE; }. Bool_t SendFileWriteProgress(TFile* ); { MayNotUse(""SendFileWriteProgress""); return kFALSE; }. Bool_t SendParameters(TList* , const char* = 0); { MayNotUse(""SendParameters""); return kFALSE; }. Bool_t SendInfoTime(); { MayNotUse(""SendInfoTime""); return kFALSE; }. Bool_t SendInfoUser(const char* = 0); { MayNotUse(""SendInfoUser""); return kFALSE; }. Bool_t SendInfoDes",MatchSource.WIKI,root/html532/TVirtualMonitoringWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMonitoringWriter.html
https://root.cern/root/html532/TVirtualMonitoringWriter.html:2373,Security,Hash,Hash,2373,"st char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator ne",MatchSource.WIKI,root/html532/TVirtualMonitoringWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMonitoringWriter.html
https://root.cern/root/html532/TVirtualMonitoringWriter.html:5289,Testability,Test,TestBit,5289,"TObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tSendFileCloseEvent(TFile*); virtual Bool_tSendFileOpenProgress(TFile*, TList*, const char*, Bool_t = kFALSE); virtual Bool_tSendFileReadProgress(TFile*); virtual Bool_tSendFileWriteProgress(TFile*); virtual Bool_tSendInfoDescription(const char*); virtual Bool_tSendInfoStatus(const char*); virtual Bool_tSendInfoTime(); virtual Bool_tSendInfoUser(const char* = 0); virtual Bool_tSendParameters(TList*, const char* = 0); virtual Bool_tSendProcessingProgress(Double_t, Double_t, Bool_t = kFALSE); virtual Bool_tSendProcessingStatus(const char*, Bool_t = kFALSE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetLogLevel(const char* = ""WARNING""); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidVerbose(Bool_t); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TVirtualMonitoringWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMonitoringWriter.html
https://root.cern/root/html532/TVirtualMonitoringWriter.html:5328,Testability,Test,TestBits,5328,"TObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tSendFileCloseEvent(TFile*); virtual Bool_tSendFileOpenProgress(TFile*, TList*, const char*, Bool_t = kFALSE); virtual Bool_tSendFileReadProgress(TFile*); virtual Bool_tSendFileWriteProgress(TFile*); virtual Bool_tSendInfoDescription(const char*); virtual Bool_tSendInfoStatus(const char*); virtual Bool_tSendInfoTime(); virtual Bool_tSendInfoUser(const char* = 0); virtual Bool_tSendParameters(TList*, const char* = 0); virtual Bool_tSendProcessingProgress(Double_t, Double_t, Bool_t = kFALSE); virtual Bool_tSendProcessingStatus(const char*, Bool_t = kFALSE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetLogLevel(const char* = ""WARNING""); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidVerbose(Bool_t); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TVirtualMonitoringWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMonitoringWriter.html
https://root.cern/root/html532/TVirtualMonitoringWriter.html:803,Usability,Clear,Clear,803," TVirtualMonitoringWriter(); TVirtualMonitoringWriter(const char* name, Double_t value); virtual~TVirtualMonitoringWriter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::Get",MatchSource.WIKI,root/html532/TVirtualMonitoringWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMonitoringWriter.html
https://root.cern/root/html532/TVirtualMutex.html:401,Availability,avail,available,401,". TVirtualMutex. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualMutex. class TVirtualMutex: public TObject. TVirtualMutex. This class implements a mutex interface. The actual work is done via; TMutex which is available as soon as the thread library is loaded. and. TLockGuard. This class provides mutex resource management in a guaranteed and; exception safe way. Use like this:; {; TLockGuard guard(mutex);; ... // do something; }; when guard goes out of scope the mutex is unlocked in the TLockGuard; destructor. The exception mechanism takes care of calling the dtors; of local objects so it is exception safe. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualMutex(); voidTObject::AbstractMethod(const char* method) const; Int_tAcquire(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual Int_tCleanUp(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* ",MatchSource.WIKI,root/html532/TVirtualMutex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMutex.html
https://root.cern/root/html532/TVirtualMutex.html:940,Availability,avail,available,940,". TVirtualMutex. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualMutex. class TVirtualMutex: public TObject. TVirtualMutex. This class implements a mutex interface. The actual work is done via; TMutex which is available as soon as the thread library is loaded. and. TLockGuard. This class provides mutex resource management in a guaranteed and; exception safe way. Use like this:; {; TLockGuard guard(mutex);; ... // do something; }; when guard goes out of scope the mutex is unlocked in the TLockGuard; destructor. The exception mechanism takes care of calling the dtors; of local objects so it is exception safe. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualMutex(); voidTObject::AbstractMethod(const char* method) const; Int_tAcquire(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual Int_tCleanUp(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* ",MatchSource.WIKI,root/html532/TVirtualMutex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMutex.html
https://root.cern/root/html532/TVirtualMutex.html:1822,Availability,Error,Error,1822," virtual~TVirtualMutex(); voidTObject::AbstractMethod(const char* method) const; Int_tAcquire(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual Int_tCleanUp(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* ",MatchSource.WIKI,root/html532/TVirtualMutex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMutex.html
https://root.cern/root/html532/TVirtualMutex.html:1951,Availability,error,error,1951," virtual~TVirtualMutex(); voidTObject::AbstractMethod(const char* method) const; Int_tAcquire(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual Int_tCleanUp(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* ",MatchSource.WIKI,root/html532/TVirtualMutex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMutex.html
https://root.cern/root/html532/TVirtualMutex.html:2035,Availability,error,error,2035," method) const; Int_tAcquire(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual Int_tCleanUp(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual TVirtualMutex*Factory(Bool_t = kFALSE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsF",MatchSource.WIKI,root/html532/TVirtualMutex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMutex.html
https://root.cern/root/html532/TVirtualMutex.html:6064,Deployability,Release,Release,6064,"f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Int_tTryLock(); virtual Int_tUnLock(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualMutex(); { }. Int_t Lock(). Int_t TryLock(). Int_t UnLock(). Int_t CleanUp(). Int_t Acquire(); { return Lock(); }. Int_t Release(); { return UnLock(); }. TVirtualMutex * Factory(Bool_t = kFALSE). TLockGuard& operator=(const TVirtualMutex& ). » Author: Fons Rademakers 14/07/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TVirtualMutex.h 25230 2008-08-25 15:22:04Z rdm $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TVirtualMutex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMutex.html
https://root.cern/root/html532/TVirtualMutex.html:345,Integrability,interface,interface,345,". TVirtualMutex. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualMutex. class TVirtualMutex: public TObject. TVirtualMutex. This class implements a mutex interface. The actual work is done via; TMutex which is available as soon as the thread library is loaded. and. TLockGuard. This class provides mutex resource management in a guaranteed and; exception safe way. Use like this:; {; TLockGuard guard(mutex);; ... // do something; }; when guard goes out of scope the mutex is unlocked in the TLockGuard; destructor. The exception mechanism takes care of calling the dtors; of local objects so it is exception safe. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualMutex(); voidTObject::AbstractMethod(const char* method) const; Int_tAcquire(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual Int_tCleanUp(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* ",MatchSource.WIKI,root/html532/TVirtualMutex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMutex.html
https://root.cern/root/html532/TVirtualMutex.html:2963,Modifiability,Inherit,InheritsFrom,2963,"l voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual TVirtualMutex*Factory(Bool_t = kFALSE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual Int_tLock(); virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[]",MatchSource.WIKI,root/html532/TVirtualMutex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMutex.html
https://root.cern/root/html532/TVirtualMutex.html:3029,Modifiability,Inherit,InheritsFrom,3029,"error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual TVirtualMutex*Factory(Bool_t = kFALSE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual Int_tLock(); virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TV",MatchSource.WIKI,root/html532/TVirtualMutex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMutex.html
https://root.cern/root/html532/TVirtualMutex.html:5849,Modifiability,Inherit,Inheritance,5849,"f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Int_tTryLock(); virtual Int_tUnLock(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualMutex(); { }. Int_t Lock(). Int_t TryLock(). Int_t UnLock(). Int_t CleanUp(). Int_t Acquire(); { return Lock(); }. Int_t Release(); { return UnLock(); }. TVirtualMutex * Factory(Bool_t = kFALSE). TLockGuard& operator=(const TVirtualMutex& ). » Author: Fons Rademakers 14/07/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TVirtualMutex.h 25230 2008-08-25 15:22:04Z rdm $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TVirtualMutex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMutex.html
https://root.cern/root/html532/TVirtualMutex.html:5862,Modifiability,Inherit,Inherited,5862,"f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Int_tTryLock(); virtual Int_tUnLock(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualMutex(); { }. Int_t Lock(). Int_t TryLock(). Int_t UnLock(). Int_t CleanUp(). Int_t Acquire(); { return Lock(); }. Int_t Release(); { return UnLock(); }. TVirtualMutex * Factory(Bool_t = kFALSE). TLockGuard& operator=(const TVirtualMutex& ). » Author: Fons Rademakers 14/07/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TVirtualMutex.h 25230 2008-08-25 15:22:04Z rdm $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TVirtualMutex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMutex.html
https://root.cern/root/html532/TVirtualMutex.html:444,Performance,load,loaded,444,". TVirtualMutex. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualMutex. class TVirtualMutex: public TObject. TVirtualMutex. This class implements a mutex interface. The actual work is done via; TMutex which is available as soon as the thread library is loaded. and. TLockGuard. This class provides mutex resource management in a guaranteed and; exception safe way. Use like this:; {; TLockGuard guard(mutex);; ... // do something; }; when guard goes out of scope the mutex is unlocked in the TLockGuard; destructor. The exception mechanism takes care of calling the dtors; of local objects so it is exception safe. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualMutex(); voidTObject::AbstractMethod(const char* method) const; Int_tAcquire(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual Int_tCleanUp(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* ",MatchSource.WIKI,root/html532/TVirtualMutex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMutex.html
https://root.cern/root/html532/TVirtualMutex.html:546,Safety,safe,safe,546,". TVirtualMutex. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualMutex. class TVirtualMutex: public TObject. TVirtualMutex. This class implements a mutex interface. The actual work is done via; TMutex which is available as soon as the thread library is loaded. and. TLockGuard. This class provides mutex resource management in a guaranteed and; exception safe way. Use like this:; {; TLockGuard guard(mutex);; ... // do something; }; when guard goes out of scope the mutex is unlocked in the TLockGuard; destructor. The exception mechanism takes care of calling the dtors; of local objects so it is exception safe. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualMutex(); voidTObject::AbstractMethod(const char* method) const; Int_tAcquire(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual Int_tCleanUp(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* ",MatchSource.WIKI,root/html532/TVirtualMutex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMutex.html
https://root.cern/root/html532/TVirtualMutex.html:800,Safety,safe,safe,800,". TVirtualMutex. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualMutex. class TVirtualMutex: public TObject. TVirtualMutex. This class implements a mutex interface. The actual work is done via; TMutex which is available as soon as the thread library is loaded. and. TLockGuard. This class provides mutex resource management in a guaranteed and; exception safe way. Use like this:; {; TLockGuard guard(mutex);; ... // do something; }; when guard goes out of scope the mutex is unlocked in the TLockGuard; destructor. The exception mechanism takes care of calling the dtors; of local objects so it is exception safe. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualMutex(); voidTObject::AbstractMethod(const char* method) const; Int_tAcquire(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual Int_tCleanUp(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* ",MatchSource.WIKI,root/html532/TVirtualMutex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMutex.html
https://root.cern/root/html532/TVirtualMutex.html:2853,Security,Hash,Hash,2853,"har* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual TVirtualMutex*Factory(Bool_t = kFALSE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual Int_tLock(); virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); vo",MatchSource.WIKI,root/html532/TVirtualMutex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMutex.html
https://root.cern/root/html532/TVirtualMutex.html:5012,Testability,Test,TestBit,5012,"::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TVirtualMutex&operator=(const TVirtualMutex&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); Int_tRelease(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Int_tTryLock(); virtual Int_tUnLock(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TVirtualMutex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMutex.html
https://root.cern/root/html532/TVirtualMutex.html:5051,Testability,Test,TestBits,5051,"::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TVirtualMutex&operator=(const TVirtualMutex&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); Int_tRelease(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Int_tTryLock(); virtual Int_tUnLock(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TVirtualMutex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMutex.html
https://root.cern/root/html532/TVirtualMutex.html:1282,Usability,Clear,Clear,1282," virtual~TVirtualMutex(); voidTObject::AbstractMethod(const char* method) const; Int_tAcquire(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual Int_tCleanUp(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* ",MatchSource.WIKI,root/html532/TVirtualMutex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualMutex.html
https://root.cern/root/html532/TVirtualObject.html:275,Integrability,Wrap,Wrapper,275,". TVirtualObject. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TVirtualObject. class TVirtualObject. TVirtualObject. Wrapper around an object and giving indirect access to its content; even if the object is not of a class in the Cint/Reflex dictionary. Function Members (Methods); public:. TVirtualObject(TClass* cl); ~TVirtualObject(); TClass*GetClass() const; void*GetObject() const. private:. TVirtualObject(const TVirtualObject&); TVirtualObject&operator=(const TVirtualObject&). Data Members; public:. TClassReffClass; void*fObject. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualObject(const TVirtualObject& ). TVirtualObject & operator=(const TVirtualObject& ). TVirtualObject(TClass* cl); { }. ~TVirtualObject(); { if (fClass) fClass->Destructor(fObject); }. TClass * GetClass() const; { return fClass; }. void * GetObject() const; { return fObject; }. » Author: Philippe Canal July, 2008 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id: TVirtualObject.h 30902 2009-10-28 15:13:43Z pcanal $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TVirtualObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualObject.html
https://root.cern/root/html532/TVirtualObject.html:710,Modifiability,Inherit,Inheritance,710,". TVirtualObject. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TVirtualObject. class TVirtualObject. TVirtualObject. Wrapper around an object and giving indirect access to its content; even if the object is not of a class in the Cint/Reflex dictionary. Function Members (Methods); public:. TVirtualObject(TClass* cl); ~TVirtualObject(); TClass*GetClass() const; void*GetObject() const. private:. TVirtualObject(const TVirtualObject&); TVirtualObject&operator=(const TVirtualObject&). Data Members; public:. TClassReffClass; void*fObject. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualObject(const TVirtualObject& ). TVirtualObject & operator=(const TVirtualObject& ). TVirtualObject(TClass* cl); { }. ~TVirtualObject(); { if (fClass) fClass->Destructor(fObject); }. TClass * GetClass() const; { return fClass; }. void * GetObject() const; { return fObject; }. » Author: Philippe Canal July, 2008 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id: TVirtualObject.h 30902 2009-10-28 15:13:43Z pcanal $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TVirtualObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualObject.html
https://root.cern/root/html532/TVirtualObject.html:723,Modifiability,Inherit,Inherited,723,". TVirtualObject. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TVirtualObject. class TVirtualObject. TVirtualObject. Wrapper around an object and giving indirect access to its content; even if the object is not of a class in the Cint/Reflex dictionary. Function Members (Methods); public:. TVirtualObject(TClass* cl); ~TVirtualObject(); TClass*GetClass() const; void*GetObject() const. private:. TVirtualObject(const TVirtualObject&); TVirtualObject&operator=(const TVirtualObject&). Data Members; public:. TClassReffClass; void*fObject. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualObject(const TVirtualObject& ). TVirtualObject & operator=(const TVirtualObject& ). TVirtualObject(TClass* cl); { }. ~TVirtualObject(); { if (fClass) fClass->Destructor(fObject); }. TClass * GetClass() const; { return fClass; }. void * GetObject() const; { return fObject; }. » Author: Philippe Canal July, 2008 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id: TVirtualObject.h 30902 2009-10-28 15:13:43Z pcanal $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TVirtualObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualObject.html
https://root.cern/root/html532/TVirtualObject.html:320,Security,access,access,320,". TVirtualObject. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TVirtualObject. class TVirtualObject. TVirtualObject. Wrapper around an object and giving indirect access to its content; even if the object is not of a class in the Cint/Reflex dictionary. Function Members (Methods); public:. TVirtualObject(TClass* cl); ~TVirtualObject(); TClass*GetClass() const; void*GetObject() const. private:. TVirtualObject(const TVirtualObject&); TVirtualObject&operator=(const TVirtualObject&). Data Members; public:. TClassReffClass; void*fObject. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualObject(const TVirtualObject& ). TVirtualObject & operator=(const TVirtualObject& ). TVirtualObject(TClass* cl); { }. ~TVirtualObject(); { if (fClass) fClass->Destructor(fObject); }. TClass * GetClass() const; { return fClass; }. void * GetObject() const; { return fObject; }. » Author: Philippe Canal July, 2008 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id: TVirtualObject.h 30902 2009-10-28 15:13:43Z pcanal $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TVirtualObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualObject.html
https://root.cern/root/html532/TVirtualPacketizer.html:2038,Availability,Error,Error,2038," virtual~TVirtualPacketizer(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAddProcessed(TSlave*, TProofProgressStatus*, Double_t, TList**); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dum",MatchSource.WIKI,root/html532/TVirtualPacketizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPacketizer.html
https://root.cern/root/html532/TVirtualPacketizer.html:2167,Availability,error,error,2167,"zer(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAddProcessed(TSlave*, TProofProgressStatus*, Double_t, TList**); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetActiveWorkers(); Long64_tGetBytesRead() const; TList*GetConfigParams(Bool_t steal = kFALSE); Double_tGetCumProcTime() const; virtual Float_tGetCurrentRate(Bool_t& all); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tGetEntriesProcessed() const; virtual Int_tGetEstEntriesProcessed(Float_t, Long64_t& ent, Long64_t& bytes, Long64_t& calls); TList*GetFailedPackets(); virtual const char*TObject::GetIconName() const; Float_tGetInitTime() const; virtual const char*TObject::GetName() const; virtual TDSetElement*GetNextPacket(TSlave* sl, TMessage* r); virtual char*TObject::GetObje",MatchSource.WIKI,root/html532/TVirtualPacketizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPacketizer.html
https://root.cern/root/html532/TVirtualPacketizer.html:2251,Availability,error,error,2251,"sed(TSlave*, TProofProgressStatus*, Double_t, TList**); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetActiveWorkers(); Long64_tGetBytesRead() const; TList*GetConfigParams(Bool_t steal = kFALSE); Double_tGetCumProcTime() const; virtual Float_tGetCurrentRate(Bool_t& all); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tGetEntriesProcessed() const; virtual Int_tGetEstEntriesProcessed(Float_t, Long64_t& ent, Long64_t& bytes, Long64_t& calls); TList*GetFailedPackets(); virtual const char*TObject::GetIconName() const; Float_tGetInitTime() const; virtual const char*TObject::GetName() const; virtual TDSetElement*GetNextPacket(TSlave* sl, TMessage* r); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Opt",MatchSource.WIKI,root/html532/TVirtualPacketizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPacketizer.html
https://root.cern/root/html532/TVirtualPacketizer.html:7418,Deployability,configurat,configuration,7418,"; virtual Bool_tHandleTimer(TTimer* timer); voidTObject::MakeZombie(); voidoperator=(const TVirtualPacketizer&). Data Members; public:. enum EUseEstOpt { kEstOff; kEstCurrent; kEstAverage; };; enum EStatusBits { kIsInitializing; kIsDone; kIsTree; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfAWLastFillWhether to fill the last measurement; Int_tfActWrksLastActive workers at fProcTimeLast; Long_tfCircNCircularity; TNtupleD*fCircProgKeeps circular info for ""instantenous""; TList*fConfigParamsList of configuration parameters; TStringfDataSetName of the dataset being processed (for dataset-driven runs); Float_tfEffSessLastNumber of effective sessions at fProcTimeLast; Float_tfEvtRateLastEvt rate at fProcTimeLast; TList*fFailedPacketsa list of packets that failed while processing; Float_tfInitTimetime before processing; Float_tfMBsReadLastMBs read at fProcTimeLast; Double_tfMaxPacketTimemaximum packet time; Double_tfMinPacketTimeminimum packet time; Float_tfProcTimetime since start of processing; Float_tfProcTimeLastTime of the last measurement; TTimer*fProgressprogress updates timer; TNtuple*fProgressPerf{Active workers, evt rate, MBs read} as a function of processing time; TProofProgressStatus*fProgressStatuspointer to status in the player.; Float_tfReportPeriodTime between reports if nothing changes (estimated proc time / 100); TMap*fSlaveStatsslave status, keyed by correspondig TSlave; TTimefStartTimetime offset; Bool_tfStopTermination of Process() requested?; Float_tfTimeUpdttime between updates; Long64_tfTotalEntriestotal number of entries to be distributed;; TVirtualPacketizer::EUseEstOptfUseEstOptControl usage of estimated values for the progress info; Bool_tfValidConstructed properly?. Class Charts. Inheritance; Inherited Members; Include",MatchSource.WIKI,root/html532/TVirtualPacketizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPacketizer.html
https://root.cern/root/html532/TVirtualPacketizer.html:7997,Deployability,update,updates,7997,"; virtual Bool_tHandleTimer(TTimer* timer); voidTObject::MakeZombie(); voidoperator=(const TVirtualPacketizer&). Data Members; public:. enum EUseEstOpt { kEstOff; kEstCurrent; kEstAverage; };; enum EStatusBits { kIsInitializing; kIsDone; kIsTree; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfAWLastFillWhether to fill the last measurement; Int_tfActWrksLastActive workers at fProcTimeLast; Long_tfCircNCircularity; TNtupleD*fCircProgKeeps circular info for ""instantenous""; TList*fConfigParamsList of configuration parameters; TStringfDataSetName of the dataset being processed (for dataset-driven runs); Float_tfEffSessLastNumber of effective sessions at fProcTimeLast; Float_tfEvtRateLastEvt rate at fProcTimeLast; TList*fFailedPacketsa list of packets that failed while processing; Float_tfInitTimetime before processing; Float_tfMBsReadLastMBs read at fProcTimeLast; Double_tfMaxPacketTimemaximum packet time; Double_tfMinPacketTimeminimum packet time; Float_tfProcTimetime since start of processing; Float_tfProcTimeLastTime of the last measurement; TTimer*fProgressprogress updates timer; TNtuple*fProgressPerf{Active workers, evt rate, MBs read} as a function of processing time; TProofProgressStatus*fProgressStatuspointer to status in the player.; Float_tfReportPeriodTime between reports if nothing changes (estimated proc time / 100); TMap*fSlaveStatsslave status, keyed by correspondig TSlave; TTimefStartTimetime offset; Bool_tfStopTermination of Process() requested?; Float_tfTimeUpdttime between updates; Long64_tfTotalEntriestotal number of entries to be distributed;; TVirtualPacketizer::EUseEstOptfUseEstOptControl usage of estimated values for the progress info; Bool_tfValidConstructed properly?. Class Charts. Inheritance; Inherited Members; Include",MatchSource.WIKI,root/html532/TVirtualPacketizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPacketizer.html
https://root.cern/root/html532/TVirtualPacketizer.html:8428,Deployability,update,updates,8428,"igParamsList of configuration parameters; TStringfDataSetName of the dataset being processed (for dataset-driven runs); Float_tfEffSessLastNumber of effective sessions at fProcTimeLast; Float_tfEvtRateLastEvt rate at fProcTimeLast; TList*fFailedPacketsa list of packets that failed while processing; Float_tfInitTimetime before processing; Float_tfMBsReadLastMBs read at fProcTimeLast; Double_tfMaxPacketTimemaximum packet time; Double_tfMinPacketTimeminimum packet time; Float_tfProcTimetime since start of processing; Float_tfProcTimeLastTime of the last measurement; TTimer*fProgressprogress updates timer; TNtuple*fProgressPerf{Active workers, evt rate, MBs read} as a function of processing time; TProofProgressStatus*fProgressStatuspointer to status in the player.; Float_tfReportPeriodTime between reports if nothing changes (estimated proc time / 100); TMap*fSlaveStatsslave status, keyed by correspondig TSlave; TTimefStartTimetime offset; Bool_tfStopTermination of Process() requested?; Float_tfTimeUpdttime between updates; Long64_tfTotalEntriestotal number of entries to be distributed;; TVirtualPacketizer::EUseEstOptfUseEstOptControl usage of estimated values for the progress info; Bool_tfValidConstructed properly?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualPacketizer(TList* input, TProofProgressStatus* st = 0); Constructor. ~TVirtualPacketizer(); Destructor. Long64_t GetEntries(Bool_t tree, TDSetElement* e); Get entries. TDSetElement * GetNextPacket(TSlave* sl, TMessage* r); Get next packet. void StopProcess(Bool_t abort, Bool_t stoptimer = kFALSE); Stop process. TDSetElement* CreateNewPacket(TDSetElement* base, Long64_t first, Long64_t num); Creates a new TDSetElement from from base packet starting from; the first entry with num entries.; The function returns a new created objects which have to be deleted. Bool_t HandleTimer(TTimer* timer); Send progress message to client. void SetInitTime(); Set the initializati",MatchSource.WIKI,root/html532/TVirtualPacketizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPacketizer.html
https://root.cern/root/html532/TVirtualPacketizer.html:9344,Integrability,message,message,9344,"fStartTimetime offset; Bool_tfStopTermination of Process() requested?; Float_tfTimeUpdttime between updates; Long64_tfTotalEntriestotal number of entries to be distributed;; TVirtualPacketizer::EUseEstOptfUseEstOptControl usage of estimated values for the progress info; Bool_tfValidConstructed properly?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualPacketizer(TList* input, TProofProgressStatus* st = 0); Constructor. ~TVirtualPacketizer(); Destructor. Long64_t GetEntries(Bool_t tree, TDSetElement* e); Get entries. TDSetElement * GetNextPacket(TSlave* sl, TMessage* r); Get next packet. void StopProcess(Bool_t abort, Bool_t stoptimer = kFALSE); Stop process. TDSetElement* CreateNewPacket(TDSetElement* base, Long64_t first, Long64_t num); Creates a new TDSetElement from from base packet starting from; the first entry with num entries.; The function returns a new created objects which have to be deleted. Bool_t HandleTimer(TTimer* timer); Send progress message to client. void SetInitTime(); Set the initialization time. TVirtualPacketizer(TList* input, TProofProgressStatus* st = 0). void operator=(const TVirtualPacketizer& ). Bool_t IsValid() const; { return fValid; }. Long64_t GetEntriesProcessed() const; { return (fProgressStatus? fProgressStatus->GetEntries() : 0); }. Int_t GetEstEntriesProcessed(Float_t , Long64_t& ent, Long64_t& bytes, Long64_t& calls); { ent = GetEntriesProcessed(); bytes = GetBytesRead(); calls = GetReadCalls(); return 0; }. Float_t GetCurrentRate(Bool_t& all); { all = kTRUE; return (fProgressStatus? fProgressStatus->GetCurrentRate() : 0.); }. Long64_t GetTotalEntries() const; { return fTotalEntries; }. TList * GetFailedPackets(); { return fFailedPackets; }. void SetFailedPackets(TList* list); { fFailedPackets = list; }. Long64_t GetBytesRead() const; { return (fProgressStatus? fProgressStatus->GetBytesRead() : 0); }. Long64_t GetReadCalls() const; { return (fProgressStatus? fProgressStatus->Get",MatchSource.WIKI,root/html532/TVirtualPacketizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPacketizer.html
https://root.cern/root/html532/TVirtualPacketizer.html:3713,Modifiability,Inherit,InheritsFrom,3713,"al Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tGetEntriesProcessed() const; virtual Int_tGetEstEntriesProcessed(Float_t, Long64_t& ent, Long64_t& bytes, Long64_t& calls); TList*GetFailedPackets(); virtual const char*TObject::GetIconName() const; Float_tGetInitTime() const; virtual const char*TObject::GetName() const; virtual TDSetElement*GetNextPacket(TSlave* sl, TMessage* r); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Float_tGetProcTime() const; TNtuple*GetProgressPerf(Bool_t steal = kFALSE); Long64_tGetReadCalls() const; TMap*GetSlaveStats() const; TProofProgressStatus*GetStatus(); virtual const char*TObject::GetTitle() const; Long64_tGetTotalEntries() const; virtual UInt_tTObject::GetUniqueID() const; virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tIsValid() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidMarkBad(TSlave*, TProofProgressStatus*, TList**); voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject:",MatchSource.WIKI,root/html532/TVirtualPacketizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPacketizer.html
https://root.cern/root/html532/TVirtualPacketizer.html:3779,Modifiability,Inherit,InheritsFrom,3779,"GetDtorOnly(); Long64_tGetEntriesProcessed() const; virtual Int_tGetEstEntriesProcessed(Float_t, Long64_t& ent, Long64_t& bytes, Long64_t& calls); TList*GetFailedPackets(); virtual const char*TObject::GetIconName() const; Float_tGetInitTime() const; virtual const char*TObject::GetName() const; virtual TDSetElement*GetNextPacket(TSlave* sl, TMessage* r); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Float_tGetProcTime() const; TNtuple*GetProgressPerf(Bool_t steal = kFALSE); Long64_tGetReadCalls() const; TMap*GetSlaveStats() const; TProofProgressStatus*GetStatus(); virtual const char*TObject::GetTitle() const; Long64_tGetTotalEntries() const; virtual UInt_tTObject::GetUniqueID() const; virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tIsValid() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidMarkBad(TSlave*, TProofProgressStatus*, TList**); voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](s",MatchSource.WIKI,root/html532/TVirtualPacketizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPacketizer.html
https://root.cern/root/html532/TVirtualPacketizer.html:7418,Modifiability,config,configuration,7418,"; virtual Bool_tHandleTimer(TTimer* timer); voidTObject::MakeZombie(); voidoperator=(const TVirtualPacketizer&). Data Members; public:. enum EUseEstOpt { kEstOff; kEstCurrent; kEstAverage; };; enum EStatusBits { kIsInitializing; kIsDone; kIsTree; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfAWLastFillWhether to fill the last measurement; Int_tfActWrksLastActive workers at fProcTimeLast; Long_tfCircNCircularity; TNtupleD*fCircProgKeeps circular info for ""instantenous""; TList*fConfigParamsList of configuration parameters; TStringfDataSetName of the dataset being processed (for dataset-driven runs); Float_tfEffSessLastNumber of effective sessions at fProcTimeLast; Float_tfEvtRateLastEvt rate at fProcTimeLast; TList*fFailedPacketsa list of packets that failed while processing; Float_tfInitTimetime before processing; Float_tfMBsReadLastMBs read at fProcTimeLast; Double_tfMaxPacketTimemaximum packet time; Double_tfMinPacketTimeminimum packet time; Float_tfProcTimetime since start of processing; Float_tfProcTimeLastTime of the last measurement; TTimer*fProgressprogress updates timer; TNtuple*fProgressPerf{Active workers, evt rate, MBs read} as a function of processing time; TProofProgressStatus*fProgressStatuspointer to status in the player.; Float_tfReportPeriodTime between reports if nothing changes (estimated proc time / 100); TMap*fSlaveStatsslave status, keyed by correspondig TSlave; TTimefStartTimetime offset; Bool_tfStopTermination of Process() requested?; Float_tfTimeUpdttime between updates; Long64_tfTotalEntriestotal number of entries to be distributed;; TVirtualPacketizer::EUseEstOptfUseEstOptControl usage of estimated values for the progress info; Bool_tfValidConstructed properly?. Class Charts. Inheritance; Inherited Members; Include",MatchSource.WIKI,root/html532/TVirtualPacketizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPacketizer.html
https://root.cern/root/html532/TVirtualPacketizer.html:8648,Modifiability,Inherit,Inheritance,8648,"hat failed while processing; Float_tfInitTimetime before processing; Float_tfMBsReadLastMBs read at fProcTimeLast; Double_tfMaxPacketTimemaximum packet time; Double_tfMinPacketTimeminimum packet time; Float_tfProcTimetime since start of processing; Float_tfProcTimeLastTime of the last measurement; TTimer*fProgressprogress updates timer; TNtuple*fProgressPerf{Active workers, evt rate, MBs read} as a function of processing time; TProofProgressStatus*fProgressStatuspointer to status in the player.; Float_tfReportPeriodTime between reports if nothing changes (estimated proc time / 100); TMap*fSlaveStatsslave status, keyed by correspondig TSlave; TTimefStartTimetime offset; Bool_tfStopTermination of Process() requested?; Float_tfTimeUpdttime between updates; Long64_tfTotalEntriestotal number of entries to be distributed;; TVirtualPacketizer::EUseEstOptfUseEstOptControl usage of estimated values for the progress info; Bool_tfValidConstructed properly?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualPacketizer(TList* input, TProofProgressStatus* st = 0); Constructor. ~TVirtualPacketizer(); Destructor. Long64_t GetEntries(Bool_t tree, TDSetElement* e); Get entries. TDSetElement * GetNextPacket(TSlave* sl, TMessage* r); Get next packet. void StopProcess(Bool_t abort, Bool_t stoptimer = kFALSE); Stop process. TDSetElement* CreateNewPacket(TDSetElement* base, Long64_t first, Long64_t num); Creates a new TDSetElement from from base packet starting from; the first entry with num entries.; The function returns a new created objects which have to be deleted. Bool_t HandleTimer(TTimer* timer); Send progress message to client. void SetInitTime(); Set the initialization time. TVirtualPacketizer(TList* input, TProofProgressStatus* st = 0). void operator=(const TVirtualPacketizer& ). Bool_t IsValid() const; { return fValid; }. Long64_t GetEntriesProcessed() const; { return (fProgressStatus? fProgressStatus->GetEntries() : 0); }. Int_t ",MatchSource.WIKI,root/html532/TVirtualPacketizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPacketizer.html
https://root.cern/root/html532/TVirtualPacketizer.html:8661,Modifiability,Inherit,Inherited,8661,"hat failed while processing; Float_tfInitTimetime before processing; Float_tfMBsReadLastMBs read at fProcTimeLast; Double_tfMaxPacketTimemaximum packet time; Double_tfMinPacketTimeminimum packet time; Float_tfProcTimetime since start of processing; Float_tfProcTimeLastTime of the last measurement; TTimer*fProgressprogress updates timer; TNtuple*fProgressPerf{Active workers, evt rate, MBs read} as a function of processing time; TProofProgressStatus*fProgressStatuspointer to status in the player.; Float_tfReportPeriodTime between reports if nothing changes (estimated proc time / 100); TMap*fSlaveStatsslave status, keyed by correspondig TSlave; TTimefStartTimetime offset; Bool_tfStopTermination of Process() requested?; Float_tfTimeUpdttime between updates; Long64_tfTotalEntriestotal number of entries to be distributed;; TVirtualPacketizer::EUseEstOptfUseEstOptControl usage of estimated values for the progress info; Bool_tfValidConstructed properly?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualPacketizer(TList* input, TProofProgressStatus* st = 0); Constructor. ~TVirtualPacketizer(); Destructor. Long64_t GetEntries(Bool_t tree, TDSetElement* e); Get entries. TDSetElement * GetNextPacket(TSlave* sl, TMessage* r); Get next packet. void StopProcess(Bool_t abort, Bool_t stoptimer = kFALSE); Stop process. TDSetElement* CreateNewPacket(TDSetElement* base, Long64_t first, Long64_t num); Creates a new TDSetElement from from base packet starting from; the first entry with num entries.; The function returns a new created objects which have to be deleted. Bool_t HandleTimer(TTimer* timer); Send progress message to client. void SetInitTime(); Set the initialization time. TVirtualPacketizer(TList* input, TProofProgressStatus* st = 0). void operator=(const TVirtualPacketizer& ). Bool_t IsValid() const; { return fValid; }. Long64_t GetEntriesProcessed() const; { return (fProgressStatus? fProgressStatus->GetEntries() : 0); }. Int_t ",MatchSource.WIKI,root/html532/TVirtualPacketizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPacketizer.html
https://root.cern/root/html532/TVirtualPacketizer.html:363,Performance,load,load,363,". TVirtualPacketizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TVirtualPacketizer. class TVirtualPacketizer: public TObject. TVirtualPacketizer. The packetizer is a load balancing object created for each query.; It generates packets to be processed on PROOF worker servers.; A packet is an event range (begin entry and number of entries) or; object range (first object and number of objects) in a TTree; (entries) or a directory (objects) in a file.; Packets are generated taking into account the performance of the; remote machine, the time it took to process a previous packet on; the remote machine, the locality of the database files, etc. TVirtualPacketizer includes common parts of PROOF packetizers.; Look in subclasses for details.; The default packetizer is TPacketizerAdaptive.; To use an alternative one, for instance - the TPacketizer, call:; proof->SetParameter(""PROOF_Packetizer"", ""TPacketizer"");. Function Members (Methods); public:. virtual~TVirtualPacketizer(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAddProcessed(TSlave*, TProofProgressStatus*, Double_t, TList**); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dum",MatchSource.WIKI,root/html532/TVirtualPacketizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPacketizer.html
https://root.cern/root/html532/TVirtualPacketizer.html:695,Performance,perform,performance,695,". TVirtualPacketizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TVirtualPacketizer. class TVirtualPacketizer: public TObject. TVirtualPacketizer. The packetizer is a load balancing object created for each query.; It generates packets to be processed on PROOF worker servers.; A packet is an event range (begin entry and number of entries) or; object range (first object and number of objects) in a TTree; (entries) or a directory (objects) in a file.; Packets are generated taking into account the performance of the; remote machine, the time it took to process a previous packet on; the remote machine, the locality of the database files, etc. TVirtualPacketizer includes common parts of PROOF packetizers.; Look in subclasses for details.; The default packetizer is TPacketizerAdaptive.; To use an alternative one, for instance - the TPacketizer, call:; proof->SetParameter(""PROOF_Packetizer"", ""TPacketizer"");. Function Members (Methods); public:. virtual~TVirtualPacketizer(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAddProcessed(TSlave*, TProofProgressStatus*, Double_t, TList**); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dum",MatchSource.WIKI,root/html532/TVirtualPacketizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPacketizer.html
https://root.cern/root/html532/TVirtualPacketizer.html:5780,Safety,abort,abort,5780,"ject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetFailedPackets(TList* list); virtual voidSetInitTime(); static voidTObject::SetObjectStat(Bool_t stat); voidSetProgressStatus(TProofProgressStatus* st); voidSetTotalEntries(Long64_t ent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStopProcess(Bool_t abort, Bool_t stoptimer = kFALSE); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TVirtualPacketizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPacketizer.html
https://root.cern/root/html532/TVirtualPacketizer.html:8997,Safety,abort,abort,8997,"er; TNtuple*fProgressPerf{Active workers, evt rate, MBs read} as a function of processing time; TProofProgressStatus*fProgressStatuspointer to status in the player.; Float_tfReportPeriodTime between reports if nothing changes (estimated proc time / 100); TMap*fSlaveStatsslave status, keyed by correspondig TSlave; TTimefStartTimetime offset; Bool_tfStopTermination of Process() requested?; Float_tfTimeUpdttime between updates; Long64_tfTotalEntriestotal number of entries to be distributed;; TVirtualPacketizer::EUseEstOptfUseEstOptControl usage of estimated values for the progress info; Bool_tfValidConstructed properly?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualPacketizer(TList* input, TProofProgressStatus* st = 0); Constructor. ~TVirtualPacketizer(); Destructor. Long64_t GetEntries(Bool_t tree, TDSetElement* e); Get entries. TDSetElement * GetNextPacket(TSlave* sl, TMessage* r); Get next packet. void StopProcess(Bool_t abort, Bool_t stoptimer = kFALSE); Stop process. TDSetElement* CreateNewPacket(TDSetElement* base, Long64_t first, Long64_t num); Creates a new TDSetElement from from base packet starting from; the first entry with num entries.; The function returns a new created objects which have to be deleted. Bool_t HandleTimer(TTimer* timer); Send progress message to client. void SetInitTime(); Set the initialization time. TVirtualPacketizer(TList* input, TProofProgressStatus* st = 0). void operator=(const TVirtualPacketizer& ). Bool_t IsValid() const; { return fValid; }. Long64_t GetEntriesProcessed() const; { return (fProgressStatus? fProgressStatus->GetEntries() : 0); }. Int_t GetEstEntriesProcessed(Float_t , Long64_t& ent, Long64_t& bytes, Long64_t& calls); { ent = GetEntriesProcessed(); bytes = GetBytesRead(); calls = GetReadCalls(); return 0; }. Float_t GetCurrentRate(Bool_t& all); { all = kTRUE; return (fProgressStatus? fProgressStatus->GetCurrentRate() : 0.); }. Long64_t GetTotalEntries() const; { ret",MatchSource.WIKI,root/html532/TVirtualPacketizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPacketizer.html
https://root.cern/root/html532/TVirtualPacketizer.html:3603,Security,Hash,Hash,3603,"igParams(Bool_t steal = kFALSE); Double_tGetCumProcTime() const; virtual Float_tGetCurrentRate(Bool_t& all); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tGetEntriesProcessed() const; virtual Int_tGetEstEntriesProcessed(Float_t, Long64_t& ent, Long64_t& bytes, Long64_t& calls); TList*GetFailedPackets(); virtual const char*TObject::GetIconName() const; Float_tGetInitTime() const; virtual const char*TObject::GetName() const; virtual TDSetElement*GetNextPacket(TSlave* sl, TMessage* r); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Float_tGetProcTime() const; TNtuple*GetProgressPerf(Bool_t steal = kFALSE); Long64_tGetReadCalls() const; TMap*GetSlaveStats() const; TProofProgressStatus*GetStatus(); virtual const char*TObject::GetTitle() const; Long64_tGetTotalEntries() const; virtual UInt_tTObject::GetUniqueID() const; virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tIsValid() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidMarkBad(TSlave*, TProofProgressStatus*, TList**); voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr)",MatchSource.WIKI,root/html532/TVirtualPacketizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPacketizer.html
https://root.cern/root/html532/TVirtualPacketizer.html:5975,Testability,Test,TestBit,5975,"ject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetFailedPackets(TList* list); virtual voidSetInitTime(); static voidTObject::SetObjectStat(Bool_t stat); voidSetProgressStatus(TProofProgressStatus* st); voidSetTotalEntries(Long64_t ent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStopProcess(Bool_t abort, Bool_t stoptimer = kFALSE); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TVirtualPacketizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPacketizer.html
https://root.cern/root/html532/TVirtualPacketizer.html:6014,Testability,Test,TestBits,6014,"ject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetFailedPackets(TList* list); virtual voidSetInitTime(); static voidTObject::SetObjectStat(Bool_t stat); voidSetProgressStatus(TProofProgressStatus* st); voidSetTotalEntries(Long64_t ent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStopProcess(Bool_t abort, Bool_t stoptimer = kFALSE); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TVirtualPacketizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPacketizer.html
https://root.cern/root/html532/TVirtualPacketizer.html:1498,Usability,Clear,Clear,1498," virtual~TVirtualPacketizer(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAddProcessed(TSlave*, TProofProgressStatus*, Double_t, TList**); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dum",MatchSource.WIKI,root/html532/TVirtualPacketizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPacketizer.html
https://root.cern/root/html532/TVirtualPad.html:565,Availability,avail,available,565,". TVirtualPad. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualPad. class TVirtualPad: public TObject, public TAttLine, public TAttFill, public TAttPad, public TQObject. TVirtualPad is an abstract base class for the Pad and Canvas classes. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualPad(); virtual voidAbsCoordinates(Bool_t set); virtual Double_tAbsPixeltoX(Int_t px); virtual Double_tAbsPixeltoY(Int_t py); voidTObject::AbstractMethod(const char* method) const; virtual voidAddExec(const char* name, const char* command); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual TVirtualPad*cd(Int_t subpadnumber = 0); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual voidCloseToolTip(TObject* tip); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); vi",MatchSource.WIKI,root/html532/TVirtualPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPad.html
https://root.cern/root/html532/TVirtualPad.html:4467,Availability,Error,Error,4467,"(const char* signal); voidTQObject::Emit(const char* signal, Long_t* paramArr); voidTQObject::Emit(const char* signal, const char* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Double_tGetAbsHNDC() const; virtual Double_tGetAbsWNDC() const; virtual Double_tGetAbsXlowNDC() const; virtual Double_tGetAbsYlowNDC() const; Float_tTAttPad::GetAfile() const; virtual Double_tGetAspectRatio() const; Float_tTAttPad::GetAstat() const; virtual Short_tGetBorderMode() const; virtual Short_tGetBorderSize() const; Float_tTAttPad::GetBottomMargin() const; virtual TCanvas*GetCanvas() const; virtual Int_tGetCanvasID()",MatchSource.WIKI,root/html532/TVirtualPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPad.html
https://root.cern/root/html532/TVirtualPad.html:4596,Availability,error,error,4596,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Double_tGetAbsHNDC() const; virtual Double_tGetAbsWNDC() const; virtual Double_tGetAbsXlowNDC() const; virtual Double_tGetAbsYlowNDC() const; Float_tTAttPad::GetAfile() const; virtual Double_tGetAspectRatio() const; Float_tTAttPad::GetAstat() const; virtual Short_tGetBorderMode() const; virtual Short_tGetBorderSize() const; Float_tTAttPad::GetBottomMargin() const; virtual TCanvas*GetCanvas() const; virtual Int_tGetCanvasID() const; virtual TCanvasImp*GetCanvasImp() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOn",MatchSource.WIKI,root/html532/TVirtualPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPad.html
https://root.cern/root/html532/TVirtualPad.html:4680,Availability,error,error,4680,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Double_tGetAbsHNDC() const; virtual Double_tGetAbsWNDC() const; virtual Double_tGetAbsXlowNDC() const; virtual Double_tGetAbsYlowNDC() const; Float_tTAttPad::GetAfile() const; virtual Double_tGetAspectRatio() const; Float_tTAttPad::GetAstat() const; virtual Short_tGetBorderMode() const; virtual Short_tGetBorderSize() const; Float_tTAttPad::GetBottomMargin() const; virtual TCanvas*GetCanvas() const; virtual Int_tGetCanvasID() const; virtual TCanvasImp*GetCanvasImp() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetEvent() const; virtual Int_tGetEventX() const; virtual Int_tGe",MatchSource.WIKI,root/html532/TVirtualPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPad.html
https://root.cern/root/html532/TVirtualPad.html:28334,Deployability,Update,Update,28334,"t value = 1). void SetPad(const char* name, const char* title, Double_t xlow, Double_t ylow, Double_t xup, Double_t yup, Color_t color = 35, Short_t bordersize = 5, Short_t bordermode = -1). void SetAttFillPS(Color_t color, Style_t style). void SetAttLinePS(Color_t color, Style_t style, Width_t lwidth). void SetAttMarkerPS(Color_t color, Style_t style, Size_t msize). void SetAttTextPS(Int_t align, Float_t angle, Color_t color, Style_t font, Float_t tsize). void SetName(const char* name). void SetSelected(TObject* obj). void SetTicks(Int_t valuex = 1, Int_t valuey = 1). void SetTickx(Int_t value = 1). void SetTicky(Int_t value = 1). void SetTitle(const char* title = """"). void SetTheta(Double_t theta = 30). void SetPhi(Double_t phi = 30). void SetToolTipText(const char* text, Long_t delayms = 1000). void SetVertical(Bool_t vert = kTRUE). void SetView(TView* view = 0). void SetViewer3D(TVirtualViewer3D* ); {}. TObject * WaitPrimitive(const char* pname = """", const char* emode = """"). void Update(). Int_t UtoAbsPixel(Double_t u) const. Int_t VtoAbsPixel(Double_t v) const. Int_t UtoPixel(Double_t u) const. Int_t VtoPixel(Double_t v) const. Int_t XtoAbsPixel(Double_t x) const. Int_t YtoAbsPixel(Double_t y) const. Double_t XtoPad(Double_t x) const. Double_t YtoPad(Double_t y) const. Int_t XtoPixel(Double_t x) const. Int_t YtoPixel(Double_t y) const. TObject * CreateToolTip(const TBox* b, const char* text, Long_t delayms). void DeleteToolTip(TObject* tip). void ResetToolTip(TObject* tip). void CloseToolTip(TObject* tip). TVirtualViewer3D * GetViewer3D(Option_t* type = """"). Bool_t HasViewer3D() const. void ReleaseViewer3D(Option_t* type = """"). Int_t GetGLDevice(). void SetCopyGLDevice(Bool_t copy). » Author: Rene Brun 05/12/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TVirtualPad.h 41495 2011-10-20 09:54:31Z rdm $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regardin",MatchSource.WIKI,root/html532/TVirtualPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPad.html
https://root.cern/root/html532/TVirtualPad.html:10104,Integrability,Message,Message,10104,"tual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tIsBatch() const; Bool_tIsBeingResized() const; virtual Bool_tIsEditable() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tIsModified() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsRetained() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; virtual Bool_tIsVertical() const; Bool_tTObject::IsZombie() const; static voidTQObject::LoadRQ_OBJECT(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidModified(Bool_t flag = 1); virtual voidTAttLine::Modify(); virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Bool_tOpaqueMoving() const; virtual Bool_tOpaqueResizing() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TObject&TObject::operator=(const TObject& rhs); static TVirtualPad*&Pad(); virtual Bool_tPadInHighlightMode() const; virtual Bool_tPadInSelectionMode() const; virtual Double_tPadtoX(Double_t x) con",MatchSource.WIKI,root/html532/TVirtualPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPad.html
https://root.cern/root/html532/TVirtualPad.html:9201,Modifiability,Inherit,InheritsFrom,9201," = """"); virtual TVirtualPad*GetVirtCanvas() const; virtual UInt_tGetWh() const; virtual Double_tGetWNDC() const; virtual UInt_tGetWw() const; virtual Double_tGetX1() const; virtual Double_tGetX2() const; Float_tTAttPad::GetXfile() const; virtual Double_tGetXlowNDC() const; Float_tTAttPad::GetXstat() const; virtual Double_tGetY1() const; virtual Double_tGetY2() const; Float_tTAttPad::GetYfile() const; virtual Double_tGetYlowNDC() const; Float_tTAttPad::GetYstat() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual Bool_tHasCrosshair() const; virtual Bool_tHasFixedAspectRatio() const; virtual ULong_tTObject::Hash() const; virtual Bool_tHasViewer3D() const; virtual voidHighLight(Color_t col = kRed, Bool_t set = kTRUE); virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tIsBatch() const; Bool_tIsBeingResized() const; virtual Bool_tIsEditable() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tIsModified() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsRetained() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; virtual Bool_tIsVertical() const; Bool_tTObject::IsZombie() const; static voidTQObject::LoadRQ_OBJECT(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidModified(Bool_t flag = 1); virtual voidTAttLine::Modify(); ",MatchSource.WIKI,root/html532/TVirtualPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPad.html
https://root.cern/root/html532/TVirtualPad.html:9267,Modifiability,Inherit,InheritsFrom,9267,"etWh() const; virtual Double_tGetWNDC() const; virtual UInt_tGetWw() const; virtual Double_tGetX1() const; virtual Double_tGetX2() const; Float_tTAttPad::GetXfile() const; virtual Double_tGetXlowNDC() const; Float_tTAttPad::GetXstat() const; virtual Double_tGetY1() const; virtual Double_tGetY2() const; Float_tTAttPad::GetYfile() const; virtual Double_tGetYlowNDC() const; Float_tTAttPad::GetYstat() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual Bool_tHasCrosshair() const; virtual Bool_tHasFixedAspectRatio() const; virtual ULong_tTObject::Hash() const; virtual Bool_tHasViewer3D() const; virtual voidHighLight(Color_t col = kRed, Bool_t set = kTRUE); virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tIsBatch() const; Bool_tIsBeingResized() const; virtual Bool_tIsEditable() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tIsModified() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsRetained() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; virtual Bool_tIsVertical() const; Bool_tTObject::IsZombie() const; static voidTQObject::LoadRQ_OBJECT(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidModified(Bool_t flag = 1); virtual voidTAttLine::Modify(); virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfCo",MatchSource.WIKI,root/html532/TVirtualPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPad.html
https://root.cern/root/html532/TVirtualPad.html:20868,Modifiability,Inherit,Inheritance,20868,"ameLineColorpad frame line color; Style_tTAttPad::fFrameLineStylepad frame line style; Width_tTAttPad::fFrameLineWidthpad frame line width; Float_tTAttPad::fLeftMarginLeftMargin; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tfResizing!true when resizing the pad; Float_tTAttPad::fRightMarginRightMargin; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Float_tTAttPad::fTopMarginTopMargin; Float_tTAttPad::fXfileX position where to draw the file name; Float_tTAttPad::fXstatX position where to draw the statistics; Float_tTAttPad::fYfileY position where to draw the file name; Float_tTAttPad::fYstatY position where to draw the statistics; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualPad *& Pad(); Return the current pad for the current thread. ~TVirtualPad(); VirtualPad destructor. void Streamer(TBuffer& b); Stream an object of class TVirtualPad. Bool_t PadInSelectionMode() const; Should always return false unless you have non-standard picking. Bool_t PadInHighlightMode() const; Should always return false, unless you can highlight selected object in pad. void PushTopLevelSelectable(TObject* top); Does nothing, unless you implement your own picking.; When complex object containing sub-objects (which can be picked); is painted in a pad, this ""top-level"" object is pushed into; the selectables stack. void PushSelectableObject(TObject* obj); Does nothing, unless you implement your own picking.; ""Complete"" object, or part of complex object, which; can be picked. void PopTopLevelSelectable(); Does nothing, unless you implement your own picking.; Remove top level selectable and all its' children. void * GetSender()",MatchSource.WIKI,root/html532/TVirtualPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPad.html
https://root.cern/root/html532/TVirtualPad.html:20881,Modifiability,Inherit,Inherited,20881,"ameLineColorpad frame line color; Style_tTAttPad::fFrameLineStylepad frame line style; Width_tTAttPad::fFrameLineWidthpad frame line width; Float_tTAttPad::fLeftMarginLeftMargin; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tfResizing!true when resizing the pad; Float_tTAttPad::fRightMarginRightMargin; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Float_tTAttPad::fTopMarginTopMargin; Float_tTAttPad::fXfileX position where to draw the file name; Float_tTAttPad::fXstatX position where to draw the statistics; Float_tTAttPad::fYfileY position where to draw the file name; Float_tTAttPad::fYstatY position where to draw the statistics; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualPad *& Pad(); Return the current pad for the current thread. ~TVirtualPad(); VirtualPad destructor. void Streamer(TBuffer& b); Stream an object of class TVirtualPad. Bool_t PadInSelectionMode() const; Should always return false unless you have non-standard picking. Bool_t PadInHighlightMode() const; Should always return false, unless you can highlight selected object in pad. void PushTopLevelSelectable(TObject* top); Does nothing, unless you implement your own picking.; When complex object containing sub-objects (which can be picked); is painted in a pad, this ""top-level"" object is pushed into; the selectables stack. void PushSelectableObject(TObject* obj); Does nothing, unless you implement your own picking.; ""Complete"" object, or part of complex object, which; can be picked. void PopTopLevelSelectable(); Does nothing, unless you implement your own picking.; Remove top level selectable and all its' children. void * GetSender()",MatchSource.WIKI,root/html532/TVirtualPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPad.html
https://root.cern/root/html532/TVirtualPad.html:8905,Security,Hash,Hash,8905,"t; virtual UInt_tTObject::GetUniqueID() const; virtual Double_tGetUxmax() const; virtual Double_tGetUxmin() const; virtual Double_tGetUymax() const; virtual Double_tGetUymin() const; virtual TView*GetView() const; virtual TObject*GetView3D() const; virtual TVirtualViewer3D*GetViewer3D(Option_t* type = """"); virtual TVirtualPad*GetVirtCanvas() const; virtual UInt_tGetWh() const; virtual Double_tGetWNDC() const; virtual UInt_tGetWw() const; virtual Double_tGetX1() const; virtual Double_tGetX2() const; Float_tTAttPad::GetXfile() const; virtual Double_tGetXlowNDC() const; Float_tTAttPad::GetXstat() const; virtual Double_tGetY1() const; virtual Double_tGetY2() const; Float_tTAttPad::GetYfile() const; virtual Double_tGetYlowNDC() const; Float_tTAttPad::GetYstat() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual Bool_tHasCrosshair() const; virtual Bool_tHasFixedAspectRatio() const; virtual ULong_tTObject::Hash() const; virtual Bool_tHasViewer3D() const; virtual voidHighLight(Color_t col = kRed, Bool_t set = kTRUE); virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tIsBatch() const; Bool_tIsBeingResized() const; virtual Bool_tIsEditable() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tIsModified() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsRetained() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; virtual Bool_tIsVertical() const; Bool_tTObject::IsZombie() const; static voidTQObject::LoadRQ_OBJECT(); virtual ",MatchSource.WIKI,root/html532/TVirtualPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPad.html
https://root.cern/root/html532/TVirtualPad.html:17610,Testability,Test,TestBit,17610," color = 35, Short_t bordersize = 5, Short_t bordermode = -1); virtual voidSetPhi(Double_t phi = 30); virtual voidTAttPad::SetRightMargin(Float_t rightmargin); virtual voidSetSelected(TObject* obj); virtual voidSetTheta(Double_t theta = 30); virtual voidSetTicks(Int_t valuex = 1, Int_t valuey = 1); virtual voidSetTickx(Int_t value = 1); virtual voidSetTicky(Int_t value = 1); virtual voidSetTitle(const char* title = """"); virtual voidSetToolTipText(const char* text, Long_t delayms = 1000); virtual voidTAttPad::SetTopMargin(Float_t topmargin); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetVertical(Bool_t vert = kTRUE); virtual voidSetView(TView* view = 0); virtual voidSetViewer3D(TVirtualViewer3D*); virtual voidTAttPad::SetXfile(Float_t xfile); virtual voidTAttPad::SetXstat(Float_t xstat); virtual voidTAttPad::SetYfile(Float_t yfile); virtual voidTAttPad::SetYstat(Float_t ystat); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUpdate(); virtual voidTObject::UseCurrentStyle(); virtual Int_tUtoAbsPixel(Double_t u) const; virtual Int_tUtoPixel(Double_t u) const; virtual Int_tVtoAbsPixel(Double_t v) const; virtual Int_tVtoPixel(Double_t v) const; virtual TObject*WaitPrimitive(const char* pname = """", const char* emode = """"); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual Int_tXtoAbsPixel(Double_t x) const; virtual Double_tXtoPad(Double_t x) const; virtual Int_tXtoPixel(Double_t x) const; virtual Int_tYtoAbsPixel(Double_t y) const; virtual Double_tYtoPad(Double_t y) const; virtual Int_tYtoPixel(Double_t y) const.",MatchSource.WIKI,root/html532/TVirtualPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPad.html
https://root.cern/root/html532/TVirtualPad.html:17649,Testability,Test,TestBits,17649," color = 35, Short_t bordersize = 5, Short_t bordermode = -1); virtual voidSetPhi(Double_t phi = 30); virtual voidTAttPad::SetRightMargin(Float_t rightmargin); virtual voidSetSelected(TObject* obj); virtual voidSetTheta(Double_t theta = 30); virtual voidSetTicks(Int_t valuex = 1, Int_t valuey = 1); virtual voidSetTickx(Int_t value = 1); virtual voidSetTicky(Int_t value = 1); virtual voidSetTitle(const char* title = """"); virtual voidSetToolTipText(const char* text, Long_t delayms = 1000); virtual voidTAttPad::SetTopMargin(Float_t topmargin); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetVertical(Bool_t vert = kTRUE); virtual voidSetView(TView* view = 0); virtual voidSetViewer3D(TVirtualViewer3D*); virtual voidTAttPad::SetXfile(Float_t xfile); virtual voidTAttPad::SetXstat(Float_t xstat); virtual voidTAttPad::SetYfile(Float_t yfile); virtual voidTAttPad::SetYstat(Float_t ystat); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUpdate(); virtual voidTObject::UseCurrentStyle(); virtual Int_tUtoAbsPixel(Double_t u) const; virtual Int_tUtoPixel(Double_t u) const; virtual Int_tVtoAbsPixel(Double_t v) const; virtual Int_tVtoPixel(Double_t v) const; virtual TObject*WaitPrimitive(const char* pname = """", const char* emode = """"); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual Int_tXtoAbsPixel(Double_t x) const; virtual Double_tXtoPad(Double_t x) const; virtual Int_tXtoPixel(Double_t x) const; virtual Int_tYtoAbsPixel(Double_t y) const; virtual Double_tYtoPad(Double_t y) const; virtual Int_tYtoPixel(Double_t y) const.",MatchSource.WIKI,root/html532/TVirtualPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPad.html
https://root.cern/root/html532/TVirtualPad.html:22110,Usability,Clear,Clear,22110,"ol_t PadInSelectionMode() const; Should always return false unless you have non-standard picking. Bool_t PadInHighlightMode() const; Should always return false, unless you can highlight selected object in pad. void PushTopLevelSelectable(TObject* top); Does nothing, unless you implement your own picking.; When complex object containing sub-objects (which can be picked); is painted in a pad, this ""top-level"" object is pushed into; the selectables stack. void PushSelectableObject(TObject* obj); Does nothing, unless you implement your own picking.; ""Complete"" object, or part of complex object, which; can be picked. void PopTopLevelSelectable(); Does nothing, unless you implement your own picking.; Remove top level selectable and all its' children. void * GetSender(); { return this; }. void AbsCoordinates(Bool_t set). Double_t AbsPixeltoX(Int_t px). Double_t AbsPixeltoY(Int_t py). void AddExec(const char* name, const char* command). TVirtualPad* cd(Int_t subpadnumber = 0). void Clear(Option_t* option = """"). void Close(Option_t* option = """"). void CopyPixmap(). void CopyPixmaps(). void DeleteExec(const char* name). void Divide(Int_t nx = 1, Int_t ny = 1, Float_t xmargin = 0.01, Float_t ymargin = 0.01, Int_t color = 0). void Draw(Option_t* option = """"). void DrawClassObject(const TObject* obj, Option_t* option = """"). TH1F * DrawFrame(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax, const char* title = """"). void ExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis). Short_t GetBorderMode() const. Short_t GetBorderSize() const. Int_t GetCanvasID() const. TCanvasImp * GetCanvasImp() const. TCanvas * GetCanvas() const. TVirtualPad * GetVirtCanvas() const. Int_t GetEvent() const. Int_t GetEventX() const. Int_t GetEventY() const. TFrame * GetFrame(). Color_t GetHighLightColor() const. Int_t GetNumber() const. void GetRange(Double_t& x1, Double_t& y1, Double_t& x2, Double_t& y2). void GetRangeAxis(Double_t& xmin, Double_t& ymin, Double_t& xmax, Double_t& ymax)",MatchSource.WIKI,root/html532/TVirtualPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPad.html
https://root.cern/root/html532/TVirtualPadEditor.html:499,Availability,avail,available,499,". TVirtualPadEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualPadEditor. class TVirtualPadEditor. TVirtualPadEditor. Abstract base class used by ROOT graphics editor. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualPadEditor(); virtual voidBuild(); static TClass*Class(); virtual voidDeleteEditors(); virtual voidDrawLine(Double_t, Double_t, Double_t, Double_t); virtual voidDrawLineNDC(Double_t, Double_t, Double_t, Double_t); virtual voidDrawText(Double_t, Double_t, const char*); virtual voidDrawTextNDC(Double_t, Double_t, const char*); virtual voidFillAttributes(Int_t, Int_t); virtual TCanvas*GetCanvas() const; static const char*GetEditorName(); static TVirtualPadEditor*GetPadEditor(Bool_t load = kTRUE); virtual voidHide(); static voidHideEditor(); virtual TClass*IsA() const; virtual Bool_tIsGlobal() const; virtual voidLineAttributes(Int_t, Int_t, Int_t); static TVirtualPadEditor*LoadEditor(); virtual voidMarkerAttributes(Int_t, Int_t, Float_t); TVirtualPadEditor&operator=(const TVirtualPadEditor&); virtual voidSetGlobal(Bool_t); static voidSetPadEditorName(const char* name); virtual voidShow(); static voidShowEditor(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); static voidTerminate(); virtual voidTextAttributes(Int_t, Float_t, Int_t, Int_t, Float_t); static voidUpdateFillAttributes(Int_t col, Int_t sty); static voidUpdateLineAttributes(Int_t col, Int_t sty, Int_t width); static voidUpdateMarkerAttributes(Int_t col, Int_t sty, Float_t msiz); static voidUpdateTextAttributes(Int_t align, Float_t angle, Int_t col, Int_t font, Float_t tsize). Data Members; protected:. sta",MatchSource.WIKI,root/html532/TVirtualPadEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPadEditor.html
https://root.cern/root/html532/TVirtualPadEditor.html:2899,Deployability,Update,UpdateFillAttributes,2899,"col, Int_t font, Float_t tsize). Data Members; protected:. static TStringfgEditorNamename of the default pad editor ""Ged""; static TVirtualPadEditor*fgPadEditorsingleton editor dialog. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TVirtualPadEditor(); Virtual editor dtor. TVirtualPadEditor * LoadEditor(); Static function returning a pointer to a new pad editor.; This pointer can be adopted by a TCanvas (i.e. TRootCanvas); when it embeds the editor. const char * GetEditorName(); Returns the type of the default pad editor. Static method. TVirtualPadEditor * GetPadEditor(Bool_t load = kTRUE); Returns the pad editor dialog. Static method. void SetPadEditorName(const char* name); Set type of default pad editor. Static method. void ShowEditor(); Show the global pad editor. Static method. void HideEditor(); Hide the pad editor. Static method. void Terminate(); Close the global pad editor. Static method. void UpdateFillAttributes(Int_t col, Int_t sty); Update fill attributes via the pad editor. void UpdateTextAttributes(Int_t align, Float_t angle, Int_t col, Int_t font, Float_t tsize); Update text attributes via the pad editor. void UpdateLineAttributes(Int_t col, Int_t sty, Int_t width); Update line attributes via the pad editor. void UpdateMarkerAttributes(Int_t col, Int_t sty, Float_t msiz); Update marker attributes via the pad editor. Bool_t IsGlobal() const. void DrawLine(Double_t , Double_t , Double_t , Double_t ); methods related to the old editor interface. { }. void DrawLineNDC(Double_t , Double_t , Double_t , Double_t ); { }. void DrawText(Double_t , Double_t , const char* ); { }. void DrawTextNDC(Double_t , Double_t , const char* ); { }. void FillAttributes(Int_t , Int_t ); { }. void LineAttributes(Int_t , Int_t , Int_t ); { }. void MarkerAttributes(Int_t , Int_t , Float_t ); { }. void TextAttributes(Int_t , Float_t , Int_t , Int_t , Float_t ); { }. void Build(); { }. void Show(); { }. void Hide(); { }. void DeleteEdit",MatchSource.WIKI,root/html532/TVirtualPadEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPadEditor.html
https://root.cern/root/html532/TVirtualPadEditor.html:2943,Deployability,Update,Update,2943,"col, Int_t font, Float_t tsize). Data Members; protected:. static TStringfgEditorNamename of the default pad editor ""Ged""; static TVirtualPadEditor*fgPadEditorsingleton editor dialog. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TVirtualPadEditor(); Virtual editor dtor. TVirtualPadEditor * LoadEditor(); Static function returning a pointer to a new pad editor.; This pointer can be adopted by a TCanvas (i.e. TRootCanvas); when it embeds the editor. const char * GetEditorName(); Returns the type of the default pad editor. Static method. TVirtualPadEditor * GetPadEditor(Bool_t load = kTRUE); Returns the pad editor dialog. Static method. void SetPadEditorName(const char* name); Set type of default pad editor. Static method. void ShowEditor(); Show the global pad editor. Static method. void HideEditor(); Hide the pad editor. Static method. void Terminate(); Close the global pad editor. Static method. void UpdateFillAttributes(Int_t col, Int_t sty); Update fill attributes via the pad editor. void UpdateTextAttributes(Int_t align, Float_t angle, Int_t col, Int_t font, Float_t tsize); Update text attributes via the pad editor. void UpdateLineAttributes(Int_t col, Int_t sty, Int_t width); Update line attributes via the pad editor. void UpdateMarkerAttributes(Int_t col, Int_t sty, Float_t msiz); Update marker attributes via the pad editor. Bool_t IsGlobal() const. void DrawLine(Double_t , Double_t , Double_t , Double_t ); methods related to the old editor interface. { }. void DrawLineNDC(Double_t , Double_t , Double_t , Double_t ); { }. void DrawText(Double_t , Double_t , const char* ); { }. void DrawTextNDC(Double_t , Double_t , const char* ); { }. void FillAttributes(Int_t , Int_t ); { }. void LineAttributes(Int_t , Int_t , Int_t ); { }. void MarkerAttributes(Int_t , Int_t , Float_t ); { }. void TextAttributes(Int_t , Float_t , Int_t , Int_t , Float_t ); { }. void Build(); { }. void Show(); { }. void Hide(); { }. void DeleteEdit",MatchSource.WIKI,root/html532/TVirtualPadEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPadEditor.html
https://root.cern/root/html532/TVirtualPadEditor.html:2991,Deployability,Update,UpdateTextAttributes,2991,"r ""Ged""; static TVirtualPadEditor*fgPadEditorsingleton editor dialog. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TVirtualPadEditor(); Virtual editor dtor. TVirtualPadEditor * LoadEditor(); Static function returning a pointer to a new pad editor.; This pointer can be adopted by a TCanvas (i.e. TRootCanvas); when it embeds the editor. const char * GetEditorName(); Returns the type of the default pad editor. Static method. TVirtualPadEditor * GetPadEditor(Bool_t load = kTRUE); Returns the pad editor dialog. Static method. void SetPadEditorName(const char* name); Set type of default pad editor. Static method. void ShowEditor(); Show the global pad editor. Static method. void HideEditor(); Hide the pad editor. Static method. void Terminate(); Close the global pad editor. Static method. void UpdateFillAttributes(Int_t col, Int_t sty); Update fill attributes via the pad editor. void UpdateTextAttributes(Int_t align, Float_t angle, Int_t col, Int_t font, Float_t tsize); Update text attributes via the pad editor. void UpdateLineAttributes(Int_t col, Int_t sty, Int_t width); Update line attributes via the pad editor. void UpdateMarkerAttributes(Int_t col, Int_t sty, Float_t msiz); Update marker attributes via the pad editor. Bool_t IsGlobal() const. void DrawLine(Double_t , Double_t , Double_t , Double_t ); methods related to the old editor interface. { }. void DrawLineNDC(Double_t , Double_t , Double_t , Double_t ); { }. void DrawText(Double_t , Double_t , const char* ); { }. void DrawTextNDC(Double_t , Double_t , const char* ); { }. void FillAttributes(Int_t , Int_t ); { }. void LineAttributes(Int_t , Int_t , Int_t ); { }. void MarkerAttributes(Int_t , Int_t , Float_t ); { }. void TextAttributes(Int_t , Float_t , Int_t , Int_t , Float_t ); { }. void Build(); { }. void Show(); { }. void Hide(); { }. void DeleteEditors(); { }. void SetGlobal(Bool_t ); { }. TCanvas* GetCanvas() const. » Author: Rene Brun 25/11/03 » Copyright (C)",MatchSource.WIKI,root/html532/TVirtualPadEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPadEditor.html
https://root.cern/root/html532/TVirtualPadEditor.html:3079,Deployability,Update,Update,3079,"r ""Ged""; static TVirtualPadEditor*fgPadEditorsingleton editor dialog. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TVirtualPadEditor(); Virtual editor dtor. TVirtualPadEditor * LoadEditor(); Static function returning a pointer to a new pad editor.; This pointer can be adopted by a TCanvas (i.e. TRootCanvas); when it embeds the editor. const char * GetEditorName(); Returns the type of the default pad editor. Static method. TVirtualPadEditor * GetPadEditor(Bool_t load = kTRUE); Returns the pad editor dialog. Static method. void SetPadEditorName(const char* name); Set type of default pad editor. Static method. void ShowEditor(); Show the global pad editor. Static method. void HideEditor(); Hide the pad editor. Static method. void Terminate(); Close the global pad editor. Static method. void UpdateFillAttributes(Int_t col, Int_t sty); Update fill attributes via the pad editor. void UpdateTextAttributes(Int_t align, Float_t angle, Int_t col, Int_t font, Float_t tsize); Update text attributes via the pad editor. void UpdateLineAttributes(Int_t col, Int_t sty, Int_t width); Update line attributes via the pad editor. void UpdateMarkerAttributes(Int_t col, Int_t sty, Float_t msiz); Update marker attributes via the pad editor. Bool_t IsGlobal() const. void DrawLine(Double_t , Double_t , Double_t , Double_t ); methods related to the old editor interface. { }. void DrawLineNDC(Double_t , Double_t , Double_t , Double_t ); { }. void DrawText(Double_t , Double_t , const char* ); { }. void DrawTextNDC(Double_t , Double_t , const char* ); { }. void FillAttributes(Int_t , Int_t ); { }. void LineAttributes(Int_t , Int_t , Int_t ); { }. void MarkerAttributes(Int_t , Int_t , Float_t ); { }. void TextAttributes(Int_t , Float_t , Int_t , Int_t , Float_t ); { }. void Build(); { }. void Show(); { }. void Hide(); { }. void DeleteEditors(); { }. void SetGlobal(Bool_t ); { }. TCanvas* GetCanvas() const. » Author: Rene Brun 25/11/03 » Copyright (C)",MatchSource.WIKI,root/html532/TVirtualPadEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPadEditor.html
https://root.cern/root/html532/TVirtualPadEditor.html:3127,Deployability,Update,UpdateLineAttributes,3127,"udes; Libraries. Function documentation; ~TVirtualPadEditor(); Virtual editor dtor. TVirtualPadEditor * LoadEditor(); Static function returning a pointer to a new pad editor.; This pointer can be adopted by a TCanvas (i.e. TRootCanvas); when it embeds the editor. const char * GetEditorName(); Returns the type of the default pad editor. Static method. TVirtualPadEditor * GetPadEditor(Bool_t load = kTRUE); Returns the pad editor dialog. Static method. void SetPadEditorName(const char* name); Set type of default pad editor. Static method. void ShowEditor(); Show the global pad editor. Static method. void HideEditor(); Hide the pad editor. Static method. void Terminate(); Close the global pad editor. Static method. void UpdateFillAttributes(Int_t col, Int_t sty); Update fill attributes via the pad editor. void UpdateTextAttributes(Int_t align, Float_t angle, Int_t col, Int_t font, Float_t tsize); Update text attributes via the pad editor. void UpdateLineAttributes(Int_t col, Int_t sty, Int_t width); Update line attributes via the pad editor. void UpdateMarkerAttributes(Int_t col, Int_t sty, Float_t msiz); Update marker attributes via the pad editor. Bool_t IsGlobal() const. void DrawLine(Double_t , Double_t , Double_t , Double_t ); methods related to the old editor interface. { }. void DrawLineNDC(Double_t , Double_t , Double_t , Double_t ); { }. void DrawText(Double_t , Double_t , const char* ); { }. void DrawTextNDC(Double_t , Double_t , const char* ); { }. void FillAttributes(Int_t , Int_t ); { }. void LineAttributes(Int_t , Int_t , Int_t ); { }. void MarkerAttributes(Int_t , Int_t , Float_t ); { }. void TextAttributes(Int_t , Float_t , Int_t , Int_t , Float_t ); { }. void Build(); { }. void Show(); { }. void Hide(); { }. void DeleteEditors(); { }. void SetGlobal(Bool_t ); { }. TCanvas* GetCanvas() const. » Author: Rene Brun 25/11/03 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TVirtualPadEditor.h,v 1.0 2003/11/25 » Last ",MatchSource.WIKI,root/html532/TVirtualPadEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPadEditor.html
https://root.cern/root/html532/TVirtualPadEditor.html:3184,Deployability,Update,Update,3184,"udes; Libraries. Function documentation; ~TVirtualPadEditor(); Virtual editor dtor. TVirtualPadEditor * LoadEditor(); Static function returning a pointer to a new pad editor.; This pointer can be adopted by a TCanvas (i.e. TRootCanvas); when it embeds the editor. const char * GetEditorName(); Returns the type of the default pad editor. Static method. TVirtualPadEditor * GetPadEditor(Bool_t load = kTRUE); Returns the pad editor dialog. Static method. void SetPadEditorName(const char* name); Set type of default pad editor. Static method. void ShowEditor(); Show the global pad editor. Static method. void HideEditor(); Hide the pad editor. Static method. void Terminate(); Close the global pad editor. Static method. void UpdateFillAttributes(Int_t col, Int_t sty); Update fill attributes via the pad editor. void UpdateTextAttributes(Int_t align, Float_t angle, Int_t col, Int_t font, Float_t tsize); Update text attributes via the pad editor. void UpdateLineAttributes(Int_t col, Int_t sty, Int_t width); Update line attributes via the pad editor. void UpdateMarkerAttributes(Int_t col, Int_t sty, Float_t msiz); Update marker attributes via the pad editor. Bool_t IsGlobal() const. void DrawLine(Double_t , Double_t , Double_t , Double_t ); methods related to the old editor interface. { }. void DrawLineNDC(Double_t , Double_t , Double_t , Double_t ); { }. void DrawText(Double_t , Double_t , const char* ); { }. void DrawTextNDC(Double_t , Double_t , const char* ); { }. void FillAttributes(Int_t , Int_t ); { }. void LineAttributes(Int_t , Int_t , Int_t ); { }. void MarkerAttributes(Int_t , Int_t , Float_t ); { }. void TextAttributes(Int_t , Float_t , Int_t , Int_t , Float_t ); { }. void Build(); { }. void Show(); { }. void Hide(); { }. void DeleteEditors(); { }. void SetGlobal(Bool_t ); { }. TCanvas* GetCanvas() const. » Author: Rene Brun 25/11/03 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TVirtualPadEditor.h,v 1.0 2003/11/25 » Last ",MatchSource.WIKI,root/html532/TVirtualPadEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPadEditor.html
https://root.cern/root/html532/TVirtualPadEditor.html:3232,Deployability,Update,UpdateMarkerAttributes,3232,"Editor(); Static function returning a pointer to a new pad editor.; This pointer can be adopted by a TCanvas (i.e. TRootCanvas); when it embeds the editor. const char * GetEditorName(); Returns the type of the default pad editor. Static method. TVirtualPadEditor * GetPadEditor(Bool_t load = kTRUE); Returns the pad editor dialog. Static method. void SetPadEditorName(const char* name); Set type of default pad editor. Static method. void ShowEditor(); Show the global pad editor. Static method. void HideEditor(); Hide the pad editor. Static method. void Terminate(); Close the global pad editor. Static method. void UpdateFillAttributes(Int_t col, Int_t sty); Update fill attributes via the pad editor. void UpdateTextAttributes(Int_t align, Float_t angle, Int_t col, Int_t font, Float_t tsize); Update text attributes via the pad editor. void UpdateLineAttributes(Int_t col, Int_t sty, Int_t width); Update line attributes via the pad editor. void UpdateMarkerAttributes(Int_t col, Int_t sty, Float_t msiz); Update marker attributes via the pad editor. Bool_t IsGlobal() const. void DrawLine(Double_t , Double_t , Double_t , Double_t ); methods related to the old editor interface. { }. void DrawLineNDC(Double_t , Double_t , Double_t , Double_t ); { }. void DrawText(Double_t , Double_t , const char* ); { }. void DrawTextNDC(Double_t , Double_t , const char* ); { }. void FillAttributes(Int_t , Int_t ); { }. void LineAttributes(Int_t , Int_t , Int_t ); { }. void MarkerAttributes(Int_t , Int_t , Float_t ); { }. void TextAttributes(Int_t , Float_t , Int_t , Int_t , Float_t ); { }. void Build(); { }. void Show(); { }. void Hide(); { }. void DeleteEditors(); { }. void SetGlobal(Bool_t ); { }. TCanvas* GetCanvas() const. » Author: Rene Brun 25/11/03 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TVirtualPadEditor.h,v 1.0 2003/11/25 » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regard",MatchSource.WIKI,root/html532/TVirtualPadEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPadEditor.html
https://root.cern/root/html532/TVirtualPadEditor.html:3292,Deployability,Update,Update,3292,"Editor(); Static function returning a pointer to a new pad editor.; This pointer can be adopted by a TCanvas (i.e. TRootCanvas); when it embeds the editor. const char * GetEditorName(); Returns the type of the default pad editor. Static method. TVirtualPadEditor * GetPadEditor(Bool_t load = kTRUE); Returns the pad editor dialog. Static method. void SetPadEditorName(const char* name); Set type of default pad editor. Static method. void ShowEditor(); Show the global pad editor. Static method. void HideEditor(); Hide the pad editor. Static method. void Terminate(); Close the global pad editor. Static method. void UpdateFillAttributes(Int_t col, Int_t sty); Update fill attributes via the pad editor. void UpdateTextAttributes(Int_t align, Float_t angle, Int_t col, Int_t font, Float_t tsize); Update text attributes via the pad editor. void UpdateLineAttributes(Int_t col, Int_t sty, Int_t width); Update line attributes via the pad editor. void UpdateMarkerAttributes(Int_t col, Int_t sty, Float_t msiz); Update marker attributes via the pad editor. Bool_t IsGlobal() const. void DrawLine(Double_t , Double_t , Double_t , Double_t ); methods related to the old editor interface. { }. void DrawLineNDC(Double_t , Double_t , Double_t , Double_t ); { }. void DrawText(Double_t , Double_t , const char* ); { }. void DrawTextNDC(Double_t , Double_t , const char* ); { }. void FillAttributes(Int_t , Int_t ); { }. void LineAttributes(Int_t , Int_t , Int_t ); { }. void MarkerAttributes(Int_t , Int_t , Float_t ); { }. void TextAttributes(Int_t , Float_t , Int_t , Int_t , Float_t ); { }. void Build(); { }. void Show(); { }. void Hide(); { }. void DeleteEditors(); { }. void SetGlobal(Bool_t ); { }. TCanvas* GetCanvas() const. » Author: Rene Brun 25/11/03 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TVirtualPadEditor.h,v 1.0 2003/11/25 » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regard",MatchSource.WIKI,root/html532/TVirtualPadEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPadEditor.html
https://root.cern/root/html532/TVirtualPadEditor.html:3455,Integrability,interface,interface,3455,"ter can be adopted by a TCanvas (i.e. TRootCanvas); when it embeds the editor. const char * GetEditorName(); Returns the type of the default pad editor. Static method. TVirtualPadEditor * GetPadEditor(Bool_t load = kTRUE); Returns the pad editor dialog. Static method. void SetPadEditorName(const char* name); Set type of default pad editor. Static method. void ShowEditor(); Show the global pad editor. Static method. void HideEditor(); Hide the pad editor. Static method. void Terminate(); Close the global pad editor. Static method. void UpdateFillAttributes(Int_t col, Int_t sty); Update fill attributes via the pad editor. void UpdateTextAttributes(Int_t align, Float_t angle, Int_t col, Int_t font, Float_t tsize); Update text attributes via the pad editor. void UpdateLineAttributes(Int_t col, Int_t sty, Int_t width); Update line attributes via the pad editor. void UpdateMarkerAttributes(Int_t col, Int_t sty, Float_t msiz); Update marker attributes via the pad editor. Bool_t IsGlobal() const. void DrawLine(Double_t , Double_t , Double_t , Double_t ); methods related to the old editor interface. { }. void DrawLineNDC(Double_t , Double_t , Double_t , Double_t ); { }. void DrawText(Double_t , Double_t , const char* ); { }. void DrawTextNDC(Double_t , Double_t , const char* ); { }. void FillAttributes(Int_t , Int_t ); { }. void LineAttributes(Int_t , Int_t , Int_t ); { }. void MarkerAttributes(Int_t , Int_t , Float_t ); { }. void TextAttributes(Int_t , Float_t , Int_t , Int_t , Float_t ); { }. void Build(); { }. void Show(); { }. void Hide(); { }. void DeleteEditors(); { }. void SetGlobal(Bool_t ); { }. TCanvas* GetCanvas() const. » Author: Rene Brun 25/11/03 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TVirtualPadEditor.h,v 1.0 2003/11/25 » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TVirtualPadEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPadEditor.html
https://root.cern/root/html532/TVirtualPadEditor.html:2137,Modifiability,Inherit,Inheritance,2137,"idLineAttributes(Int_t, Int_t, Int_t); static TVirtualPadEditor*LoadEditor(); virtual voidMarkerAttributes(Int_t, Int_t, Float_t); TVirtualPadEditor&operator=(const TVirtualPadEditor&); virtual voidSetGlobal(Bool_t); static voidSetPadEditorName(const char* name); virtual voidShow(); static voidShowEditor(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); static voidTerminate(); virtual voidTextAttributes(Int_t, Float_t, Int_t, Int_t, Float_t); static voidUpdateFillAttributes(Int_t col, Int_t sty); static voidUpdateLineAttributes(Int_t col, Int_t sty, Int_t width); static voidUpdateMarkerAttributes(Int_t col, Int_t sty, Float_t msiz); static voidUpdateTextAttributes(Int_t align, Float_t angle, Int_t col, Int_t font, Float_t tsize). Data Members; protected:. static TStringfgEditorNamename of the default pad editor ""Ged""; static TVirtualPadEditor*fgPadEditorsingleton editor dialog. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TVirtualPadEditor(); Virtual editor dtor. TVirtualPadEditor * LoadEditor(); Static function returning a pointer to a new pad editor.; This pointer can be adopted by a TCanvas (i.e. TRootCanvas); when it embeds the editor. const char * GetEditorName(); Returns the type of the default pad editor. Static method. TVirtualPadEditor * GetPadEditor(Bool_t load = kTRUE); Returns the pad editor dialog. Static method. void SetPadEditorName(const char* name); Set type of default pad editor. Static method. void ShowEditor(); Show the global pad editor. Static method. void HideEditor(); Hide the pad editor. Static method. void Terminate(); Close the global pad editor. Static method. void UpdateFillAttributes(Int_t col, Int_t sty); Update fill attributes via the pad editor. void UpdateTextAttributes(Int_t align, Float_t angle, Int_t col, Int_t font, Float_t tsize); Update text attributes via the pad editor. void UpdateLineAttributes(Int_t col, Int_",MatchSource.WIKI,root/html532/TVirtualPadEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPadEditor.html
https://root.cern/root/html532/TVirtualPadEditor.html:2150,Modifiability,Inherit,Inherited,2150,"idLineAttributes(Int_t, Int_t, Int_t); static TVirtualPadEditor*LoadEditor(); virtual voidMarkerAttributes(Int_t, Int_t, Float_t); TVirtualPadEditor&operator=(const TVirtualPadEditor&); virtual voidSetGlobal(Bool_t); static voidSetPadEditorName(const char* name); virtual voidShow(); static voidShowEditor(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); static voidTerminate(); virtual voidTextAttributes(Int_t, Float_t, Int_t, Int_t, Float_t); static voidUpdateFillAttributes(Int_t col, Int_t sty); static voidUpdateLineAttributes(Int_t col, Int_t sty, Int_t width); static voidUpdateMarkerAttributes(Int_t col, Int_t sty, Float_t msiz); static voidUpdateTextAttributes(Int_t align, Float_t angle, Int_t col, Int_t font, Float_t tsize). Data Members; protected:. static TStringfgEditorNamename of the default pad editor ""Ged""; static TVirtualPadEditor*fgPadEditorsingleton editor dialog. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TVirtualPadEditor(); Virtual editor dtor. TVirtualPadEditor * LoadEditor(); Static function returning a pointer to a new pad editor.; This pointer can be adopted by a TCanvas (i.e. TRootCanvas); when it embeds the editor. const char * GetEditorName(); Returns the type of the default pad editor. Static method. TVirtualPadEditor * GetPadEditor(Bool_t load = kTRUE); Returns the pad editor dialog. Static method. void SetPadEditorName(const char* name); Set type of default pad editor. Static method. void ShowEditor(); Show the global pad editor. Static method. void HideEditor(); Hide the pad editor. Static method. void Terminate(); Close the global pad editor. Static method. void UpdateFillAttributes(Int_t col, Int_t sty); Update fill attributes via the pad editor. void UpdateTextAttributes(Int_t align, Float_t angle, Int_t col, Int_t font, Float_t tsize); Update text attributes via the pad editor. void UpdateLineAttributes(Int_t col, Int_",MatchSource.WIKI,root/html532/TVirtualPadEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPadEditor.html
https://root.cern/root/html532/TVirtualPadEditor.html:1032,Performance,load,load,1032," TVirtualPadEditor. class TVirtualPadEditor. TVirtualPadEditor. Abstract base class used by ROOT graphics editor. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualPadEditor(); virtual voidBuild(); static TClass*Class(); virtual voidDeleteEditors(); virtual voidDrawLine(Double_t, Double_t, Double_t, Double_t); virtual voidDrawLineNDC(Double_t, Double_t, Double_t, Double_t); virtual voidDrawText(Double_t, Double_t, const char*); virtual voidDrawTextNDC(Double_t, Double_t, const char*); virtual voidFillAttributes(Int_t, Int_t); virtual TCanvas*GetCanvas() const; static const char*GetEditorName(); static TVirtualPadEditor*GetPadEditor(Bool_t load = kTRUE); virtual voidHide(); static voidHideEditor(); virtual TClass*IsA() const; virtual Bool_tIsGlobal() const; virtual voidLineAttributes(Int_t, Int_t, Int_t); static TVirtualPadEditor*LoadEditor(); virtual voidMarkerAttributes(Int_t, Int_t, Float_t); TVirtualPadEditor&operator=(const TVirtualPadEditor&); virtual voidSetGlobal(Bool_t); static voidSetPadEditorName(const char* name); virtual voidShow(); static voidShowEditor(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); static voidTerminate(); virtual voidTextAttributes(Int_t, Float_t, Int_t, Int_t, Float_t); static voidUpdateFillAttributes(Int_t col, Int_t sty); static voidUpdateLineAttributes(Int_t col, Int_t sty, Int_t width); static voidUpdateMarkerAttributes(Int_t col, Int_t sty, Float_t msiz); static voidUpdateTextAttributes(Int_t align, Float_t angle, Int_t col, Int_t font, Float_t tsize). Data Members; protected:. static TStringfgEditorNamename of the default pad editor ""Ged""; static TVirtualPadEditor*fgPadEditorsingleton editor dialog. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TVirtualPadEditor(); Virtual editor d",MatchSource.WIKI,root/html532/TVirtualPadEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPadEditor.html
https://root.cern/root/html532/TVirtualPadEditor.html:1226,Performance,Load,LoadEditor,1226," TVirtualPadEditor. class TVirtualPadEditor. TVirtualPadEditor. Abstract base class used by ROOT graphics editor. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualPadEditor(); virtual voidBuild(); static TClass*Class(); virtual voidDeleteEditors(); virtual voidDrawLine(Double_t, Double_t, Double_t, Double_t); virtual voidDrawLineNDC(Double_t, Double_t, Double_t, Double_t); virtual voidDrawText(Double_t, Double_t, const char*); virtual voidDrawTextNDC(Double_t, Double_t, const char*); virtual voidFillAttributes(Int_t, Int_t); virtual TCanvas*GetCanvas() const; static const char*GetEditorName(); static TVirtualPadEditor*GetPadEditor(Bool_t load = kTRUE); virtual voidHide(); static voidHideEditor(); virtual TClass*IsA() const; virtual Bool_tIsGlobal() const; virtual voidLineAttributes(Int_t, Int_t, Int_t); static TVirtualPadEditor*LoadEditor(); virtual voidMarkerAttributes(Int_t, Int_t, Float_t); TVirtualPadEditor&operator=(const TVirtualPadEditor&); virtual voidSetGlobal(Bool_t); static voidSetPadEditorName(const char* name); virtual voidShow(); static voidShowEditor(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); static voidTerminate(); virtual voidTextAttributes(Int_t, Float_t, Int_t, Int_t, Float_t); static voidUpdateFillAttributes(Int_t col, Int_t sty); static voidUpdateLineAttributes(Int_t col, Int_t sty, Int_t width); static voidUpdateMarkerAttributes(Int_t col, Int_t sty, Float_t msiz); static voidUpdateTextAttributes(Int_t align, Float_t angle, Int_t col, Int_t font, Float_t tsize). Data Members; protected:. static TStringfgEditorNamename of the default pad editor ""Ged""; static TVirtualPadEditor*fgPadEditorsingleton editor dialog. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TVirtualPadEditor(); Virtual editor d",MatchSource.WIKI,root/html532/TVirtualPadEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPadEditor.html
https://root.cern/root/html532/TVirtualPadEditor.html:2277,Performance,Load,LoadEditor,2277,"PadEditor&operator=(const TVirtualPadEditor&); virtual voidSetGlobal(Bool_t); static voidSetPadEditorName(const char* name); virtual voidShow(); static voidShowEditor(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); static voidTerminate(); virtual voidTextAttributes(Int_t, Float_t, Int_t, Int_t, Float_t); static voidUpdateFillAttributes(Int_t col, Int_t sty); static voidUpdateLineAttributes(Int_t col, Int_t sty, Int_t width); static voidUpdateMarkerAttributes(Int_t col, Int_t sty, Float_t msiz); static voidUpdateTextAttributes(Int_t align, Float_t angle, Int_t col, Int_t font, Float_t tsize). Data Members; protected:. static TStringfgEditorNamename of the default pad editor ""Ged""; static TVirtualPadEditor*fgPadEditorsingleton editor dialog. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TVirtualPadEditor(); Virtual editor dtor. TVirtualPadEditor * LoadEditor(); Static function returning a pointer to a new pad editor.; This pointer can be adopted by a TCanvas (i.e. TRootCanvas); when it embeds the editor. const char * GetEditorName(); Returns the type of the default pad editor. Static method. TVirtualPadEditor * GetPadEditor(Bool_t load = kTRUE); Returns the pad editor dialog. Static method. void SetPadEditorName(const char* name); Set type of default pad editor. Static method. void ShowEditor(); Show the global pad editor. Static method. void HideEditor(); Hide the pad editor. Static method. void Terminate(); Close the global pad editor. Static method. void UpdateFillAttributes(Int_t col, Int_t sty); Update fill attributes via the pad editor. void UpdateTextAttributes(Int_t align, Float_t angle, Int_t col, Int_t font, Float_t tsize); Update text attributes via the pad editor. void UpdateLineAttributes(Int_t col, Int_t sty, Int_t width); Update line attributes via the pad editor. void UpdateMarkerAttributes(Int_t col, Int_t sty, Float_t msiz); Update mar",MatchSource.WIKI,root/html532/TVirtualPadEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPadEditor.html
https://root.cern/root/html532/TVirtualPadEditor.html:2566,Performance,load,load,2566,"irtual(TBuffer& b); static voidTerminate(); virtual voidTextAttributes(Int_t, Float_t, Int_t, Int_t, Float_t); static voidUpdateFillAttributes(Int_t col, Int_t sty); static voidUpdateLineAttributes(Int_t col, Int_t sty, Int_t width); static voidUpdateMarkerAttributes(Int_t col, Int_t sty, Float_t msiz); static voidUpdateTextAttributes(Int_t align, Float_t angle, Int_t col, Int_t font, Float_t tsize). Data Members; protected:. static TStringfgEditorNamename of the default pad editor ""Ged""; static TVirtualPadEditor*fgPadEditorsingleton editor dialog. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TVirtualPadEditor(); Virtual editor dtor. TVirtualPadEditor * LoadEditor(); Static function returning a pointer to a new pad editor.; This pointer can be adopted by a TCanvas (i.e. TRootCanvas); when it embeds the editor. const char * GetEditorName(); Returns the type of the default pad editor. Static method. TVirtualPadEditor * GetPadEditor(Bool_t load = kTRUE); Returns the pad editor dialog. Static method. void SetPadEditorName(const char* name); Set type of default pad editor. Static method. void ShowEditor(); Show the global pad editor. Static method. void HideEditor(); Hide the pad editor. Static method. void Terminate(); Close the global pad editor. Static method. void UpdateFillAttributes(Int_t col, Int_t sty); Update fill attributes via the pad editor. void UpdateTextAttributes(Int_t align, Float_t angle, Int_t col, Int_t font, Float_t tsize); Update text attributes via the pad editor. void UpdateLineAttributes(Int_t col, Int_t sty, Int_t width); Update line attributes via the pad editor. void UpdateMarkerAttributes(Int_t col, Int_t sty, Float_t msiz); Update marker attributes via the pad editor. Bool_t IsGlobal() const. void DrawLine(Double_t , Double_t , Double_t , Double_t ); methods related to the old editor interface. { }. void DrawLineNDC(Double_t , Double_t , Double_t , Double_t ); { }. void DrawText(Double_t , Doubl",MatchSource.WIKI,root/html532/TVirtualPadEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPadEditor.html
https://root.cern/root/html532/TVirtualPadPainter.html:433,Availability,avail,available,433,". TVirtualPadPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualPadPainter. class TVirtualPadPainter. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualPadPainter(); static TClass*Class(); virtual voidClearDrawable(); virtual voidCopyDrawable(Int_t device, Int_t px, Int_t py); virtual Int_tCreateDrawable(UInt_t w, UInt_t h); virtual voidDestroyDrawable(); virtual voidDrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, TVirtualPadPainter::EBoxMode mode); virtual voidDrawFillArea(Int_t n, const Double_t* x, const Double_t* y); virtual voidDrawFillArea(Int_t n, const Float_t* x, const Float_t* y); virtual voidDrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidDrawLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2); virtual voidDrawPolyLine(Int_t n, const Double_t* x, const Double_t* y); virtual voidDrawPolyLine(Int_t n, const Float_t* x, const Float_t* y); virtual voidDrawPolyLineNDC(Int_t n, const Double_t* u, const Double_t* v); virtual voidDrawPolyMarker(Int_t n, const Double_t* x, const Double_t* y); virtual voidDrawPolyMarker(Int_t n, const Float_t* x, const Float_t* y); virtual voidDrawText(Double_t x, Double_t y, const char* text, TVirtualPadPainter::ETextMode mode); virtual voidDrawTextNDC(Double_t u, Double_t v, const char* text, TVirtualPadPainter::ETextMode mode); virtual Color_tGetFillColor() const; virtual Style_tGetFillStyle() const; virtual Color_tGetLineColor() const; virtual Style_tGetLineStyle() const; virtual Width_tGetLineWidth() const; virtual Short_tGetTextAlign() const; virtual Float_tGetTextAngle() const; virtual Color_tGetTextColor() const; virtual Font_tGetTextFont() const; virtual",MatchSource.WIKI,root/html532/TVirtualPadPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPadPainter.html
https://root.cern/root/html532/TVirtualPadPainter.html:4478,Integrability,interface,interface,4478," Create a pad painter of specified type. Color_t GetLineColor() const; Line attributes to be set up in TPad. Style_t GetLineStyle() const. Width_t GetLineWidth() const. void SetLineColor(Color_t lcolor). void SetLineStyle(Style_t lstyle). void SetLineWidth(Width_t lwidth). Color_t GetFillColor() const; Fill attributes to be set up in TPad. Style_t GetFillStyle() const. Bool_t IsTransparent() const. void SetFillColor(Color_t fcolor). void SetFillStyle(Style_t fstyle). void SetOpacity(Int_t percent). Short_t GetTextAlign() const; Text attributes. Float_t GetTextAngle() const. Color_t GetTextColor() const. Font_t GetTextFont() const. Float_t GetTextSize() const. Float_t GetTextMagnitude() const. void SetTextAlign(Short_t align = 11). void SetTextAngle(Float_t tangle = 0). void SetTextColor(Color_t tcolor = 1). void SetTextFont(Font_t tfont = 62). void SetTextSize(Float_t tsize = 1). void SetTextSizePixels(Int_t npixels). Int_t CreateDrawable(UInt_t w, UInt_t h); This part is an interface to X11 pixmap management and to save sub-pads off-screens for OpenGL.; Currently, must be implemented only for X11/GDI. void ClearDrawable(). void CopyDrawable(Int_t device, Int_t px, Int_t py). void DestroyDrawable(). void SelectDrawable(Int_t device). These functions are not required by X11/GDI. void DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Now, drawing primitives. void DrawLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2). void DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, TVirtualPadPainter::EBoxMode mode). void DrawFillArea(Int_t n, const Double_t* x, const Double_t* y). void DrawFillArea(Int_t n, const Float_t* x, const Float_t* y). void DrawPolyLine(Int_t n, const Double_t* x, const Double_t* y). void DrawPolyLine(Int_t n, const Float_t* x, const Float_t* y). void DrawPolyLineNDC(Int_t n, const Double_t* u, const Double_t* v). void DrawPolyMarker(Int_t n, const Double_t* x, const Double_t* y). void DrawPolyMarker(Int_t n, const Float_",MatchSource.WIKI,root/html532/TVirtualPadPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPadPainter.html
https://root.cern/root/html532/TVirtualPadPainter.html:3207,Modifiability,Inherit,Inheritance,3207,"nter&operator=(const TVirtualPadPainter&); static TVirtualPadPainter*PadPainter(Option_t* opt = """"); virtual voidSaveImage(TVirtualPad* pad, const char* fileName, Int_t type) const; virtual voidSelectDrawable(Int_t device); virtual voidSetFillColor(Color_t fcolor); virtual voidSetFillStyle(Style_t fstyle); virtual voidSetLineColor(Color_t lcolor); virtual voidSetLineStyle(Style_t lstyle); virtual voidSetLineWidth(Width_t lwidth); virtual voidSetOpacity(Int_t percent); virtual voidSetTextAlign(Short_t align = 11); virtual voidSetTextAngle(Float_t tangle = 0); virtual voidSetTextColor(Color_t tcolor = 1); virtual voidSetTextFont(Font_t tfont = 62); virtual voidSetTextSize(Float_t tsize = 1); virtual voidSetTextSizePixels(Int_t npixels); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; public:. enum EBoxMode { kHollow; kFilled; };; enum ETextMode { kClear; kOpaque; };. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TVirtualPadPainter(); Virtual dtor. void InitPainter(); Empty definition. void InvalidateCS(); Empty definition. void LockPainter(); Empty definition. TVirtualPadPainter * PadPainter(Option_t* opt = """"); Create a pad painter of specified type. Color_t GetLineColor() const; Line attributes to be set up in TPad. Style_t GetLineStyle() const. Width_t GetLineWidth() const. void SetLineColor(Color_t lcolor). void SetLineStyle(Style_t lstyle). void SetLineWidth(Width_t lwidth). Color_t GetFillColor() const; Fill attributes to be set up in TPad. Style_t GetFillStyle() const. Bool_t IsTransparent() const. void SetFillColor(Color_t fcolor). void SetFillStyle(Style_t fstyle). void SetOpacity(Int_t percent). Short_t GetTextAlign() const; Text attributes. Float_t GetTextAngle() const. Color_t GetTextColor() const. Font_t GetTextFont() const. Float_t GetTextSize() const. Float_t GetTextMagnitude() const. void SetTextAlign(Short_t align = 11). void",MatchSource.WIKI,root/html532/TVirtualPadPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPadPainter.html
https://root.cern/root/html532/TVirtualPadPainter.html:3220,Modifiability,Inherit,Inherited,3220,"nter&operator=(const TVirtualPadPainter&); static TVirtualPadPainter*PadPainter(Option_t* opt = """"); virtual voidSaveImage(TVirtualPad* pad, const char* fileName, Int_t type) const; virtual voidSelectDrawable(Int_t device); virtual voidSetFillColor(Color_t fcolor); virtual voidSetFillStyle(Style_t fstyle); virtual voidSetLineColor(Color_t lcolor); virtual voidSetLineStyle(Style_t lstyle); virtual voidSetLineWidth(Width_t lwidth); virtual voidSetOpacity(Int_t percent); virtual voidSetTextAlign(Short_t align = 11); virtual voidSetTextAngle(Float_t tangle = 0); virtual voidSetTextColor(Color_t tcolor = 1); virtual voidSetTextFont(Font_t tfont = 62); virtual voidSetTextSize(Float_t tsize = 1); virtual voidSetTextSizePixels(Int_t npixels); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; public:. enum EBoxMode { kHollow; kFilled; };; enum ETextMode { kClear; kOpaque; };. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TVirtualPadPainter(); Virtual dtor. void InitPainter(); Empty definition. void InvalidateCS(); Empty definition. void LockPainter(); Empty definition. TVirtualPadPainter * PadPainter(Option_t* opt = """"); Create a pad painter of specified type. Color_t GetLineColor() const; Line attributes to be set up in TPad. Style_t GetLineStyle() const. Width_t GetLineWidth() const. void SetLineColor(Color_t lcolor). void SetLineStyle(Style_t lstyle). void SetLineWidth(Width_t lwidth). Color_t GetFillColor() const; Fill attributes to be set up in TPad. Style_t GetFillStyle() const. Bool_t IsTransparent() const. void SetFillColor(Color_t fcolor). void SetFillStyle(Style_t fstyle). void SetOpacity(Int_t percent). Short_t GetTextAlign() const; Text attributes. Float_t GetTextAngle() const. Color_t GetTextColor() const. Font_t GetTextFont() const. Float_t GetTextSize() const. Float_t GetTextMagnitude() const. void SetTextAlign(Short_t align = 11). void",MatchSource.WIKI,root/html532/TVirtualPadPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPadPainter.html
https://root.cern/root/html532/TVirtualPadPainter.html:4613,Usability,Clear,ClearDrawable,4613,") const. Width_t GetLineWidth() const. void SetLineColor(Color_t lcolor). void SetLineStyle(Style_t lstyle). void SetLineWidth(Width_t lwidth). Color_t GetFillColor() const; Fill attributes to be set up in TPad. Style_t GetFillStyle() const. Bool_t IsTransparent() const. void SetFillColor(Color_t fcolor). void SetFillStyle(Style_t fstyle). void SetOpacity(Int_t percent). Short_t GetTextAlign() const; Text attributes. Float_t GetTextAngle() const. Color_t GetTextColor() const. Font_t GetTextFont() const. Float_t GetTextSize() const. Float_t GetTextMagnitude() const. void SetTextAlign(Short_t align = 11). void SetTextAngle(Float_t tangle = 0). void SetTextColor(Color_t tcolor = 1). void SetTextFont(Font_t tfont = 62). void SetTextSize(Float_t tsize = 1). void SetTextSizePixels(Int_t npixels). Int_t CreateDrawable(UInt_t w, UInt_t h); This part is an interface to X11 pixmap management and to save sub-pads off-screens for OpenGL.; Currently, must be implemented only for X11/GDI. void ClearDrawable(). void CopyDrawable(Int_t device, Int_t px, Int_t py). void DestroyDrawable(). void SelectDrawable(Int_t device). These functions are not required by X11/GDI. void DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Now, drawing primitives. void DrawLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2). void DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, TVirtualPadPainter::EBoxMode mode). void DrawFillArea(Int_t n, const Double_t* x, const Double_t* y). void DrawFillArea(Int_t n, const Float_t* x, const Float_t* y). void DrawPolyLine(Int_t n, const Double_t* x, const Double_t* y). void DrawPolyLine(Int_t n, const Float_t* x, const Float_t* y). void DrawPolyLineNDC(Int_t n, const Double_t* u, const Double_t* v). void DrawPolyMarker(Int_t n, const Double_t* x, const Double_t* y). void DrawPolyMarker(Int_t n, const Float_t* x, const Float_t* y). void DrawText(Double_t x, Double_t y, const char* text, TVirtualPadPainter::ETextMode mode). void DrawTex",MatchSource.WIKI,root/html532/TVirtualPadPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPadPainter.html
https://root.cern/root/html532/TVirtualPerfStats.html:554,Availability,avail,available,554,". TVirtualPerfStats. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualPerfStats. class TVirtualPerfStats: public TObject. TVirtualPerfStats. Provides the interface for the PROOF internal performance measurment; and event tracing. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualPerfStats(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; static const char*EventType(TVirtualPerfStats::EEventType type); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFileEvent(const char* slave, const char* slavename, const char* nodename, const char* filename, Bool_t isStart); virtual voidFileOpenEvent(TFile* file, const",MatchSource.WIKI,root/html532/TVirtualPerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPerfStats.html
https://root.cern/root/html532/TVirtualPerfStats.html:1400,Availability,Error,Error,1400," virtual~TVirtualPerfStats(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; static const char*EventType(TVirtualPerfStats::EEventType type); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFileEvent(const char* slave, const char* slavename, const char* nodename, const char* filename, Bool_t isStart); virtual voidFileOpenEvent(TFile* file, const",MatchSource.WIKI,root/html532/TVirtualPerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPerfStats.html
https://root.cern/root/html532/TVirtualPerfStats.html:1594,Availability,error,error,1594,"VirtualPerfStats(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; static const char*EventType(TVirtualPerfStats::EEventType type); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFileEvent(const char* slave, const char* slavename, const char* nodename, const char* filename, Bool_t isStart); virtual voidFileOpenEvent(TFile* file, const char* filename, Double_t start); virtual voidFileReadEvent(TFile* file, Int_t len, Double_t start); virtual voidFileUnzipEvent(TFile* file, Long64_t pos, Double_t start, Int_t complen, Int_t objlen); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Long64_tGetBytesRead() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual Long64_tGetNumEvents() const; virtual char*TO",MatchSource.WIKI,root/html532/TVirtualPerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPerfStats.html
https://root.cern/root/html532/TVirtualPerfStats.html:1678,Availability,error,error,1678,"oidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; static const char*EventType(TVirtualPerfStats::EEventType type); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFileEvent(const char* slave, const char* slavename, const char* nodename, const char* filename, Bool_t isStart); virtual voidFileOpenEvent(TFile* file, const char* filename, Double_t start); virtual voidFileReadEvent(TFile* file, Int_t len, Double_t start); virtual voidFileUnzipEvent(TFile* file, Long64_t pos, Double_t start, Int_t complen, Int_t objlen); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Long64_tGetBytesRead() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual Long64_tGetNumEvents() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(",MatchSource.WIKI,root/html532/TVirtualPerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPerfStats.html
https://root.cern/root/html532/TVirtualPerfStats.html:344,Integrability,interface,interface,344,". TVirtualPerfStats. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualPerfStats. class TVirtualPerfStats: public TObject. TVirtualPerfStats. Provides the interface for the PROOF internal performance measurment; and event tracing. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualPerfStats(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; static const char*EventType(TVirtualPerfStats::EEventType type); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFileEvent(const char* slave, const char* slavename, const char* nodename, const char* filename, Bool_t isStart); virtual voidFileOpenEvent(TFile* file, const",MatchSource.WIKI,root/html532/TVirtualPerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPerfStats.html
https://root.cern/root/html532/TVirtualPerfStats.html:3004,Modifiability,Inherit,InheritsFrom,3004,"lename, Double_t start); virtual voidFileReadEvent(TFile* file, Int_t len, Double_t start); virtual voidFileUnzipEvent(TFile* file, Long64_t pos, Double_t start, Int_t complen, Int_t objlen); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Long64_tGetBytesRead() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual Long64_tGetNumEvents() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TOb",MatchSource.WIKI,root/html532/TVirtualPerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPerfStats.html
https://root.cern/root/html532/TVirtualPerfStats.html:3070,Modifiability,Inherit,InheritsFrom,3070,"t_t len, Double_t start); virtual voidFileUnzipEvent(TFile* file, Long64_t pos, Double_t start, Int_t complen, Int_t objlen); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Long64_tGetBytesRead() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual Long64_tGetNumEvents() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TVirtualPerfStats&opera",MatchSource.WIKI,root/html532/TVirtualPerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPerfStats.html
https://root.cern/root/html532/TVirtualPerfStats.html:6362,Modifiability,Inherit,Inheritance,6362,"ect::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum EEventType { kUnDefined; kPacket; kStart; kStop; kFile; kFileOpen; kFileRead; kRate; kNumEventType; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const char * EventType(TVirtualPerfStats::EEventType type); Return the name of the event type. virtual ~TVirtualPerfStats(); {}. void SimpleEvent(TVirtualPerfStats::EEventType type). void PacketEvent(const char* slave, const char* slavename, const char* filename, Long64_t eventsprocessed, Double_t latency, Double_t proctime, Double_t cputime, Long64_t bytesRead). void FileOpenEvent(TFile* file, const char* filename, Double_t start). void FileReadEvent(TFile* file, Int_t len, Double_t start). void FileUnzipEvent(TFile* file, Long64_t pos, Double_t start, Int_t complen, Int_t objlen). void RateEvent(Double_t proctime, Double_t deltatime, Long64_t eventsprocessed, Long64_t bytesRead). Long64_t GetBytesRead() const. void SetNumEvents(Long64_t num). Long64_t GetNumEvents() const. » Author: Kristjan Gulbrandsen 11/05/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TVirtualPerfStats.h 38055 2011-",MatchSource.WIKI,root/html532/TVirtualPerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPerfStats.html
https://root.cern/root/html532/TVirtualPerfStats.html:6375,Modifiability,Inherit,Inherited,6375,"ect::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum EEventType { kUnDefined; kPacket; kStart; kStop; kFile; kFileOpen; kFileRead; kRate; kNumEventType; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const char * EventType(TVirtualPerfStats::EEventType type); Return the name of the event type. virtual ~TVirtualPerfStats(); {}. void SimpleEvent(TVirtualPerfStats::EEventType type). void PacketEvent(const char* slave, const char* slavename, const char* filename, Long64_t eventsprocessed, Double_t latency, Double_t proctime, Double_t cputime, Long64_t bytesRead). void FileOpenEvent(TFile* file, const char* filename, Double_t start). void FileReadEvent(TFile* file, Int_t len, Double_t start). void FileUnzipEvent(TFile* file, Long64_t pos, Double_t start, Int_t complen, Int_t objlen). void RateEvent(Double_t proctime, Double_t deltatime, Long64_t eventsprocessed, Long64_t bytesRead). Long64_t GetBytesRead() const. void SetNumEvents(Long64_t num). Long64_t GetNumEvents() const. » Author: Kristjan Gulbrandsen 11/05/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TVirtualPerfStats.h 38055 2011-",MatchSource.WIKI,root/html532/TVirtualPerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPerfStats.html
https://root.cern/root/html532/TVirtualPerfStats.html:377,Performance,perform,performance,377,". TVirtualPerfStats. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualPerfStats. class TVirtualPerfStats: public TObject. TVirtualPerfStats. Provides the interface for the PROOF internal performance measurment; and event tracing. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualPerfStats(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; static const char*EventType(TVirtualPerfStats::EEventType type); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFileEvent(const char* slave, const char* slavename, const char* nodename, const char* filename, Bool_t isStart); virtual voidFileOpenEvent(TFile* file, const",MatchSource.WIKI,root/html532/TVirtualPerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPerfStats.html
https://root.cern/root/html532/TVirtualPerfStats.html:4232,Performance,latency,latency,4232,"IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TVirtualPerfStats&operator=(const TVirtualPerfStats&); virtual voidPacketEvent(const char* slave, const char* slavename, const char* filename, Long64_t eventsprocessed, Double_t latency, Double_t proctime, Double_t cputime, Long64_t bytesRead); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidRateEvent(Double_t proctime, Double_t deltatime, Long64_t eventsprocessed, Long64_t bytesRead); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetBytesRead(Long64_t num); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetNumEvents(Long64_t num); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& i",MatchSource.WIKI,root/html532/TVirtualPerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPerfStats.html
https://root.cern/root/html532/TVirtualPerfStats.html:6738,Performance,latency,latency,6738,"har* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum EEventType { kUnDefined; kPacket; kStart; kStop; kFile; kFileOpen; kFileRead; kRate; kNumEventType; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const char * EventType(TVirtualPerfStats::EEventType type); Return the name of the event type. virtual ~TVirtualPerfStats(); {}. void SimpleEvent(TVirtualPerfStats::EEventType type). void PacketEvent(const char* slave, const char* slavename, const char* filename, Long64_t eventsprocessed, Double_t latency, Double_t proctime, Double_t cputime, Long64_t bytesRead). void FileOpenEvent(TFile* file, const char* filename, Double_t start). void FileReadEvent(TFile* file, Int_t len, Double_t start). void FileUnzipEvent(TFile* file, Long64_t pos, Double_t start, Int_t complen, Int_t objlen). void RateEvent(Double_t proctime, Double_t deltatime, Long64_t eventsprocessed, Long64_t bytesRead). Long64_t GetBytesRead() const. void SetNumEvents(Long64_t num). Long64_t GetNumEvents() const. » Author: Kristjan Gulbrandsen 11/05/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TVirtualPerfStats.h 38055 2011-02-11 22:06:25Z pcanal $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TVirtualPerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPerfStats.html
https://root.cern/root/html532/TVirtualPerfStats.html:2894,Security,Hash,Hash,2894,"const char* nodename, const char* filename, Bool_t isStart); virtual voidFileOpenEvent(TFile* file, const char* filename, Double_t start); virtual voidFileReadEvent(TFile* file, Int_t len, Double_t start); virtual voidFileUnzipEvent(TFile* file, Long64_t pos, Double_t start, Int_t complen, Int_t objlen); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Long64_tGetBytesRead() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual Long64_tGetNumEvents() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator ",MatchSource.WIKI,root/html532/TVirtualPerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPerfStats.html
https://root.cern/root/html532/TVirtualPerfStats.html:5463,Testability,Test,TestBit,5463,"dTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TVirtualPerfStats&operator=(const TVirtualPerfStats&); virtual voidPacketEvent(const char* slave, const char* slavename, const char* filename, Long64_t eventsprocessed, Double_t latency, Double_t proctime, Double_t cputime, Long64_t bytesRead); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidRateEvent(Double_t proctime, Double_t deltatime, Long64_t eventsprocessed, Long64_t bytesRead); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetBytesRead(Long64_t num); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetNumEvents(Long64_t num); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidSimpleEvent(TVirtualPerfStats::EEventType type); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TVirtualPerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPerfStats.html
https://root.cern/root/html532/TVirtualPerfStats.html:5502,Testability,Test,TestBits,5502,"dTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TVirtualPerfStats&operator=(const TVirtualPerfStats&); virtual voidPacketEvent(const char* slave, const char* slavename, const char* filename, Long64_t eventsprocessed, Double_t latency, Double_t proctime, Double_t cputime, Long64_t bytesRead); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidRateEvent(Double_t proctime, Double_t deltatime, Long64_t eventsprocessed, Long64_t bytesRead); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetBytesRead(Long64_t num); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetNumEvents(Long64_t num); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidSimpleEvent(TVirtualPerfStats::EEventType type); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TVirtualPerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPerfStats.html
https://root.cern/root/html532/TVirtualPerfStats.html:860,Usability,Clear,Clear,860," virtual~TVirtualPerfStats(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; static const char*EventType(TVirtualPerfStats::EEventType type); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFileEvent(const char* slave, const char* slavename, const char* nodename, const char* filename, Bool_t isStart); virtual voidFileOpenEvent(TFile* file, const",MatchSource.WIKI,root/html532/TVirtualPerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPerfStats.html
https://root.cern/root/html532/TVirtualPerfStats.html:6573,Usability,Simpl,SimpleEvent,6573,"ng(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum EEventType { kUnDefined; kPacket; kStart; kStop; kFile; kFileOpen; kFileRead; kRate; kNumEventType; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const char * EventType(TVirtualPerfStats::EEventType type); Return the name of the event type. virtual ~TVirtualPerfStats(); {}. void SimpleEvent(TVirtualPerfStats::EEventType type). void PacketEvent(const char* slave, const char* slavename, const char* filename, Long64_t eventsprocessed, Double_t latency, Double_t proctime, Double_t cputime, Long64_t bytesRead). void FileOpenEvent(TFile* file, const char* filename, Double_t start). void FileReadEvent(TFile* file, Int_t len, Double_t start). void FileUnzipEvent(TFile* file, Long64_t pos, Double_t start, Int_t complen, Int_t objlen). void RateEvent(Double_t proctime, Double_t deltatime, Long64_t eventsprocessed, Long64_t bytesRead). Long64_t GetBytesRead() const. void SetNumEvents(Long64_t num). Long64_t GetNumEvents() const. » Author: Kristjan Gulbrandsen 11/05/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TVirtualPerfStats.h 38055 2011-02-11 22:06:25Z pcanal $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT",MatchSource.WIKI,root/html532/TVirtualPerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPerfStats.html
https://root.cern/root/html532/TVirtualProofPlayer.html:576,Availability,avail,available,576,". TVirtualProofPlayer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOF; » TVirtualProofPlayer. class TVirtualProofPlayer: public TObject, public TQObject. TVirtualProofPlayer. Abstract interface for the PROOF player.; See the concrete implementations under 'proofplayer' for details. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualProofPlayer(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddEventsProcessed(Long64_t ev); virtual voidAddInput(TObject* inp); virtual voidAddOutput(TList* out); virtual Int_tAddOutputObject(TObject* obj); virtual voidAddQueryResult(TQueryResult* q); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual voidClearInput(); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual void",MatchSource.WIKI,root/html532/TVirtualProofPlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualProofPlayer.html
https://root.cern/root/html532/TVirtualProofPlayer.html:4144,Availability,Error,Error,4144,"(const char* signal); voidTQObject::Emit(const char* signal, Long_t* paramArr); voidTQObject::Emit(const char* signal, const char* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFeedback(TList* objs)SIGNAL ; virtual Long64_tFinalize(TQueryResult* qr); virtual Long64_tFinalize(Bool_t force = kFALSE, Bool_t sync = kFALSE); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Long64_tGetCacheSize(); virtual TQueryResult*GetCurrentQuery() const; virtual Int_tGetDrawArgs(const char* var, const char* sel, Option_t* opt, TString& selector, TString& objname); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetEventsProcessed() const; virtual TVirtualProofPlayer::EExitS",MatchSource.WIKI,root/html532/TVirtualProofPlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualProofPlayer.html
https://root.cern/root/html532/TVirtualProofPlayer.html:4273,Availability,error,error,4273,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFeedback(TList* objs)SIGNAL ; virtual Long64_tFinalize(TQueryResult* qr); virtual Long64_tFinalize(Bool_t force = kFALSE, Bool_t sync = kFALSE); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Long64_tGetCacheSize(); virtual TQueryResult*GetCurrentQuery() const; virtual Int_tGetDrawArgs(const char* var, const char* sel, Option_t* opt, TString& selector, TString& objname); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetEventsProcessed() const; virtual TVirtualProofPlayer::EExitStatusGetExitStatus() const; virtual const char*TObject::GetIconName() const; virtual TList*GetInputList() const; virtual Int_tGet",MatchSource.WIKI,root/html532/TVirtualProofPlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualProofPlayer.html
https://root.cern/root/html532/TVirtualProofPlayer.html:4357,Availability,error,error,4357,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFeedback(TList* objs)SIGNAL ; virtual Long64_tFinalize(TQueryResult* qr); virtual Long64_tFinalize(Bool_t force = kFALSE, Bool_t sync = kFALSE); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Long64_tGetCacheSize(); virtual TQueryResult*GetCurrentQuery() const; virtual Int_tGetDrawArgs(const char* var, const char* sel, Option_t* opt, TString& selector, TString& objname); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetEventsProcessed() const; virtual TVirtualProofPlayer::EExitStatusGetExitStatus() const; virtual const char*TObject::GetIconName() const; virtual TList*GetInputList() const; virtual Int_tGetLearnEntries(); TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetLi",MatchSource.WIKI,root/html532/TVirtualProofPlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualProofPlayer.html
https://root.cern/root/html532/TVirtualProofPlayer.html:13748,Deployability,Update,UpdateAutoBin,13748,"Result* q). TQueryResult * GetCurrentQuery() const. TQueryResult * GetQueryResult(const char* ref). void RemoveQueryResult(const char* ref). void SetCurrentQuery(TQueryResult* q). void SetMaxDrawQueries(Int_t max). void RestorePreviousQuery(). Int_t AddOutputObject(TObject* obj). void AddOutput(TList* out). void StoreOutput(TList* out). void StoreFeedback(TObject* slave, TList* out). void Progress(Long64_t total, Long64_t processed). void Progress(TSlave* , Long64_t total, Long64_t processed). void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti). void Progress(TProofProgressInfo* ). void Progress(TSlave* , TProofProgressInfo* ). void Feedback(TList* objs). TDrawFeedback * CreateDrawFeedback(TProof* p). void SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt). void DeleteDrawFeedback(TDrawFeedback* f). TDSetElement * GetNextPacket(TSlave* slave, TMessage* r). Int_t ReinitSelector(TQueryResult* qr). void UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax). Bool_t IsClient() const. EExitStatus GetExitStatus() const. Long64_t GetEventsProcessed() const. void AddEventsProcessed(Long64_t ev). TProofProgressStatus* GetProgressStatus() const. void SetDispatchTimer(Bool_t on = kTRUE). void SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0). Long64_t GetCacheSize(). Int_t GetLearnEntries(). TVirtualPacketizer * GetPacketizer() const; { return 0; }. TVirtualProofPlayer * Create(const char* player, TProof* p, TSocket* s = 0). » Author: Fons Rademakers 15/03/07 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id: TVirtualProofPlayer.h 39171 2011-05-12 16:21:17Z ganis $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TVirtualProofPlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualProofPlayer.html
https://root.cern/root/html532/TVirtualProofPlayer.html:343,Integrability,interface,interface,343,". TVirtualProofPlayer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOF; » TVirtualProofPlayer. class TVirtualProofPlayer: public TObject, public TQObject. TVirtualProofPlayer. Abstract interface for the PROOF player.; See the concrete implementations under 'proofplayer' for details. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualProofPlayer(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddEventsProcessed(Long64_t ev); virtual voidAddInput(TObject* inp); virtual voidAddOutput(TList* out); virtual Int_tAddOutputObject(TObject* obj); virtual voidAddQueryResult(TQueryResult* q); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual voidClearInput(); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual void",MatchSource.WIKI,root/html532/TVirtualProofPlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualProofPlayer.html
https://root.cern/root/html532/TVirtualProofPlayer.html:7225,Integrability,Message,Message,7225,":HasConnection(const char* signal_name) const; virtual ULong_tTObject::Hash() const; virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tIsClient() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; static voidTQObject::LoadRQ_OBJECT(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidMergeOutput(); virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TObject&TObject::operator=(const TObject& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Long64_tProcess(TDSet* set, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); virtual voidProgress(TProof",MatchSource.WIKI,root/html532/TVirtualProofPlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualProofPlayer.html
https://root.cern/root/html532/TVirtualProofPlayer.html:6498,Modifiability,Inherit,InheritsFrom,6498," const; virtual TDSetElement*GetNextPacket(TSlave* slave, TMessage* r); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TObject*GetOutput(const char* name) const; virtual TList*GetOutputList() const; virtual TVirtualPacketizer*GetPacketizer() const; virtual TProofProgressStatus*GetProgressStatus() const; virtual TQueryResult*GetQueryResult(const char* ref); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual voidHandleGetTreeHeader(TMessage* mess); virtual voidHandleRecvHisto(TMessage* mess); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTObject::Hash() const; virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tIsClient() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; static voidTQObject::LoadRQ_OBJECT(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidMergeOutput(); virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTOb",MatchSource.WIKI,root/html532/TVirtualProofPlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualProofPlayer.html
https://root.cern/root/html532/TVirtualProofPlayer.html:6564,Modifiability,Inherit,InheritsFrom,6564,"* r); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TObject*GetOutput(const char* name) const; virtual TList*GetOutputList() const; virtual TVirtualPacketizer*GetPacketizer() const; virtual TProofProgressStatus*GetProgressStatus() const; virtual TQueryResult*GetQueryResult(const char* ref); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual voidHandleGetTreeHeader(TMessage* mess); virtual voidHandleRecvHisto(TMessage* mess); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTObject::Hash() const; virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tIsClient() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; static voidTQObject::LoadRQ_OBJECT(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidMergeOutput(); virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator del",MatchSource.WIKI,root/html532/TVirtualProofPlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualProofPlayer.html
https://root.cern/root/html532/TVirtualProofPlayer.html:11976,Modifiability,Inherit,Inheritance,11976,"ar* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTObject::MakeZombie(). Data Members; public:. enum EStatusBits { kIsSubmerger; };; enum EExitStatus { kFinished; kStopped; kAborted; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualProofPlayer(); { }. Long64_t Process(TDSet* set, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0). Long64_t Finalize(TQueryResult* qr). Long64_t DrawSelect(TDSet* set, const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0). void HandleGetTreeHeader(TMessage* mess). void HandleRecvHisto(TMessage* mess). void StopProcess(Bool_t abort, Int_t timeout = -1). void AddInput(TObject* inp). void ClearInput(). TObject * GetOutput(const char* name) const. TList * GetOutputList() const. TList * GetInputList() const. TList * GetListOfResults() const. void AddQueryResult(TQueryResult* q). TQueryResult * GetCurrentQuery() const. TQueryResult * GetQueryResult(const char* ref). void RemoveQueryResult(const char* ref). void SetCurrentQuery(TQueryResult* q). void SetMaxDrawQueries(Int_t max). void RestorePreviousQuery(). Int_t AddOutp",MatchSource.WIKI,root/html532/TVirtualProofPlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualProofPlayer.html
https://root.cern/root/html532/TVirtualProofPlayer.html:11989,Modifiability,Inherit,Inherited,11989,"ar* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTObject::MakeZombie(). Data Members; public:. enum EStatusBits { kIsSubmerger; };; enum EExitStatus { kFinished; kStopped; kAborted; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualProofPlayer(); { }. Long64_t Process(TDSet* set, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0). Long64_t Finalize(TQueryResult* qr). Long64_t DrawSelect(TDSet* set, const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0). void HandleGetTreeHeader(TMessage* mess). void HandleRecvHisto(TMessage* mess). void StopProcess(Bool_t abort, Int_t timeout = -1). void AddInput(TObject* inp). void ClearInput(). TObject * GetOutput(const char* name) const. TList * GetOutputList() const. TList * GetInputList() const. TList * GetListOfResults() const. void AddQueryResult(TQueryResult* q). TQueryResult * GetCurrentQuery() const. TQueryResult * GetQueryResult(const char* ref). void RemoveQueryResult(const char* ref). void SetCurrentQuery(TQueryResult* q). void SetMaxDrawQueries(Int_t max). void RestorePreviousQuery(). Int_t AddOutp",MatchSource.WIKI,root/html532/TVirtualProofPlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualProofPlayer.html
https://root.cern/root/html532/TVirtualProofPlayer.html:9694,Safety,abort,abort,9694,"l, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti)SIGNAL ; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tReinitSelector(TQueryResult* qr); virtual voidRemoveQueryResult(const char* ref); voidTObject::ResetBit(UInt_t f); virtual voidRestorePreviousQuery(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetCurrentQuery(TQueryResult* q); virtual voidSetDispatchTimer(Bool_t on = kTRUE); virtual voidSetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetInitTime(); virtual voidSetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidStoreOutput(TList* out); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TVirtualProofPlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualProofPlayer.html
https://root.cern/root/html532/TVirtualProofPlayer.html:9716,Safety,timeout,timeout,9716,"l, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti)SIGNAL ; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tReinitSelector(TQueryResult* qr); virtual voidRemoveQueryResult(const char* ref); voidTObject::ResetBit(UInt_t f); virtual voidRestorePreviousQuery(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetCurrentQuery(TQueryResult* q); virtual voidSetDispatchTimer(Bool_t on = kTRUE); virtual voidSetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetInitTime(); virtual voidSetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidStoreOutput(TList* out); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TVirtualProofPlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualProofPlayer.html
https://root.cern/root/html532/TVirtualProofPlayer.html:9856,Safety,abort,abort,9856,"l, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti)SIGNAL ; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tReinitSelector(TQueryResult* qr); virtual voidRemoveQueryResult(const char* ref); voidTObject::ResetBit(UInt_t f); virtual voidRestorePreviousQuery(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetCurrentQuery(TQueryResult* q); virtual voidSetDispatchTimer(Bool_t on = kTRUE); virtual voidSetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetInitTime(); virtual voidSetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidStoreOutput(TList* out); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TVirtualProofPlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualProofPlayer.html
https://root.cern/root/html532/TVirtualProofPlayer.html:9869,Safety,timeout,timeout,9869,"l, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti)SIGNAL ; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tReinitSelector(TQueryResult* qr); virtual voidRemoveQueryResult(const char* ref); voidTObject::ResetBit(UInt_t f); virtual voidRestorePreviousQuery(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetCurrentQuery(TQueryResult* q); virtual voidSetDispatchTimer(Bool_t on = kTRUE); virtual voidSetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetInitTime(); virtual voidSetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidStoreOutput(TList* out); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TVirtualProofPlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualProofPlayer.html
https://root.cern/root/html532/TVirtualProofPlayer.html:12503,Safety,abort,abort,12503,"Pick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualProofPlayer(); { }. Long64_t Process(TDSet* set, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0). Long64_t Finalize(TQueryResult* qr). Long64_t DrawSelect(TDSet* set, const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0). void HandleGetTreeHeader(TMessage* mess). void HandleRecvHisto(TMessage* mess). void StopProcess(Bool_t abort, Int_t timeout = -1). void AddInput(TObject* inp). void ClearInput(). TObject * GetOutput(const char* name) const. TList * GetOutputList() const. TList * GetInputList() const. TList * GetListOfResults() const. void AddQueryResult(TQueryResult* q). TQueryResult * GetCurrentQuery() const. TQueryResult * GetQueryResult(const char* ref). void RemoveQueryResult(const char* ref). void SetCurrentQuery(TQueryResult* q). void SetMaxDrawQueries(Int_t max). void RestorePreviousQuery(). Int_t AddOutputObject(TObject* obj). void AddOutput(TList* out). void StoreOutput(TList* out). void StoreFeedback(TObject* slave, TList* out). void Progress(Long64_t total, Long64_t processed). void Progress(TSlave* , Long64_t total, Long64_t processed). void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti). void Progress(TProofProgressInfo* ). void Progress(TSlave* , TProofProgressInfo* ). void Feedback(TList* objs). TDrawFeedb",MatchSource.WIKI,root/html532/TVirtualProofPlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualProofPlayer.html
https://root.cern/root/html532/TVirtualProofPlayer.html:12516,Safety,timeout,timeout,12516,"Pick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualProofPlayer(); { }. Long64_t Process(TDSet* set, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0). Long64_t Finalize(TQueryResult* qr). Long64_t DrawSelect(TDSet* set, const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0). void HandleGetTreeHeader(TMessage* mess). void HandleRecvHisto(TMessage* mess). void StopProcess(Bool_t abort, Int_t timeout = -1). void AddInput(TObject* inp). void ClearInput(). TObject * GetOutput(const char* name) const. TList * GetOutputList() const. TList * GetInputList() const. TList * GetListOfResults() const. void AddQueryResult(TQueryResult* q). TQueryResult * GetCurrentQuery() const. TQueryResult * GetQueryResult(const char* ref). void RemoveQueryResult(const char* ref). void SetCurrentQuery(TQueryResult* q). void SetMaxDrawQueries(Int_t max). void RestorePreviousQuery(). Int_t AddOutputObject(TObject* obj). void AddOutput(TList* out). void StoreOutput(TList* out). void StoreFeedback(TObject* slave, TList* out). void Progress(Long64_t total, Long64_t processed). void Progress(TSlave* , Long64_t total, Long64_t processed). void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti). void Progress(TProofProgressInfo* ). void Progress(TSlave* , TProofProgressInfo* ). void Feedback(TList* objs). TDrawFeedb",MatchSource.WIKI,root/html532/TVirtualProofPlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualProofPlayer.html
https://root.cern/root/html532/TVirtualProofPlayer.html:14147,Safety,abort,abort,14147,"Result* q). TQueryResult * GetCurrentQuery() const. TQueryResult * GetQueryResult(const char* ref). void RemoveQueryResult(const char* ref). void SetCurrentQuery(TQueryResult* q). void SetMaxDrawQueries(Int_t max). void RestorePreviousQuery(). Int_t AddOutputObject(TObject* obj). void AddOutput(TList* out). void StoreOutput(TList* out). void StoreFeedback(TObject* slave, TList* out). void Progress(Long64_t total, Long64_t processed). void Progress(TSlave* , Long64_t total, Long64_t processed). void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti). void Progress(TProofProgressInfo* ). void Progress(TSlave* , TProofProgressInfo* ). void Feedback(TList* objs). TDrawFeedback * CreateDrawFeedback(TProof* p). void SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt). void DeleteDrawFeedback(TDrawFeedback* f). TDSetElement * GetNextPacket(TSlave* slave, TMessage* r). Int_t ReinitSelector(TQueryResult* qr). void UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax). Bool_t IsClient() const. EExitStatus GetExitStatus() const. Long64_t GetEventsProcessed() const. void AddEventsProcessed(Long64_t ev). TProofProgressStatus* GetProgressStatus() const. void SetDispatchTimer(Bool_t on = kTRUE). void SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0). Long64_t GetCacheSize(). Int_t GetLearnEntries(). TVirtualPacketizer * GetPacketizer() const; { return 0; }. TVirtualProofPlayer * Create(const char* player, TProof* p, TSocket* s = 0). » Author: Fons Rademakers 15/03/07 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id: TVirtualProofPlayer.h 39171 2011-05-12 16:21:17Z ganis $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TVirtualProofPlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualProofPlayer.html
https://root.cern/root/html532/TVirtualProofPlayer.html:14169,Safety,timeout,timeout,14169,"Result* q). TQueryResult * GetCurrentQuery() const. TQueryResult * GetQueryResult(const char* ref). void RemoveQueryResult(const char* ref). void SetCurrentQuery(TQueryResult* q). void SetMaxDrawQueries(Int_t max). void RestorePreviousQuery(). Int_t AddOutputObject(TObject* obj). void AddOutput(TList* out). void StoreOutput(TList* out). void StoreFeedback(TObject* slave, TList* out). void Progress(Long64_t total, Long64_t processed). void Progress(TSlave* , Long64_t total, Long64_t processed). void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti). void Progress(TProofProgressInfo* ). void Progress(TSlave* , TProofProgressInfo* ). void Feedback(TList* objs). TDrawFeedback * CreateDrawFeedback(TProof* p). void SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt). void DeleteDrawFeedback(TDrawFeedback* f). TDSetElement * GetNextPacket(TSlave* slave, TMessage* r). Int_t ReinitSelector(TQueryResult* qr). void UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax). Bool_t IsClient() const. EExitStatus GetExitStatus() const. Long64_t GetEventsProcessed() const. void AddEventsProcessed(Long64_t ev). TProofProgressStatus* GetProgressStatus() const. void SetDispatchTimer(Bool_t on = kTRUE). void SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0). Long64_t GetCacheSize(). Int_t GetLearnEntries(). TVirtualPacketizer * GetPacketizer() const; { return 0; }. TVirtualProofPlayer * Create(const char* player, TProof* p, TSocket* s = 0). » Author: Fons Rademakers 15/03/07 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id: TVirtualProofPlayer.h 39171 2011-05-12 16:21:17Z ganis $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TVirtualProofPlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualProofPlayer.html
https://root.cern/root/html532/TVirtualProofPlayer.html:6300,Security,Hash,Hash,6300,"ject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; virtual TList*GetListOfResults() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virtual TDSetElement*GetNextPacket(TSlave* slave, TMessage* r); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TObject*GetOutput(const char* name) const; virtual TList*GetOutputList() const; virtual TVirtualPacketizer*GetPacketizer() const; virtual TProofProgressStatus*GetProgressStatus() const; virtual TQueryResult*GetQueryResult(const char* ref); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual voidHandleGetTreeHeader(TMessage* mess); virtual voidHandleRecvHisto(TMessage* mess); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTObject::Hash() const; virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tIsClient() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; static voidTQObject::LoadRQ_OBJECT(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidMergeOutput(); virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual Bool_tTObject::Notify(); virtual Int_",MatchSource.WIKI,root/html532/TVirtualProofPlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualProofPlayer.html
https://root.cern/root/html532/TVirtualProofPlayer.html:10136,Testability,Test,TestBit,10136,"l, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti)SIGNAL ; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tReinitSelector(TQueryResult* qr); virtual voidRemoveQueryResult(const char* ref); voidTObject::ResetBit(UInt_t f); virtual voidRestorePreviousQuery(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetCurrentQuery(TQueryResult* q); virtual voidSetDispatchTimer(Bool_t on = kTRUE); virtual voidSetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetInitTime(); virtual voidSetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidStoreOutput(TList* out); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TVirtualProofPlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualProofPlayer.html
https://root.cern/root/html532/TVirtualProofPlayer.html:10175,Testability,Test,TestBits,10175,"l, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti)SIGNAL ; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tReinitSelector(TQueryResult* qr); virtual voidRemoveQueryResult(const char* ref); voidTObject::ResetBit(UInt_t f); virtual voidRestorePreviousQuery(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetCurrentQuery(TQueryResult* q); virtual voidSetDispatchTimer(Bool_t on = kTRUE); virtual voidSetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetInitTime(); virtual voidSetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidStoreOutput(TList* out); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html532/TVirtualProofPlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualProofPlayer.html
https://root.cern/root/html532/TVirtualProofPlayer.html:1329,Usability,Clear,Clear,1329," virtual~TVirtualProofPlayer(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddEventsProcessed(Long64_t ev); virtual voidAddInput(TObject* inp); virtual voidAddOutput(TList* out); virtual Int_tAddOutputObject(TObject* obj); virtual voidAddQueryResult(TQueryResult* q); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual voidClearInput(); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual void",MatchSource.WIKI,root/html532/TVirtualProofPlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualProofPlayer.html
https://root.cern/root/html532/TVirtualProofPlayer.html:12565,Usability,Clear,ClearInput,12565,"] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualProofPlayer(); { }. Long64_t Process(TDSet* set, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0). Long64_t Finalize(TQueryResult* qr). Long64_t DrawSelect(TDSet* set, const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0). void HandleGetTreeHeader(TMessage* mess). void HandleRecvHisto(TMessage* mess). void StopProcess(Bool_t abort, Int_t timeout = -1). void AddInput(TObject* inp). void ClearInput(). TObject * GetOutput(const char* name) const. TList * GetOutputList() const. TList * GetInputList() const. TList * GetListOfResults() const. void AddQueryResult(TQueryResult* q). TQueryResult * GetCurrentQuery() const. TQueryResult * GetQueryResult(const char* ref). void RemoveQueryResult(const char* ref). void SetCurrentQuery(TQueryResult* q). void SetMaxDrawQueries(Int_t max). void RestorePreviousQuery(). Int_t AddOutputObject(TObject* obj). void AddOutput(TList* out). void StoreOutput(TList* out). void StoreFeedback(TObject* slave, TList* out). void Progress(Long64_t total, Long64_t processed). void Progress(TSlave* , Long64_t total, Long64_t processed). void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti). void Progress(TProofProgressInfo* ). void Progress(TSlave* , TProofProgressInfo* ). void Feedback(TList* objs). TDrawFeedback * CreateDrawFeedback(TProof* p). void SetDrawFeedbackOption(T",MatchSource.WIKI,root/html532/TVirtualProofPlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualProofPlayer.html
https://root.cern/root/html532/TVirtualProofPlayer.html:13471,Usability,Feedback,Feedback,13471,"void StopProcess(Bool_t abort, Int_t timeout = -1). void AddInput(TObject* inp). void ClearInput(). TObject * GetOutput(const char* name) const. TList * GetOutputList() const. TList * GetInputList() const. TList * GetListOfResults() const. void AddQueryResult(TQueryResult* q). TQueryResult * GetCurrentQuery() const. TQueryResult * GetQueryResult(const char* ref). void RemoveQueryResult(const char* ref). void SetCurrentQuery(TQueryResult* q). void SetMaxDrawQueries(Int_t max). void RestorePreviousQuery(). Int_t AddOutputObject(TObject* obj). void AddOutput(TList* out). void StoreOutput(TList* out). void StoreFeedback(TObject* slave, TList* out). void Progress(Long64_t total, Long64_t processed). void Progress(TSlave* , Long64_t total, Long64_t processed). void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti). void Progress(TProofProgressInfo* ). void Progress(TSlave* , TProofProgressInfo* ). void Feedback(TList* objs). TDrawFeedback * CreateDrawFeedback(TProof* p). void SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt). void DeleteDrawFeedback(TDrawFeedback* f). TDSetElement * GetNextPacket(TSlave* slave, TMessage* r). Int_t ReinitSelector(TQueryResult* qr). void UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax). Bool_t IsClient() const. EExitStatus GetExitStatus() const. Long64_t GetEventsProcessed() const. void AddEventsProcessed(Long64_t ev). TProofProgressStatus* GetProgressStatus() const. void SetDispatchTimer(Bool_t on = kTRUE). void SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0). Long64_t GetCacheSize(). Int_t GetLearnEntries(). TVirtualPacketizer * GetPacketizer() const; { return 0; }. TVirtualProofPlayer * Create(const char* player, TProof* p, TSocket* s = 0). » Author: Fons Rademakers 15/03/07 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed",MatchSource.WIKI,root/html532/TVirtualProofPlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualProofPlayer.html
https://root.cern/root/html532/TVirtualPS.html:568,Availability,avail,available,568,". TVirtualPS. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualPS. class TVirtualPS: public TNamed, public TAttLine, public TAttFill, public TAttMarker, public TAttText. TVirtualPS is an abstract interface to a Postscript, PDF and SVG drivers. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualPS(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidCellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); virtual voidCellArrayEnd(); virtual voidCellArrayFill(Int_t r, Int_t g, Int_t b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidDrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawFrame(Double_t xl, Double_t yl, Double_t xt, Double_t yt, Int_t mode, Int_t border, Int_t dark, Int_t light); virtual voidDrawPolyMarker(Int_t n, Float_t* x, Float_t* y); virtual voidDrawPolyMarker(Int_t n, Double_t* x, Double_t* y); virt",MatchSource.WIKI,root/html532/TVirtualPS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPS.html
https://root.cern/root/html532/TVirtualPS.html:2170,Availability,Error,Error,2170,"""""); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidDrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawFrame(Double_t xl, Double_t yl, Double_t xt, Double_t yt, Int_t mode, Int_t border, Int_t dark, Int_t light); virtual voidDrawPolyMarker(Int_t n, Float_t* x, Float_t* y); virtual voidDrawPolyMarker(Int_t n, Double_t* x, Double_t* y); virtual voidDrawPS(Int_t n, Float_t* xw, Float_t* yw); virtual voidDrawPS(Int_t n, Double_t* xw, Double_t* yw); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() co",MatchSource.WIKI,root/html532/TVirtualPS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPS.html
https://root.cern/root/html532/TVirtualPS.html:2299,Availability,error,error,2299,":Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidDrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawFrame(Double_t xl, Double_t yl, Double_t xt, Double_t yt, Int_t mode, Int_t border, Int_t dark, Int_t light); virtual voidDrawPolyMarker(Int_t n, Float_t* x, Float_t* y); virtual voidDrawPolyMarker(Int_t n, Double_t* x, Double_t* y); virtual voidDrawPS(Int_t n, Float_t* xw, Float_t* yw); virtual voidDrawPS(Int_t n, Double_t* xw, Double_t* yw); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObje",MatchSource.WIKI,root/html532/TVirtualPS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPS.html
https://root.cern/root/html532/TVirtualPS.html:2383,Availability,error,error,2383,"y, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidDrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawFrame(Double_t xl, Double_t yl, Double_t xt, Double_t yt, Int_t mode, Int_t border, Int_t dark, Int_t light); virtual voidDrawPolyMarker(Int_t n, Float_t* x, Float_t* y); virtual voidDrawPolyMarker(Int_t n, Double_t* x, Double_t* y); virtual voidDrawPS(Int_t n, Float_t* xw, Float_t* yw); virtual voidDrawPS(Int_t n, Double_t* xw, Double_t* yw); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Opt",MatchSource.WIKI,root/html532/TVirtualPS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPS.html
https://root.cern/root/html532/TVirtualPS.html:386,Integrability,interface,interface,386,". TVirtualPS. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualPS. class TVirtualPS: public TNamed, public TAttLine, public TAttFill, public TAttMarker, public TAttText. TVirtualPS is an abstract interface to a Postscript, PDF and SVG drivers. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualPS(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidCellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); virtual voidCellArrayEnd(); virtual voidCellArrayFill(Int_t r, Int_t g, Int_t b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidDrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawFrame(Double_t xl, Double_t yl, Double_t xt, Double_t yt, Int_t mode, Int_t border, Int_t dark, Int_t light); virtual voidDrawPolyMarker(Int_t n, Float_t* x, Float_t* y); virtual voidDrawPolyMarker(Int_t n, Double_t* x, Double_t* y); virt",MatchSource.WIKI,root/html532/TVirtualPS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPS.html
https://root.cern/root/html532/TVirtualPS.html:3987,Modifiability,Inherit,InheritsFrom,3987,"tyle_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual void*GetStream() const; virtual Short_tTAttText::GetTextAlign() const; virtual Float_tTAttText::GetTextAngle() const; virtual Color_tTAttText::GetTextColor() const; virtual Font_tTAttText::GetTextFont() const; virtual Float_tTAttText::GetTextSize() const; virtual const char*TNamed::GetTitle() const; virtual Int_tGetType() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttLine::Modify(); virtual voidNewPage(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual voidOpen(const char* filename, Int_t type = -111); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](",MatchSource.WIKI,root/html532/TVirtualPS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPS.html
https://root.cern/root/html532/TVirtualPS.html:4053,Modifiability,Inherit,InheritsFrom,4053,"LineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual void*GetStream() const; virtual Short_tTAttText::GetTextAlign() const; virtual Float_tTAttText::GetTextAngle() const; virtual Color_tTAttText::GetTextColor() const; virtual Font_tTAttText::GetTextFont() const; virtual Float_tTAttText::GetTextSize() const; virtual const char*TNamed::GetTitle() const; virtual Int_tGetType() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttLine::Modify(); virtual voidNewPage(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual voidOpen(const char* filename, Int_t type = -111); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*",MatchSource.WIKI,root/html532/TVirtualPS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPS.html
https://root.cern/root/html532/TVirtualPS.html:10237,Modifiability,Inherit,Inheritance,10237,"Key; kOverwrite; kWriteDelete; };. protected:. char*fBufferFile buffer; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; const char*fImplicitCREscEscape symbol before enforced new line; Int_tfLenBufferBuffer length; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tfNByteNumber of bytes written in the file (PDF); TStringTNamed::fNameobject identifier; Bool_tfPrintedTrue when a page must be printed; Int_tfSizBufferBuffer size; ofstream*fStreamFile stream identifier; Short_tTAttText::fTextAlignText alignment; Float_tTAttText::fTextAngleText angle; Color_tTAttText::fTextColorText color index; Font_tTAttText::fTextFontText font number; Float_tTAttText::fTextSizeText size; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TVirtualPS(); VirtualPS destructor. void PrintStr(const char* string = """"); Output the string str in the output buffer. void PrintFast(Int_t nch, const char* string = """"); Fast version of Print. void WriteInteger(Int_t i, Bool_t space = kTRUE); Write one Integer to the file. n: Integer to be written in the file.; space: If TRUE, a space in written before the integer. void WriteReal(Float_t r); Write a Real number to the file. TVirtualPS& operator=(const TVirtualPS& ). void CellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2). void CellArrayFill(Int_t r, Int_t g, Int_t b). void CellArrayEnd(). void Close(Option_t* opt = """"). void DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2). void DrawFrame(Double_t xl, Double_t yl, Double_t xt, Double_t yt, Int_t mode, Int_t border, Int_t dark, Int_t light). void DrawPolyMarker(Int_t n, Double_t* x, Double_t* y). void DrawPS(Int_t n, Float_t* xw, Float_t* ",MatchSource.WIKI,root/html532/TVirtualPS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPS.html
https://root.cern/root/html532/TVirtualPS.html:10250,Modifiability,Inherit,Inherited,10250,"Key; kOverwrite; kWriteDelete; };. protected:. char*fBufferFile buffer; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; const char*fImplicitCREscEscape symbol before enforced new line; Int_tfLenBufferBuffer length; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tfNByteNumber of bytes written in the file (PDF); TStringTNamed::fNameobject identifier; Bool_tfPrintedTrue when a page must be printed; Int_tfSizBufferBuffer size; ofstream*fStreamFile stream identifier; Short_tTAttText::fTextAlignText alignment; Float_tTAttText::fTextAngleText angle; Color_tTAttText::fTextColorText color index; Font_tTAttText::fTextFontText font number; Float_tTAttText::fTextSizeText size; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TVirtualPS(); VirtualPS destructor. void PrintStr(const char* string = """"); Output the string str in the output buffer. void PrintFast(Int_t nch, const char* string = """"); Fast version of Print. void WriteInteger(Int_t i, Bool_t space = kTRUE); Write one Integer to the file. n: Integer to be written in the file.; space: If TRUE, a space in written before the integer. void WriteReal(Float_t r); Write a Real number to the file. TVirtualPS& operator=(const TVirtualPS& ). void CellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2). void CellArrayFill(Int_t r, Int_t g, Int_t b). void CellArrayEnd(). void Close(Option_t* opt = """"). void DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2). void DrawFrame(Double_t xl, Double_t yl, Double_t xt, Double_t yt, Int_t mode, Int_t border, Int_t dark, Int_t light). void DrawPolyMarker(Int_t n, Double_t* x, Double_t* y). void DrawPS(Int_t n, Float_t* xw, Float_t* ",MatchSource.WIKI,root/html532/TVirtualPS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPS.html
https://root.cern/root/html532/TVirtualPS.html:3877,Security,Hash,Hash,3877,") const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual void*GetStream() const; virtual Short_tTAttText::GetTextAlign() const; virtual Float_tTAttText::GetTextAngle() const; virtual Color_tTAttText::GetTextColor() const; virtual Font_tTAttText::GetTextFont() const; virtual Float_tTAttText::GetTextSize() const; virtual const char*TNamed::GetTitle() const; virtual Int_tGetType() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttLine::Modify(); virtual voidNewPage(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual voidOpen(const char* filename, Int_t type = -111); static voidTObject::operator delete(void* ptr); static voidTObject::operator del",MatchSource.WIKI,root/html532/TVirtualPS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPS.html
https://root.cern/root/html532/TVirtualPS.html:8317,Testability,Test,TestBit,8317,"olor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidTAttMarker::SetMarkerAttributes()MENU ; virtual voidTAttMarker::SetMarkerColor(Color_t tcolor = 1); virtual voidTAttMarker::SetMarkerSize(Size_t msize = 1); virtual voidTAttMarker::SetMarkerStyle(Style_t mstyle = 1); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetStream(ofstream* os); virtual voidTAttText::SetTextAlign(Short_t align = 11); virtual voidTAttText::SetTextAngle(Float_t tangle = 0)MENU ; virtual voidTAttText::SetTextAttributes()MENU ; virtual voidTAttText::SetTextColor(Color_t tcolor = 1); virtual voidTAttText::SetTextFont(Font_t tfont = 62); virtual voidTAttText::SetTextSize(Float_t tsize = 1); virtual voidTAttText::SetTextSizePixels(Int_t npixels); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidSetType(Int_t = -111); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidText(Double_t x, Double_t y, const char* string); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidWriteInteger(Int_t i, Bool_t space = kTRUE); virtual voidWriteReal(Float_t r).",MatchSource.WIKI,root/html532/TVirtualPS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPS.html
https://root.cern/root/html532/TVirtualPS.html:8356,Testability,Test,TestBits,8356,"olor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidTAttMarker::SetMarkerAttributes()MENU ; virtual voidTAttMarker::SetMarkerColor(Color_t tcolor = 1); virtual voidTAttMarker::SetMarkerSize(Size_t msize = 1); virtual voidTAttMarker::SetMarkerStyle(Style_t mstyle = 1); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetStream(ofstream* os); virtual voidTAttText::SetTextAlign(Short_t align = 11); virtual voidTAttText::SetTextAngle(Float_t tangle = 0)MENU ; virtual voidTAttText::SetTextAttributes()MENU ; virtual voidTAttText::SetTextColor(Color_t tcolor = 1); virtual voidTAttText::SetTextFont(Font_t tfont = 62); virtual voidTAttText::SetTextSize(Float_t tsize = 1); virtual voidTAttText::SetTextSizePixels(Int_t npixels); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidSetType(Int_t = -111); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidText(Double_t x, Double_t y, const char* string); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidWriteInteger(Int_t i, Bool_t space = kTRUE); virtual voidWriteReal(Float_t r).",MatchSource.WIKI,root/html532/TVirtualPS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPS.html
https://root.cern/root/html532/TVirtualPS.html:1046,Usability,Clear,Clear,1046," virtual~TVirtualPS(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidCellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); virtual voidCellArrayEnd(); virtual voidCellArrayFill(Int_t r, Int_t g, Int_t b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidDrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawFrame(Double_t xl, Double_t yl, Double_t xt, Double_t yt, Int_t mode, Int_t border, Int_t dark, Int_t light); virtual voidDrawPolyMarker(Int_t n, Float_t* x, Float_t* y); virtual voidDrawPolyMarker(Int_t n, Double_t* x, Double_t* y); virt",MatchSource.WIKI,root/html532/TVirtualPS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualPS.html
https://root.cern/root/html532/TVirtualStreamerInfo.html:567,Availability,avail,available,567,". TVirtualStreamerInfo. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TVirtualStreamerInfo. class TVirtualStreamerInfo: public TNamed. TVirtualStreamerInfo Abstract Interface class. Abstract Interface describing Streamer information for one class. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualStreamerInfo(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidBuild(); virtual voidBuildCheck(); virtual voidBuildEmulated(TFile* file); virtual Bool_tBuildFor(const TClass* cl); virtual voidBuildOld(); virtual voidCallShowMembers(void* obj, TMemberInspector& insp) const; static Bool_tCanDelete(); static Bool_tCanOptimize(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t*); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Bool_tCompareContent(TClass* cl, TVirtualStreamerInfo* info, Bool_t warn, Bool_t complete); virtual voidCompile(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteArray(void* p, Bool_t dtorOnly = kFALSE); virtual voidDestructor(void* p, Bool_t dtorOnly = kFALSE); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(co",MatchSource.WIKI,root/html532/TVirtualStreamerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualStreamerInfo.html
https://root.cern/root/html532/TVirtualStreamerInfo.html:1917,Availability,Error,Error,1917,"l voidBuildOld(); virtual voidCallShowMembers(void* obj, TMemberInspector& insp) const; static Bool_tCanDelete(); static Bool_tCanOptimize(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t*); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Bool_tCompareContent(TClass* cl, TVirtualStreamerInfo* info, Bool_t warn, Bool_t complete); virtual voidCompile(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteArray(void* p, Bool_t dtorOnly = kFALSE); virtual voidDestructor(void* p, Bool_t dtorOnly = kFALSE); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); static TVirtualStreamerInfo*Factory(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidForceWriteInfo(TFile* file, Bool_t force = kFALSE); virtual TClassStreamer*GenEmulatedClassStreamer(const char* class_name, Bool_t silent); virtual TVirtualCollectionProxy*GenEmulatedProxy(const char* class_name, Bool_t silent); virtual Int_tGenerateHeaderFile(const char* dirname, const TList* subClasses = 0, const TList* extrainfos = 0); virtual TClassStreamer*GenExplicitClassStreamer(const ROOT::TCollectionPr",MatchSource.WIKI,root/html532/TVirtualStreamerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualStreamerInfo.html
https://root.cern/root/html532/TVirtualStreamerInfo.html:2046,Availability,error,error,2046,"nOptimize(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t*); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Bool_tCompareContent(TClass* cl, TVirtualStreamerInfo* info, Bool_t warn, Bool_t complete); virtual voidCompile(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteArray(void* p, Bool_t dtorOnly = kFALSE); virtual voidDestructor(void* p, Bool_t dtorOnly = kFALSE); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); static TVirtualStreamerInfo*Factory(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidForceWriteInfo(TFile* file, Bool_t force = kFALSE); virtual TClassStreamer*GenEmulatedClassStreamer(const char* class_name, Bool_t silent); virtual TVirtualCollectionProxy*GenEmulatedProxy(const char* class_name, Bool_t silent); virtual Int_tGenerateHeaderFile(const char* dirname, const TList* subClasses = 0, const TList* extrainfos = 0); virtual TClassStreamer*GenExplicitClassStreamer(const ROOT::TCollectionProxyInfo& info, TClass* cl); virtual TVirtualCollectionProxy*GenExplicitProxy(const ROOT::TCollectionProxyInfo& info, TClass* cl);",MatchSource.WIKI,root/html532/TVirtualStreamerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualStreamerInfo.html
https://root.cern/root/html532/TVirtualStreamerInfo.html:2130,Availability,error,error,2130,"irtual voidClear(Option_t*); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Bool_tCompareContent(TClass* cl, TVirtualStreamerInfo* info, Bool_t warn, Bool_t complete); virtual voidCompile(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteArray(void* p, Bool_t dtorOnly = kFALSE); virtual voidDestructor(void* p, Bool_t dtorOnly = kFALSE); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); static TVirtualStreamerInfo*Factory(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidForceWriteInfo(TFile* file, Bool_t force = kFALSE); virtual TClassStreamer*GenEmulatedClassStreamer(const char* class_name, Bool_t silent); virtual TVirtualCollectionProxy*GenEmulatedProxy(const char* class_name, Bool_t silent); virtual Int_tGenerateHeaderFile(const char* dirname, const TList* subClasses = 0, const TList* extrainfos = 0); virtual TClassStreamer*GenExplicitClassStreamer(const ROOT::TCollectionProxyInfo& info, TClass* cl); virtual TVirtualCollectionProxy*GenExplicitProxy(const ROOT::TCollectionProxyInfo& info, TClass* cl); virtual TClass*GetActualClass(const void* obj) const; virtual UInt_tGetCheckSum() c",MatchSource.WIKI,root/html532/TVirtualStreamerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualStreamerInfo.html
https://root.cern/root/html532/TVirtualStreamerInfo.html:12835,Deployability,Update,Update,12835,"Info(TFile* file, Bool_t force = kFALSE). Int_t GenerateHeaderFile(const char* dirname, const TList* subClasses = 0, const TList* extrainfos = 0). TClass * GetActualClass(const void* obj) const. TClass * GetClass() const. UInt_t GetCheckSum() const. Int_t GetClassVersion() const. ULong_t * GetElems() const. TObjArray * GetElements() const. Int_t GetOffset(const char* ) const. Int_t * GetOffsets() const. Version_t GetOldVersion() const. Int_t GetOnFileClassVersion() const. Int_t GetNumber() const. Int_t GetSize() const. TStreamerElement * GetStreamerElement(const char* datamember, Int_t& offset) const. Bool_t IsBuilt() const; { return fIsBuilt; }. Bool_t IsCompiled() const; { return TestBit(kIsCompiled); }. Bool_t IsOptimized() const; { return fOptimized; }. Int_t IsRecovered() const; { return TestBit(kRecovered); }. void ls(Option_t* option = """") const. TVirtualStreamerInfo * NewInfo(TClass* cl). void * New(void* obj = 0). void * NewArray(Long_t nElements, void* ary = 0). void Destructor(void* p, Bool_t dtorOnly = kFALSE). void DeleteArray(void* p, Bool_t dtorOnly = kFALSE). void SetCheckSum(UInt_t checksum). void SetClass(TClass* cl). void SetClassVersion(Int_t vers). void TagFile(TFile* fFile). void Update(const TClass* oldClass, TClass* newClass). TVirtualCollectionProxy * GenEmulatedProxy(const char* class_name, Bool_t silent). TClassStreamer * GenEmulatedClassStreamer(const char* class_name, Bool_t silent). TVirtualCollectionProxy * GenExplicitProxy(const ROOT::TCollectionProxyInfo& info, TClass* cl). TClassStreamer * GenExplicitClassStreamer(const ROOT::TCollectionProxyInfo& info, TClass* cl). » Author: Rene Brun 05/02/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: TVirtualStreamerInfo.h 41102 2011-10-03 21:42:02Z pcanal $ » Last generated: 2011-12-02 14:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html532/TVirtualStreamerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualStreamerInfo.html
https://root.cern/root/html532/TVirtualStreamerInfo.html:350,Integrability,Interface,Interface,350,". TVirtualStreamerInfo. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TVirtualStreamerInfo. class TVirtualStreamerInfo: public TNamed. TVirtualStreamerInfo Abstract Interface class. Abstract Interface describing Streamer information for one class. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualStreamerInfo(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidBuild(); virtual voidBuildCheck(); virtual voidBuildEmulated(TFile* file); virtual Bool_tBuildFor(const TClass* cl); virtual voidBuildOld(); virtual voidCallShowMembers(void* obj, TMemberInspector& insp) const; static Bool_tCanDelete(); static Bool_tCanOptimize(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t*); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Bool_tCompareContent(TClass* cl, TVirtualStreamerInfo* info, Bool_t warn, Bool_t complete); virtual voidCompile(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteArray(void* p, Bool_t dtorOnly = kFALSE); virtual voidDestructor(void* p, Bool_t dtorOnly = kFALSE); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(co",MatchSource.WIKI,root/html532/TVirtualStreamerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualStreamerInfo.html
https://root.cern/root/html532/TVirtualStreamerInfo.html:376,Integrability,Interface,Interface,376,". TVirtualStreamerInfo. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TVirtualStreamerInfo. class TVirtualStreamerInfo: public TNamed. TVirtualStreamerInfo Abstract Interface class. Abstract Interface describing Streamer information for one class. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualStreamerInfo(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidBuild(); virtual voidBuildCheck(); virtual voidBuildEmulated(TFile* file); virtual Bool_tBuildFor(const TClass* cl); virtual voidBuildOld(); virtual voidCallShowMembers(void* obj, TMemberInspector& insp) const; static Bool_tCanDelete(); static Bool_tCanOptimize(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t*); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Bool_tCompareContent(TClass* cl, TVirtualStreamerInfo* info, Bool_t warn, Bool_t complete); virtual voidCompile(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteArray(void* p, Bool_t dtorOnly = kFALSE); virtual voidDestructor(void* p, Bool_t dtorOnly = kFALSE); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(co",MatchSource.WIKI,root/html532/TVirtualStreamerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualStreamerInfo.html
https://root.cern/root/html532/TVirtualStreamerInfo.html:4311,Modifiability,Inherit,InheritsFrom,4311,"Type*GetElementCounter(const char* countName, TClass* cl); virtual TObjArray*GetElements() const; virtual ULong_t*GetElems() const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual Int_tGetNumber() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Int_tGetOffset(const char*) const; virtual Int_t*GetOffsets() const; virtual Version_tGetOldVersion() const; virtual Int_tGetOnFileClassVersion() const; virtual Option_t*TObject::GetOption() const; virtual Int_tGetSize() const; virtual TStreamerElement*GetStreamerElement(const char* datamember, Int_t& offset) const; static Bool_tGetStreamMemberWise(); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tIsBuilt() const; Bool_tIsCompiled() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tIsOptimized() const; Int_tIsRecovered() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual void*New(void* obj = 0); virtual void*NewArray(Long_t nElements, void* ary = 0); virtual TVirtualStreamerInfo*NewInfo(TClass* cl); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObje",MatchSource.WIKI,root/html532/TVirtualStreamerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualStreamerInfo.html
https://root.cern/root/html532/TVirtualStreamerInfo.html:4377,Modifiability,Inherit,InheritsFrom,4377," TObjArray*GetElements() const; virtual ULong_t*GetElems() const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual Int_tGetNumber() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Int_tGetOffset(const char*) const; virtual Int_t*GetOffsets() const; virtual Version_tGetOldVersion() const; virtual Int_tGetOnFileClassVersion() const; virtual Option_t*TObject::GetOption() const; virtual Int_tGetSize() const; virtual TStreamerElement*GetStreamerElement(const char* datamember, Int_t& offset) const; static Bool_tGetStreamMemberWise(); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tIsBuilt() const; Bool_tIsCompiled() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tIsOptimized() const; Int_tIsRecovered() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual void*New(void* obj = 0); virtual void*NewArray(Long_t nElements, void* ary = 0); virtual TVirtualStreamerInfo*NewInfo(TClass* cl); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator del",MatchSource.WIKI,root/html532/TVirtualStreamerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualStreamerInfo.html
https://root.cern/root/html532/TVirtualStreamerInfo.html:8977,Modifiability,Inherit,Inheritance,8977,"16; kObject; kAny; kObjectp; kObjectP; kTString; kTObject; kTNamed; kAnyp; kAnyP; kAnyPnoVT; kSTLp; kSkip; kSkipL; kSkipP; kConv; kConvL; kConvP; kSTL; kSTLstring; kStreamer; kStreamLoop; kCache; kArtificial; kCacheNew; kCacheDelete; kMissing; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfIsBuilt! true if the StreamerInfo has been 'built'; TStringTNamed::fNameobject identifier; Bool_tfOptimized! true if the Streamer has been optimized; TStringTNamed::fTitleobject title; static Bool_tfgCanDeleteTrue if ReadBuffer can delete object; static TVirtualStreamerInfo*fgInfoFactory; static Bool_tfgOptimizeTrue if optimization on; static Bool_tfgStreamMemberWiseTrue if the collections are to be stream ""member-wise"" (when possible). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualStreamerInfo& operator=(const TVirtualStreamerInfo& ); assignment operator. ~TVirtualStreamerInfo(); Destructor. Bool_t CanDelete(); static function returning true if ReadBuffer can delete object. Bool_t CanOptimize(); static function returning true if optimization can be on. TStreamerBasicType * GetElementCounter(const char* countName, TClass* cl); Get pointer to a TStreamerBasicType in TClass *cl; static function. Bool_t GetStreamMemberWise(); Return whether the TStreamerInfos will save the collections in; ""member-wise"" order whenever possible. The default is to store member-wise.; kTRUE indicates member-wise storing; kFALSE inddicates object-wise storing. A collection can be saved member wise when it contain is guaranteed to be; homogeneous. For example std::vector<THit> can be stored member wise,; while std::vector<THit*> can not (possible use of polymorphism). void Optimize(Bool_t opt = kTRUE); This is a static function.; ",MatchSource.WIKI,root/html532/TVirtualStreamerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html532/TVirtualStreamerInfo.html
